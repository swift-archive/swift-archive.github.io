<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>-Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160122/b6dec2ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br>This is a nice rule in theory, but English fights it with the full fury of its irregularity. There are a lot of common operations whose past tense shares a spelling with the infinitive—&#39;split&#39;, &#39;cut&#39;, &#39;read&#39;, and &#39;cast&#39; immediately come to mind. How do you handle naming non-mutating versions of these operations? Conjugating other irregular verbs also imposes a barrier on developers whose first language is not English.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/9a7780b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How do you handle naming non-mutating versions of these operations? Conjugating other irregular verbs also imposes a barrier on developers whose first language is not English.<br></p><p>Swift could use “after” as a prefix, or something similar.<br></p><p>array.sort()<br>array.afterSort()<br></p><p>I was tempted to say “afterSorting()” but that has the same problems mentioned above.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/05101914/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 1:57 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How do you handle naming non-mutating versions of these operations? Conjugating other irregular verbs also imposes a barrier on developers whose first language is not English.<br>&gt; <br>&gt; Swift could use “after” as a prefix, or something similar.<br>&gt; <br>&gt; array.sort()<br>&gt; array.afterSort()<br>&gt; <br>&gt; I was tempted to say “afterSorting()” but that has the same problems mentioned above.<br></p><p>That&#39;s reminiscent of the way the classic Cocoa naming guidelines cleverly avoided these issues by using the &#39;did-&#39; prefix consistently instead of ever conjugating verbs into preterite tense. &#39;after&#39; is a bit awkward, though, as are any other equivalent prefixes i can think of that have the same effect on the past participle (havingSplit? bySplitting?)<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/79c6f7ef/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>January 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Text is not enough to represent whether function are adjectives or verbs. By distinguishing between adjectives (nonmutating) and verbs (mutating) functions, with metadata, we will also be able to settle when to enforce self. <br></p><p>When a function is a mutating verb (i.e. when self. really means “self, &quot;), self. reads redundantly.<br>When a function is an adjective (i.e. when self. means “me, &quot;), it doesn’t read well if self. is not used.<br></p><p>sort(…)<br>self.sorted(…)<br></p><p>append(…)<br>self.appended(with …)<br></p><p>split(using: …)<br>self.split(by: …)<br></p><p>cut(…)<br>self.cut(by: …)<br></p><p>Sometimes, “self.” means “I”, but I don’t believe those cases are relevant to this thread.<br></p><p><br>&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br>&gt; This is a nice rule in theory, but English fights it with the full fury of its irregularity. There are a lot of common operations whose past tense shares a spelling with the infinitive—&#39;split&#39;, &#39;cut&#39;, &#39;read&#39;, and &#39;cast&#39; immediately come to mind. How do you handle naming non-mutating versions of these operations? Conjugating other irregular verbs also imposes a barrier on developers whose first language is not English.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/9f01e463/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/04e39d45455f95ce6dc18e918d18c2ad?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Thomas Visser</string> &lt;thomas.visser at gmail.com&gt;<p>January 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Uses of non-mutating methods should read as noun phrases when possible, e.g. x.distanceTo(y), i.successor().<br>&gt; <br></p><p>This seems to indicate (to me) that e.g. Optional.map and should be renamed to Optional.mapped? Except that ‘map’ in this case could be considered a ’term of art’. Would it make sense to add to add some kind of guidance on how to weigh the individual guidelines when they are conflicting?<br></p><p>Thomas<br></p><p>&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/32b35369/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Current:<br>Use imperative verb phrases for mutating methods: x.reverse(), x.sort(), x.tweak()<br>Use noun phrases for non-mutating methods: x.distanceTo(...), idx.successor()<br>Proposed:<br>Use verb phrases to declare procedural methods, whether or not they mutate an instance or just produce side effects: x.reverse(), x.sort(), x.tweak(), x.perform(), x.dispatch(), x.send()<br>Use noun phrases to describe values returned by a functional method: x.distanceTo(y), index.successor() (This admittedly leaves further issues around other functional methods, for example, seq.separatedBySequence(seq) and  int.strideTo(other: Self, step:Self.Stride), etc. )<br>I suggest that mutating methods are just a procedural method (side effect, no return value) vs functional.<br></p><p>-- E<br></p><p><br>&gt; On Jan 22, 2016, at 2:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/c1dc9b2c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>This review seems like a good time to bring up the proposal regarding naming conventions for conversion protocols: https://github.com/apple/swift-evolution/pull/60 &lt;https://github.com/apple/swift-evolution/pull/60&gt;.  Dave had mentioned having the standard library team discuss this as part of the API guidelines: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002798.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002798.html&gt;.  I’m wondering if the solution for this naming issue should continue as an independent proposal or be included as part of the the larger API Design Guidelines proposal.<br></p><p>-Matthew<br></p><p>&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/fa579987/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>-- E<br></p><p>&gt; On Jan 22, 2016, at 3:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This review seems like a good time to bring up the proposal regarding naming conventions for conversion protocols: https://github.com/apple/swift-evolution/pull/60 &lt;https://github.com/apple/swift-evolution/pull/60&gt;.  Dave had mentioned having the standard library team discuss this as part of the API guidelines: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002798.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002798.html&gt;.  I’m wondering if the solution for this naming issue should continue as an independent proposal or be included as part of the the larger API Design Guidelines proposal.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/d1cc5d63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February  1, 2016 at 12:00:00am</p></header><div class="content"><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br></p><p>What is your evaluation of the proposal?<br>+1<br></p><p>I read the guidelines and I like them a lot in general. I think they are a very good start. <br></p><p>I have read the alternatives and disagreements in the discussion threads.  However, in my opinion the guidelines still stand as the winner. I find it better, simpler, more concise and better looking than the alternatives discussed. <br></p><p>For example the ed/ ing ending for non-mutable methods. This is a convention I have used in java for a long time and I found it very natural in general even when the English language may not cooperate as it has been discussed by others. I got used to this convention very quickly many years ago in libraries I use in java. <br></p><p>There is only one guideline that I think is not aligned with the consensus I seem to pick up from the discussions. That is the use of camel case for enum cases. After reading different opinions I am now leaning towards saying that Enum cases should be lower camel case given that they are values.  At first my opinion was the same as the guideline. After reading the discussions and seeing examples I changed my mind. <br></p><p><br>Is the problem being addressed significant enough to warrant a change to Swift?<br>This will bring a lot of changes when applied. I think they are a good start. I don&#39;t think it should cover all cases. <br></p><p>I saw the loginWithUserName(_:password:) example and alternatives: login(userName:password:), etc. I don&#39;t know if this is addressed in the guidelines. I don&#39;t think this example falls under the weak type first argument.  It would be nice to have some guidance here. I do not know how to state it but I think in this case I would say login(userName:password:) is better as it could be part of a family of login() methods that take different parameters, i.e. credentials. <br></p><p>Does this proposal fit well with the feel and direction of Swift?<br>Definitely. I find the guidelines are concise, natural and easy to get used to. <br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I have used Java libraries for many years that use the ed ending for non-mutable methods for example. <br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I read the proposal entirely and I have read the majority of responses in the mailing list. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/4e112ec9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0acf75deb034e62d9e8c18c2d3680b54?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Michael Wells</string> &lt;michael at michaelwells.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>I’m a big fan of guidelines like these so count me as a strong +1.<br></p><p>In general<br></p><p>I’m supportive of lowerCamelCase for enumerations. <br>I’m still not sure about the first argument label suggestions. Personally, I’d prefer that the first argument always include a label, but I know that is not a popular opinion.<br>I continue to believe that property access implies (or at least strongly hints) at O(1)<br></p><p>WRT translation from ObjC to Swift a few things come to mind:<br>Import things like[UIColor blueColor] to Swift as UIColor.blue instead of UIColor.blueColor(). That is, things that feel like static properties on a class should be imported that way. <br>Are singleton accessors methods or properties? [NSNotificationCenter defaultCenter]imports as NSNotificationCenter.defaultCenter() or NSNotificationCenter.defaultCenter? <br>Group string encoding constants (and other constants like this) together in an enum or struct. I can never remember NSUTF8StringEncoding since I’m always looking for StringEncoding first.<br>I know this is out of scope for this review, but I’d love for the guidelines to go even further in defining canonical Swift. What about, dare I say it, brace locations, tab-vs-spaces, how to wrap func definitions within some column width max, etc? From the sample code it appears that Apple has adopted a Swift style and it might be nice to make that public. This public style guide would not be a decree of &quot;how one must write&quot; Swift, but more as a &quot;this is how the core team writes&quot; Swift. I’m one of those developers that has no strong preference for these issues, but I really do value consistency.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Most definitely.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes these guidelines makes a huge difference in how the language feels. It fits perfectly with the direction of Swift.<br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve been a big proponent of design guides in all of the languages I’ve used: C, C++, Java, C#, Objective C, and now Swift. I really appreciate where languages make opinionated decisions on how to write idiomatic code.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve read the proposals many times and I’ve been actively following this discussion.<br></p><p>&gt; On Jan 31, 2016, at 9:29 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; +1<br>&gt; <br>&gt; I read the guidelines and I like them a lot in general. I think they are a very good start. <br>&gt; <br>&gt; I have read the alternatives and disagreements in the discussion threads.  However, in my opinion the guidelines still stand as the winner. I find it better, simpler, more concise and better looking than the alternatives discussed. <br>&gt; <br>&gt; For example the ed/ ing ending for non-mutable methods. This is a convention I have used in java for a long time and I found it very natural in general even when the English language may not cooperate as it has been discussed by others. I got used to this convention very quickly many years ago in libraries I use in java. <br>&gt; <br>&gt; There is only one guideline that I think is not aligned with the consensus I seem to pick up from the discussions. That is the use of camel case for enum cases. After reading different opinions I am now leaning towards saying that Enum cases should be lower camel case given that they are values.  At first my opinion was the same as the guideline. After reading the discussions and seeing examples I changed my mind. <br>&gt; <br>&gt; <br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; This will bring a lot of changes when applied. I think they are a good start. I don&#39;t think it should cover all cases. <br>&gt; <br>&gt; I saw the loginWithUserName(_:password:) example and alternatives: login(userName:password:), etc. I don&#39;t know if this is addressed in the guidelines. I don&#39;t think this example falls under the weak type first argument.  It would be nice to have some guidance here. I do not know how to state it but I think in this case I would say login(userName:password:) is better as it could be part of a family of login() methods that take different parameters, i.e. credentials. <br>&gt; <br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; Definitely. I find the guidelines are concise, natural and easy to get used to. <br>&gt; <br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; I have used Java libraries for many years that use the ed ending for non-mutable methods for example. <br>&gt; <br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; I read the proposal entirely and I have read the majority of responses in the mailing list. <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/60074463/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 22, 2016 at 06:00:00pm</p></header><div class="content"><p>Under &quot;Follow case conventions&quot;, how should acronyms (like &quot;HTML&quot;) be<br>handled: HTMLElement or HtmlElement?<br></p><p>On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through<br>&gt; January 31, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/bce5053f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 3:59 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Under &quot;Follow case conventions&quot;, how should acronyms (like &quot;HTML&quot;) be handled: HTMLElement or HtmlElement?<br></p><p>I would certainly prefer the second style. Unless the acronym comes at the end of the identifier, it is more readable when only the first letter of the acronym is uppercase, IMO. Otherwise the acronym merges with the capitalized first letter of the following word.  <br></p><p>Using all caps for acronyms also doesn’t work very well at the start of a variable name, leading to:<br></p><p>var hTMLElement = HTMLElement()<br></p><p>versus:<br></p><p>var htmlElement = HtmlElement()<br></p><p>--CK<br></p><p>&gt; On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/522afb13/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 23, 2016 at 09:00:00am</p></header><div class="content"><p>I would definitely prefer the second style as well although maybe that&#39;s<br>just because I&#39;m used to it.<br></p><p>On Sat, Jan 23, 2016 at 12:34 AM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 22, 2016, at 3:59 PM, Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Under &quot;Follow case conventions&quot;, how should acronyms (like &quot;HTML&quot;) be<br>&gt; handled: HTMLElement or HtmlElement?<br>&gt;<br>&gt;<br>&gt; I would certainly prefer the second style. Unless the acronym comes at the<br>&gt; end of the identifier, it is more readable when only the first letter of<br>&gt; the acronym is uppercase, IMO. Otherwise the acronym merges with the<br>&gt; capitalized first letter of the following word.<br>&gt;<br>&gt; Using all caps for acronyms also doesn’t work very well at the start of a<br>&gt; variable name, leading to:<br>&gt;<br>&gt; var hTMLElement = HTMLElement()<br>&gt;<br>&gt; versus:<br>&gt;<br>&gt; var htmlElement = HtmlElement()<br>&gt;<br>&gt; --CK<br>&gt;<br>&gt; On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through<br>&gt;&gt; January 31, 2016. The proposal is available here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt;&gt; top of the message:<br>&gt;&gt;<br>&gt;&gt; Proposal link:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;<br>&gt;&gt; Reply text<br>&gt;&gt;<br>&gt;&gt; Other replies<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt; goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt; answer in your review:<br>&gt;&gt;<br>&gt;&gt;    - What is your evaluation of the proposal?<br>&gt;&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;&gt;    change to Swift?<br>&gt;&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;    - If you have used other languages or libraries with a similar<br>&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Doug Gregor<br>&gt;&gt;<br>&gt;&gt; Review Manager<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/aead37df/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 9:34 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 3:59 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Under &quot;Follow case conventions&quot;, how should acronyms (like &quot;HTML&quot;) be handled: HTMLElement or HtmlElement?<br>&gt; <br>&gt; I would certainly prefer the second style. Unless the acronym comes at the end of the identifier, it is more readable when only the first letter of the acronym is uppercase, IMO. Otherwise the acronym merges with the capitalized first letter of the following word.  <br>&gt; <br>&gt; Using all caps for acronyms also doesn’t work very well at the start of a variable name, leading to:<br>&gt; <br>&gt; var hTMLElement = HTMLElement()<br>&gt; <br>&gt; versus:<br>&gt; <br>&gt; var htmlElement = HtmlElement()<br></p><p>Interesting. For me, it feels like the acronym should should up in ALLCAPS or nocaps; never with just a Leadingcap. For example:<br></p><p>	var htmlElement = HTMLElement()<br></p><p>I find that this form keeps acronym feeling like an acronym, rather than looking like a strange (possibly abbreviated) word.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; --CK<br>&gt; <br>&gt;&gt; On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/4d655b55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 24, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 10:39 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 9:34 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 3:59 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under &quot;Follow case conventions&quot;, how should acronyms (like &quot;HTML&quot;) be handled: HTMLElement or HtmlElement?<br>&gt;&gt; <br>&gt;&gt; I would certainly prefer the second style. Unless the acronym comes at the end of the identifier, it is more readable when only the first letter of the acronym is uppercase, IMO. Otherwise the acronym merges with the capitalized first letter of the following word.  <br>&gt;&gt; <br>&gt;&gt; Using all caps for acronyms also doesn’t work very well at the start of a variable name, leading to:<br>&gt;&gt; <br>&gt;&gt; var hTMLElement = HTMLElement()<br>&gt;&gt; <br>&gt;&gt; versus:<br>&gt;&gt; <br>&gt;&gt; var htmlElement = HtmlElement()<br>&gt; <br>&gt; Interesting. For me, it feels like the acronym should should up in ALLCAPS or nocaps; never with just a Leadingcap. For example:<br>&gt; <br>&gt; 	var htmlElement = HTMLElement()<br>&gt; <br></p><p>I guess I just don’t like my function calls SHOUTing at me. :-)<br></p><p>The leading-caps-for-acronyms style might not be particularly popular. The most prominent use I’m aware of is in the .NET frameworks.<br></p><p>This discussion of acronyms does raise a different issue, though. I would suggest expanding the “Avoid abbreviations” section of the API Design Guidelines a bit to make a clear distinction between truncating words just to shorten identifiers (bad) and using common acronyms (good). You don’t want people thinking they’re being advised to do this:<br></p><p>var hyperTextMarkupLanguageElement = HyperTextMarkupLanguageElement()<br></p><p>&gt; I find that this form keeps acronym feeling like an acronym, rather than looking like a strange (possibly abbreviated) word.<br></p><p>But an acronym *is* a strange, abbreviated word. ;-)<br></p><p>—CK<br></p><p>&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; --CK<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/3be4bdad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 24, 2016 at 08:00:00am</p></header><div class="content"><p>I follow Doug&#39;s pattern. If it isn&#39;t written that way in the wild, I don&#39;t write it that way in my code. <br></p><p>So never:<br>  HtmlElement<br>  PngFile<br>  PdfFormat<br></p><p>I think those have a real disadvantage because you&#39;ve changed how those abbreviations are used. <br></p><p>-David<br></p><p>&gt; On Jan 24, 2016, at 12:51 AM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 10:39 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 9:34 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 3:59 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under &quot;Follow case conventions&quot;, how should acronyms (like &quot;HTML&quot;) be handled: HTMLElement or HtmlElement?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would certainly prefer the second style. Unless the acronym comes at the end of the identifier, it is more readable when only the first letter of the acronym is uppercase, IMO. Otherwise the acronym merges with the capitalized first letter of the following word.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using all caps for acronyms also doesn’t work very well at the start of a variable name, leading to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var hTMLElement = HTMLElement()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; versus:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var htmlElement = HtmlElement()<br>&gt;&gt; <br>&gt;&gt; Interesting. For me, it feels like the acronym should should up in ALLCAPS or nocaps; never with just a Leadingcap. For example:<br>&gt;&gt; <br>&gt;&gt; 	var htmlElement = HTMLElement()<br>&gt; <br>&gt; I guess I just don’t like my function calls SHOUTing at me. :-)<br>&gt; <br>&gt; The leading-caps-for-acronyms style might not be particularly popular. The most prominent use I’m aware of is in the .NET frameworks.<br>&gt; <br>&gt; This discussion of acronyms does raise a different issue, though. I would suggest expanding the “Avoid abbreviations” section of the API Design Guidelines a bit to make a clear distinction between truncating words just to shorten identifiers (bad) and using common acronyms (good). You don’t want people thinking they’re being advised to do this:<br>&gt; <br>&gt; var hyperTextMarkupLanguageElement = HyperTextMarkupLanguageElement()<br>&gt; <br>&gt;&gt; I find that this form keeps acronym feeling like an acronym, rather than looking like a strange (possibly abbreviated) word.<br>&gt; <br>&gt; But an acronym *is* a strange, abbreviated word. ;-)<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --CK<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/b75132a3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 24, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; This discussion of acronyms does raise a different issue, though. I would suggest expanding the “Avoid abbreviations” section of the API Design Guidelines a bit to make a clear distinction between truncating words just to shorten identifiers (bad) and using common acronyms (good). You don’t want people thinking they’re being advised to do this:<br>&gt; <br>&gt; var hyperTextMarkupLanguageElement = HyperTextMarkupLanguageElement()<br></p><p>Sorry, I think my over-the-top example completely undermined the point I was trying to make. “HTML” and other common acronyms are clearly not being discouraged in the current guideline. But there is no acronym so obscure it can’t easily be found on the internet. So what abbreviations are you discouraging? Truncations like Str or Len? Or is this guideline really just about acronyms and not making up your own? I just thought it could be more clear.<br></p><p>—CK<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/5ea6ad33/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt; <br>&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt; <br>&gt; func add(observer: NSObject, for keyPath: String)<br>&gt; grid.add(self, for: graphics) // vague<br>&gt; <br>&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt; <br>&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br></p><p>I don’t understand why to compensate for weak type information we put some of that compensation in the name of the function and other parts of it in the [external] name of the parameter.<br></p><p>If we were going to reference functions like this: addObserver:forKeyPath, then I can understand it. But that’s not the plan of record, it’s to do this: addObserver(_:forKeyPath). <br></p><p>Regardless of the default naming scheme, it seems like the rule should be to use external names to clarify that parameters role.<br></p><p>func add(observer observer: NSObject, forKeyPath path: String)<br>grid.add(observer: self, forKeyPath: graphics)<br></p><p>This promotes a very clear and consistent rule: weak type information should be clarified by the parameter’s external name. There are no exceptions for the first parameter. Otherwise, it seems like there is super fine line between this rule and the next one below. <br></p><p>Additionally, this also alleviates my concerns with the default parameter have _ as the external name by default because this addresses the case when it would be desirable to have that name. Further, the case below handles the case when it’s not.<br></p><p><br>&gt; Omit Needless Words. Every word in a name should convey salient information at the use site.<br>&gt; <br>&gt; More words may be needed to clarify intent or disambiguate meaning, but those that are redundant with information the reader already possesses should be omitted. In particular, omit words that merely repeat type information:<br>&gt; <br>&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt; allViews.removeElement(cancelButton)<br>&gt; <br>&gt; In this case, the word Element adds nothing salient at the call site. This API would be better:<br>&gt; <br>&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt; allViews.remove(cancelButton) // clearer<br>&gt; <br>&gt; Occasionally, repeating type information is necessary to avoid ambiguity, but in general it is better to use a word that describes a parameter’s role rather than its type. See the next item for details.<br></p><p>The description here seems to overlap with the “Compensate for Weak Type Information” rule, especially with the clause: “repeating type information”. It may be better to re-work the example to be `removeItem(member: Element)` to make this distinction more clear that it’s not type information being removed.<br></p><p>Also, by clarifying that statement, the above rule change I suggested would be consistent. Type information clarification goes into the external parameter name, functionality clarification goes into the function name. Those are hard-n-fast rules that are straight-forward. <br></p><p><br>&gt; Be Grammatical<br>&gt; <br>&gt; When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br></p><p>Is this guideline suggesting that we should design our APIs to generally have both mutating and non-mutaging counterparts?<br></p><p>As other have pointed out, this is also very hard to do all the time. I think the alternatives are worse. It would be nice if there were a way to annotate all member functions as mutating/non-mutating to really by-pass this ambiguity.<br></p><p>Other than the above, the proposal looks pretty good to me.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/53c6cf00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fa2575f192bfdb93dd4cb043545a5df4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium at gmail.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>How would we apply this to delegate patterns?<br>For example, would we keep tableview(tableView:cellForRowAtIndexPath:), or<br>would we switch to delegate(tableView:cellForRowAtIndexPath:) ?<br>Or perhaps better, for clarity over which protocol is being conformed to /<br>which property of the delegator is calling the function:<br>dataSource(tableView:cellForRowAtIndexPath:),<br>delegate(tableView:didSelectRowAtIndexPath:)<br></p><p>On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; *Compensate For Weak Type Information as needed to clarify a<br>&gt; parameter’s role.*<br>&gt;<br>&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt; fundamental type such Int or String, type information and context at<br>&gt; the point of use may not fully convey intent. In this example, the<br>&gt; declaration may be clear, but the use site is vague:<br>&gt;<br>&gt; func add(observer: NSObject, for keyPath: String)<br>&gt; grid.add(self, for: graphics) // vague<br>&gt;<br>&gt;<br>&gt; To restore clarity, precede each weakly-typed parameter with a noun<br>&gt; describing its role:<br>&gt;<br>&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;<br>&gt;<br>&gt; I don’t understand why to compensate for weak type information we put some<br>&gt; of that compensation in the name of the function and other parts of it in<br>&gt; the [external] name of the parameter.<br>&gt;<br>&gt; If we were going to reference functions like this: addObserver:forKeyPath,<br>&gt; then I can understand it. But that’s not the plan of record, it’s to do<br>&gt; this: addObserver(_:forKeyPath).<br>&gt;<br>&gt; Regardless of the default naming scheme, it seems like the rule should be<br>&gt; to use external names to clarify that parameters role.<br>&gt;<br>&gt; func add(observer observer: NSObject, forKeyPath path: String)<br>&gt; grid.add(observer: self, forKeyPath: graphics)<br>&gt;<br>&gt;<br>&gt; This promotes a very clear and consistent rule: weak type information<br>&gt; should be clarified by the parameter’s external name. There are no<br>&gt; exceptions for the first parameter. Otherwise, it seems like there is super<br>&gt; fine line between this rule and the next one below.<br>&gt;<br>&gt; Additionally, this also alleviates my concerns with the default parameter<br>&gt; have _ as the external name by default because this addresses the case<br>&gt; when it would be desirable to have that name. Further, the case below<br>&gt; handles the case when it’s not.<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Omit Needless Words. Every word in a name should convey salient<br>&gt; information at the use site.*<br>&gt;<br>&gt; More words may be needed to clarify intent or disambiguate meaning, but<br>&gt; those that are redundant with information the reader already<br>&gt; possesses should be omitted. In particular, omit words that merely repeat<br>&gt; type information:<br>&gt;<br>&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt; allViews.removeElement(cancelButton)<br>&gt;<br>&gt;<br>&gt; In this case, the word Element adds nothing salient at the call site. This<br>&gt; API would be better:<br>&gt;<br>&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt; allViews.remove(cancelButton) // clearer<br>&gt;<br>&gt;<br>&gt; Occasionally, repeating type information is necessary to avoid ambiguity,<br>&gt; but in general it is better to use a word that describes a<br>&gt; parameter’s role rather than its type. See the next item for details.<br>&gt;<br>&gt;<br>&gt; The description here seems to overlap with the “Compensate for Weak Type<br>&gt; Information” rule, especially with the clause: “repeating type<br>&gt; information”. It may be better to re-work the example to be<br>&gt; `removeItem(member: Element)` to make this distinction more clear that it’s<br>&gt; not type information being removed.<br>&gt;<br>&gt; Also, by clarifying that statement, the above rule change I suggested<br>&gt; would be consistent. Type information clarification goes into the external<br>&gt; parameter name, functionality clarification goes into the function name.<br>&gt; Those are hard-n-fast rules that are straight-forward.<br>&gt;<br>&gt;<br>&gt; *Be Grammatical*<br>&gt;<br>&gt; When a mutating method is described by a verb, name its non-mutating<br>&gt; counterpart according to the “ed/ing” rule, e.g. the non-mutating versions<br>&gt; of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br>&gt;<br>&gt;<br>&gt; Is this guideline suggesting that we should design our APIs to generally<br>&gt; have both mutating and non-mutaging counterparts?<br>&gt;<br>&gt; As other have pointed out, this is also very hard to do all the time. I<br>&gt; think the alternatives are worse. It would be nice if there were a way to<br>&gt; annotate all member functions as mutating/non-mutating to really by-pass<br>&gt; this ambiguity.<br>&gt;<br>&gt; Other than the above, the proposal looks pretty good to me.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/c051e538/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0acf75deb034e62d9e8c18c2d3680b54?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Michael Wells</string> &lt;michael at michaelwells.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt; <br>&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt; <br>&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt; <br>&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt; <br>&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt; <br></p><p>Where this rule feels clumsy to me is in code such as<br></p><p>func loginWithUsername(username: String, password: String) -&gt; Bool<br></p><p>vs.<br></p><p>func login(username: String, password: String) -&gt; Bool<br></p><p>But maybe it just takes some time to get used to the style.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/dc202a54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 5:26 PM, Michael Wells via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt; <br>&gt; <br>&gt; Where this rule feels clumsy to me is in code such as<br>&gt; <br>&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt; func login(username: String, password: String) -&gt; Bool<br>&gt; <br>&gt; But maybe it just takes some time to get used to the style.<br></p><p><br>Consider an exception rule:<br></p><p>Prefer external names for the first parameter when the natural semantic relationship between the parameters is stronger than their relation to the operation. So<br></p><p>login(username: String, password:String)<br>moveTo(x: Double, y: Double)<br></p><p>but <br></p><p>addLineToPoint(p1: CGPoint, withThickness: CGFloat)<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/bc31a634/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 23.01.2016 um 01:35 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 5:26 PM, Michael Wells via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Where this rule feels clumsy to me is in code such as<br>&gt;&gt; <br>&gt;&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; vs.<br>&gt;&gt; <br>&gt;&gt; func login(username: String, password: String) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; But maybe it just takes some time to get used to the style.<br>&gt; <br>&gt; <br>&gt; Consider an exception rule:<br>&gt; <br>&gt; Prefer external names for the first parameter when the natural semantic relationship between the parameters is stronger than their relation to the operation. So<br>&gt; <br>&gt; login(username: String, password:String)<br></p><p>I would actually prefer one of<br></p><p>func loginWithUsername(username: String, password: String)<br>func login(withUsername username: String, password: String)<br></p><p>because of the weak type information to just<br></p><p>func login(sername: String, password: String)<br></p><p><br>Of course the ideal version would define the types Username and Password (ideally with a future newtype construct :-) and then could use just<br></p><p>func login(username: Username, password: Password)<br></p><p><br>&gt; but <br>&gt; <br>&gt; addLineToPoint(p1: CGPoint, withThickness: CGFloat)<br></p><p>Why should addLineTo(point: CGPoint, withThickness thickness: CGFloat) be considered as having weak type information for the point?<br></p><p><br>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/5c81797e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>And I&#39;d prefer logIn (verb) over login (noun) in the example :)<br></p><p>On Sat, Jan 23, 2016 at 12:07 PM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Am 23.01.2016 um 01:35 schrieb Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 5:26 PM, Michael Wells via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; *Compensate For Weak Type Information as needed to clarify a<br>&gt;&gt; parameter’s role.*<br>&gt;&gt;<br>&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt;&gt; fundamental type such Int or String, type information and context at<br>&gt;&gt; the point of use may not fully convey intent. In this example, the<br>&gt;&gt; declaration may be clear, but the use site is vague:<br>&gt;&gt;<br>&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun<br>&gt;&gt; describing its role:<br>&gt;&gt;<br>&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Where this rule feels clumsy to me is in code such as<br>&gt;<br>&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt;<br>&gt; vs.<br>&gt;<br>&gt; func login(username: String, password: String) -&gt; Bool<br>&gt;<br>&gt; But maybe it just takes some time to get used to the style.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Consider an exception rule:<br>&gt;<br>&gt; Prefer external names for the first parameter when the natural semantic<br>&gt; relationship between the parameters is stronger than their relation to the<br>&gt; operation. So<br>&gt;<br>&gt; login(username: String, password:String)<br>&gt;<br>&gt;<br>&gt; I would actually prefer one of<br>&gt;<br>&gt; func loginWithUsername(username: String, password: String)<br>&gt; func login(withUsername username: String, password: String)<br>&gt;<br>&gt; because of the weak type information to just<br>&gt;<br>&gt; func login(sername: String, password: String)<br>&gt;<br>&gt;<br>&gt; Of course the ideal version would define the types Username and Password<br>&gt; (ideally with a future newtype construct :-) and then could use just<br>&gt;<br>&gt; func login(username: Username, password: Password)<br>&gt;<br>&gt;<br>&gt; but<br>&gt;<br>&gt; addLineToPoint(p1: CGPoint, withThickness: CGFloat)<br>&gt;<br>&gt;<br>&gt; Why should addLineTo(point: CGPoint, withThickness thickness: CGFloat) be<br>&gt; considered as having weak type information for the point?<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/c1550fa0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32ed5b32826658f01df18fa220fa090e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Haravikk</string> &lt;me at haravikk.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 23 Jan 2016, at 11:07, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would actually prefer one of<br>&gt; <br>&gt; func loginWithUsername(username: String, password: String)<br>&gt; func login(withUsername username: String, password: String)<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>I’m actually a big fan of the second definition, as it makes more sense to me for variations to be grouped by function name, as a login(withCertificate) or whatever is functionally identical, it just has different arguments to trigger it.<br></p><p>i.e- the function is named for what it will eventually perform (a login), and the parameters are named for what the function variant requires in order to perform that action, but in a form that allows the entire function declaration to be read like natural language.<br></p><p>I never really liked Objective-C’s grouping of the first parameter’s name into the function name, as you could end up with an object that has a loginWithUsername function and a separate loginWithCertificate function even though both do essentially the same thing. A lot of the methods of String for example suffer from this, which makes them quite a pain to use when dealing with “pure” Swift code (i.e- trying to work without any visible bridging to Objective-C).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/4cea28c2/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 1567 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/4cea28c2/attachment.p7s&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 4:35 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 5:26 PM, Michael Wells via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Where this rule feels clumsy to me is in code such as<br>&gt;&gt; <br>&gt;&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; vs.<br>&gt;&gt; <br>&gt;&gt; func login(username: String, password: String) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; But maybe it just takes some time to get used to the style.<br>&gt; <br>&gt; <br>&gt; Consider an exception rule:<br>&gt; <br>&gt; Prefer external names for the first parameter when the natural semantic relationship between the parameters is stronger than their relation to the operation. So<br>&gt; <br>&gt; login(username: String, password:String)<br>&gt; moveTo(x: Double, y: Double)<br></p><p>I’ve tried to capture a similar rule before without much luck: to me, it’s something about the various parameters being equally suited to being the direct object of the verb in the base name. I can<br></p><p>	loginWithPassword(String, username: String)<br></p><p>or<br></p><p>	loginWithUsername(String, password: String)<br></p><p>and it’s only convention that gives slight preference to the latter: username and password are both equally important parameters to the “login” operation, so it feels wrong to have to give one of them the extra weight of being described in the base name.<br></p><p>	transition(from from: UIViewController, to: UIViewController, etc.)<br></p><p>is one of my favorite examples where the first two parameters have equal importance.<br></p><p>&gt; but <br>&gt; <br>&gt; addLineToPoint(p1: CGPoint, withThickness: CGFloat)<br></p><p>As noted elsewhere, this isn’t a good counterexample, because “Point” is needless:<br></p><p>	addLineTo(p1: CGPoint, withThickness: CGFloat)<br></p><p>(the “with” also seems unnecessary to me). <br></p><p>However, the previously-shown<br></p><p>	func addObserver(observer: NSObject, forKeyPath path: String)<br></p><p>has a first parameter that is far more important than the second parameter, and the base name (“add”) is fairly generic on its own.<br></p><p>	- Doug<br></p><p>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/71482454/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 4:26 PM, Michael Wells via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt; <br>&gt; <br>&gt; Where this rule feels clumsy to me is in code such as<br>&gt; <br>&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt; func login(username: String, password: String) -&gt; Bool<br>&gt; <br>&gt; But maybe it just takes some time to get used to the style.<br></p><p><br>I much prefer the second version:<br></p><p>func login(username name: String, password: String) -&gt; Bool<br>login(username: “bob”, password: “1234”)<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/aad094af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 22, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 for me too.<br></p><p>func login(username name: String, password: String) -&gt; Bool<br>login(username: “bob”, password: “1234”)<br></p><p>It feels much more consistent and simpler.<br></p><p>&gt; On Jan 22, 2016, at 7:47 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 4:26 PM, Michael Wells via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Where this rule feels clumsy to me is in code such as<br>&gt;&gt; <br>&gt;&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; vs.<br>&gt;&gt; <br>&gt;&gt; func login(username: String, password: String) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; But maybe it just takes some time to get used to the style.<br>&gt; <br>&gt; <br>&gt; I much prefer the second version:<br>&gt; <br>&gt; Guess everything is ok now... <br>&gt; login(username: “bob”, password: “1234”)<br>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/a8d9a241/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 22, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; Where this rule feels clumsy to me is in code such as<br>&gt;<br>&gt; func loginWithUsername(username: String, password: String) -&gt; Bool<br>&gt;<br>&gt; vs.<br>&gt;<br>&gt; func login(username: String, password: String) -&gt; Bool<br>&gt;<br>&gt; But maybe it just takes some time to get used to the style.<br>&gt;<br></p><p>You&#39;re right that loginWithUsername is clumsy, since the first argument is<br>probably an expression like &quot;username&quot; or &quot;usernameField.text&quot; or somesuch.<br>But I would much prefer<br></p><p>    func loginAs(username: String, password: String) -&gt; Bool<br></p><p>because it reads like something I&#39;d actually say. Consider telling a<br>coworker &quot;log in as &#39;mayoff&#39;, password &#39;bikeshed&#39;&quot;.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/b4018230/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 4:12 PM, Ross O&#39;Brien &lt;narrativium at gmail.com&gt; wrote:<br>&gt; <br>&gt; How would we apply this to delegate patterns?<br>&gt; For example, would we keep tableview(tableView:cellForRowAtIndexPath:), or would we switch to delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt; Or perhaps better, for clarity over which protocol is being conformed to / which property of the delegator is calling the function:<br>&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt; delegate(tableView:didSelectRowAtIndexPath:)<br></p><p>There would be no argument label for `tableView`; it’s a needless word and there is a strong type information: it’s a TableView. <br></p><p>Weak type information would be like “key path” below. Yes, it’s String, but it’s actually a specially crafted string that takes the form: “some.nested.values”. A string like “some+234+//23” is not going to work.<br></p><p>I’m also not really convinced that `removeAt(position: Int)` doesn’t actually fall under both rules. The first parameter is a weak type; it has rules associated with it (non-zero and less than collection size). In the guidelines, it could be argued that it should be `removeAtIndex(position: Int)`. I’d prefer the `removeAt(index position: Int)` version. But, you can kinda make the weak type argument for a lot of scenarios… It’s a little ambiguous to me.<br></p><p>-David<br></p><p>&gt; <br>&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt; <br>&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt; <br>&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt; <br>&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt; <br>&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt; <br>&gt; I don’t understand why to compensate for weak type information we put some of that compensation in the name of the function and other parts of it in the [external] name of the parameter.<br>&gt; <br>&gt; If we were going to reference functions like this: addObserver:forKeyPath, then I can understand it. But that’s not the plan of record, it’s to do this: addObserver(_:forKeyPath). <br>&gt; <br>&gt; Regardless of the default naming scheme, it seems like the rule should be to use external names to clarify that parameters role.<br>&gt; <br>&gt; func add(observer observer: NSObject, forKeyPath path: String)<br>&gt; grid.add(observer: self, forKeyPath: graphics)<br>&gt; <br>&gt; This promotes a very clear and consistent rule: weak type information should be clarified by the parameter’s external name. There are no exceptions for the first parameter. Otherwise, it seems like there is super fine line between this rule and the next one below. <br>&gt; <br>&gt; Additionally, this also alleviates my concerns with the default parameter have _ as the external name by default because this addresses the case when it would be desirable to have that name. Further, the case below handles the case when it’s not.<br>&gt; <br>&gt; <br>&gt;&gt; Omit Needless Words. Every word in a name should convey salient information at the use site.<br>&gt;&gt; <br>&gt;&gt; More words may be needed to clarify intent or disambiguate meaning, but those that are redundant with information the reader already possesses should be omitted. In particular, omit words that merely repeat type information:<br>&gt;&gt; <br>&gt;&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt;&gt; allViews.removeElement(cancelButton)<br>&gt;&gt; <br>&gt;&gt; In this case, the word Element adds nothing salient at the call site. This API would be better:<br>&gt;&gt; <br>&gt;&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt;&gt; allViews.remove(cancelButton) // clearer<br>&gt;&gt; <br>&gt;&gt; Occasionally, repeating type information is necessary to avoid ambiguity, but in general it is better to use a word that describes a parameter’s role rather than its type. See the next item for details.<br>&gt; <br>&gt; The description here seems to overlap with the “Compensate for Weak Type Information” rule, especially with the clause: “repeating type information”. It may be better to re-work the example to be `removeItem(member: Element)` to make this distinction more clear that it’s not type information being removed.<br>&gt; <br>&gt; Also, by clarifying that statement, the above rule change I suggested would be consistent. Type information clarification goes into the external parameter name, functionality clarification goes into the function name. Those are hard-n-fast rules that are straight-forward. <br>&gt; <br>&gt; <br>&gt;&gt; Be Grammatical<br>&gt;&gt; <br>&gt;&gt; When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br>&gt; <br>&gt; Is this guideline suggesting that we should design our APIs to generally have both mutating and non-mutaging counterparts?<br>&gt; <br>&gt; As other have pointed out, this is also very hard to do all the time. I think the alternatives are worse. It would be nice if there were a way to annotate all member functions as mutating/non-mutating to really by-pass this ambiguity.<br>&gt; <br>&gt; Other than the above, the proposal looks pretty good to me.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/25e40adb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 23, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How would we apply this to delegate patterns?<br>&gt; For example, would we keep tableview(tableView:cellForRowAtIndexPath:), or would we switch to delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt; Or perhaps better, for clarity over which protocol is being conformed to / which property of the delegator is calling the function:<br>&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt; delegate(tableView:didSelectRowAtIndexPath:)<br></p><p>FWIW, I am personally favorable to a more radical-renaming for delegate methods, roughly the below:<br></p><p>func numberOfSections(inTableView tableView: UITableView) -&gt; Int // &lt;- against guidelines, but symmetric<br>func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>func cellForRow(inTableView tableView: UITableView, atIndexPath indexPath: NSIndexPath) -&gt; UITableView<br></p><p>…where the rule is to find the “what is this method about” part of the selector, make that the name of the Swift function, and then label each argument as-necessary; the goal is for the methods to read as approximate natural-language sentences.<br></p><p>This is most definitely *not* in line with conventions, but I have found it to be *much* more readable overall; this is especially true in the case of new APIs (which don’t have the benefit of deep familiarity like the table-view and similar).<br></p><p>EG, consider the following lightly-edited definition (from some Swift code that needs to be usable from Objective-C):<br></p><p>// from a `TransitionAnimatorDelegateProtocol`<br>@objc(transitionAnimator:userInfoForTransitionSender:transitionOrigin:transitionDestination:)<br>  func transitionUserInfo(<br>    forAnimator animator: TransitionAnimator,<br>    sender: AnyObject?,<br>    origin: TransitionOriginProtocol,<br>    destination: TransitionDestinationProtocol) -&gt; [String:AnyObject]?<br></p><p>…which, coming across in Swift, feels a whole lot more readable than the “conventional” approach; I mean really, would anyone out there voluntarily use a name like the below, instead:<br></p><p>func transtionAnimator(<br>  animator: TransitionAnimator, <br>  userInfoForTransitionSender sender: AnyObject?,<br>  transitionOrigin origin: TransitionOriginProtocol,<br>  transitionDestination destination: TransitionDestination) -&gt; [String:AnyObject]?<br></p><p>…except out of respect for tradition?<br></p><p>I’m still processing the overall guidelines.<br></p><p>&gt; <br>&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt; <br>&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt; <br>&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt; <br>&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt; <br>&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt; <br>&gt; I don’t understand why to compensate for weak type information we put some of that compensation in the name of the function and other parts of it in the [external] name of the parameter.<br>&gt; <br>&gt; If we were going to reference functions like this: addObserver:forKeyPath, then I can understand it. But that’s not the plan of record, it’s to do this: addObserver(_:forKeyPath). <br>&gt; <br>&gt; Regardless of the default naming scheme, it seems like the rule should be to use external names to clarify that parameters role.<br>&gt; <br>&gt; func add(observer observer: NSObject, forKeyPath path: String)<br>&gt; grid.add(observer: self, forKeyPath: graphics)<br>&gt; <br>&gt; This promotes a very clear and consistent rule: weak type information should be clarified by the parameter’s external name. There are no exceptions for the first parameter. Otherwise, it seems like there is super fine line between this rule and the next one below. <br>&gt; <br>&gt; Additionally, this also alleviates my concerns with the default parameter have _ as the external name by default because this addresses the case when it would be desirable to have that name. Further, the case below handles the case when it’s not.<br>&gt; <br>&gt; <br>&gt;&gt; Omit Needless Words. Every word in a name should convey salient information at the use site.<br>&gt;&gt; <br>&gt;&gt; More words may be needed to clarify intent or disambiguate meaning, but those that are redundant with information the reader already possesses should be omitted. In particular, omit words that merely repeat type information:<br>&gt;&gt; <br>&gt;&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt;&gt; allViews.removeElement(cancelButton)<br>&gt;&gt; <br>&gt;&gt; In this case, the word Element adds nothing salient at the call site. This API would be better:<br>&gt;&gt; <br>&gt;&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt;&gt; allViews.remove(cancelButton) // clearer<br>&gt;&gt; <br>&gt;&gt; Occasionally, repeating type information is necessary to avoid ambiguity, but in general it is better to use a word that describes a parameter’s role rather than its type. See the next item for details.<br>&gt; <br>&gt; The description here seems to overlap with the “Compensate for Weak Type Information” rule, especially with the clause: “repeating type information”. It may be better to re-work the example to be `removeItem(member: Element)` to make this distinction more clear that it’s not type information being removed.<br>&gt; <br>&gt; Also, by clarifying that statement, the above rule change I suggested would be consistent. Type information clarification goes into the external parameter name, functionality clarification goes into the function name. Those are hard-n-fast rules that are straight-forward. <br>&gt; <br>&gt; <br>&gt;&gt; Be Grammatical<br>&gt;&gt; <br>&gt;&gt; When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br>&gt; <br>&gt; Is this guideline suggesting that we should design our APIs to generally have both mutating and non-mutaging counterparts?<br>&gt; <br>&gt; As other have pointed out, this is also very hard to do all the time. I think the alternatives are worse. It would be nice if there were a way to annotate all member functions as mutating/non-mutating to really by-pass this ambiguity.<br>&gt; <br>&gt; Other than the above, the proposal looks pretty good to me.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/1fc783e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 5:11 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt; For example, would we keep tableview(tableView:cellForRowAtIndexPath:), or would we switch to delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt; Or perhaps better, for clarity over which protocol is being conformed to / which property of the delegator is calling the function:<br>&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt; <br>&gt; FWIW, I am personally favorable to a more radical-renaming for delegate methods, roughly the below:<br>&gt; <br>&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int // &lt;- against guidelines, but symmetric<br>&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath indexPath: NSIndexPath) -&gt; UITableView<br>&gt; <br>&gt; …where the rule is to find the “what is this method about” part of the selector, make that the name of the Swift function, and then label each argument as-necessary; the goal is for the methods to read as approximate natural-language sentences.<br>&gt; <br>&gt; This is most definitely *not* in line with conventions, but I have found it to be *much* more readable overall; this is especially true in the case of new APIs (which don’t have the benefit of deep familiarity like the table-view and similar).<br></p><p>I’ve always found the delegate naming convention counterintuitive, because the important action is either in the second argument label or (when the source is the only parameter) buried in the base name.<br></p><p>In truth, I’d intended to investigate whether one could automatically translate Cocoa’s delegate methods into a form much like what you’re describing, but haven’t had time to experiment with it. Personally, I think it’s a promising direction to go, if we can come up with a guideline and implement some heuristics in the Clang importer to translate Cocoa well.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d042d91c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>I find your convention more readable.<br></p><p>The other convention of starting with delegate() or dataSource() is nice in that they would appear next to each listed to each other.  But I think I prefer readability over this convenience.  Also, the IDE could be smart and list together the methods that are part of a protocol.  Then we would have the best of both worlds.  :-)<br></p><p><br></p><p>&gt; On Jan 23, 2016, at 8:11 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt; For example, would we keep tableview(tableView:cellForRowAtIndexPath:), or would we switch to delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt; Or perhaps better, for clarity over which protocol is being conformed to / which property of the delegator is calling the function:<br>&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt; <br>&gt; FWIW, I am personally favorable to a more radical-renaming for delegate methods, roughly the below:<br>&gt; <br>&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int // &lt;- against guidelines, but symmetric<br>&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath indexPath: NSIndexPath) -&gt; UITableView<br>&gt; <br>&gt; …where the rule is to find the “what is this method about” part of the selector, make that the name of the Swift function, and then label each argument as-necessary; the goal is for the methods to read as approximate natural-language sentences.<br>&gt; <br>&gt; This is most definitely *not* in line with conventions, but I have found it to be *much* more readable overall; this is especially true in the case of new APIs (which don’t have the benefit of deep familiarity like the table-view and similar).<br>&gt; <br>&gt; EG, consider the following lightly-edited definition (from some Swift code that needs to be usable from Objective-C):<br>&gt; <br>&gt; // from a `TransitionAnimatorDelegateProtocol`<br>&gt; @objc(transitionAnimator:userInfoForTransitionSender:transitionOrigin:transitionDestination:)<br>&gt;   func transitionUserInfo(<br>&gt;     forAnimator animator: TransitionAnimator,<br>&gt;     sender: AnyObject?,<br>&gt;     origin: TransitionOriginProtocol,<br>&gt;     destination: TransitionDestinationProtocol) -&gt; [String:AnyObject]?<br>&gt; <br>&gt; …which, coming across in Swift, feels a whole lot more readable than the “conventional” approach; I mean really, would anyone out there voluntarily use a name like the below, instead:<br>&gt; <br>&gt; func transtionAnimator(<br>&gt;   animator: TransitionAnimator, <br>&gt;   userInfoForTransitionSender sender: AnyObject?,<br>&gt;   transitionOrigin origin: TransitionOriginProtocol,<br>&gt;   transitionDestination destination: TransitionDestination) -&gt; [String:AnyObject]?<br>&gt; <br>&gt; …except out of respect for tradition?<br>&gt; <br>&gt; I’m still processing the overall guidelines.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Jan 23, 2016 at 12:00 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt; <br>&gt;&gt; I don’t understand why to compensate for weak type information we put some of that compensation in the name of the function and other parts of it in the [external] name of the parameter.<br>&gt;&gt; <br>&gt;&gt; If we were going to reference functions like this: addObserver:forKeyPath, then I can understand it. But that’s not the plan of record, it’s to do this: addObserver(_:forKeyPath). <br>&gt;&gt; <br>&gt;&gt; Regardless of the default naming scheme, it seems like the rule should be to use external names to clarify that parameters role.<br>&gt;&gt; <br>&gt;&gt; func add(observer observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.add(observer: self, forKeyPath: graphics)<br>&gt;&gt; <br>&gt;&gt; This promotes a very clear and consistent rule: weak type information should be clarified by the parameter’s external name. There are no exceptions for the first parameter. Otherwise, it seems like there is super fine line between this rule and the next one below. <br>&gt;&gt; <br>&gt;&gt; Additionally, this also alleviates my concerns with the default parameter have _ as the external name by default because this addresses the case when it would be desirable to have that name. Further, the case below handles the case when it’s not.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Omit Needless Words. Every word in a name should convey salient information at the use site.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More words may be needed to clarify intent or disambiguate meaning, but those that are redundant with information the reader already possesses should be omitted. In particular, omit words that merely repeat type information:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt;&gt;&gt; allViews.removeElement(cancelButton)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case, the word Element adds nothing salient at the call site. This API would be better:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt;&gt;&gt; allViews.remove(cancelButton) // clearer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Occasionally, repeating type information is necessary to avoid ambiguity, but in general it is better to use a word that describes a parameter’s role rather than its type. See the next item for details.<br>&gt;&gt; <br>&gt;&gt; The description here seems to overlap with the “Compensate for Weak Type Information” rule, especially with the clause: “repeating type information”. It may be better to re-work the example to be `removeItem(member: Element)` to make this distinction more clear that it’s not type information being removed.<br>&gt;&gt; <br>&gt;&gt; Also, by clarifying that statement, the above rule change I suggested would be consistent. Type information clarification goes into the external parameter name, functionality clarification goes into the function name. Those are hard-n-fast rules that are straight-forward. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Be Grammatical<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).<br>&gt;&gt; <br>&gt;&gt; Is this guideline suggesting that we should design our APIs to generally have both mutating and non-mutaging counterparts?<br>&gt;&gt; <br>&gt;&gt; As other have pointed out, this is also very hard to do all the time. I think the alternatives are worse. It would be nice if there were a way to annotate all member functions as mutating/non-mutating to really by-pass this ambiguity.<br>&gt;&gt; <br>&gt;&gt; Other than the above, the proposal looks pretty good to me.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/318748ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; *Protocols* that describe what something *is* should read as nouns<br>(e.g. |Collection|). Protocols that describe a *capability* should be<br>named using the suffixes |able|, |ible|, or |ing| (e.g. |Equatable|,<br>|ProgressReporting|).<br></p><p>I personally like the idea behind the current convention for protocols<br>that describe a thing (IntegerType, CollectionType, etc) where there is<br>a suffix of Type appended to the end, so I give this specific part of<br>the proposal a -1. The specific wording of the protocol&#39;s name is not so<br>important as the recognition at a glance that this is a protocol vs a<br>concrete type. I like being able to infer at a glance how I&#39;m expected<br>to use a specific type reference based on its name alone; otherwise I<br>may have to refer back to the type definition to refresh my memory of<br>whether or not it is in fact a protocol or is something else.<br></p><p>This change could also lead to confusion among some developers. For<br>someone who is new to Swift, would they know they should use Bool over<br>Boolean if they&#39;ve seen both types before? Both names look reasonable to<br>store a boolean value, but the semantics of each type differ<br>significantly. Someone may try to have a type conform to Bool instead of<br>Boolean, which would obviously not work, but could cause some<br>consternation for developers who don&#39;t know the difference by heart.<br>Naming the protocol BooleanType at least calls out that this may not be<br>conceptually the same as a plain boolean value, which could make a<br>developer think twice before trying to use that over Bool.<br></p><p>Removing some common prefix from these kinds of protocols could also run<br>the risk of unintentionally shadowing type names, if someone wanted to<br>write their own Collection or Error struct or class for instance, or if<br>a pre-existing concrete type in their code turned out to unexpectedly<br>shadow a protocol in a new dependency that they want to add. These<br>situations would not cause any technical hiccups due to module<br>namespacing, but it could lead to confusion when a developer forgets to<br>qualify the name and tries to use one type where the other is expected.<br></p><p>In short, appending Type (or something like it) i think is a reasonable<br>convention to keep around for non-behavioral protocols.<br></p><p>As far as alternatives to &#39;Type&#39;, I personally don&#39;t like the suffix<br>&#39;Protocol&#39; as much (which is suggested as a disambiguation option in the<br>related standard library review), since &#39;Type&#39; is shorter, feels nicer<br>to read, and describes the purpose of the protocol well to me. C#&#39;s<br>approach of prefixing all interfaces with a capital I would be even more<br>succinct, but I personally don&#39;t think that approach would look nice to<br>read either. (PCollection, PBoolean? Ick.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/a1ddcae3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 23, 2016 at 03:00:00pm</p></header><div class="content"><p>I never liked the convention of distinguishing between interfaces and classes by prepending an „I“ for interfaces in other languages and I’m not overly fond fond of the suffix „Type“ currently used in Swift protocols.<br>This is the same as prefixing (or suffixing) variable names with something to express their type, e.g. `String sName` or `int iLength`.<br>That’s what we have type information for. <br></p><p>And because of the substitution principle it should make no difference whether I have a protocol or a struct or class. What is a `CollectionType` vs. a `Collection`? Is it the type of a `Collection`, i.e. a meta type? Why not simply `Collection` if it describes what a collection is? <br>I guess its often more the problem of finding a suitable different name for the implementation and that’s why I sometimes wonder whether it might make sense to give protocols their own namespace…<br></p><p>In short, I am not fond of the suffix „Type“ (but I would dislike the suffix „Protocol“ or prefixes like „I“ or „P“ even more).<br></p><p>I’m open to debate, though :-)<br></p><p>-Thorsten<br></p><p><br></p><p><br></p><p>&gt; Am 23.01.2016 um 06:25 schrieb Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; &gt; Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).<br>&gt; <br>&gt; I personally like the idea behind the current convention for protocols that describe a thing (IntegerType, CollectionType, etc) where there is a suffix of Type appended to the end, so I give this specific part of the proposal a -1. The specific wording of the protocol&#39;s name is not so important as the recognition at a glance that this is a protocol vs a concrete type. I like being able to infer at a glance how I&#39;m expected to use a specific type reference based on its name alone; otherwise I may have to refer back to the type definition to refresh my memory of whether or not it is in fact a protocol or is something else.<br>&gt; <br>&gt; This change could also lead to confusion among some developers. For someone who is new to Swift, would they know they should use Bool over Boolean if they&#39;ve seen both types before? Both names look reasonable to store a boolean value, but the semantics of each type differ significantly. Someone may try to have a type conform to Bool instead of Boolean, which would obviously not work, but could cause some consternation for developers who don&#39;t know the difference by heart. Naming the protocol BooleanType at least calls out that this may not be conceptually the same as a plain boolean value, which could make a developer think twice before trying to use that over Bool.<br>&gt; <br>&gt; Removing some common prefix from these kinds of protocols could also run the risk of unintentionally shadowing type names, if someone wanted to write their own Collection or Error struct or class for instance, or if a pre-existing concrete type in their code turned out to unexpectedly shadow a protocol in a new dependency that they want to add. These situations would not cause any technical hiccups due to module namespacing, but it could lead to confusion when a developer forgets to qualify the name and tries to use one type where the other is expected.<br>&gt; <br>&gt; In short, appending Type (or something like it) i think is a reasonable convention to keep around for non-behavioral protocols.<br>&gt; <br>&gt; As far as alternatives to &#39;Type&#39;, I personally don&#39;t like the suffix &#39;Protocol&#39; as much (which is suggested as a disambiguation option in the related standard library review), since &#39;Type&#39; is shorter, feels nicer to read, and describes the purpose of the protocol well to me. C#&#39;s approach of prefixing all interfaces with a capital I would be even more succinct, but I personally don&#39;t think that approach would look nice to read either. (PCollection, PBoolean? Ick.) <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/afce5fab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32ed5b32826658f01df18fa220fa090e?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Haravikk</string> &lt;me at haravikk.com&gt;<p>January 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Since I learned object-oriented programming in Java, I never understood the need for suffixes and prefixes at all, as Java’s package system makes for very simple namespaces for everything in the event that simply using a class/interface name is unclear.<br></p><p>I’d say that personally I don’t see why CollectionType shouldn’t just be Collection, in cases where several things are named Collection we should really have some kind of disambiguation mechanism anyway, perhaps with some special cases for specifying when you want a protocol rather than a class/struct.<br></p><p>In my ideal world every language would would follow Java’s example on name-spaces, while avoiding emulating its horrific security record ;)<br></p><p>&gt; On 23 Jan 2016, at 14:52, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I never liked the convention of distinguishing between interfaces and classes by prepending an „I“ for interfaces in other languages and I’m not overly fond fond of the suffix „Type“ currently used in Swift protocols.<br>&gt; This is the same as prefixing (or suffixing) variable names with something to express their type, e.g. `String sName` or `int iLength`.<br>&gt; That’s what we have type information for. <br>&gt; <br>&gt; And because of the substitution principle it should make no difference whether I have a protocol or a struct or class. What is a `CollectionType` vs. a `Collection`? Is it the type of a `Collection`, i.e. a meta type? Why not simply `Collection` if it describes what a collection is? <br>&gt; I guess its often more the problem of finding a suitable different name for the implementation and that’s why I sometimes wonder whether it might make sense to give protocols their own namespace…<br>&gt; <br>&gt; In short, I am not fond of the suffix „Type“ (but I would dislike the suffix „Protocol“ or prefixes like „I“ or „P“ even more).<br>&gt; <br>&gt; I’m open to debate, though :-)<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 23.01.2016 um 06:25 schrieb Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; &gt; Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).<br>&gt;&gt; <br>&gt;&gt; I personally like the idea behind the current convention for protocols that describe a thing (IntegerType, CollectionType, etc) where there is a suffix of Type appended to the end, so I give this specific part of the proposal a -1. The specific wording of the protocol&#39;s name is not so important as the recognition at a glance that this is a protocol vs a concrete type. I like being able to infer at a glance how I&#39;m expected to use a specific type reference based on its name alone; otherwise I may have to refer back to the type definition to refresh my memory of whether or not it is in fact a protocol or is something else.<br>&gt;&gt; <br>&gt;&gt; This change could also lead to confusion among some developers. For someone who is new to Swift, would they know they should use Bool over Boolean if they&#39;ve seen both types before? Both names look reasonable to store a boolean value, but the semantics of each type differ significantly. Someone may try to have a type conform to Bool instead of Boolean, which would obviously not work, but could cause some consternation for developers who don&#39;t know the difference by heart. Naming the protocol BooleanType at least calls out that this may not be conceptually the same as a plain boolean value, which could make a developer think twice before trying to use that over Bool.<br>&gt;&gt; <br>&gt;&gt; Removing some common prefix from these kinds of protocols could also run the risk of unintentionally shadowing type names, if someone wanted to write their own Collection or Error struct or class for instance, or if a pre-existing concrete type in their code turned out to unexpectedly shadow a protocol in a new dependency that they want to add. These situations would not cause any technical hiccups due to module namespacing, but it could lead to confusion when a developer forgets to qualify the name and tries to use one type where the other is expected.<br>&gt;&gt; <br>&gt;&gt; In short, appending Type (or something like it) i think is a reasonable convention to keep around for non-behavioral protocols.<br>&gt;&gt; <br>&gt;&gt; As far as alternatives to &#39;Type&#39;, I personally don&#39;t like the suffix &#39;Protocol&#39; as much (which is suggested as a disambiguation option in the related standard library review), since &#39;Type&#39; is shorter, feels nicer to read, and describes the purpose of the protocol well to me. C#&#39;s approach of prefixing all interfaces with a capital I would be even more succinct, but I personally don&#39;t think that approach would look nice to read either. (PCollection, PBoolean? Ick.) <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/fb9f6769/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 1567 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/fb9f6769/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>Many of Java&#39;s interfaces also conform to the standard swift uses, with things like runnable/comparable. Those define capabilities and are named with the same reasoning that the api guidelines propose, so it&#39;s easy to infer that they are interfaces from the name. I haven&#39;t worked in Java in a while so I could be forgetting other interfaces that don&#39;t follow this trend though, but interfaces in Java are more easily swapped with classes than protocols are in swift anyways (since protocols with associated types cannot be used as the type of a variable or whatnot).<br></p><p>--<br>Kevin Lundberg<br></p><p>&gt; On Jan 23, 2016, at 10:27 AM, Haravikk &lt;me at haravikk.com&gt; wrote:<br>&gt; <br>&gt; Since I learned object-oriented programming in Java, I never understood the need for suffixes and prefixes at all, as Java’s package system makes for very simple namespaces for everything in the event that simply using a class/interface name is unclear.<br>&gt; <br>&gt; I’d say that personally I don’t see why CollectionType shouldn’t just be Collection, in cases where several things are named Collection we should really have some kind of disambiguation mechanism anyway, perhaps with some special cases for specifying when you want a protocol rather than a class/struct.<br>&gt; <br>&gt; In my ideal world every language would would follow Java’s example on name-spaces, while avoiding emulating its horrific security record ;)<br>&gt; <br>&gt;&gt; On 23 Jan 2016, at 14:52, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I never liked the convention of distinguishing between interfaces and classes by prepending an „I“ for interfaces in other languages and I’m not overly fond fond of the suffix „Type“ currently used in Swift protocols.<br>&gt;&gt; This is the same as prefixing (or suffixing) variable names with something to express their type, e.g. `String sName` or `int iLength`.<br>&gt;&gt; That’s what we have type information for. <br>&gt;&gt; <br>&gt;&gt; And because of the substitution principle it should make no difference whether I have a protocol or a struct or class. What is a `CollectionType` vs. a `Collection`? Is it the type of a `Collection`, i.e. a meta type? Why not simply `Collection` if it describes what a collection is? <br>&gt;&gt; I guess its often more the problem of finding a suitable different name for the implementation and that’s why I sometimes wonder whether it might make sense to give protocols their own namespace…<br>&gt;&gt; <br>&gt;&gt; In short, I am not fond of the suffix „Type“ (but I would dislike the suffix „Protocol“ or prefixes like „I“ or „P“ even more).<br>&gt;&gt; <br>&gt;&gt; I’m open to debate, though :-)<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 23.01.2016 um 06:25 schrieb Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I personally like the idea behind the current convention for protocols that describe a thing (IntegerType, CollectionType, etc) where there is a suffix of Type appended to the end, so I give this specific part of the proposal a -1. The specific wording of the protocol&#39;s name is not so important as the recognition at a glance that this is a protocol vs a concrete type. I like being able to infer at a glance how I&#39;m expected to use a specific type reference based on its name alone; otherwise I may have to refer back to the type definition to refresh my memory of whether or not it is in fact a protocol or is something else.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change could also lead to confusion among some developers. For someone who is new to Swift, would they know they should use Bool over Boolean if they&#39;ve seen both types before? Both names look reasonable to store a boolean value, but the semantics of each type differ significantly. Someone may try to have a type conform to Bool instead of Boolean, which would obviously not work, but could cause some consternation for developers who don&#39;t know the difference by heart. Naming the protocol BooleanType at least calls out that this may not be conceptually the same as a plain boolean value, which could make a developer think twice before trying to use that over Bool.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Removing some common prefix from these kinds of protocols could also run the risk of unintentionally shadowing type names, if someone wanted to write their own Collection or Error struct or class for instance, or if a pre-existing concrete type in their code turned out to unexpectedly shadow a protocol in a new dependency that they want to add. These situations would not cause any technical hiccups due to module namespacing, but it could lead to confusion when a developer forgets to qualify the name and tries to use one type where the other is expected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short, appending Type (or something like it) i think is a reasonable convention to keep around for non-behavioral protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as alternatives to &#39;Type&#39;, I personally don&#39;t like the suffix &#39;Protocol&#39; as much (which is suggested as a disambiguation option in the related standard library review), since &#39;Type&#39; is shorter, feels nicer to read, and describes the purpose of the protocol well to me. C#&#39;s approach of prefixing all interfaces with a capital I would be even more succinct, but I personally don&#39;t think that approach would look nice to read either. (PCollection, PBoolean? Ick.) <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/489a1066/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 23, 2016 at 08:00:00pm</p></header><div class="content"><p>True, though that’s partly an issue with Swift’s limitations on how certain types of protocols can be used (and I believe is the subject of another discussion, though the thread escapes me at the moment).<br></p><p>Still, I don’t think that matters when it comes to naming them; I still think that things like CollectionType should just be the Collection protocol, since the fact that it’s a protocol makes it clear that its purpose is to define the requirements of a collection. If a class or struct then comes along that’s also called Collection then that’s an issue for how naming conflicts are resolved (i.e- namespaces) IMO.<br></p><p>&gt; On 23 Jan 2016, at 16:25, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Many of Java&#39;s interfaces also conform to the standard swift uses, with things like runnable/comparable. Those define capabilities and are named with the same reasoning that the api guidelines propose, so it&#39;s easy to infer that they are interfaces from the name. I haven&#39;t worked in Java in a while so I could be forgetting other interfaces that don&#39;t follow this trend though, but interfaces in Java are more easily swapped with classes than protocols are in swift anyways (since protocols with associated types cannot be used as the type of a variable or whatnot).<br>&gt; <br>&gt; --<br>&gt; Kevin Lundberg<br>&gt; <br>&gt; On Jan 23, 2016, at 10:27 AM, Haravikk &lt;me at haravikk.com &lt;mailto:me at haravikk.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Since I learned object-oriented programming in Java, I never understood the need for suffixes and prefixes at all, as Java’s package system makes for very simple namespaces for everything in the event that simply using a class/interface name is unclear.<br>&gt;&gt; <br>&gt;&gt; I’d say that personally I don’t see why CollectionType shouldn’t just be Collection, in cases where several things are named Collection we should really have some kind of disambiguation mechanism anyway, perhaps with some special cases for specifying when you want a protocol rather than a class/struct.<br>&gt;&gt; <br>&gt;&gt; In my ideal world every language would would follow Java’s example on name-spaces, while avoiding emulating its horrific security record ;)<br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Jan 2016, at 14:52, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I never liked the convention of distinguishing between interfaces and classes by prepending an „I“ for interfaces in other languages and I’m not overly fond fond of the suffix „Type“ currently used in Swift protocols.<br>&gt;&gt;&gt; This is the same as prefixing (or suffixing) variable names with something to express their type, e.g. `String sName` or `int iLength`.<br>&gt;&gt;&gt; That’s what we have type information for. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And because of the substitution principle it should make no difference whether I have a protocol or a struct or class. What is a `CollectionType` vs. a `Collection`? Is it the type of a `Collection`, i.e. a meta type? Why not simply `Collection` if it describes what a collection is? <br>&gt;&gt;&gt; I guess its often more the problem of finding a suitable different name for the implementation and that’s why I sometimes wonder whether it might make sense to give protocols their own namespace…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short, I am not fond of the suffix „Type“ (but I would dislike the suffix „Protocol“ or prefixes like „I“ or „P“ even more).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m open to debate, though :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 23.01.2016 um 06:25 schrieb Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I personally like the idea behind the current convention for protocols that describe a thing (IntegerType, CollectionType, etc) where there is a suffix of Type appended to the end, so I give this specific part of the proposal a -1. The specific wording of the protocol&#39;s name is not so important as the recognition at a glance that this is a protocol vs a concrete type. I like being able to infer at a glance how I&#39;m expected to use a specific type reference based on its name alone; otherwise I may have to refer back to the type definition to refresh my memory of whether or not it is in fact a protocol or is something else.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change could also lead to confusion among some developers. For someone who is new to Swift, would they know they should use Bool over Boolean if they&#39;ve seen both types before? Both names look reasonable to store a boolean value, but the semantics of each type differ significantly. Someone may try to have a type conform to Bool instead of Boolean, which would obviously not work, but could cause some consternation for developers who don&#39;t know the difference by heart. Naming the protocol BooleanType at least calls out that this may not be conceptually the same as a plain boolean value, which could make a developer think twice before trying to use that over Bool.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Removing some common prefix from these kinds of protocols could also run the risk of unintentionally shadowing type names, if someone wanted to write their own Collection or Error struct or class for     instance, or if a pre-existing concrete type in their code turned out to unexpectedly shadow a protocol in a new dependency that they want to add. These situations would not cause any technical hiccups due to module namespacing, but it could lead to confusion when a developer forgets to qualify the name and tries to use one type where the other is expected.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In short, appending Type (or something like it) i think is a reasonable convention to keep around for non-behavioral protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As far as alternatives to &#39;Type&#39;, I personally don&#39;t like the suffix &#39;Protocol&#39; as much (which is suggested as a disambiguation option in the related standard library review), since &#39;Type&#39; is shorter, feels nicer to read, and describes the purpose of the protocol well to me. C#&#39;s approach of prefixing all interfaces with a capital I would be even more succinct, but I personally don&#39;t think that approach would     look nice to read either. (PCollection, PBoolean? Ick.) <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/b243e93d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>I courteously disagree. I believe adding Type makes it clear that this is a role that conforming to a protocol fulfills.<br></p><p>-- E<br></p><p><br>&gt; On Jan 23, 2016, at 1:25 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; True, though that’s partly an issue with Swift’s limitations on how certain types of protocols can be used (and I believe is the subject of another discussion, though the thread escapes me at the moment).<br>&gt; <br>&gt; Still, I don’t think that matters when it comes to naming them; I still think that things like CollectionType should just be the Collection protocol, since the fact that it’s a protocol makes it clear that its purpose is to define the requirements of a collection. If a class or struct then comes along that’s also called Collection then that’s an issue for how naming conflicts are resolved (i.e- namespaces) IMO.<br>&gt; <br>&gt;&gt; On 23 Jan 2016, at 16:25, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Many of Java&#39;s interfaces also conform to the standard swift uses, with things like runnable/comparable. Those define capabilities and are named with the same reasoning that the api guidelines propose, so it&#39;s easy to infer that they are interfaces from the name. I haven&#39;t worked in Java in a while so I could be forgetting other interfaces that don&#39;t follow this trend though, but interfaces in Java are more easily swapped with classes than protocols are in swift anyways (since protocols with associated types cannot be used as the type of a variable or whatnot).<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Kevin Lundberg<br>&gt;&gt; <br>&gt;&gt; On Jan 23, 2016, at 10:27 AM, Haravikk &lt;me at haravikk.com &lt;mailto:me at haravikk.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Since I learned object-oriented programming in Java, I never understood the need for suffixes and prefixes at all, as Java’s package system makes for very simple namespaces for everything in the event that simply using a class/interface name is unclear.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d say that personally I don’t see why CollectionType shouldn’t just be Collection, in cases where several things are named Collection we should really have some kind of disambiguation mechanism anyway, perhaps with some special cases for specifying when you want a protocol rather than a class/struct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my ideal world every language would would follow Java’s example on name-spaces, while avoiding emulating its horrific security record ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 23 Jan 2016, at 14:52, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I never liked the convention of distinguishing between interfaces and classes by prepending an „I“ for interfaces in other languages and I’m not overly fond fond of the suffix „Type“ currently used in Swift protocols.<br>&gt;&gt;&gt;&gt; This is the same as prefixing (or suffixing) variable names with something to express their type, e.g. `String sName` or `int iLength`.<br>&gt;&gt;&gt;&gt; That’s what we have type information for. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And because of the substitution principle it should make no difference whether I have a protocol or a struct or class. What is a `CollectionType` vs. a `Collection`? Is it the type of a `Collection`, i.e. a meta type? Why not simply `Collection` if it describes what a collection is? <br>&gt;&gt;&gt;&gt; I guess its often more the problem of finding a suitable different name for the implementation and that’s why I sometimes wonder whether it might make sense to give protocols their own namespace…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In short, I am not fond of the suffix „Type“ (but I would dislike the suffix „Protocol“ or prefixes like „I“ or „P“ even more).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m open to debate, though :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 23.01.2016 um 06:25 schrieb Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I personally like the idea behind the current convention for protocols that describe a thing (IntegerType, CollectionType, etc) where there is a suffix of Type appended to the end, so I give this specific part of the proposal a -1. The specific wording of the protocol&#39;s name is not so important as the recognition at a glance that this is a protocol vs a concrete type. I like being able to infer at a glance how I&#39;m expected to use a specific type reference based on its name alone; otherwise I may have to refer back to the type definition to refresh my memory of whether or not it is in fact a protocol or is something else.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This change could also lead to confusion among some developers. For someone who is new to Swift, would they know they should use Bool over Boolean if they&#39;ve seen both types before? Both names look reasonable to store a boolean value, but the semantics of each type differ significantly. Someone may try to have a type conform to Bool instead of Boolean, which would obviously not work, but could cause some consternation for developers who don&#39;t know the difference by heart. Naming the protocol BooleanType at least calls out that this may not be conceptually the same as a plain boolean value, which could make a developer think twice before trying to use that over Bool.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Removing some common prefix from these kinds of protocols could also run the risk of unintentionally shadowing type names, if someone wanted to write their own Collection or Error struct or class for instance, or if a pre-existing concrete type in their code turned out to unexpectedly shadow a protocol in a new dependency that they want to add. These situations would not cause any technical hiccups due to module namespacing, but it could lead to confusion when a developer forgets to qualify the name and tries to use one type where the other is expected.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In short, appending Type (or something like it) i think is a reasonable convention to keep around for non-behavioral protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As far as alternatives to &#39;Type&#39;, I personally don&#39;t like the suffix &#39;Protocol&#39; as much (which is suggested as a disambiguation option in the related standard library review), since &#39;Type&#39; is shorter, feels nicer to read, and describes the purpose of the protocol well to me. C#&#39;s approach of prefixing all interfaces with a capital I would be     even more succinct, but I personally don&#39;t think that approach would look nice to read either. (PCollection, PBoolean? Ick.) <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/b3e5f8a1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>Proposal link:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br></p><p>&gt; What is your evaluation of the proposal?<br></p><p>I think there are more things which would make a &quot;guidelines&quot; document even<br>better for promoting consistent code:<br></p><p>- When to use functions vs. properties for getters. The changes in SE-0006<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>include<br>&quot;func min()&quot; and &quot;var underestimatedCount&quot;. SE-0005<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>includes &quot;class func darkGray()&quot;. I imagine it should be implied that<br>properties are more efficient to compute, but this doesn&#39;t seem to be<br>applied consistently.<br></p><p>- Edge cases of naming, such as what to do with acronyms (like URL) when<br>they appear in function and variable names, especially at the beginning.<br></p><p>- When to use structs/classes/enums; when to use optionals; other such<br>basic API design topics.<br></p><p>While certainly not everything from the Coding Guidelines for Cocoa<br>&lt;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html&gt;<br>(linked from SE-0005) applies to Swift, the Swift guidelines would do well<br>to match its thoroughness.<br></p><p><br>    Protocols that describe what something is should read as nouns (e.g.<br>Collection).<br>    Protocols that describe a capability should be named using the suffixes<br>able, ible, or ing (e.g. Equatable, ProgressReporting).<br></p><p>&quot;SetAlgebra&quot; (from SE-0006) doesn&#39;t really fit in with this.<br></p><p><br>Extremely minor:<br>    text = &quot;The value is: &quot;<br>    text += String(veryLargeNumber)<br>    text += &quot; and in hexadecimal, it&#39;s&quot;<br>    text += String(veryLargeNumber, radix: 16)<br></p><p>The second string literal should have a space at the end as well as the<br>beginning.<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Having a set of guidelines is important.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>Fairly in-depth.<br></p><p>Jacob<br></p><p>On Fri, Jan 22, 2016 at 1:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through<br>&gt; January 31, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/dca5fa86/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>What is the rationale behind naming enumeration cases in upper camel case?<br></p><p>*Follow case conventions:* names of types, protocols and enum cases are<br>&gt; UpperCamelCase. Everything else is lowerCamelCase.<br></p><p><br>let a = NSComparisonResult.OrderedSame  // refers to a value, but is<br>upper-case<br>let b = NSDate.distantFuture            // refers to a property/value, but<br>is lower-case<br></p><p>   - everything related to types (type names, protocol names, generic type<br>   parameter names) should be upper camel case<br>   - everything else (function names, property names, variable names, etc.)<br>   should be lower camel case<br></p><p>This is already the current and the proposed recommendation with<br>enumeration cases being the only exception.<br>Enumeration cases are not types.<br></p><p><br>On Fri, Jan 22, 2016 at 10:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through<br>&gt; January 31, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/2df23eef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt; <br>&gt; Follow case conventions: names of types, protocols and enum cases areUpperCamelCase. Everything else is lowerCamelCase.<br>&gt; <br>&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is upper-case<br>&gt; let b = NSDate.distantFuture            // refers to a property/value, but is lower-case<br>&gt; everything related to types (type names, protocol names, generic type parameter names) should be upper camel case<br>&gt; everything else (function names, property names, variable names, etc.) should be lower camel case<br>&gt; This is already the current and the proposed recommendation with enumeration cases being the only exception.<br>&gt; Enumeration cases are not types.<br></p><p>I agree. It would make enum cases feel more consistent with the rest of the language to make them lowerCamelCase.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/f98a34a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 23, 2016 at 01:00:00pm</p></header><div class="content"><p>I think it makes sense for enum cases to be UpperCamelCase as they can be<br>thought of as scoped types (singleton types in the case of cases with no<br>associated types).<br></p><p>Option set elements, on the other hand, I think really are values so it may<br>make sense for those to be lowerCamelCase.<br></p><p>On Sat, Jan 23, 2016 at 1:11 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt;<br>&gt; *Follow case conventions:* names of types, protocols and enum cases are<br>&gt;&gt; UpperCamelCase. Everything else is lowerCamelCase.<br>&gt;<br>&gt;<br>&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is<br>&gt; upper-case<br>&gt; let b = NSDate.distantFuture            // refers to a property/value, but<br>&gt; is lower-case<br>&gt;<br>&gt;    - everything related to types (type names, protocol names, generic<br>&gt;    type parameter names) should be upper camel case<br>&gt;    - everything else (function names, property names, variable names,<br>&gt;    etc.) should be lower camel case<br>&gt;<br>&gt; This is already the current and the proposed recommendation with<br>&gt; enumeration cases being the only exception.<br>&gt; Enumeration cases are not types.<br>&gt;<br>&gt;<br>&gt; I agree. It would make enum cases feel more consistent with the rest of<br>&gt; the language to make them lowerCamelCase.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/981c7b27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>January 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 1:24 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br></p><p>This reasoning makes sense to me. It&#39;s also a convention that I&#39;ve seen on other languages like Java and C# where enum cases are capitalized even though they aren&#39;t strictly types of their own.<br></p><p>&gt; Option set elements, on the other hand, I think really are values so it may make sense for those to be lowerCamelCase.<br></p><p>I think of option set elements in the same way as enums here, where each option set option can behave as an individual singleton type that represents a specific value. The way they&#39;re used reminds me a lot of how enums are typically used, just with multiple instances at once in a set instead of a single enum case.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 11:45 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 1:24 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br>&gt; <br>&gt; This reasoning makes sense to me. It&#39;s also a convention that I&#39;ve seen on other languages like Java and C# where enum cases are capitalized even though they aren&#39;t strictly types of their own.<br></p><p>In Java they are final, singleton class instances. If Boolean for example had been retrofitted to be an enum, there would be a single instance of Boolean.False in the system.<br></p><p>In Swift, enums are a union value type. Every “false” in swift is a new instance of the Bool enum. Bool.False is effectively a static read-only property. For enum cases like Optional.Some  which have associated data, Optional.Some is effectively a static factory method.<br></p><p>&gt; <br>&gt; I think of option set elements in the same way as enums here, where each option set option can behave as an individual singleton type that represents a specific value. The way they&#39;re used reminds me a lot of how enums are typically used, just with multiple instances at once in a set instead of a single enum case.<br></p><p><br>Having static properties and methods be lower camel case and enum cases be upper camel case is inconsistent. There really is nothing special about enum cases over static members, except that switch statements know how to be comprehensive.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>The question is whether enumeration cases are more type-like or more member-like. I lean towards agreeing with<br>Trent and Kevin, especially with associated values.<br></p><p>&gt; On Jan 23, 2016, at 4:34 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 11:45 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 1:24 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br>&gt;&gt; <br>&gt;&gt; This reasoning makes sense to me. It&#39;s also a convention that I&#39;ve seen on other languages like Java and C# where enum cases are capitalized even though they aren&#39;t strictly types of their own.<br>&gt; <br>&gt; In Java they are final, singleton class instances. If Boolean for example had been retrofitted to be an enum, there would be a single instance of Boolean.False in the system.<br>&gt; <br>&gt; In Swift, enums are a union value type. Every “false” in swift is a new instance of the Bool enum. Bool.False is effectively a static read-only property. For enum cases like Optional.Some  which have associated data, Optional.Some is effectively a static factory method.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think of option set elements in the same way as enums here, where each option set option can behave as an individual singleton type that represents a specific value. The way they&#39;re used reminds me a lot of how enums are typically used, just with multiple instances at once in a set instead of a single enum case.<br>&gt; <br>&gt; <br>&gt; Having static properties and methods be lower camel case and enum cases be upper camel case is inconsistent. There really is nothing special about enum cases over static members, except that switch statements know how to be comprehensive.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>January 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I am used to enum cases being UpperCamelCase from Java, although sometimes I’ve seen them in all caps.  I think of enum cases as their own type even though they are a member of the enum type.  <br></p><p>It is similar to inner classes in Java for example.  I would not like enum cases to be lowerCamelCase.<br></p><p><br>&gt; On Jan 23, 2016, at 1:45 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 1:24 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br>&gt; <br>&gt; This reasoning makes sense to me. It&#39;s also a convention that I&#39;ve seen on other languages like Java and C# where enum cases are capitalized even though they aren&#39;t strictly types of their own.<br>&gt; <br>&gt;&gt; Option set elements, on the other hand, I think really are values so it may make sense for those to be lowerCamelCase.<br>&gt; <br>&gt; I think of option set elements in the same way as enums here, where each option set option can behave as an individual singleton type that represents a specific value. The way they&#39;re used reminds me a lot of how enums are typically used, just with multiple instances at once in a set instead of a single enum case.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>Java enums are actually new subclasses (with a singleton instance).<br></p><p>However, the problem is one of consistency. How do you explain to developers the intuition behind these statements and the choice of UpperCamelCase vs lowerCamelCase?<br></p><p>import Foundation<br>import UIKit<br></p><p>let w:NSComparisonResult    = .OrderedAscending<br>let x:UnicodeDecodingResult = .Result(&quot;☃&quot;)<br>let y:UIRectEdge            = .Top<br>let z:CGPoint               = .zero<br></p><p><br>-DW<br>&gt; On Jan 28, 2016, at 4:28 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I am used to enum cases being UpperCamelCase from Java, although sometimes I’ve seen them in all caps.  I think of enum cases as their own type even though they are a member of the enum type.  <br>&gt; <br>&gt; It is similar to inner classes in Java for example.  I would not like enum cases to be lowerCamelCase.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 1:45 PM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 1:24 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br>&gt;&gt; <br>&gt;&gt; This reasoning makes sense to me. It&#39;s also a convention that I&#39;ve seen on other languages like Java and C# where enum cases are capitalized even though they aren&#39;t strictly types of their own.<br>&gt;&gt; <br>&gt;&gt;&gt; Option set elements, on the other hand, I think really are values so it may make sense for those to be lowerCamelCase.<br>&gt;&gt; <br>&gt;&gt; I think of option set elements in the same way as enums here, where each option set option can behave as an individual singleton type that represents a specific value. The way they&#39;re used reminds me a lot of how enums are typically used, just with multiple instances at once in a set instead of a single enum case.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/7314494e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br></p><p>They aren&#39;t, though. I don&#39;t see much value in setting false expectations.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 23, 2016 at 01:00:00pm</p></header><div class="content"><p>While enum cases may not be types from a compiler perspective, I think they<br>are from a user&#39;s level.<br></p><p>Consider:<br></p><p>enum MyError: ErrorType {<br>    case FileError(fileName: String)<br>    case SocketError(ipAddr: String, port: Int16)<br>}<br></p><p>&gt;From a compiler perspective, it&#39;s a tagged union (one type), but for a user<br>this is a set of disjoint types that happen to share the same space and<br>have exhaustiveness checking, etc. It&#39;s a much more efficient and<br>convenient version of multiple structs or tuples.<br></p><p>On Sat, Jan 23, 2016 at 1:49 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think it makes sense for enum cases to be UpperCamelCase as they can<br>&gt; be thought of as scoped types (singleton types in the case of cases with no<br>&gt; associated types).<br>&gt;<br>&gt; They aren&#39;t, though. I don&#39;t see much value in setting false expectations.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/67820b27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 24, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, I think they are a lot like sum (or union) types. In Ceylon enums actually are modeled as union types (there is no specific enum syntax).<br></p><p>-Thorsten<br></p><p><br>&gt; Am 23.01.2016 um 19:57 schrieb Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; While enum cases may not be types from a compiler perspective, I think they are from a user&#39;s level.<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt;     case FileError(fileName: String)<br>&gt;     case SocketError(ipAddr: String, port: Int16)<br>&gt; }<br>&gt; <br>&gt; From a compiler perspective, it&#39;s a tagged union (one type), but for a user this is a set of disjoint types that happen to share the same space and have exhaustiveness checking, etc. It&#39;s a much more efficient and convenient version of multiple structs or tuples.<br>&gt; <br>&gt; On Sat, Jan 23, 2016 at 1:49 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br>&gt; <br>&gt; They aren&#39;t, though. I don&#39;t see much value in setting false expectations.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/43a579e3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>What about enums with associated data? Those really are like types. So do we capitalize those? <br></p><p>Unless those get redesigned, there is really this contrary feel to those and other enum cases. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 23, 2016, at 10:49 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think it makes sense for enum cases to be UpperCamelCase as they can be thought of as scoped types (singleton types in the case of cases with no associated types).<br>&gt; <br>&gt; They aren&#39;t, though. I don&#39;t see much value in setting false expectations.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 11:01 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; What about enums with associated data? Those really are like types. So do we capitalize those?<br>&gt; <br>&gt; Unless those get redesigned, there is really this contrary feel to those and other enum cases. <br></p><p>Before open sourcing, I had written up some thoughts on this:<br></p><p>https://github.com/apple/swift/blob/master/docs/proposals/EnumStyle.rst<br></p><p>From an API perspective, an enum &#39;case&#39; behaves similarly to a factory method or initializer on a struct or class, and in native Swift we generally prefer `init`s to static factory methods when possible. We also see a lot of API design in the wild where framework authors paper over the enum-ness of their API enums with initializers:<br></p><p>enum Result&lt;T&gt; {<br>  case Success(T)<br>  case Error(ErrorType)<br></p><p>  init(success: T) { self = .Success(success) }<br>  init(error: ErrorType) { self = .Error(error) }<br>}<br></p><p>We hadn&#39;t settled on our argument label model when we originally designed and implemented enums; I feel like if we had, it&#39;s likely we would have favored cases that natively look and feel more like initializers, using labels to distinguish cases:<br></p><p>enum Result&lt;T&gt; {<br>  case (success: T)<br>  case (error: ErrorType)<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/a158369a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>+1 on the CamelCase. Just so y’all know, though, there’s a bug in the complier involving naming collisions between cases and types. Currently (Xcode 7.2), case labels silently override type names, leading to the following error:<br>enum Foo {<br>    case Int            // Ok<br>    case Something(Int) // “Error: Use of undeclared type &#39;Int&#39;&quot;<br>    case Float(Double)  // Ok<br>}<br></p><p>That should probably get fixed *before* the API design guidelines start recommending that case labels begin with uppercase letters. (I mean, it should get fixed anyway, but it should especially get fixed before we start encouraging behavior which makes it easier to encounter.)<br></p><p>- Dave Sweeris<br></p><p>On Jan 23, 2016, at 11:18 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; <br>&gt;&gt; On Jan 23, 2016, at 11:01 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about enums with associated data? Those really are like types. So do we capitalize those?<br>&gt;&gt; <br>&gt;&gt; Unless those get redesigned, there is really this contrary feel to those and other enum cases. <br>&gt; <br>&gt; Before open sourcing, I had written up some thoughts on this:<br>&gt; <br>&gt; https://github.com/apple/swift/blob/master/docs/proposals/EnumStyle.rst &lt;https://github.com/apple/swift/blob/master/docs/proposals/EnumStyle.rst&gt;<br>&gt; <br>&gt; From an API perspective, an enum &#39;case&#39; behaves similarly to a factory method or initializer on a struct or class, and in native Swift we generally prefer `init`s to static factory methods when possible. We also see a lot of API design in the wild where framework authors paper over the enum-ness of their API enums with initializers:<br>&gt; <br>&gt; enum Result&lt;T&gt; {<br>&gt;   case Success(T)<br>&gt;   case Error(ErrorType)<br>&gt; <br>&gt;   init(success: T) { self = .Success(success) }<br>&gt;   init(error: ErrorType) { self = .Error(error) }<br>&gt; }<br>&gt; <br>&gt; We hadn&#39;t settled on our argument label model when we originally designed and implemented enums; I feel like if we had, it&#39;s likely we would have favored cases that natively look and feel more like initializers, using labels to distinguish cases:<br>&gt; <br>&gt; enum Result&lt;T&gt; {<br>&gt;   case (success: T)<br>&gt;   case (error: ErrorType)<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/02d0195d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 12:55 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 on the CamelCase. Just so y’all know, though, there’s a bug in the complier involving naming collisions between cases and types. Currently (Xcode 7.2), case labels silently override type names, leading to the following error:<br>&gt; enum Foo {<br>&gt;     case Int            // Ok<br>&gt;     case Something(Int) // “Error: Use of undeclared type &#39;Int&#39;&quot;<br>&gt;     case Float(Double)  // Ok<br>&gt; }<br>&gt; <br></p><p>The error could read better, but the compiler is IMO working properly.<br></p><p>The standard library is an implicitly loaded module called Swift:<br></p><p>enum Foo {<br>    case Int            // Ok<br>    case Something(Swift.Int) // Ok<br>    case Float(Double)  // Ok<br>}<br></p><p>-DW <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/8ce8b4ab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 23, 2016 at 04:00:00pm</p></header><div class="content"><p>API guidelines should probably be consistent about enum cases and static let properties<br></p><p>I’ve been naming my &#39;static let’s in UpperCamelCase to match the convention of enums, because I often use them the same way in code. But standard types do differently, e.g.<br></p><p>var initialPoint:CGPoint = .zero<br></p><p>-DW<br></p><p><br>&gt; On Jan 23, 2016, at 11:11 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt;&gt; <br>&gt;&gt; Follow case conventions: names of types, protocols and enum cases areUpperCamelCase. Everything else islowerCamelCase.<br>&gt;&gt; <br>&gt;&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is upper-case<br>&gt;&gt; let b = NSDate.distantFuture            // refers to a property/value, but is lower-case<br>&gt;&gt; everything related to types (type names, protocol names, generic type parameter names) should be upper camel case<br>&gt;&gt; everything else (function names, property names, variable names, etc.) should be lower camel case<br>&gt;&gt; This is already the current and the proposed recommendation with enumeration cases being the only exception.<br>&gt;&gt; Enumeration cases are not types.<br>&gt; <br>&gt; I agree. It would make enum cases feel more consistent with the rest of the language to make them lowerCamelCase.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/08b3decb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>I am a fan of uppercasing global constants and functions. However, you are the only human on earth<br>that I have yet encountered who embraces even a slight part of this.<br></p><p>It&#39;s a battle I gave up on.<br></p><p>-- E<br></p><p><br>&gt; On Jan 23, 2016, at 4:25 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; API guidelines should probably be consistent about enum cases and static let properties<br>&gt; <br>&gt; I’ve been naming my &#39;static let’s in UpperCamelCase to match the convention of enums, because I often use them the same way in code. But standard types do differently, e.g.<br>&gt; <br>&gt; var initialPoint:CGPoint = .zero<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 11:11 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Follow case conventions: names of types, protocols and enum cases areUpperCamelCase. Everything else islowerCamelCase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is upper-case<br>&gt;&gt;&gt; let b = NSDate.distantFuture            // refers to a property/value, but is lower-case<br>&gt;&gt;&gt; everything related to types (type names, protocol names, generic type parameter names) should be upper camel case<br>&gt;&gt;&gt; everything else (function names, property names, variable names, etc.) should be lower camel case<br>&gt;&gt;&gt; This is already the current and the proposed recommendation with enumeration cases being the only exception.<br>&gt;&gt;&gt; Enumeration cases are not types.<br>&gt;&gt; <br>&gt;&gt; I agree. It would make enum cases feel more consistent with the rest of the language to make them lowerCamelCase.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/906f4830/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 23, 2016 at 06:00:00pm</p></header><div class="content"><p>I’m not committed one way or another on particular style, as long as it is either consistent or there is a clear line drawn.<br></p><p>-DW<br></p><p>&gt; On Jan 23, 2016, at 5:43 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I am a fan of uppercasing global constants and functions. However, you are the only human on earth<br>&gt; that I have yet encountered who embraces even a slight part of this.<br>&gt; <br>&gt; It&#39;s a battle I gave up on.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 4:25 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; API guidelines should probably be consistent about enum cases and static let properties<br>&gt;&gt; <br>&gt;&gt; I’ve been naming my &#39;static let’s in UpperCamelCase to match the convention of enums, because I often use them the same way in code. But standard types do differently, e.g.<br>&gt;&gt; <br>&gt;&gt; var initialPoint:CGPoint = .zero<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 11:11 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Follow case conventions: names of types, protocols and enum cases areUpperCamelCase. Everything else islowerCamelCase.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is upper-case<br>&gt;&gt;&gt;&gt; let b = NSDate.distantFuture            // refers to a property/value, but is lower-case<br>&gt;&gt;&gt;&gt; everything related to types (type names, protocol names, generic type parameter names) should be upper camel case<br>&gt;&gt;&gt;&gt; everything else (function names, property names, variable names, etc.) should be lower camel case<br>&gt;&gt;&gt;&gt; This is already the current and the proposed recommendation with enumeration cases being the only exception.<br>&gt;&gt;&gt;&gt; Enumeration cases are not types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree. It would make enum cases feel more consistent with the rest of the language to make them lowerCamelCase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/ac58efff/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt; <br>&gt; Follow case conventions: names of types, protocols and enum cases areUpperCamelCase. Everything else is lowerCamelCase.<br>&gt; <br>&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is upper-case<br>&gt; let b = NSDate.distantFuture            // refers to a property/value, but is lower-case<br>&gt; everything related to types (type names, protocol names, generic type parameter names) should be upper camel case<br>&gt; everything else (function names, property names, variable names, etc.) should be lower camel case<br>&gt; This is already the current and the proposed recommendation with enumeration cases being the only exception.<br>&gt; Enumeration cases are not types.<br></p><p>This is something that’s come up a few times before, and I (personally) agree that it makes more sense for enum cases to be lowerCamelCase. Thanks for bringing it up!<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 10:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/a3c9d111/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 10:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 23, 2016, at 2:12 AM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What is the rationale behind naming enumeration cases in upper camel case?<br>&gt;&gt; <br>&gt;&gt; Follow case conventions: names of types, protocols and enum cases areUpperCamelCase. Everything else is lowerCamelCase.<br>&gt;&gt; <br>&gt;&gt; let a = NSComparisonResult.OrderedSame  // refers to a value, but is upper-case<br>&gt;&gt; let b = NSDate.distantFuture            // refers to a property/value, but is lower-case<br>&gt;&gt; everything related to types (type names, protocol names, generic type parameter names) should be upper camel case<br>&gt;&gt; everything else (function names, property names, variable names, etc.) should be lower camel case<br>&gt;&gt; This is already the current and the proposed recommendation with enumeration cases being the only exception.<br>&gt;&gt; Enumeration cases are not types.<br>&gt; <br>&gt; This is something that’s come up a few times before, and I (personally) agree that it makes more sense for enum cases to be lowerCamelCase. Thanks for bringing it up!<br></p><p>I agree as well.  Enum cases are values (not types) by every measure I know of.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/4da43377/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>This all looks good to me (aside from the linguistic problems with verb conjugation I&#39;ve raised in another subthread). However, I think these naming guidelines lead us to reconsider our default argument labeling rules for &#39;func&#39; declarations again, as David Owens and others have suggested. The stated goal of the current language rule is to guide people into good API design following our conventions, but I don&#39;t think it succeeds in serving that purpose. If you follow the guidelines, the argument labels for your secondary arguments generally end up becoming prepositional phrases, which make for poor variable names, and you&#39;re naturally guided to giving the argument an explicit descriptive binding name:<br></p><p>func perform(stuff: Stuff, with: Thing) {<br>  with.apply(stuff) // &#39;with&#39; is a weird variable name<br>}<br></p><p>func perform(stuff: Stuff, with thing: Thing) {<br>  thing.apply(stuff) // &#39;thing&#39; is better<br>}<br></p><p>The shorthand thus doesn&#39;t save the good API citizen from much work. On the other hand, a developer who&#39;s unaware or uninterested in the guidelines and is just trying to C or Java in Swift gets argument labels by default that neither follow the guidelines nor meet their expectation:<br></p><p>func atan2(y: Double, x: Double) -&gt; Double { ... }<br></p><p>atan2(10, 10) // Why doesn&#39;t this work?<br>atan2(10, x: 10) // Nobody wants this<br></p><p>And when staring down potentially dozens or hundreds of compile errors at various mismatched use sites, they&#39;re unlikely to reconsider their API naming choice, and will instead do the minimal amount of work to get their code to compile by suppressing the argument label. The language hasn&#39;t led this developer to better conventional API design either.<br></p><p>I can think of a couple possible modifications to the language rule that could help reduce the surprise factor, and still lead people to good API design:<br></p><p>- Require all &#39;func&#39; arguments after the first to explicitly specify both a label and a binding name. Users following the guidelines will usually end up doing this anyway, and users who aren&#39;t will get a helpful message instead of unexpected behavior. This also avoids a problem with our current rule, where otherwise identical-looking parameter declarations in a &#39;func&#39; end up behaving differently based on position. A diagnostic immediately at the declaration site also seems more likely to me to lead the developer to think more about their API naming; diagnosing call sites that don&#39;t look the way they want is just going to lead them to reactively suppress the labels to get their code to compile.<br>- Change the default rule so that all arguments *after an explicitly labeled argument* default to being labeled (instead of all arguments after the first). It&#39;s unlikely anyone wants an unlabeled argument positionally after a labeled one, and the rare methods in Cocoa that take more than two arguments do tend to use noun rather than preposition phrases for arguments after the second. Users following the guidelines get nice labeled APIs, and users who aren&#39;t get the bare, uncaring anonymous arguments they deserve:<br></p><p>func perform(stuff: Stuff, with thing: Thing, options: StuffOptions) // perform(_:with:options:)<br>func atan2(y: Double, x: Double) // atan2(_:_:)<br></p><p>-Joe<br></p><p>&gt; On Jan 22, 2016, at 1:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/fda66c46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 23, 2016 at 09:00:00pm</p></header><div class="content"><p>I think Joe&#39;s reply is a pretty good summary.<br></p><p>At a high-level, I really get no sense on how APIs are really supposed to be developed in Swift. Joe talks about second arguments generally becoming prepositional phrases, but is that the true intent? Because that&#39;s not what the guideline says, nor what the language semantics really promote or suggest to do.<br></p><p>For example, the guidelines say to do one thing but the example does something different:<br></p><p>&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt; <br>&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a fundamental type such Int or String, type information and context at the point of use may not fully convey intent. In this example, the declaration may be clear, but the use site is vague:<br>&gt; <br>&gt; func add(observer: NSObject, for keyPath: String)<br>&gt; grid.add(self, for: graphics)<br>&gt; <br>&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt; <br>&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br></p><p>This example already had a &quot;for&quot; in the label, but if it were not already there, the API, according to the guidelines, should become this:<br></p><p>func addObserver(_ observer: NSObject, keyPath path: String)<br>grid.addObserver(self, keyPath: graphics) // clear<br></p><p>Especially when compared with the ObjC import items. Seemingly, the ObjC APIs would be using prepositional clauses for parameter labels while the Swift labels would simply be more descriptive nouns.<br></p><p>The rules I described are keeping in strict guidance to the API design guidelines of adding nouns. So the above would actually be:<br></p><p>func add(observer o: NSObject, keyPath path: String)<br>grid.add(observer: self, keyPath: graphics)<br></p><p>However, if the API guidelines are really about creating APIs that are to be read in a more English-like manner, like ObjC APIs are designed, then the guidelines should really be amended to make that clear.<br></p><p>If the intention is truly that Swift APIs are supposed to read as naturally as ObjC APIs, then I completely agree with Joe that there should be a language change to actually require the label for parameters.<br></p><p>func addObserver(o: NSObject, path: String) // error: Argument label required for `path`.<br></p><p>However, this pattern of using prepositional phrases is still going to be in contradiction when using init(). <br></p><p>let items = Array&lt;Int&gt;(capacityOf: 12, filledWith: 10)<br></p><p>// vs<br></p><p>let items = Array&lt;Int&gt;(count: 12, repeatedValue: 10)<br></p><p>The difference is that init has a much tighter coupling with direct sets to properties on the type. <br></p><p>So yeah... basic story is, even after using Swift since its been released, I still have no clear sense of what a Swift API should look like, and the guidelines don&#39;t bring any of that clarity that I&#39;m missing to the table. At the end of the day, Swift chose a C-style pattern which actively dissuades API authors from building the more fluid types of APIs we have in ObjC; there&#39;s simply more sigils in the way to break up a natural reading of the API.<br></p><p>grid.addObserver(self, forKeyPath: graphics)<br></p><p>// vs<br></p><p>[grid addObserver:self forKeyPath:graphics]<br></p><p>All of my inclinations for C-style syntactical languages say the API should be (in order of my conceptual preference model):<br></p><p>grid.add(observer: self, keyPath: graphics)<br></p><p>// or<br></p><p>grid.addObserver(self, keyPath: graphics)<br></p><p>// or<br></p><p>grid.addObserver(self, graphics)<br></p><p>And then take this proposed change to a Swift based on guideline updates:<br></p><p> extension Strideable {<br></p><p>-  public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>+  public func strideThrough(end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br></p><p> }<br></p><p>In what part of the guidelines does it say that we should &quot;by&quot; as the argument label? The stride parameter does not have a lack of type information; in fact, it&#39;s quite strong. The call site *is* arguably better with &quot;by&quot; vs. &quot;stride&quot;. However, &quot;stride&quot; is not missing context on type information or role specificity. <br></p><p>I guess I&#39;m starting to ramble on here, so I&#39;ll stop now...<br></p><p>-David<br></p><p>&gt; On Jan 23, 2016, at 10:45 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; This all looks good to me (aside from the linguistic problems with verb conjugation I&#39;ve raised in another subthread). However, I think these naming guidelines lead us to reconsider our default argument labeling rules for &#39;func&#39; declarations again, as David Owens and others have suggested. The stated goal of the current language rule is to guide people into good API design following our conventions, but I don&#39;t think it succeeds in serving that purpose. If you follow the guidelines, the argument labels for your secondary arguments generally end up becoming prepositional phrases, which make for poor variable names, and you&#39;re naturally guided to giving the argument an explicit descriptive binding name:<br>&gt; <br>&gt; func perform(stuff: Stuff, with: Thing) {<br>&gt;   with.apply(stuff) // &#39;with&#39; is a weird variable name<br>&gt; }<br>&gt; <br>&gt; func perform(stuff: Stuff, with thing: Thing) {<br>&gt;   thing.apply(stuff) // &#39;thing&#39; is better<br>&gt; }<br>&gt; <br>&gt; The shorthand thus doesn&#39;t save the good API citizen from much work. On the other hand, a developer who&#39;s unaware or uninterested in the guidelines and is just trying to C or Java in Swift gets argument labels by default that neither follow the guidelines nor meet their expectation:<br>&gt; <br>&gt; func atan2(y: Double, x: Double) -&gt; Double { ... }<br>&gt; <br>&gt; atan2(10, 10) // Why doesn&#39;t this work?<br>&gt; atan2(10, x: 10) // Nobody wants this<br>&gt; <br>&gt; And when staring down potentially dozens or hundreds of compile errors at various mismatched use sites, they&#39;re unlikely to reconsider their API naming choice, and will instead do the minimal amount of work to get their code to compile by suppressing the argument label. The language hasn&#39;t led this developer to better conventional API design either.<br>&gt; <br>&gt; I can think of a couple possible modifications to the language rule that could help reduce the surprise factor, and still lead people to good API design:<br>&gt; <br>&gt; - Require all &#39;func&#39; arguments after the first to explicitly specify both a label and a binding name. Users following the guidelines will usually end up doing this anyway, and users who aren&#39;t will get a helpful message instead of unexpected behavior. This also avoids a problem with our current rule, where otherwise identical-looking parameter declarations in a &#39;func&#39; end up behaving differently based on position. A diagnostic immediately at the declaration site also seems more likely to me to lead the developer to think more about their API naming; diagnosing call sites that don&#39;t look the way they want is just going to lead them to reactively suppress the labels to get their code to compile.<br>&gt; - Change the default rule so that all arguments *after an explicitly labeled argument* default to being labeled (instead of all arguments after the first). It&#39;s unlikely anyone wants an unlabeled argument positionally after a labeled one, and the rare methods in Cocoa that take more than two arguments do tend to use noun rather than preposition phrases for arguments after the second. Users following the guidelines get nice labeled APIs, and users who aren&#39;t get the bare, uncaring anonymous arguments they deserve:<br>&gt; <br>&gt; func perform(stuff: Stuff, with thing: Thing, options: StuffOptions) // perform(_:with:options:)<br>&gt; func atan2(y: Double, x: Double) // atan2(_:_:)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d7fdf801/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 10:45 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; This all looks good to me (aside from the linguistic problems with verb conjugation I&#39;ve raised in another subthread). However, I think these naming guidelines lead us to reconsider our default argument labeling rules for &#39;func&#39; declarations again, as David Owens and others have suggested. The stated goal of the current language rule is to guide people into good API design following our conventions, but I don&#39;t think it succeeds in serving that purpose. If you follow the guidelines, the argument labels for your secondary arguments generally end up becoming prepositional phrases, which make for poor variable names, and you&#39;re naturally guided to giving the argument an explicit descriptive binding name:<br>&gt; <br>&gt; func perform(stuff: Stuff, with: Thing) {<br>&gt;   with.apply(stuff) // &#39;with&#39; is a weird variable name<br>&gt; }<br>&gt; <br>&gt; func perform(stuff: Stuff, with thing: Thing) {<br>&gt;   thing.apply(stuff) // &#39;thing&#39; is better<br>&gt; }<br></p><p>I don’t understand how you came to the conclusion that secondary arguments generally end up becoming prepositional phrases. I know you’re using abstract examples, but the “with” in your example above is essentially vacuous. Indeed, the Clang importer rules of SE-0005 won’t allow us to prune argument labels if the result is just “with” (or “for”, or one of a few other vacuous words). I would expect the API above to use:<br></p><p>	func perform(stuff: Stuff, thing: Thing) {<br></p><p>Now, meaningful prepositions do show up sometimes as the argument label. For example<br></p><p>	func insert(x: Element, at index: Index)<br></p><p>but this case doesn’t seem like the dominant case it all: you’re often just describing what the argument is rather than its relationship to the operation, and it only can be “just a preposition” if any word you add to clarify the role of the parameter would be redundant with the type information.<br></p><p>&gt; The shorthand thus doesn&#39;t save the good API citizen from much work. On the other hand, a developer who&#39;s unaware or uninterested in the guidelines and is just trying to C or Java in Swift gets argument labels by default that neither follow the guidelines nor meet their expectation:<br>&gt; <br>&gt; func atan2(y: Double, x: Double) -&gt; Double { ... }<br>&gt; <br>&gt; atan2(10, 10) // Why doesn&#39;t this work?<br>&gt; atan2(10, x: 10) // Nobody wants this<br>&gt; <br>&gt; And when staring down potentially dozens or hundreds of compile errors at various mismatched use sites, they&#39;re unlikely to reconsider their API naming choice, and will instead do the minimal amount of work to get their code to compile by suppressing the argument label.<br></p><p>*Any* refactoring tool for Swift should be able to handle renaming argument labels, so this shouldn’t be any more painful that your typical rename.<br></p><p>&gt; The language hasn&#39;t led this developer to better conventional API design either.<br>&gt; <br>&gt; I can think of a couple possible modifications to the language rule that could help reduce the surprise factor, and still lead people to good API design:<br>&gt; <br>&gt; - Require all &#39;func&#39; arguments after the first to explicitly specify both a label and a binding name. Users following the guidelines will usually end up doing this anyway, and users who aren&#39;t will get a helpful message instead of unexpected behavior. This also avoids a problem with our current rule, where otherwise identical-looking parameter declarations in a &#39;func&#39; end up behaving differently based on position. A diagnostic immediately at the declaration site also seems more likely to me to lead the developer to think more about their API naming; diagnosing call sites that don&#39;t look the way they want is just going to lead them to reactively suppress the labels to get their code to compile.<br></p><p>Obviously, I’d be concerned about us introducing a significant amount of boilerplate by doing this. We could determine just how much boilerplate this would be added by proxy: how many second-or-later parameters in Objective-C methods have the same identifier as the corresponding selector piece? If it’s a significant fraction, then this kind of change becomes hard to justify.<br></p><p>&gt; - Change the default rule so that all arguments *after an explicitly labeled argument* default to being labeled (instead of all arguments after the first). It&#39;s unlikely anyone wants an unlabeled argument positionally after a labeled one, and the rare methods in Cocoa that take more than two arguments do tend to use noun rather than preposition phrases for arguments after the second. Users following the guidelines get nice labeled APIs, and users who aren&#39;t get the bare, uncaring anonymous arguments they deserve:<br>&gt; <br>&gt; func perform(stuff: Stuff, with thing: Thing, options: StuffOptions) // perform(_:with:options:)<br>&gt; func atan2(y: Double, x: Double) // atan2(_:_:)<br></p><p>It seems to me that this nudges us toward less-readable call sites, with anonymous arguments dominating simply because it’s the easy thing. It’s more motivating to fix a poor API decision (i.e., a bad argument label) if you’re seeing it at each and every call site...<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/41e82626/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 11:10 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 23, 2016, at 10:45 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This all looks good to me (aside from the linguistic problems with verb conjugation I&#39;ve raised in another subthread). However, I think these naming guidelines lead us to reconsider our default argument labeling rules for &#39;func&#39; declarations again, as David Owens and others have suggested. The stated goal of the current language rule is to guide people into good API design following our conventions, but I don&#39;t think it succeeds in serving that purpose. If you follow the guidelines, the argument labels for your secondary arguments generally end up becoming prepositional phrases, which make for poor variable names, and you&#39;re naturally guided to giving the argument an explicit descriptive binding name:<br>&gt;&gt; <br>&gt;&gt; func perform(stuff: Stuff, with: Thing) {<br>&gt;&gt;   with.apply(stuff) // &#39;with&#39; is a weird variable name<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func perform(stuff: Stuff, with thing: Thing) {<br>&gt;&gt;   thing.apply(stuff) // &#39;thing&#39; is better<br>&gt;&gt; }<br>&gt; <br>&gt; I don’t understand how you came to the conclusion that secondary arguments generally end up becoming prepositional phrases.<br></p><p>This might be Cocoa bias leaking through, but nearly every example in the proposal that has secondary labeled arguments uses a prepositional phrase for them, aside from special cases like defaulted arguments. Prepositional phrases also fall naturally from the &quot;be grammatical&quot; and &quot;clarity at the point of use&quot; admonitions. If you don&#39;t think this is representative of your intent, then you might need to make the showcased examples more diverse.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/a12fd777/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 24, 2016 at 02:00:00pm</p></header><div class="content"><p>I really like the general spirit of these guidelines. I particularly appreciate their emphasis on clarity at the point of use, and their recognition that both brevity and verbosity can be the enemy of clarity.<br></p><p>Some of the particulars of the guidelines haven’t worked well for me in practice — and I see from this thread that others have hit some of the same problems. The guidelines as they stand feel like they’ve mostly been vetted against a bunch of ADTs (which is probably true — stdlib?), and could use exposure to a broader range of libraries.<br></p><p>Immediately after the guidelines were published, before this review began, I tried applying them to Siesta. The project has 244 public declarations, of which I found 28 that the guidelines seemed to recommend changing. Of those 28, after much reflection and discussion, I ended up changing only 7 to match the guidelines (and also cleaning up several others, but in a non-guideline-compliant way).<br></p><p>In short, in a real-world project, pre-guidelines code agreed with the guidelines 89% of the time, but where it disagreed, the guidelines achieved only a 25% acceptance rate with the curmudgeonly developers.<br></p><p>You can follow that discussion here:<br></p><p>	https://gist.github.com/pcantrell/22a6564ca7d22789315b &lt;https://gist.github.com/pcantrell/22a6564ca7d22789315b&gt;<br>	https://github.com/bustoutsolutions/siesta/issues/15 &lt;https://github.com/bustoutsolutions/siesta/issues/15&gt;<br></p><p>Several places where we rejected the guidelines relate to the raging debate about first argument labels. Here’s a rundown of those particular cases. (Since this message will be a long one, I’ll share in a separate message some notes on the other places where we rejected the guidelines on questions other than the first arg label.)<br></p><p>Hopefully some more concrete examples can be useful in informing the discussion.<br></p><p>_____________________________<br></p><p>Quick context: there are things called resources. Resources can have observers. Observers are either self-owned or have an external owner object. Observers can either conform to a protocol or be closures; if the the latter, then they _must_ have an external owner (because closures aren’t objects).<br></p><p>There are thus three different methods to add observers to a resource — though they all cover the same underlying notion of “observer” (and in fact all boil down to the same thing internally):<br></p><p>    resource.addObserver(foo)<br></p><p>    resource.addObserver(fancyIndicator, owner: foo)<br></p><p>    resource.addObserver(owner: foo) {<br>        resource, event in<br>        updateStuff(resource.latestData)<br>    }<br></p><p>The API guidelines as stated would have us change that last one to:<br></p><p>    resource.addObserverWithOwner(foo) {<br>        resource, event in<br>        updateStuff(resource.latestData)<br>    }<br></p><p>However, this incorrectly implies that there is a distinct kind of thing that is an “observer with owner,” and that we will get one only from the third flavor of the method. That implication is wrong.<br></p><p>The consistency in the original of the “addObserver” name and the “owner:” label make the correct implication: all three methods serve the same purpose, observers are observers, and “owner” means the same thing in the two places it appears. I certainly think the non-compliant version of the code reads better.<br></p><p>There was extensive discussion around another family of methods that return a resource given either a path fragment or an absolute URL. This is where we ended up:<br></p><p>    service.resource(&quot;/foo&quot;)<br>    service.resource(absoluteURL: &quot;http://bar.com&quot;)<br>    service.resource(absoluteURL: NSURL(string: &quot;http://bar.com&quot;))<br></p><p>(The first is by far the most common, the “standard” flavor.)<br></p><p>The guidelines would have had us do this:<br></p><p>    service.resourceWithPathFragment(&quot;/foo&quot;)<br>    service.resourceWithAbsoluteURL(&quot;http://bar.com&quot;)<br>    service.resourceWithAbsoluteURL(NSURL(string: &quot;http://bar.com&quot;))<br></p><p>To my eyes, this crosses the line into verbosity that impedes clarity, but there’s an even more serious problem: it wrongly implies that there’s a distinction between “resources with path fragments” and “resources with absolute URLs.” That’s dangerously wrong. One of the central conceits of the whole library is that _all_ resources get a canonicalized absolute URL, and there’s a uniqueness guarantee for that URL no matter whether it was constructed for a path fragment, an absolute URL, or resource-relative navigation.<br></p><p>In the cases of both addObserver(…) and service.resource(…), the guidelines would have us actively mislead users.<br></p><p>Another trickier example of the same issue is the much-discussed typedContent method, which downcasts based on inferred type and returns a default value if content is either missing or of the wrong type:<br></p><p>    var image: UIImage?<br>    ...<br>    image = imageResource.typedContent(ifNone: placeholderImage)<br></p><p>How to make this conform to the guidelines? The obvious fix is terrible:<br></p><p>    image = imageResource.typedContentIfNone(placeholderImage)<br></p><p>This implies … what? That the method only returns typed content if there is none of the placeholder image? No, clearly a rephrasing is necessary:<br></p><p>    image = imageResource.typedContentWithDefault(placeholderImage)<br></p><p>But again we have this problem of determining whether “with default” describes the method’s behavior, its result, or its first argument. Are we attaching content with the default somehow attached to it? (No.) Are we returning some content, or a default value if there is none? (Yes.) So maybe this is better:<br></p><p>    image = imageResource.typedContentOrDefault(placeholderImage)<br></p><p>But now my brain is having parsing problems. What is the LHS of that “or?” It just doesn’t read naturally. OK, maybe even more words can save us:<br></p><p>    image = imageResource.typedContentOrDefaultIfNone(placeholderImage)<br></p><p>Yuck. At this point, we might as well stuff the entire method abstract in the name:<br></p><p>    image = imageResource.typedContentOrDefaultIfNoneOrMismatchedType(placeholderImage)<br></p><p>Yuck squared. The original is so much clearer:<br></p><p>    image = imageResource.typedContent(ifNone: placeholderImage)<br></p><p>IMO, there’s nothing wrong with leaning on programming language syntax to help segment and clarify English syntax.<br></p><p>_______________________________<br></p><p>What’s the better guideline on first argument labels?<br></p><p>Radek had a nice thought in the aforementioned Gihub thread:<br></p><p>&gt; The rationale being, ifNone doesn&#39;t really describe the method … it describes the parameter. Most of the time, the job of the method makes the first parameter obvious (hence the guideline), but here, it doesn&#39;t. So the parameter makes sense.<br></p><p><br>I’ll give a +1 for these two recommendations from Erica, which run along the same lines as Radek’s thought, but in more thorough detail:<br></p><p>&gt; On Jan 23, 2016, at 6:33 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Prefer external names for the first parameter when the natural<br>&gt; semantic relationship between the parameters is stronger than their<br>&gt; relation to the operation. <br>&gt; <br>&gt; For example, the following calls use labels for the first parameter:<br>&gt; <br>&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt; moveTo(x: 50.0, y: 30.0)<br>&gt; <br>&gt; This example is contrary to Swift&#39;s normal naming scheme which integrates the<br>&gt; first argument into the function or method name, for example:<br>&gt; <br>&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt; moveToX(50.0, y: 30.0)<br>&gt; <br>&gt; The coupling between x and y, username and password, (and yes it is a judgement call) <br>&gt; should be considered as a reason to employ an external label.<br>…<br>&gt; <br>&gt; Differentiate related calls whose implementations are distinguished by their<br>&gt; parameters, as you would with initializers, using first parameter labels.<br>&gt; <br>&gt; Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and loginWithCredential(myCredential),<br>&gt; prefer:<br>&gt; <br>&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt; login(credential: myCredential)<br></p><p>I’m not sure we’ve found the perfect, crisp way of saying all this — but I strongly agree that the existing guidelines are too rigid on the question of the first arg label, and Erica’s wording comes the closest I’ve seen to being a viable replacement.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/8c439111/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 24, 2016 at 06:00:00pm</p></header><div class="content"><p>My line of thinking is a close variant of this. Usually if I think of the arguments as a potential data structure I pass into the function, then I name the function as if I was passing them all as a single unlabelled argument. <br></p><p>Usually I think of this as a tuple, so I’m not distracted by whether or not a formal type is needed.<br></p><p>examples (which work today!):<br></p><p>let origin = (x: 0.0, y:0.0)<br>func moveTo(x x: Double, y:Double) { print(&quot;moved to (\(x), \(y))&quot;) }<br>moveTo(origin)<br></p><p>let userCredentials = (username:”jdoe&quot;, password:”abcd1234”) <br>func logInWith(username username:String, password:String) -&gt; Bool { return true }<br>logInWith(userCredentials) // my preferred name, since you are giving access to a user and not to credentials<br></p><p>-DW<br></p><p>&gt; On Jan 24, 2016, at 1:23 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&lt;snip&gt;<br>&gt; Radek had a nice thought in the aforementioned Gihub thread:<br>&gt; <br>&gt;&gt; The rationale being, ifNone doesn&#39;t really describe the method … it describes the parameter. Most of the time, the job of the method makes the first parameter obvious (hence the guideline), but here, it doesn&#39;t. So the parameter makes sense.<br>&gt; <br>&gt; <br>&gt; I’ll give a +1 for these two recommendations from Erica, which run along the same lines as Radek’s thought, but in more thorough detail:<br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 6:33 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Prefer external names for the first parameter when the natural<br>&gt;&gt; semantic relationship between the parameters is stronger than their<br>&gt;&gt; relation to the operation. <br>&gt;&gt; <br>&gt;&gt; For example, the following calls use labels for the first parameter:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveTo(x: 50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; This example is contrary to Swift&#39;s normal naming scheme which integrates the<br>&gt;&gt; first argument into the function or method name, for example:<br>&gt;&gt; <br>&gt;&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveToX(50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; The coupling between x and y, username and password, (and yes it is a judgement call) <br>&gt;&gt; should be considered as a reason to employ an external label.<br>&gt; …<br>&gt;&gt; <br>&gt;&gt; Differentiate related calls whose implementations are distinguished by their<br>&gt;&gt; parameters, as you would with initializers, using first parameter labels.<br>&gt;&gt; <br>&gt;&gt; Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and loginWithCredential(myCredential),<br>&gt;&gt; prefer:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; login(credential: myCredential)<br>&gt; <br>&gt; I’m not sure we’ve found the perfect, crisp way of saying all this — but I strongly agree that the existing guidelines are too rigid on the question of the first arg label, and Erica’s wording comes the closest I’ve seen to being a viable replacement.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/5de5df13/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 2:23 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some of the particulars of the guidelines haven’t worked well for me in practice — and I see from this thread that others have hit some of the same problems.<br>…<br>&gt; In short, in a real-world project, pre-guidelines code agreed with the guidelines 89% of the time, but where it disagreed, the guidelines achieved only a 25% acceptance rate with the curmudgeonly developers.<br>&gt; <br>&gt; You can follow that discussion here:<br>&gt; <br>&gt; 	https://gist.github.com/pcantrell/22a6564ca7d22789315b &lt;https://gist.github.com/pcantrell/22a6564ca7d22789315b&gt;<br>&gt; 	https://github.com/bustoutsolutions/siesta/issues/15 &lt;https://github.com/bustoutsolutions/siesta/issues/15&gt;…<br>&gt; I’ll share in a separate message some notes on the other places where we rejected the guidelines on questions other than the first arg label.<br></p><p>Here is that separate message as promised, with real-world examples of where the guidelines didn’t seem right for Siesta for reasons other than first arg naming.<br></p><p>Interestingly, all of them are part-of-speech questions. I’m intentionally writing up these notes before perusing Erica’s grammar writeup, so I can capture the raw reactions before letting them be colored by that document. Erica, I’ll get to your doc soon!<br></p><p>_____________<br></p><p>Siesta uses the widespread fluent style of attaching callbacks to a request:<br></p><p>    resource.load()<br>        .onCompletion { _ in stopSpinnyThing() }<br>        .onSuccess { _ in showHappyFace() }<br>        .onFailure { _ in showSadFace() }<br>        .onNewData { _ in soundTrumpets() }<br></p><p>These methods mutate the receiving request (by adding a callback), and the guidelines thus say that they should be named as imperative verbs. The results of that don’t seem like an improvement:<br></p><p>    resource.load()<br>        .addCompletionCallback { _ in stopSpinnyThing() }<br>        .addSuccessCallback { _ in showHappyFace() }<br>        .addFailureCallback { _ in showSadFace() }<br>        .addNewDataCallback { _ in soundTrumpets() }<br></p><p>In a related case, it’s possible to attach a callback to be run before any request within a given context:<br></p><p>    $0.config.beforeStartingRequest {<br>        _ in performDrumroll()<br>    }<br></p><p>It’s not even clear to me what the imperative verb here should be. Maybe “callBeforeStartingRequest”? The guideline-conforming options are all awkward; the guideline-breaking form above is clear.<br></p><p>I’d suggest a rule along these lines (but with less convoluted phrasing, if anyone can figure that out):<br></p><p>“When a method’s last argument is a closure, the method’s name and other arguments may read as a clause which modifies the closure as if it were a sentence with an imperative verb.”<br></p><p>Um, yeah, mouthful. Examples may help:<br></p><p>	Before starting a request, ← method<br>	perform a drumroll. ← closure<br></p><p>	On completion, ← method<br>	stop the spinny thing. ← closure<br></p><p>____<br></p><p>The ResourceObserver protocol, which clients will implement frequently, consists of “response to event” methods that may or may not mutate the receiver, but probably have side effects. These are methods clients will implement, but probably not call. An example:<br></p><p>    func resourceChanged(resource: Resource, event: ResourceEvent) {<br>        tableView.reloadData()<br>    }<br></p><p>The name “resourceChanged” feels right to me. The old-school Cocoa name would be resourceDidChange, which also feels OK. Options that are strictly nouns or verbs — resourceChange, respondToResourceChange — all feel awkward by comparison.<br></p><p>I think this has something to do with the “responding to event” nature of the method, crossed with the fact that it’s named in a protocol. We can’t know what it does, so we it doesn’t make sense to describe it as a verb. We only know why it’s called, what situation it’s responding to.<br>____<br></p><p>On the other side of the verb/noun coin, the ResponseTransformer protocol consists of a single method…<br></p><p>    public protocol ResponseTransformer {<br>        @warn_unused_result<br>        func process(response: Response) -&gt; Response<br>    }<br></p><p>…which is purely functional — should mutate neither the receiver nor the argument — yet just really, really seems wrong to me if it’s not named “process.” Why? I don’t have a rule. My gut just tells me that method should be a verb.<br></p><p>____<br></p><p>Last up, the rule that all enum cases should be nouns didn’t seem to fit here:<br></p><p>    public enum ResourceEvent: CustomStringConvertible {<br>        case ObserverAdded<br>        case Requested<br>        case RequestCancelled<br>        case NewData(NewDataSource)<br>        case NotModified<br>        case Error<br>    }<br></p><p>Noun alternatives such as “ObserverAddition” and “RequestStart” somehow come with more mental friction.<br></p><p>Again, I don’t have a rule to propose here — and in these cases, we may just have to say “this is why guidelines are guidelines, not laws,” and leave it at that. Or someone can propose better names, which would be awesome!<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/f6ad6133/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Paul, let’s start a new thread about this — I was going to write about the same idiom, but it’s out of scope of this review.<br></p><p>I disagree with Dave that this is just a EDSL, I think things like completion/success/failure handlers are a very common pattern, and it would be great to have consistent naming and a Guidelines recommendation for them. (Usually in the context of argument names, not chainable methods, which are, indeed, quite DSL-y).<br></p><p>— Radek<br></p><p>&gt; On 25 Jan 2016, at 04:48, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Siesta uses the widespread fluent style of attaching callbacks to a request:<br>&gt; <br>&gt;     resource.load()<br>&gt;         .onCompletion { _ in stopSpinnyThing() }<br>&gt;         .onSuccess { _ in showHappyFace() }<br>&gt;         .onFailure { _ in showSadFace() }<br>&gt;         .onNewData { _ in soundTrumpets() }<br>&gt; <br>&gt; These methods mutate the receiving request (by adding a callback), and the guidelines thus say that they should be named as imperative verbs. The results of that don’t seem like an improvement:<br>&gt; <br>&gt;     resource.load()<br>&gt;         .addCompletionCallback { _ in stopSpinnyThing() }<br>&gt;         .addSuccessCallback { _ in showHappyFace() }<br>&gt;         .addFailureCallback { _ in showSadFace() }<br>&gt;         .addNewDataCallback { _ in soundTrumpets() }<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/8d724d9b/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Ooookay, this thread took *a while* to go through. Phew!<br></p><p>Echoing from my reviews of SE-0005 and SE-0006:<br></p><p>&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br></p><p>And these guidelines do a great job at this. Like Paul Cantrell said, they recognize that both verbosity and brevity endanger clarity of code, and present many formalized rules to try to strike a balance in between, and keep S/N high. Both by reminding writers (yes, software writers!) to be explicit when it’s important, and by getting rid of noise that conveys little to no information, especially in a statically-typed language.<br></p><p>Although the API Design Guidelines sometimes err slightly more on the side of explicitness than me, I’m +1 aside from some concerns below:<br></p><p>* * *<br></p><p>= Prefer to follow the language’s defaults for the presence of argument labels =<br></p><p>This has been extensively discussed in this thread, by Erica, Paul, Dave, and others, so apologies if I repeat arguments already made, but:<br></p><p>I think there are more use cases where it makes sense to make the first argument label explicit than the guidelines consider.<br></p><p>The way I see it, most of the time, the method name, its fundamental job describes the first parameter, or makes it obvious. And so, the default behavior of Swift, and the general guideline are correct. However, there are cases, where this isn’t so.<br></p><p>   addObserver(foo)<br></p><p>Here, the method name says what first argument it takes right on the box. And `add(observer: …)` wouldn’t be appropriate, because this isn’t some general, generic “add”. The method adds an observer in particular. It’s fundamentally what it does, so it goes on the name.<br></p><p>   array.contains(“foo”)<br></p><p>This doesn’t describe the parameter explicitly, but the parameter is obvious, and makes something of a “sentence”. No label needed.<br></p><p>   login(username: “foo&quot;, password: “bar&quot;)<br></p><p>Here, “username” should _not_ be part of the name, because it doesn’t describe the fundamental job of the method. The method logs you in. Username is just a parameter.<br></p><p>One way to think about it, as Erica pointed out, is that the parameters are bound more strongly together than “username” is to the name. Another way to think about it, it would be completely natural to make the parameters a standalone tuple or a separate type:<br></p><p>   let credentials = (username: “foo”, password: “bar”)<br>   login(credentials)<br>   // or:<br>   login(LoginPair(username: “foo”, password: “bar”))<br></p><p>Another way in which it makes sense, and again this was pointed out, is that if you have multiple ways of logging in, it’s still logging in:<br></p><p>   login(username: “foo”, password: “bar”)<br>   login(token: “asdfg”)<br></p><p>Making the names “loginWithUsername” and “loginWithToken”:<br></p><p>- looks weird if you’re not used to Objective-C<br>- is unnecessarily verbose (tiny thing, but “with” conveys zero information, so I’d prefer to rely on Swift’s punctuation and make it an explicit parameter label)<br>- makes it seem as if the two methods were fundamentally different things, and they’re not. They’re two variants of the same method, so they should have a common name, and different parameters.<br></p><p>More examples:<br></p><p>   moveTo(x: Double, y: Double)<br></p><p>This passes multiple of the previous tests. “x” is a parameter, has nothing to do with the method itself. It could just as well be a tuple or a separate type. And if you had a different way of passing the position data, you’d still want the same name.<br></p><p>   constructColor(red: 0.2, green: 0.3, blue: 0.1)<br></p><p>Same thing.<br></p><p>An example from SE-0005 I proposed: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt; <br>   func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>   func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>   func encode(coder: Coder)<br>Copying and pasting what I said in that thread:<br></p><p>&gt; Again, the method, the action itself (“fill”, “stroke”, “encode”) doesn’t naturally describe the first parameter in a way “insert” on a collection, or “addObserver” would. The blend mode and coder values here are merely _options_ of the method, not its _fundamental job_.<br>&gt; <br>&gt; One way to conceptualize the difference is to think of arguments as being either “inputs” or “options”. A passed element to be inserted to a collection is an input, but blend mode is only an option of a fill, an operation that conceptually takes no inputs.<br>&gt; <br>&gt; (I also don’t believe that “don’t repeat type information” rule applies here. “blend mode” is a description of the parameter, not only its type. Same with coder. We’re not needlessly repeating type information here, we’re describing option parameters, which happen to be the same as type names.)<br></p><p>I think the language defaults and general guidelines are good. But the guidelines should be slightly more open about other situations where overriding the default is clearer to the reader.<br></p><p>* * *<br></p><p>= Omit Needless Words =<br></p><p>One more example to the parameters discussion, and also related to omitting needless words:<br></p><p>   array.joinWithSeparator(“,”)<br></p><p>I have multiple problems with this API. First of all, this should be, in my mind:<br></p><p>   array.join(separator: “,”)<br></p><p>because “separator” is a parameter, not the description of the method itself.<br></p><p>(In fact, I would go as far as to say `array.join(“,”)` because it seems always obvious from context.)<br></p><p>But aside from that, I take issue with this pattern because of the word “with”. This is a needless word that should be omitted. It contains no information. It’s just syntactic glue, which is not necessary here since we can say `join(separator: …)` instead.<br></p><p>(A rule of thumb: If you’re tempted to write `fooWithBar(…)`, you probably should use `foo(bar:)`, just like `initWithFoo:` from ObjC is translated to `init(foo:)`)<br></p><p>And I see that in many places. Not much in Swift, but a lot more in Objective-C APIs. Needless words like “with”, “and”, “by”, “using”, “for&quot;. I’m not saying they’re always unnecessary; they often help convey the semantics or intent, or are needed for the method name to make sense. Or sometimes they replace a noun in describing a parameter (see: stride). But too often they’re just glue words used to make code sound like English without any actual readability benefits, and merely adding noise.<br></p><p>Sorry about this mini-rant. I’m not sure if this requires additional examples or clarification in the Guidelines text aside from the first-parameter discussion, but something I wanted to point out.<br></p><p>* * *<br></p><p>= If the first parameter of a method is defaulted, it should have an argument label. =<br></p><p>Okay, I think you all got the idea by now, but I can’t help myself. This rule says you should do something like:<br></p><p>   mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>   close(completionHandler completion: ((Bool) -&gt; Void)? = nil)<br></p><p>But consider what would happen if these parameters weren&#39;t defaulted, for whatever reason:<br></p><p>It would still make more sense to say:<br></p><p>   removeAll(keepingCapacity: false)<br>   close(completionHandler: { … })<br></p><p>Than:<br></p><p>   removeAllKeepingCapacity(false)<br>   closeWithCompletionHandler({ … })<br></p><p>This suggests to me that this rule is not fundamental, rather it derives from the distinction between the implied function input and method options/parameters I discussed earlier. The use case with default values is just the most common example of this in practice, since “options” (vs inputs) very often have a sensible default.<br></p><p>* * *<br></p><p>= -ed / - ing / -inPlace =<br></p><p>I have nothing to add others haven’t, but I agree that these rules are still really awkward.<br></p><p>* * *<br></p><p>I haven’t found any other serious issues with the proposal. I have some ideas to _add_ to the Guidelines, but I figure those can wait and should get their own thread later. The overall language and spirit is exactly what I was hoping for.<br></p><p>And just don’t forget:<br></p><p>&gt; Good APIs aren&#39;t the result of<br>&gt; applying a set of mechanical rules.  You have to consider what the usage<br>&gt; will look like.<br></p><p>&gt; (Dave Abrahams)<br></p><p>These are guidelines, not the law. It’s a great thing to have a set of guidelines applicable in 95% of cases, and have the community consistently apply them, but there’s always room for good judgement along the edges.<br></p><p>Best,<br>— Radek<br></p><p>&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/3e31130a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>Cross-linking to an interesting discussion in SE-0005 about adding a heuristic to split the method name and an explicit first argument label by the word “with”:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007874.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007874.html&gt;<br>— Radek<br></p><p>&gt; On 25 Jan 2016, at 19:07, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ooookay, this thread took *a while* to go through. Phew!<br>&gt; <br>&gt; Echoing from my reviews of SE-0005 and SE-0006:<br>&gt; <br>&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless verbosity and keeping the signal-to-noise ratio high is one of the most immediately appealing aspects of Swift, as well as a great general improvement to the programming experience.<br>&gt; <br>&gt; And these guidelines do a great job at this. Like Paul Cantrell said, they recognize that both verbosity and brevity endanger clarity of code, and present many formalized rules to try to strike a balance in between, and keep S/N high. Both by reminding writers (yes, software writers!) to be explicit when it’s important, and by getting rid of noise that conveys little to no information, especially in a statically-typed language.<br>&gt; <br>&gt; Although the API Design Guidelines sometimes err slightly more on the side of explicitness than me, I’m +1 aside from some concerns below:<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; = Prefer to follow the language’s defaults for the presence of argument labels =<br>&gt; <br>&gt; This has been extensively discussed in this thread, by Erica, Paul, Dave, and others, so apologies if I repeat arguments already made, but:<br>&gt; <br>&gt; I think there are more use cases where it makes sense to make the first argument label explicit than the guidelines consider.<br>&gt; <br>&gt; The way I see it, most of the time, the method name, its fundamental job describes the first parameter, or makes it obvious. And so, the default behavior of Swift, and the general guideline are correct. However, there are cases, where this isn’t so.<br>&gt; <br>&gt;    addObserver(foo)<br>&gt; <br>&gt; Here, the method name says what first argument it takes right on the box. And `add(observer: …)` wouldn’t be appropriate, because this isn’t some general, generic “add”. The method adds an observer in particular. It’s fundamentally what it does, so it goes on the name.<br>&gt; <br>&gt;    array.contains(“foo”)<br>&gt; <br>&gt; This doesn’t describe the parameter explicitly, but the parameter is obvious, and makes something of a “sentence”. No label needed.<br>&gt; <br>&gt;    login(username: “foo&quot;, password: “bar&quot;)<br>&gt; <br>&gt; Here, “username” should _not_ be part of the name, because it doesn’t describe the fundamental job of the method. The method logs you in. Username is just a parameter.<br>&gt; <br>&gt; One way to think about it, as Erica pointed out, is that the parameters are bound more strongly together than “username” is to the name. Another way to think about it, it would be completely natural to make the parameters a standalone tuple or a separate type:<br>&gt; <br>&gt;    let credentials = (username: “foo”, password: “bar”)<br>&gt;    login(credentials)<br>&gt;    // or:<br>&gt;    login(LoginPair(username: “foo”, password: “bar”))<br>&gt; <br>&gt; Another way in which it makes sense, and again this was pointed out, is that if you have multiple ways of logging in, it’s still logging in:<br>&gt; <br>&gt;    login(username: “foo”, password: “bar”)<br>&gt;    login(token: “asdfg”)<br>&gt; <br>&gt; Making the names “loginWithUsername” and “loginWithToken”:<br>&gt; <br>&gt; - looks weird if you’re not used to Objective-C<br>&gt; - is unnecessarily verbose (tiny thing, but “with” conveys zero information, so I’d prefer to rely on Swift’s punctuation and make it an explicit parameter label)<br>&gt; - makes it seem as if the two methods were fundamentally different things, and they’re not. They’re two variants of the same method, so they should have a common name, and different parameters.<br>&gt; <br>&gt; More examples:<br>&gt; <br>&gt;    moveTo(x: Double, y: Double)<br>&gt; <br>&gt; This passes multiple of the previous tests. “x” is a parameter, has nothing to do with the method itself. It could just as well be a tuple or a separate type. And if you had a different way of passing the position data, you’d still want the same name.<br>&gt; <br>&gt;    constructColor(red: 0.2, green: 0.3, blue: 0.1)<br>&gt; <br>&gt; Same thing.<br>&gt; <br>&gt; An example from SE-0005 I proposed: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt; <br>&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;    func encode(coder: Coder)<br>&gt; Copying and pasting what I said in that thread:<br>&gt; <br>&gt;&gt; Again, the method, the action itself (“fill”, “stroke”, “encode”) doesn’t naturally describe the first parameter in a way “insert” on a collection, or “addObserver” would. The blend mode and coder values here are merely _options_ of the method, not its _fundamental job_.<br>&gt;&gt; <br>&gt;&gt; One way to conceptualize the difference is to think of arguments as being either “inputs” or “options”. A passed element to be inserted to a collection is an input, but blend mode is only an option of a fill, an operation that conceptually takes no inputs.<br>&gt;&gt; <br>&gt;&gt; (I also don’t believe that “don’t repeat type information” rule applies here. “blend mode” is a description of the parameter, not only its type. Same with coder. We’re not needlessly repeating type information here, we’re describing option parameters, which happen to be the same as type names.)<br>&gt; <br>&gt; I think the language defaults and general guidelines are good. But the guidelines should be slightly more open about other situations where overriding the default is clearer to the reader.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; = Omit Needless Words =<br>&gt; <br>&gt; One more example to the parameters discussion, and also related to omitting needless words:<br>&gt; <br>&gt;    array.joinWithSeparator(“,”)<br>&gt; <br>&gt; I have multiple problems with this API. First of all, this should be, in my mind:<br>&gt; <br>&gt;    array.join(separator: “,”)<br>&gt; <br>&gt; because “separator” is a parameter, not the description of the method itself.<br>&gt; <br>&gt; (In fact, I would go as far as to say `array.join(“,”)` because it seems always obvious from context.)<br>&gt; <br>&gt; But aside from that, I take issue with this pattern because of the word “with”. This is a needless word that should be omitted. It contains no information. It’s just syntactic glue, which is not necessary here since we can say `join(separator: …)` instead.<br>&gt; <br>&gt; (A rule of thumb: If you’re tempted to write `fooWithBar(…)`, you probably should use `foo(bar:)`, just like `initWithFoo:` from ObjC is translated to `init(foo:)`)<br>&gt; <br>&gt; And I see that in many places. Not much in Swift, but a lot more in Objective-C APIs. Needless words like “with”, “and”, “by”, “using”, “for&quot;. I’m not saying they’re always unnecessary; they often help convey the semantics or intent, or are needed for the method name to make sense. Or sometimes they replace a noun in describing a parameter (see: stride). But too often they’re just glue words used to make code sound like English without any actual readability benefits, and merely adding noise.<br>&gt; <br>&gt; Sorry about this mini-rant. I’m not sure if this requires additional examples or clarification in the Guidelines text aside from the first-parameter discussion, but something I wanted to point out.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; = If the first parameter of a method is defaulted, it should have an argument label. =<br>&gt; <br>&gt; Okay, I think you all got the idea by now, but I can’t help myself. This rule says you should do something like:<br>&gt; <br>&gt;    mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>&gt;    close(completionHandler completion: ((Bool) -&gt; Void)? = nil)<br>&gt; <br>&gt; But consider what would happen if these parameters weren&#39;t defaulted, for whatever reason:<br>&gt; <br>&gt; It would still make more sense to say:<br>&gt; <br>&gt;    removeAll(keepingCapacity: false)<br>&gt;    close(completionHandler: { … })<br>&gt; <br>&gt; Than:<br>&gt; <br>&gt;    removeAllKeepingCapacity(false)<br>&gt;    closeWithCompletionHandler({ … })<br>&gt; <br>&gt; This suggests to me that this rule is not fundamental, rather it derives from the distinction between the implied function input and method options/parameters I discussed earlier. The use case with default values is just the most common example of this in practice, since “options” (vs inputs) very often have a sensible default.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; = -ed / - ing / -inPlace =<br>&gt; <br>&gt; I have nothing to add others haven’t, but I agree that these rules are still really awkward.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I haven’t found any other serious issues with the proposal. I have some ideas to _add_ to the Guidelines, but I figure those can wait and should get their own thread later. The overall language and spirit is exactly what I was hoping for.<br>&gt; <br>&gt; And just don’t forget:<br>&gt; <br>&gt;&gt; Good APIs aren&#39;t the result of<br>&gt;&gt; applying a set of mechanical rules.  You have to consider what the usage<br>&gt;&gt; will look like.<br>&gt; <br>&gt;&gt; (Dave Abrahams)<br>&gt; <br>&gt; These are guidelines, not the law. It’s a great thing to have a set of guidelines applicable in 95% of cases, and have the community consistently apply them, but there’s always room for good judgement along the edges.<br>&gt; <br>&gt; Best,<br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/f26e2ee9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>My evaluation is inline below...<br></p><p>&gt; On Jan 22, 2016, at 4:02 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>Overall, I like the proposal. It provides sound guidance that can lead to consistent code in practice. However, there are some issues and concerns I have:<br></p><p>- Under &quot;Fundamentals&quot;, there is a bullet called &quot;Write a documentation comment...&quot;. Under this bullet, this is another bullet called &quot;Use a single sentence fragment...&quot;. Why? I find sentence fragments often detract from clarity and concise nature, which can lead to confusion.<br></p><p>- Under &quot;Naming&quot;, there is a bullet called &quot;Omit Needless Words&quot;. This bullet states, &quot;Occasionally, repeating information is necessary to avoid ambiguity...&quot; It would be useful to provide an example that the reader can use to disambiguate this use case.<br></p><p>- Under &quot;Naming&quot;, there is a bullet called &quot;Compensate for Weak Type Information...&quot;. The example provided is confusing. First, it contradicts the guidance relating to omitting needless words. It suggests that <br></p><p>func add(observer: NSObject, for keyPath: String)<br></p><p>becomes<br></p><p>func addObserver(_ observer: NSObject, forKeyPath: String)<br></p><p>This results in &quot;Observer&quot; followed by &quot;observer&quot;. Why is this more clear?<br></p><p>In addition, I don&#39;t understand why it collapsed &quot;for keyPath&quot; to &quot;forKeyPath&quot;. Perhaps an explanation would clarify?<br></p><p>- Under &quot;Naming&quot;, there is a bullet called &quot;Uses of non-mutating methods should read as noun phrases...&quot;. This bullet provides an example of an exception. Why would calling this method firstAndLast() have less clarity than split()? Perhaps a better example is in order.<br></p><p>- Under &quot;Naming&quot;, there is a bullet called &quot;When a mutating method is described by a very, name its non-mutating counterpart...&quot;. On the surface this appears to provide good guidance, I think in practice it becomes difficult and doesn&#39;t necessarily provide the desired result. I think Ruby provides a better example of how the desired result is very clear. In Ruby, the name of a mutating method is designated by an exclamation point at the end of the name. For example, myString.reverse() returns the value of the reversed string, while myString.reverse!() mutates myString with the reversed value. I&#39;m not necessarily proposing that Swift use the exclamation point for this purpose (as Swift already uses this force unwrapping), so much as I&#39;m proposing that you investigate how other languages clearly disambiguate non-mutating and mutating methods.<br></p><p>- Under &quot;Conventions&quot;, there is a bullet called &quot;Methods can share a base name when they share the same basic meaning...&quot;. There are some examples when this convention does not apply. I think it would be helpful to illustrate to the reader how to address these exceptions (i.e., do this, instead of that).<br></p><p>- Under &quot;Conventions&quot;, there is a bullet called &quot;Prefer to follow the language&#39;s defaults for the presence of argument labels&quot;. Be aware that the current compiler issues the warning when the first argument label is &quot;_&quot;, &quot;Extraneous &#39;_&#39; in parameter: &lt;parameter&gt; has no keyword argument name&quot;. I would either like the compiler to not issue a warning for this use case, or at least give the developer the means to disable this warning.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>I think publishing a clear set of guidelines is absolutely necessary.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Absolutely. Great job!<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I think all serious languages have a document that specifies a set of guidelines with the intent of bringing consistency in the use of the language. Languages that do not drive a set of best practices tend to suffer, at least form a readability perspective. For as much as I like Ruby, it lacks such a set of guidelines, which has resulted in the community writing code that lacks the consistency that makes it easy to read others&#39; code.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>As always, I read the proposal multiple times, which included reading through the guidelines multiple times, sleeping on it, pondering it, and finally writing my evaluation.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1d51ed64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Overall, I like the proposal. It provides sound guidance that can lead to consistent code in practice. However, there are some issues and concerns I have:<br>&gt; <br>&gt; - Under &quot;Fundamentals&quot;, there is a bullet called &quot;Write a documentation comment...&quot;. Under this bullet, this is another bullet called &quot;Use a single sentence fragment...&quot;. Why? I find sentence fragments often detract from clarity and concise nature, which can lead to confusion.<br></p><p>This fragment is added to the name of the function so if you have a function named &quot;myFunction&quot;, the descriptive fragment is &quot;converts integers to strings.&quot; and the display is:<br></p><p>Description: myFunction converts integers to string.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1ad4c4bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Erica,<br></p><p>This was in the documentation section, I didn&#39;t think this applied to the naming of functions/methods.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 29, 2016, at 11:11 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; Overall, I like the proposal. It provides sound guidance that can lead to consistent code in practice. However, there are some issues and concerns I have:<br>&gt;&gt; <br>&gt;&gt; - Under &quot;Fundamentals&quot;, there is a bullet called &quot;Write a documentation comment...&quot;. Under this bullet, this is another bullet called &quot;Use a single sentence fragment...&quot;. Why? I find sentence fragments often detract from clarity and concise nature, which can lead to confusion.<br>&gt; <br>&gt; This fragment is added to the name of the function so if you have a function named &quot;myFunction&quot;, the descriptive fragment is &quot;converts integers to strings.&quot; and the display is:<br>&gt; <br>&gt; Description: myFunction converts integers to string.<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/d33ea877/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>This is about documentation markup. Consider the following markup:<br></p><p>/// Converts integers to string.<br>func myFunction() {}<br></p><p>It renders like this: http://imgur.com/YHFu68b &lt;http://imgur.com/YHFu68b&gt; <br>If you use a full sentence as the description, you end up instead with: http://imgur.com/Jzxe2RT &lt;http://imgur.com/Jzxe2RT&gt;<br></p><p>The latter over-emphasizes the function name. If you limit the description to a sentence fragment, the<br>declaration naturally continues to the description.<br></p><p><br>&gt; On Jan 29, 2016, at 9:27 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; This was in the documentation section, I didn&#39;t think this applied to the naming of functions/methods.<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 11:11 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Overall, I like the proposal. It provides sound guidance that can lead to consistent code in practice. However, there are some issues and concerns I have:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Under &quot;Fundamentals&quot;, there is a bullet called &quot;Write a documentation comment...&quot;. Under this bullet, this is another bullet called &quot;Use a single sentence fragment...&quot;. Why? I find sentence fragments often detract from clarity and concise nature, which can lead to confusion.<br>&gt;&gt; <br>&gt;&gt; This fragment is added to the name of the function so if you have a function named &quot;myFunction&quot;, the descriptive fragment is &quot;converts integers to strings.&quot; and the display is:<br>&gt;&gt; <br>&gt;&gt; Description: myFunction converts integers to string.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/c4099ed2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Erica,<br></p><p>Your explanation and example help clarify what the guideline is attempting to convey. Maybe the guideline can be expanded on a bit to do the same.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Jan 29, 2016, at 11:42 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; http://imgur.com/YHFu68b &lt;http://imgur.com/YHFu68b&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/da3bb32a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>It suddenly occurs to me it&#39;s almost the 31st and I haven&#39;t actually responded to the proposal as a proposal. I heartily endorse a general set of API guidelines and I appreciate this first approach towards satisfying that goal. I have issues with two sections.<br></p><p>First, I&#39;d entirely eliminate the guidance in the &quot;Be Grammatical&quot; section and move the section with boolean assertions and property names to Special Instructions.<br></p><p>* I disagree with the mutating/non-mutating differentiation. I started writing about this here before personally abandoning it as too big a question: Grammatical.md &lt;https://github.com/erica/SwiftStyle/blob/master/Grammatical.md&gt;. In a nutshell, side-effects and pure functionality are not considered the way I&#39;d want them to be and the ed/ing naming is problematic.<br>* The protocol question is big and wide as well, and I have written on-list: it&#39;s not &quot;the role of a protocol to describe implementation details...Going that way leads you to over-designated hungarian-esque guidelines that I&#39;d rather keep loose, friendly, and sensible.&quot;<br></p><p>In &quot;Conventions&quot;:<br></p><p>* I don&#39;t like endorsing that any property could or should not be O(1) (vs recommending using a function instead)<br>* The case convention for enumerations remains conventional without a guiding principle. I&#39;d rather have a firm &quot;use lower camel case for members&quot; that I can complain about  (because it feels to me like &quot;pick a type layout for this memory&quot;, so upper camel) rather than &quot;use upper camel and let everyone on the Swift team complain about it&quot; once and for all.<br>* With regard to argument labels, I&#39;d like to add two rules, as detailed in-thread and written about here: ArgumentLabels.md &lt;https://github.com/erica/SwiftStyle/blob/master/ArgumentLabels.md&gt;<br></p><p>Differentiate related calls whose implementations are distinguished by their parameters, as you would with initializers, using first parameter labels. Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and loginWithCredential(myCredential), prefer:<br></p><p>login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>login(credential: myCredential)<br>This approach emphasizes the action being taken (login) and demotes the actual arguments involved in performing that action. In doing so, they require labels to differentiate which implementation of that action is to be used.<br></p><p>and<br></p><p>Prefer external names for the first parameter when the natural semantic relationship between the parameters is stronger than their relation to the operation. <br></p><p>For example, the following calls use labels for the first parameter:<br></p><p>login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>moveTo(x: 50.0, y: 30.0)<br>constructColor(red: 0.2, green: 0.3, blue: 0.1)<br>This example is contrary to Swift&#39;s normal naming scheme which integrates the first argument into the function or method name, for example:<br></p><p>loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>moveToX(50.0, y: 30.0)<br>constructColorWithRed(0.2, green: 0.3, blue: 0.1)<br>The relationships between (x, y), (username, password), and (red, green, blue) are strong enough to allow you to make a judgement call to employ an external label.<br></p><p>The following shows a counter-example.<br></p><p>addLineTo(p1, withWidth: 25.0)<br>In this call, the point and width have no natural relationship. There&#39;s no reason to create an external label for the first argument so this example follows the standard Swift call approach.<br></p><p><br>&gt; On Jan 22, 2016, at 2:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/81461dfc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 10:29 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Differentiate related calls whose implementations are distinguished by their parameters, as you would with initializers, using first parameter labels.<br>&gt; …<br>&gt; Prefer external names for the first parameter when the natural semantic relationship between the parameters is stronger than their relation to the operation. <br>&gt; <br>&gt; For example, the following calls use labels for the first parameter:<br>&gt; <br>&gt;     login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;     moveTo(x: 50.0, y: 30.0)<br>&gt;     constructColor(red: 0.2, green: 0.3, blue: 0.1)<br>&gt; <br>&gt; This example is contrary to Swift&#39;s normal naming scheme which integrates the first argument into the function or method name, for example:<br>&gt; <br>&gt;     loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt;     moveToX(50.0, y: 30.0)<br>&gt;     constructColorWithRed(0.2, green: 0.3, blue: 0.1)<br>&gt; <br>&gt; The relationships between (x, y), (username, password), and (red, green, blue) are strong enough to allow you to make a judgement call to employ an external label.<br>&gt; <br></p><p>An anecdote in support of Erica’s thinking in the ongoing Battle of the First Argument Labels:<br></p><p>I mentioned the ongoing swift-evolution debates to Bret Jackson, one of my Macalester colleagues — awesome developer, 3D / VR / HCI researcher, tons of C++ experience, never seen Swift before — and typed out this example for him:<br></p><p>	moveTo(1.0, y: 0.5)<br></p><p>…and then this (he nods approvingly):<br></p><p>	moveTo(x: 1.0, y: 0.5)<br></p><p>…and then this:<br></p><p>	moveToX(1.0, y: 0.5)<br></p><p>…at which point, before I’d even finished typing it out, he physically recoiled in revulsion, threw hand up in front of his face, and let out a pained “oh please no!!” I wish I had video of him squirming in his chair. It was something to behold.<br></p><p>Thus my N=1 study of Swift newcomers concludes that “moveToX” is horrifying.<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January 31, 2016 at 01:00:00am</p></header><div class="content"><p>Overall I like the proposals but I do have comments on a few issues.<br></p><p>enum case capitalisation. I generally like the use of lowerCamelCase <br>names because they are not types. Types are determined at compile time <br>and the case (value) of an enum is only known at runtime. I have already <br>seen people get confused by expecting to be able to use information <br>about an enum value at compile time. I think normally using <br>upperCamelCase would increase the confusion between cases and types.<br></p><p><br>I have flicked through the thread and there are some good interesting <br>discussions particularly about argument labels in different ways. I&#39;m <br>not sure there are any specific changes I want to strongly back but the <br>current proposals are not the uniquely correct approach. If there are <br>substantial changes it would be good to run them through as a proposal <br>for changes on top of this one so that they get proper review, the <br>thread is huge and many people may have missed things that they really <br>care about.<br></p><p>Joseph<br></p><p>On 22/01/2016 21:02, Douglas Gregor via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through<br>&gt; January 31, 2016. The proposal is available here:<br>&gt;<br>&gt;     https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt;<br>&gt;     Proposal link:<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;<br>&gt;     Reply text<br>&gt;<br>&gt;         Other replies<br>&gt;<br>&gt;<br>&gt;           &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;           goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction<br>&gt; of Swift. When writing your review, here are some questions you might<br>&gt; want to answer in your review:<br>&gt;<br>&gt;   * What is your evaluation of the proposal?<br>&gt;   * Is the problem being addressed significant enough to warrant a<br>&gt;     change to Swift?<br>&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt;   * If you have used other languages or libraries with a similar<br>&gt;     feature, how do you feel that this proposal compares to those?<br>&gt;   * How much effort did you put into your review? A glance, a quick<br>&gt;     reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;     https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>Human Friendly Ltd.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>January 31, 2016 at 11:00:00pm</p></header><div class="content"><p>I’m still processing all my thoughts on this and might have a thought or two on the Obj-C bridging thread as well, but I had a question about one specific style guideline:<br></p><p>&gt; Uses &lt;&gt; of nonmutating Boolean methods and properties should read as assertions about the receiver, e.g. x.isEmpty, line1.intersects(line2)<br></p><p><br>I have really mixed feelings on this, and was wondering what the rationale was (maybe to convince me it’s a good idea.) To me, this seems like adding extra language to a proposal that is pretty good at removing now unnecessary language. It also seems unhelpful to me as an API user and writer because in an alphabetical list, related functionality (like a “playing” nonmutating property and a “play” function, or a “playRate” mutable property) are all going to be moved away from each other in a list. I acknowledge that Xcode’s autocomplete is getting better though in that regard, and that most documentation is grouped. But I’m not a fan of the crowding of “is” functions that is going to happen.<br></p><p>In reviewing AVFoundation specifically (but I’m going through the others as well), I’m not sure this is an improvement either.<br></p><p>Mildly worse, makes it sound like a function instead of a property:<br>exposurePointOfInterestSupported -&gt; isExposurePointOfInterestSupported<br></p><p>Same sort of thing, I’m not sure this is cleaner:<br>supportsVideoMirroring -&gt; isVideoMirroringSupported<br></p><p>This one almost sounds to me like the function meaning is being tweaked:<br>videoMirrored -&gt; isVideoMirrored<br></p><p>The name of this one now sounds like it is supposed to have an argument to check to see if a specific video orientation is supported (although it is true that the original property wasn’t named great either):<br>supportsVideoOrientation -&gt; isVideoOrientationSupported<br></p><p>Like I said, I’d be willing to be talked into this, but at this point I’m just really curious what the justification is. For simple cases this seems to work well, but I’m really not enthused for what this does to more complex or domain specific property names. I’m willing to call this “unease after doing Obj-C too long”, but I’d like to understand why the Swift team feels this is better.<br></p><p>&gt; On Jan 22, 2016, at 1:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/22cfae69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; supportsVideoMirroring -&gt; isVideoMirroringSupported<br>&gt; supportsVideoOrientation -&gt; isVideoOrientationSupported<br></p><p><br>IMHO, for this particular case, I think the ones on the left read more as assertions about the receiver than the alternatives on the right.  <br>I may be wrong, but I did not interpret this guideline as having to prefix boolean properties with is.  I think these two would be fine as supportVideMirroring and supportVideoOrientation as they read as assertions about the receiver.  <br></p><p><br></p><p><br></p><p>&gt; On Feb 1, 2016, at 2:51 AM, Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m still processing all my thoughts on this and might have a thought or two on the Obj-C bridging thread as well, but I had a question about one specific style guideline:<br>&gt; <br>&gt;&gt; Uses &lt;&gt; of nonmutating Boolean methods and properties should read as assertions about the receiver, e.g. x.isEmpty, line1.intersects(line2)<br>&gt; <br>&gt; <br>&gt; I have really mixed feelings on this, and was wondering what the rationale was (maybe to convince me it’s a good idea.) To me, this seems like adding extra language to a proposal that is pretty good at removing now unnecessary language. It also seems unhelpful to me as an API user and writer because in an alphabetical list, related functionality (like a “playing” nonmutating property and a “play” function, or a “playRate” mutable property) are all going to be moved away from each other in a list. I acknowledge that Xcode’s autocomplete is getting better though in that regard, and that most documentation is grouped. But I’m not a fan of the crowding of “is” functions that is going to happen.<br>&gt; <br>&gt; In reviewing AVFoundation specifically (but I’m going through the others as well), I’m not sure this is an improvement either.<br>&gt; <br>&gt; Mildly worse, makes it sound like a function instead of a property:<br>&gt; exposurePointOfInterestSupported -&gt; isExposurePointOfInterestSupported<br>&gt; <br>&gt; Same sort of thing, I’m not sure this is cleaner:<br>&gt; supportsVideoMirroring -&gt; isVideoMirroringSupported<br>&gt; <br>&gt; This one almost sounds to me like the function meaning is being tweaked:<br>&gt; videoMirrored -&gt; isVideoMirrored<br>&gt; <br>&gt; The name of this one now sounds like it is supposed to have an argument to check to see if a specific video orientation is supported (although it is true that the original property wasn’t named great either):<br>&gt; supportsVideoOrientation -&gt; isVideoOrientationSupported<br>&gt; <br>&gt; Like I said, I’d be willing to be talked into this, but at this point I’m just really curious what the justification is. For simple cases this seems to work well, but I’m really not enthused for what this does to more complex or domain specific property names. I’m willing to call this “unease after doing Obj-C too long”, but I’d like to understand why the Swift team feels this is better.<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 1:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/541cbc8b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February  1, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;d like to add my voice to the many that are in favor of this proposal.<br></p><p>I agree with the general spirit of the guidelines and I think they cover the most important points. They can always be expanded in the future if experience deems it necessary but I&#39;d rather have people actually read and use the document than be put off by length and complexity.<br></p><p>Various minor points<br></p><p>* Will these guidelines become part of &quot;The Swift Programming Language&quot;? Personally I would support that.<br></p><p>* I&#39;m in favor of lowerCaseEnumCases<br></p><p>* var htmlElement = HTMLElement<br></p><p>* I don&#39;t think  stripping the &quot;Type&quot; suffix from protocols is a clear win, mostly a change of tradeoffs (which have already been discussed extensively).<br>Ultimately I would be fine with either approach.<br></p><p>* One small idea I&#39;d like to throw out there is whether the guidelines should contain a small note that one might look to the standard library for inspiration as well. It will have many examples for following the guidelines as presented and might offer some helpful precedent in cases where one is still unsure. In a way this is probably obvious but it might not hurt to mention?<br></p><p>* On the guidelines page the bullet point &quot;When the first argument is defaulted, it should have a distinct argument label.&quot; is wrapped in a link (without a target). This is probably unintentional.<br></p><p><br>And a bit of rambling regarding the property vs method discussion:<br>The current situation seems to be that there are a lot of conflicting &quot;rules&quot; (most with exceptions attached) that need to be weighed against each other, with the decision coming down to &quot;collective gut feeling&quot;. It don&#39;t see a way to formalize them without breaking at least some existing conventions and probably some heated discussions ;-). I also wonder if that would actually produce better APIs on the whole or simply produce clear rules for the sake of having clear rules with APIs suffering in some cases...<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/ca67dbec/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
