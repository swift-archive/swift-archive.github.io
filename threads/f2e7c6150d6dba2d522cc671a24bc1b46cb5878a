<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 21, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello Swift Community,<br></p><p>Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist. &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br></p><p>Cheers,<br></p><p>~Robert Widmann<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/f2e7878a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 21, 2016 at 08:00:00pm</p></header><div class="content"><p>This is nice. Is `areSame()` being proposed because static `==` is the<br>status quo and you&#39;re trying to make the point that `==` in the future need<br>not guarantee the same semantics?<br></p><p>Nit: I think the more common term in stdlib would be `areEquivalent()`. Do<br>you think `same` in that context (independent of the word &quot;ordering&quot;) might<br>erroneously suggest identity?<br></p><p><br>On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift Community,<br>&gt;<br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to<br>&gt; clean up the semantics of ordering relations in the standard library.  We<br>&gt; have a draft that you can get as a gist.<br>&gt; &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any<br>&gt; feedback you might have about this proposal helps - though please keeps<br>&gt; your comments on Swift-Evolution and not on the gist.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/4afbd35f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 21, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is nice. Is `areSame()` being proposed because static `==` is the status quo and you&#39;re trying to make the point that `==` in the future need not guarantee the same semantics?<br></p><p>Yep!  Equivalence and equality are strictly very different things.<br></p><p>&gt; <br>&gt; Nit: I think the more common term in stdlib would be `areEquivalent()`. Do you think `same` in that context (independent of the word &quot;ordering&quot;) might erroneously suggest identity?<br></p><p>There is room for improvement here.  Keep ‘em coming.<br></p><p>&gt; <br>&gt; <br>&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift Community,<br>&gt; <br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist. &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/ab054520/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 21, 2016 at 07:00:00pm</p></header><div class="content"><p>Great proposal. I want to second that areSame may mislead user to think this is about identity.<br></p><p>I like areEquivalent() but there may be better names.<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is the status quo and you&#39;re trying to make the point that `==` in the future need not guarantee the same semantics?<br>&gt; <br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Nit: I think the more common term in stdlib would be `areEquivalent()`. Do you think `same` in that context (independent of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt; <br>&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist.  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/62287bb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 21, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 7:15 PM, Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Great proposal. I want to second that areSame may mislead user to think this is about identity.<br>&gt; <br>&gt; I like areEquivalent() but there may be better names.<br></p><p>what about areEqual() ?<br></p><p>&gt; <br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is the status quo and you&#39;re trying to make the point that `==` in the future need not guarantee the same semantics?<br>&gt;&gt; <br>&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nit: I think the more common term in stdlib would be `areEquivalent()`. Do you think `same` in that context (independent of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt; <br>&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist.  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/e9851a56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 21, 2016 at 10:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 10:23 PM, Jose Cheyo Jimenez via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Jul 21, 2016, at 7:15 PM, Duan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Great proposal. I want to second that areSame may mislead user to think<br>&gt; this is about identity.<br>&gt;<br>&gt; I like areEquivalent() but there may be better names.<br>&gt;<br>&gt;<br>&gt; what about areEqual() ?<br>&gt;<br></p><p>As Robert mentioned above, the point here is explicitly to distinguish<br>equivalence from equality.<br></p><p><br>&gt;<br>&gt;<br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is nice. Is `areSame()` being proposed because static `==` is the<br>&gt; status quo and you&#39;re trying to make the point that `==` in the future need<br>&gt; not guarantee the same semantics?<br>&gt;<br>&gt;<br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;<br>&gt;<br>&gt; Nit: I think the more common term in stdlib would be `areEquivalent()`. Do<br>&gt; you think `same` in that context (independent of the word &quot;ordering&quot;) might<br>&gt; erroneously suggest identity?<br>&gt;<br>&gt;<br>&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift Community,<br>&gt;&gt;<br>&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to<br>&gt;&gt; clean up the semantics of ordering relations in the standard library.  We<br>&gt;&gt; have a draft that you can get as a gist.<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any<br>&gt;&gt; feedback you might have about this proposal helps - though please keeps<br>&gt;&gt; your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/43286362/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 21, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 8:32 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is nice. Is `areSame()` being proposed because static `==` is the<br>&gt; status quo and you&#39;re trying to make the point that `==` in the future need<br>&gt; not guarantee the same semantics?<br>&gt;<br>&gt;<br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;<br>&gt;<br>&gt; Nit: I think the more common term in stdlib would be `areEquivalent()`. Do<br>&gt; you think `same` in that context (independent of the word &quot;ordering&quot;) might<br>&gt; erroneously suggest identity?<br>&gt;<br>&gt;<br>&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;<br></p><p>Well, since you asked...<br>Wikipedia reminds me that a ~ b is an appropriate mathematical notation for<br>equivalence of a and b. We probably wouldn&#39;t want to confuse things with<br>bitwise not, but in the grand tradition of reduplicating to form operators<br>from their mathematical counterparts, what about infix operator `~~`? [In a<br>few minutes, I might find this to be a terrible idea.]<br></p><p>On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift Community,<br>&gt;&gt;<br>&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to<br>&gt;&gt; clean up the semantics of ordering relations in the standard library.  We<br>&gt;&gt; have a draft that you can get as a gist.<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any<br>&gt;&gt; feedback you might have about this proposal helps - though please keeps<br>&gt;&gt; your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/cc7c6847/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 22 Jul 2016, at 03:32, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is the status quo and you&#39;re trying to make the point that `==` in the future need not guarantee the same semantics?<br>&gt; <br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt; <br></p><p>As I understand it:<br></p><p>-&gt; what we call “Equatable” today checks for equivalence. For value types, equivalent is the same as equality (that’s why they are values - two instances with the same data are indistinguishable).<br>-&gt; For reference types, we have an instance-equality operator (===) which checks for what I believe you mean by equality.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/ce082924/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:48 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Jul 2016, at 03:32, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is the status quo and you&#39;re trying to make the point that `==` in the future need not guarantee the same semantics?<br>&gt;&gt; <br>&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; <br>&gt; <br>&gt; As I understand it:<br>&gt; <br>&gt; -&gt; what we call “Equatable” today checks for equivalence. For value types, equivalent is the same as equality (that’s why they are values - two instances with the same data are indistinguishable).<br>&gt; -&gt; For reference types, we have an instance-equality operator (===) which checks for what I believe you mean by equality.<br></p><p>Except that the standard floating point == is not an equivalence relation.  I’m not sure if the distinction introduced by this proposal is solely due to that or if there are other example use cases for making a distinction.<br></p><p>&gt; <br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/e00a5116/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 22 Jul 2016, at 16:54, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 22, 2016, at 9:48 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Jul 2016, at 03:32, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is the status quo and you&#39;re trying to make the point that `==` in the future need not guarantee the same semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As I understand it:<br>&gt;&gt; <br>&gt;&gt; -&gt; what we call “Equatable” today checks for equivalence. For value types, equivalent is the same as equality (that’s why they are values - two instances with the same data are indistinguishable).<br>&gt;&gt; -&gt; For reference types, we have an instance-equality operator (===) which checks for what I believe you mean by equality.<br>&gt; <br>&gt; Except that the standard floating point == is not an equivalence relation.  I’m not sure if the distinction introduced by this proposal is solely due to that or if there are other example use cases for making a distinction.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>If it is literally just that one FloatingPoint case, then should decide which FloatingPoint should offer as the default and offer the alternative implementation as a method on FloatingPoint (areIEEEEqual()? :P areEqualOrBothNan()?).<br></p><p>The additional benefit is that this secondary equivalence function is far more descriptive about what it is doing. I’m not sure you will really be able to write generic code which always knows whether (==/areSame) are appropriate, because the differences would be so subtle. You would really have to check on a type-by-type basis.<br></p><p>e.g.<br></p><p>func find&lt;T&gt;(_ value: T, in arr: Array&lt;T&gt;) -&gt; Array&lt;T&gt;.Index? {<br></p><p>    if T is FloatingPoint {<br>       return (arr as! Array&lt;FloatingPoint&gt;).index(where: { $0.areEqualOrBothNan(value) })<br>    }<br>    else {<br>        return arr.index(where: { $0 == value })<br>    }<br>}<br></p><p>Or something better without casting and with overloads for generic constraints…<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/edf2190b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 22, 2016 at 11:00:00am</p></header><div class="content"><p>Excellent point Karl.<br></p><p>In my view, floating point NaN values are really quite similar to `.none`.<br></p><p>I would be interested in exploring a move *away* from the IEEE 754 handling<br>of NaN. In particular, we could model Float and Double as optionals (maybe<br>implicitly-unwrapped) with NaN bit-patterns indicating `.none`.<br></p><p>Or we could model *just the non-NaN values* and make undefined operations<br>trap, among other possibilities.<br></p><p><br>5. Will it be considered &quot;ok&quot; to define a type for which `T.areSame(a, b)<br>&gt;&gt; == true` but `a != b`? An obvious example would be Double.nan, so I assume<br>&gt;&gt; the answer is a resounding yes.<br>&gt;<br>&gt;<br></p><p>Yes, because `==` is not a protocol requirement of Equatable, so it<br>&gt; can have domain-specific semantics.<br></p><p><br>Per SE-0091<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;<br>the<br>operator will be the protocol requirement.<br></p><p>Nevin<br></p><p><br>On Fri, Jul 22, 2016 at 11:06 AM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 22 Jul 2016, at 16:54, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 9:48 AM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 22 Jul 2016, at 03:32, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is nice. Is `areSame()` being proposed because static `==` is the<br>&gt; status quo and you&#39;re trying to make the point that `==` in the future need<br>&gt; not guarantee the same semantics?<br>&gt;<br>&gt;<br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;<br>&gt;<br>&gt; As I understand it:<br>&gt;<br>&gt; -&gt; what we call “Equatable” today checks for equivalence. For value types,<br>&gt; equivalent is the same as equality (that’s why they are values - two<br>&gt; instances with the same data are indistinguishable).<br>&gt; -&gt; For reference types, we have an instance-equality operator (===) which<br>&gt; checks for what I believe you mean by equality.<br>&gt;<br>&gt;<br>&gt; Except that the standard floating point == is not an equivalence<br>&gt; relation.  I’m not sure if the distinction introduced by this proposal is<br>&gt; solely due to that or if there are other example use cases for making a<br>&gt; distinction.<br>&gt;<br>&gt;<br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; If it is literally just that one FloatingPoint case, then should decide<br>&gt; which FloatingPoint should offer as the default and offer the alternative<br>&gt; implementation as a method on FloatingPoint (areIEEEEqual()? :P<br>&gt; areEqualOrBothNan()?).<br>&gt;<br>&gt; The additional benefit is that this secondary equivalence function is far<br>&gt; more descriptive about what it is doing. I’m not sure you will really be<br>&gt; able to write generic code which always knows whether (==/areSame) are<br>&gt; appropriate, because the differences would be so subtle. You would really<br>&gt; have to check on a type-by-type basis.<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; func find&lt;T&gt;(_ value: T, in arr: Array&lt;T&gt;) -&gt; Array&lt;T&gt;.Index? {<br>&gt;<br>&gt;     if T is FloatingPoint {<br>&gt;        return (arr as! Array&lt;FloatingPoint&gt;).index(where: {<br>&gt; $0.areEqualOrBothNan(value) })<br>&gt;     }<br>&gt;     else {<br>&gt;         return arr.index(where: { $0 == value })<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Or something better without casting and with overloads for generic<br>&gt; constraints…<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/eab52887/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 22, 2016 at 08:00:00am</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:38 AM, Nevin Brackett-Rozinsky<br>&lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; Excellent point Karl.<br>&gt;<br>&gt; In my view, floating point NaN values are really quite similar to `.none`.<br>&gt;<br>&gt; I would be interested in exploring a move *away* from the IEEE 754 handling<br>&gt; of NaN. In particular, we could model Float and Double as optionals (maybe<br>&gt; implicitly-unwrapped) with NaN bit-patterns indicating `.none`.<br>&gt;<br>&gt; Or we could model *just the non-NaN values* and make undefined operations<br>&gt; trap, among other possibilities.<br></p><p>I think these are non-starters.<br></p><p>&gt;&gt;&gt; 5. Will it be considered &quot;ok&quot; to define a type for which `T.areSame(a, b)<br>&gt;&gt;&gt; == true` but `a != b`? An obvious example would be Double.nan, so I assume<br>&gt;&gt;&gt; the answer is a resounding yes.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, because `==` is not a protocol requirement of Equatable, so it<br>&gt;&gt; can have domain-specific semantics.<br>&gt;<br>&gt;<br>&gt; Per SE-0091 the operator will be the protocol requirement.<br></p><p>If SE-0091 removes non-protocol operators, then we will have to change<br>the language again to accommodate what we need.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 8:54 AM Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 8:38 AM, Nevin Brackett-Rozinsky<br>&gt; &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; &gt; Excellent point Karl.<br>&gt; &gt;<br>&gt; &gt; In my view, floating point NaN values are really quite similar to<br>&gt; `.none`.<br>&gt; &gt;<br>&gt; &gt; I would be interested in exploring a move *away* from the IEEE 754<br>&gt; handling<br>&gt; &gt; of NaN. In particular, we could model Float and Double as optionals<br>&gt; (maybe<br>&gt; &gt; implicitly-unwrapped) with NaN bit-patterns indicating `.none`.<br>&gt; &gt;<br>&gt; &gt; Or we could model *just the non-NaN values* and make undefined operations<br>&gt; &gt; trap, among other possibilities.<br>&gt;<br>&gt; I think these are non-starters.<br>&gt;<br>&gt; &gt;&gt;&gt; 5. Will it be considered &quot;ok&quot; to define a type for which `T.areSame(a,<br>&gt; b)<br>&gt; &gt;&gt;&gt; == true` but `a != b`? An obvious example would be Double.nan, so I<br>&gt; assume<br>&gt; &gt;&gt;&gt; the answer is a resounding yes.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, because `==` is not a protocol requirement of Equatable, so it<br>&gt; &gt;&gt; can have domain-specific semantics.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Per SE-0091 the operator will be the protocol requirement.<br>&gt;<br>&gt; If SE-0091 removes non-protocol operators, then we will have to change<br>&gt; the language again to accommodate what we need.<br>&gt;<br></p><p>SE-0091 does not (is not intended) to remove non-protocol operators. Global<br>free operators can still exist; that proposal only clarifies the way that<br>operator requirements within protocols manifest on conforming types (and<br>how lookup is affected as a result).<br></p><p><br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/660b240a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 21, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>On Thu, Jul 21, 2016 at 6:11 PM, Robert Widmann via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift Community,<br>&gt;<br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean<br>&gt; up the semantics of ordering relations in the standard library.<br></p><p>Great work!<br></p><p>As a part of your implementation, are you planning to add &lt;=&gt;<br>overloads for tuples, like we do now for comparison operators?  (See<br>stdlib/public/core/Tuple.swift.gyb.)<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 05:00:00am</p></header><div class="content"><p>Robert, the gist is notably vague on this point, so I&#39;m hoping you will<br>clarify. Are you proposing that FloatingPoint will break with IEEE754<br>semantics? What will be the result of `Float.nan == Float.nan`?<br></p><p>(My guess at the sanest outcome is that areSame/Equivalent() and &lt;=&gt; will<br>be totally ordered but FloatingPoint types will override == and the<br>standard comparison operators to maintain IEEE754 semantics, yes?)<br></p><p><br>On Thu, Jul 21, 2016 at 11:02 PM Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 6:11 PM, Robert Widmann via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift Community,<br>&gt; &gt;<br>&gt; &gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to<br>&gt; clean<br>&gt; &gt; up the semantics of ordering relations in the standard library.<br>&gt;<br>&gt; Great work!<br>&gt;<br>&gt; As a part of your implementation, are you planning to add &lt;=&gt;<br>&gt; overloads for tuples, like we do now for comparison operators?  (See<br>&gt; stdlib/public/core/Tuple.swift.gyb.)<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/99bb7240/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 21, 2016 at 10:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 10:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Robert, the gist is notably vague on this point, so I&#39;m hoping you will<br>&gt; clarify. Are you proposing that FloatingPoint will break with IEEE754<br>&gt; semantics? What will be the result of `Float.nan == Float.nan`?<br>&gt;<br>&gt; (My guess at the sanest outcome is that areSame/Equivalent() and &lt;=&gt; will be<br>&gt; totally ordered but FloatingPoint types will override == and the standard<br>&gt; comparison operators to maintain IEEE754 semantics, yes?)<br></p><p>Right, == (and !=, &lt;, &gt;, &lt;=, &gt;=) can be customized with<br>domain-specific semantics, and floating point does this.  In addition,<br>floating point protocols will list == as a requirement, so generic<br>code generic over floating point types will get IEEE 754 semantics<br>when using == syntax, but code that only has an Equatable requirement<br>will use the total ordering semantics.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July 21, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 10:37 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Jul 21, 2016 at 10:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; Robert, the gist is notably vague on this point, so I&#39;m hoping you will<br>&gt;&gt; clarify. Are you proposing that FloatingPoint will break with IEEE754<br>&gt;&gt; semantics? What will be the result of `Float.nan == Float.nan`?<br>&gt;&gt; <br>&gt;&gt; (My guess at the sanest outcome is that areSame/Equivalent() and &lt;=&gt; will be<br>&gt;&gt; totally ordered but FloatingPoint types will override == and the standard<br>&gt;&gt; comparison operators to maintain IEEE754 semantics, yes?)<br>&gt; <br>&gt; Right, == (and !=, &lt;, &gt;, &lt;=, &gt;=) can be customized with<br>&gt; domain-specific semantics, and floating point does this.  In addition,<br>&gt; floating point protocols will list == as a requirement, so generic<br>&gt; code generic over floating point types will get IEEE 754 semantics<br>&gt; when using == syntax, but code that only has an Equatable requirement<br>&gt; will use the total ordering semantics.<br></p><p>I think this needs to be spelled out clearly in the final proposal. Floating-point compares involving NaN are mentioned in the motivation section, but there is no clear connection made to that issue in the proposal or detailed design.<br></p><p>Mark<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 21, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 6:11 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift Community,<br>&gt; <br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist.  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br></p><p>My thoughts on this are not yet fully formed, but I have a couple questions concerning `isSame(_:_:)` and `==`:<br></p><p>* Should calls like `index(of:)` and `split(separator:)` use `==` or `isSame(_:_:)`?<br></p><p>* Should `Hashable` use `==` or `isSame(_:_:)`?<br></p><p>* Do we know of any use cases where a type conforms to `Equatable` but not `Comparable` and needs separate `isSame(_:_:)` and `==` operators? <br></p><p>Essentially, I&#39;m wondering if we can leave `Equatable`&#39;s definition alone and only change `Comparable` to require `&lt;=&gt;`, with a generic operator to provide a default `==` which uses `&lt;=&gt;`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 21, 2016 at 11:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 11:09 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jul 21, 2016, at 6:11 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello Swift Community,<br>&gt;&gt;<br>&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist.  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;<br>&gt; My thoughts on this are not yet fully formed, but I have a couple questions concerning `isSame(_:_:)` and `==`:<br>&gt;<br>&gt; * Should calls like `index(of:)` and `split(separator:)` use `==` or `isSame(_:_:)`?<br></p><p>Use sites should always use `==`.  They will pick up the semantics<br>appropriate for the generic constraints they see.<br></p><p>&gt; * Should `Hashable` use `==` or `isSame(_:_:)`?<br></p><p>Code generic over Hashable will not see a difference.<br></p><p>&gt; * Do we know of any use cases where a type conforms to `Equatable` but not `Comparable` and needs separate `isSame(_:_:)` and `==` operators?<br></p><p>No, but I can easily imagine that one exists.<br></p><p>&gt; Essentially, I&#39;m wondering if we can leave `Equatable`&#39;s definition alone and only change `Comparable` to require `&lt;=&gt;`, with a generic operator to provide a default `==` which uses `&lt;=&gt;`.<br></p><p>We can&#39;t do that, because two values equal according to `&lt;=&gt;` should<br>be equal according to Equatable.  Otherwise protocols don&#39;t make any<br>sense.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 22, 2016 at 09:00:00am</p></header><div class="content"><p>Just trying to summarize to make sure I understand. So, on most Equatable types, == and areSame will have the same semantics (return the same result for all operations), but some types will want different semantics, and that&#39;s why areSame is introduced.<br></p><p>Correct?<br></p><p>If that&#39;s the case, I&#39;m a bit perplexed on what types would want different semantics for == and areSame. Is FloatingPoint one of them? Is that why NaN is brought up in the Motivation section?<br></p><p>If that is the reason, perhaps an example showing the different semantics of == and areSame for FloatingPoint would be great.<br></p><p>And yes, I kind of prefer areEquivalent. It does remove the identity ambiguity.<br></p><p>Sent from my iPhone<br>&gt; On 22 Jul 2016, at 08:34, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Jul 21, 2016 at 11:09 PM, Brent Royal-Gordon via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Jul 21, 2016, at 6:11 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist.  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt; <br>&gt;&gt; My thoughts on this are not yet fully formed, but I have a couple questions concerning `isSame(_:_:)` and `==`:<br>&gt;&gt; <br>&gt;&gt; * Should calls like `index(of:)` and `split(separator:)` use `==` or `isSame(_:_:)`?<br>&gt; <br>&gt; Use sites should always use `==`.  They will pick up the semantics<br>&gt; appropriate for the generic constraints they see.<br>&gt; <br>&gt;&gt; * Should `Hashable` use `==` or `isSame(_:_:)`?<br>&gt; <br>&gt; Code generic over Hashable will not see a difference.<br>&gt; <br>&gt;&gt; * Do we know of any use cases where a type conforms to `Equatable` but not `Comparable` and needs separate `isSame(_:_:)` and `==` operators?<br>&gt; <br>&gt; No, but I can easily imagine that one exists.<br>&gt; <br>&gt;&gt; Essentially, I&#39;m wondering if we can leave `Equatable`&#39;s definition alone and only change `Comparable` to require `&lt;=&gt;`, with a generic operator to provide a default `==` which uses `&lt;=&gt;`.<br>&gt; <br>&gt; We can&#39;t do that, because two values equal according to `&lt;=&gt;` should<br>&gt; be equal according to Equatable.  Otherwise protocols don&#39;t make any<br>&gt; sense.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/30df3be2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 22, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 12:29 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; Just trying to summarize to make sure I understand. So, on most Equatable<br>&gt; types, == and areSame will have the same semantics (return the same result<br>&gt; for all operations), but some types will want different semantics, and<br>&gt; that&#39;s why areSame is introduced.<br>&gt;<br>&gt; Correct?<br></p><p>Correct.<br></p><p>Note that only the `areSame()` function is the Equatable requirement.<br>For `==`, there will be a global generic operator, that will just<br>forward to `areSame()`.  Individual types can add their own overloads<br>of `==` which will be preferred over the generic `==` due to overload<br>resolution rules.<br></p><p>&gt; If that&#39;s the case, I&#39;m a bit perplexed on what types would want different<br>&gt; semantics for == and areSame. Is FloatingPoint one of them? Is that why NaN<br>&gt; is brought up in the Motivation section?<br></p><p>Yes, floating point types are a good example.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 22 Jul 2016, at 04:11, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist.  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br></p><p>Bravo! It would be great to have Comparable defined in terms of a full comparison. I&#39;d specifically call out String as a concrete example in the Motivation section, as this proposal is likely to give a performance boost on sorting String arrays, which is a pretty common thing to do.<br></p><p>----<br></p><p>I think the Detailed design section should explicitly show as source code:<br></p><p>1. What is the updated Equatable protocol?<br></p><p>2. What are all the updated operators? (I.e. show the new default implementations of `==` and `!=` too.)<br></p><p>3. In code comments, what are the updated rules or laws that should hold for Equatable and Comparable (and FloatingPoint, if any)?<br></p><p>4. What are the new &quot;by: (Self, Self) -&gt; Ordering&quot; functions that the proposal is about to introduce to the stdlib?<br></p><p>----<br></p><p>On the topic of partial orderings (e.g. floating-point types), starting with the more important questions first:<br></p><p>5. Will it be considered &quot;ok&quot; to define a type for which `T.areSame(a, b) == true` but `a != b`? An obvious example would be Double.nan, so I assume the answer is a resounding yes.<br></p><p>6. Similarly, will it be &quot;ok&quot; to define a type for which `T.areSame(a, b) == false` but `a == b`? One possible example could be the comparison of `-0.0 &lt;=&gt; +0.0`. Should those be `.same` or not?<br></p><p>7. What, in fact, is the proposed total order for the stdlib&#39;s floating-point types?<br></p><p>(For an example, here is one possible way of defining `&lt;=&gt;` for Double, using `Double.bitPattern`. It distinguishes between +0.0 and -0.0, and even the various patterns of NaN! But do we want this for our `&lt;=&gt;` or something else?<br></p><p>    func &lt;=&gt; (lhs: Double, rhs: Double) -&gt; Ordering {<br>      func f(_ x: UInt64) -&gt; UInt64 {<br>        return x &lt; 0x80000000_00000000 ? x + 0x80000000_00000000 : ~x<br>      }<br>      return f(lhs.bitPattern) &lt;=&gt; f(rhs.bitPattern)<br>    }<br>    print(            -0.0 &lt;=&gt; 0.0)         // ascending<br>    print(             1.0 &lt;=&gt; 0.0)         // descending<br>    print( Double.infinity &lt;=&gt; Double.nan)  // ascending<br>    print(-Double.infinity &lt;=&gt; -Double.nan) // descending<br>    print(      Double.nan &lt;=&gt; Double.nan)  // same<br></p><p>See http://swiftlang.ng.bluemix.net/#/repl/5791db33719d5d045b4d430c for a running example.)<br></p><p>----<br></p><p>A general idea:<br></p><p>8. I wouldn&#39;t mind if the proposal also covered including generated definitions for `tuple1 &lt;=&gt; tuple2` of tuples from zero arity through to 6 or whatever the gyb&#39;s upper limit may be.<br></p><p>That would simplify the example implementation of Date down to:<br></p><p>    func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>      return (lhs.year, lhs.month, lhs.day)<br>         &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>    }<br></p><p>9. Some of us were not satisfied with the name of `.areSame(_:_:)`. Let me just point out that it would be nice if the name aligned with whatever `Ordering.same` will be called.<br></p><p>-- Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 22, 2016 at 08:00:00am</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 2:13 AM, Pyry Jahkola via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; 5. Will it be considered &quot;ok&quot; to define a type for which `T.areSame(a, b) == true` but `a != b`? An obvious example would be Double.nan, so I assume the answer is a resounding yes.<br></p><p>Yes, because `==` is not a protocol requirement of Equatable, so it<br>can have domain-specific semantics.<br></p><p>&gt; 6. Similarly, will it be &quot;ok&quot; to define a type for which `T.areSame(a, b) == false` but `a == b`? One possible example could be the comparison of `-0.0 &lt;=&gt; +0.0`. Should those be `.same` or not?<br>&gt;<br>&gt; 7. What, in fact, is the proposed total order for the stdlib&#39;s floating-point types?<br></p><p>The IEEE 754 definition.<br></p><p>https://github.com/apple/swift/blob/f318fe853d7898246db24d501f1ddc03c9eb8651/stdlib/public/core/FloatingPoint.swift.gyb#L855<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>Dmitri Gribenko wrote:<br></p><p>&gt;&gt; 7. What, in fact, is the proposed total order for the stdlib&#39;s floating-point types?<br>&gt; <br>&gt; The IEEE 754 definition.<br>&gt; <br>&gt; https://github.com/apple/swift/blob/f318fe853d7898246db24d501f1ddc03c9eb8651/stdlib/public/core/FloatingPoint.swift.gyb#L855<br></p><p>Cool. So if I&#39;m reading it correctly, that&#39;s exactly the same order as what I defined here, using bitPattern: http://swiftlang.ng.bluemix.net/#/repl/5791db33719d5d045b4d430c. I suppose your implementation is better in the usual case where most values are in the range of -Double.infinity ... Double.infinity.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/d999559d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Definitely a +1 from me, in fact I&#39;ve implemented essentially this as an extension for my own convenience, but would definitely prefer it to be a proper component of the stdlib.<br></p><p>I have some queries to raise:<br></p><p>First is the naming, to me Ordering implies the enum itself is used for ordering collections but that&#39;s not really the case. In my own hacked implementation I&#39;m using Order.before, Order.same, and Order.after. It&#39;s not much of a change, but it seems to clarify what the enum is, at least in my opinion.<br>One thing I was considering, but didn&#39;t do since my extension is just a bolt-on for convenience, is whether the before/ascending and after/descending cases should contain a value, allowing implementations to provide a hint of how far back/forward an element should be. This is a hint only of course, but could be useful; for example, when implementing a binary search you could instead use the hint value to provide a (hopefully) better guess at where to jump to next, for example if the value is very high you might jump to a position forward backward/forward rather than always selecting the middle every time. This is what Java&#39;s Comparable type does, since it uses a number where negative is before, 0 is same and positive is after.<br>Why is Equatable in this case implemented with a static .areSame() method, but Comparable isn&#39;t implemented by a static .compare() method? Seems like they should both be the same personally.<br>There should be a way to &quot;flip&quot; the operator. One thing that&#39;s great about the current sorting method is the ability to pass the &lt; or &gt; operators for ascending/descending respectively, we can do the first one by passing the &lt;=&gt; operator, but a flip function or something would be nice to, well, flip it (swap the ascending and descending cases before returning).<br></p><p>Just some thoughts, but I definitely want this.<br></p><p>&gt; On 22 Jul 2016, at 02:11, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift Community,<br>&gt; <br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist. &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/8ade1775/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 22 Jul 2016, at 03:11, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift Community,<br>&gt; <br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to clean up the semantics of ordering relations in the standard library.  We have a draft that you can get as a gist. &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any feedback you might have about this proposal helps - though please keeps your comments on Swift-Evolution and not on the gist.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I fear that this will become confusing (especially since Equatable may now be implemented as a static function, too). We will have 3 different “equality” comparisons in Swift:<br></p><p>=== for reference-types<br>== for all types<br>areSame() which may be subtly different to ==<br></p><p>In order to have an opinion on whether or not this is justified, I need to know more about how areSame() may differ from == and how this will affect generic code. What is required that could not fit inside an override of Equatable? If this only applies to a few types, will it be its own protocol (e.g. EquivalenceCheckable)?<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/a0d1034d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>I like a lot of this, but the changes to Equatable are where I get stuck.<br>What are the scenarios where areSame is useful *outside* the context of the<br>proposed new Comparable interface?<br></p><p>I ask because changing the requirement for Equatable to areSame instead of<br>== seems like a backwards change to me. There are plenty of unorderable<br>types where == is the obvious thing you want to implement, and this makes<br>it less obvious. It also adds a named method to a protocol to serve the<br>purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>(even though you keep the global one and delegate to it).<br></p><p>There are two concepts at play here: comparability and orderability. 99.99%<br>of the time, they are identical. Your proposal mentions one place where<br>they&#39;re not: IEEE floating point numbers, because there exists an element<br>in that space, NaN, that doesn&#39;t satisfy an equivalence relation at all.<br>But it&#39;s still reasonable to want a stable ordering with those included.<br></p><p>In the proposal as it&#39;s written right now, the individual inequality<br>operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>the default implementations provided would make the latter true. So<br>FloatingPoint would still have to provide its own implementations of *all<br>of the (in)equality operators*, not just ==, in order to have the correct<br>definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>write-up.<br></p><p>That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>written, with some tweaks):<br></p><p>1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>equivalence and equality on its own (if there is one, please let me know!).<br>As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>Equatable when it shouldn&#39;t.<br>2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>implement &lt;=&gt; and get everything else for free, but it also lets types<br>replace individual operators with customized implementations (see #4 below)<br>easily *within* the type (SE-0091).<br>3) Comparable should be documented to imply that the default behavior is to<br>link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>changed, meaning that only &lt;=&gt; must define a total ordering and the<br>individual comparison operators need not.<br>4) The very few types, like FloatingPoint, that need to provide<br>domain-specific behavior to do the obvious/intended thing for users can and<br>should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>explicitly, and it would *not* affect ordering. I think it&#39;s entirely<br>reasonable to have (NaN == NaN) return false and (NaN != NaN) return true<br>but (NaN &lt;=&gt; NaN) return .same without introducing another areSame concept,<br>because the former is demanded by IEEE 754.<br>5) Algorithms that rely on a total order, like sorts, must be implemented<br>in terms of &lt;=&gt;, not in terms of the individual operators, because of the<br>possibility that the definitions can be severed above.<br></p><p>As mentioned below, the one thing that a three-way comparison loses is the<br>easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>trivial to write a function that does this and I think it should be<br>included as part of the proposal. Something like this (may be typos, I&#39;m<br>writing it in Gmail):<br></p><p>public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>-&gt; Ordering {<br>  return { lhs, rhs in<br>    switch ordering(lhs, rhs) {<br>    case .ascending: return .descending<br>    case .descending: return .ascending<br>    case .same: return .same<br>  }<br>}<br></p><p>(Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>it.)<br></p><p><br>On Thu, Jul 21, 2016 at 6:11 PM Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift Community,<br>&gt;<br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal to<br>&gt; clean up the semantics of ordering relations in the standard library.  We<br>&gt; have a draft that you can get as a gist.<br>&gt; &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;  Any<br>&gt; feedback you might have about this proposal helps - though please keeps<br>&gt; your comments on Swift-Evolution and not on the gist.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/f51ebb40/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
