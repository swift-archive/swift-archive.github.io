<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September 18, 2016 at 12:00:00pm</p></header><div class="content"><p>*TLÕæDR:*<br></p><p>Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most<br>source-breaking changes were done with in Swift 3; however, the<br>categorization of Unicode characters into identifiers &amp; operators was never<br>thoroughly discussed on swift-evolution. This seems like it might be our<br>last chance, and I think there are some big improvements to be had.<br></p><p>I&#39;ve gathered some information+thoughts into an early-stage pitch /<br>pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can<br>discuss these issues and come up with good (pragmatic) solutions here. I<br>imagine this can morph into a proposal later.<br></p><p>You can read the following in nicer HTML form at<br>https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59<br></p><p>I look forward to the discussion!<br></p><p>-Jacob<br></p><p>*# Background and motivation*<br></p><p>To ease lexing/parsing and avoid user confusion, the names of custom<br>identifiers (type names, variable names, etc.) and operators in Swift can<br>be composed of (mostly) separate sets of characters.<br></p><p>Using terminology from TSPL:<br></p><p>`identifier-head`/`operator-head` are characters which can *begin *an<br>identifier or operator.<br></p><p>`identifier-character`/`operator-character` are characters which can appear<br>anywhere in an identifier or operator (these are supersets of the `-head`<br>sets).<br></p><p>&lt;<br>https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html<br>&gt;<br></p><p>(Note also that some particular arrangements of characters are reserved;<br>for instance, `$` followed by digits for an implicit closure parameter, and<br>&quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot<br>elsewhere.&quot; There are also special characters in the language which are<br>neither identifiers nor operators, such as: `()[]{},:@#`)<br></p><p><br>*## Prior discussion on swift-evolution*<br></p><p>*&quot;Request to add middle dot (U+00B7) as operator character?&quot;*<br>&lt;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html<br>&gt;<br></p><p>*&quot;Free the &#39;$&#39; Symbol!&quot;*<br>&lt;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html<br>&gt;<br></p><p>*&quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;*<br>&lt;https://github.com/apple/swift-evolution/pull/354&gt;<br></p><p><br>Chris Lattner has said:<br></p><p>&gt; &quot;...our current operator space (particularly the unicode segments<br>covered) is not super well considered.  It would be great for someone to<br>take a more systematic pass over them to rationalize things.&quot;<br></p><p>&gt; &quot;We need a token to be unambiguously an operator or identifier - we can<br>have different rules for the leading and subsequent characters though.&quot;<br></p><p><br>*# Current state of affairs*<br></p><p>Swift&#39;s `identifier-head` and `identifier-character` mostly conform to the<br>recommendations in &lt;<br>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html&gt;<br>&lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489&gt;<br></p><p>The allowed operator characters include &quot;Unicode math, symbol, arrow,<br>dingbat, and line/box drawing chars&quot;, however I don&#39;t believe this aligns<br>with any particular spec:<br>&lt;<br>https://github.com/apple/swift/blob/08e7963/include/swift/AST/Identifier.h#L87-L121&gt;<br></p><p>&lt;https://github.com/apple/swift/commit/a2341a4&gt;<br></p><p><br></p><p>*## Identifiers/operators elsewhere*<br></p><p>There is an Unicode Standard Annex &quot;identifier and pattern syntax&quot; &lt;<br>http://unicode.org/reports/tr31/&gt; which defines the categories<br>`ID_Start`/`ID_Continue`.<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AID_Continue%3A%5D<br>&gt;<br></p><p>*### ECMAScript 2015 &quot;ES6&quot;*<br></p><p>Uses `ID_Start` and `ID_Continue`, as well as `Other_ID_Start` /<br>`Other_ID_Continue`.<br>&lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br></p><p>*### Haskell*<br></p><p>Distinguishes identifiers/operators by their general category (such as &quot;any<br>Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, etc.).<br>&lt;http://www.fileformat.info/info/unicode/category/index.htm&gt;<br></p><p>In particular, identifiers can start with any lowercase letter or _, and<br>may contain any letter/digit/&#39;/_. This would seem to include letters like Œ¥<br>and –Ø, and digits like Ÿ¢.<br></p><p>&lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&lt;<br>https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973<br>&gt;<br></p><p><br></p><p>*# Current problems*<br></p><p>*## Weird identifier code points*<br></p><p>The current `identifier-character` set contains many characters which<br>wouldn&#39;t make good identifiers:<br></p><p>- 11 entire planes of characters (U+20000‚ÄìU+2FFFD, etc.) which are<br>currently unassigned.<br>- The middle dot ¬∑ which looks like an operator.<br>- Many non-combining &quot;modifiers&quot; and accent marks, such as ¬¥ and ¬® and Íìª<br>which don&#39;t really make sense on their own.<br>- &quot;Tone marks&quot; from various languages, including À´ (similar to a<br>box-drawing character ‚îú which is an operator).<br>- The &quot;Greek question mark&quot; Õæ<br>- Symbols which are simply not linguistic, such as €û and ‡ºí.<br></p><p>short url: &lt;https://goo.gl/tyn0Cz&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D<br>&gt;<br></p><p>*## Weird operator code points*<br></p><p>The current `operator-character` set has a lot of characters that are<br>clearly operator-esque (‚âà ‚àà ‚äï ‚äÖ), but some things are not so obviously<br>desirable:<br></p><p>- Box-drawing characters<br>- Combining accents and other characters<br>- Various symbols, e.g. ‚öÑ and ‚ôÑ (this category also overlaps with emoji)<br>- Braille patterns such as ‚†ü ‚Äî should they not be treated as letter-like<br>(thus identifiers)?<br>- A plethora of arrows<br></p><p>short url: &lt;https://goo.gl/s136Nh&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D<br>&gt;<br></p><p><br>*## Code points which are both*<br></p><p>A handful of characters are accepted *both* as `identifier-head` and<br>`operator-head` (which seems pointless and might have been unintentional):<br></p><p>U+3021‚ÄìU+3029, Suzhou numerals  „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© &lt;<br>https://en.wikipedia.org/wiki/Suzhou_numerals&gt;<br></p><p>U+302A‚ÄìU+302F, ideographic &amp; hangul tone marks   „Ä™  „Ä´  „Ä¨  „Ä≠  „ÄÆ  „ÄØ<br></p><p>    let „Ä® = 2<br>    infix operator &lt;„Ä®&gt;<br></p><p>(Note that `infix operator „Ä®` doesn&#39;t work because the lexer greedily<br>treats this as an identifier. Also, interestingly, the corresponding<br>ideographic zero „Äá is only an identifier char.)<br></p><p>short url: &lt;https://goo.gl/lZcMqO&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d]<br>&gt;<br></p><p>In addition to the numerals and tone marks above, many (all?) *combining<br>marks* are accepted as `identifier-character` and `operator-character`.<br>These may be necessary for natural-looking words in some languages, but<br>they don&#39;t seem necessary for operators.<br></p><p>Also present in both sets are the *variation selectors* 1 through 256<br>(U+FE00‚ÄìU+FE0F, U+E0100‚ÄìU+E01EF). It seems they are of limited use for the<br>operator characters, unless you count the emoji: &lt;<br>http://www.unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt&gt;<br></p><p>short url: &lt;https://goo.gl/VKrisf&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d]<br>&gt;<br></p><p><br>*## Code points which should be illegal*<br></p><p>There are several surprising non-printing characters, including:<br></p><p>- U+2064 INVISIBLE PLUS is currently an identifier<br>- U+200B ZERO WIDTH SPACE is currently an identifier<br></p><p>No good will come of these. Invisible characters should probably be<br>disallowed (although some may be necessary for properly joining/splitting<br>characters in some other languages).<br></p><p><br>*## Categories which are split between identifiers and operators*<br></p><p>- Emoji and symbols: most of the newer emoji are identifiers, but many<br>emoji/pictographs are operators, especially those from &quot;Miscellaneous<br>Symbols&quot;. The results are hilariously illogical:<br></p><p>  - ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>  - ‚úåÔ∏è is an operator, but ü§ò is an identifier.<br>  - üîº is an operator, but ‚ñ∂Ô∏è is an identifier.<br>  - ‚ú≥Ô∏è is an operator, but üîØ is an identifier.<br>  - ‚úàÔ∏è is an operator, but üõ© is an identifier.<br>  - ‚ô†Ô∏è is an operator, but üÇ° is an identifier. (Presumably, üÇ° = A ‚ô†Ô∏è üÇ†!)<br></p><p>  (But the counterintuitive examples extend outside the emoji too: + is an<br>operator, while ‚Çä and ‚Å∫ are identifiers.)<br></p><p>- Currency symbols: ¬¢ ¬£ ¬§ ¬• are operators, but ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø and many others<br>are identifiers, and $ is allowed in an identifier.<br></p><p><br>*## Missing characters*<br></p><p>A handful of characters are neither operators nor identifiers. This list<br>mostly makes sense (reserved characters and whitespace), but I wonder about<br>a few which seem like they could easily be operators: ‚ëä ‚ëÄ ÔπÖ etc.<br></p><p>short url: &lt;https://goo.gl/U0GVNn&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D<br>&gt;<br></p><p><br>*# Solutions*<br></p><p>Still up for discussion ‚Äî please reply to this thread!<br></p><p>Adopting (X)ID_Start/Continue for identifiers, or a simpler solution like<br>Haskell&#39;s use of &quot;letter&quot; categories, might work well.<br></p><p>(I&#39;ve given up hope of finding some kind of &quot;perfect&quot; solution ‚Äî how can it<br>be possible, when ·õè is a letter, yet ‚Üë is not?)<br></p><p>Making the choice of operator characters more logical/standards-based would<br>be nice (not just a set of ranges). However, Haskell&#39;s approach of using<br>all punctuation &amp; symbols is probably not right for Swift:<br></p><p>short url: &lt;https://goo.gl/Ud4KqY&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D<br>&gt;<br></p><p>I&#39;m not really sure what to do with emoji ‚Äî they&#39;re a very cute novelty<br>feature, but I don&#39;t know what the motivation is for including these as<br>valid operators/identifiers.<br></p><p>At the least, we should try to gather them all into one of the two<br>categories. My inclination would be to keep them as identifiers, which<br>would mean moving the following out of the operator category:<br></p><p>short url: &lt;https://goo.gl/CBJEKX&gt;<br></p><p>&lt;<br>http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D<br>&gt;<br></p><p><br>*# Concurrently-discussable topics*<br></p><p>There are a few relevant topics that came to mind, which I think are worth<br>discussing around the same time.<br></p><p>*## Dollar signs ($)*<br></p><p>$ is currently allowed in identifiers, but it can&#39;t begin an identifier<br>except for the magic implicit closure params ($0, $1, ...) and<br>LLDB/REPL-related uses.<br></p><p>It&#39;s arguable, but I feel that $ would be more effective as an operator<br>character than an identifier character. There&#39;s precedent in Haskell for<br>operators like `&lt;$&gt;` and being able to replicate these in Swift would be<br>nice.<br></p><p><br>*## Diagnostics improvements*<br></p><p>Regardless of what ends up being the ultimate solution, it would be great<br>to improve diagnostics for cases when the wrong types of characters are<br>used.<br></p><p>`infix operator abc` produces `&#39;abc&#39; is considered to be an identifier, not<br>an operator`. That&#39;s not too bad.<br></p><p>`let +++ = 3` produces `expected pattern`.<br></p><p>`let $foo = 3` produces `expected numeric value following &#39;$&#39;`.<br></p><p><br>*## Security and —ÅŒønfu—ï–∞bI–µ characters*<br></p><p>Confusable characters (e vs. –µ, o vs. Œø, ; vs. Õæ) are an issue not taken<br>lightly in the world of web security (cf. domain names). I haven&#39;t found<br>much information about whether this has been considered a major security<br>issue in programming languages, but I would think so (one can imagine such<br>characters being introduced to a codebase subtly over time, hiding<br>malicious functionality).<br></p><p>It&#39;d be pretty cool if Swift could detect whether two identifiers might be<br>confusable, and produce a warning.<br></p><p>&lt;http://www.unicode.org/reports/tr36/#Recommendations_General&gt;<br>&lt;http://unicode.org/reports/tr39/#Confusable_Detection&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/975425b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 18, 2016 at 09:00:00pm</p></header><div class="content"><p>Some thoughts<br></p><p>&gt; On Sep 18, 2016, at 3:33 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; TLÕæDR:<br>&gt; <br>&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most source-breaking changes were done with in Swift 3; however, the categorization of Unicode characters into identifiers &amp; operators was never thoroughly discussed on swift-evolution. This seems like it might be our last chance, and I think there are some big improvements to be had.<br>&gt; <br>&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch / pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can discuss these issues and come up with good (pragmatic) solutions here. I imagine this can morph into a proposal later.<br>&gt; <br>&gt; You can read the following in nicer HTML form at https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59 &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt;<br>&gt; <br>&gt; I look forward to the discussion!<br>&gt; <br>&gt; -Jacob<br>&gt; <br>&gt; # Background and motivation<br>&gt; <br>&gt; To ease lexing/parsing and avoid user confusion, the names of custom identifiers (type names, variable names, etc.) and operators in Swift can be composed of (mostly) separate sets of characters.<br>&gt; <br>&gt; Using terminology from TSPL:<br>&gt; <br>&gt; `identifier-head`/`operator-head` are characters which can begin an identifier or operator.<br>&gt; <br>&gt; `identifier-character`/`operator-character` are characters which can appear anywhere in an identifier or operator (these are supersets of the `-head` sets).<br>&gt; <br>&gt; &lt;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html &lt;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&gt;&gt;<br>&gt; <br>&gt; (Note also that some particular arrangements of characters are reserved; for instance, `$` followed by digits for an implicit closure parameter, and &quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.&quot; There are also special characters in the language which are neither identifiers nor operators, such as: `()[]{},:@#`)<br>&gt; <br>&gt; <br>&gt; ## Prior discussion on swift-evolution<br>&gt; <br>&gt; &quot;Request to add middle dot (U+00B7) as operator character?&quot;<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;&gt;<br>&gt; <br>&gt; &quot;Free the &#39;$&#39; Symbol!&quot;<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;&gt;<br>&gt; <br>&gt; &quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/354 &lt;https://github.com/apple/swift-evolution/pull/354&gt;&gt;<br>&gt; <br>&gt; <br>&gt; Chris Lattner has said:<br>&gt; <br>&gt; &gt; &quot;...our current operator space (particularly the unicode segments covered) is not super well considered.  It would be great for someone to take a more systematic pass over them to rationalize things.&quot;<br>&gt; <br>&gt; &gt; &quot;We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.&quot;<br>&gt; <br></p><p>I feel a bit bad having implemented the patch that banned this - it feels like dollar was mistakenly left out of the operator character range considering how well it worked in operators up to then.  Disambiguation with respect to other language constructs (anonymous parameters in closures and LLDB variables) is trivial and we already had diagnostics about it.<br></p><p>I definitely support having Swift‚Äôs operators use a wider range of the unicode spectrum - perhaps even a policy where instead of whitelisting ranges we blacklist reserved characters or ranges.<br></p><p>&gt; <br>&gt; # Current state of affairs<br>&gt; <br>&gt; Swift&#39;s `identifier-head` and `identifier-character` mostly conform to the recommendations in &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html&gt;&gt;<br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489 &lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489&gt;&gt;<br>&gt; <br>&gt; The allowed operator characters include &quot;Unicode math, symbol, arrow, dingbat, and line/box drawing chars&quot;, however I don&#39;t believe this aligns with any particular spec:<br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/include/swift/AST/Identifier.h#L87-L121 &lt;https://github.com/apple/swift/blob/08e7963/include/swift/AST/Identifier.h#L87-L121&gt;&gt;<br>&gt; &lt;https://github.com/apple/swift/commit/a2341a4 &lt;https://github.com/apple/swift/commit/a2341a4&gt;&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; ## Identifiers/operators elsewhere<br>&gt; <br>&gt; There is an Unicode Standard Annex &quot;identifier and pattern syntax&quot; &lt;http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;&gt; which defines the categories `ID_Start`/`ID_Continue`.<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AID_Continue%3A%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AID_Continue%3A%5D&gt;&gt;<br>&gt; <br>&gt; ### ECMAScript 2015 &quot;ES6&quot;<br>&gt; <br>&gt; Uses `ID_Start` and `ID_Continue`, as well as `Other_ID_Start` / `Other_ID_Continue`.<br>&gt; &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;&gt;<br>&gt; <br>&gt; ### Haskell<br>&gt; <br>&gt; Distinguishes identifiers/operators by their general category (such as &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, etc.).<br>&gt; &lt;http://www.fileformat.info/info/unicode/category/index.htm &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt;&gt;<br>&gt; <br>&gt; In particular, identifiers can start with any lowercase letter or _, and may contain any letter/digit/&#39;/_. This would seem to include letters like Œ¥ and –Ø, and digits like Ÿ¢.<br>&gt; <br>&gt; &lt;https://www.haskell.org/onlinereport/syntax-iso.html &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;&gt;<br>&gt; &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973 &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;&gt;<br>&gt; <br></p><p>To give a language that supports the extreme case: Coq and Agda allow the full range of the Unicode spectrum (or so their implementation/docs would seem to say) in identifiers.<br></p><p>&gt; <br>&gt; <br>&gt; # Current problems<br>&gt; <br>&gt; ## Weird identifier code points<br>&gt; <br>&gt; The current `identifier-character` set contains many characters which wouldn&#39;t make good identifiers:<br>&gt; <br>&gt; - 11 entire planes of characters (U+20000‚ÄìU+2FFFD, etc.) which are currently unassigned.<br>&gt; - The middle dot ¬∑ which looks like an operator.<br>&gt; - Many non-combining &quot;modifiers&quot; and accent marks, such as ¬¥ and ¬® and Íìª which don&#39;t really make sense on their own.<br>&gt; - &quot;Tone marks&quot; from various languages, including À´ (similar to a box-drawing character ‚îú which is an operator).<br>&gt; - The &quot;Greek question mark&quot; Õæ<br>&gt; - Symbols which are simply not linguistic, such as €û and ‡ºí.<br>&gt; <br>&gt; short url: &lt;https://goo.gl/tyn0Cz &lt;https://goo.gl/tyn0Cz&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D&gt;&gt;<br>&gt; <br>&gt; ## Weird operator code points<br>&gt; <br>&gt; The current `operator-character` set has a lot of characters that are clearly operator-esque (‚âà ‚àà ‚äï ‚äÖ), but some things are not so obviously desirable:<br>&gt; <br>&gt; - Box-drawing characters<br>&gt; - Combining accents and other characters<br>&gt; - Various symbols, e.g. ‚öÑ and ‚ôÑ (this category also overlaps with emoji)<br>&gt; - Braille patterns such as ‚†ü ‚Äî should they not be treated as letter-like (thus identifiers)?<br>&gt; - A plethora of arrows<br>&gt; <br>&gt; short url: &lt;https://goo.gl/s136Nh &lt;https://goo.gl/s136Nh&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D&gt;&gt;<br>&gt; <br>&gt; <br>&gt; ## Code points which are both<br>&gt; <br>&gt; A handful of characters are accepted both as `identifier-head` and `operator-head` (which seems pointless and might have been unintentional):<br>&gt; <br>&gt; U+3021‚ÄìU+3029, Suzhou numerals  „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© &lt;https://en.wikipedia.org/wiki/Suzhou_numerals &lt;https://en.wikipedia.org/wiki/Suzhou_numerals&gt;&gt;<br>&gt; <br>&gt; U+302A‚ÄìU+302F, ideographic &amp; hangul tone marks   „Ä™ ¬†„Ä´ ¬†„Ä¨ ¬†„Ä≠ ¬†„ÄÆ ¬†„ÄØ<br>&gt; <br>&gt;     let „Ä® = 2<br>&gt;     infix operator &lt;„Ä®&gt;<br>&gt; <br>&gt; (Note that `infix operator „Ä®` doesn&#39;t work because the lexer greedily treats this as an identifier. Also, interestingly, the corresponding ideographic zero „Äá is only an identifier char.)<br>&gt; <br>&gt; short url: &lt;https://goo.gl/lZcMqO &lt;https://goo.gl/lZcMqO&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d] &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d]&gt;&gt;<br>&gt; <br>&gt; In addition to the numerals and tone marks above, many (all?) combining marks are accepted as `identifier-character` and `operator-character`. These may be necessary for natural-looking words in some languages, but they don&#39;t seem necessary for operators.<br>&gt; <br>&gt; Also present in both sets are the variation selectors 1 through 256 (U+FE00‚ÄìU+FE0F, U+E0100‚ÄìU+E01EF). It seems they are of limited use for the operator characters, unless you count the emoji: &lt;http://www.unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt &lt;http://www.unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt&gt;&gt;<br>&gt; <br>&gt; short url: &lt;https://goo.gl/VKrisf &lt;https://goo.gl/VKrisf&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d] &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d]&gt;&gt;<br>&gt; <br>&gt; <br>&gt; ## Code points which should be illegal<br>&gt; <br>&gt; There are several surprising non-printing characters, including:<br>&gt; <br>&gt; - U+2064 INVISIBLE PLUS is currently an identifier<br>&gt; - U+200B ZERO WIDTH SPACE is currently an identifier<br>&gt; <br>&gt; No good will come of these. Invisible characters should probably be disallowed (although some may be necessary for properly joining/splitting characters in some other languages).<br>&gt; <br>&gt; <br>&gt; ## Categories which are split between identifiers and operators<br>&gt; <br>&gt; - Emoji and symbols: most of the newer emoji are identifiers, but many emoji/pictographs are operators, especially those from &quot;Miscellaneous Symbols&quot;. The results are hilariously illogical:<br>&gt; <br>&gt;   - ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt;   - ‚úåÔ∏è is an operator, but ü§ò is an identifier.<br>&gt;   - üîº is an operator, but ‚ñ∂Ô∏è is an identifier.<br>&gt;   - ‚ú≥Ô∏è is an operator, but üîØ is an identifier.<br>&gt;   - ‚úàÔ∏è is an operator, but üõ© is an identifier.<br>&gt;   - ‚ô†Ô∏è is an operator, but üÇ° is an identifier. (Presumably, üÇ° = A ‚ô†Ô∏è üÇ†!)<br>&gt; <br>&gt;   (But the counterintuitive examples extend outside the emoji too: + is an operator, while ‚Çä and ‚Å∫ are identifiers.)<br>&gt; <br>&gt; - Currency symbols: ¬¢ ¬£ ¬§ ¬• are operators, but ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø and many others are identifiers, and $ is allowed in an identifier.<br>&gt; <br>&gt; <br>&gt; ## Missing characters<br>&gt; <br>&gt; A handful of characters are neither operators nor identifiers. This list mostly makes sense (reserved characters and whitespace), but I wonder about a few which seem like they could easily be operators: ‚ëä ‚ëÄ ÔπÖ etc.<br>&gt; <br>&gt; short url: &lt;https://goo.gl/U0GVNn &lt;https://goo.gl/U0GVNn&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D&gt;&gt;<br>&gt; <br>&gt; <br>&gt; # Solutions<br>&gt; <br>&gt; Still up for discussion ‚Äî please reply to this thread!<br>&gt; <br>&gt; Adopting (X)ID_Start/Continue for identifiers, or a simpler solution like Haskell&#39;s use of &quot;letter&quot; categories, might work well.<br>&gt; <br>&gt; (I&#39;ve given up hope of finding some kind of &quot;perfect&quot; solution ‚Äî how can it be possible, when ·õè is a letter, yet ‚Üë is not?)<br>&gt; <br>&gt; Making the choice of operator characters more logical/standards-based would be nice (not just a set of ranges). However, Haskell&#39;s approach of using all punctuation &amp; symbols is probably not right for Swift:<br>&gt; <br>&gt; short url: &lt;https://goo.gl/Ud4KqY &lt;https://goo.gl/Ud4KqY&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D&gt;&gt;<br>&gt; <br>&gt; I&#39;m not really sure what to do with emoji ‚Äî they&#39;re a very cute novelty feature, but I don&#39;t know what the motivation is for including these as valid operators/identifiers.<br>&gt; <br>&gt; At the least, we should try to gather them all into one of the two categories. My inclination would be to keep them as identifiers, which would mean moving the following out of the operator category:<br>&gt; <br>&gt; short url: &lt;https://goo.gl/CBJEKX &lt;https://goo.gl/CBJEKX&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D&gt;&gt;<br>&gt; <br>&gt; <br>&gt; # Concurrently-discussable topics<br>&gt; <br>&gt; There are a few relevant topics that came to mind, which I think are worth discussing around the same time.<br>&gt; <br>&gt; ## Dollar signs ($)<br>&gt; <br>&gt; $ is currently allowed in identifiers, but it can&#39;t begin an identifier except for the magic implicit closure params ($0, $1, ...) and LLDB/REPL-related uses.<br>&gt; <br>&gt; It&#39;s arguable, but I feel that $ would be more effective as an operator character than an identifier character. There&#39;s precedent in Haskell for operators like `&lt;$&gt;` and being able to replicate these in Swift would be nice.<br>&gt; <br>&gt; <br>&gt; ## Diagnostics improvements<br>&gt; <br>&gt; Regardless of what ends up being the ultimate solution, it would be great to improve diagnostics for cases when the wrong types of characters are used.<br>&gt; <br>&gt; `infix operator abc` produces `&#39;abc&#39; is considered to be an identifier, not an operator`. That&#39;s not too bad.<br>&gt; <br>&gt; `let +++ = 3` produces `expected pattern`.<br>&gt; <br>&gt; `let $foo = 3` produces `expected numeric value following &#39;$&#39;`.<br>&gt; <br>&gt; <br>&gt; ## Security and —ÅŒønfu—ï–∞bI–µ characters<br>&gt; <br>&gt; Confusable characters (e vs. –µ, o vs. Œø, ; vs. Õæ) are an issue not taken lightly in the world of web security (cf. domain names). I haven&#39;t found much information about whether this has been considered a major security issue in programming languages, but I would think so (one can imagine such characters being introduced to a codebase subtly over time, hiding malicious functionality).<br>&gt; <br>&gt; It&#39;d be pretty cool if Swift could detect whether two identifiers might be confusable, and produce a warning.<br>&gt; <br>&gt; &lt;http://www.unicode.org/reports/tr36/#Recommendations_General &lt;http://www.unicode.org/reports/tr36/#Recommendations_General&gt;&gt;<br>&gt; &lt;http://unicode.org/reports/tr39/#Confusable_Detection &lt;http://unicode.org/reports/tr39/#Confusable_Detection&gt;&gt;<br>&gt; <br></p><p>We have had a patch sitting in the queue for a long time now &lt;https://github.com/apple/swift/pull/732&gt; that does diagnostics for confusables if you want to take that up again.<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/61577cc6/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/61577cc6/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 19, 2016 at 01:00:00am</p></header><div class="content"><p>There was a proposal written some time ago by Jo√£o Pinheiro about Unicode<br>normalization for identifiers. Unfortunately, it couldn&#39;t make it in time<br>for the Swift 3 deadline, but it may be in the PR queue. Here it is again<br>in full:<br></p><p>Normalize Unicode Identifiers<br></p><p>Proposal: SE-NNNN<br>Author: Jo√£o Pinheiro<br>Status: Awaiting review<br>Review manager: TBD<br></p><p>Introduction<br></p><p>This proposal aims to introduce identifier normalization in order to<br>prevent the unsafe and potentially abusive use of invisible or equivalent<br>representations of Unicode characters in identifiers.<br></p><p>Swift-evolution thread: Discussion thread<br></p><p>Motivation<br></p><p>Even though Swift supports the use of Unicode for identifiers, these aren&#39;t<br>yet normalized. This allows for different Unicode representations of the<br>same characters to be considered distinct identifiers.<br></p><p>For example:<br></p><p>let √Ö = &quot;Angstrom&quot;<br>let √Ö = &quot;Latin Capital Letter A With Ring Above&quot;<br>let √Ö = &quot;Latin Capital Letter A + Combining Ring Above&quot;<br></p><p>In addition to that, default-ignorable characters like the Zero Width Space<br>and Zero Width Non-Joiner (exemplified below) are also currently accepted<br>as valid parts of identifiers without any restrictions.<br></p><p>let ab = &quot;ab&quot;<br>let a‚Äãb = &quot;a + Zero Width Space + b&quot;<br></p><p>func xy() { print(&quot;xy&quot;) }<br>func x‚Äåy() { print(&quot;x + &lt;Zero Width Non-Joiner&gt; + y&quot;) }<br></p><p>The use of default-ignorable characters in identifiers is problematical,<br>first because the effects they represent are stylistic or otherwise out of<br>scope for identifiers, and second because the characters themselves often<br>have no visible display. It is also possible to misapply these characters<br>such that users can create strings that look the same but actually contain<br>different characters, which can create security problems.<br></p><p>Proposed solution<br></p><p>Normalize Swift identifiers according to the normalization form NFC<br>recommended for case-sensitive languages in the Unicode Standard Annexes 15<br>and 31 and follow the Normalization Charts.<br></p><p>In addition to that, prohibit the use of default-ignorable characters in<br>identifiers except in the special cases described in UAX31, listed below:<br></p><p>Allow Zero Width Non-Joiner (U+200C) when breaking a cursive connection<br>Allow Zero Width Non-Joiner (U+200C) in a conjunct context<br>Allow Zero Width Joiner (U+200D) in a conjunct context<br></p><p>Impact on existing code<br></p><p>This has potential to be a code-breaking change in cases where people may<br>have used distinct, but identical looking, identifiers with different<br>Unicode representations. The likelihood of that happening in actual code is<br>very small and the problem can be solved by renaming identifiers that don&#39;t<br>conform to the new normalized form into new non-colliding identifiers.<br></p><p>Alternatives considered<br></p><p>The option of ignoring default-ignorable characters in identifiers was also<br>discussed, but it was considered to be more confusing and less secure than<br>explicitly treating them as errors.<br></p><p>Unaddressed Issues<br></p><p>There was some discussion around the issue of Unicode confusable<br>characters, but it was considered to be out of scope for this proposal.<br>Unicode confusable characters are a complicated issue and any possible<br>solutions also come with significant drawbacks that would require more time<br>and consideration.<br></p><p><br>On Sun, Sep 18, 2016 at 20:35 Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Some thoughts<br>&gt;<br>&gt; On Sep 18, 2016, at 3:33 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *TLÕæDR:*<br>&gt;<br>&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most<br>&gt; source-breaking changes were done with in Swift 3; however, the<br>&gt; categorization of Unicode characters into identifiers &amp; operators was never<br>&gt; thoroughly discussed on swift-evolution. This seems like it might be our<br>&gt; last chance, and I think there are some big improvements to be had.<br>&gt;<br>&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch /<br>&gt; pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can<br>&gt; discuss these issues and come up with good (pragmatic) solutions here. I<br>&gt; imagine this can morph into a proposal later.<br>&gt;<br>&gt; You can read the following in nicer HTML form at<br>&gt; https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59<br>&gt;<br>&gt; I look forward to the discussion!<br>&gt;<br>&gt; -Jacob<br>&gt;<br>&gt; *# Background and motivation*<br>&gt;<br>&gt; To ease lexing/parsing and avoid user confusion, the names of custom<br>&gt; identifiers (type names, variable names, etc.) and operators in Swift can<br>&gt; be composed of (mostly) separate sets of characters.<br>&gt;<br>&gt; Using terminology from TSPL:<br>&gt;<br>&gt; `identifier-head`/`operator-head` are characters which can *begin *an<br>&gt; identifier or operator.<br>&gt;<br>&gt; `identifier-character`/`operator-character` are characters which can<br>&gt; appear anywhere in an identifier or operator (these are supersets of the<br>&gt; `-head` sets).<br>&gt;<br>&gt; &lt;<br>&gt; https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html<br>&gt; &gt;<br>&gt;<br>&gt; (Note also that some particular arrangements of characters are reserved;<br>&gt; for instance, `$` followed by digits for an implicit closure parameter, and<br>&gt; &quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot<br>&gt; elsewhere.&quot; There are also special characters in the language which are<br>&gt; neither identifiers nor operators, such as: `()[]{},:@#`)<br>&gt;<br>&gt;<br>&gt; *## Prior discussion on swift-evolution*<br>&gt;<br>&gt; *&quot;Request to add middle dot (U+00B7) as operator character?&quot;*<br>&gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html<br>&gt; &gt;<br>&gt;<br>&gt; *&quot;Free the &#39;$&#39; Symbol!&quot;*<br>&gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html<br>&gt; &gt;<br>&gt;<br>&gt; *&quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;*<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;<br>&gt;<br>&gt; Chris Lattner has said:<br>&gt;<br>&gt; &gt; &quot;...our current operator space (particularly the unicode segments<br>&gt; covered) is not super well considered.  It would be great for someone to<br>&gt; take a more systematic pass over them to rationalize things.&quot;<br>&gt;<br>&gt; &gt; &quot;We need a token to be unambiguously an operator or identifier - we can<br>&gt; have different rules for the leading and subsequent characters though.&quot;<br>&gt;<br>&gt;<br>&gt; I feel a bit bad having implemented the patch that banned this - it feels<br>&gt; like dollar was mistakenly left out of the operator character range<br>&gt; considering how well it worked in operators up to then.  Disambiguation<br>&gt; with respect to other language constructs (anonymous parameters in closures<br>&gt; and LLDB variables) is trivial and we already had diagnostics about it.<br>&gt;<br>&gt; I definitely support having Swift‚Äôs operators use a wider range of the<br>&gt; unicode spectrum - perhaps even a policy where instead of whitelisting<br>&gt; ranges we blacklist reserved characters or ranges.<br>&gt;<br>&gt;<br>&gt; *# Current state of affairs*<br>&gt;<br>&gt; Swift&#39;s `identifier-head` and `identifier-character` mostly conform to the<br>&gt; recommendations in &lt;<br>&gt; http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html&gt;<br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489<br>&gt; &gt;<br>&gt;<br>&gt; The allowed operator characters include &quot;Unicode math, symbol, arrow,<br>&gt; dingbat, and line/box drawing chars&quot;, however I don&#39;t believe this aligns<br>&gt; with any particular spec:<br>&gt; &lt;<br>&gt; https://github.com/apple/swift/blob/08e7963/include/swift/AST/Identifier.h#L87-L121&gt;<br>&gt;<br>&gt; &lt;https://github.com/apple/swift/commit/a2341a4&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; *## Identifiers/operators elsewhere*<br>&gt;<br>&gt; There is an Unicode Standard Annex &quot;identifier and pattern syntax&quot; &lt;<br>&gt; http://unicode.org/reports/tr31/&gt; which defines the categories<br>&gt; `ID_Start`/`ID_Continue`.<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AID_Continue%3A%5D<br>&gt; &gt;<br>&gt;<br>&gt; *### ECMAScript 2015 &quot;ES6&quot;*<br>&gt;<br>&gt; Uses `ID_Start` and `ID_Continue`, as well as `Other_ID_Start` /<br>&gt; `Other_ID_Continue`.<br>&gt; &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt;<br>&gt; *### Haskell*<br>&gt;<br>&gt; Distinguishes identifiers/operators by their general category (such as<br>&gt; &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, etc.).<br>&gt;<br>&gt; &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt;<br>&gt;<br>&gt; In particular, identifiers can start with any lowercase letter or _, and<br>&gt; may contain any letter/digit/&#39;/_. This would seem to include letters like Œ¥<br>&gt; and –Ø, and digits like Ÿ¢.<br>&gt;<br>&gt; &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt; &lt;<br>&gt; https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; To give a language that supports the extreme case: Coq and Agda allow the<br>&gt; full range of the Unicode spectrum (or so their implementation/docs would<br>&gt; seem to say) in identifiers.<br>&gt;<br>&gt;<br>&gt;<br>&gt; *# Current problems*<br>&gt;<br>&gt; *## Weird identifier code points*<br>&gt;<br>&gt; The current `identifier-character` set contains many characters which<br>&gt; wouldn&#39;t make good identifiers:<br>&gt;<br>&gt; - 11 entire planes of characters (U+20000‚ÄìU+2FFFD, etc.) which are<br>&gt; currently unassigned.<br>&gt; - The middle dot ¬∑ which looks like an operator.<br>&gt; - Many non-combining &quot;modifiers&quot; and accent marks, such as ¬¥ and ¬® and Íìª<br>&gt; which don&#39;t really make sense on their own.<br>&gt; - &quot;Tone marks&quot; from various languages, including À´ (similar to a<br>&gt; box-drawing character ‚îú which is an operator).<br>&gt; - The &quot;Greek question mark&quot; Õæ<br>&gt; - Symbols which are simply not linguistic, such as €û and ‡ºí.<br>&gt;<br>&gt; short url: &lt;https://goo.gl/tyn0Cz&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D<br>&gt; &gt;<br>&gt;<br>&gt; *## Weird operator code points*<br>&gt;<br>&gt; The current `operator-character` set has a lot of characters that are<br>&gt; clearly operator-esque (‚âà ‚àà ‚äï ‚äÖ), but some things are not so obviously<br>&gt; desirable:<br>&gt;<br>&gt; - Box-drawing characters<br>&gt; - Combining accents and other characters<br>&gt; - Various symbols, e.g. ‚öÑ and ‚ôÑ (this category also overlaps with emoji)<br>&gt; - Braille patterns such as ‚†ü ‚Äî should they not be treated as letter-like<br>&gt; (thus identifiers)?<br>&gt; - A plethora of arrows<br>&gt;<br>&gt; short url: &lt;https://goo.gl/s136Nh&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; *## Code points which are both*<br>&gt;<br>&gt; A handful of characters are accepted *both* as `identifier-head` and<br>&gt; `operator-head` (which seems pointless and might have been unintentional):<br>&gt;<br>&gt; U+3021‚ÄìU+3029, Suzhou numerals  „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© &lt;<br>&gt; https://en.wikipedia.org/wiki/Suzhou_numerals&gt;<br>&gt;<br>&gt; U+302A‚ÄìU+302F, ideographic &amp; hangul tone marks   „Ä™  „Ä´  „Ä¨  „Ä≠  „ÄÆ  „ÄØ<br>&gt;<br>&gt;     let „Ä® = 2<br>&gt;     infix operator &lt;„Ä®&gt;<br>&gt;<br>&gt; (Note that `infix operator „Ä®` doesn&#39;t work because the lexer greedily<br>&gt; treats this as an identifier. Also, interestingly, the corresponding<br>&gt; ideographic zero „Äá is only an identifier char.)<br>&gt;<br>&gt; short url: &lt;https://goo.gl/lZcMqO&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d]<br>&gt; &gt;<br>&gt;<br>&gt; In addition to the numerals and tone marks above, many (all?) *combining<br>&gt; marks* are accepted as `identifier-character` and `operator-character`.<br>&gt; These may be necessary for natural-looking words in some languages, but<br>&gt; they don&#39;t seem necessary for operators.<br>&gt;<br>&gt; Also present in both sets are the *variation selectors* 1 through 256<br>&gt; (U+FE00‚ÄìU+FE0F, U+E0100‚ÄìU+E01EF). It seems they are of limited use for the<br>&gt; operator characters, unless you count the emoji: &lt;<br>&gt; http://www.unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt&gt;<br>&gt;<br>&gt; short url: &lt;https://goo.gl/VKrisf&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d]<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; *## Code points which should be illegal*<br>&gt;<br>&gt; There are several surprising non-printing characters, including:<br>&gt;<br>&gt; - U+2064 INVISIBLE PLUS is currently an identifier<br>&gt; - U+200B ZERO WIDTH SPACE is currently an identifier<br>&gt;<br>&gt; No good will come of these. Invisible characters should probably be<br>&gt; disallowed (although some may be necessary for properly joining/splitting<br>&gt; characters in some other languages).<br>&gt;<br>&gt;<br>&gt; *## Categories which are split between identifiers and operators*<br>&gt;<br>&gt; - Emoji and symbols: most of the newer emoji are identifiers, but many<br>&gt; emoji/pictographs are operators, especially those from &quot;Miscellaneous<br>&gt; Symbols&quot;. The results are hilariously illogical:<br>&gt;<br>&gt;   - ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt;   - ‚úåÔ∏è is an operator, but ü§ò is an identifier.<br>&gt;   - üîº is an operator, but ‚ñ∂Ô∏è is an identifier.<br>&gt;   - ‚ú≥Ô∏è is an operator, but üîØ is an identifier.<br>&gt;   - ‚úàÔ∏è is an operator, but üõ© is an identifier.<br>&gt;   - ‚ô†Ô∏è is an operator, but üÇ° is an identifier. (Presumably, üÇ° = A ‚ô†Ô∏è üÇ†!)<br>&gt;<br>&gt;   (But the counterintuitive examples extend outside the emoji too: + is an<br>&gt; operator, while ‚Çä and ‚Å∫ are identifiers.)<br>&gt;<br>&gt; - Currency symbols: ¬¢ ¬£ ¬§ ¬• are operators, but ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø and many others<br>&gt; are identifiers, and $ is allowed in an identifier.<br>&gt;<br>&gt;<br>&gt; *## Missing characters*<br>&gt;<br>&gt; A handful of characters are neither operators nor identifiers. This list<br>&gt; mostly makes sense (reserved characters and whitespace), but I wonder about<br>&gt; a few which seem like they could easily be operators: ‚ëä ‚ëÄ ÔπÖ etc.<br>&gt;<br>&gt; short url: &lt;https://goo.gl/U0GVNn&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; *# Solutions*<br>&gt;<br>&gt; Still up for discussion ‚Äî please reply to this thread!<br>&gt;<br>&gt; Adopting (X)ID_Start/Continue for identifiers, or a simpler solution like<br>&gt; Haskell&#39;s use of &quot;letter&quot; categories, might work well.<br>&gt;<br>&gt; (I&#39;ve given up hope of finding some kind of &quot;perfect&quot; solution ‚Äî how can<br>&gt; it be possible, when ·õè is a letter, yet ‚Üë is not?)<br>&gt;<br>&gt; Making the choice of operator characters more logical/standards-based<br>&gt; would be nice (not just a set of ranges). However, Haskell&#39;s approach of<br>&gt; using all punctuation &amp; symbols is probably not right for Swift:<br>&gt;<br>&gt; short url: &lt;https://goo.gl/Ud4KqY&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D<br>&gt; &gt;<br>&gt;<br>&gt; I&#39;m not really sure what to do with emoji ‚Äî they&#39;re a very cute novelty<br>&gt; feature, but I don&#39;t know what the motivation is for including these as<br>&gt; valid operators/identifiers.<br>&gt;<br>&gt; At the least, we should try to gather them all into one of the two<br>&gt; categories. My inclination would be to keep them as identifiers, which<br>&gt; would mean moving the following out of the operator category:<br>&gt;<br>&gt; short url: &lt;https://goo.gl/CBJEKX&gt;<br>&gt;<br>&gt; &lt;<br>&gt; http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; *# Concurrently-discussable topics*<br>&gt;<br>&gt; There are a few relevant topics that came to mind, which I think are worth<br>&gt; discussing around the same time.<br>&gt;<br>&gt; *## Dollar signs ($)*<br>&gt;<br>&gt; $ is currently allowed in identifiers, but it can&#39;t begin an identifier<br>&gt; except for the magic implicit closure params ($0, $1, ...) and<br>&gt; LLDB/REPL-related uses.<br>&gt;<br>&gt; It&#39;s arguable, but I feel that $ would be more effective as an operator<br>&gt; character than an identifier character. There&#39;s precedent in Haskell for<br>&gt; operators like `&lt;$&gt;` and being able to replicate these in Swift would be<br>&gt; nice.<br>&gt;<br>&gt;<br>&gt; *## Diagnostics improvements*<br>&gt;<br>&gt; Regardless of what ends up being the ultimate solution, it would be great<br>&gt; to improve diagnostics for cases when the wrong types of characters are<br>&gt; used.<br>&gt;<br>&gt; `infix operator abc` produces `&#39;abc&#39; is considered to be an identifier,<br>&gt; not an operator`. That&#39;s not too bad.<br>&gt;<br>&gt; `let +++ = 3` produces `expected pattern`.<br>&gt;<br>&gt; `let $foo = 3` produces `expected numeric value following &#39;$&#39;`.<br>&gt;<br>&gt;<br>&gt; *## Security and —ÅŒønfu—ï–∞bI–µ characters*<br>&gt;<br>&gt; Confusable characters (e vs. –µ, o vs. Œø, ; vs. Õæ) are an issue not taken<br>&gt; lightly in the world of web security (cf. domain names). I haven&#39;t found<br>&gt; much information about whether this has been considered a major security<br>&gt; issue in programming languages, but I would think so (one can imagine such<br>&gt; characters being introduced to a codebase subtly over time, hiding<br>&gt; malicious functionality).<br>&gt;<br>&gt; It&#39;d be pretty cool if Swift could detect whether two identifiers might be<br>&gt; confusable, and produce a warning.<br>&gt;<br>&gt; &lt;http://www.unicode.org/reports/tr36/#Recommendations_General&gt;<br>&gt; &lt;http://unicode.org/reports/tr39/#Confusable_Detection&gt;<br>&gt;<br>&gt;<br>&gt; We have had a patch sitting in the queue for a long time now<br>&gt; &lt;https://github.com/apple/swift/pull/732&gt; that does diagnostics for<br>&gt; confusables if you want to take that up again.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/5202f746/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September 21, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Sep 18, 2016 at 6:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>wrote:<br></p><p>&gt; Some thoughts<br>&gt;<br>&gt; On Sep 18, 2016, at 3:33 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *TLÕæDR:*<br>&gt;<br>&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most<br>&gt; source-breaking changes were done with in Swift 3; however, the<br>&gt; categorization of Unicode characters into identifiers &amp; operators was never<br>&gt; thoroughly discussed on swift-evolution. This seems like it might be our<br>&gt; last chance, and I think there are some big improvements to be had.<br>&gt;<br>&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch /<br>&gt; pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can<br>&gt; discuss these issues and come up with good (pragmatic) solutions here. I<br>&gt; imagine this can morph into a proposal later.<br>&gt;<br>&gt; You can read the following in nicer HTML form at https://gist.github.com/<br>&gt; jtbandes/c0b0c072181dcd22c3147802025d0b59<br>&gt;<br>&gt; I look forward to the discussion!<br>&gt;<br>&gt; -Jacob<br>&gt;<br>&gt; *# Background and motivation*<br>&gt;<br>&gt; To ease lexing/parsing and avoid user confusion, the names of custom<br>&gt; identifiers (type names, variable names, etc.) and operators in Swift can<br>&gt; be composed of (mostly) separate sets of characters.<br>&gt;<br>&gt; Using terminology from TSPL:<br>&gt;<br>&gt; `identifier-head`/`operator-head` are characters which can *begin *an<br>&gt; identifier or operator.<br>&gt;<br>&gt; `identifier-character`/`operator-character` are characters which can<br>&gt; appear anywhere in an identifier or operator (these are supersets of the<br>&gt; `-head` sets).<br>&gt;<br>&gt; &lt;https://developer.apple.com/library/content/documentation/<br>&gt; Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&gt;<br>&gt;<br>&gt; (Note also that some particular arrangements of characters are reserved;<br>&gt; for instance, `$` followed by digits for an implicit closure parameter, and<br>&gt; &quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot<br>&gt; elsewhere.&quot; There are also special characters in the language which are<br>&gt; neither identifiers nor operators, such as: `()[]{},:@#`)<br>&gt;<br>&gt;<br>&gt; *## Prior discussion on swift-evolution*<br>&gt;<br>&gt; *&quot;Request to add middle dot (U+00B7) as operator character?&quot;*<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20151214/003176.html&gt;<br>&gt;<br>&gt; *&quot;Free the &#39;$&#39; Symbol!&quot;*<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20151228/005133.html&gt;<br>&gt;<br>&gt; *&quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;*<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;<br>&gt;<br>&gt; Chris Lattner has said:<br>&gt;<br>&gt; &gt; &quot;...our current operator space (particularly the unicode segments<br>&gt; covered) is not super well considered.  It would be great for someone to<br>&gt; take a more systematic pass over them to rationalize things.&quot;<br>&gt;<br>&gt; &gt; &quot;We need a token to be unambiguously an operator or identifier - we can<br>&gt; have different rules for the leading and subsequent characters though.&quot;<br>&gt;<br>&gt;<br>&gt; I feel a bit bad having implemented the patch that banned this - it feels<br>&gt; like dollar was mistakenly left out of the operator character range<br>&gt; considering how well it worked in operators up to then.  Disambiguation<br>&gt; with respect to other language constructs (anonymous parameters in closures<br>&gt; and LLDB variables) is trivial and we already had diagnostics about it.<br>&gt;<br></p><p>But more importantly, you were also the one who first asked for it to be an<br>operator character :-)<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html<br></p><p>Did you have a formal proposal in the works for this? If so, it might be<br>worth reviewing separately from any other changes. $ is a more well-known<br>character, and probably more likely to elicit opinions than some more<br>obscure Unicode stuff.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/0d3fe98a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 22, 2016 at 08:00:00am</p></header><div class="content"><p>In that case it was because $ was not allowed in operators.  Here it‚Äôs just not allowed at all!<br></p><p>Nevertheless, the irony is delicious,<br></p><p>~Robert Widmann<br></p><p>&gt; On Sep 22, 2016, at 2:05 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sun, Sep 18, 2016 at 6:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt; Some thoughts<br>&gt; <br>&gt;&gt; On Sep 18, 2016, at 3:33 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; TLÕæDR:<br>&gt;&gt; <br>&gt;&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most source-breaking changes were done with in Swift 3; however, the categorization of Unicode characters into identifiers &amp; operators was never thoroughly discussed on swift-evolution. This seems like it might be our last chance, and I think there are some big improvements to be had.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch / pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can discuss these issues and come up with good (pragmatic) solutions here. I imagine this can morph into a proposal later.<br>&gt;&gt; <br>&gt;&gt; You can read the following in nicer HTML form at https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59 &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt;<br>&gt;&gt; <br>&gt;&gt; I look forward to the discussion!<br>&gt;&gt; <br>&gt;&gt; -Jacob<br>&gt;&gt; <br>&gt;&gt; # Background and motivation<br>&gt;&gt; <br>&gt;&gt; To ease lexing/parsing and avoid user confusion, the names of custom identifiers (type names, variable names, etc.) and operators in Swift can be composed of (mostly) separate sets of characters.<br>&gt;&gt; <br>&gt;&gt; Using terminology from TSPL:<br>&gt;&gt; <br>&gt;&gt; `identifier-head`/`operator-head` are characters which can begin an identifier or operator.<br>&gt;&gt; <br>&gt;&gt; `identifier-character`/`operator-character` are characters which can appear anywhere in an identifier or operator (these are supersets of the `-head` sets).<br>&gt;&gt; <br>&gt;&gt; &lt;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html &lt;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; (Note also that some particular arrangements of characters are reserved; for instance, `$` followed by digits for an implicit closure parameter, and &quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.&quot; There are also special characters in the language which are neither identifiers nor operators, such as: `()[]{},:@#`)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Prior discussion on swift-evolution<br>&gt;&gt; <br>&gt;&gt; &quot;Request to add middle dot (U+00B7) as operator character?&quot;<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; &quot;Free the &#39;$&#39; Symbol!&quot;<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; &quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/354 &lt;https://github.com/apple/swift-evolution/pull/354&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Chris Lattner has said:<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;...our current operator space (particularly the unicode segments covered) is not super well considered.  It would be great for someone to take a more systematic pass over them to rationalize things.&quot;<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.&quot;<br>&gt;&gt; <br>&gt; <br>&gt; I feel a bit bad having implemented the patch that banned this - it feels like dollar was mistakenly left out of the operator character range considering how well it worked in operators up to then.  Disambiguation with respect to other language constructs (anonymous parameters in closures and LLDB variables) is trivial and we already had diagnostics about it.<br>&gt; <br>&gt; But more importantly, you were also the one who first asked for it to be an operator character :-)  https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt; <br>&gt; Did you have a formal proposal in the works for this? If so, it might be worth reviewing separately from any other changes. $ is a more well-known character, and probably more likely to elicit opinions than some more obscure Unicode stuff.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/60262701/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>September 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Let me tl;dr&#39;er this even more: ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br></p><p>-- E, succinct, who thinks there&#39;s room for improvement<br></p><p><br>&gt; On Sep 18, 2016, at 1:33 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; TLÕæDR:<br>&gt; <br>&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most source-breaking changes were done with in Swift 3; however, the categorization of Unicode characters into identifiers &amp; operators was never thoroughly discussed on swift-evolution. This seems like it might be our last chance, and I think there are some big improvements to be had.<br>&gt; <br>&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch / pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can discuss these issues and come up with good (pragmatic) solutions here. I imagine this can morph into a proposal later.<br>&gt; <br>&gt; You can read the following in nicer HTML form at https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59 &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt;<br>&gt; <br>&gt; I look forward to the discussion!<br>&gt; <br>&gt; -Jacob<br>&gt; <br>&gt; # Background and motivation<br>&gt; <br>&gt; To ease lexing/parsing and avoid user confusion, the names of custom identifiers (type names, variable names, etc.) and operators in Swift can be composed of (mostly) separate sets of characters.<br>&gt; <br>&gt; Using terminology from TSPL:<br>&gt; <br>&gt; `identifier-head`/`operator-head` are characters which can begin an identifier or operator.<br>&gt; <br>&gt; `identifier-character`/`operator-character` are characters which can appear anywhere in an identifier or operator (these are supersets of the `-head` sets).<br>&gt; <br>&gt; &lt;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html &lt;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&gt;&gt;<br>&gt; <br>&gt; (Note also that some particular arrangements of characters are reserved; for instance, `$` followed by digits for an implicit closure parameter, and &quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.&quot; There are also special characters in the language which are neither identifiers nor operators, such as: `()[]{},:@#`)<br>&gt; <br>&gt; <br>&gt; ## Prior discussion on swift-evolution<br>&gt; <br>&gt; &quot;Request to add middle dot (U+00B7) as operator character?&quot;<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;&gt;<br>&gt; <br>&gt; &quot;Free the &#39;$&#39; Symbol!&quot;<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;&gt;<br>&gt; <br>&gt; &quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/354 &lt;https://github.com/apple/swift-evolution/pull/354&gt;&gt;<br>&gt; <br>&gt; <br>&gt; Chris Lattner has said:<br>&gt; <br>&gt; &gt; &quot;...our current operator space (particularly the unicode segments covered) is not super well considered.  It would be great for someone to take a more systematic pass over them to rationalize things.&quot;<br>&gt; <br>&gt; &gt; &quot;We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.&quot;<br>&gt; <br>&gt; <br>&gt; # Current state of affairs<br>&gt; <br>&gt; Swift&#39;s `identifier-head` and `identifier-character` mostly conform to the recommendations in &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html&gt;&gt;  <br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489 &lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489&gt;&gt;<br>&gt; <br>&gt; The allowed operator characters include &quot;Unicode math, symbol, arrow, dingbat, and line/box drawing chars&quot;, however I don&#39;t believe this aligns with any particular spec:<br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/include/swift/AST/Identifier.h#L87-L121 &lt;https://github.com/apple/swift/blob/08e7963/include/swift/AST/Identifier.h#L87-L121&gt;&gt;  <br>&gt; &lt;https://github.com/apple/swift/commit/a2341a4 &lt;https://github.com/apple/swift/commit/a2341a4&gt;&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; ## Identifiers/operators elsewhere<br>&gt; <br>&gt; There is an Unicode Standard Annex &quot;identifier and pattern syntax&quot; &lt;http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;&gt; which defines the categories `ID_Start`/`ID_Continue`.<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AID_Continue%3A%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AID_Continue%3A%5D&gt;&gt;<br>&gt; <br>&gt; ### ECMAScript 2015 &quot;ES6&quot;<br>&gt; <br>&gt; Uses `ID_Start` and `ID_Continue`, as well as `Other_ID_Start` / `Other_ID_Continue`.<br>&gt; &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;&gt;<br>&gt; <br>&gt; ### Haskell<br>&gt; <br>&gt; Distinguishes identifiers/operators by their general category (such as &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, etc.).  <br>&gt; &lt;http://www.fileformat.info/info/unicode/category/index.htm &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt;&gt;<br>&gt; <br>&gt; In particular, identifiers can start with any lowercase letter or _, and may contain any letter/digit/&#39;/_. This would seem to include letters like Œ¥ and –Ø, and digits like Ÿ¢.<br>&gt; <br>&gt; &lt;https://www.haskell.org/onlinereport/syntax-iso.html &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;&gt;  <br>&gt; &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973 &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Current problems<br>&gt; <br>&gt; ## Weird identifier code points<br>&gt; <br>&gt; The current `identifier-character` set contains many characters which wouldn&#39;t make good identifiers:<br>&gt; <br>&gt; - 11 entire planes of characters (U+20000‚ÄìU+2FFFD, etc.) which are currently unassigned.<br>&gt; - The middle dot ¬∑ which looks like an operator.<br>&gt; - Many non-combining &quot;modifiers&quot; and accent marks, such as ¬¥ and ¬® and Íìª which don&#39;t really make sense on their own.<br>&gt; - &quot;Tone marks&quot; from various languages, including À´ (similar to a box-drawing character ‚îú which is an operator).<br>&gt; - The &quot;Greek question mark&quot; Õæ<br>&gt; - Symbols which are simply not linguistic, such as €û and ‡ºí.<br>&gt; <br>&gt; short url: &lt;https://goo.gl/tyn0Cz &lt;https://goo.gl/tyn0Cz&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D&gt;&gt;<br>&gt; <br>&gt; ## Weird operator code points<br>&gt; <br>&gt; The current `operator-character` set has a lot of characters that are clearly operator-esque (‚âà ‚àà ‚äï ‚äÖ), but some things are not so obviously desirable:<br>&gt; <br>&gt; - Box-drawing characters<br>&gt; - Combining accents and other characters<br>&gt; - Various symbols, e.g. ‚öÑ and ‚ôÑ (this category also overlaps with emoji)<br>&gt; - Braille patterns such as ‚†ü ‚Äî should they not be treated as letter-like (thus identifiers)?<br>&gt; - A plethora of arrows<br>&gt; <br>&gt; short url: &lt;https://goo.gl/s136Nh &lt;https://goo.gl/s136Nh&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D&gt;&gt;<br>&gt; <br>&gt; <br>&gt; ## Code points which are both<br>&gt; <br>&gt; A handful of characters are accepted both as `identifier-head` and `operator-head` (which seems pointless and might have been unintentional):<br>&gt; <br>&gt; U+3021‚ÄìU+3029, Suzhou numerals  „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© &lt;https://en.wikipedia.org/wiki/Suzhou_numerals &lt;https://en.wikipedia.org/wiki/Suzhou_numerals&gt;&gt;  <br>&gt; <br>&gt; U+302A‚ÄìU+302F, ideographic &amp; hangul tone marks   „Ä™ ¬†„Ä´ ¬†„Ä¨ ¬†„Ä≠ ¬†„ÄÆ ¬†„ÄØ<br>&gt; <br>&gt;     let „Ä® = 2<br>&gt;     infix operator &lt;„Ä®&gt;<br>&gt; <br>&gt; (Note that `infix operator „Ä®` doesn&#39;t work because the lexer greedily treats this as an identifier. Also, interestingly, the corresponding ideographic zero „Äá is only an identifier char.)<br>&gt; <br>&gt; short url: &lt;https://goo.gl/lZcMqO &lt;https://goo.gl/lZcMqO&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d] &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d]&gt;&gt;<br>&gt; <br>&gt; In addition to the numerals and tone marks above, many (all?) combining marks are accepted as `identifier-character` and `operator-character`. These may be necessary for natural-looking words in some languages, but they don&#39;t seem necessary for operators.<br>&gt; <br>&gt; Also present in both sets are the variation selectors 1 through 256 (U+FE00‚ÄìU+FE0F, U+E0100‚ÄìU+E01EF). It seems they are of limited use for the operator characters, unless you count the emoji: &lt;http://www.unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt &lt;http://www.unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt&gt;&gt;<br>&gt; <br>&gt; short url: &lt;https://goo.gl/VKrisf &lt;https://goo.gl/VKrisf&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d] &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-%5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d]&gt;&gt;<br>&gt; <br>&gt; <br>&gt; ## Code points which should be illegal<br>&gt; <br>&gt; There are several surprising non-printing characters, including:<br>&gt; <br>&gt; - U+2064 INVISIBLE PLUS is currently an identifier<br>&gt; - U+200B ZERO WIDTH SPACE is currently an identifier<br>&gt; <br>&gt; No good will come of these. Invisible characters should probably be disallowed (although some may be necessary for properly joining/splitting characters in some other languages).<br>&gt; <br>&gt; <br>&gt; ## Categories which are split between identifiers and operators<br>&gt; <br>&gt; - Emoji and symbols: most of the newer emoji are identifiers, but many emoji/pictographs are operators, especially those from &quot;Miscellaneous Symbols&quot;. The results are hilariously illogical:<br>&gt; <br>&gt;   - ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt;   - ‚úåÔ∏è is an operator, but ü§ò is an identifier.<br>&gt;   - üîº is an operator, but ‚ñ∂Ô∏è is an identifier.<br>&gt;   - ‚ú≥Ô∏è is an operator, but üîØ is an identifier.<br>&gt;   - ‚úàÔ∏è is an operator, but üõ© is an identifier.<br>&gt;   - ‚ô†Ô∏è is an operator, but üÇ° is an identifier. (Presumably, üÇ° = A ‚ô†Ô∏è üÇ†!)<br>&gt;   <br>&gt;   (But the counterintuitive examples extend outside the emoji too: + is an operator, while ‚Çä and ‚Å∫ are identifiers.)<br>&gt; <br>&gt; - Currency symbols: ¬¢ ¬£ ¬§ ¬• are operators, but ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø and many others are identifiers, and $ is allowed in an identifier.<br>&gt; <br>&gt; <br>&gt; ## Missing characters<br>&gt; <br>&gt; A handful of characters are neither operators nor identifiers. This list mostly makes sense (reserved characters and whitespace), but I wonder about a few which seem like they could easily be operators: ‚ëä ‚ëÄ ÔπÖ etc.<br>&gt; <br>&gt; short url: &lt;https://goo.gl/U0GVNn &lt;https://goo.gl/U0GVNn&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D&gt;&gt;<br>&gt; <br>&gt; <br>&gt; # Solutions<br>&gt; <br>&gt; Still up for discussion ‚Äî please reply to this thread!<br>&gt; <br>&gt; Adopting (X)ID_Start/Continue for identifiers, or a simpler solution like Haskell&#39;s use of &quot;letter&quot; categories, might work well.<br>&gt; <br>&gt; (I&#39;ve given up hope of finding some kind of &quot;perfect&quot; solution ‚Äî how can it be possible, when ·õè is a letter, yet ‚Üë is not?)<br>&gt; <br>&gt; Making the choice of operator characters more logical/standards-based would be nice (not just a set of ranges). However, Haskell&#39;s approach of using all punctuation &amp; symbols is probably not right for Swift:<br>&gt; <br>&gt; short url: &lt;https://goo.gl/Ud4KqY &lt;https://goo.gl/Ud4KqY&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D&gt;&gt;<br>&gt; <br>&gt; I&#39;m not really sure what to do with emoji ‚Äî they&#39;re a very cute novelty feature, but I don&#39;t know what the motivation is for including these as valid operators/identifiers.<br>&gt; <br>&gt; At the least, we should try to gather them all into one of the two categories. My inclination would be to keep them as identifiers, which would mean moving the following out of the operator category:<br>&gt; <br>&gt; short url: &lt;https://goo.gl/CBJEKX &lt;https://goo.gl/CBJEKX&gt;&gt;<br>&gt; <br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D&gt;&gt;<br>&gt; <br>&gt; <br>&gt; # Concurrently-discussable topics<br>&gt; <br>&gt; There are a few relevant topics that came to mind, which I think are worth discussing around the same time.<br>&gt; <br>&gt; ## Dollar signs ($)<br>&gt; <br>&gt; $ is currently allowed in identifiers, but it can&#39;t begin an identifier except for the magic implicit closure params ($0, $1, ...) and LLDB/REPL-related uses.<br>&gt; <br>&gt; It&#39;s arguable, but I feel that $ would be more effective as an operator character than an identifier character. There&#39;s precedent in Haskell for operators like `&lt;$&gt;` and being able to replicate these in Swift would be nice.<br>&gt; <br>&gt; <br>&gt; ## Diagnostics improvements<br>&gt; <br>&gt; Regardless of what ends up being the ultimate solution, it would be great to improve diagnostics for cases when the wrong types of characters are used.<br>&gt; <br>&gt; `infix operator abc` produces `&#39;abc&#39; is considered to be an identifier, not an operator`. That&#39;s not too bad.<br>&gt; <br>&gt; `let +++ = 3` produces `expected pattern`.<br>&gt; <br>&gt; `let $foo = 3` produces `expected numeric value following &#39;$&#39;`.<br>&gt; <br>&gt; <br>&gt; ## Security and —ÅŒønfu—ï–∞bI–µ characters<br>&gt; <br>&gt; Confusable characters (e vs. –µ, o vs. Œø, ; vs. Õæ) are an issue not taken lightly in the world of web security (cf. domain names). I haven&#39;t found much information about whether this has been considered a major security issue in programming languages, but I would think so (one can imagine such characters being introduced to a codebase subtly over time, hiding malicious functionality).<br>&gt; <br>&gt; It&#39;d be pretty cool if Swift could detect whether two identifiers might be confusable, and produce a warning.<br>&gt; <br>&gt; &lt;http://www.unicode.org/reports/tr36/#Recommendations_General &lt;http://www.unicode.org/reports/tr36/#Recommendations_General&gt;&gt;  <br>&gt; &lt;http://unicode.org/reports/tr39/#Confusable_Detection &lt;http://unicode.org/reports/tr39/#Confusable_Detection&gt;&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/72b90155/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 18, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Sep 18, 2016 at 9:19 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Let me tl;dr&#39;er this even more: ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt;<br>&gt; -- E, succinct, who thinks there&#39;s room for improvement<br>&gt;<br></p><p>Ha, yes. Let&#39;s see if I can be as succinct in my contribution to the<br>discussion:<br></p><p>1) Agree that current situation not ideal, for reasons above<br></p><p>2) The solution might best be not one but several proposals:<br></p><p>  2a) Unicode normalization: invisible characters, Greek tonos, etc. (cf.<br>previous message about previously proposed solution, which reflects Unicode<br>recommendations in UTR #31)--low hanging fruit: there&#39;s an established<br>Unicode recommendation with clear wins for security and consistency<br></p><p>  2b) Legal and illegal characters for identifiers *or* operators: UTR #31<br>makes recommendations regarding rarely used scripts; probably best to<br>follow the letter and spirit of these recommendations (which would probably<br>mean ancient Greek musical symbols and Egyptian hieroglyphics shouldn&#39;t be<br>identifier or operator characters)<br></p><p>  2c) Decisions as to which characters are identifier characters or<br>operator characters: for instance, emoji should probably never be operator<br>characters; if an emoji has a non-emoji counterpart that is an operator<br>(‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è, etc.) it might be best simply to make these illegal rather than<br>operator characters<br></p><p>  2d) Confusables: I think the last time we had this discussion, it was<br>apparent that it&#39;d be difficult to decide which confusables to allow or<br>disallow after some of the low-hanging fruit is taken care of by Unicode<br>normalization (see item 2a); the Unicode Consortium-provided list seems too<br>quick to call two things &quot;confusable&quot; for our purposes (with criteria that<br>might be relevant for URLs or other use cases, but casting too wide a net<br>perhaps for Swift identifiers)<br></p><p><br>On Sep 18, 2016, at 1:33 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *TLÕæDR:*<br>&gt;<br>&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most<br>&gt; source-breaking changes were done with in Swift 3; however, the<br>&gt; categorization of Unicode characters into identifiers &amp; operators was never<br>&gt; thoroughly discussed on swift-evolution. This seems like it might be our<br>&gt; last chance, and I think there are some big improvements to be had.<br>&gt;<br>&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch /<br>&gt; pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can<br>&gt; discuss these issues and come up with good (pragmatic) solutions here. I<br>&gt; imagine this can morph into a proposal later.<br>&gt;<br>&gt; You can read the following in nicer HTML form at https://gist.github.com/<br>&gt; jtbandes/c0b0c072181dcd22c3147802025d0b59<br>&gt;<br>&gt; I look forward to the discussion!<br>&gt;<br>&gt; -Jacob<br>&gt;<br>&gt; *# Background and motivation*<br>&gt;<br>&gt; To ease lexing/parsing and avoid user confusion, the names of custom<br>&gt; identifiers (type names, variable names, etc.) and operators in Swift can<br>&gt; be composed of (mostly) separate sets of characters.<br>&gt;<br>&gt; Using terminology from TSPL:<br>&gt;<br>&gt; `identifier-head`/`operator-head` are characters which can *begin *an<br>&gt; identifier or operator.<br>&gt;<br>&gt; `identifier-character`/`operator-character` are characters which can<br>&gt; appear anywhere in an identifier or operator (these are supersets of the<br>&gt; `-head` sets).<br>&gt;<br>&gt; &lt;https://developer.apple.com/library/content/documentation/<br>&gt; Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&gt;<br>&gt;<br>&gt; (Note also that some particular arrangements of characters are reserved;<br>&gt; for instance, `$` followed by digits for an implicit closure parameter, and<br>&gt; &quot;If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot<br>&gt; elsewhere.&quot; There are also special characters in the language which are<br>&gt; neither identifiers nor operators, such as: `()[]{},:@#`)<br>&gt;<br>&gt;<br>&gt; *## Prior discussion on swift-evolution*<br>&gt;<br>&gt; *&quot;Request to add middle dot (U+00B7) as operator character?&quot;*<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20151214/003176.html&gt;<br>&gt;<br>&gt; *&quot;Free the &#39;$&#39; Symbol!&quot;*<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20151228/005133.html&gt;<br>&gt;<br>&gt; *&quot;Proposal: Allow Single Dollar Sign as Valid Identifier&quot;*<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;<br>&gt;<br>&gt; Chris Lattner has said:<br>&gt;<br>&gt; &gt; &quot;...our current operator space (particularly the unicode segments<br>&gt; covered) is not super well considered.  It would be great for someone to<br>&gt; take a more systematic pass over them to rationalize things.&quot;<br>&gt;<br>&gt; &gt; &quot;We need a token to be unambiguously an operator or identifier - we can<br>&gt; have different rules for the leading and subsequent characters though.&quot;<br>&gt;<br>&gt;<br>&gt; *# Current state of affairs*<br>&gt;<br>&gt; Swift&#39;s `identifier-head` and `identifier-character` mostly conform to the<br>&gt; recommendations in &lt;http://www.open-std.org/jtc1/<br>&gt; sc22/wg21/docs/papers/2010/n3146.html&gt;<br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/lib/Parse/Lexer.cpp#L421-L489<br>&gt; &gt;<br>&gt;<br>&gt; The allowed operator characters include &quot;Unicode math, symbol, arrow,<br>&gt; dingbat, and line/box drawing chars&quot;, however I don&#39;t believe this aligns<br>&gt; with any particular spec:<br>&gt; &lt;https://github.com/apple/swift/blob/08e7963/include/<br>&gt; swift/AST/Identifier.h#L87-L121&gt;<br>&gt; &lt;https://github.com/apple/swift/commit/a2341a4&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; *## Identifiers/operators elsewhere*<br>&gt;<br>&gt; There is an Unicode Standard Annex &quot;identifier and pattern syntax&quot; &lt;<br>&gt; http://unicode.org/reports/tr31/&gt; which defines the categories<br>&gt; `ID_Start`/`ID_Continue`.<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; %5B%3AID_Continue%3A%5D&gt;<br>&gt;<br>&gt; *### ECMAScript 2015 &quot;ES6&quot;*<br>&gt;<br>&gt; Uses `ID_Start` and `ID_Continue`, as well as `Other_ID_Start` /<br>&gt; `Other_ID_Continue`.<br>&gt; &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt;<br>&gt; *### Haskell*<br>&gt;<br>&gt; Distinguishes identifiers/operators by their general category (such as<br>&gt; &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, etc.).<br>&gt;<br>&gt; &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt;<br>&gt;<br>&gt; In particular, identifiers can start with any lowercase letter or _, and<br>&gt; may contain any letter/digit/&#39;/_. This would seem to include letters like Œ¥<br>&gt; and –Ø, and digits like Ÿ¢.<br>&gt;<br>&gt; &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt; &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cf<br>&gt; d213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; *# Current problems*<br>&gt;<br>&gt; *## Weird identifier code points*<br>&gt;<br>&gt; The current `identifier-character` set contains many characters which<br>&gt; wouldn&#39;t make good identifiers:<br>&gt;<br>&gt; - 11 entire planes of characters (U+20000‚ÄìU+2FFFD, etc.) which are<br>&gt; currently unassigned.<br>&gt; - The middle dot ¬∑ which looks like an operator.<br>&gt; - Many non-combining &quot;modifiers&quot; and accent marks, such as ¬¥ and ¬® and Íìª<br>&gt; which don&#39;t really make sense on their own.<br>&gt; - &quot;Tone marks&quot; from various languages, including À´ (similar to a<br>&gt; box-drawing character ‚îú which is an operator).<br>&gt; - The &quot;Greek question mark&quot; Õæ<br>&gt; - Symbols which are simply not linguistic, such as €û and ‡ºí.<br>&gt;<br>&gt; short url: &lt;https://goo.gl/tyn0Cz&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; %5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%<br>&gt; 5Cu00AD%0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%5Cu00BA%0D%0A%<br>&gt; 5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%5Cu00F6%0D%0A%<br>&gt; 5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%5Cu167F%0D%0A%<br>&gt; 5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%5Cu1FFF%0D%0A%<br>&gt; 5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%5Cu2040%0D%0A%<br>&gt; 5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%5Cu2100-%<br>&gt; 5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%5Cu2C00-%<br>&gt; 5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%5Cu3021-%<br>&gt; 5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%5CuF900-%<br>&gt; 5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%5CuFE30-%<br>&gt; 5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%<br>&gt; 5CU0001FFFD%0D%0A%5CU00020000-%5CU0002FFFD%0D%0A%<br>&gt; 5CU00030000-%5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%<br>&gt; 0D%0A%5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%0D%0A%<br>&gt; 5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%<br>&gt; 0D%0A%5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%0D%0A%<br>&gt; 5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%<br>&gt; 0D%0A%5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-<br>&gt; %5CU000EFFFD%5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%<br>&gt; 5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D&gt;<br>&gt;<br>&gt; *## Weird operator code points*<br>&gt;<br>&gt; The current `operator-character` set has a lot of characters that are<br>&gt; clearly operator-esque (‚âà ‚àà ‚äï ‚äÖ), but some things are not so obviously<br>&gt; desirable:<br>&gt;<br>&gt; - Box-drawing characters<br>&gt; - Combining accents and other characters<br>&gt; - Various symbols, e.g. ‚öÑ and ‚ôÑ (this category also overlaps with emoji)<br>&gt; - Braille patterns such as ‚†ü ‚Äî should they not be treated as letter-like<br>&gt; (thus identifiers)?<br>&gt; - A plethora of arrows<br>&gt;<br>&gt; short url: &lt;https://goo.gl/s136Nh&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; %5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%<br>&gt; 5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%<br>&gt; 0D%0A%5Cu00AE%0D%0A%5Cu00B0-%5Cu00B1%0D%0A%5Cu00B6%0D%0A%<br>&gt; 5Cu00BB%0D%0A%5Cu00BF%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%<br>&gt; 5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%5Cu2030-%5Cu203E%0D%0A%<br>&gt; 5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%5Cu2190-%5Cu23FF%0D%0A%<br>&gt; 5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%5Cu2E00-%5Cu2E7F%0D%0A%<br>&gt; 5Cu3001-%5Cu3003%0D%0A%5Cu3008-%5Cu3030%5D%0D%0A%5B%<br>&gt; 5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%<br>&gt; 5CuFE00-%5CuFE0F%0D%0A%5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D&gt;<br>&gt;<br>&gt;<br>&gt; *## Code points which are both*<br>&gt;<br>&gt; A handful of characters are accepted *both* as `identifier-head` and<br>&gt; `operator-head` (which seems pointless and might have been unintentional):<br>&gt;<br>&gt; U+3021‚ÄìU+3029, Suzhou numerals  „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© &lt;https://en.wikipedia.org/<br>&gt; wiki/Suzhou_numerals&gt;<br>&gt;<br>&gt; U+302A‚ÄìU+302F, ideographic &amp; hangul tone marks   „Ä™  „Ä´  „Ä¨  „Ä≠  „ÄÆ  „ÄØ<br>&gt;<br>&gt;     let „Ä® = 2<br>&gt;     infix operator &lt;„Ä®&gt;<br>&gt;<br>&gt; (Note that `infix operator „Ä®` doesn&#39;t work because the lexer greedily<br>&gt; treats this as an identifier. Also, interestingly, the corresponding<br>&gt; ideographic zero „Äá is only an identifier char.)<br>&gt;<br>&gt; short url: &lt;https://goo.gl/lZcMqO&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; [%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%<br>&gt; 5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%<br>&gt; 5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%<br>&gt; 5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%<br>&gt; 5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%<br>&gt; 5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%<br>&gt; 5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%<br>&gt; 5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%<br>&gt; 5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%<br>&gt; 5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%<br>&gt; 5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%<br>&gt; 5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%<br>&gt; 5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%<br>&gt; 5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%<br>&gt; 0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%<br>&gt; 5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%<br>&gt; 0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%<br>&gt; 5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%<br>&gt; 0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-<br>&gt; %5cU000EFFFD%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%26%<br>&gt; 7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%5cu00AB%<br>&gt; 0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%5cu00B1%0d%0a%<br>&gt; 5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%5cu00D7%0d%0a%<br>&gt; 5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%5cu2030-%<br>&gt; 5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%5cu2190-%<br>&gt; 5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%5cu2E00-%<br>&gt; 5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%5cu3008-%5cu3030%5d]&gt;<br>&gt;<br>&gt; In addition to the numerals and tone marks above, many (all?) *combining<br>&gt; marks* are accepted as `identifier-character` and `operator-character`.<br>&gt; These may be necessary for natural-looking words in some languages, but<br>&gt; they don&#39;t seem necessary for operators.<br>&gt;<br>&gt; Also present in both sets are the *variation selectors* 1 through 256<br>&gt; (U+FE00‚ÄìU+FE0F, U+E0100‚ÄìU+E01EF). It seems they are of limited use for the<br>&gt; operator characters, unless you count the emoji: &lt;http://www.unicode.org/<br>&gt; Public/UCD/latest/ucd/StandardizedVariants.txt&gt;<br>&gt;<br>&gt; short url: &lt;https://goo.gl/VKrisf&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; [%5ba-zA-Z%0d%0a_%0d%0a%5cu00A8%0d%0a%5cu00AA%0d%0a%<br>&gt; 5cu00AD%0d%0a%5cu00AF%0d%0a%5cu00B2-%5cu00B5%0d%0a%5cu00B7-%5cu00BA%0d%0a%<br>&gt; 5cu00BC-%5cu00BE%0d%0a%5cu00C0-%5cu00D6%0d%0a%5cu00D8-%5cu00F6%0d%0a%<br>&gt; 5cu00F8-%5cu00FF%0d%0a%5cu0100-%5cu02FF%0d%0a%5cu0370-%5cu167F%0d%0a%<br>&gt; 5cu1681-%5cu180D%0d%0a%5cu180F-%5cu1DBF%0d%0a%5cu1E00-%5cu1FFF%0d%0a%<br>&gt; 5cu200B-%5cu200D%0d%0a%5cu202A-%5cu202E%0d%0a%5cu203F-%5cu2040%0d%0a%<br>&gt; 5cu2054%0d%0a%5cu2060-%5cu206F%0d%0a%5cu2070-%5cu20CF%0d%0a%5cu2100-%<br>&gt; 5cu218F%0d%0a%5cu2460-%5cu24FF%0d%0a%5cu2776-%5cu2793%0d%0a%5cu2C00-%<br>&gt; 5cu2DFF%0d%0a%5cu2E80-%5cu2FFF%0d%0a%5cu3004-%5cu3007%0d%0a%5cu3021-%<br>&gt; 5cu302F%0d%0a%5cu3031-%5cu303F%0d%0a%5cu3040-%5cuD7FF%0d%0a%5cuF900-%<br>&gt; 5cuFD3D%0d%0a%5cuFD40-%5cuFDCF%0d%0a%5cuFDF0-%5cuFE1F%0d%0a%5cuFE30-%<br>&gt; 5cuFE44%0d%0a%5cuFE47-%5cuFFFD%0d%0a%5cU00010000-%<br>&gt; 5cU0001FFFD%0d%0a%5cU00020000-%5cU0002FFFD%0d%0a%<br>&gt; 5cU00030000-%5cU0003FFFD%0d%0a%5cU00040000-%5cU0004FFFD%<br>&gt; 0d%0a%5cU00050000-%5cU0005FFFD%0d%0a%5cU00060000-%5cU0006FFFD%0d%0a%<br>&gt; 5cU00070000-%5cU0007FFFD%0d%0a%5cU00080000-%5cU0008FFFD%<br>&gt; 0d%0a%5cU00090000-%5cU0009FFFD%0d%0a%5cU000A0000-%5cU000AFFFD%0d%0a%<br>&gt; 5cU000B0000-%5cU000BFFFD%0d%0a%5cU000C0000-%5cU000CFFFD%<br>&gt; 0d%0a%5cU000D0000-%5cU000DFFFD%0d%0a%5cU000E0000-<br>&gt; %5cU000EFFFD%5d%0d%0a%5b0-9%0d%0a%5cu0300-%5cu036F%0d%0a%<br>&gt; 5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%<br>&gt; 5cuFE20-%5cuFE2F%5d%26%5b%2f%3d%5c-%2b%21%2a%25%3C%3E%5c%<br>&gt; 26%7c%5c%5e~%3f%0d%0a%5cu00A1-%5cu00A7%0d%0a%5cu00A9%<br>&gt; 5cu00AB%0d%0a%5cu00AC%0d%0a%5cu00AE%0d%0a%5cu00B0-%<br>&gt; 5cu00B1%0d%0a%5cu00B6%0d%0a%5cu00BB%0d%0a%5cu00BF%0d%0a%<br>&gt; 5cu00D7%0d%0a%5cu00F7%0d%0a%5cu2016-%5cu2017%0d%0a%5cu2020-%5cu2027%0d%0a%<br>&gt; 5cu2030-%5cu203E%0d%0a%5cu2041-%5cu2053%0d%0a%5cu2055-%5cu205E%0d%0a%<br>&gt; 5cu2190-%5cu23FF%0d%0a%5cu2500-%5cu2775%0d%0a%5cu2794-%5cu2BFF%0d%0a%<br>&gt; 5cu2E00-%5cu2E7F%0d%0a%5cu3001-%5cu3003%0d%0a%<br>&gt; 5cu3008-%5cu3030%5d%0d%0a%5b%5cu0300-%5cu036F%0d%0a%<br>&gt; 5cu1DC0-%5cu1DFF%0d%0a%5cu20D0-%5cu20FF%0d%0a%5cuFE00-%5cuFE0F%0d%0a%<br>&gt; 5cuFE20-%5cuFE2F%0d%0a%5cU000E0100-%5cU000E01EF%5d]&gt;<br>&gt;<br>&gt;<br>&gt; *## Code points which should be illegal*<br>&gt;<br>&gt; There are several surprising non-printing characters, including:<br>&gt;<br>&gt; - U+2064 INVISIBLE PLUS is currently an identifier<br>&gt; - U+200B ZERO WIDTH SPACE is currently an identifier<br>&gt;<br>&gt; No good will come of these. Invisible characters should probably be<br>&gt; disallowed (although some may be necessary for properly joining/splitting<br>&gt; characters in some other languages).<br>&gt;<br>&gt;<br>&gt; *## Categories which are split between identifiers and operators*<br>&gt;<br>&gt; - Emoji and symbols: most of the newer emoji are identifiers, but many<br>&gt; emoji/pictographs are operators, especially those from &quot;Miscellaneous<br>&gt; Symbols&quot;. The results are hilariously illogical:<br>&gt;<br>&gt;   - ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt;   - ‚úåÔ∏è is an operator, but ü§ò is an identifier.<br>&gt;   - üîº is an operator, but ‚ñ∂Ô∏è is an identifier.<br>&gt;   - ‚ú≥Ô∏è is an operator, but üîØ is an identifier.<br>&gt;   - ‚úàÔ∏è is an operator, but üõ© is an identifier.<br>&gt;   - ‚ô†Ô∏è is an operator, but üÇ° is an identifier. (Presumably, üÇ° = A ‚ô†Ô∏è üÇ†!)<br>&gt;<br>&gt;   (But the counterintuitive examples extend outside the emoji too: + is an<br>&gt; operator, while ‚Çä and ‚Å∫ are identifiers.)<br>&gt;<br>&gt; - Currency symbols: ¬¢ ¬£ ¬§ ¬• are operators, but ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø and many others<br>&gt; are identifiers, and $ is allowed in an identifier.<br>&gt;<br>&gt;<br>&gt; *## Missing characters*<br>&gt;<br>&gt; A handful of characters are neither operators nor identifiers. This list<br>&gt; mostly makes sense (reserved characters and whitespace), but I wonder about<br>&gt; a few which seem like they could easily be operators: ‚ëä ‚ëÄ ÔπÖ etc.<br>&gt;<br>&gt; short url: &lt;https://goo.gl/U0GVNn&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; %5B%5B%5Cu0001-%5CU0010FFFF%5D-%5B%5B%2F%3D%5C-%2B!*%25%<br>&gt; 3C%3E%5C%26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%<br>&gt; 5Cu00A9%5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%<br>&gt; 5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%<br>&gt; 5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%<br>&gt; 5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%<br>&gt; 5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%<br>&gt; 5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%<br>&gt; 5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%<br>&gt; 5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%<br>&gt; 5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%<br>&gt; 5Ba-zA-Z%0D%0A_%0D%0A%5Cu00A8%0D%0A%5Cu00AA%0D%0A%5Cu00AD%<br>&gt; 0D%0A%5Cu00AF%0D%0A%5Cu00B2-%5Cu00B5%0D%0A%5Cu00B7-%<br>&gt; 5Cu00BA%0D%0A%5Cu00BC-%5Cu00BE%0D%0A%5Cu00C0-%5Cu00D6%0D%0A%5Cu00D8-%<br>&gt; 5Cu00F6%0D%0A%5Cu00F8-%5Cu00FF%0D%0A%5Cu0100-%5Cu02FF%0D%0A%5Cu0370-%<br>&gt; 5Cu167F%0D%0A%5Cu1681-%5Cu180D%0D%0A%5Cu180F-%5Cu1DBF%0D%0A%5Cu1E00-%<br>&gt; 5Cu1FFF%0D%0A%5Cu200B-%5Cu200D%0D%0A%5Cu202A-%5Cu202E%0D%0A%5Cu203F-%<br>&gt; 5Cu2040%0D%0A%5Cu2054%0D%0A%5Cu2060-%5Cu206F%0D%0A%5Cu2070-%5Cu20CF%0D%0A%<br>&gt; 5Cu2100-%5Cu218F%0D%0A%5Cu2460-%5Cu24FF%0D%0A%5Cu2776-%5Cu2793%0D%0A%<br>&gt; 5Cu2C00-%5Cu2DFF%0D%0A%5Cu2E80-%5Cu2FFF%0D%0A%5Cu3004-%5Cu3007%0D%0A%<br>&gt; 5Cu3021-%5Cu302F%0D%0A%5Cu3031-%5Cu303F%0D%0A%5Cu3040-%5CuD7FF%0D%0A%<br>&gt; 5CuF900-%5CuFD3D%0D%0A%5CuFD40-%5CuFDCF%0D%0A%5CuFDF0-%5CuFE1F%0D%0A%<br>&gt; 5CuFE30-%5CuFE44%0D%0A%5CuFE47-%5CuFFFD%0D%0A%5CU00010000-%5CU0001FFFD%0D%<br>&gt; 0A%5CU00020000-%5CU0002FFFD%0D%0A%5CU00030000-%<br>&gt; 5CU0003FFFD%0D%0A%5CU00040000-%5CU0004FFFD%0D%0A%<br>&gt; 5CU00050000-%5CU0005FFFD%0D%0A%5CU00060000-%5CU0006FFFD%<br>&gt; 0D%0A%5CU00070000-%5CU0007FFFD%0D%0A%5CU00080000-%5CU0008FFFD%0D%0A%<br>&gt; 5CU00090000-%5CU0009FFFD%0D%0A%5CU000A0000-%5CU000AFFFD%<br>&gt; 0D%0A%5CU000B0000-%5CU000BFFFD%0D%0A%5CU000C0000-%5CU000CFFFD%0D%0A%<br>&gt; 5CU000D0000-%5CU000DFFFD%0D%0A%5CU000E0000-%5CU000EFFFD%<br>&gt; 5D%0D%0A%5B0-9%0D%0A%5Cu0300-%5Cu036F%0D%0A%5Cu1DC0-%<br>&gt; 5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE20-%5CuFE2F%5D%5D%5D&gt;<br>&gt;<br>&gt;<br>&gt; *# Solutions*<br>&gt;<br>&gt; Still up for discussion ‚Äî please reply to this thread!<br>&gt;<br>&gt; Adopting (X)ID_Start/Continue for identifiers, or a simpler solution like<br>&gt; Haskell&#39;s use of &quot;letter&quot; categories, might work well.<br>&gt;<br>&gt; (I&#39;ve given up hope of finding some kind of &quot;perfect&quot; solution ‚Äî how can<br>&gt; it be possible, when ·õè is a letter, yet ‚Üë is not?)<br>&gt;<br>&gt; Making the choice of operator characters more logical/standards-based<br>&gt; would be nice (not just a set of ranges). However, Haskell&#39;s approach of<br>&gt; using all punctuation &amp; symbols is probably not right for Swift:<br>&gt;<br>&gt; short url: &lt;https://goo.gl/Ud4KqY&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%<br>&gt; 5B-%2F%3D%2B!*%25%3C%3E%5C%26%7C%5C%5E~?%5Cu00A1-%5Cu00A7%<br>&gt; 5Cu00A9%5Cu00AB%5Cu00AC%5Cu00AE%5Cu00B0-%5Cu00B1%5Cu00B6%5Cu00BB%5Cu00BF%<br>&gt; 5Cu00D7%5Cu00F7%5Cu2016-%5Cu2017%5Cu2020-%5Cu2027%<br>&gt; 5Cu2030-%5Cu203E%5Cu2041-%5Cu2053%5Cu2055-%5Cu205E%<br>&gt; 5Cu2190-%5Cu23FF%5Cu2500-%5Cu2775%5Cu2794-%5Cu2BFF%<br>&gt; 5Cu2E00-%5Cu2E7F%5Cu3001-%5Cu3003%5Cu3008-%5Cu3030%<br>&gt; 5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%<br>&gt; 5CuFE00-%5CuFE0F%5CuFE20-%5CuFE2F%5CU000E0100-%5CU000E01EF%5D%5D&amp;b=%5B%5B:<br>&gt; Currency_Symbol:%5D%5B:Modifier_Symbol:%5D%5B:Math_<br>&gt; Symbol:%5D%5B:Other_Symbol:%5D%5B:Connector_Punctuation:%<br>&gt; 5D%5B:Dash_Punctuation:%5D%5B:Close_Punctuation:%5D%5B:<br>&gt; Final_Punctuation:%5D%5B:Initial_Punctuation:%5D%5B:<br>&gt; Other_Punctuation:%5D%5B:Open_Punctuation:%5D%5D&gt;<br>&gt;<br>&gt; I&#39;m not really sure what to do with emoji ‚Äî they&#39;re a very cute novelty<br>&gt; feature, but I don&#39;t know what the motivation is for including these as<br>&gt; valid operators/identifiers.<br>&gt;<br>&gt; At the least, we should try to gather them all into one of the two<br>&gt; categories. My inclination would be to keep them as identifiers, which<br>&gt; would mean moving the following out of the operator category:<br>&gt;<br>&gt; short url: &lt;https://goo.gl/CBJEKX&gt;<br>&gt;<br>&gt; &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=<br>&gt; %5B%5B%3AEmoji%3A%5D%26%5B%5B%2F%3D%5C-%2B%21*%25%3C%3E%5C%<br>&gt; 26%7C%5C%5E~%3F%0D%0A%5Cu00A1-%5Cu00A7%0D%0A%5Cu00A9%<br>&gt; 5Cu00AB%0D%0A%5Cu00AC%0D%0A%5Cu00AE%0D%0A%5Cu00B0-%<br>&gt; 5Cu00B1%0D%0A%5Cu00B6%0D%0A%5Cu00BB%0D%0A%5Cu00BF%0D%0A%<br>&gt; 5Cu00D7%0D%0A%5Cu00F7%0D%0A%5Cu2016-%5Cu2017%0D%0A%5Cu2020-%5Cu2027%0D%0A%<br>&gt; 5Cu2030-%5Cu203E%0D%0A%5Cu2041-%5Cu2053%0D%0A%5Cu2055-%5Cu205E%0D%0A%<br>&gt; 5Cu2190-%5Cu23FF%0D%0A%5Cu2500-%5Cu2775%0D%0A%5Cu2794-%5Cu2BFF%0D%0A%<br>&gt; 5Cu2E00-%5Cu2E7F%0D%0A%5Cu3001-%5Cu3003%0D%0A%<br>&gt; 5Cu3008-%5Cu3030%5D%0D%0A%5B%5Cu0300-%5Cu036F%0D%0A%<br>&gt; 5Cu1DC0-%5Cu1DFF%0D%0A%5Cu20D0-%5Cu20FF%0D%0A%5CuFE00-%5CuFE0F%0D%0A%<br>&gt; 5CuFE20-%5CuFE2F%0D%0A%5CU000E0100-%5CU000E01EF%5D%5D%5D&gt;<br>&gt;<br>&gt;<br>&gt; *# Concurrently-discussable topics*<br>&gt;<br>&gt; There are a few relevant topics that came to mind, which I think are worth<br>&gt; discussing around the same time.<br>&gt;<br>&gt; *## Dollar signs ($)*<br>&gt;<br>&gt; $ is currently allowed in identifiers, but it can&#39;t begin an identifier<br>&gt; except for the magic implicit closure params ($0, $1, ...) and<br>&gt; LLDB/REPL-related uses.<br>&gt;<br>&gt; It&#39;s arguable, but I feel that $ would be more effective as an operator<br>&gt; character than an identifier character. There&#39;s precedent in Haskell for<br>&gt; operators like `&lt;$&gt;` and being able to replicate these in Swift would be<br>&gt; nice.<br>&gt;<br>&gt;<br>&gt; *## Diagnostics improvements*<br>&gt;<br>&gt; Regardless of what ends up being the ultimate solution, it would be great<br>&gt; to improve diagnostics for cases when the wrong types of characters are<br>&gt; used.<br>&gt;<br>&gt; `infix operator abc` produces `&#39;abc&#39; is considered to be an identifier,<br>&gt; not an operator`. That&#39;s not too bad.<br>&gt;<br>&gt; `let +++ = 3` produces `expected pattern`.<br>&gt;<br>&gt; `let $foo = 3` produces `expected numeric value following &#39;$&#39;`.<br>&gt;<br>&gt;<br>&gt; *## Security and —ÅŒønfu—ï–∞bI–µ characters*<br>&gt;<br>&gt; Confusable characters (e vs. –µ, o vs. Œø, ; vs. Õæ) are an issue not taken<br>&gt; lightly in the world of web security (cf. domain names). I haven&#39;t found<br>&gt; much information about whether this has been considered a major security<br>&gt; issue in programming languages, but I would think so (one can imagine such<br>&gt; characters being introduced to a codebase subtly over time, hiding<br>&gt; malicious functionality).<br>&gt;<br>&gt; It&#39;d be pretty cool if Swift could detect whether two identifiers might be<br>&gt; confusable, and produce a warning.<br>&gt;<br>&gt; &lt;http://www.unicode.org/reports/tr36/#Recommendations_General&gt;<br>&gt; &lt;http://unicode.org/reports/tr39/#Confusable_Detection&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/a1291201/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Sep 18, 2016, at 6:24 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sun, Sep 18, 2016 at 9:19 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Let me tl;dr&#39;er this even more: ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt; <br>&gt; -- E, succinct, who thinks there&#39;s room for improvement<br>&gt; <br>&gt; Ha, yes. Let&#39;s see if I can be as succinct in my contribution to the discussion:<br>&gt; <br>&gt; 1) Agree that current situation not ideal, for reasons above<br></p><p>+1, totally agreed.  We really need to improve this, aiming for Swift 3.1 or Swift 4 seems like a really good idea, because the appetite for this sort of change will probably be very low after Swift 4.<br></p><p>&gt; 2) The solution might best be not one but several proposals:<br>&gt; <br>&gt;   2a) Unicode normalization: invisible characters, Greek tonos, etc. (cf. previous message about previously proposed solution, which reflects Unicode recommendations in UTR #31)--low hanging fruit: there&#39;s an established Unicode recommendation with clear wins for security and consistency<br>&gt; <br>&gt;   2b) Legal and illegal characters for identifiers *or* operators: UTR #31 makes recommendations regarding rarely used scripts; probably best to follow the letter and spirit of these recommendations (which would probably mean ancient Greek musical symbols and Egyptian hieroglyphics shouldn&#39;t be identifier or operator characters)<br>&gt; <br>&gt;   2c) Decisions as to which characters are identifier characters or operator characters: for instance, emoji should probably never be operator characters; if an emoji has a non-emoji counterpart that is an operator (‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è, etc.) it might be best simply to make these illegal rather than operator characters<br>&gt; <br>&gt;   2d) Confusables: I think the last time we had this discussion, it was apparent that it&#39;d be difficult to decide which confusables to allow or disallow after some of the low-hanging fruit is taken care of by Unicode normalization (see item 2a); the Unicode Consortium-provided list seems too quick to call two things &quot;confusable&quot; for our purposes (with criteria that might be relevant for URLs or other use cases, but casting too wide a net perhaps for Swift identifiers)<br></p><p>These all seem like good points.  I agree that we should default to following an existing Unicode standard unless there is a really good reason to deviate.<br></p><p>I don‚Äôt have an opinion about the specific direction of the proposal though.<br></p><p><br>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/f3a7feec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>September 23, 2016 at 12:00:00pm</p></header><div class="content"><p>It would probably make sense to define the supported characters based on their category, rather than abstract ranges of character sets. For example, using the Letter and Number categories might be sufficient for defining identifiers.<br></p><p>https://en.wikipedia.org/wiki/Unicode_character_property#General_Category<br></p><p>In this case both of these characters are in the &#39;Symbol, Other&#39; category:<br></p><p>üôÇ http://www.fileformat.info/info/unicode/char/1f642/index.htm<br>‚òπÔ∏è http://www.fileformat.info/info/unicode/char/2639/index.htm<br></p><p>Having the language define which categories are used for which type means they don&#39;t have to be individually enumerated as part of the grammar<br></p><p>https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID458<br></p><p>It is possible to read and process the Unicode format to build up the character ranges programmatically; that&#39;s what ICU does to efficiently be able to answer questions like &#39;Is this a valid upper case letter?&#39;. But defining the ranges as part of the grammar leads to evolutionary changes like this which can&#39;t be predicted in advance, because they&#39;re defined on a set of fixed code points.<br></p><p>Alex<br></p><p>&gt; On 18 Sep 2016, at 21:29, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 18, 2016, at 6:24 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sun, Sep 18, 2016 at 9:19 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Let me tl;dr&#39;er this even more: ‚òπÔ∏è is an operator, but üôÇ is an identifier.<br>&gt;&gt; <br>&gt;&gt; -- E, succinct, who thinks there&#39;s room for improvement<br>&gt;&gt; <br>&gt;&gt; Ha, yes. Let&#39;s see if I can be as succinct in my contribution to the discussion:<br>&gt;&gt; <br>&gt;&gt; 1) Agree that current situation not ideal, for reasons above<br>&gt; <br>&gt; +1, totally agreed.  We really need to improve this, aiming for Swift 3.1 or Swift 4 seems like a really good idea, because the appetite for this sort of change will probably be very low after Swift 4.<br>&gt; <br>&gt;&gt; 2) The solution might best be not one but several proposals:<br>&gt;&gt; <br>&gt;&gt;   2a) Unicode normalization: invisible characters, Greek tonos, etc. (cf. previous message about previously proposed solution, which reflects Unicode recommendations in UTR #31)--low hanging fruit: there&#39;s an established Unicode recommendation with clear wins for security and consistency<br>&gt;&gt; <br>&gt;&gt;   2b) Legal and illegal characters for identifiers *or* operators: UTR #31 makes recommendations regarding rarely used scripts; probably best to follow the letter and spirit of these recommendations (which would probably mean ancient Greek musical symbols and Egyptian hieroglyphics shouldn&#39;t be identifier or operator characters)<br>&gt;&gt; <br>&gt;&gt;   2c) Decisions as to which characters are identifier characters or operator characters: for instance, emoji should probably never be operator characters; if an emoji has a non-emoji counterpart that is an operator (‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è, etc.) it might be best simply to make these illegal rather than operator characters<br>&gt;&gt; <br>&gt;&gt;   2d) Confusables: I think the last time we had this discussion, it was apparent that it&#39;d be difficult to decide which confusables to allow or disallow after some of the low-hanging fruit is taken care of by Unicode normalization (see item 2a); the Unicode Consortium-provided list seems too quick to call two things &quot;confusable&quot; for our purposes (with criteria that might be relevant for URLs or other use cases, but casting too wide a net perhaps for Swift identifiers)<br>&gt; <br>&gt; These all seem like good points.  I agree that we should default to following an existing Unicode standard unless there is a really good reason to deviate.<br>&gt; <br>&gt; I don‚Äôt have an opinion about the specific direction of the proposal though.<br>&gt; <br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/c9c1eb94/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unicode identifiers &amp; operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September 21, 2016 at 11:00:00pm</p></header><div class="content"><p>Side question: it looks like ICU is used by the standard library on<br>non-Apple platforms. Would it be possible to make it a dependency of the<br>compiler too? If we want to explicitly detect emoji, for instance, it&#39;d be<br>nice to use a canonical library that already does it.<br></p><p>On Sun, Sep 18, 2016 at 12:33 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; *TLÕæDR:*<br>&gt;<br>&gt; Swift 4 Stage 1 seeks to prioritize &quot;Source stability features&quot;. Most<br>&gt; source-breaking changes were done with in Swift 3; however, the<br>&gt; categorization of Unicode characters into identifiers &amp; operators was never<br>&gt; thoroughly discussed on swift-evolution. This seems like it might be our<br>&gt; last chance, and I think there are some big improvements to be had.<br>&gt;<br>&gt; I&#39;ve gathered some information+thoughts into an early-stage pitch /<br>&gt; pre-proposal. It doesn&#39;t really have a conclusion, so I&#39;m hoping we can<br>&gt; discuss these issues and come up with good (pragmatic) solutions here. I<br>&gt; imagine this can morph into a proposal later.<br>&gt;<br>&gt; You can read the following in nicer HTML form at https://gist.github.com/<br>&gt; jtbandes/c0b0c072181dcd22c3147802025d0b59<br>&gt;<br>&gt; I look forward to the discussion!<br>&gt;<br>&gt; -Jacob<br>&gt; &lt;snip&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/7a00479b/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
