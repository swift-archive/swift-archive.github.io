<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October  7, 2016 at 02:00:00pm</p></header><div class="content"><p>on Mon Oct 03 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Sep 30, 2016, at 10:48 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 29, 2016, at 11:45 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I consider the first one to be a fairly-low-risk<br>&gt;&gt;&gt; extension to SE-0139 that’s borderline bug-fix. We already know<br>&gt;&gt;&gt; that those types have weak numeric representations in Objective-C<br>&gt;&gt;&gt; because they come from Objective-C, so losing some of the type info<br>&gt;&gt;&gt; by bridging to Objective-C is (IMO) falls out of having strong<br>&gt;&gt;&gt; types in Swift for weaker types in Objective-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second one makes me a little nervous, I think because it<br>&gt;&gt;&gt; weakens typing for types defined in Swift. These types don’t<br>&gt;&gt;&gt; naturally have Objective-C counterparts, so if we’re going to<br>&gt;&gt;&gt; weaken the types, it feels like we should only do so via some<br>&gt;&gt;&gt; explicit conformance (e.g., to a publicly-available form of<br>&gt;&gt;&gt; _ObjectiveCBridgeable).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m up for reviving the ObjectiveCBridgeable proposal :)<br>&gt;<br>&gt; I kind of hope id-as-Any leads us in a direction where<br>&gt; ObjectiveCBridgeable isn&#39;t necessary to expose for most user types. If<br>&gt; we at some point allow Swift value types to conform to ObjC protocols,<br>&gt; expose @objc methods, and opt in to being representable in ObjC as<br>&gt; classes, then most of the work of building an ObjC class to bridge to<br>&gt; could potentially be handled by the compiler.<br></p><p>Well, ObjectiveCBridgeable is much too complicated for the semantics we<br>need, but it&#39;s easy to imagine a simpler CustomObjectiveCBridgeable<br>protocol that performs the same service.  But it seems to me that coming<br>up with a class representation and initializing it is the easy part, and<br>that the “conforming to an ObjC protocol, exposing @objc methods, and<br>opting in to being representable in ObjC as classes” part is essentially<br>equivalent to conforming to CustomObjectiveCBridgeable.<br></p><p>What am I missing?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Making some RawRepresentable things bridge to ObjC as their raw value</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 2:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Oct 03 2016, Joe Groff &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Sep 30, 2016, at 10:48 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 29, 2016, at 11:45 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally, I consider the first one to be a fairly-low-risk<br>&gt;&gt;&gt;&gt; extension to SE-0139 that’s borderline bug-fix. We already know<br>&gt;&gt;&gt;&gt; that those types have weak numeric representations in Objective-C<br>&gt;&gt;&gt;&gt; because they come from Objective-C, so losing some of the type info<br>&gt;&gt;&gt;&gt; by bridging to Objective-C is (IMO) falls out of having strong<br>&gt;&gt;&gt;&gt; types in Swift for weaker types in Objective-C.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The second one makes me a little nervous, I think because it<br>&gt;&gt;&gt;&gt; weakens typing for types defined in Swift. These types don’t<br>&gt;&gt;&gt;&gt; naturally have Objective-C counterparts, so if we’re going to<br>&gt;&gt;&gt;&gt; weaken the types, it feels like we should only do so via some<br>&gt;&gt;&gt;&gt; explicit conformance (e.g., to a publicly-available form of<br>&gt;&gt;&gt;&gt; _ObjectiveCBridgeable).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m up for reviving the ObjectiveCBridgeable proposal :)<br>&gt;&gt; <br>&gt;&gt; I kind of hope id-as-Any leads us in a direction where<br>&gt;&gt; ObjectiveCBridgeable isn&#39;t necessary to expose for most user types. If<br>&gt;&gt; we at some point allow Swift value types to conform to ObjC protocols,<br>&gt;&gt; expose @objc methods, and opt in to being representable in ObjC as<br>&gt;&gt; classes, then most of the work of building an ObjC class to bridge to<br>&gt;&gt; could potentially be handled by the compiler.<br>&gt; <br>&gt; Well, ObjectiveCBridgeable is much too complicated for the semantics we<br>&gt; need, but it&#39;s easy to imagine a simpler CustomObjectiveCBridgeable<br>&gt; protocol that performs the same service.  But it seems to me that coming<br>&gt; up with a class representation and initializing it is the easy part, and<br>&gt; that the “conforming to an ObjC protocol, exposing @objc methods, and<br>&gt; opting in to being representable in ObjC as classes” part is essentially<br>&gt; equivalent to conforming to CustomObjectiveCBridgeable.<br>&gt; <br>&gt; What am I missing?<br></p><p>Implementation-wise, it probably ends up looking similar. Once you&#39;re exposing @objc methods, the only real practical way to do that is by realizing a distinct ObjC class. Language-design-wise, it feels cleaner to me to push the details of bridging user types under the hood as much as possible. Cocoa has definite use for fully customizing the bridging interface to map core Swift concepts to established ObjC interfaces, and perhaps there are a few third parties who&#39;d also like to dress up their established ObjC frameworks with a modern, value-oriented Swift veneer, but I think we could automate the bridge for the majority of users with higher-level features.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/11ce85a0/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
