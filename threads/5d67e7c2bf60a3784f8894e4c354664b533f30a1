<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br></p><p>To summarize the place we’d like to end up:<br></p><p>- “public” -&gt; symbol visible outside the current module.<br>- “internal” -&gt; symbol visible within the current module.<br>- unknown -&gt; symbol visible within the current file.<br>- “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br></p><p>The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br></p><p>The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br></p><p>fileprivate<br>private(file)<br>internal(file)<br>fileaccessible<br>etc<br></p><p>Some other thoughts on the choice: <br>- this will be a declaration modifier, so it will not “burn” a keyword.<br>- if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br></p><p>Thoughts appreciated.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 14, 2016 at 06:00:00pm</p></header><div class="content"><p>What color is your bikeshed?<br></p><p>I don&#39;t suppose you&#39;d consider swapping private and internal (since the opposite of public is private, and internal means inside)?<br></p><p>Anyway, there&#39;s fileScoped (or filescoped), access(file) (which has the option of being used for access with module and global), <br>filedelimited, filefixed, filebounded, filebound, filerestricted.<br></p><p>You may want constructing phrases around bounding, restrictions, access, limitations, visibility, and local.<br></p><p>-- E<br></p><p><br></p><p><br>&gt; On Mar 14, 2016, at 6:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; <br>&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; <br>&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; <br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt; <br>&gt; Some other thoughts on the choice: <br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; <br>&gt; Thoughts appreciated.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df6c4df2577aeca9491e42e0e33190e9?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Eric Summers</string> &lt;eric.summers at icloud.com&gt;<p>March 14, 2016 at 08:00:00pm</p></header><div class="content"><p>What about:<br>public<br>private<br>private(module) // instead of internal<br>private(file) or private(test)<br></p><p>Eric<br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 14, 2016, at 5:41 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What color is your bikeshed?<br>&gt; <br>&gt; I don&#39;t suppose you&#39;d consider swapping private and internal (since the opposite of public is private, and internal means inside)?<br>&gt; <br>&gt; Anyway, there&#39;s fileScoped (or filescoped), access(file) (which has the option of being used for access with module and global), <br>&gt; filedelimited, filefixed, filebounded, filebound, filerestricted.<br>&gt; <br>&gt; You may want constructing phrases around bounding, restrictions, access, limitations, visibility, and local.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 6:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt; <br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt; <br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; <br>&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt; <br>&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt; <br>&gt;&gt; fileprivate<br>&gt;&gt; private(file)<br>&gt;&gt; internal(file)<br>&gt;&gt; fileaccessible<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt; <br>&gt;&gt; Thoughts appreciated.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 15, 2016 at 12:00:00am</p></header><div class="content"><p>On Mon, Mar 14, 2016 at 5:18 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;<br>&gt; To summarize the place we’d like to end up:<br>&gt;<br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt;<br></p><p>Very much like the thinking.<br></p><p>I guess it isn&#39;t feasible at this point to change `internal` to mean file<br>scoped? That could avoid the need for another qualifier by simply<br>leveraging the default of module scope for things without an access<br>qualifier.<br></p><p>As you know the default of whole module means most developers need never<br>use access control unless they desire to reduce access scope (e.g. file<br>scope, dec scoped). Those working on frameworks would be the ones to<br>leverage public in addition to the other levels.<br></p><p>Of the top of my head: ` pubic`, `internal` (and `internal(module`)),<br>`internal(file)`, `private`. This makes public and private being closest to<br>other languages as you noted with internal being more swift nuanced.<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/f79a4263/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9db7e0c3d3ce86e2bf80675a61fbc49c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James Berry</string> &lt;jberry at rogueorbit.com&gt;<p>March 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; <br>&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; <br>&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; <br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt; <br>&gt; Some other thoughts on the choice: <br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; <br>&gt; Thoughts appreciated.<br></p><p><br>I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br></p><p>	private			symbol visible within the current declaration (class, extension, etc).<br>	private(module)	symbol visible within the current module.<br>	private(file)		symbol visible within the current file.<br></p><p>James<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 15, 2016 at 01:00:00am</p></header><div class="content"><p>I really like James&#39;s idea:<br></p><p>private                 symbol visible within the current declaration<br>(class, extension, etc).<br>private(module) symbol visible within the current module.<br>private(file)           symbol visible within the current file.<br></p><p>this is very precise and crystal clear. All other already suggested names<br>have room for interpretation.  These are obvious at a glance.<br></p><p>On Mon, Mar 14, 2016 at 8:49 PM James Berry via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt; &gt;<br>&gt; &gt; To summarize the place we’d like to end up:<br>&gt; &gt;<br>&gt; &gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt; &gt;<br>&gt; &gt; The rationale here is that this aligns Swift with common art seen in<br>&gt; other languages, and that many people using private today don’t *want*<br>&gt; visibility out of their current declaration.  It also encourages “extension<br>&gt; oriented programming”, at least it will when some of the other restrictions<br>&gt; on extensions are lifted.  We discussed dropping the third one entirely,<br>&gt; but think it *is* a useful and important level of access control, and<br>&gt; when/if we ever get the ability to write unit tests inside of the file that<br>&gt; defines the functionality, they will be a nicer solution to @testable.<br>&gt; &gt;<br>&gt; &gt; The thing we need to know is what the spelling should be for the third<br>&gt; one.  Off hand, perhaps:<br>&gt; &gt;<br>&gt; &gt; fileprivate<br>&gt; &gt; private(file)<br>&gt; &gt; internal(file)<br>&gt; &gt; fileaccessible<br>&gt; &gt; etc<br>&gt; &gt;<br>&gt; &gt; Some other thoughts on the choice:<br>&gt; &gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; &gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt; googlable keyword.<br>&gt; &gt;<br>&gt; &gt; Thoughts appreciated.<br>&gt;<br>&gt;<br>&gt; I like fileprivate, if that’s the only change. On the other hand, if we<br>&gt; want to consider a broader change, what about:<br>&gt;<br>&gt;         private                 symbol visible within the current<br>&gt; declaration (class, extension, etc).<br>&gt;         private(module) symbol visible within the current module.<br>&gt;         private(file)           symbol visible within the current file.<br>&gt;<br>&gt; James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/cc8ac6dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 14, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 6:47 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like James&#39;s idea:<br>&gt; <br>&gt; private                 symbol visible within the current declaration (class, extension, etc).<br>&gt; private(module) symbol visible within the current module.<br>&gt; private(file)           symbol visible within the current file.<br>&gt; <br>&gt; this is very precise and crystal clear. All other already suggested names have room for interpretation.  These are obvious at a glance.<br></p><p>I like this too. It also admits groupings between &#39;file&#39; and &#39;module&#39; in the future (&#39;directory&#39; or &#39;submodule&#39; maybe), the lack of which has been often cited as another weakness in our current model.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 7:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 6:47 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like James&#39;s idea:<br>&gt;&gt; <br>&gt;&gt; private                 symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; private(module) symbol visible within the current module.<br>&gt;&gt; private(file)           symbol visible within the current file.<br>&gt;&gt; <br>&gt;&gt; this is very precise and crystal clear. All other already suggested names have room for interpretation.  These are obvious at a glance.<br>&gt; <br>&gt; I like this too. It also admits groupings between &#39;file&#39; and &#39;module&#39; in the future (&#39;directory&#39; or &#39;submodule&#39; maybe), the lack of which has been often cited as another weakness in our current model.<br>&gt; <br></p><p>+1 here too.<br></p><p>* It resolves my issues with public/internal vs public/private. <br>* As Ilya put it: &quot;obvious at a glance&quot;<br>* Uses one concept applied to different scopes.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 14, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 8:57 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 7:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 6:47 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really like James&#39;s idea:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private                 symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; private(module) symbol visible within the current module.<br>&gt;&gt;&gt; private(file)           symbol visible within the current file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this is very precise and crystal clear. All other already suggested names have room for interpretation.  These are obvious at a glance.<br>&gt;&gt; <br>&gt;&gt; I like this too. It also admits groupings between &#39;file&#39; and &#39;module&#39; in the future (&#39;directory&#39; or &#39;submodule&#39; maybe), the lack of which has been often cited as another weakness in our current model.<br>&gt;&gt; <br>&gt; <br>&gt; +1 here too.<br>&gt; <br>&gt; * It resolves my issues with public/internal vs public/private. <br>&gt; * As Ilya put it: &quot;obvious at a glance&quot;<br>&gt; * Uses one concept applied to different scopes.<br>&gt; <br></p><p>Tentative +1 here as well, but I think we should continue the bikeshed.  I’m not yet certain this is the best we can come up with...<br></p><p>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 14, 2016 at 09:00:00pm</p></header><div class="content"><p>How would you handle translating the existing private(set) and the like with this syntax? It seems like it could get confusing and perhaps end up in a situation where you have something like private(file, set) but then you have to constantly remember which order the parameters are in.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Mar 14, 2016, at 8:47 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like James&#39;s idea:<br>&gt; <br>&gt; private                 symbol visible within the current declaration (class, extension, etc).<br>&gt; private(module) symbol visible within the current module.<br>&gt; private(file)           symbol visible within the current file.<br>&gt; <br>&gt; this is very precise and crystal clear. All other already suggested names have room for interpretation.  These are obvious at a glance.<br>&gt; <br>&gt; On Mon, Mar 14, 2016 at 8:49 PM James Berry via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; &gt;<br>&gt; &gt; To summarize the place we’d like to end up:<br>&gt; &gt;<br>&gt; &gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; &gt;<br>&gt; &gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; &gt;<br>&gt; &gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; &gt;<br>&gt; &gt; fileprivate<br>&gt; &gt; private(file)<br>&gt; &gt; internal(file)<br>&gt; &gt; fileaccessible<br>&gt; &gt; etc<br>&gt; &gt;<br>&gt; &gt; Some other thoughts on the choice:<br>&gt; &gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; &gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; &gt;<br>&gt; &gt; Thoughts appreciated.<br>&gt; <br>&gt; <br>&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt; <br>&gt;         private                 symbol visible within the current declaration (class, extension, etc).<br>&gt;         private(module) symbol visible within the current module.<br>&gt;         private(file)           symbol visible within the current file.<br>&gt; <br>&gt; James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 15, 2016 at 07:00:00am</p></header><div class="content"><p>How about<br></p><p>- “public” -&gt; symbol visible outside the current module.<br>- “package or module” -&gt; symbol visible within the current module.<br>- internal -&gt; symbol visible within the current file.<br>- “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br></p><p>?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 15 Mar 2016, at 00:49, James Berry via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt; <br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt; <br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; <br>&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt; <br>&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt; <br>&gt;&gt; fileprivate<br>&gt;&gt; private(file)<br>&gt;&gt; internal(file)<br>&gt;&gt; fileaccessible<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt; <br>&gt;&gt; Thoughts appreciated.<br>&gt; <br>&gt; <br>&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt; <br>&gt;    private            symbol visible within the current declaration (class, extension, etc).<br>&gt;    private(module)    symbol visible within the current module.<br>&gt;    private(file)        symbol visible within the current file.<br>&gt; <br>&gt; James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/8a938b98/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 15, 2016 at 02:00:00pm</p></header><div class="content"><p>I like the idea of public and then varying degrees of private (with the default being the most private). Public values are published outside of the build target.<br></p><p>However, I have a question how we would express the concept of mixed property access levels, for instance with a private (to the scope) setter and private (to the module) getter.<br></p><p>-DW<br></p><p>&gt; On Mar 14, 2016, at 6:49 PM, James Berry via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	private			symbol visible within the current declaration (class, extension, etc).<br>&gt; 	private(module)	symbol visible within the current module.<br>&gt; 	private(file)		symbol visible within the current file.<br>&gt; <br>&gt; James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/475752ba/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/475752ba/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Oddball cases:<br></p><p>Global visibility, private settable			public private(set) var foo: String<br>Global visibility, module settable			public private(module set) var foo: String<br>Module visibility, file settable				private(module, file set) var foo: String<br></p><p>of course if module visibility is the default, that might be instead:<br></p><p>Module visibility, file settable				private(file set) var foo: String<br></p><p>-- E<br></p><p>&gt; On Mar 15, 2016, at 2:14 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea of public and then varying degrees of private (with the default being the most private). Public values are published outside of the build target.<br>&gt; <br>&gt; However, I have a question how we would express the concept of mixed property access levels, for instance with a private (to the scope) setter and private (to the module) getter.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 6:49 PM, James Berry via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	private			symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; 	private(module)	symbol visible within the current module.<br>&gt;&gt; 	private(file)		symbol visible within the current file.<br>&gt;&gt; <br>&gt;&gt; James<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/cd2cacad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 15, 2016 at 08:00:00pm</p></header><div class="content"><p>See my email earlier in this thread about how to potentially deal with this<br>leveraging fairly normal syntax we already have to support in swift.<br></p><p>On Tue, Mar 15, 2016 at 1:34 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oddball cases:<br>&gt;<br>&gt; Global visibility, private settable public private(set) var foo: String<br>&gt; Global visibility, module settable public private(module set) var foo:<br>&gt; String<br>&gt; Module visibility, file settable private(module, file set) var foo: String<br>&gt;<br>&gt; of course if module visibility is the default, that might be instead:<br>&gt;<br>&gt; Module visibility, file settable private(file set) var foo: String<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Mar 15, 2016, at 2:14 PM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like the idea of public and then varying degrees of private (with the<br>&gt; default being the most private). Public values are published outside of the<br>&gt; build target.<br>&gt;<br>&gt; However, I have a question how we would express the concept of mixed<br>&gt; property access levels, for instance with a private (to the scope) setter<br>&gt; and private (to the module) getter.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Mar 14, 2016, at 6:49 PM, James Berry via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; private symbol visible within the current declaration (class, extension,<br>&gt; etc).<br>&gt; private(module) symbol visible within the current module.<br>&gt; private(file) symbol visible within the current file.<br>&gt;<br>&gt; James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/3a8a960b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 15, 2016 at 03:00:00pm</p></header><div class="content"><p>I see two results on the gmane search and neither one seems to match what you&#39;re talking about:<br>http://search.gmane.org/?query=Scoped&amp;author=Shawn&amp;group=gmane.comp.lang.swift.evolution&amp;sort=relevance &lt;http://search.gmane.org/?query=Scoped&amp;author=Shawn&amp;group=gmane.comp.lang.swift.evolution&amp;sort=relevance&gt;<br></p><p>Do you have a direct link to the message I should be reading?<br></p><p>Thanks!<br></p><p>-- Erica<br></p><p><br>&gt; On Mar 15, 2016, at 2:42 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; See my email earlier in this thread about how to potentially deal with this leveraging fairly normal syntax we already have to support in swift.<br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 1:34 PM Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Oddball cases:<br>&gt; <br>&gt; Global visibility, private settable			public private(set) var foo: String<br>&gt; Global visibility, module settable			public private(module set) var foo: String<br>&gt; Module visibility, file settable				private(module, file set) var foo: String<br>&gt; <br>&gt; of course if module visibility is the default, that might be instead:<br>&gt; <br>&gt; Module visibility, file settable				private(file set) var foo: String<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 2:14 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the idea of public and then varying degrees of private (with the default being the most private). Public values are published outside of the build target.<br>&gt;&gt; <br>&gt;&gt; However, I have a question how we would express the concept of mixed property access levels, for instance with a private (to the scope) setter and private (to the module) getter.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 6:49 PM, James Berry via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	private			symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; 	private(module)	symbol visible within the current module.<br>&gt;&gt;&gt; 	private(file)		symbol visible within the current file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; James<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/2efd6065/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 15, 2016 at 09:00:00pm</p></header><div class="content"><p>On Tue, Mar 15, 2016 at 2:05 PM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; I see two results on the gmane search and neither one seems to match what<br>&gt; you&#39;re talking about:<br>&gt;<br>&gt; http://search.gmane.org/?query=Scoped&amp;author=Shawn&amp;group=gmane.comp.lang.swift.evolution&amp;sort=relevance<br>&gt;<br>&gt; Do you have a direct link to the message I should be reading?<br>&gt;<br>&gt; Thanks!<br>&gt;<br></p><p>[swift-evolution] SE-0025: Scoped Access Level, next steps<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160314/012640.html&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/dc2bfa30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 3:09 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 2:05 PM Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; I see two results on the gmane search and neither one seems to match what you&#39;re talking about:<br>&gt; http://search.gmane.org/?query=Scoped&amp;author=Shawn&amp;group=gmane.comp.lang.swift.evolution&amp;sort=relevance &lt;http://search.gmane.org/?query=Scoped&amp;author=Shawn&amp;group=gmane.comp.lang.swift.evolution&amp;sort=relevance&gt;<br>&gt; <br>&gt; Do you have a direct link to the message I should be reading?<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; [swift-evolution] SE-0025: Scoped Access Level, next steps &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160314/012640.html&gt; <br></p><p><br>The state of the art is:<br>public private(set) var foo = 0<br>If I&#39;m reading and understanding this correctly, you propose a generally postfix solution like this:<br>public var foo = 0 {  // marks default getter and setter public however...<br>  private set         // marks default setter private<br>}<br>Unless there&#39;s a specific getter or setter implementation, I&#39;m not fond of the<br>postfix declarations. In my opinion `private set` is modifying `public`, not `var foo = 0`<br></p><p>I recognize that in a type rather than a global variable, the modification<br>override could not be adjacent. Another comparison. Current art:<br>public struct bar {<br>    private(set) var gar = 0<br>}<br>vs (what I think is) your suggestion:<br>public struct bar {<br>    var gar = 0 {<br>        private set<br>    }<br>}<br>And again, moving the access control modification to the end just doesn&#39;t look <br>right to me or seem to enhance readability. :(<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/8746b2ef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>March 14, 2016 at 08:00:00pm</p></header><div class="content"><p>+1<br></p><p>I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br></p><p>By Erica’s suggestion about switching…<br></p><p>- public<br>- modular, modulelock, packaged  (module only)<br>- internal (file only)<br>- private<br></p><p>Designer . Developer .  Nerd <br>Jo Albright<br></p><p><br>&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; <br>&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; <br>&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; <br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt; <br>&gt; Some other thoughts on the choice: <br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; <br>&gt; Thoughts appreciated.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/7dd9f1de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 14, 2016 at 09:00:00pm</p></header><div class="content"><p>I, too, prefer it to be more like this:<br></p><p> public  // unchanged<br> module  // currently internal<br> internal  // currently private<br> private  // new hotness<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt; <br>&gt; By Erica’s suggestion about switching…<br>&gt; <br>&gt; - public<br>&gt; - modular, modulelock, packaged  (module only)<br>&gt; - internal (file only)<br>&gt; - private<br>&gt; <br>&gt; Designer . Developer .  Nerd <br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt; <br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt; <br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; <br>&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt; <br>&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt; <br>&gt;&gt; fileprivate<br>&gt;&gt; private(file)<br>&gt;&gt; internal(file)<br>&gt;&gt; fileaccessible<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt; <br>&gt;&gt; Thoughts appreciated.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Although really, why not just use “file” instead of “internal” since it won’t burn any keywords or cause any other conflicts as far as I know.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Mar 14, 2016, at 9:38 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; I, too, prefer it to be more like this:<br>&gt; <br>&gt; public  // unchanged<br>&gt; module  // currently internal<br>&gt; internal  // currently private<br>&gt; private  // new hotness<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt;&gt; <br>&gt;&gt; By Erica’s suggestion about switching…<br>&gt;&gt; <br>&gt;&gt; - public<br>&gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt;&gt; - internal (file only)<br>&gt;&gt; - private<br>&gt;&gt; <br>&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt; private(file)<br>&gt;&gt;&gt; internal(file)<br>&gt;&gt;&gt; fileaccessible<br>&gt;&gt;&gt; etc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Another +1 for James&#39; idea to use private(module), private(file), private:<br>- It avoids ambiguity whether internal/private/local is more restrictive<br>and replaces it with a single axis, public vs. private.<br>- The two longer terms, private(module) and private(file), are the least<br>used ones.<br>- As mentioned by Joe, it admits clean extension to groupings between file<br>and modules in the future (e.g. submodules).<br></p><p>The only question is (as Sean mentioned) how this combines with the syntax<br>for setter access level, e.g. the current private(set). Options:<br>- Unnamed 2nd argument, giving private(file), private(file, set),<br>private(set).<br>- Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>set), private(accessor: set). Less ambiguity but longer.<br>- Not using multiple arguments, but that&#39;d probably break consistency with<br>the other unification efforts going on to make everything look like<br>function calls.<br></p><p><br>On Tue, Mar 15, 2016 at 1:42 PM, Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Although really, why not just use “file” instead of “internal” since it<br>&gt; won’t burn any keywords or cause any other conflicts as far as I know.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Mar 14, 2016, at 9:38 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I, too, prefer it to be more like this:<br>&gt; &gt;<br>&gt; &gt; public  // unchanged<br>&gt; &gt; module  // currently internal<br>&gt; &gt; internal  // currently private<br>&gt; &gt; private  // new hotness<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly,<br>&gt; filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s<br>&gt; filebound &amp; file fixed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; By Erica’s suggestion about switching…<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - public<br>&gt; &gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt; &gt;&gt; - internal (file only)<br>&gt; &gt;&gt; - private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Designer . Developer .  Nerd<br>&gt; &gt;&gt; Jo Albright<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here,<br>&gt; but would like some bikeshedding to happen on the replacement name for<br>&gt; private.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in<br>&gt; other languages, and that many people using private today don’t *want*<br>&gt; visibility out of their current declaration.  It also encourages “extension<br>&gt; oriented programming”, at least it will when some of the other restrictions<br>&gt; on extensions are lifted.  We discussed dropping the third one entirely,<br>&gt; but think it *is* a useful and important level of access control, and<br>&gt; when/if we ever get the ability to write unit tests inside of the file that<br>&gt; defines the functionality, they will be a nicer solution to @testable.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The thing we need to know is what the spelling should be for the third<br>&gt; one.  Off hand, perhaps:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate<br>&gt; &gt;&gt;&gt; private(file)<br>&gt; &gt;&gt;&gt; internal(file)<br>&gt; &gt;&gt;&gt; fileaccessible<br>&gt; &gt;&gt;&gt; etc<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Some other thoughts on the choice:<br>&gt; &gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; &gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt; googlable keyword.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts appreciated.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/fe42a72b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 15, 2016 at 03:00:00am</p></header><div class="content"><p>On Mon, Mar 14, 2016 at 8:36 PM Patrick Pijnappel via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Another +1 for James&#39; idea to use private(module), private(file), private:<br>&gt; - It avoids ambiguity whether internal/private/local is more restrictive<br>&gt; and replaces it with a single axis, public vs. private.<br>&gt;<br></p><p>It seems to just move the ambiguity under private and muddies the<br>traditional meaning of private compared to other languages IMHO.<br></p><p><br>&gt; - The two longer terms, private(module) and private(file), are the least<br>&gt; used ones.<br>&gt;<br></p><p>True-ish except that a large amount of code (at least in swift stdlib) is<br>using `internal` which would be mapped to `private(module)` despite that<br>being the default access level.<br></p><p><br>&gt; - As mentioned by Joe, it admits clean extension to groupings between file<br>&gt; and modules in the future (e.g. submodules).<br>&gt;<br>&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt; for setter access level, e.g. the current private(set). Options:<br>&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt; private(set).<br>&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt; set), private(accessor: set). Less ambiguity but longer.<br>&gt;<br></p><p>The questions to me is what if I want the setter to be private to file or<br>module scopes while the getter has a different level of visibility?<br></p><p><br>&gt; On Tue, Mar 15, 2016 at 1:42 PM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Although really, why not just use “file” instead of “internal” since it<br>&gt;&gt; won’t burn any keywords or cause any other conflicts as far as I know.<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 14, 2016, at 9:38 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I, too, prefer it to be more like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public  // unchanged<br>&gt;&gt; &gt; module  // currently internal<br>&gt;&gt; &gt; internal  // currently private<br>&gt;&gt; &gt; private  // new hotness<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; l8r<br>&gt;&gt; &gt; Sean<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly,<br>&gt;&gt; filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s<br>&gt;&gt; filebound &amp; file fixed.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; By Erica’s suggestion about switching…<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - public<br>&gt;&gt; &gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt;&gt; &gt;&gt; - internal (file only)<br>&gt;&gt; &gt;&gt; - private<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Designer . Developer .  Nerd<br>&gt;&gt; &gt;&gt; Jo Albright<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here,<br>&gt;&gt; but would like some bikeshedding to happen on the replacement name for<br>&gt;&gt; private.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; &gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; &gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; &gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt;&gt; extension, etc).<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in<br>&gt;&gt; other languages, and that many people using private today don’t *want*<br>&gt;&gt; visibility out of their current declaration.  It also encourages “extension<br>&gt;&gt; oriented programming”, at least it will when some of the other restrictions<br>&gt;&gt; on extensions are lifted.  We discussed dropping the third one entirely,<br>&gt;&gt; but think it *is* a useful and important level of access control, and<br>&gt;&gt; when/if we ever get the ability to write unit tests inside of the file that<br>&gt;&gt; defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; The thing we need to know is what the spelling should be for the<br>&gt;&gt; third one.  Off hand, perhaps:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; fileprivate<br>&gt;&gt; &gt;&gt;&gt; private(file)<br>&gt;&gt; &gt;&gt;&gt; internal(file)<br>&gt;&gt; &gt;&gt;&gt; fileaccessible<br>&gt;&gt; &gt;&gt;&gt; etc<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Some other thoughts on the choice:<br>&gt;&gt; &gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a<br>&gt;&gt; keyword.<br>&gt;&gt; &gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt;&gt; googlable keyword.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Thoughts appreciated.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -Chris<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/a8f128b2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another +1 for James&#39; idea to use private(module), private(file), private:<br>&gt; - It avoids ambiguity whether internal/private/local is more restrictive and replaces it with a single axis, public vs. private.<br>&gt; - The two longer terms, private(module) and private(file), are the least used ones.<br>&gt; - As mentioned by Joe, it admits clean extension to groupings between file and modules in the future (e.g. submodules).<br>&gt; <br>&gt; The only question is (as Sean mentioned) how this combines with the syntax for setter access level, e.g. the current private(set). Options:<br>&gt; - Unnamed 2nd argument, giving private(file), private(file, set), private(set).<br></p><p>We could conceivably reskin private(set) too. A lot of people complain it&#39;s &quot;weird&quot; as-is, for better or worse.<br></p><p>-Joe<br></p><p>&gt; - Named 2nd argument, giving e.g. private(file), private(file, accessor: set), private(accessor: set). Less ambiguity but longer.<br>&gt; - Not using multiple arguments, but that&#39;d probably break consistency with the other unification efforts going on to make everything look like function calls.<br>&gt; <br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 1:42 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Although really, why not just use “file” instead of “internal” since it won’t burn any keywords or cause any other conflicts as far as I know.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Mar 14, 2016, at 9:38 PM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I, too, prefer it to be more like this:<br>&gt; &gt;<br>&gt; &gt; public  // unchanged<br>&gt; &gt; module  // currently internal<br>&gt; &gt; internal  // currently private<br>&gt; &gt; private  // new hotness<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; By Erica’s suggestion about switching…<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - public<br>&gt; &gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt; &gt;&gt; - internal (file only)<br>&gt; &gt;&gt; - private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Designer . Developer .  Nerd<br>&gt; &gt;&gt; Jo Albright<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate<br>&gt; &gt;&gt;&gt; private(file)<br>&gt; &gt;&gt;&gt; internal(file)<br>&gt; &gt;&gt;&gt; fileaccessible<br>&gt; &gt;&gt;&gt; etc<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Some other thoughts on the choice:<br>&gt; &gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; &gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts appreciated.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/4168954f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 14, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 8:51 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another +1 for James&#39; idea to use private(module), private(file), private:<br>&gt;&gt; - It avoids ambiguity whether internal/private/local is more restrictive and replaces it with a single axis, public vs. private.<br>&gt;&gt; - The two longer terms, private(module) and private(file), are the least used ones.<br>&gt;&gt; - As mentioned by Joe, it admits clean extension to groupings between file and modules in the future (e.g. submodules).<br>&gt;&gt; <br>&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax for setter access level, e.g. the current private(set). Options:<br>&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set), private(set).<br>&gt; <br>&gt; We could conceivably reskin private(set) too. A lot of people complain it&#39;s &quot;weird&quot; as-is, for better or worse.<br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>That’s because it is weird :)<br></p><p>I always thought the computed form should be:<br></p><p>public var whatever: String {<br>    get { … }<br>    // override overall visibility to restrict setter<br>    private set { … }<br>}<br></p><p><br>For this proposal you could do something like:<br></p><p>var private set whatever: String = &quot;&quot;<br></p><p><br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/f7610e6e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 15, 2016 at 08:00:00am</p></header><div class="content"><p>How about:<br></p><p>var whatever: String {<br>    private(file) set // default implementation<br>}<br></p><p>And<br></p><p>var whatever: String {<br>    private set {<br>        return &quot;custom&quot;<br>    }<br>}<br></p><p>&gt; On 15 Mar 2016, at 05:12, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:51 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another +1 for James&#39; idea to use private(module), private(file), private:<br>&gt;&gt;&gt; - It avoids ambiguity whether internal/private/local is more restrictive and replaces it with a single axis, public vs. private.<br>&gt;&gt;&gt; - The two longer terms, private(module) and private(file), are the least used ones.<br>&gt;&gt;&gt; - As mentioned by Joe, it admits clean extension to groupings between file and modules in the future (e.g. submodules).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set), private(set).<br>&gt;&gt; <br>&gt;&gt; We could conceivably reskin private(set) too. A lot of people complain it&#39;s &quot;weird&quot; as-is, for better or worse.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; That’s because it is weird :)<br>&gt; <br>&gt; I always thought the computed form should be:<br>&gt; <br>&gt; public var whatever: String {<br>&gt;     get { … }<br>&gt;     // override overall visibility to restrict setter<br>&gt;     private set { … }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; For this proposal you could do something like:<br>&gt; <br>&gt; var private set whatever: String = &quot;&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/a412f3f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 15, 2016 at 08:00:00am</p></header><div class="content"><p>Oops, Shawn Ericsson already said it better than me :)<br></p><p>Sent from my iPhone<br></p><p>&gt; On 15 Mar 2016, at 08:38, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt; var whatever: String {<br>&gt;     private(file) set // default implementation<br>&gt; }<br>&gt; <br>&gt; And<br>&gt; <br>&gt; var whatever: String {<br>&gt;     private set {<br>&gt;         return &quot;custom&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt;&gt; On 15 Mar 2016, at 05:12, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:51 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another +1 for James&#39; idea to use private(module), private(file), private:<br>&gt;&gt;&gt;&gt; - It avoids ambiguity whether internal/private/local is more restrictive and replaces it with a single axis, public vs. private.<br>&gt;&gt;&gt;&gt; - The two longer terms, private(module) and private(file), are the least used ones.<br>&gt;&gt;&gt;&gt; - As mentioned by Joe, it admits clean extension to groupings between file and modules in the future (e.g. submodules).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only question is (as Sean mentioned) how this combines with the syntax for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;&gt; - Unnamed 2nd argument, giving private(file), private(file, set), private(set).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could conceivably reskin private(set) too. A lot of people complain it&#39;s &quot;weird&quot; as-is, for better or worse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; That’s because it is weird :)<br>&gt;&gt; <br>&gt;&gt; I always thought the computed form should be:<br>&gt;&gt; <br>&gt;&gt; public var whatever: String {<br>&gt;&gt;     get { … }<br>&gt;&gt;     // override overall visibility to restrict setter<br>&gt;&gt;     private set { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; For this proposal you could do something like:<br>&gt;&gt; <br>&gt;&gt; var private set whatever: String = &quot;&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/45ae5f8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>March 15, 2016 at 09:00:00am</p></header><div class="content"><p>Hi,<br>i think the current idea of adding additional specifier is wrong<br>answer to original question/problem.<br>The original problem was how to ensure that particular type is the<br>only one in a given file. (making private effectively scoped private<br>for that type).<br></p><p>Solution should be to mark the whole structure/file as only for one<br>type, instead of inventing yet another keyword to be used in all<br>placed. (Will we have &quot;protected&quot; too in future?).<br></p><p>O.<br></p><p>On Tue, Mar 15, 2016 at 8:40 AM, David Hart via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Oops, Shawn Ericsson already said it better than me :)<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 15 Mar 2016, at 08:38, David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; How about:<br>&gt;<br>&gt; var whatever: String {<br>&gt;     private(file) set // default implementation<br>&gt; }<br>&gt;<br>&gt; And<br>&gt;<br>&gt; var whatever: String {<br>&gt;     private set {<br>&gt;         return &quot;custom&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; On 15 Mar 2016, at 05:12, Russ Bishop via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 14, 2016, at 8:51 PM, Joe Groff via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Another +1 for James&#39; idea to use private(module), private(file), private:<br>&gt; - It avoids ambiguity whether internal/private/local is more restrictive and<br>&gt; replaces it with a single axis, public vs. private.<br>&gt; - The two longer terms, private(module) and private(file), are the least<br>&gt; used ones.<br>&gt; - As mentioned by Joe, it admits clean extension to groupings between file<br>&gt; and modules in the future (e.g. submodules).<br>&gt;<br>&gt; The only question is (as Sean mentioned) how this combines with the syntax<br>&gt; for setter access level, e.g. the current private(set). Options:<br>&gt; - Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt; private(set).<br>&gt;<br>&gt;<br>&gt; We could conceivably reskin private(set) too. A lot of people complain it&#39;s<br>&gt; &quot;weird&quot; as-is, for better or worse.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; That’s because it is weird :)<br>&gt;<br>&gt; I always thought the computed form should be:<br>&gt;<br>&gt; public var whatever: String {<br>&gt;     get { … }<br>&gt;     // override overall visibility to restrict setter<br>&gt;     private set { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; For this proposal you could do something like:<br>&gt;<br>&gt; var private set whatever: String = &quot;&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 9:42 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Although really, why not just use “file” instead of “internal” since it won’t burn any keywords or cause any other conflicts as far as I know.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>IMHO, “file” is a reasonable variable name. Although if you’re talking about ‘private(file)’ rather than just ‘file’, that might not be a problem.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 10:41 PM, davesweeris at mac.com wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 9:42 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Although really, why not just use “file” instead of “internal” since it won’t burn any keywords or cause any other conflicts as far as I know.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt; IMHO, “file” is a reasonable variable name. Although if you’re talking about ‘private(file)’ rather than just ‘file’, that might not be a problem.<br>&gt; <br>&gt; - Dave Sweeris<br></p><p>I don&#39;t believe that&#39;s an issue here because this label exists only in a places where variable and function names cannot.<br></p><p>l8r<br>Sean<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 15, 2016 at 08:00:00am</p></header><div class="content"><p>I think swapping internal is dangerous because some languages already use internal to represent a module scope (C# for example).<br></p><p>I&#39;m also quite a fan of:<br></p><p>private(module)<br>private(file)<br>private<br></p><p>But then Im not sure how we would modify property setters:<br></p><p>private(file)(set) ??<br></p><p>Sent from my iPhone<br>&gt; On 15 Mar 2016, at 03:38, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I, too, prefer it to be more like this:<br>&gt; <br>&gt; public  // unchanged<br>&gt; module  // currently internal<br>&gt; internal  // currently private<br>&gt; private  // new hotness<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt;&gt; <br>&gt;&gt; By Erica’s suggestion about switching…<br>&gt;&gt; <br>&gt;&gt; - public<br>&gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt;&gt; - internal (file only)<br>&gt;&gt; - private<br>&gt;&gt; <br>&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt; private(file)<br>&gt;&gt;&gt; internal(file)<br>&gt;&gt;&gt; fileaccessible<br>&gt;&gt;&gt; etc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>March 15, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;m in favor of this too. Parameterizing the private syntax is nice, but<br>it introduces complications elsewhere. We should come up with a new<br>word, `module` seems good to me.<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p><p>On Mon, Mar 14, 2016, at 10:38 PM, Sean Heber via swift-evolution wrote:<br>&gt; I, too, prefer it to be more like this:<br>&gt; <br>&gt;  public  // unchanged<br>&gt;  module  // currently internal<br>&gt;  internal  // currently private<br>&gt;  private  // new hotness<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; +1<br>&gt; &gt; <br>&gt; &gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt; &gt; <br>&gt; &gt; By Erica’s suggestion about switching…<br>&gt; &gt; <br>&gt; &gt; - public<br>&gt; &gt; - modular, modulelock, packaged  (module only)<br>&gt; &gt; - internal (file only)<br>&gt; &gt; - private<br>&gt; &gt; <br>&gt; &gt; Designer . Developer .  Nerd <br>&gt; &gt; Jo Albright<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; To summarize the place we’d like to end up:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; fileprivate<br>&gt; &gt;&gt; private(file)<br>&gt; &gt;&gt; internal(file)<br>&gt; &gt;&gt; fileaccessible<br>&gt; &gt;&gt; etc<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Some other thoughts on the choice: <br>&gt; &gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; &gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Thoughts appreciated.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 7:38 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I, too, prefer it to be more like this:<br>&gt; <br>&gt; public  // unchanged<br>&gt; module  // currently internal<br>&gt; internal  // currently private<br>&gt; private  // new hotness<br></p><p>I like these best out of what’s been suggested so far. I agree with those that think the parameterized versions are too long and unnecessary.<br></p><p>—CK <br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt;&gt; <br>&gt;&gt; By Erica’s suggestion about switching…<br>&gt;&gt; <br>&gt;&gt; - public<br>&gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt;&gt; - internal (file only)<br>&gt;&gt; - private<br>&gt;&gt; <br>&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt; private(file)<br>&gt;&gt;&gt; internal(file)<br>&gt;&gt;&gt; fileaccessible<br>&gt;&gt;&gt; etc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>March 15, 2016 at 07:00:00pm</p></header><div class="content"><p>Generally I’m in favor of dropping “internal” as being somewhat vague, and moving forward with module and fileprivate.<br></p><p>public<br>module<br>fileprivate (also google friendly)<br>private<br></p><p>&gt; On Mar 15, 2016, at 5:32 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 14, 2016, at 7:38 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I, too, prefer it to be more like this:<br>&gt;&gt; <br>&gt;&gt; public  // unchanged<br>&gt;&gt; module  // currently internal<br>&gt;&gt; internal  // currently private<br>&gt;&gt; private  // new hotness<br>&gt; <br>&gt; I like these best out of what’s been suggested so far. I agree with those that think the parameterized versions are too long and unnecessary.<br>&gt; <br>&gt; —CK <br>&gt; <br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By Erica’s suggestion about switching…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - public<br>&gt;&gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt;&gt;&gt; - internal (file only)<br>&gt;&gt;&gt; - private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt;&gt; Jo Albright<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt;&gt; private(file)<br>&gt;&gt;&gt;&gt; internal(file)<br>&gt;&gt;&gt;&gt; fileaccessible<br>&gt;&gt;&gt;&gt; etc<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts appreciated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/a960bdf7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>March 16, 2016 at 12:00:00pm</p></header><div class="content"><p>On Tue, Mar 15, 2016 at 10:32 AM, Charles Kissinger via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 14, 2016, at 7:38 PM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I, too, prefer it to be more like this:<br>&gt; &gt;<br>&gt; &gt; public  // unchanged<br>&gt; &gt; module  // currently internal<br>&gt; &gt; internal  // currently private<br>&gt; &gt; private  // new hotness<br>&gt;<br>&gt; I like these best out of what’s been suggested so far. I agree with those<br>&gt; that think the parameterized versions are too long and unnecessary.<br>&gt;<br>&gt;<br>&gt;<br>+1 to this as well.  &quot;file&quot; is fine instead of &quot;internal&quot; as well.  I don&#39;t<br>like the parameterized versions private(file) and private(module) because<br>they can get very verbose (I find I use file access all the time), and<br>because of the already-mentioned concerns about stacking with the<br>private(set) convention.<br></p><p><br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly,<br>&gt; filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s<br>&gt; filebound &amp; file fixed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; By Erica’s suggestion about switching…<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - public<br>&gt; &gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt; &gt;&gt; - internal (file only)<br>&gt; &gt;&gt; - private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Designer . Developer .  Nerd<br>&gt; &gt;&gt; Jo Albright<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here,<br>&gt; but would like some bikeshedding to happen on the replacement name for<br>&gt; private.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in<br>&gt; other languages, and that many people using private today don’t *want*<br>&gt; visibility out of their current declaration.  It also encourages “extension<br>&gt; oriented programming”, at least it will when some of the other restrictions<br>&gt; on extensions are lifted.  We discussed dropping the third one entirely,<br>&gt; but think it *is* a useful and important level of access control, and<br>&gt; when/if we ever get the ability to write unit tests inside of the file that<br>&gt; defines the functionality, they will be a nicer solution to @testable.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The thing we need to know is what the spelling should be for the third<br>&gt; one.  Off hand, perhaps:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate<br>&gt; &gt;&gt;&gt; private(file)<br>&gt; &gt;&gt;&gt; internal(file)<br>&gt; &gt;&gt;&gt; fileaccessible<br>&gt; &gt;&gt;&gt; etc<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Some other thoughts on the choice:<br>&gt; &gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; &gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt; googlable keyword.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts appreciated.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/03cd4ff2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 26, 2016 at 10:00:00am</p></header><div class="content"><p>+1 for this. The only reason I was thinking &#39;external&#39; was because &#39;module&#39; seems to clash with the identity of the actual module but i am for the order and introducing a new word for module access. <br></p><p><br>&gt; On Mar 14, 2016, at 7:38 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I, too, prefer it to be more like this:<br>&gt; <br>&gt; public  // unchanged<br>&gt; module  // currently internal<br>&gt; internal  // currently private<br>&gt; private  // new hotness<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 7:50 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I like this a lot. Name ideas : enclosed, filelocal, fileonly, filelock, fileaccess, fileprivate, insidefile, inner. I also like Erica’s filebound &amp; file fixed.<br>&gt;&gt; <br>&gt;&gt; By Erica’s suggestion about switching…<br>&gt;&gt; <br>&gt;&gt; - public<br>&gt;&gt; - modular, modulelock, packaged  (module only)<br>&gt;&gt; - internal (file only)<br>&gt;&gt; - private<br>&gt;&gt; <br>&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 8:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt; private(file)<br>&gt;&gt;&gt; internal(file)<br>&gt;&gt;&gt; fileaccessible<br>&gt;&gt;&gt; etc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some other thoughts on the choice: <br>&gt;&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 15, 2016 at 04:00:00am</p></header><div class="content"><p>On Mon, Mar 14, 2016 at 5:18 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;<br>&gt; To summarize the place we’d like to end up:<br>&gt;<br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt;<br></p><p>More thinking out loud...<br></p><p>`public` -&gt; exported from module<br>&lt;omitted&gt; -&gt; module scoped (e.g. current internal)<br>`private` -&gt; class, struct, etc. scoped (e.g. new private)<br>`private(file)` or `file` -&gt; file scoped (e.g existing private)<br>`private(module)` or `module` or `internal` -&gt; module scoped (e.g. current<br>internal)<br></p><p>public var foo = 0 // marks default getter and setter public<br></p><p>public var foo = 0 {  // marks default getter and setter public however...<br>  private set         // marks default setter private<br>}<br></p><p>var foo = 0 { // marks default getter and setter module scoped however...<br>  public get  // marks default getter public<br>  private set // marks default setter private<br>}<br></p><p>public var foo: Int { ... } // marks provided getter public, read-only<br></p><p>var foo: Int {        // marks provided getter and setter module scoped<br>however...<br>  public get { ... }  // marks provided getter public<br>  private set { ... } // marks provided setter private<br>}<br></p><p>public var foo: Int { // marks provided getter and setter public however...<br>  get { ... }         // not specified, inherit access level public<br>  private set { ... } // marks provided setter private<br>}<br></p><p>var foo: Int {        // marks provided getter and setter module scoped<br>however...<br>  get { ... }         // not specified, inherit access level module scoped<br>  private set { ... } // marks provided setter private<br>}<br></p><p>private(module) var foo: Int { // marks provided getter and setter module<br>scoped however...<br>  get { ... }                 // not specified, inherit access level module<br>scoped<br>  private(file) set { ... }   // marks provided setter file scoped<br>}<br></p><p>var foo: Int {                // marks provided getter and setter module<br>scoped however...<br>  private(file) get { ... }   // not specified, inherit access level module<br>scoped<br>  private set { ... }         // marks provided setter file scoped<br>}<br></p><p>...etc...<br></p><p>public subscript(index: Int) -&gt; Int { ... } // marks provided getter<br>public, read-only<br></p><p>public subscript(index: Int) -&gt; Int { // marks provided getter and setter<br>public<br>  get { ... }                         // not specified, inherit access<br>level public<br>  set { ... }                         // not specified, inherit access<br>level public<br>}<br></p><p>public subscript(index: Int) -&gt; Int { // marks provided getter and setter<br>public however...<br>  get { ... }                         // not specified, inherit access<br>level public<br>  private set { ... }                 // marks provided setter private<br>}<br></p><p>subscript(index: Int) -&gt; Int {  // marks provided getter and setter module<br>scoped however...<br>  get { ... }                   // not specified, inherit access level<br>module scoped<br>  private set { ... }           // marks provided setter private<br>}<br></p><p>subscript(index: Int) -&gt; Int {  // marks provided getter and setter module<br>scoped however...<br>  public get { ... }            // marks provided getter public<br>  private set { ... }           // marks provided setter private<br>}<br></p><p>subscript(index: Int) -&gt; Int {  // marks provided getter and setter module<br>scoped however...<br>  public get { ... }            // marks provided getter public<br>  private(file) set { ... }     // marks provided setter file scoped<br>}<br>...etc...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/8682bf77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 15, 2016 at 10:00:00am</p></header><div class="content"><p>I agree that the current &quot;private&quot; is useful, and would rather keep everything as-is than remove this scope.<br>I&#39;m neutral on adding a new access level, but don&#39;t like the &quot;private(file)&quot;-syntax:<br>The issues with properties could be solved (my preference would be &quot;private &lt;file&gt; (set) var x: Int&quot;), but imho all access levels should be specified in the same way (that would put me in the &quot;local&quot; camp).<br></p><p>If the access model is changed, i vote for a broad discussion about the topic as whole to minimize breaking changes (for example, it would be nice to have an elegant way to express that a method can be overridden by a subclass, but not be called).<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 15, 2016 at 09:00:00am</p></header><div class="content"><p>I agree with you Tino that we should not stop here, but I would break it down in smaller proposals that had the biggest breakage in the language but still could all fit into Swift 3. It is one of the last chances of being allowed to break source and ABI compatibility and we ought to make it count IMHO.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 15 Mar 2016, at 09:45, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that the current &quot;private&quot; is useful, and would rather keep everything as-is than remove this scope.<br>&gt; I&#39;m neutral on adding a new access level, but don&#39;t like the &quot;private(file)&quot;-syntax:<br>&gt; The issues with properties could be solved (my preference would be &quot;private &lt;file&gt; (set) var x: Int&quot;), but imho all access levels should be specified in the same way (that would put me in the &quot;local&quot; camp).<br>&gt; <br>&gt; If the access model is changed, i vote for a broad discussion about the topic as whole to minimize breaking changes (for example, it would be nice to have an elegant way to express that a method can be overridden by a subclass, but not be called).<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>March 15, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br></p><p>domestic?<br></p><p>I&#39;m not too thrilled to see the list extend to four words though. The more visibility levels we have between public and private the more subtle the difference and meaningless the choice of word. So I think I&#39;ll fall in the camp of private(file)`.<br></p><p>Speaking of meaning though, there&#39;s one thing bothering me about altering the meaning of `private` to mean what `local` meant in the Scoped Access Level proposal. <br></p><p>The new `private` keyword will sometime mean file-private and sometime mean declaration-private depending on where it is. That&#39;s because file-private and declaration-private are the same thing for elements not part of a declaration. With the `local` keyword, I&#39;d have expected the compiler to emit an error for this declaration found at the root of a file:<br></p><p>	local class A {} // error: use `private` at file scope<br></p><p>thus, restricting `local` to where it actually had an effect: inside declarations. It&#39;s useful when seeing `local` to know that this symbol will not be accessible everywhere in the file. <br></p><p>But does this same restriction makes sense for `private`? I think not. And that will make the `private` attribute have the same meaning as `private(file)` when at the root of the file. I&#39;m thus privileging `private(file)` because it makes sense for the compiler to do this:<br></p><p>	private(file) class A {} // error: use `private` at file scope<br></p><p>whereas using a different keyword would make things look messy. Note that I&#39;m reversing the error here: the compiler wants `private` (the old `local`) to be used at file scope, and `private(file)` would be reserved for use inside declarations.<br></p><p>Put simply: whatever the keyword we end up with, oftentimes it&#39;ll have the same meaning as `private` and the compiler will have to force your hand with one or the other. In my opinion the old approach with the `local` keyword was cleaner because there was no overloaded meaning.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>March 15, 2016 at 12:00:00pm</p></header><div class="content"><p>I am really not in favor of the parametrized access keywords.<br></p><p>To me, private(module) and private(file) seem redundant. Module already implies it is restricted to the module, and file already implies it is restricted to the file so the private keyword just seems unnecessary in my opinion.<br></p><p>“unknown” could just be local or file<br>“internal” really should become “module” or “modular” for clarity reasons<br></p><p><br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt; <br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 16, 2016 at 06:00:00am</p></header><div class="content"><p>Bikeshedding!<br></p><p>I would suggest three things:<br>Make the access modifies annotations, i.e. they are spelt with an @ and use lower-camel case (which I think was the result of a previous Swift Evolution proposal, otherwise what ever was agreed for annotations)<br>Move them to the end of the declaration because they clutter the declaration at present, e.g. struct Foo: Bar @public { … }<br>Names:<br>@public<br>@module<br>@file<br>@private<br></p><p>Cheers,<br></p><p> — Howard.<br></p><p>&gt; On 15 Mar 2016, at 8:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; <br>&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; <br>&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; <br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt; <br>&gt; Some other thoughts on the choice: <br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; <br>&gt; Thoughts appreciated.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/fa20d447/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March 15, 2016 at 11:00:00pm</p></header><div class="content"><p>Just wondering, wouldn&#39;t private be enougth for a class level declaration ?<br></p><p>Not sure why we need a file baed one.<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Tue, Mar 15, 2016 at 12:18 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;<br>&gt; To summarize the place we’d like to end up:<br>&gt;<br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt;<br>&gt; The rationale here is that this aligns Swift with common art seen in other<br>&gt; languages, and that many people using private today don’t *want* visibility<br>&gt; out of their current declaration.  It also encourages “extension oriented<br>&gt; programming”, at least it will when some of the other restrictions on<br>&gt; extensions are lifted.  We discussed dropping the third one entirely, but<br>&gt; think it *is* a useful and important level of access control, and when/if<br>&gt; we ever get the ability to write unit tests inside of the file that defines<br>&gt; the functionality, they will be a nicer solution to @testable.<br>&gt;<br>&gt; The thing we need to know is what the spelling should be for the third<br>&gt; one.  Off hand, perhaps:<br>&gt;<br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt;<br>&gt; Some other thoughts on the choice:<br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt; googlable keyword.<br>&gt;<br>&gt; Thoughts appreciated.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/6b01cedc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 15, 2016 at 11:00:00pm</p></header><div class="content"><p>I think in the referenced example the new private would mean “class and extensions”, with file being the new private, which I think is confusing.<br></p><p>My preference would be:<br></p><p>public<br>module (currently internal)<br>protected (class and extensions)<br>private <br></p><p>protected is widely used to mean this in other languages and fits well semantically between public and private. The other alternative could be just to re-use the class and struct keys; i.e- a “class” accessible property means the class, its descendants and its extensions know about it, with struct being the same for structs (in which case it’s just extensions, so the distinction might be nice for clarity). Alternatively we could re-use the extension keyword, to indicate that the property/method is available to extensions (including sub-classes).<br></p><p>&gt; On 15 Mar 2016, at 23:40, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just wondering, wouldn&#39;t private be enougth for a class level declaration ?<br>&gt; <br>&gt; Not sure why we need a file baed one.<br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head of Trolls<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; <br>&gt; On Tue, Mar 15, 2016 at 12:18 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; <br>&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to @testable.<br>&gt; <br>&gt; The thing we need to know is what the spelling should be for the third one.  Off hand, perhaps:<br>&gt; <br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt; <br>&gt; Some other thoughts on the choice:<br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a googlable keyword.<br>&gt; <br>&gt; Thoughts appreciated.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/ad2b389e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>Just had an idea for a different approach for access levels (as if things aren&#39;t complicated enough ;-) - but I&#39;m only brainstorming here):<br>The problem of access levels isn&#39;t limited to programming — file systems have to deal with it as well.<br>So, ignoring ACLs for a moment, imagine<br></p><p>protected x: Int<br>protected(set) public y: Int<br></p><p>would be expressed as<br></p><p>module(read, write) x: Int<br>public(read) y: Int<br></p><p>As far as I can see, this syntax is less convenient, but could allow things like &quot;public(override)&quot; to express that a method can&#39;t be called outside the module, but still can be overridden by subclasses.<br>Any thoughts on this?<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br></p><p>I think moving `private` to this new access control level because it&#39;s the most private one we currently have sets a bad precedent. If we add a fifth level in Swift 4 (say, one that hides the member from nested types), does that now become `private` and we need to come up with a new name for the fourth level? Will users ever be able to get used to what the keywords actually mean?<br></p><p>Rather than use relative terms, let&#39;s use absolute ones. An extreme, imperfect example of what I mean:<br></p><p>* exported<br>* module<br>* file<br>* scope<br></p><p>Then if we add other access levels in the future, we don&#39;t have to worry about reshuffling the existing names, because they will all still be correct. We just have to come up with a good name for the new one.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 17, 2016 at 02:00:00am</p></header><div class="content"><p>The access level discussed in the proposal already hides the members from<br>nested types. The goal is to make something completely hidden outside of<br>the scope. (otherwise, it would be possible to get access to something by<br>simply inserting a nested class and without modifying the original class or<br>extension definition). We discussed it during the review. So it is already<br>the most private, and the name matches the meaning.<br></p><p>One of the goals of the core team in the response was to preserve the terms<br>of art. In that sense, public and private make the most sense, the other<br>two (internal and what today is called private) are not universal.<br></p><p>&gt; think moving `private` to this new access control level because it&#39;s the<br>most private one we currently have sets a bad precedent. If we add a fifth<br>level in Swift 4 (say, one that hides the member from nested types), does<br>that now become `private` and we need to come up with a new name for the<br>fourth level? Will users ever be able to get used to what the keywords<br>actually mean?<br></p><p>On Wed, Mar 16, 2016 at 7:01 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt; &gt;<br>&gt; &gt; To summarize the place we’d like to end up:<br>&gt; &gt;<br>&gt; &gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; &gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; &gt; - unknown -&gt; symbol visible within the current file.<br>&gt; &gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt;<br>&gt; I think moving `private` to this new access control level because it&#39;s the<br>&gt; most private one we currently have sets a bad precedent. If we add a fifth<br>&gt; level in Swift 4 (say, one that hides the member from nested types), does<br>&gt; that now become `private` and we need to come up with a new name for the<br>&gt; fourth level? Will users ever be able to get used to what the keywords<br>&gt; actually mean?<br>&gt;<br>&gt; Rather than use relative terms, let&#39;s use absolute ones. An extreme,<br>&gt; imperfect example of what I mean:<br>&gt;<br>&gt; * exported<br>&gt; * module<br>&gt; * file<br>&gt; * scope<br>&gt;<br>&gt; Then if we add other access levels in the future, we don&#39;t have to worry<br>&gt; about reshuffling the existing names, because they will all still be<br>&gt; correct. We just have to come up with a good name for the new one.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160317/ec044ebb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 19:02 , Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The access level discussed in the proposal already hides the members from nested types.<br></p><p>Really? In the following code, the nested type and the local method are definitely in the same lexical scope by my understanding of &quot;lexical scope&quot;:<br></p><p>struct Foo {<br>local static func foo() {}<br>struct Nested {<br>	init() {<br>		Foo.foo()<br>	}<br>}<br>}<br></p><p>I guess this is something else that would need to be clarified if/when the proposal returns to review.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/d371dc5d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&lt;responding to several posts in this thread at once&gt;<br></p><p>On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br></p><p>What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br></p><p>Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br></p><p>I’ve seen several proposals that seem promising:<br></p><p>On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt; <br>&gt; 	private			symbol visible within the current declaration (class, extension, etc).<br>&gt; 	private(module)	symbol visible within the current module.<br>&gt; 	private(file)		symbol visible within the current file.<br></p><p>I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br></p><p>On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; public<br>&gt; private-module<br>&gt; private-file<br>&gt; private<br></p><p>This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br></p><p>How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br></p><p>	public<br>	moduleprivate<br>	fileprivate<br>	private<br></p><p>The advantages, as I see them are:<br>1) We keep public and private meaning the “right” and “obvious” things.<br>2) The declmodifiers “read” correctly.<br>3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>4) The unusual ones would be “googable”.<br>5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br></p><p>What do you all think?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March 24, 2016 at 02:00:00am</p></header><div class="content"><p>I like it. Searchable and clear.<br></p><p>&gt;<br>&gt;         public<br>&gt;         moduleprivate<br>&gt;         fileprivate<br>&gt;         private<br>&gt;<br>&gt; …<br>&gt; What do you all think?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/8fcba34e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 24, 2016 at 08:00:00am</p></header><div class="content"><p>I like it very much.<br></p><p>&gt; On 24 Mar 2016, at 06:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/90eb265f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 24, 2016 at 07:00:00am</p></header><div class="content"><p>Agreed, seems like a good way to go.<br></p><p>[[iOS messageWithContent:webContent] broadcast]<br></p><p>&gt; On 24 Mar 2016, at 07:04, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like it very much.<br>&gt; <br>&gt;&gt; On 24 Mar 2016, at 06:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt; 	public<br>&gt;&gt; 	moduleprivate<br>&gt;&gt; 	fileprivate<br>&gt;&gt; 	private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt; <br>&gt;&gt; What do you all think?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/653de206/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>It&#39;s very consistent with other keywords. I wish compound keywords were<br>joined with a dash or something that made them easier to read, but I guess<br>it&#39;s too late now. If we have associatedtype, it makes sense to use<br>moduleprivate (I saw that the name associatedtype was discussed extensively<br>but didn&#39;t participate in the discussion; I am sure that it was given a lot<br>of thought). If we could change this, I&#39;d suggest keyword names with dashes<br>everywhere, but if not, these names work well and is a great compromise for<br>everything I&#39;ve seen in this thread.<br></p><p>I am not worried about the length because the 2 most frequently written<br>keywords would be public and private. Moduleprivate is the default, and<br>file private will not be used as often as private.<br></p><p>One question: should the proposal be explicit about access control for<br>nested classes? We discussed it here briefly (I wanted private to be<br>completely private to the class or extension itself while 2 other people<br>wanted a nested class to have access to the outer class.)<br></p><p>On Thu, Mar 24, 2016 at 1:13 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;<br>&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;<br>&gt; What we do with private setters is orthogonal from this proposal, so I’m<br>&gt; going to ignore it in this thread.  After SE-0025 is resolved, it would be<br>&gt; great to have another thread/proposal that discusses reskinning<br>&gt; private(set) - presumably as just a modifier on the setter.<br>&gt;<br>&gt; Similarly, this proposal has nothing to do with “protected” or any other<br>&gt; type based access control, so I don’t delve into that at all either.<br>&gt;<br>&gt; I’ve seen several proposals that seem promising:<br>&gt;<br>&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt; &gt; I like fileprivate, if that’s the only change. On the other hand, if we<br>&gt; want to consider a broader change, what about:<br>&gt; &gt;<br>&gt; &gt;       private                 symbol visible within the current<br>&gt; declaration (class, extension, etc).<br>&gt; &gt;       private(module) symbol visible within the current module.<br>&gt; &gt;       private(file)           symbol visible within the current file.<br>&gt;<br>&gt; I love how this establishes a family with different levels of access<br>&gt; control, and unites them under the idea of &quot;levels of being private”.  I<br>&gt; also like how people would commonly only ever write public and private<br>&gt; (because “private(module)” is the default, and &quot;private(file)&quot; is<br>&gt; obscure).  However, parenthesized modifiers that take a keyword (as opposed<br>&gt; to an identifier) are a bit weird and awkward, so it would be nice to avoid<br>&gt; them if possible.<br>&gt;<br>&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; public<br>&gt; &gt; private-module<br>&gt; &gt; private-file<br>&gt; &gt; private<br>&gt;<br>&gt; This follows the same sort of structure as James’ proposal, without the<br>&gt; parens.  It has the same advantages, but trades them with hyphenated decl<br>&gt; modifiers.  We don’t do that, but it is a good direction.<br>&gt;<br>&gt; How about we continue this trend, and follow other existing Swift keywords<br>&gt; that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;<br>&gt;         public<br>&gt;         moduleprivate<br>&gt;         fileprivate<br>&gt;         private<br>&gt;<br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward<br>&gt; parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt;<br>&gt; What do you all think?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/95e96fee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Mar 24, 2016, at 5:07 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s very consistent with other keywords. I wish compound keywords were joined with a dash or something that made them easier to read, but I guess it&#39;s too late now. If we have associatedtype, it makes sense to use moduleprivate (I saw that the name  associatedtype was discussed extensively but didn&#39;t participate in the discussion; I am sure that it was given a lot of thought). If we could change this, I&#39;d suggest keyword names with dashes everywhere, but if not, these names work well and is a great compromise for everything I&#39;ve seen in this thread.<br>&gt; <br>&gt; I am not worried about the length because the 2 most frequently written keywords would be public and private. Moduleprivate is the default, and file private will not be used as often as private.<br>&gt; <br>&gt; One question: should the proposal be explicit about access control for nested classes? We discussed it here briefly (I wanted private to be completely private to the class or extension itself while 2 other people wanted a nested class to have access to the outer class.)<br></p><p>I don&#39;t think it would make sense at all to allow an outer type to see private members of a nested class.  That would break the semantics of private meaning &quot;containing scope&quot;.<br></p><p>However, with Chris&#39;s suggestion of using identifiers as parameters, maybe we could eventually have something like private(OuterTypeName) to specify the precise level of access desired.<br></p><p>&gt; <br>&gt;&gt; On Thu, Mar 24, 2016 at 1:13 AM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt; <br>&gt;&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt;&gt; <br>&gt;&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt;&gt; <br>&gt;&gt; I’ve seen several proposals that seem promising:<br>&gt;&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt; &gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       private                 symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; &gt;       private(module) symbol visible within the current module.<br>&gt;&gt; &gt;       private(file)           symbol visible within the current file.<br>&gt;&gt; <br>&gt;&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br>&gt;&gt; <br>&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; public<br>&gt;&gt; &gt; private-module<br>&gt;&gt; &gt; private-file<br>&gt;&gt; &gt; private<br>&gt;&gt; <br>&gt;&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt;&gt; <br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt;         public<br>&gt;&gt;         moduleprivate<br>&gt;&gt;         fileprivate<br>&gt;&gt;         private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt; <br>&gt;&gt; What do you all think?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/9114e628/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 24, 2016 at 01:00:00pm</p></header><div class="content"><p>The discussion was about the other direction: whether a nested class should<br>have access to private members of the outer class.<br></p><p>On Thu, Mar 24, 2016 at 9:35 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Mar 24, 2016, at 5:07 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It&#39;s very consistent with other keywords. I wish compound keywords were<br>&gt; joined with a dash or something that made them easier to read, but I guess<br>&gt; it&#39;s too late now. If we have associatedtype, it makes sense to use<br>&gt; moduleprivate (I saw that the name associatedtype was discussed extensively<br>&gt; but didn&#39;t participate in the discussion; I am sure that it was given a lot<br>&gt; of thought). If we could change this, I&#39;d suggest keyword names with dashes<br>&gt; everywhere, but if not, these names work well and is a great compromise for<br>&gt; everything I&#39;ve seen in this thread.<br>&gt;<br>&gt; I am not worried about the length because the 2 most frequently written<br>&gt; keywords would be public and private. Moduleprivate is the default, and<br>&gt; file private will not be used as often as private.<br>&gt;<br>&gt; One question: should the proposal be explicit about access control for<br>&gt; nested classes? We discussed it here briefly (I wanted private to be<br>&gt; completely private to the class or extension itself while 2 other people<br>&gt; wanted a nested class to have access to the outer class.)<br>&gt;<br>&gt;<br>&gt; I don&#39;t think it would make sense at all to allow an outer type to see<br>&gt; private members of a nested class.  That would break the semantics of<br>&gt; private meaning &quot;containing scope&quot;.<br>&gt;<br>&gt; However, with Chris&#39;s suggestion of using identifiers as parameters, maybe<br>&gt; we could eventually have something like private(OuterTypeName) to specify<br>&gt; the precise level of access desired.<br>&gt;<br>&gt;<br>&gt; On Thu, Mar 24, 2016 at 1:13 AM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Per Doug’s email, the core team agrees we should make a change here,<br>&gt;&gt; but would like some bikeshedding to happen on the replacement name for<br>&gt;&gt; private.<br>&gt;&gt;<br>&gt;&gt; What we do with private setters is orthogonal from this proposal, so I’m<br>&gt;&gt; going to ignore it in this thread.  After SE-0025 is resolved, it would be<br>&gt;&gt; great to have another thread/proposal that discusses reskinning<br>&gt;&gt; private(set) - presumably as just a modifier on the setter.<br>&gt;&gt;<br>&gt;&gt; Similarly, this proposal has nothing to do with “protected” or any other<br>&gt;&gt; type based access control, so I don’t delve into that at all either.<br>&gt;&gt;<br>&gt;&gt; I’ve seen several proposals that seem promising:<br>&gt;&gt;<br>&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt; &gt; I like fileprivate, if that’s the only change. On the other hand, if we<br>&gt;&gt; want to consider a broader change, what about:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       private                 symbol visible within the current<br>&gt;&gt; declaration (class, extension, etc).<br>&gt;&gt; &gt;       private(module) symbol visible within the current module.<br>&gt;&gt; &gt;       private(file)           symbol visible within the current file.<br>&gt;&gt;<br>&gt;&gt; I love how this establishes a family with different levels of access<br>&gt;&gt; control, and unites them under the idea of &quot;levels of being private”.  I<br>&gt;&gt; also like how people would commonly only ever write public and private<br>&gt;&gt; (because “private(module)” is the default, and &quot;private(file)&quot; is<br>&gt;&gt; obscure).  However, parenthesized modifiers that take a keyword (as opposed<br>&gt;&gt; to an identifier) are a bit weird and awkward, so it would be nice to avoid<br>&gt;&gt; them if possible.<br>&gt;&gt;<br>&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; public<br>&gt;&gt; &gt; private-module<br>&gt;&gt; &gt; private-file<br>&gt;&gt; &gt; private<br>&gt;&gt;<br>&gt;&gt; This follows the same sort of structure as James’ proposal, without the<br>&gt;&gt; parens.  It has the same advantages, but trades them with hyphenated decl<br>&gt;&gt; modifiers.  We don’t do that, but it is a good direction.<br>&gt;&gt;<br>&gt;&gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt;<br>&gt;&gt;         public<br>&gt;&gt;         moduleprivate<br>&gt;&gt;         fileprivate<br>&gt;&gt;         private<br>&gt;&gt;<br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward<br>&gt;&gt; parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;<br>&gt;&gt; What do you all think?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/203b2a14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Mar 24, 2016, at 8:40 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; The discussion was about the other direction: whether a nested class should have access to private members of the outer class.<br></p><p>In that case the answer seems clear as well.  Everywhere in Swift&#39;s access model nested scopes have visibility to all members visible in the containing scope.  For example, all scopes in a file can see any &quot;fileprivate&quot; members contained in that file.  <br></p><p>Following this semantic, all nested types would be able to see members of their containing type, even those with the new &quot;private&quot; visibility because the nested types are within the same scope where those members are declared. <br></p><p>Semantic consistency is the most important concern IMO.  All current access modifiers are strictly based on nested scopes.  Hiding members of a containing type from a nested type would break this model and introduce type-driven semantics, which I think (and hope) is beyond the scope of this proposal (pun mildly intended).<br></p><p>Matthew<br></p><p>&gt; <br>&gt;&gt; On Thu, Mar 24, 2016 at 9:35 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 5:07 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s very consistent with other keywords. I wish compound keywords were joined with a dash or something that made them easier to read, but I guess it&#39;s too late now. If we have associatedtype, it makes sense to use moduleprivate (I saw that the name  associatedtype was discussed extensively but didn&#39;t participate in the discussion; I am sure that it was given a lot of thought). If we could change this, I&#39;d suggest keyword names with dashes everywhere, but if not, these names work well and is a great compromise for everything I&#39;ve seen in this thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not worried about the length because the 2 most frequently written keywords would be public and private. Moduleprivate is the default, and file private will not be used as often as private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One question: should the proposal be explicit about access control for nested classes? We discussed it here briefly (I wanted private to be completely private to the class or extension itself while 2 other people wanted a nested class to have access to the outer class.)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think it would make sense at all to allow an outer type to see private members of a nested class.  That would break the semantics of private meaning &quot;containing scope&quot;.<br>&gt;&gt; <br>&gt;&gt; However, with Chris&#39;s suggestion of using identifiers as parameters, maybe we could eventually have something like private(OuterTypeName) to specify the precise level of access desired.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Mar 24, 2016 at 1:13 AM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve seen several proposals that seem promising:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;       private                 symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt;&gt; &gt;       private(module) symbol visible within the current module.<br>&gt;&gt;&gt;&gt; &gt;       private(file)           symbol visible within the current file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; public<br>&gt;&gt;&gt;&gt; &gt; private-module<br>&gt;&gt;&gt;&gt; &gt; private-file<br>&gt;&gt;&gt;&gt; &gt; private<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         public<br>&gt;&gt;&gt;&gt;         moduleprivate<br>&gt;&gt;&gt;&gt;         fileprivate<br>&gt;&gt;&gt;&gt;         private<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you all think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/df34c5a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>I am not sure if consistency is a problem here. My primary concern is that<br>as long as the class or extension code itself hasn&#39;t changed, it&#39;s private<br>API stays hidden from anything else. If we can simply inject a class into a<br>class or extension and get access to all of its internals, that reduces the<br>protection level that private would provide. I&#39;d like private to hide<br>implementation details completely.<br></p><p>That said, I am not sure if we need to discuss it as part of this proposal.<br>On Thu, Mar 24, 2016 at 10:28 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Mar 24, 2016, at 8:40 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The discussion was about the other direction: whether a nested class<br>&gt; should have access to private members of the outer class.<br>&gt;<br>&gt;<br>&gt; In that case the answer seems clear as well.  Everywhere in Swift&#39;s access<br>&gt; model nested scopes have visibility to all members visible in the<br>&gt; containing scope.  For example, all scopes in a file can see any<br>&gt; &quot;fileprivate&quot; members contained in that file.<br>&gt;<br>&gt; Following this semantic, all nested types would be able to see members of<br>&gt; their containing type, even those with the new &quot;private&quot; visibility because<br>&gt; the nested types are within the same scope where those members are<br>&gt; declared.<br>&gt;<br>&gt; Semantic consistency is the most important concern IMO.  All current<br>&gt; access modifiers are strictly based on nested scopes.  Hiding members of a<br>&gt; containing type from a nested type would break this model and introduce<br>&gt; type-driven semantics, which I think (and hope) is beyond the scope of this<br>&gt; proposal (pun mildly intended).<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; On Thu, Mar 24, 2016 at 9:35 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Mar 24, 2016, at 5:07 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It&#39;s very consistent with other keywords. I wish compound keywords were<br>&gt;&gt; joined with a dash or something that made them easier to read, but I guess<br>&gt;&gt; it&#39;s too late now. If we have associatedtype, it makes sense to use<br>&gt;&gt; moduleprivate (I saw that the name associatedtype was discussed extensively<br>&gt;&gt; but didn&#39;t participate in the discussion; I am sure that it was given a lot<br>&gt;&gt; of thought). If we could change this, I&#39;d suggest keyword names with dashes<br>&gt;&gt; everywhere, but if not, these names work well and is a great compromise for<br>&gt;&gt; everything I&#39;ve seen in this thread.<br>&gt;&gt;<br>&gt;&gt; I am not worried about the length because the 2 most frequently written<br>&gt;&gt; keywords would be public and private. Moduleprivate is the default, and<br>&gt;&gt; file private will not be used as often as private.<br>&gt;&gt;<br>&gt;&gt; One question: should the proposal be explicit about access control for<br>&gt;&gt; nested classes? We discussed it here briefly (I wanted private to be<br>&gt;&gt; completely private to the class or extension itself while 2 other people<br>&gt;&gt; wanted a nested class to have access to the outer class.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think it would make sense at all to allow an outer type to see<br>&gt;&gt; private members of a nested class.  That would break the semantics of<br>&gt;&gt; private meaning &quot;containing scope&quot;.<br>&gt;&gt;<br>&gt;&gt; However, with Chris&#39;s suggestion of using identifiers as parameters,<br>&gt;&gt; maybe we could eventually have something like private(OuterTypeName) to<br>&gt;&gt; specify the precise level of access desired.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Mar 24, 2016 at 1:13 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; Per Doug’s email, the core team agrees we should make a change here,<br>&gt;&gt;&gt; but would like some bikeshedding to happen on the replacement name for<br>&gt;&gt;&gt; private.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What we do with private setters is orthogonal from this proposal, so I’m<br>&gt;&gt;&gt; going to ignore it in this thread.  After SE-0025 is resolved, it would be<br>&gt;&gt;&gt; great to have another thread/proposal that discusses reskinning<br>&gt;&gt;&gt; private(set) - presumably as just a modifier on the setter.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Similarly, this proposal has nothing to do with “protected” or any other<br>&gt;&gt;&gt; type based access control, so I don’t delve into that at all either.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve seen several proposals that seem promising:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt;&gt; &gt; I like fileprivate, if that’s the only change. On the other hand, if<br>&gt;&gt;&gt; we want to consider a broader change, what about:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       private                 symbol visible within the current<br>&gt;&gt;&gt; declaration (class, extension, etc).<br>&gt;&gt;&gt; &gt;       private(module) symbol visible within the current module.<br>&gt;&gt;&gt; &gt;       private(file)           symbol visible within the current file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I love how this establishes a family with different levels of access<br>&gt;&gt;&gt; control, and unites them under the idea of &quot;levels of being private”.  I<br>&gt;&gt;&gt; also like how people would commonly only ever write public and private<br>&gt;&gt;&gt; (because “private(module)” is the default, and &quot;private(file)&quot; is<br>&gt;&gt;&gt; obscure).  However, parenthesized modifiers that take a keyword (as opposed<br>&gt;&gt;&gt; to an identifier) are a bit weird and awkward, so it would be nice to avoid<br>&gt;&gt;&gt; them if possible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; public<br>&gt;&gt;&gt; &gt; private-module<br>&gt;&gt;&gt; &gt; private-file<br>&gt;&gt;&gt; &gt; private<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This follows the same sort of structure as James’ proposal, without the<br>&gt;&gt;&gt; parens.  It has the same advantages, but trades them with hyphenated decl<br>&gt;&gt;&gt; modifiers.  We don’t do that, but it is a good direction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt;&gt; and use:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         public<br>&gt;&gt;&gt;         moduleprivate<br>&gt;&gt;&gt;         fileprivate<br>&gt;&gt;&gt;         private<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What do you all think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/f176bc91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 9:59 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; I am not sure if consistency is a problem here. My primary concern is that as long as the class or extension code itself hasn&#39;t changed, it&#39;s private API stays hidden from anything else. If we can simply inject a class into a class or extension and get access to all of its internals, that reduces the protection level that private would provide. I&#39;d like private to hide implementation details completely.<br></p><p>That wouldn’t be possible because the semantics are scope-based, not type-based.  <br></p><p>Here’s an example (using the new “private” modifier):<br></p><p>fileA.swift:<br></p><p>class C {<br>	private let s: String<br>	<br>	class Nested {<br>		func foo() {<br>			let c = C()<br></p><p>			// s is visible here because `Nested` and `foo` <br>			// are within the lexical scope that declared `s`<br>			let s = c.s<br>		}<br>	}<br>}<br></p><p>extension C {<br>	// `s` is not visible anywhere here<br>	// because we are not within the lexical scope<br>	// where `s` was declared<br>}<br></p><p>fileB.swift:<br></p><p>extension C {<br>	// `s` is not visible anywhere here<br>	// because we are not within the lexical scope<br>	// where `s` was declared<br>}<br></p><p>&gt; <br>&gt; That said, I am not sure if we need to discuss it as part of this proposal.<br>&gt; On Thu, Mar 24, 2016 at 10:28 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Mar 24, 2016, at 8:40 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The discussion was about the other direction: whether a nested class should have access to private members of the outer class.<br>&gt; <br>&gt; In that case the answer seems clear as well.  Everywhere in Swift&#39;s access model nested scopes have visibility to all members visible in the containing scope.  For example, all scopes in a file can see any &quot;fileprivate&quot; members contained in that file.  <br>&gt; <br>&gt; Following this semantic, all nested types would be able to see members of their containing type, even those with the new &quot;private&quot; visibility because the nested types are within the same scope where those members are declared. <br>&gt; <br>&gt; Semantic consistency is the most important concern IMO.  All current access modifiers are strictly based on nested scopes.  Hiding members of a containing type from a nested type would break this model and introduce type-driven semantics, which I think (and hope) is beyond the scope of this proposal (pun mildly intended).<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Mar 24, 2016 at 9:35 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Mar 24, 2016, at 5:07 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; It&#39;s very consistent with other keywords. I wish compound keywords were joined with a dash or something that made them easier to read, but I guess it&#39;s too late now. If we have associatedtype, it makes sense to use moduleprivate (I saw that the name  associatedtype was discussed extensively but didn&#39;t participate in the discussion; I am sure that it was given a lot of thought). If we could change this, I&#39;d suggest keyword names with dashes everywhere, but if not, these names work well and is a great compromise for everything I&#39;ve seen in this thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not worried about the length because the 2 most frequently written keywords would be public and private. Moduleprivate is the default, and file private will not be used as often as private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One question: should the proposal be explicit about access control for nested classes? We discussed it here briefly (I wanted private to be completely private to the class or extension itself while 2 other people wanted a nested class to have access to the outer class.)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think it would make sense at all to allow an outer type to see private members of a nested class.  That would break the semantics of private meaning &quot;containing scope&quot;.<br>&gt;&gt; <br>&gt;&gt; However, with Chris&#39;s suggestion of using identifiers as parameters, maybe we could eventually have something like private(OuterTypeName) to specify the precise level of access desired.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Mar 24, 2016 at 1:13 AM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve seen several proposals that seem promising:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com &lt;mailto:jberry at rogueorbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       private                 symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; &gt;       private(module) symbol visible within the current module.<br>&gt;&gt;&gt; &gt;       private(file)           symbol visible within the current file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; public<br>&gt;&gt;&gt; &gt; private-module<br>&gt;&gt;&gt; &gt; private-file<br>&gt;&gt;&gt; &gt; private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         public<br>&gt;&gt;&gt;         moduleprivate<br>&gt;&gt;&gt;         fileprivate<br>&gt;&gt;&gt;         private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you all think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/570e2550/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>March 24, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Le 24 mars 2016 à 01:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; <br>&gt; [..snip..]<br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br></p><p>The think I fear with moduleprivate and fileprivate, is that someone will one day suggest to lowerCamelCase them. The parenthesized version was de-facto preventing my fear from ever being reality.<br>Obviously, I am on the &quot;all keywords should be all lowercases&quot; team.<br></p><p>Dany<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>We already have other precedents for combining multiple words into a<br>keyword. I don&#39;t that these will be any different.<br>On Thu, Mar 24, 2016 at 7:02 AM Dany St-Amant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Le 24 mars 2016 à 01:13, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; &gt;<br>&gt; &gt; [..snip..]<br>&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;<br>&gt; &gt;       public<br>&gt; &gt;       moduleprivate<br>&gt; &gt;       fileprivate<br>&gt; &gt;       private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt; &gt;<br>&gt; &gt; What do you all think?<br>&gt;<br>&gt; The think I fear with moduleprivate and fileprivate, is that someone will<br>&gt; one day suggest to lowerCamelCase them. The parenthesized version was<br>&gt; de-facto preventing my fear from ever being reality.<br>&gt; Obviously, I am on the &quot;all keywords should be all lowercases&quot; team.<br>&gt;<br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/319e2b25/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 24, 2016 at 12:00:00pm</p></header><div class="content"><p>I think that supercalifragilisticexpialidocious may benefit from lowerCamelCasing ;).<br></p><p>[[iOS messageWithContent:webContent] broadcast]<br></p><p>&gt; On 24 Mar 2016, at 11:02, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 24 mars 2016 à 01:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt;&gt; <br>&gt;&gt; [..snip..]<br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt;    public<br>&gt;&gt;    moduleprivate<br>&gt;&gt;    fileprivate<br>&gt;&gt;    private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt; <br>&gt;&gt; What do you all think?<br>&gt; <br>&gt; The think I fear with moduleprivate and fileprivate, is that someone will one day suggest to lowerCamelCase them. The parenthesized version was de-facto preventing my fear from ever being reality.<br>&gt; Obviously, I am on the &quot;all keywords should be all lowercases&quot; team.<br>&gt; <br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/7f56a9bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07c147e6770f1e43d129f52aafd44138?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Biala</string> &lt;bialata at yahoo.com&gt;<p>March 24, 2016 at 12:00:00pm</p></header><div class="content"><p>In real life only public and private make sense. So it may be just private and everything else is public by default. Public may stay for compatibility :) And saying that I think there is no need to change anything as the current model is good enough.<br>What ever you do - don,t break existing code. Swift is not beta anymore...No one can invest in big projects if the syntax is unstable!<br> <br></p><p>    On Thursday, March 24, 2016 2:17 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br> <br></p><p> I think that supercalifragilisticexpialidocious may benefit from lowerCamelCasing ;).<br></p><p>[[iOS messageWithContent:webContent] broadcast]<br>On 24 Mar 2016, at 11:02, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br>Le 24 mars 2016 à 01:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p><br></p><p><br></p><p>&lt;responding to several posts in this thread at once&gt;<br></p><p><br></p><p><br></p><p>[..snip..]<br></p><p><br>How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br></p><p><br></p><p><br></p><p>    public<br></p><p><br>    moduleprivate<br></p><p><br>    fileprivate<br></p><p><br>    private<br></p><p><br></p><p><br></p><p>The advantages, as I see them are:<br></p><p><br>1) We keep public and private meaning the “right” and “obvious” things.<br></p><p><br>2) The declmodifiers “read” correctly.<br></p><p><br>3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br></p><p><br>4) The unusual ones would be “googable”.<br></p><p><br>5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br></p><p><br></p><p><br></p><p>What do you all think?<br></p><p><br>The think I fear with moduleprivate and fileprivate, is that someone will one day suggest to lowerCamelCase them. The parenthesized version was de-facto preventing my fear from ever being reality.<br>Obviously, I am on the &quot;all keywords should be all lowercases&quot; team.<br></p><p>Dany<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/b7a5b088/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 24, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mar 24, 2016, at 4:02 AM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; What do you all think?<br>&gt; <br>&gt; The think I fear with moduleprivate and fileprivate, is that someone will one day suggest to lowerCamelCase them. The parenthesized version was de-facto preventing my fear from ever being reality.<br>&gt; Obviously, I am on the &quot;all keywords should be all lowercases&quot; team.<br></p><p>Nothing is impossible, but I consider the odds of typealias and associatedtype becoming lower camel cased to be extremely near zero.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/afb1af7924cbadd912a8b5b2f1308bba?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>John Siracusa</string> &lt;siracusa at gmail.com&gt;<p>March 24, 2016 at 09:00:00am</p></header><div class="content"><p>On Thu, Mar 24, 2016 at 1:13 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; public<br>&gt; &gt; private-module<br>&gt; &gt; private-file<br>&gt; &gt; private<br>&gt;<br>&gt; This follows the same sort of structure as James’ proposal, without the<br>&gt; parens.  It has the same advantages, but trades them with hyphenated decl<br>&gt; modifiers.  We don’t do that, but it is a good direction.<br>&gt;<br>&gt; How about we continue this trend, and follow other existing Swift keywords<br>&gt; that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;<br>&gt;         public<br>&gt;         moduleprivate<br>&gt;         fileprivate<br>&gt;         private<br>&gt;<br></p><p>Why is it important to highlight word boundaries in so many other<br>conventions in Swift but not in this one? What would be lost with this<br>alternative?<br></p><p>public<br>module_private<br>file_private<br>private<br></p><p>Is it just the extra (chorded, on US keyboards) keystroke? I think the<br>readability benefits of clear word boundaries far outweigh the keystroke<br>cost (especially with good editor auto-complete).<br></p><p>I also think the precedent of nameslikethis is a dangerous one for<br>readability. It&#39;s easy to say this is &quot;just for this limited area of the<br>language,&quot; but witness how associatedtype is already used to support<br>moduleprivate and friends. Precedents matter, and I think this is not a<br>good one.<br></p><p>-John<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/915c9448/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 25, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; Why is it important to highlight word boundaries in so many other conventions in Swift but not in this one? What would be lost with this alternative?<br>&gt; <br>&gt; public<br>&gt; module_private<br>&gt; file_private<br>&gt; private<br>&gt; <br>&gt; Is it just the extra (chorded, on US keyboards) keystroke? I think the readability benefits of clear word boundaries far outweigh the keystroke cost (especially with good editor auto-complete).<br></p><p>The keywords, unlike identifiers, are always the same. You don&#39;t need to parse them every time; ‘on an infinite timescale’, you get used to them and recognize them at a glance. So the value of adding an underscore (or, heaven forbid, camel case style) to a keyword is a lot less than with identifiers.<br></p><p>My personal completely subjective opinion is that the underscored ones look gross and pull too much attention onto themselves, rather than helping to focus on the identifiers. To me, this actually detracts from the overall readability of the entire line.<br></p><p>In other words: nothing says “nothing to see here, move along” quite like abunchofgibberishthrowntogether.<br></p><p>A.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/91e2c12a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Why is it important to highlight word boundaries in so many other conventions in Swift but not in this one? What would be lost with this alternative?<br>&gt; <br>&gt; public<br>&gt; module_private<br>&gt; file_private<br>&gt; private<br>&gt; <br>&gt; Is it just the extra (chorded, on US keyboards) keystroke? I think the readability benefits of clear word boundaries far outweigh the keystroke cost (especially with good editor auto-complete).<br></p><p>Swift style, deriving from Objective-C style, seems to disfavor underscores in general, except as a &quot;formally public but informally private&quot; marker at the beginning of an identifier. We&#39;re in the process of removing the last underscored language constructs, `@warn_unused_result` and its `mutable_variant` parameter, and replacing them with alternatives without underscores.<br></p><p>So if we wanted to mark a word boundary, we&#39;d probably use camelCase. And to me, camelCase just feels wrong for keywords, particularly ones as common as access modifiers. I think it&#39;s because identifiers are camelCase too; you really want keywords to disappear into the background, but in something like this:<br></p><p>	modulePrivate func spinWicket() {<br></p><p>That `modulePrivate` looks like an identifier—maybe a return type or something—rather than a keyword.<br></p><p>Honestly, though, I&#39;m not sure why people are working so hard to cram `private` in there. Does `moduleprivate` or `private(module)` really convey more information than `module`? Particularly once you&#39;ve looked it up and know that it&#39;s an access modifier?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 4:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Honestly, though, I&#39;m not sure why people are working so hard to cram `private` in there. Does `moduleprivate` or `private(module)` really convey more information than `module`? Particularly once you&#39;ve looked it up and know that it&#39;s an access modifier?<br></p><p>I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>`moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>more fixed in purpose.<br></p><p>I hesitate to make this thread any longer but since it&#39;s already bikeshedding, I felt it was worth adding another few cents.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt; more fixed in purpose.<br></p><p>Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br></p><p>`module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br></p><p>(Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br></p><p>Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt;&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt;&gt; more fixed in purpose.<br>&gt; <br>&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br>&gt; <br>&gt; `module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br>&gt; <br>&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br>&gt; <br>&gt; Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br></p><p><br>`moduleprivate` is the default value. I doubt it will get  used much if at all. I don&#39;t think `fileprivate` will get used much either<br>but in such cases, I think those seven extra letters are essential and documenting.<br></p><p>The two remaining public and private access levels are simple and intuitively obvious.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt;&gt;&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt;&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt;&gt;&gt; more fixed in purpose.<br>&gt;&gt; <br>&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br>&gt;&gt; <br>&gt;&gt; `module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br>&gt;&gt; <br>&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br>&gt;&gt; <br>&gt;&gt; Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br>&gt; <br>&gt; <br>&gt; `moduleprivate` is the default value. I doubt it will get  used much if at all. I don&#39;t think `fileprivate` will get used much either<br>&gt; but in such cases, I think those seven extra letters are essential and documenting.<br>&gt; <br>&gt; The two remaining public and private access levels are simple and intuitively obvious.<br></p><p>I&#39;m going to say that I remain unhappy with these new names. I don&#39;t believe that these won&#39;t get used, and I don&#39;t want them to feel awkward, discouraged, or penalized when they do. The standard library, for example, has in its style guide that all access control should be explicit, which is a reasonable style to enforce. I also have a small concern that they won&#39;t be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or module-private?&quot; &quot;neither, just private-private&quot;.<br></p><p>I realize these are all vague concerns, and I don&#39;t have something more concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be very literally accurate but (a) would force people to learn what &quot;scoped&quot; means unnecessarily, and (b) aren&#39;t less awkward.<br></p><p>I agree with the concerns that just saying &quot;file var foo&quot; makes it sound like there&#39;s one copy of the variable shared in the entire file, even when applied to an instance property. I think there&#39;s a lot of value is making the access control terms adjectives.<br></p><p>I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/7d42f0d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 25, 2016, at 9:15 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt;&gt;&gt;&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt;&gt;&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt;&gt;&gt;&gt; more fixed in purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; `moduleprivate` is the default value. I doubt it will get  used much if at all. I don&#39;t think `fileprivate` will get used much either<br>&gt;&gt; but in such cases, I think those seven extra letters are essential and documenting.<br>&gt;&gt; <br>&gt;&gt; The two remaining public and private access levels are simple and intuitively obvious.<br>&gt; <br>&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t believe that these won&#39;t get used, and I don&#39;t want them to feel awkward, discouraged, or penalized when they do. The standard library, for example, has in its style guide that all access control should be explicit, which is a reasonable style to enforce. I also have a small concern that they won&#39;t be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or module-private?&quot; &quot;neither, just private-private&quot;.<br></p><p>I think this is a very important observation. Being able to talk about these levers is very important, especially in the context of teaching new people about the various levels of access control.<br></p><p>&gt; I realize these are all vague concerns, and I don&#39;t have something more concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be very literally accurate but (a) would force people to learn what &quot;scoped&quot; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt; <br>&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound like there&#39;s one copy of the variable shared in the entire file, even when applied to an instance property. I think there&#39;s a lot of value is making the access control terms adjectives.<br>&gt; <br>&gt; I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br></p><p>I agree 100% with this. <br></p><p>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/b01b5f05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 29, 2016 at 07:00:00am</p></header><div class="content"><p>I also agree with everything Jordan said! <br></p><p>-Thorsten <br></p><p>&gt; Am 25.03.2016 um 17:27 schrieb David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt;&gt; On Mar 25, 2016, at 9:15 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt;&gt;&gt;&gt;&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt;&gt;&gt;&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt;&gt;&gt;&gt;&gt; more fixed in purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `moduleprivate` is the default value. I doubt it will get  used much if at all. I don&#39;t think `fileprivate` will get used much either<br>&gt;&gt;&gt; but in such cases, I think those seven extra letters are essential and documenting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The two remaining public and private access levels are simple and intuitively obvious.<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t believe that these won&#39;t get used, and I don&#39;t want them to feel awkward, discouraged, or penalized when they do. The standard library, for example, has in its style guide that all access control should be explicit, which is a reasonable style to enforce. I also have a small concern that they won&#39;t be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or module-private?&quot; &quot;neither, just private-private&quot;.<br>&gt; <br>&gt; I think this is a very important observation. Being able to talk about these levers is very important, especially in the context of teaching new people about the various levels of access control.<br>&gt; <br>&gt;&gt; I realize these are all vague concerns, and I don&#39;t have something more concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be very literally accurate but (a) would force people to learn what &quot;scoped&quot; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt;&gt; <br>&gt;&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound like there&#39;s one copy of the variable shared in the entire file, even when applied to an instance property. I think there&#39;s a lot of value is making the access control terms adjectives.<br>&gt;&gt; <br>&gt;&gt; I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br>&gt; <br>&gt; I agree 100% with this. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/afde3ddc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Well... how about we reverse the terms: call them &#39;privatetomodule&#39; and<br>&#39;privatetofile&#39;.<br></p><p>This is &#39;private(module)&#39; and &#39;private(file)&#39; but fitting the all<br>lower-case style. It puts &#39;private&#39; first (and when you use the keyword,<br>&#39;private&#39; is the bit you want to start with more than &#39;module&#39; or &#39;file&#39;).<br>It&#39;s easier to use in conversation (&quot;these properties are private to the<br>file&quot;).<br>Disadvantage: it adds &#39;to&#39;, so the words are even longer (but no longer<br>than the parenthesised form would&#39;ve taken).<br></p><p>&#39;privatetofile extension Foo : BarConvertible { }&#39;<br></p><p>On Fri, Mar 25, 2016 at 4:15 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I think it does. `module` could mean many things related to how Swift<br>&gt; creates and consumes modules.<br>&gt; `moduleprivate` combines something about access levels (public/private)<br>&gt; and scope (module), is easy to<br>&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it<br>&gt; is less flexible in meaning and<br>&gt; more fixed in purpose.<br>&gt;<br>&gt;<br>&gt; Sure, but is that worth 7 to 9 extra characters at every single use site<br>&gt; for something that&#39;s actually pretty common? Is it worth the muddled mess<br>&gt; of an all-lowercase keyword with no obvious break, or the<br>&gt; attention-grabbing of a capital letter or an underscore?<br>&gt;<br>&gt; `module` and `file` are not going to be obscure corners of the language.<br>&gt; Most people will probably learn about them at the same time they learn<br>&gt; about `public` and `private`.<br>&gt;<br>&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see<br>&gt; it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as<br>&gt; easily confused with a declaration.)<br>&gt;<br>&gt; Obviousness for new users is great, but you can take it too far. We call<br>&gt; the type `Int32`, not<br>&gt; `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and<br>&gt; if we did, it&#39;s not clear the longer name would really be more obvious,<br>&gt; because it would be such a pain to read.<br>&gt;<br>&gt;<br>&gt;<br>&gt; `moduleprivate` is the default value. I doubt it will get  used much if at<br>&gt; all. I don&#39;t think `fileprivate` will get used much either<br>&gt; but in such cases, I think those seven extra letters are essential and<br>&gt; documenting.<br>&gt;<br>&gt; The two remaining public and private access levels are simple and<br>&gt; intuitively obvious.<br>&gt;<br>&gt;<br>&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t<br>&gt; believe that these won&#39;t get used, and I don&#39;t want them to feel awkward,<br>&gt; discouraged, or penalized when they do. The standard library, for example,<br>&gt; has in its style guide that all access control should be explicit, which is<br>&gt; a reasonable style to enforce. I also have a small concern that they won&#39;t<br>&gt; be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or<br>&gt; module-private?&quot; &quot;neither, just private-private&quot;.<br>&gt;<br>&gt; I realize these are all vague concerns, and I don&#39;t have something more<br>&gt; concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be<br>&gt; very literally accurate but (a) would force people to learn what &quot;scoped&quot;<br>&gt; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt;<br>&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound<br>&gt; like there&#39;s one copy of the variable shared in the entire file, even when<br>&gt; applied to an instance property. I think there&#39;s a lot of value is making<br>&gt; the access control terms adjectives.<br>&gt;<br>&gt; I honestly still think &quot;public, internal, private, local&quot; is a better<br>&gt; taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically<br>&gt; ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re<br>&gt; all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to<br>&gt; read or to use in conversation. But both the core team and the list<br>&gt; disagree, mainly because (a) it aligns &#39;private&#39; more closely with other<br>&gt; languages, and (b) if you&#39;re not thinking about it, more restrictive is<br>&gt; better than less. (Both of which I agree are good ideas.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/4fd9176a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>It doesn&#39;t solve the problem for me. &quot;These properties are private.&quot; &quot;To what?&quot; &quot;Just private&quot; / &quot;To the scope&quot;.<br></p><p>They&#39;re also still awkward to read in code. I know we have lots of decl modifiers, but I&#39;ve convinced myself we&#39;re not in Java&#39;s &quot;public static void main&quot; soup situation yet.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 25, 2016, at 9:27 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Well... how about we reverse the terms: call them &#39;privatetomodule&#39; and &#39;privatetofile&#39;.<br>&gt; <br>&gt; This is &#39;private(module)&#39; and &#39;private(file)&#39; but fitting the all lower-case style. It puts &#39;private&#39; first (and when you use the keyword, &#39;private&#39; is the bit you want to start with more than &#39;module&#39; or &#39;file&#39;). It&#39;s easier to use in conversation (&quot;these properties are private to the file&quot;).<br>&gt; Disadvantage: it adds &#39;to&#39;, so the words are even longer (but no longer than the parenthesised form would&#39;ve taken).<br>&gt; <br>&gt; &#39;privatetofile extension Foo : BarConvertible { }&#39;<br>&gt; <br>&gt; On Fri, Mar 25, 2016 at 4:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt;&gt;&gt;&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt;&gt;&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt;&gt;&gt;&gt; more fixed in purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; `moduleprivate` is the default value. I doubt it will get  used much if at all. I don&#39;t think `fileprivate` will get used much either<br>&gt;&gt; but in such cases, I think those seven extra letters are essential and documenting.<br>&gt;&gt; <br>&gt;&gt; The two remaining public and private access levels are simple and intuitively obvious.<br>&gt; <br>&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t believe that these won&#39;t get used, and I don&#39;t want them to feel awkward, discouraged, or penalized when they do. The standard library, for example, has in its style guide that all access control should be explicit, which is a reasonable style to enforce. I also have a small concern that they won&#39;t be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or module-private?&quot; &quot;neither, just private-private&quot;.<br>&gt; <br>&gt; I realize these are all vague concerns, and I don&#39;t have something more concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be very literally accurate but (a) would force people to learn what &quot;scoped&quot; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt; <br>&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound like there&#39;s one copy of the variable shared in the entire file, even when applied to an instance property. I think there&#39;s a lot of value is making the access control terms adjectives.<br>&gt; <br>&gt; I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/2d4c2bdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Well, several prominent voices seem to think that &#39;private&#39; is &quot;intuitively<br>obvious&quot; when it refers to declaration-level scope, so I didn&#39;t argue that<br>point. I still happen to disagree; I would add &#39;privatetodeclaration&#39; to<br>&#39;privatetomodule&#39; and &#39;privatetofile&#39;, which would solve that<br>conversational point: &quot;These properties are private to the declaration&quot;.<br></p><p>Alternatively: &#39;fileaccessible&#39;, &#39;moduleaccessible&#39;,<br>&#39;declarationaccessible&#39;? (Does that confuse code accessibility with such<br>things as UIAccessibility?)<br></p><p>That doesn&#39;t answer your awkward-to-read-in-code problem. I don&#39;t have a<br>solution to that.<br></p><p>To re-specify the problem, again (perhaps more for my benefit while writing<br>as yours while reading): the terms we choose have to suggest accessibility,<br>but a subjective spectrum of adjectives does not give us clarity. The idea<br>of building into these symbols references to exactly where the scope ends<br>appears to be popular. There aren&#39;t any existing one-word terms which<br>express these concepts so we&#39;re coining new words out of two (or more)<br>existing words. Which combination of words is least awkward to read, or<br>most intuitive to type, is still going to be subjective.<br></p><p><br>On Fri, Mar 25, 2016 at 4:29 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; It doesn&#39;t solve the problem for me. &quot;These properties are private.&quot; &quot;To<br>&gt; what?&quot; &quot;Just private&quot; / &quot;To the scope&quot;.<br>&gt;<br>&gt; They&#39;re also still awkward to read in code. I know we have lots of decl<br>&gt; modifiers, but I&#39;ve convinced myself we&#39;re not in Java&#39;s &quot;public static<br>&gt; void main&quot; soup situation yet.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 25, 2016, at 9:27 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Well... how about we reverse the terms: call them &#39;privatetomodule&#39; and<br>&gt; &#39;privatetofile&#39;.<br>&gt;<br>&gt; This is &#39;private(module)&#39; and &#39;private(file)&#39; but fitting the all<br>&gt; lower-case style. It puts &#39;private&#39; first (and when you use the keyword,<br>&gt; &#39;private&#39; is the bit you want to start with more than &#39;module&#39; or &#39;file&#39;).<br>&gt; It&#39;s easier to use in conversation (&quot;these properties are private to the<br>&gt; file&quot;).<br>&gt; Disadvantage: it adds &#39;to&#39;, so the words are even longer (but no longer<br>&gt; than the parenthesised form would&#39;ve taken).<br>&gt;<br>&gt; &#39;privatetofile extension Foo : BarConvertible { }&#39;<br>&gt;<br>&gt; On Fri, Mar 25, 2016 at 4:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think it does. `module` could mean many things related to how Swift<br>&gt;&gt; creates and consumes modules.<br>&gt;&gt; `moduleprivate` combines something about access levels (public/private)<br>&gt;&gt; and scope (module), is easy to<br>&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it<br>&gt;&gt; is less flexible in meaning and<br>&gt;&gt; more fixed in purpose.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site<br>&gt;&gt; for something that&#39;s actually pretty common? Is it worth the muddled mess<br>&gt;&gt; of an all-lowercase keyword with no obvious break, or the<br>&gt;&gt; attention-grabbing of a capital letter or an underscore?<br>&gt;&gt;<br>&gt;&gt; `module` and `file` are not going to be obscure corners of the language.<br>&gt;&gt; Most people will probably learn about them at the same time they learn<br>&gt;&gt; about `public` and `private`.<br>&gt;&gt;<br>&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t<br>&gt;&gt; see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t<br>&gt;&gt; be as easily confused with a declaration.)<br>&gt;&gt;<br>&gt;&gt; Obviousness for new users is great, but you can take it too far. We call<br>&gt;&gt; the type `Int32`, not<br>&gt;&gt; `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and<br>&gt;&gt; if we did, it&#39;s not clear the longer name would really be more obvious,<br>&gt;&gt; because it would be such a pain to read.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; `moduleprivate` is the default value. I doubt it will get  used much if<br>&gt;&gt; at all. I don&#39;t think `fileprivate` will get used much either<br>&gt;&gt; but in such cases, I think those seven extra letters are essential and<br>&gt;&gt; documenting.<br>&gt;&gt;<br>&gt;&gt; The two remaining public and private access levels are simple and<br>&gt;&gt; intuitively obvious.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t<br>&gt;&gt; believe that these won&#39;t get used, and I don&#39;t want them to feel awkward,<br>&gt;&gt; discouraged, or penalized when they do. The standard library, for example,<br>&gt;&gt; has in its style guide that all access control should be explicit, which is<br>&gt;&gt; a reasonable style to enforce. I also have a small concern that they won&#39;t<br>&gt;&gt; be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or<br>&gt;&gt; module-private?&quot; &quot;neither, just private-private&quot;.<br>&gt;&gt;<br>&gt;&gt; I realize these are all vague concerns, and I don&#39;t have something more<br>&gt;&gt; concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be<br>&gt;&gt; very literally accurate but (a) would force people to learn what &quot;scoped&quot;<br>&gt;&gt; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt;&gt;<br>&gt;&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound<br>&gt;&gt; like there&#39;s one copy of the variable shared in the entire file, even when<br>&gt;&gt; applied to an instance property. I think there&#39;s a lot of value is making<br>&gt;&gt; the access control terms adjectives.<br>&gt;&gt;<br>&gt;&gt; I honestly still think &quot;public, internal, private, local&quot; is a better<br>&gt;&gt; taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically<br>&gt;&gt; ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re<br>&gt;&gt; all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to<br>&gt;&gt; read or to use in conversation. But both the core team and the list<br>&gt;&gt; disagree, mainly because (a) it aligns &#39;private&#39; more closely with other<br>&gt;&gt; languages, and (b) if you&#39;re not thinking about it, more restrictive is<br>&gt;&gt; better than less. (Both of which I agree are good ideas.)<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/67119071/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 25, 2016, at 9:46, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Well, several prominent voices seem to think that &#39;private&#39; is &quot;intuitively obvious&quot; when it refers to declaration-level scope, so I didn&#39;t argue that point. I still happen to disagree; I would add &#39;privatetodeclaration&#39; to &#39;privatetomodule&#39; and &#39;privatetofile&#39;, which would solve that conversational point: &quot;These properties are private to the declaration&quot;.<br>&gt; <br>&gt; Alternatively: &#39;fileaccessible&#39;, &#39;moduleaccessible&#39;, &#39;declarationaccessible&#39;? (Does that confuse code accessibility with such things as UIAccessibility?)<br></p><p>Just on this point, yes, we&#39;ve been advised to avoid the word &quot;accessibility&quot; in the past. We&#39;re deliberately using &quot;access control&quot; and &quot;access&quot;; &quot;accessible&quot; is kind of on the line.<br></p><p>(We&#39;re not using &quot;visible&quot; because whether something is &quot;visible&quot; depends on the use site, whereas access level is a characteristic of the declaration only.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/ef8fd072/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>This problem would be real only if this was new terminology in general (and<br>even then, I&#39;d say plain private means as private as it can be). But for<br>most people for whom Swift is not the first programming language, it has a<br>well defined meaning. This came up many times during discussions, and<br>before the review I always replied that unfortunately the right name is<br>already taken.<br></p><p>I can see that it could take a little adjustment for some people, but for<br>me, even now, when I write private in code, I always have to remind myself<br>that it doesn&#39;t mean what I think it means. I am sure that there are a lot<br>of people who feel the same way (especially the ones not on this mailing<br>list). For them, it would only resolve an ambiguity and not introduce a new<br>one.<br></p><p>On Fri, Mar 25, 2016 at 12:29 PM Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It doesn&#39;t solve the problem for me. &quot;These properties are private.&quot; &quot;To<br>&gt; what?&quot; &quot;Just private&quot; / &quot;To the scope&quot;.<br>&gt;<br>&gt; They&#39;re also still awkward to read in code. I know we have lots of decl<br>&gt; modifiers, but I&#39;ve convinced myself we&#39;re not in Java&#39;s &quot;public static<br>&gt; void main&quot; soup situation yet.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 25, 2016, at 9:27 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Well... how about we reverse the terms: call them &#39;privatetomodule&#39; and<br>&gt; &#39;privatetofile&#39;.<br>&gt;<br>&gt; This is &#39;private(module)&#39; and &#39;private(file)&#39; but fitting the all<br>&gt; lower-case style. It puts &#39;private&#39; first (and when you use the keyword,<br>&gt; &#39;private&#39; is the bit you want to start with more than &#39;module&#39; or &#39;file&#39;).<br>&gt; It&#39;s easier to use in conversation (&quot;these properties are private to the<br>&gt; file&quot;).<br>&gt; Disadvantage: it adds &#39;to&#39;, so the words are even longer (but no longer<br>&gt; than the parenthesised form would&#39;ve taken).<br>&gt;<br>&gt; &#39;privatetofile extension Foo : BarConvertible { }&#39;<br>&gt;<br>&gt; On Fri, Mar 25, 2016 at 4:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think it does. `module` could mean many things related to how Swift<br>&gt;&gt; creates and consumes modules.<br>&gt;&gt; `moduleprivate` combines something about access levels (public/private)<br>&gt;&gt; and scope (module), is easy to<br>&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it<br>&gt;&gt; is less flexible in meaning and<br>&gt;&gt; more fixed in purpose.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site<br>&gt;&gt; for something that&#39;s actually pretty common? Is it worth the muddled mess<br>&gt;&gt; of an all-lowercase keyword with no obvious break, or the<br>&gt;&gt; attention-grabbing of a capital letter or an underscore?<br>&gt;&gt;<br>&gt;&gt; `module` and `file` are not going to be obscure corners of the language.<br>&gt;&gt; Most people will probably learn about them at the same time they learn<br>&gt;&gt; about `public` and `private`.<br>&gt;&gt;<br>&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t<br>&gt;&gt; see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t<br>&gt;&gt; be as easily confused with a declaration.)<br>&gt;&gt;<br>&gt;&gt; Obviousness for new users is great, but you can take it too far. We call<br>&gt;&gt; the type `Int32`, not<br>&gt;&gt; `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and<br>&gt;&gt; if we did, it&#39;s not clear the longer name would really be more obvious,<br>&gt;&gt; because it would be such a pain to read.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; `moduleprivate` is the default value. I doubt it will get  used much if<br>&gt;&gt; at all. I don&#39;t think `fileprivate` will get used much either<br>&gt;&gt; but in such cases, I think those seven extra letters are essential and<br>&gt;&gt; documenting.<br>&gt;&gt;<br>&gt;&gt; The two remaining public and private access levels are simple and<br>&gt;&gt; intuitively obvious.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t<br>&gt;&gt; believe that these won&#39;t get used, and I don&#39;t want them to feel awkward,<br>&gt;&gt; discouraged, or penalized when they do. The standard library, for example,<br>&gt;&gt; has in its style guide that all access control should be explicit, which is<br>&gt;&gt; a reasonable style to enforce. I also have a small concern that they won&#39;t<br>&gt;&gt; be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or<br>&gt;&gt; module-private?&quot; &quot;neither, just private-private&quot;.<br>&gt;&gt;<br>&gt;&gt; I realize these are all vague concerns, and I don&#39;t have something more<br>&gt;&gt; concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be<br>&gt;&gt; very literally accurate but (a) would force people to learn what &quot;scoped&quot;<br>&gt;&gt; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt;&gt;<br>&gt;&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound<br>&gt;&gt; like there&#39;s one copy of the variable shared in the entire file, even when<br>&gt;&gt; applied to an instance property. I think there&#39;s a lot of value is making<br>&gt;&gt; the access control terms adjectives.<br>&gt;&gt;<br>&gt;&gt; I honestly still think &quot;public, internal, private, local&quot; is a better<br>&gt;&gt; taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically<br>&gt;&gt; ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re<br>&gt;&gt; all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to<br>&gt;&gt; read or to use in conversation. But both the core team and the list<br>&gt;&gt; disagree, mainly because (a) it aligns &#39;private&#39; more closely with other<br>&gt;&gt; languages, and (b) if you&#39;re not thinking about it, more restrictive is<br>&gt;&gt; better than less. (Both of which I agree are good ideas.)<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/59c524ac/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>March 25, 2016 at 07:00:00pm</p></header><div class="content"><p>You perfectly articulated what I&#39;ve been trying to say and I agree 100% with your concerns. <br></p><p>While we are in a minority, I think it&#39;s important to consider how the use of private in three keywords could become confusing to people learning the language and even just in a slight mental lapse while coding: &quot;wait what kind of private do I need?&quot;<br></p><p>Brandon <br></p><p>&gt; On Mar 25, 2016, at 12:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 16:20 , Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:13 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it does. `module` could mean many things related to how Swift creates and consumes modules. <br>&gt;&gt;&gt;&gt; `moduleprivate` combines something about access levels (public/private) and scope (module), is easy to <br>&gt;&gt;&gt;&gt; Google, offers few &quot;wrong&quot; interpretations. By using a longer keyword, it is less flexible in meaning and <br>&gt;&gt;&gt;&gt; more fixed in purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common? Is it worth the muddled mess of an all-lowercase keyword with no obvious break, or the attention-grabbing of a capital letter or an underscore?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `module` and `file` are not going to be obscure corners of the language. Most people will probably learn about them at the same time they learn about `public` and `private`. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Actually, if `module` continues to be the default, you probably won&#39;t see it *that* often. You *will* see `file`, but that&#39;s the one that can&#39;t be as easily confused with a declaration.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviousness for new users is great, but you can take it too far. We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`—and if we did, it&#39;s not clear the longer name would really be more obvious, because it would be such a pain to read.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; `moduleprivate` is the default value. I doubt it will get  used much if at all. I don&#39;t think `fileprivate` will get used much either<br>&gt;&gt; but in such cases, I think those seven extra letters are essential and documenting.<br>&gt;&gt; <br>&gt;&gt; The two remaining public and private access levels are simple and intuitively obvious.<br>&gt; <br>&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t believe that these won&#39;t get used, and I don&#39;t want them to feel awkward, discouraged, or penalized when they do. The standard library, for example, has in its style guide that all access control should be explicit, which is a reasonable style to enforce. I also have a small concern that they won&#39;t be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or module-private?&quot; &quot;neither, just private-private&quot;.<br>&gt; <br>&gt; I realize these are all vague concerns, and I don&#39;t have something more concrete—or a better alternative. &quot;modulescoped&quot; and &quot;filescoped&quot; would be very literally accurate but (a) would force people to learn what &quot;scoped&quot; means unnecessarily, and (b) aren&#39;t less awkward.<br>&gt; <br>&gt; I agree with the concerns that just saying &quot;file var foo&quot; makes it sound like there&#39;s one copy of the variable shared in the entire file, even when applied to an instance property. I think there&#39;s a lot of value is making the access control terms adjectives.<br>&gt; <br>&gt; I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/80d0f760/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br></p><p>If we&#39;re not married to &quot;private&quot; being the most private access level, I think there is a word that implies more privacy than &quot;private&quot;: &quot;secret&quot;. Something that&#39;s private is often still shared with trusted people, but something that&#39;s secret is very carefully protected indeed. &quot;Three may keep a secret, if two of them are dead.&quot;<br></p><p>So then our four access levels would be:<br></p><p>* public<br>* internal<br>* private<br>* secret<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 26, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, Mar 25, 2016 at 4:57 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I honestly still think &quot;public, internal, private, local&quot; is a better<br>&gt; taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically<br>&gt; ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re<br>&gt; all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to<br>&gt; read or to use in conversation. But both the core team and the list<br>&gt; disagree, mainly because (a) it aligns &#39;private&#39; more closely with other<br>&gt; languages, and (b) if you&#39;re not thinking about it, more restrictive is<br>&gt; better than less. (Both of which I agree are good ideas.)<br>&gt;<br>&gt; If we&#39;re not married to &quot;private&quot; being the most private access level, I<br>&gt; think there is a word that implies more privacy than &quot;private&quot;: &quot;secret&quot;.<br>&gt; Something that&#39;s private is often still shared with trusted people, but<br>&gt; something that&#39;s secret is very carefully protected indeed. &quot;Three may keep<br>&gt; a secret, if two of them are dead.&quot;<br>&gt;<br>&gt; So then our four access levels would be:<br>&gt;<br>&gt; * public<br>&gt; * internal<br>&gt; * private<br>&gt; * secret<br>&gt;<br></p><p>I can support that and do like the word &#39;secret&#39;. I am fine with keeping<br>&#39;private&#39; the same as it currently is even if it different from other<br>languages (since it already does).<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/206242a1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 25, 2016 at 07:00:00pm</p></header><div class="content"><p>I like that very much. I like that all four access levels are<br>described by single words, that they are adjectives, that they obviate<br>the &quot;private private&quot; problem described by Jordan, and that their<br>relative level ordering is (IMO) obvious by the usual meaning of the<br>words.<br></p><p><br>On Fri, Mar 25, 2016 at 6:56 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I honestly still think &quot;public, internal, private, local&quot; is a better taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to read or to use in conversation. But both the core team and the list disagree, mainly because (a) it aligns &#39;private&#39; more closely with other languages, and (b) if you&#39;re not thinking about it, more restrictive is better than less. (Both of which I agree are good ideas.)<br>&gt;<br>&gt; If we&#39;re not married to &quot;private&quot; being the most private access level, I think there is a word that implies more privacy than &quot;private&quot;: &quot;secret&quot;. Something that&#39;s private is often still shared with trusted people, but something that&#39;s secret is very carefully protected indeed. &quot;Three may keep a secret, if two of them are dead.&quot;<br>&gt;<br>&gt; So then our four access levels would be:<br>&gt;<br>&gt; * public<br>&gt; * internal<br>&gt; * private<br>&gt; * secret<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 26, 2016 at 12:00:00am</p></header><div class="content"><p>all of these names (public, internal, private, local) have specific meaning<br>in the context of computer languages. I think that we should use standard<br>terms and give them the expected meaning. I did not do this originally with<br>SE-0025 and suggested &quot;scoped&quot; because I thought that &quot;private&quot; could not<br>be changed. But since it can, we should definitely use it, and give it the<br>meaning that most people expect.<br></p><p>On Fri, Mar 25, 2016 at 7:57 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I honestly still think &quot;public, internal, private, local&quot; is a better<br>&gt; taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically<br>&gt; ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re<br>&gt; all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to<br>&gt; read or to use in conversation. But both the core team and the list<br>&gt; disagree, mainly because (a) it aligns &#39;private&#39; more closely with other<br>&gt; languages, and (b) if you&#39;re not thinking about it, more restrictive is<br>&gt; better than less. (Both of which I agree are good ideas.)<br>&gt;<br>&gt; If we&#39;re not married to &quot;private&quot; being the most private access level, I<br>&gt; think there is a word that implies more privacy than &quot;private&quot;: &quot;secret&quot;.<br>&gt; Something that&#39;s private is often still shared with trusted people, but<br>&gt; something that&#39;s secret is very carefully protected indeed. &quot;Three may keep<br>&gt; a secret, if two of them are dead.&quot;<br>&gt;<br>&gt; So then our four access levels would be:<br>&gt;<br>&gt; * public<br>&gt; * internal<br>&gt; * private<br>&gt; * secret<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/104d3f40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 26, 2016 at 01:00:00am</p></header><div class="content"><p>I am sure that fileprivate is very useful. SE-0025 did not ask to remove it.<br></p><p>On Fri, Mar 25, 2016 at 8:57 PM Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>wrote:<br></p><p>&gt; all of these names (public, internal, private, local) have specific<br>&gt; meaning in the context of computer languages. I think that we should use<br>&gt; standard terms and give them the expected meaning. I did not do this<br>&gt; originally with SE-0025 and suggested &quot;scoped&quot; because I thought that<br>&gt; &quot;private&quot; could not be changed. But since it can, we should definitely use<br>&gt; it, and give it the meaning that most people expect.<br>&gt;<br>&gt;<br>&gt; On Fri, Mar 25, 2016 at 7:57 PM Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; I honestly still think &quot;public, internal, private, local&quot; is a better<br>&gt;&gt; taxonomy.. It&#39;s true that &quot;internal&quot; and &quot;private&quot; aren&#39;t automatically<br>&gt;&gt; ordered relative to each other (and maybe not even &quot;local&quot;), but they&#39;re<br>&gt;&gt; all adjectives (unlike &quot;module&quot; and &quot;file&quot;), and they&#39;re not awkward to<br>&gt;&gt; read or to use in conversation. But both the core team and the list<br>&gt;&gt; disagree, mainly because (a) it aligns &#39;private&#39; more closely with other<br>&gt;&gt; languages, and (b) if you&#39;re not thinking about it, more restrictive is<br>&gt;&gt; better than less. (Both of which I agree are good ideas.)<br>&gt;&gt;<br>&gt;&gt; If we&#39;re not married to &quot;private&quot; being the most private access level, I<br>&gt;&gt; think there is a word that implies more privacy than &quot;private&quot;: &quot;secret&quot;.<br>&gt;&gt; Something that&#39;s private is often still shared with trusted people, but<br>&gt;&gt; something that&#39;s secret is very carefully protected indeed. &quot;Three may keep<br>&gt;&gt; a secret, if two of them are dead.&quot;<br>&gt;&gt;<br>&gt;&gt; So then our four access levels would be:<br>&gt;&gt;<br>&gt;&gt; * public<br>&gt;&gt; * internal<br>&gt;&gt; * private<br>&gt;&gt; * secret<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/a6d2185e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; all of these names (public, internal, private, local) have specific meaning in the context of computer languages.<br></p><p>Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s an access level. It usually has something to do with declaring variables inside a function.<br></p><p>For instance, Perl uses it to back up and restore a global variable. ML uses it to create a scope (roughly). Lua and Julia use it to declare lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new access level is specifically *not* supposed to allow.<br></p><p>I don&#39;t know of any language where `local` is used as an access level. If you&#39;re aware of an analogous use in another language, I&#39;d be interested to see it. But the examples I&#39;ve found if anything *undermine* the suggestion that `local` would be a good keyword choice.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 26, 2016 at 01:00:00am</p></header><div class="content"><p>The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages<br>refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and<br>Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent<br>to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br></p><p>Possibly my familiarity with other languages isn&#39;t broad enough, but this<br>is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is<br>&quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding<br>in Swift, you don&#39;t learn these meanings anywhere else first.<br></p><p>To use a hopefully recognised example: an American who wants &#39;chips&#39; wants<br>what a Brit calls crisps; a Brit who wants chips wants what an American<br>calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the<br>one you grew up with.<br></p><p>On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; all of these names (public, internal, private, local) have specific<br>&gt; meaning in the context of computer languages.<br>&gt;<br>&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s<br>&gt; an access level. It usually has something to do with declaring variables<br>&gt; inside a function.<br>&gt;<br>&gt; For instance, Perl uses it to back up and restore a global variable. ML<br>&gt; uses it to create a scope (roughly). Lua and Julia use it to declare<br>&gt; lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new<br>&gt; access level is specifically *not* supposed to allow.<br>&gt;<br>&gt; I don&#39;t know of any language where `local` is used as an access level. If<br>&gt; you&#39;re aware of an analogous use in another language, I&#39;d be interested to<br>&gt; see it. But the examples I&#39;ve found if anything *undermine* the suggestion<br>&gt; that `local` would be a good keyword choice.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/489aebfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 25, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;ll throw another suggestion into the ring:<br></p><p>private (scoped access)<br>public (file access)<br>internal (module access)<br>external (infinity and beyond)<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Mar 25, 2016, at 8:57 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt; <br>&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt; <br>&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants what a Brit calls crisps; a Brit who wants chips wants what an American calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the one you grew up with.<br>&gt; <br>&gt;&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; all of these names (public, internal, private, local) have specific meaning in the context of computer languages.<br>&gt;&gt; <br>&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s an access level. It usually has something to do with declaring variables inside a function.<br>&gt;&gt; <br>&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML uses it to create a scope (roughly). Lua and Julia use it to declare lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new access level is specifically *not* supposed to allow.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If you&#39;re aware of an analogous use in another language, I&#39;d be interested to see it. But the examples I&#39;ve found if anything *undermine* the suggestion that `local` would be a good keyword choice.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/98ce70fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 26, 2016 at 10:00:00am</p></header><div class="content"><p>The word &#39;external&#39; is growing on me but as the (module access). <br></p><p>public (unchanged)<br>external (module access)<br>internal (file access)<br>private (scoped access)<br></p><p>module access = has external access from other files in the module. <br>file access = has internal access to current file<br>scope access = has only access to the current scope. <br></p><p>Private will align with other languages definition of private. <br>I don&#39;t think public should change and I don&#39;t like all the others to be called private(levelofprivacy).<br></p><p><br></p><p><br>&gt; On Mar 25, 2016, at 7:32 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ll throw another suggestion into the ring:<br>&gt; <br>&gt; private (scoped access)<br>&gt; public (file access)<br>&gt; internal (module access)<br>&gt; external (infinity and beyond)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 8:57 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt;&gt; <br>&gt;&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt;&gt; <br>&gt;&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants what a Brit calls crisps; a Brit who wants chips wants what an American calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the one you grew up with.<br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; all of these names (public, internal, private, local) have specific meaning in the context of computer languages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s an access level. It usually has something to do with declaring variables inside a function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML uses it to create a scope (roughly). Lua and Julia use it to declare lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new access level is specifically *not* supposed to allow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If you&#39;re aware of an analogous use in another language, I&#39;d be interested to see it. But the examples I&#39;ve found if anything *undermine* the suggestion that `local` would be a good keyword choice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/62ce3204/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 26, 2016 at 12:00:00am</p></header><div class="content"><p>I agree with Ross. Swift already redefined the common access modifiers meanings. <br>Why not use the word &#39;protected&#39; to mean &#39;local&#39;?<br></p><p>public<br>internal<br>private<br>protected // Java got it wrong. :) This is &quot;protected&quot; against extensions.  <br></p><p>&gt; On Mar 25, 2016, at 6:57 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt; <br>&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt; <br>&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants what a Brit calls crisps; a Brit who wants chips wants what an American calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the one you grew up with.<br>&gt; <br>&gt;&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; all of these names (public, internal, private, local) have specific meaning in the context of computer languages.<br>&gt;&gt; <br>&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s an access level. It usually has something to do with declaring variables inside a function.<br>&gt;&gt; <br>&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML uses it to create a scope (roughly). Lua and Julia use it to declare lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new access level is specifically *not* supposed to allow.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If you&#39;re aware of an analogous use in another language, I&#39;d be interested to see it. But the examples I&#39;ve found if anything *undermine* the suggestion that `local` would be a good keyword choice.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/3ad62a41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 26, 2016 at 09:00:00am</p></header><div class="content"><p>I can’t find a reply that seemed to cover this so I’d like to ask again, but why just you a parameter on private for all hidden visibility types? i.e-<br></p><p>	public			(current meaning of public)<br>	private (module)	(current meaning of internal)<br>	private (type)		(new scoped visibility, could be named scoped instead but I prefer type personally)<br>	private (file)		(current meaning of private)<br></p><p>This eliminates the need for an additional keyword, and actually trims internal as well, plus all visibility is then either public (externally accessible) or private (internally accessible with some degree of restriction). When used without a parameter private on its own would now default to private (type).<br></p><p>The ability to place a visibility restriction only upon a getter/setter would be handled as a parameter value, for example:<br></p><p>	private (file: set)			(value can only be set within this file)<br>	private (type: get, file: set)	(value is accessible within type, sub-types and extensions, but can only be set within this file)<br></p><p>I think it’s a very neat way to do things, and I think that for most cases private (type), the new default for private, is sufficient for a lot of use-cases. More importantly it eliminates the need for new keywords, actually trims one (we only need two for visibility not four) and also eliminates the need to find good single-word keywords that make sense on their own, since all limited types are explicitly grouped as private which should make it absolutely clear.<br></p><p>&gt; On 26 Mar 2016, at 07:14, Cheyo Ximenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with Ross. Swift already redefined the common access modifiers meanings. <br>&gt; Why not use the word &#39;protected&#39; to mean &#39;local&#39;?<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; private<br>&gt; protected // Java got it wrong. :) This is &quot;protected&quot; against extensions.  <br>&gt; <br>&gt; On Mar 25, 2016, at 6:57 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt;&gt; <br>&gt;&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt;&gt; <br>&gt;&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants what a Brit calls crisps; a Brit who wants chips wants what an American calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the one you grew up with.<br>&gt;&gt; <br>&gt;&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; all of these names (public, internal, private, local) have specific meaning in the context of computer languages.<br>&gt;&gt; <br>&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s an access level. It usually has something to do with declaring variables inside a function.<br>&gt;&gt; <br>&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML uses it to create a scope (roughly). Lua and Julia use it to declare lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new access level is specifically *not* supposed to allow.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If you&#39;re aware of an analogous use in another language, I&#39;d be interested to see it. But the examples I&#39;ve found if anything *undermine* the suggestion that `local` would be a good keyword choice.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/9e79f3d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Haravikk: private (type) would be the subject of another proposal.<br></p><p>What this proposal is about is the following (all in one file):<br></p><p>struct Foo {<br>    func doThing() {<br>        doPrivateThing()<br>    }<br></p><p>    private func doPrivateThing() { }<br>}<br></p><p>extension Foo {<br>    func doOtherThing() {<br>        doPrivateThing()<br>    }<br></p><p>    private func doPrivateThing() { }<br>}<br></p><p>There would be two functions called doPrivateThing(). The first is private<br>to the struct declaration; the second to the extension. There&#39;s no conflict<br>between them.<br></p><p>What you suggest would be a proposal of its own - it would have to be,<br>because types can be extended outside of their original modules, which<br>would beg the question of whether a property could actually be a &#39;public<br>(type)&#39; rather than a &#39;private (type)&#39;.<br></p><p>The reason we continue to have confusion about this (I&#39;m guilty of this<br>too) is because &quot;private&quot; has a standard meaning in many languages and a<br>non-standard meaning in Swift.<br></p><p>Chris Lattner&#39;s explained the reasoning about conjoined keywords in a few<br>places I think, but the posts from this thread are here:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013261.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013439.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013463.html<br></p><p><br>On Sat, Mar 26, 2016 at 9:13 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt; I can’t find a reply that seemed to cover this so I’d like to ask again,<br>&gt; but why just you a parameter on private for all hidden visibility types?<br>&gt; i.e-<br>&gt;<br>&gt; public (current meaning of public)<br>&gt; private (module) (current meaning of internal)<br>&gt; private (type) (new scoped visibility, could be named scoped instead but<br>&gt; I prefer type personally)<br>&gt; private (file) (current meaning of private)<br>&gt;<br>&gt; This eliminates the need for an additional keyword, and actually trims<br>&gt; internal as well, plus all visibility is then either public (externally<br>&gt; accessible) or private (internally accessible with some degree of<br>&gt; restriction). When used without a parameter private on its own would now<br>&gt; default to private (type).<br>&gt;<br>&gt; The ability to place a visibility restriction only upon a getter/setter<br>&gt; would be handled as a parameter value, for example:<br>&gt;<br>&gt; private (file: set) (value can only be set within this file)<br>&gt; private (type: get, file: set) (value is accessible within type,<br>&gt; sub-types and extensions, but can only be set within this file)<br>&gt;<br>&gt; I think it’s a very neat way to do things, and I think that for most cases<br>&gt; private (type), the new default for private, is sufficient for a lot of<br>&gt; use-cases. More importantly it eliminates the need for new keywords,<br>&gt; actually trims one (we only need two for visibility not four) and also<br>&gt; eliminates the need to find good single-word keywords that make sense on<br>&gt; their own, since all limited types are explicitly grouped as private which<br>&gt; should make it absolutely clear.<br>&gt;<br>&gt; On 26 Mar 2016, at 07:14, Cheyo Ximenez via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree with Ross. Swift already redefined the common access modifiers<br>&gt; meanings.<br>&gt; Why not use the word &#39;protected&#39; to mean &#39;local&#39;?<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; private<br>&gt; protected // Java got it wrong. :) This is &quot;protected&quot; against extensions.<br>&gt;<br>&gt;<br>&gt; On Mar 25, 2016, at 6:57 PM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages<br>&gt; refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and<br>&gt; Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent<br>&gt; to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt;<br>&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this<br>&gt; is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is<br>&gt; &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding<br>&gt; in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt;<br>&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants<br>&gt; what a Brit calls crisps; a Brit who wants chips wants what an American<br>&gt; calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the<br>&gt; one you grew up with.<br>&gt;<br>&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; all of these names (public, internal, private, local) have specific<br>&gt;&gt; meaning in the context of computer languages.<br>&gt;&gt;<br>&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s<br>&gt;&gt; an access level. It usually has something to do with declaring variables<br>&gt;&gt; inside a function.<br>&gt;&gt;<br>&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML<br>&gt;&gt; uses it to create a scope (roughly). Lua and Julia use it to declare<br>&gt;&gt; lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new<br>&gt;&gt; access level is specifically *not* supposed to allow.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If<br>&gt;&gt; you&#39;re aware of an analogous use in another language, I&#39;d be interested to<br>&gt;&gt; see it. But the examples I&#39;ve found if anything *undermine* the suggestion<br>&gt;&gt; that `local` would be a good keyword choice.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/fe610b67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 26 Mar 2016, at 14:11, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Haravikk: private (type) would be the subject of another proposal.<br>&gt; <br>&gt; What this proposal is about is the following (all in one file):<br>&gt; <br>&gt; struct Foo {<br>&gt;     func doThing() {<br>&gt;         doPrivateThing()<br>&gt;     }<br>&gt; <br>&gt;     private func doPrivateThing() { }<br>&gt; }<br>&gt; <br>&gt; extension Foo {<br>&gt;     func doOtherThing() {<br>&gt;         doPrivateThing()<br>&gt;     }<br>&gt; <br>&gt;     private func doPrivateThing() { }<br>&gt; }<br>&gt; <br>&gt; There would be two functions called doPrivateThing(). The first is private to the struct declaration; the second to the extension. There&#39;s no conflict between them.<br></p><p>I wasn’t actually trying to propose a new form of visibility, but the keyword discussion keeps coming up on various types of visibility so I guess I’m just getting confused with my terminology in these cases. My point was to re-raise the private(foo) style rather than cover some other type of visibility. It also doesn’t help that everyone has different names on what everything should named, but then that’s partly the point I was trying to make =D<br></p><p>&gt; The reason we continue to have confusion about this (I&#39;m guilty of this too) is because &quot;private&quot; has a standard meaning in many languages and a non-standard meaning in Swift.<br>&gt; <br>&gt; Chris Lattner&#39;s explained the reasoning about conjoined keywords in a few places I think, but the posts from this thread are here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013261.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013261.html&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013439.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013439.html&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013463.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013463.html&gt;<br>Thanks for linking these, but I really don’t like any of the proposed conjoined keywords any more than I like the suggested single-word alternatives, which is why I really feel that the parenthesised restriction is a much better style, as we can argue forever on what the best new visibility keywords and nothing will be good enough IMO. The parenthesised style however means that we not only avoid keyword bloat, we would actually remove one, plus we get the same benefit to clarity of having two-word visibility without the nastiness of the various conjoined options I’ve seen so far.<br></p><p>Other than it being “weird and awkward” I don’t see any real reasons why we can’t just the private(foo) style; it’s not really more awkward than a conjoined keyword, and I think that the logical grouping is worth it being a bit different. In fact, in the first linked post Chris points out that well chosen public/private defaults should be all that most people need, so you only need the parenthesis for the more unusual cases which I think makes it ideal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/debf66dc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 27, 2016 at 04:00:00pm</p></header><div class="content"><p>I like the idea of protected (against extensions).<br>However this raises the question whether extensions are also extensions of scope.<br></p><p><br>Can &quot;private(scope)&quot; properties/functions be accessed from extensions?<br></p><p><br>In your case:<br>Is &quot;protected&quot; exactly like local? So it doesn&#39;t hide properties from extensions within the file?<br>By making &quot;private&quot; scope based it is less private than &quot;protected&quot; which doesn&#39;t feel right to me. (Assuming extensions extend scope)<br></p><p>In my opinion &quot;protected&quot; should protect against other scopes/classes. Leaving &quot;private&quot; file based.<br></p><p><br>Kind regards<br>- Maximilian<br></p><p>&gt; Am 26.03.2016 um 08:14 schrieb Cheyo Ximenez via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I agree with Ross. Swift already redefined the common access modifiers meanings. <br>&gt; Why not use the word &#39;protected&#39; to mean &#39;local&#39;?<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; private<br>&gt; protected // Java got it wrong. :) This is &quot;protected&quot; against extensions.  <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 6:57 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt;&gt; <br>&gt;&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt;&gt; <br>&gt;&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants what a Brit calls crisps; a Brit who wants chips wants what an American calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the one you grew up with.<br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; all of these names (public, internal, private, local) have specific meaning in the context of computer languages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s an access level. It usually has something to do with declaring variables inside a function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML uses it to create a scope (roughly). Lua and Julia use it to declare lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new access level is specifically *not* supposed to allow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If you&#39;re aware of an analogous use in another language, I&#39;d be interested to see it. But the examples I&#39;ve found if anything *undermine* the suggestion that `local` would be a good keyword choice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/7b87d2a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 27, 2016, at 7:21 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I like the idea of protected (against extensions).<br>&gt; However this raises the question whether extensions are also extensions of scope.<br>&gt; <br>&gt; <br>&gt; Can &quot;private(scope)&quot; properties/functions be accessed from extensions?<br>I think the idea is for private-scope / local to not be seen from extensions in other files. I am not sure how that works for same file extensions.  <br>&gt; <br>&gt; In your case:<br>&gt; Is &quot;protected&quot; exactly like local? So it doesn&#39;t hide properties from extensions within the file?<br></p><p>Yes. just like local. <br></p><p>&gt; By making &quot;private&quot; scope based it is less private than &quot;protected&quot; which doesn&#39;t feel right to me. (Assuming extensions extend scope)<br>&gt; <br>&gt; In my opinion &quot;protected&quot; should protect against other scopes/classes. Leaving &quot;private&quot; file based.<br></p><p>In essence there are two ideas floating around in my head:<br>1) give the new local / private-scope a unique name like &#39;secret&#39; or &#39;protected&#39; and keep everything else the same.  <br></p><p>2) redefine this new local / private-scope as just &#39;private&#39;, <br>private-file becomes &#39;internal&#39; , we find a new name for private-module like &#39;external&#39; and we keep public as is. <br></p><p>I&#39;m am now leaning towards number 2. <br></p><p>Public <br>External (default)<br>Internal<br>Private<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/71dc815f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Public <br>&gt; External (default)<br>&gt; Internal<br>&gt; Private<br></p><p>I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br></p><p>	public				as-is, item is public/exported outside of module<br>	private(module) or private	current internal, item is private to this module, would be the default<br>	private(file)			current private, item is private to this file<br>	private(scope)			new visibility type, item is private to the current scope<br></p><p>Assuming I’m understanding the restriction properly this time =)<br></p><p>It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/176147c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 27, 2016 at 11:00:00pm</p></header><div class="content"><p>I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br></p><p>My understanding is that the new private would be: <br>- visible only to the immediately enclosing scope<br>- including the scope of a inner nested scope<br>- not including the scope of an outer nested scope<br>- not visible to an extension <br></p><p>Said in code (all in the same file):<br>----------<br>class Outer { // Outer visible to module<br>    private var a: Int // visible to Outer, Inner1, &amp; Inner2<br></p><p>    class Inner1 { // Inner1 visible to module<br>        private var b: Int // visible to Inner1 only<br>    }<br>    private class Inner2 { // visible to Outer &amp; Inner(s)<br>        var c: Int // visible to Outer &amp; Inner(s)<br>    }<br>}<br></p><p>extension Outer { // visible to module<br>    // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>}<br>----------<br>If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br></p><p>Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br></p><p><br>&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Public <br>&gt;&gt; External (default)<br>&gt;&gt; Internal<br>&gt;&gt; Private<br>&gt; <br>&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt; <br>&gt; 	public				as-is, item is public/exported outside of module<br>&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt; 	private(file)			current private, item is private to this file<br>&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt; <br>&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt; <br>&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/deb5f48a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br></p><p>func f() {<br>  let outer = 0<br> // f cannot use inner<br>   func g() {<br>       let inner = 1<br>       // g can use outer<br>   }<br>}<br></p><p>It would work the same way for the access level. That said, I&#39;d rather not<br>include this in the proposal. The only change that the core team requested<br>was the name changes. I personally would prefer a completely private<br>version where you cannot inject a class into a scope to get access to the<br>scope internals, but it&#39;s an edge case that could be argued either way, and<br>I don&#39;t want to start another lengthy discussion. We already had quite a<br>few.<br></p><p>On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>wrote:<br></p><p>&gt; I know it was suggested that it be the subject of a different thread, but<br>&gt; it might be good to clarify how the new private is going to work (or at<br>&gt; least what is currently envisioned).<br>&gt;<br>&gt; My understanding is that the new private would be:<br>&gt; - visible only to the immediately enclosing scope<br>&gt; - including the scope of a inner nested scope<br>&gt; - not including the scope of an outer nested scope<br>&gt; - not visible to an extension<br>&gt;<br>&gt; Said in code (all in the same file):<br>&gt; ----------<br>&gt; class Outer { // Outer visible to module<br>&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;<br>&gt;     class Inner1 { // Inner1 visible to module<br>&gt;         private var b: Int // visible to Inner1 only<br>&gt;     }<br>&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension Outer { // visible to module<br>&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt; }<br>&gt; ----------<br>&gt; If this is the intended meaning of private, then fileprivate seems to be<br>&gt; the same as private (private to the enclosing scope... which happens to be<br>&gt; the file).<br>&gt;<br>&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt; There would still need to be a way to reference scopes other than the<br>&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;<br>&gt;<br>&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Public<br>&gt; External (default)<br>&gt; Internal<br>&gt; Private<br>&gt;<br>&gt;<br>&gt; I still feel like these are still too vague; I’m not sure I like the use<br>&gt; of external, as public to me is external since it exports outside of the<br>&gt; module, whereas what you’re proposing is in fact just limited to the module<br>&gt; itself. I dislike the current internal keyword too, but at least it reads<br>&gt; as “internal to this module&quot;, this is why the more specific terms are<br>&gt; better like:<br>&gt;<br>&gt; public as-is, item is public/exported outside of module<br>&gt; private(module) or private current internal, item is private to this<br>&gt; module, would be the default<br>&gt; private(file) current private, item is private to this file<br>&gt; private(scope) new visibility type, item is private to the current scope<br>&gt;<br>&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;<br>&gt; It’s also the easiest method if we do add another visibility later for<br>&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/890bb17c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 28, 2016 at 07:00:00am</p></header><div class="content"><p>On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>wrote:<br></p><p>&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt; example:<br>&gt;<br>&gt; func f() {<br>&gt;   let outer = 0<br>&gt;  // f cannot use inner<br>&gt;    func g() {<br>&gt;        let inner = 1<br>&gt;        // g can use outer<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt;<br>Maybe I&#39;m off in my terminology, but I think my code example matches what<br>you are saying here (outer is visible to g() but inner is not visible to f()<br></p><p><br>&gt; It would work the same way for the access level. That said, I&#39;d rather not<br>&gt; include this in the proposal.<br>&gt;<br></p><p>So as the proposal stands now, what is the scope that innerVar is visible<br>to in the following code: Inner or Outer?<br></p><p>class Outer {<br>    class Inner {<br>        private var innerVar: Int<br>    }<br>}<br></p><p><br>&gt; The only change that the core team requested was the name changes. I<br>&gt; personally would prefer a completely private version where you cannot<br>&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt; another lengthy discussion. We already had quite a few.<br>&gt;<br>&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I know it was suggested that it be the subject of a different thread, but<br>&gt;&gt; it might be good to clarify how the new private is going to work (or at<br>&gt;&gt; least what is currently envisioned).<br>&gt;&gt;<br>&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt; - not visible to an extension<br>&gt;&gt;<br>&gt;&gt; Said in code (all in the same file):<br>&gt;&gt; ----------<br>&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;<br>&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;     }<br>&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt; }<br>&gt;&gt; ----------<br>&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be<br>&gt;&gt; the same as private (private to the enclosing scope... which happens to be<br>&gt;&gt; the file).<br>&gt;&gt;<br>&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt;&gt; There would still need to be a way to reference scopes other than the<br>&gt;&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt;&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt;&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt;&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Public<br>&gt;&gt; External (default)<br>&gt;&gt; Internal<br>&gt;&gt; Private<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use<br>&gt;&gt; of external, as public to me is external since it exports outside of the<br>&gt;&gt; module, whereas what you’re proposing is in fact just limited to the module<br>&gt;&gt; itself. I dislike the current internal keyword too, but at least it reads<br>&gt;&gt; as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt; better like:<br>&gt;&gt;<br>&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt; module, would be the default<br>&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt; private(scope) new visibility type, item is private to the current scope<br>&gt;&gt;<br>&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;<br>&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/9dbd7e58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 11:00:00am</p></header><div class="content"><p>Outer<br></p><p>On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; func f() {<br>&gt;&gt;   let outer = 0<br>&gt;&gt;  // f cannot use inner<br>&gt;&gt;    func g() {<br>&gt;&gt;        let inner = 1<br>&gt;&gt;        // g can use outer<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what<br>&gt; you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;<br>&gt;<br>&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt; not include this in the proposal.<br>&gt;&gt;<br>&gt;<br>&gt; So as the proposal stands now, what is the scope that innerVar is visible<br>&gt; to in the following code: Inner or Outer?<br>&gt;<br>&gt; class Outer {<br>&gt;     class Inner {<br>&gt;         private var innerVar: Int<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;<br>&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be<br>&gt;&gt;&gt; the same as private (private to the enclosing scope... which happens to be<br>&gt;&gt;&gt; the file).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt;&gt;&gt; There would still need to be a way to reference scopes other than the<br>&gt;&gt;&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt;&gt;&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt;&gt;&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt;&gt;&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Public<br>&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt; Internal<br>&gt;&gt;&gt; Private<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use<br>&gt;&gt;&gt; of external, as public to me is external since it exports outside of the<br>&gt;&gt;&gt; module, whereas what you’re proposing is in fact just limited to the module<br>&gt;&gt;&gt; itself. I dislike the current internal keyword too, but at least it reads<br>&gt;&gt;&gt; as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt; private(scope) new visibility type, item is private to the current scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/115b63f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 28, 2016 at 08:00:00am</p></header><div class="content"><p>That is not clear to me in the proposal.  The proposal states: &quot;When a<br>function or a property is defined with `private` access modifier, it is<br>visible only within that lexical scope.&quot; The most immediate lexical scope<br>for innerVar would be Inner.<br></p><p>I&#39;m not advocating either way, just that it be clear in the proposal.<br></p><p>On Mon, Mar 28, 2016 at 7:48 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>wrote:<br></p><p>&gt; Outer<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what<br>&gt;&gt; you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt;&gt; not include this in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible<br>&gt;&gt; to in the following code: Inner or Outer?<br>&gt;&gt;<br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to<br>&gt;&gt;&gt;&gt; be the same as private (private to the enclosing scope... which happens to<br>&gt;&gt;&gt;&gt; be the file).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt;&gt;&gt;&gt; There would still need to be a way to reference scopes other than the<br>&gt;&gt;&gt;&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt;&gt;&gt;&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt;&gt;&gt;&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt;&gt;&gt;&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Public<br>&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the<br>&gt;&gt;&gt;&gt; use of external, as public to me is external since it exports outside of<br>&gt;&gt;&gt;&gt; the module, whereas what you’re proposing is in fact just limited to the<br>&gt;&gt;&gt;&gt; module itself. I dislike the current internal keyword too, but at least it<br>&gt;&gt;&gt;&gt; reads as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt;&gt; private(scope) new visibility type, item is private to the current<br>&gt;&gt;&gt;&gt; scope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/00628eed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>After replying and seeing it in code, it felt so wrong, that I am updating<br>the proposal now. It should be Inner only.<br></p><p>On Mon, Mar 28, 2016 at 8:11 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>wrote:<br></p><p>&gt; That is not clear to me in the proposal.  The proposal states: &quot;When a<br>&gt; function or a property is defined with `private` access modifier, it is<br>&gt; visible only within that lexical scope.&quot; The most immediate lexical scope<br>&gt; for innerVar would be Inner.<br>&gt;<br>&gt; I&#39;m not advocating either way, just that it be clear in the proposal.<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 7:48 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Outer<br>&gt;&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt;&gt;&gt; example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches<br>&gt;&gt;&gt; what you are saying here (outer is visible to g() but inner is not visible<br>&gt;&gt;&gt; to f()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt;&gt;&gt; not include this in the proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So as the proposal stands now, what is the scope that innerVar is<br>&gt;&gt;&gt; visible to in the following code: Inner or Outer?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;     class Inner {<br>&gt;&gt;&gt;         private var innerVar: Int<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt;&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt;&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt;&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt;&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to<br>&gt;&gt;&gt;&gt;&gt; be the same as private (private to the enclosing scope... which happens to<br>&gt;&gt;&gt;&gt;&gt; be the file).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is<br>&gt;&gt;&gt;&gt;&gt; fileprivate. There would still need to be a way to reference scopes other<br>&gt;&gt;&gt;&gt;&gt; than the immediate one (especially since there is no way to say &quot;private&quot;<br>&gt;&gt;&gt;&gt;&gt; and mean moduleprivate), though I think it would strengthen the argument<br>&gt;&gt;&gt;&gt;&gt; for something along the lines of &quot;private(file)&quot;, since it would even<br>&gt;&gt;&gt;&gt;&gt; further reduce the cases where you are spelling something more than just<br>&gt;&gt;&gt;&gt;&gt; &quot;private&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Public<br>&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the<br>&gt;&gt;&gt;&gt;&gt; use of external, as public to me is external since it exports outside of<br>&gt;&gt;&gt;&gt;&gt; the module, whereas what you’re proposing is in fact just limited to the<br>&gt;&gt;&gt;&gt;&gt; module itself. I dislike the current internal keyword too, but at least it<br>&gt;&gt;&gt;&gt;&gt; reads as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt;&gt;&gt; private(scope) new visibility type, item is private to the current<br>&gt;&gt;&gt;&gt;&gt; scope<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/4732a122/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 28, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Mar 28, 2016, at 6:48 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Outer<br></p><p>Why Outer?  It looks to me like the enclosing lexical scope is Inner, thus innerVar would *not* be visible in Outer, it would only be visible in Inner.<br>&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;  <br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather not include this in the proposal.<br>&gt;&gt; <br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible to in the following code: Inner or Outer?<br>&gt;&gt; <br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I personally would prefer a completely private version where you cannot inject a class into a scope to get access to the scope internals, but it&#39;s an edge case that could be argued either way, and I don&#39;t want to start another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My understanding is that the new private would be: <br>&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt; - not visible to an extension <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Public <br>&gt;&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt;&gt;&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt;&gt;&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/98622f96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Matthew, please take a look at my example with functions (it works today).<br>In terms of scope, it should be the same with classes. I updated the<br>proposal to restrict private to the immediate scope, so with the update, it<br>will be Inner. Please take a look at the proposal. I tried to be very clear<br>about both the meaning and motivation in the proposal example.<br></p><p>On Mon, Mar 28, 2016 at 8:58 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Mar 28, 2016, at 6:48 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Outer<br>&gt;<br>&gt;<br>&gt; Why Outer?  It looks to me like the enclosing lexical scope is Inner, thus<br>&gt; innerVar would *not* be visible in Outer, it would only be visible in Inner.<br>&gt;<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what<br>&gt;&gt; you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt;&gt; not include this in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible<br>&gt;&gt; to in the following code: Inner or Outer?<br>&gt;&gt;<br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to<br>&gt;&gt;&gt;&gt; be the same as private (private to the enclosing scope... which happens to<br>&gt;&gt;&gt;&gt; be the file).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt;&gt;&gt;&gt; There would still need to be a way to reference scopes other than the<br>&gt;&gt;&gt;&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt;&gt;&gt;&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt;&gt;&gt;&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt;&gt;&gt;&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Public<br>&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the<br>&gt;&gt;&gt;&gt; use of external, as public to me is external since it exports outside of<br>&gt;&gt;&gt;&gt; the module, whereas what you’re proposing is in fact just limited to the<br>&gt;&gt;&gt;&gt; module itself. I dislike the current internal keyword too, but at least it<br>&gt;&gt;&gt;&gt; reads as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt;&gt; private(scope) new visibility type, item is private to the current<br>&gt;&gt;&gt;&gt; scope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/decddd73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 28, 2016 at 05:00:00pm</p></header><div class="content"><p>If I may be so bold, as a programmer with over 25 years of experience, in multiple languages…<br></p><p>Although I can see the reasoning behind &quot;redefining&quot; visibility scope for Swift, I find myself both agreeing and disagreeing with various aspects.<br></p><p>Apart from Delphi, I&#39;ve never come across a use of private other than for the scope of the immediate class only. Delphi does a similar thing to Swift, in that it defines &quot;private&quot; as meaning the scope of the declaring code file until Delphi 7, when someone decided it was a good idea (possibly due to user requests) to add &quot;strict private&quot; to indicate a &quot;true&quot; private member, visible only to the declaring class.<br></p><p>Likewise, at the same time, &quot;strict protected&quot;, was added to convey visibility only to inherited classes, in addition to &quot;protected&quot;, which means roughly the same as &quot;private&quot;. Thus giving Delphi, in order of visibility, &quot;strict private&quot;, &quot;strict protected&quot;, &quot;private&quot;, &quot;protected&quot; and &quot;public&quot;. There are even ungodly hacks that allow you to access the private fields of a class in another unit!!!<br></p><p>However, in Swift, we can declare a lot more types as &quot;private&quot;, but &quot;protected&quot; really doesn&#39;t seem to make sense outside of classes, as there is no inheritance for other types like structs and enums.<br></p><p>But, in Swift, we now have the concept of extensions on all types, making inheritance less necessary and prompting us towards protocol-based programming, where behaviours can be added to any number of types without having to limit that type&#39;s inheritance from a base type. Now we can define behaviours that can apply to classes, structs, enums and, even, basic types such as Int and String.<br></p><p>Take the example of the Visitor Pattern : With strictly typed and statically compiled languages, this classically ends up with a system of double dispatch between a hierarchy of classes and a hierarchy of visitors.<br></p><p>Objective-C&#39;s class categories permit the extension of a class&#39;s behaviour without the Visitor Pattern but, with danger of dynamic dispatch that a &quot;visitation&quot; method may be called when it does not exist in the category. Another problem being that categories can only access &quot;public&quot; members of the main class because &quot;public&quot; is the only visibility Objective-C understands outside of iVars.<br></p><p>Swift&#39;s extensions permit the extension of most types (not just classes) so that they can implement one or more protocols, ensuring that the protocol(s) is/are fully implemented by raising a compiler error if not satisfied.<br></p><p>So, if we are going to bring in visibility specifiers to Swift, with all of its wonderful, type-safe, statically compiled code, we have to carefully consider, not just the names of the planned scopes but what impact any restrictions may have on the use of protocol-oriented programming and the various extensions on types that it will engender.<br></p><p>C++ uses the concept of marking certain methods and classes as &quot;friend&quot;, so that nominated classes have privileged access to otherwise private members of a class; maybe this is a worthwhile concept for determining what parts of a type can be accessed by an extension?<br></p><p>I am not suggesting &quot;friend&quot; as a name but the need for being able to restrict or allow access to certain members of a type when extending it?<br></p><p>In the light of the preceding paragraphs, I would, respectfully, suggest that &quot;protected&quot; should be allowed for exclusive use in the case of classes that really have to derive from each other, but for no other reason. Likewise, &quot;private&quot; should mean what it has meant and still means in most other languages, members of classes only, since, like &quot;protected&quot;, that is its true nature.<br></p><p>What Swift presently calls &quot;internal&quot; seems to equate more to the C# concept of &quot;internal&quot; and, in my mind, needs no further discussion or change.<br></p><p>Just as I was never happy with the Delphi concept of private and protected members being accessible, not just in the class or its derived types, but also from any code in the same code unit, I feel uneasy about the present definition of the private scope in Swift.<br></p><p>I have seen some horrendous abuses of that privileged access, with the gradual growth of single code units to truly gargantuan proportions, just because someone felt that certain classes needed to violate all the rules of common sense and be able to access each others&#39; private parts (if you&#39;ll pardon the vernacular).<br></p><p>If several types really have to be defined in the same unit, then their relationship to each other needs defining far more strictly than just to say that they have total free reign to interfere where they want.<br></p><p>Personally, I would like to see the end of the file based scope and, instead, see more clearly defined &quot;privileged&quot; access between types, even if they are in the same code unit.<br></p><p>Let the naysayers (or even the forsayers) commence :-)<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Some responses rolled into a single email:<br></p><p><br>&gt; I&#39;m going to say that I remain unhappy with these new names. I don&#39;t believe that these won&#39;t get used, and I don&#39;t want them to feel awkward, discouraged, or penalized when they do. The standard library, for example, has in its style guide that all access control should be explicit, which is a reasonable style to enforce.<br></p><p>I enforce that style in my own code, so I&#39;ll definitely be using moduleprivate. The point was that, if you don&#39;t like moduleprivate, you can establish a code style that omits it. But I personally like it very much, it&#39;s an ideal mix of standing out (by virtue of being long), but not standing out too much.<br></p><p><br>&gt; I also have a small concern that they won&#39;t be easy to talk about: &quot;this method is private&quot; &quot;wait, file-private or module-private?&quot; &quot;neither, just private-private&quot;.<br></p><p>Nope, you&#39;ll just always say file-private and module-private when you mean that. Private continues to mean private. No need to clarify when speaking.<br></p><p><br>&gt; I&#39;ve never come across a use of private other than for the scope of the immediate class only.<br></p><p>Yes. Private should be the scoped access level, that&#39;s the least surprising definition.<br></p><p><br>&gt; Delphi does a similar thing to Swift, in that it defines &quot;private&quot; as meaning the scope of the declaring code file<br></p><p>FWIW, Delphi and Ada had a strong tradition of module/unit-based encapsulation (where the module/unit refers to a single file or a header/body pair of files), with each module having public and private parts.<br></p><p>Swift doesn&#39;t go all the way here, but it does recognize that it&#39;s a useful pattern. I personally like it, and use file-private access regularly to group related entities into a single submodule. (There sure are other ways to define submodules, but this is the most lightweight one, and also the one we already have.)<br></p><p>So “fileprivate” should definitely stay, but yes, it&#39;s not nearly as common as “private”.<br></p><p><br>&gt; I would, respectfully, suggest that &quot;protected&quot; should be allowed for exclusive use in the case of classes that really have to derive from each other<br></p><p>I would personally love this, but it&#39;s outside the scope of the current proposal.<br></p><p><br>&gt; What Swift presently calls &quot;internal&quot; seems to equate more to the C# concept of &quot;internal&quot; and, in my mind, needs no further discussion or change.<br></p><p>I believe “moduleprivate” is a lot more clear than “internal”. “internal” have always bugged me as a seemingly random word.<br></p><p><br>&gt; Let&#39;s say that we go with public, moduleprivate, fileprivate, scopeprivate<br></p><p>God no. “Private” is the most common case, and shouldn&#39;t stand out that much. Scoped private will be consistent with every other language out there, so doesn&#39;t need clarification.<br></p><p><br>&gt; I have seen some horrendous abuses of that privileged access, with the gradual growth of single code units to truly gargantuan proportions, just because someone felt that certain classes needed to violate all the rules of common sense and be able to access each others&#39; private parts (if you&#39;ll pardon the vernacular).<br></p><p>Respectfully, this is not a valid argument. I&#39;ve seen horrific abuses in lots of different languages out there. Bad developers will always write bad code, and the intricacies of access level definitions won&#39;t help.<br></p><p><br>&gt; If several types really have to be defined in the same unit, then their relationship to each other needs defining far more strictly than just to say that they have total free reign to interfere where they want.<br></p><p>Yes, this is why certain members should be marked file-private. We don&#39;t need explicit friends. If a file grows beyond the size where the purpose is clear, the code needs to be refactored into multiple files.<br></p><p><br>&gt; public, internal, private, secret.<br></p><p>No. Private needs to mean what everyone expects it to mean, and it should also be the default reasonable (i.e. most restricting) choice.<br></p><p><br>&gt; +1 to paren syntax for readability, private(module) being the default if nothing declared, private with no parenthesized access keyword can default to either file or scope.<br></p><p>There&#39;s nothing readable about private(module). You don&#39;t want those parens to grab attention from the code. A longish word is quite enough.<br></p><p><br>&gt; I still think that &quot;local&quot; expresses the concept exactly, as it restricts visibility to the local scope, doesn&#39;t it?<br></p><p>No, to me it&#39;s only clear if you stop and think about it. But when coding, it invokes all the wrong associations.<br></p><p><br>&gt;&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt;&gt; <br>&gt;&gt; I&#39;ll do the same. There&#39;s many instances in my code where I rely on the file-private behavior of Swift 2&#39;s private. Mostly this happens when I have a pair of coupled classes that are meant to be used together and that need to access internal details of each other. Most declarations can be scope-private without problem, but it&#39;s not that uncommon for me to take advantage of file-private. <br>&gt; <br>&gt; +1<br></p><p><br>It *is* fairly common, but:<br></p><p>1) it is *way less* common than just plain private<br></p><p>2) in those cases where I need file-private, I really want to document *which* members are accessed from outside, so the distinction between private and file-private is very useful there<br></p><p>&gt;&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt;&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt;&gt; an entire module.<br></p><p>Here&#39;s a quick use case: a private helper class that you don&#39;t want to expose to the outside. Maybe it&#39;s only used to implement a verbose protocol. It&#39;s really a part of the bigger public class, so wants to access some of its members without much ado.<br></p><p>Another use case: a bunch of public structs/classes that can be initialized from JSON, but there&#39;s only a single publicly-visible ‘parse’ method that invokes a bunch of private initializers (and maybe mutation methods) on those structs. <br></p><p>There are tons of cases where you have a compact bunch of classes and you want them to hide the implementation details of one specific feature that involves interaction between them.<br></p><p>Haven&#39;t you even declared a bunch of Objective-C classes in a single file so that they all have access to the the private extensions of one another? I did it fairly often, and Swift&#39;s file-private is a natural extension of that.<br></p><p><br>&gt; Abandon the words &#39;public&#39; and &#39;private&#39;. [...] I really want Swift to use terms with clear meaning<br></p><p>“Private” has a very clear meaning (not accessible from outside); its current meaning was simply a wrong choice, based on a different look at what “outside” means.<br></p><p>Similarly, “public” is 100% clear; we talk about “public API” all the time.<br></p><p>We also talk about module-private, subsystem-private, framework-private and file-private stuff, so calling them such seems a no-brainer choice. Do you ever say “file-internal” yourself?<br></p><p><br>&gt; public (unchanged)<br>&gt; external (module access)<br>&gt; internal (file access)<br>&gt; private (scoped access)<br></p><p><br>This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br></p><p>And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br></p><p><br>&gt; protected // Java got it wrong. :) This is &quot;protected&quot; against extensions. &#39;<br></p><p>Please leave protected alone, I still hope we can get it into the language in some shape or form, not necessarily bound to subclasses.<br></p><p><br>&gt; If I may be so bold, as a programmer with over 25 years of experience, in multiple languages…<br></p><p>15 years here, just so that you don&#39;t disregard this as a newbie&#39;s talk. (I fully expect to be wrong on occasion, though, so I don&#39;t consider this to be a part of the argument.)<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/caf7a0d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 29, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; public (unchanged)<br>&gt;&gt; external (module access)<br>&gt;&gt; internal (file access)<br>&gt;&gt; private (scoped access)<br>&gt; <br>&gt; <br>&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt; <br>&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br></p><p><br>It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br></p><p>Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br></p><p>There is a nice symmetry to internal/external and public/private.<br></p><p>If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br></p><p>- Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/a740c19d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 29, 2016 at 02:00:00pm</p></header><div class="content"><p>-1, &quot;external&quot; can be also understood as &quot;exported&quot; or public. I think that<br>the names in the updated proposal are the clearest. Also, I think that at<br>this point we need to stop trying to come up with more names. I don&#39;t think<br>that we will ever reach a point where everybody is happy with the names.<br>The ones that we have now seems to be a good compromise that is in line<br>with other Swift keywords.<br>On Tue, Mar 29, 2016 at 9:23 AM Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; public (unchanged)<br>&gt; external (module access)<br>&gt; internal (file access)<br>&gt; private (scoped access)<br>&gt;<br>&gt;<br>&gt; This seems logical and something I could live with, but how is it better<br>&gt; than moduleprivate and fileprivate? Also, internal has contradictory prior<br>&gt; art in C# and Swift 2 (not that it stops us).<br>&gt;<br>&gt; And I see the length of moduleprivate and fileprivate as a feature, and<br>&gt; external/internal lacks it.<br>&gt;<br>&gt;<br>&gt; It is better than moduleprivate and fileprivate in that it is a single<br>&gt; word which is easier to to read and there is less typing. Less typing even<br>&gt; with autocomplete is a benefit. Once you know its meaning, that both are<br>&gt; relative to file access, you won’t have to look it up. Also, just noticed<br>&gt; this, when I type multiword keywords in an email program or chat program<br>&gt; autocorrect butts in. This is of practical value because much work is done<br>&gt; in chat and email programs.<br>&gt;<br>&gt; Simpler is better if it sufficiently conveys the meaning and it does in<br>&gt; this case. The expectation with most keywords are that they be single<br>&gt; words, especially ones that are used the most.<br>&gt;<br>&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;<br>&gt; If external/internal refer to the file, then we don’t need the multiword<br>&gt; descriptive versions.  Also, if we decide later that scoping to namespaces<br>&gt; is desired these same already reserved keywords give us more flexibility<br>&gt; than the more specific keywords would allow. Internal/external could refer<br>&gt; to the namespace scope rather than the file scope if it is inside a<br>&gt; namespace (this is beyond the scope of the proposal but trying to think<br>&gt; ahead). By not explicitly stating the scope you gain flexibility<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/1f70cdb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 29, 2016 at 09:00:00am</p></header><div class="content"><p>I agree with Ilya that &quot;external&quot; is too easy to confuse with &quot;public&quot;, especially given the specifier &quot;extern&quot; in C. Additionally, we think we can get away with renaming &quot;private&quot; because most current uses of &quot;private&quot; (file-scoped) declarations are within the same (brace-bound) scope anyway; &quot;internal&quot; could potentially cause a lot more churn. And as Andrey pointed out, we&#39;d be at odds with C#, the only other language that uses &quot;internal&quot; as an access specifier today.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 29, 2016, at 7:03 , Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1, &quot;external&quot; can be also understood as &quot;exported&quot; or public. I think that the names in the updated proposal are the clearest. Also, I think that at this point we need to stop trying to come up with more names. I don&#39;t think that we will ever reach a point where everybody is happy with the names. The ones that we have now seems to be a good compromise that is in line with other Swift keywords.<br>&gt; On Tue, Mar 29, 2016 at 9:23 AM Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt; private (scoped access)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt; <br>&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt; <br>&gt; <br>&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt; <br>&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt; <br>&gt; There is a nice symmetry to internal/external and public/private.<br>&gt; <br>&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt; <br>&gt; - Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/4f490557/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Additionally, we think we can get away with renaming &quot;private&quot; because most current uses of &quot;private&quot; (file-scoped) declarations are within the same (brace-bound) scope anyway;<br></p><p>A quick look through my code bases verifies that this is true with my small sample of code. The only outliers are private members on types accessed by extensions, but those are fairly rare in my use cases, and arguably, those should be changed to internal. Maybe that varies for others.<br></p><p>Honestly, if the assertion is already that most of the current private use cases are for lexically scoped uses anyway, is it really worth trying to add a file-based private as well that essentially pops out of the lexical scope only up to the file level? For those use cases, just use `internal`. Using `private` would still be available for top-level declarations on the file.<br></p><p>We would end up with just this:<br></p><p>`public` - publicly exported for use by all code that uses the library<br>`internal` - only allowed for use within the current module<br>`private` - the new, lexically scoped modifier<br></p><p>If file-based is really required for a small set of cases, use `private internal`.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/fb06f81f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 10:14 , David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt;&gt; Additionally, we think we can get away with renaming &quot;private&quot; because most current uses of &quot;private&quot; (file-scoped) declarations are within the same (brace-bound) scope anyway;<br>&gt; <br>&gt; A quick look through my code bases verifies that this is true with my small sample of code. The only outliers are private members on types accessed by extensions, but those are fairly rare in my use cases, and arguably, those should be changed to internal. Maybe that varies for others.<br>&gt; <br>&gt; Honestly, if the assertion is already that most of the current private use cases are for lexically scoped uses anyway, is it really worth trying to add a file-based private as well that essentially pops out of the lexical scope only up to the file level? For those use cases, just use `internal`. Using `private` would still be available for top-level declarations on the file.<br>&gt; <br>&gt; We would end up with just this:<br>&gt; <br>&gt; `public` - publicly exported for use by all code that uses the library<br>&gt; `internal` - only allowed for use within the current module<br>&gt; `private` - the new, lexically scoped modifier<br>&gt; <br>&gt; If file-based is really required for a small set of cases, use `private internal`.<br></p><p>A good handful of people already enumerated several cases where file-based scoping is useful, and I very much agree. Leaking helper operations across an entire module just because they can&#39;t be lexically scoped, or don&#39;t make sense to, doesn&#39;t seem like a good answer to me.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/699ee14b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Mar 29, 2016, at 12:18 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 10:14 , David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally, we think we can get away with renaming &quot;private&quot; because most current uses of &quot;private&quot; (file-scoped) declarations are within the same (brace-bound) scope anyway;<br>&gt;&gt; <br>&gt;&gt; A quick look through my code bases verifies that this is true with my small sample of code. The only outliers are private members on types accessed by extensions, but those are fairly rare in my use cases, and arguably, those should be changed to internal. Maybe that varies for others.<br>&gt;&gt; <br>&gt;&gt; Honestly, if the assertion is already that most of the current private use cases are for lexically scoped uses anyway, is it really worth trying to add a file-based private as well that essentially pops out of the lexical scope only up to the file level? For those use cases, just use `internal`. Using `private` would still be available for top-level declarations on the file.<br>&gt;&gt; <br>&gt;&gt; We would end up with just this:<br>&gt;&gt; <br>&gt;&gt; `public` - publicly exported for use by all code that uses the library<br>&gt;&gt; `internal` - only allowed for use within the current module<br>&gt;&gt; `private` - the new, lexically scoped modifier<br>&gt;&gt; <br>&gt;&gt; If file-based is really required for a small set of cases, use `private internal`.<br>&gt; <br>&gt; A good handful of people already enumerated several cases where file-based scoping is useful, and I very much agree. Leaking helper operations across an entire module just because they can&#39;t be lexically scoped, or don&#39;t make sense to, doesn&#39;t seem like a good answer to me.<br></p><p>+1<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/318f8202/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 10:18 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; A good handful of people already enumerated several cases where file-based scoping is useful, and I very much agree. Leaking helper operations across an entire module just because they can&#39;t be lexically scoped, or don&#39;t make sense to, doesn&#39;t seem like a good answer to me.<br></p><p>I know, I&#39;m one of them.<br></p><p>However, this thread is fairly disconcerting about how granular many of the suggestions are heading towards. We can try to solve for all of the cases or we can provide mechanism that works well for the majority of cases. I&#39;m actually in the camp of keeping the levels as they are. There is always going to be some level of leakage unless you provide a mechanism to provide very explicit access control modifiers.<br></p><p>The question at the heart of this proposal is how &quot;correct&quot; is Swift really going to be in defining access control modifiers?<br></p><p>One can argue that file-based access control is required, for many use cases, because it&#39;s not possible to limit usage to be &quot;more correct&quot;. If I want to expose the private details of my type to an extension, how do I do that? Today, file-based, but tomorrow, is there a `protected` for this? What about only to all extensions within the module? Is that `protected internal`? Is there a way to limit the extensions that can have access to the privates, because there are real scenarios for that as well?<br></p><p>Then we need to go down the rabbit-hole for type-based access control modifiers as well, though maybe that&#39;s already alluded to with the extensions example, so we get `protected` and `protected internal` there as well.<br></p><p>So this gives us public, internal, private, file-based, protected (protocol/extension based), protected (inheritance based), protected internal (protocol/extension based), and protected internal (inheritance based). <br></p><p>And let&#39;s not forget the desire to share privates with others that are not in our access control scope, so we&#39;re back to needing something like `friend` to essentially merge other types into the same access control scope.<br></p><p>I really feel like I&#39;m watching the evolution of C++ access modifiers in Swift. If that&#39;s the route the language and community wants to go, then ok. However, if Swift is really going to re-look at access levels, just looking at scoped access levels does not seem sufficient; it solves one, very narrow case, while ignoring many of the other cases. <br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/23b962ab/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 29, 2016 at 11:00:00am</p></header><div class="content"><p>If someone sees public and external in different places while learning the language they would be curious to see what the difference is. The first time I saw internal in swift, I looked it up. It was not immediately apparent from the name what it meant from then on, there was no confusion. This similarly would apply to external. <br></p><p>Since the C extern is a different word, I would not assume it is the same, but may be not that confusing, as it is used in a similar manner to C. You are exposing the item beyond this file. <br></p><p>Since external is the default, it would not be seen as often. <br></p><p>These specifiers should be single words because they are typed quite often. I think public is the single most word I typed on a library I created. Since they will be seen a lot they should be pleasing to the eye. <br></p><p>I would be ok with &quot;shared&quot; for external  but I like the symmetry of internal-external and public-private. Does it then become shared-excluded? Shared-unshared? Still like external-internal better. <br></p><p>- Paul <br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 29, 2016, at 9:31 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I agree with Ilya that &quot;external&quot; is too easy to confuse with &quot;public&quot;, especially given the specifier &quot;extern&quot; in C. Additionally, we think we can get away with renaming &quot;private&quot; because most current uses of &quot;private&quot; (file-scoped) declarations are within the same (brace-bound) scope anyway; &quot;internal&quot; could potentially cause a lot more churn. And as Andrey pointed out, we&#39;d be at odds with C#, the only other language that uses &quot;internal&quot; as an access specifier today.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 7:03 , Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1, &quot;external&quot; can be also understood as &quot;exported&quot; or public. I think that the names in the updated proposal are the clearest. Also, I think that at this point we need to stop trying to come up with more names. I don&#39;t think that we will ever reach a point where everybody is happy with the names. The ones that we have now seems to be a good compromise that is in line with other Swift keywords.<br>&gt;&gt; On Tue, Mar 29, 2016 at 9:23 AM Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt;&gt;&gt; private (scoped access)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/35651f33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc2018ce0c170425a51033a54850a538?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Lukas Stabe</string> &lt;ahti333 at gmail.com&gt;<p>March 29, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m kind of late to this thread, so if my argument has been brought up before, please just ignore me:<br></p><p>I know naming the modifiers `module` and `file` have been suggested already, and those were dismissed as being to broadly named. Would these modifiers stand on their own, I&#39;d agree with this in full. However, access modifiers always accompany something like `let`, `class`, `func` etc.<br></p><p>To give some examples:<br></p><p>    module class Worker { ... }<br></p><p>This, to me, sounds exactly like what it would be: A class belonging to the module.<br></p><p>    file let apiURL = &quot;https://api.example.com/&quot;<br></p><p>Again, imho this describes what it is perfectly: A constant belonging to the current file.<br></p><p>Extending this to the new private and to public, I think `public` fits reasonably well, and for the new private, something along the lines of `scope` could work well:<br></p><p>    scope func myUtilityFunction() { ... }<br></p><p>– Lukas<br></p><p>&gt; On 29 Mar 2016, at 13:09, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If someone sees public and external in different places while learning the language they would be curious to see what the difference is. The first time I saw internal in swift, I looked it up. It was not immediately apparent from the name what it meant from then on, there was no confusion. This similarly would apply to external. <br>&gt; <br>&gt; Since the C extern is a different word, I would not assume it is the same, but may be not that confusing, as it is used in a similar manner to C. You are exposing the item beyond this file. <br>&gt; <br>&gt; Since external is the default, it would not be seen as often. <br>&gt; <br>&gt; These specifiers should be single words because they are typed quite often. I think public is the single most word I typed on a library I created. Since they will be seen a lot they should be pleasing to the eye. <br>&gt; <br>&gt; I would be ok with &quot;shared&quot; for external  but I like the symmetry of internal-external and public-private. Does it then become shared-excluded? Shared-unshared? Still like external-internal better. <br>&gt; <br>&gt; - Paul <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 9:31 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree with Ilya that &quot;external&quot; is too easy to confuse with &quot;public&quot;, especially given the specifier &quot;extern&quot; in C. Additionally, we think we can get away with renaming &quot;private&quot; because most current uses of &quot;private&quot; (file-scoped) declarations are within the same (brace-bound) scope anyway; &quot;internal&quot; could potentially cause a lot more churn. And as Andrey pointed out, we&#39;d be at odds with C#, the only other language that uses &quot;internal&quot; as an access specifier today.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 7:03 , Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1, &quot;external&quot; can be also understood as &quot;exported&quot; or public. I think that the names in the updated proposal are the clearest. Also, I think that at this point we need to stop trying to come up with more names. I don&#39;t think that we will ever reach a point where everybody is happy with the names. The ones that we have now seems to be a good compromise that is in line with other Swift keywords.<br>&gt;&gt;&gt; On Tue, Mar 29, 2016 at 9:23 AM Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt;&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt;&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt;&gt;&gt;&gt; private (scoped access)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/5f1cb3b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I disagree strongly. We might not be able to get everyone happy with the<br>names, but we can get to a point of good compromise, and &quot;moduleprivate&quot;<br>does not seem to me a good compromise at all.<br></p><p>Aesthetically, &quot;moduleprivate&quot; leaves much to be desired, but others have<br>already touched on that. I very much agree with the objection that having<br>&quot;moduleprivate&quot; and &quot;private&quot; makes the meaning of &quot;private&quot; less clear.<br>When we modify one word with another, we generally expect the modifying<br>word to restrict the universe of things denoted by the base word. For<br>example, top secret is more restricted than secret. Red cars are a subset<br>of all cars. When this expectation is violated, it&#39;s often spoken of as a<br>surprising thing or an unfortunate name. English horns aren&#39;t horns! red<br>pandas aren&#39;t pandas! moduleprivate isn&#39;t private!<br></p><p>On Tue, Mar 29, 2016 at 9:04 AM Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -1, &quot;external&quot; can be also understood as &quot;exported&quot; or public. I think<br>&gt; that the names in the updated proposal are the clearest. Also, I think that<br>&gt; at this point we need to stop trying to come up with more names. I don&#39;t<br>&gt; think that we will ever reach a point where everybody is happy with the<br>&gt; names. The ones that we have now seems to be a good compromise that is in<br>&gt; line with other Swift keywords.<br>&gt; On Tue, Mar 29, 2016 at 9:23 AM Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; public (unchanged)<br>&gt;&gt; external (module access)<br>&gt;&gt; internal (file access)<br>&gt;&gt; private (scoped access)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This seems logical and something I could live with, but how is it better<br>&gt;&gt; than moduleprivate and fileprivate? Also, internal has contradictory prior<br>&gt;&gt; art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;<br>&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and<br>&gt;&gt; external/internal lacks it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single<br>&gt;&gt; word which is easier to to read and there is less typing. Less typing even<br>&gt;&gt; with autocomplete is a benefit. Once you know its meaning, that both are<br>&gt;&gt; relative to file access, you won’t have to look it up. Also, just noticed<br>&gt;&gt; this, when I type multiword keywords in an email program or chat program<br>&gt;&gt; autocorrect butts in. This is of practical value because much work is done<br>&gt;&gt; in chat and email programs.<br>&gt;&gt;<br>&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in<br>&gt;&gt; this case. The expectation with most keywords are that they be single<br>&gt;&gt; words, especially ones that are used the most.<br>&gt;&gt;<br>&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;<br>&gt;&gt; If external/internal refer to the file, then we don’t need the multiword<br>&gt;&gt; descriptive versions.  Also, if we decide later that scoping to namespaces<br>&gt;&gt; is desired these same already reserved keywords give us more flexibility<br>&gt;&gt; than the more specific keywords would allow. Internal/external could refer<br>&gt;&gt; to the namespace scope rather than the file scope if it is inside a<br>&gt;&gt; namespace (this is beyond the scope of the proposal but trying to think<br>&gt;&gt; ahead). By not explicitly stating the scope you gain flexibility<br>&gt;&gt;<br>&gt;&gt; - Paul<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/a5f34dd4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 29, 2016 at 03:00:00pm</p></header><div class="content"><p>How is flexibility desirable?<br></p><p>Why is it important to me, if I decide that a given class should only be<br>visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be<br>subject to change in future versions of Swift? &#39;Once you know its meaning&#39;<br>should mean once!<br></p><p>Right now, I use the word &#39;private&#39; when I want code to be only visible<br>within a file. When I migrate a project to Swift 3, an automatic migrator<br>may not be able to tell whether a given private property should now be<br>scope-private or file-private. Perhaps we can assume that anything private<br>referred to in more than one scope should be file-private and everything<br>remaining should be scope-private, but I think it would still be wise to<br>manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make<br>that process even more complicated... but okay, it&#39;s a one-time cost.<br></p><p>I don&#39;t see the advantage in knowing that adding another visibility level<br>in future will require another intensive review. I&#39;d prefer it if a keyword<br>was explicit about its meaning. Migration can then be straightforward:<br>everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce<br>the visibility of anything to scope-private then I can do so manually. If<br>we add an even more private level in future then the code doesn&#39;t break<br>just because &#39;private&#39; was too subjective in its meaning.<br></p><p><br></p><p><br></p><p>On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; public (unchanged)<br>&gt; external (module access)<br>&gt; internal (file access)<br>&gt; private (scoped access)<br>&gt;<br>&gt;<br>&gt; This seems logical and something I could live with, but how is it better<br>&gt; than moduleprivate and fileprivate? Also, internal has contradictory prior<br>&gt; art in C# and Swift 2 (not that it stops us).<br>&gt;<br>&gt; And I see the length of moduleprivate and fileprivate as a feature, and<br>&gt; external/internal lacks it.<br>&gt;<br>&gt;<br>&gt; It is better than moduleprivate and fileprivate in that it is a single<br>&gt; word which is easier to to read and there is less typing. Less typing even<br>&gt; with autocomplete is a benefit. Once you know its meaning, that both are<br>&gt; relative to file access, you won’t have to look it up. Also, just noticed<br>&gt; this, when I type multiword keywords in an email program or chat program<br>&gt; autocorrect butts in. This is of practical value because much work is done<br>&gt; in chat and email programs.<br>&gt;<br>&gt; Simpler is better if it sufficiently conveys the meaning and it does in<br>&gt; this case. The expectation with most keywords are that they be single<br>&gt; words, especially ones that are used the most.<br>&gt;<br>&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;<br>&gt; If external/internal refer to the file, then we don’t need the multiword<br>&gt; descriptive versions.  Also, if we decide later that scoping to namespaces<br>&gt; is desired these same already reserved keywords give us more flexibility<br>&gt; than the more specific keywords would allow. Internal/external could refer<br>&gt; to the namespace scope rather than the file scope if it is inside a<br>&gt; namespace (this is beyond the scope of the proposal but trying to think<br>&gt; ahead). By not explicitly stating the scope you gain flexibility<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/fe5dfdde/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 29, 2016 at 07:00:00am</p></header><div class="content"><p>Just as context is used for variable names does not need a specific scoping specifier every time one is declared.  You know from the context in which it is used that it only applies to a certain scope. <br></p><p>I would hope that if namespaces are added we would not have namespaceprivate etc The keywords would explode and become quite confusing..Instead if it is in a namespace you would use internal or external and the scope changes to the namespace rather than the file but as I said this is beyond the intent of this proposal. <br></p><p>&gt; On Mar 29, 2016, at 7:04 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; How is flexibility desirable?<br>&gt; <br>&gt; Why is it important to me, if I decide that a given class should only be visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be subject to change in future versions of Swift? &#39;Once you know its meaning&#39; should mean once!<br>&gt; <br>&gt; Right now, I use the word &#39;private&#39; when I want code to be only visible within a file. When I migrate a project to Swift 3, an automatic migrator may not be able to tell whether a given private property should now be scope-private or file-private. Perhaps we can assume that anything private referred to in more than one scope should be file-private and everything remaining should be scope-private, but I think it would still be wise to manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make that process even more complicated... but okay, it&#39;s a one-time cost.<br>&gt; <br>&gt; I don&#39;t see the advantage in knowing that adding another visibility level in future will require another intensive review. I&#39;d prefer it if a keyword was explicit about its meaning. Migration can then be straightforward: everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce the visibility of anything to scope-private then I can do so manually. If we add an even more private level in future then the code doesn&#39;t break just because &#39;private&#39; was too subjective in its meaning.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt; private (scoped access)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt; <br>&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt; <br>&gt; <br>&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt; <br>&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt; <br>&gt; There is a nice symmetry to internal/external and public/private.<br>&gt; <br>&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt; <br>&gt; - Paul<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/dccf7e71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 29, 2016 at 05:00:00pm</p></header><div class="content"><p>FWIW, Ceylon uses only a lexical access level like in the proposal (as I understood it):<br></p><p>program elements which are visible only inside the scope in which they are defined, and<br>program elements which are visible wherever the thing they belong to (a type, package, or module) is visible.<br></p><p>In Ceylon this level is called &quot;shared&quot;.<br></p><p>-Thorsten <br></p><p>&gt; Am 29.03.2016 um 16:24 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Just as context is used for variable names does not need a specific scoping specifier every time one is declared.  You know from the context in which it is used that it only applies to a certain scope. <br>&gt; <br>&gt; I would hope that if namespaces are added we would not have namespaceprivate etc The keywords would explode and become quite confusing..Instead if it is in a namespace you would use internal or external and the scope changes to the namespace rather than the file but as I said this is beyond the intent of this proposal. <br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 7:04 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How is flexibility desirable?<br>&gt;&gt; <br>&gt;&gt; Why is it important to me, if I decide that a given class should only be visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be subject to change in future versions of Swift? &#39;Once you know its meaning&#39; should mean once!<br>&gt;&gt; <br>&gt;&gt; Right now, I use the word &#39;private&#39; when I want code to be only visible within a file. When I migrate a project to Swift 3, an automatic migrator may not be able to tell whether a given private property should now be scope-private or file-private. Perhaps we can assume that anything private referred to in more than one scope should be file-private and everything remaining should be scope-private, but I think it would still be wise to manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make that process even more complicated... but okay, it&#39;s a one-time cost.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see the advantage in knowing that adding another visibility level in future will require another intensive review. I&#39;d prefer it if a keyword was explicit about its meaning. Migration can then be straightforward: everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce the visibility of anything to scope-private then I can do so manually. If we add an even more private level in future then the code doesn&#39;t break just because &#39;private&#39; was too subjective in its meaning.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt;&gt;&gt; private (scoped access)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/4e54643f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 29, 2016 at 09:00:00am</p></header><div class="content"><p>I checked this out when I was making my lists. It&#39;s a very simple solution, but I feel like &quot;internal (module-scoped) method on a public class&quot; is a common enough use case that we wouldn&#39;t want to rule it out, or force the user to write a separate extension.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 29, 2016, at 8:12 , Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW, Ceylon uses only a lexical access level like in the proposal (as I understood it):<br>&gt; <br>&gt; program elements which are visible only inside the scope in which they are defined, and<br>&gt; program elements which are visible wherever the thing they belong to (a type, package, or module) is visible.<br>&gt; <br>&gt; In Ceylon this level is called &quot;shared&quot;.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 29.03.2016 um 16:24 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Just as context is used for variable names does not need a specific scoping specifier every time one is declared.  You know from the context in which it is used that it only applies to a certain scope. <br>&gt;&gt; <br>&gt;&gt; I would hope that if namespaces are added we would not have namespaceprivate etc The keywords would explode and become quite confusing..Instead if it is in a namespace you would use internal or external and the scope changes to the namespace rather than the file but as I said this is beyond the intent of this proposal. <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 7:04 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium+swift at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How is flexibility desirable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is it important to me, if I decide that a given class should only be visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be subject to change in future versions of Swift? &#39;Once you know its meaning&#39; should mean once!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, I use the word &#39;private&#39; when I want code to be only visible within a file. When I migrate a project to Swift 3, an automatic migrator may not be able to tell whether a given private property should now be scope-private or file-private. Perhaps we can assume that anything private referred to in more than one scope should be file-private and everything remaining should be scope-private, but I think it would still be wise to manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make that process even more complicated... but okay, it&#39;s a one-time cost.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see the advantage in knowing that adding another visibility level in future will require another intensive review. I&#39;d prefer it if a keyword was explicit about its meaning. Migration can then be straightforward: everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce the visibility of anything to scope-private then I can do so manually. If we add an even more private level in future then the code doesn&#39;t break just because &#39;private&#39; was too subjective in its meaning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt;&gt;&gt; private (scoped access)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/1c624535/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 29, 2016 at 04:00:00pm</p></header><div class="content"><p>If &#39;knowing from the context that it only applies to a certain scope&#39; is<br>really that helpful, then let&#39;s make it as simple as we can:<br>&#39;firstprivate&#39;, &#39;secondprivate&#39;, &#39;thirdprivate&#39;, &#39;fourthprivate&#39;. That&#39;s an<br>easily extensible system: if we need a new level, we add &#39;fifthprivate&#39;.<br>Then we re-learn the context of each one.<br></p><p>I don&#39;t see that as advantageous.<br></p><p>This is the advantage of &#39;moduleprivate&#39; and &#39;fileprivate&#39; is to me: the<br>definitions of &#39;module&#39; and &#39;file&#39; will not change. I know where the<br>visibility of these symbols ends, just by reading it. I don&#39;t need to<br>consult the new Swift X contextual scale. I don&#39;t have to relearn it if we<br>add a new level. If we add &#39;namespaceprivate&#39; then it is immediately clear<br>that any symbol so marked is visible within a namespace and if it isn&#39;t<br>immediately clear then my first documentation search will be for &#39;Swift<br>namespace&#39; and not something like &#39;Swift restricted&#39; followed by &#39;Swift<br>namespace&#39;. We bake this objective information into the keyword itself,<br>information which is simply not present in terms like &#39;private&#39; or &#39;local&#39;<br>or &#39;secret&#39;, and we become more confident knowing that the definition of<br>&#39;file&#39; won&#39;t change between versions, and that makes our code easier to<br>maintain.<br></p><p>I have enough new things to learn as Swift evolves. Disambiguating<br>&#39;typealias&#39; into &#39;typealias&#39; and &#39;associatedtype&#39; was a new thing to learn<br>which improved Swift&#39;s clarity. Renaming &#39;private&#39; as &#39;internal&#39; does not<br>improve clarity.<br></p><p>On Tue, Mar 29, 2016 at 3:24 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; Just as context is used for variable names does not need a specific<br>&gt; scoping specifier every time one is declared.  You know from the context in<br>&gt; which it is used that it only applies to a certain scope.<br>&gt;<br>&gt; I would hope that if namespaces are added we would not have<br>&gt; namespaceprivate etc The keywords would explode and become quite<br>&gt; confusing..Instead if it is in a namespace you would use internal or<br>&gt; external and the scope changes to the namespace rather than the file but as<br>&gt; I said this is beyond the intent of this proposal.<br>&gt;<br>&gt; On Mar 29, 2016, at 7:04 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How is flexibility desirable?<br>&gt;<br>&gt; Why is it important to me, if I decide that a given class should only be<br>&gt; visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be<br>&gt; subject to change in future versions of Swift? &#39;Once you know its meaning&#39;<br>&gt; should mean once!<br>&gt;<br>&gt; Right now, I use the word &#39;private&#39; when I want code to be only visible<br>&gt; within a file. When I migrate a project to Swift 3, an automatic migrator<br>&gt; may not be able to tell whether a given private property should now be<br>&gt; scope-private or file-private. Perhaps we can assume that anything private<br>&gt; referred to in more than one scope should be file-private and everything<br>&gt; remaining should be scope-private, but I think it would still be wise to<br>&gt; manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make<br>&gt; that process even more complicated... but okay, it&#39;s a one-time cost.<br>&gt;<br>&gt; I don&#39;t see the advantage in knowing that adding another visibility level<br>&gt; in future will require another intensive review. I&#39;d prefer it if a keyword<br>&gt; was explicit about its meaning. Migration can then be straightforward:<br>&gt; everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce<br>&gt; the visibility of anything to scope-private then I can do so manually. If<br>&gt; we add an even more private level in future then the code doesn&#39;t break<br>&gt; just because &#39;private&#39; was too subjective in its meaning.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; public (unchanged)<br>&gt;&gt; external (module access)<br>&gt;&gt; internal (file access)<br>&gt;&gt; private (scoped access)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This seems logical and something I could live with, but how is it better<br>&gt;&gt; than moduleprivate and fileprivate? Also, internal has contradictory prior<br>&gt;&gt; art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;<br>&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and<br>&gt;&gt; external/internal lacks it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single<br>&gt;&gt; word which is easier to to read and there is less typing. Less typing even<br>&gt;&gt; with autocomplete is a benefit. Once you know its meaning, that both are<br>&gt;&gt; relative to file access, you won’t have to look it up. Also, just noticed<br>&gt;&gt; this, when I type multiword keywords in an email program or chat program<br>&gt;&gt; autocorrect butts in. This is of practical value because much work is done<br>&gt;&gt; in chat and email programs.<br>&gt;&gt;<br>&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in<br>&gt;&gt; this case. The expectation with most keywords are that they be single<br>&gt;&gt; words, especially ones that are used the most.<br>&gt;&gt;<br>&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;<br>&gt;&gt; If external/internal refer to the file, then we don’t need the multiword<br>&gt;&gt; descriptive versions.  Also, if we decide later that scoping to namespaces<br>&gt;&gt; is desired these same already reserved keywords give us more flexibility<br>&gt;&gt; than the more specific keywords would allow. Internal/external could refer<br>&gt;&gt; to the namespace scope rather than the file scope if it is inside a<br>&gt;&gt; namespace (this is beyond the scope of the proposal but trying to think<br>&gt;&gt; ahead). By not explicitly stating the scope you gain flexibility<br>&gt;&gt;<br>&gt;&gt; - Paul<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/56b3d518/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 29, 2016 at 09:00:00am</p></header><div class="content"><p>What does that even mean fileprivate in a namespace? Does it become exposed outside the namespace? Not so private anymore. Now we have this namespaceprivate thing too? Since a namespace could span multiple files. Getting very confusing quickly. <br></p><p> If it is just &quot;internal&quot;, it means within the scope of the namespace.  If there is no namespace internal means internal to the file. I don&#39;t want to design  namespaces here though, just keep a path to context helping with it and not have to redo all the access levels down the road. <br></p><p>These levels would stay consistent within the scope in which they are defined. <br></p><p>- Paul <br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 29, 2016, at 8:13 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; If &#39;knowing from the context that it only applies to a certain scope&#39; is really that helpful, then let&#39;s make it as simple as we can: &#39;firstprivate&#39;, &#39;secondprivate&#39;, &#39;thirdprivate&#39;, &#39;fourthprivate&#39;. That&#39;s an easily extensible system: if we need a new level, we add &#39;fifthprivate&#39;. Then we re-learn the context of each one.<br>&gt; <br>&gt; I don&#39;t see that as advantageous.<br>&gt; <br>&gt; This is the advantage of &#39;moduleprivate&#39; and &#39;fileprivate&#39; is to me: the definitions of &#39;module&#39; and &#39;file&#39; will not change. I know where the visibility of these symbols ends, just by reading it. I don&#39;t need to consult the new Swift X contextual scale. I don&#39;t have to relearn it if we add a new level. If we add &#39;namespaceprivate&#39; then it is immediately clear that any symbol so marked is visible within a namespace and if it isn&#39;t immediately clear then my first documentation search will be for &#39;Swift namespace&#39; and not something like &#39;Swift restricted&#39; followed by &#39;Swift namespace&#39;. We bake this objective information into the keyword itself, information which is simply not present in terms like &#39;private&#39; or &#39;local&#39; or &#39;secret&#39;, and we become more confident knowing that the definition of &#39;file&#39; won&#39;t change between versions, and that makes our code easier to maintain.<br>&gt; <br>&gt; I have enough new things to learn as Swift evolves. Disambiguating &#39;typealias&#39; into &#39;typealias&#39; and &#39;associatedtype&#39; was a new thing to learn which improved Swift&#39;s clarity. Renaming &#39;private&#39; as &#39;internal&#39; does not improve clarity.<br>&gt; <br>&gt;&gt; On Tue, Mar 29, 2016 at 3:24 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt; Just as context is used for variable names does not need a specific scoping specifier every time one is declared.  You know from the context in which it is used that it only applies to a certain scope. <br>&gt;&gt; <br>&gt;&gt; I would hope that if namespaces are added we would not have namespaceprivate etc The keywords would explode and become quite confusing..Instead if it is in a namespace you would use internal or external and the scope changes to the namespace rather than the file but as I said this is beyond the intent of this proposal. <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 7:04 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How is flexibility desirable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is it important to me, if I decide that a given class should only be visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be subject to change in future versions of Swift? &#39;Once you know its meaning&#39; should mean once!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, I use the word &#39;private&#39; when I want code to be only visible within a file. When I migrate a project to Swift 3, an automatic migrator may not be able to tell whether a given private property should now be scope-private or file-private. Perhaps we can assume that anything private referred to in more than one scope should be file-private and everything remaining should be scope-private, but I think it would still be wise to manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make that process even more complicated... but okay, it&#39;s a one-time cost.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see the advantage in knowing that adding another visibility level in future will require another intensive review. I&#39;d prefer it if a keyword was explicit about its meaning. Migration can then be straightforward: everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce the visibility of anything to scope-private then I can do so manually. If we add an even more private level in future then the code doesn&#39;t break just because &#39;private&#39; was too subjective in its meaning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt;&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt;&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt;&gt;&gt;&gt; private (scoped access)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems logical and something I could live with, but how is it better than moduleprivate and fileprivate? Also, internal has contradictory prior art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and external/internal lacks it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single word which is easier to to read and there is less typing. Less typing even with autocomplete is a benefit. Once you know its meaning, that both are relative to file access, you won’t have to look it up. Also, just noticed this, when I type multiword keywords in an email program or chat program autocorrect butts in. This is of practical value because much work is done in chat and email programs. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in this case. The expectation with most keywords are that they be single words, especially ones that are used the most. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If external/internal refer to the file, then we don’t need the multiword descriptive versions.  Also, if we decide later that scoping to namespaces is desired these same already reserved keywords give us more flexibility than the more specific keywords would allow. Internal/external could refer to the namespace scope rather than the file scope if it is inside a namespace (this is beyond the scope of the proposal but trying to think ahead). By not explicitly stating the scope you gain flexibility <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/1c8d32de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 29, 2016 at 05:00:00pm</p></header><div class="content"><p>That depends how you define &#39;namespace&#39;. A module is a set of files. Is a<br>namespace a set of files, a subset of the module&#39;s set?<br></p><p>If yes, namespace fits in with the hierarchy: &#39;public&#39;, &#39;module private&#39;,<br>&#39;namespace private&#39;, &#39;file private&#39;, &#39;scope private&#39;. Easy.<br></p><p>If no, then I&#39;m guessing it means that some parts of a file are in a<br>namespace and some aren&#39;t. That&#39;s orthogonal to the scope-based hierarchy.<br>That causes explosions of keywords - now you have symbols visible only<br>within one file, and only within the namespace region of it. And other<br>symbols visible within the namespace regions of other files, but not<br>outside the namespace in the file where it&#39;s declared. And others visible<br>within a file, invisible to regions of the namespace outside that file. Did<br>we just generate &#39;namespace internal&#39;, &#39;file internal&#39; and &#39;namespace file<br>internal&#39;? Which of these is &#39;internal&#39;?<br></p><p>On Tue, Mar 29, 2016 at 5:19 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; What does that even mean fileprivate in a namespace? Does it become<br>&gt; exposed outside the namespace? Not so private anymore. Now we have this<br>&gt; namespaceprivate thing too? Since a namespace could span multiple files.<br>&gt; Getting very confusing quickly.<br>&gt;<br>&gt;  If it is just &quot;internal&quot;, it means within the scope of the namespace.  If<br>&gt; there is no namespace internal means internal to the file. I don&#39;t want to<br>&gt; design  namespaces here though, just keep a path to context helping with it<br>&gt; and not have to redo all the access levels down the road.<br>&gt;<br>&gt; These levels would stay consistent within the scope in which they are<br>&gt; defined.<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Mar 29, 2016, at 8:13 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; If &#39;knowing from the context that it only applies to a certain scope&#39; is<br>&gt; really that helpful, then let&#39;s make it as simple as we can:<br>&gt; &#39;firstprivate&#39;, &#39;secondprivate&#39;, &#39;thirdprivate&#39;, &#39;fourthprivate&#39;. That&#39;s an<br>&gt; easily extensible system: if we need a new level, we add &#39;fifthprivate&#39;.<br>&gt; Then we re-learn the context of each one.<br>&gt;<br>&gt; I don&#39;t see that as advantageous.<br>&gt;<br>&gt; This is the advantage of &#39;moduleprivate&#39; and &#39;fileprivate&#39; is to me: the<br>&gt; definitions of &#39;module&#39; and &#39;file&#39; will not change. I know where the<br>&gt; visibility of these symbols ends, just by reading it. I don&#39;t need to<br>&gt; consult the new Swift X contextual scale. I don&#39;t have to relearn it if we<br>&gt; add a new level. If we add &#39;namespaceprivate&#39; then it is immediately clear<br>&gt; that any symbol so marked is visible within a namespace and if it isn&#39;t<br>&gt; immediately clear then my first documentation search will be for &#39;Swift<br>&gt; namespace&#39; and not something like &#39;Swift restricted&#39; followed by &#39;Swift<br>&gt; namespace&#39;. We bake this objective information into the keyword itself,<br>&gt; information which is simply not present in terms like &#39;private&#39; or &#39;local&#39;<br>&gt; or &#39;secret&#39;, and we become more confident knowing that the definition of<br>&gt; &#39;file&#39; won&#39;t change between versions, and that makes our code easier to<br>&gt; maintain.<br>&gt;<br>&gt; I have enough new things to learn as Swift evolves. Disambiguating<br>&gt; &#39;typealias&#39; into &#39;typealias&#39; and &#39;associatedtype&#39; was a new thing to learn<br>&gt; which improved Swift&#39;s clarity. Renaming &#39;private&#39; as &#39;internal&#39; does not<br>&gt; improve clarity.<br>&gt;<br>&gt; On Tue, Mar 29, 2016 at 3:24 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Just as context is used for variable names does not need a specific<br>&gt;&gt; scoping specifier every time one is declared.  You know from the context in<br>&gt;&gt; which it is used that it only applies to a certain scope.<br>&gt;&gt;<br>&gt;&gt; I would hope that if namespaces are added we would not have<br>&gt;&gt; namespaceprivate etc The keywords would explode and become quite<br>&gt;&gt; confusing..Instead if it is in a namespace you would use internal or<br>&gt;&gt; external and the scope changes to the namespace rather than the file but as<br>&gt;&gt; I said this is beyond the intent of this proposal.<br>&gt;&gt;<br>&gt;&gt; On Mar 29, 2016, at 7:04 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; How is flexibility desirable?<br>&gt;&gt;<br>&gt;&gt; Why is it important to me, if I decide that a given class should only be<br>&gt;&gt; visible at &#39;internal&#39; scope, that the meaning of &#39;internal&#39; should be<br>&gt;&gt; subject to change in future versions of Swift? &#39;Once you know its meaning&#39;<br>&gt;&gt; should mean once!<br>&gt;&gt;<br>&gt;&gt; Right now, I use the word &#39;private&#39; when I want code to be only visible<br>&gt;&gt; within a file. When I migrate a project to Swift 3, an automatic migrator<br>&gt;&gt; may not be able to tell whether a given private property should now be<br>&gt;&gt; scope-private or file-private. Perhaps we can assume that anything private<br>&gt;&gt; referred to in more than one scope should be file-private and everything<br>&gt;&gt; remaining should be scope-private, but I think it would still be wise to<br>&gt;&gt; manually review the changes. Using &#39;internal&#39; to replace &#39;private&#39; may make<br>&gt;&gt; that process even more complicated... but okay, it&#39;s a one-time cost.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see the advantage in knowing that adding another visibility level<br>&gt;&gt; in future will require another intensive review. I&#39;d prefer it if a keyword<br>&gt;&gt; was explicit about its meaning. Migration can then be straightforward:<br>&gt;&gt; everything &#39;private&#39; now can become &#39;file-private&#39;, and if I want to reduce<br>&gt;&gt; the visibility of anything to scope-private then I can do so manually. If<br>&gt;&gt; we add an even more private level in future then the code doesn&#39;t break<br>&gt;&gt; just because &#39;private&#39; was too subjective in its meaning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Mar 29, 2016 at 2:23 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 29, 2016, at 12:32 AM, Andrey Tarantsov via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public (unchanged)<br>&gt;&gt;&gt; external (module access)<br>&gt;&gt;&gt; internal (file access)<br>&gt;&gt;&gt; private (scoped access)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This seems logical and something I could live with, but how is it better<br>&gt;&gt;&gt; than moduleprivate and fileprivate? Also, internal has contradictory prior<br>&gt;&gt;&gt; art in C# and Swift 2 (not that it stops us).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And I see the length of moduleprivate and fileprivate as a feature, and<br>&gt;&gt;&gt; external/internal lacks it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is better than moduleprivate and fileprivate in that it is a single<br>&gt;&gt;&gt; word which is easier to to read and there is less typing. Less typing even<br>&gt;&gt;&gt; with autocomplete is a benefit. Once you know its meaning, that both are<br>&gt;&gt;&gt; relative to file access, you won’t have to look it up. Also, just noticed<br>&gt;&gt;&gt; this, when I type multiword keywords in an email program or chat program<br>&gt;&gt;&gt; autocorrect butts in. This is of practical value because much work is done<br>&gt;&gt;&gt; in chat and email programs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Simpler is better if it sufficiently conveys the meaning and it does in<br>&gt;&gt;&gt; this case. The expectation with most keywords are that they be single<br>&gt;&gt;&gt; words, especially ones that are used the most.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is a nice symmetry to internal/external and public/private.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If external/internal refer to the file, then we don’t need the multiword<br>&gt;&gt;&gt; descriptive versions.  Also, if we decide later that scoping to namespaces<br>&gt;&gt;&gt; is desired these same already reserved keywords give us more flexibility<br>&gt;&gt;&gt; than the more specific keywords would allow. Internal/external could refer<br>&gt;&gt;&gt; to the namespace scope rather than the file scope if it is inside a<br>&gt;&gt;&gt; namespace (this is beyond the scope of the proposal but trying to think<br>&gt;&gt;&gt; ahead). By not explicitly stating the scope you gain flexibility<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/7a5440c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>I still don&#39;t understand your reasoning here. If a private member can be used in a member function, and in closures inside that member function, why can&#39;t it be used in a member type?<br></p><p>I don&#39;t have a notion of &quot;immediate lexical scope&quot;. Nothing else in Swift is only visible in the &quot;immediate&quot; level of curly-braces.<br></p><p>(This doesn&#39;t mean that everything can successfully be referenced from an inner scope; for instance, a local type declared in a function cannot capture local variables or &#39;self&#39;. But there&#39;s a technical limitation there, and even with that you still find those names via name lookup.)<br></p><p>I am actively against this form of the proposal (regardless of names) and I&#39;m sorry I didn&#39;t notice the intent here the first time around.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 28, 2016, at 6:06, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Matthew, please take a look at my example with functions (it works today). In terms of scope, it should be the same with classes. I updated the proposal to restrict private to the immediate scope, so with the update, it will be Inner. Please take a look at the proposal. I tried to be very clear about both the meaning and motivation in the proposal example.<br>&gt; <br>&gt; On Mon, Mar 28, 2016 at 8:58 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Mar 28, 2016, at 6:48 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Outer<br>&gt; <br>&gt; Why Outer?  It looks to me like the enclosing lexical scope is Inner, thus innerVar would *not* be visible in Outer, it would only be visible in Inner.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br>&gt;&gt; <br>&gt;&gt; func f() {<br>&gt;&gt;   let outer = 0<br>&gt;&gt;  // f cannot use inner<br>&gt;&gt;    func g() {<br>&gt;&gt;        let inner = 1<br>&gt;&gt;        // g can use outer<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;  <br>&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather not include this in the proposal.<br>&gt;&gt; <br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible to in the following code: Inner or Outer?<br>&gt;&gt; <br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; The only change that the core team requested was the name changes. I personally would prefer a completely private version where you cannot inject a class into a scope to get access to the scope internals, but it&#39;s an edge case that could be argued either way, and I don&#39;t want to start another lengthy discussion. We already had quite a few.<br>&gt;&gt; <br>&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br>&gt;&gt; <br>&gt;&gt; My understanding is that the new private would be: <br>&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt; - not visible to an extension <br>&gt;&gt; <br>&gt;&gt; Said in code (all in the same file):<br>&gt;&gt; ----------<br>&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt; <br>&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;     }<br>&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt; }<br>&gt;&gt; ----------<br>&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br>&gt;&gt; <br>&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Public <br>&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/66ba5b73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Jordan, I agree with you.  IMO this is a change to the proposal that was not requested by the core team.  The meaning of private was accepted was clearly the traditional meaning of lexical scope, which cleanly follows the nesting of scopes used by the other access control modifiers.  <br></p><p>The modified proposal should only change the declaration modifiers used, not any semantics.  If anyone, including Ilya, wants to introduce more “exotic” semantics this should be done in a new proposal that starts the process from the beginning.<br></p><p><br>&gt; On Mar 28, 2016, at 12:38 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I still don&#39;t understand your reasoning here. If a private member can be used in a member function, and in closures inside that member function, why can&#39;t it be used in a member type?<br>&gt; <br>&gt; I don&#39;t have a notion of &quot;immediate lexical scope&quot;. Nothing else in Swift is only visible in the &quot;immediate&quot; level of curly-braces.<br>&gt; <br>&gt; (This doesn&#39;t mean that everything can successfully be referenced from an inner scope; for instance, a local type declared in a function cannot capture local variables or &#39;self&#39;. But there&#39;s a technical limitation there, and even with that you still find those names via name lookup.)<br>&gt; <br>&gt; I am actively against this form of the proposal (regardless of names) and I&#39;m sorry I didn&#39;t notice the intent here the first time around.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 28, 2016, at 6:06, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Matthew, please take a look at my example with functions (it works today). In terms of scope, it should be the same with classes. I updated the proposal to restrict private to the immediate scope, so with the update, it will be Inner. Please take a look at the proposal. I tried to be very clear about both the meaning and motivation in the proposal example.<br>&gt;&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 8:58 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Mar 28, 2016, at 6:48 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Outer<br>&gt;&gt; <br>&gt;&gt; Why Outer?  It looks to me like the enclosing lexical scope is Inner, thus innerVar would *not* be visible in Outer, it would only be visible in Inner.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather not include this in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible to in the following code: Inner or Outer?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;     class Inner {<br>&gt;&gt;&gt;         private var innerVar: Int<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I personally would prefer a completely private version where you cannot inject a class into a scope to get access to the scope internals, but it&#39;s an edge case that could be argued either way, and I don&#39;t want to start another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding is that the new private would be: <br>&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt; - not visible to an extension <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Public <br>&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt;&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt;&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/512d276d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I *still* don&#39;t understand your reasoning here. If a private member can<br>be used in a member function, and in closures inside that member function,<br>why can&#39;t it be used in a member type?<br></p><p>The simplest answer is that it&#39;s the most private access level, and also<br>one that doesn&#39;t create any confusion. We already discussed several times<br>here whether inner should have access to outer or the other way around.<br>With this design, the answer is neither.<br></p><p>A longer answer is that if you move a function into a type and make it a<br>member function, you change the semantics. It&#39;s no longer the same<br>function. If you move the type inside another type, the semantics is the<br>same. The only difference is that we get shorter names. Also, if you move a<br>function to be a member function, that changes the class API. If you move a<br>class to become a nested class, that does not change the outer class API.<br>Both classes can be used the same way but with different spelling of the<br>name of the inner class.<br></p><p>Also, I think that the terminology of access level really comes from OOP.<br>The problem with the current state of things is that it mixes this<br>terminology with export levels. This proposal makes &quot;private&quot; mean what it<br>means in OOP and extends it so that it makes sense with Swift extensions.<br></p><p>If we were talking about &quot;scoped&quot; level access, the immediate scope<br>addition would be wrong. But if we are talking about &quot;private&quot;, it&#39;s a<br>different matter.<br></p><p>On Mon, Mar 28, 2016 at 1:38 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; I *still* don&#39;t understand your reasoning here. If a private member can<br>&gt; be used in a member function, and in closures inside that member function,<br>&gt; why can&#39;t it be used in a member type?<br>&gt;<br>&gt; I don&#39;t have a notion of &quot;immediate lexical scope&quot;. Nothing else in Swift<br>&gt; is only visible in the &quot;immediate&quot; level of curly-braces.<br>&gt;<br>&gt; (This doesn&#39;t mean that everything can *successfully* be referenced from<br>&gt; an inner scope; for instance, a local type declared in a function cannot<br>&gt; capture local variables or &#39;self&#39;. But there&#39;s a technical limitation<br>&gt; there, and even *with* that you still find those names via name lookup.)<br>&gt;<br>&gt; I am actively against this form of the proposal (regardless of names) and<br>&gt; I&#39;m sorry I didn&#39;t notice the intent here the first time around.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 28, 2016, at 6:06, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Matthew, please take a look at my example with functions (it works today).<br>&gt; In terms of scope, it should be the same with classes. I updated the<br>&gt; proposal to restrict private to the immediate scope, so with the update, it<br>&gt; will be Inner. Please take a look at the proposal. I tried to be very clear<br>&gt; about both the meaning and motivation in the proposal example.<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 8:58 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Mar 28, 2016, at 6:48 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Outer<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why Outer?  It looks to me like the enclosing lexical scope is Inner,<br>&gt;&gt; thus innerVar would *not* be visible in Outer, it would only be visible in<br>&gt;&gt; Inner.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt;&gt;&gt; example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches<br>&gt;&gt;&gt; what you are saying here (outer is visible to g() but inner is not visible<br>&gt;&gt;&gt; to f()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt;&gt;&gt; not include this in the proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So as the proposal stands now, what is the scope that innerVar is<br>&gt;&gt;&gt; visible to in the following code: Inner or Outer?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;     class Inner {<br>&gt;&gt;&gt;         private var innerVar: Int<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt;&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt;&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt;&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt;&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to<br>&gt;&gt;&gt;&gt;&gt; be the same as private (private to the enclosing scope... which happens to<br>&gt;&gt;&gt;&gt;&gt; be the file).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is<br>&gt;&gt;&gt;&gt;&gt; fileprivate. There would still need to be a way to reference scopes other<br>&gt;&gt;&gt;&gt;&gt; than the immediate one (especially since there is no way to say &quot;private&quot;<br>&gt;&gt;&gt;&gt;&gt; and mean moduleprivate), though I think it would strengthen the argument<br>&gt;&gt;&gt;&gt;&gt; for something along the lines of &quot;private(file)&quot;, since it would even<br>&gt;&gt;&gt;&gt;&gt; further reduce the cases where you are spelling something more than just<br>&gt;&gt;&gt;&gt;&gt; &quot;private&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Public<br>&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the<br>&gt;&gt;&gt;&gt;&gt; use of external, as public to me is external since it exports outside of<br>&gt;&gt;&gt;&gt;&gt; the module, whereas what you’re proposing is in fact just limited to the<br>&gt;&gt;&gt;&gt;&gt; module itself. I dislike the current internal keyword too, but at least it<br>&gt;&gt;&gt;&gt;&gt; reads as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt;&gt;&gt; private(scope) new visibility type, item is private to the current<br>&gt;&gt;&gt;&gt;&gt; scope<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/22ad0490/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 06:00:00pm</p></header><div class="content"><p>If the core team is against that reasoning, maybe the proposal can be<br>&quot;accepted with modification&quot; that discards the &quot;immediate scope&quot; addition<br>and makes it &quot;scoped&quot;. Since this was discussed here, and I feel strongly<br>that it&#39;s the clearest and most natural answer to many questions raised in<br>the discussion, I wanted to include it.<br></p><p>On Mon, Mar 28, 2016 at 2:40 PM Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>wrote:<br></p><p>&gt; &gt; I *still* don&#39;t understand your reasoning here. If a private member can<br>&gt; be used in a member function, and in closures inside that member function,<br>&gt; why can&#39;t it be used in a member type?<br>&gt;<br>&gt; The simplest answer is that it&#39;s the most private access level, and also<br>&gt; one that doesn&#39;t create any confusion. We already discussed several times<br>&gt; here whether inner should have access to outer or the other way around.<br>&gt; With this design, the answer is neither.<br>&gt;<br>&gt; A longer answer is that if you move a function into a type and make it a<br>&gt; member function, you change the semantics. It&#39;s no longer the same<br>&gt; function. If you move the type inside another type, the semantics is the<br>&gt; same. The only difference is that we get shorter names. Also, if you move a<br>&gt; function to be a member function, that changes the class API. If you move a<br>&gt; class to become a nested class, that does not change the outer class API.<br>&gt; Both classes can be used the same way but with different spelling of the<br>&gt; name of the inner class.<br>&gt;<br>&gt; Also, I think that the terminology of access level really comes from OOP.<br>&gt; The problem with the current state of things is that it mixes this<br>&gt; terminology with export levels. This proposal makes &quot;private&quot; mean what it<br>&gt; means in OOP and extends it so that it makes sense with Swift extensions.<br>&gt;<br>&gt; If we were talking about &quot;scoped&quot; level access, the immediate scope<br>&gt; addition would be wrong. But if we are talking about &quot;private&quot;, it&#39;s a<br>&gt; different matter.<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 1:38 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; I *still* don&#39;t understand your reasoning here. If a private member can<br>&gt;&gt; be used in a member function, and in closures inside that member function,<br>&gt;&gt; why can&#39;t it be used in a member type?<br>&gt;&gt;<br>&gt;&gt; I don&#39;t have a notion of &quot;immediate lexical scope&quot;. Nothing else in Swift<br>&gt;&gt; is only visible in the &quot;immediate&quot; level of curly-braces.<br>&gt;&gt;<br>&gt;&gt; (This doesn&#39;t mean that everything can *successfully* be referenced from<br>&gt;&gt; an inner scope; for instance, a local type declared in a function cannot<br>&gt;&gt; capture local variables or &#39;self&#39;. But there&#39;s a technical limitation<br>&gt;&gt; there, and even *with* that you still find those names via name lookup.)<br>&gt;&gt;<br>&gt;&gt; I am actively against this form of the proposal (regardless of names) and<br>&gt;&gt; I&#39;m sorry I didn&#39;t notice the intent here the first time around.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 28, 2016, at 6:06, Ilya Belenkiy via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Matthew, please take a look at my example with functions (it works<br>&gt;&gt; today). In terms of scope, it should be the same with classes. I updated<br>&gt;&gt; the proposal to restrict private to the immediate scope, so with the<br>&gt;&gt; update, it will be Inner. Please take a look at the proposal. I tried to be<br>&gt;&gt; very clear about both the meaning and motivation in the proposal example.<br>&gt;&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 8:58 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 28, 2016, at 6:48 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Outer<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why Outer?  It looks to me like the enclosing lexical scope is Inner,<br>&gt;&gt;&gt; thus innerVar would *not* be visible in Outer, it would only be visible in<br>&gt;&gt;&gt; Inner.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 7:30 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com<br>&gt;&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt;&gt;&gt;&gt; example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches<br>&gt;&gt;&gt;&gt; what you are saying here (outer is visible to g() but inner is not visible<br>&gt;&gt;&gt;&gt; to f()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt;&gt;&gt;&gt; not include this in the proposal.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So as the proposal stands now, what is the scope that innerVar is<br>&gt;&gt;&gt;&gt; visible to in the following code: Inner or Outer?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;&gt;     class Inner {<br>&gt;&gt;&gt;&gt;         private var innerVar: Int<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt;&gt;&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt;&gt;&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt;&gt;&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt;&gt;&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;<br>&gt;&gt;&gt;&gt;&gt; matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt;&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt;&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to<br>&gt;&gt;&gt;&gt;&gt;&gt; be the same as private (private to the enclosing scope... which happens to<br>&gt;&gt;&gt;&gt;&gt;&gt; be the file).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate. There would still need to be a way to reference scopes other<br>&gt;&gt;&gt;&gt;&gt;&gt; than the immediate one (especially since there is no way to say &quot;private&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; and mean moduleprivate), though I think it would strengthen the argument<br>&gt;&gt;&gt;&gt;&gt;&gt; for something along the lines of &quot;private(file)&quot;, since it would even<br>&gt;&gt;&gt;&gt;&gt;&gt; further reduce the cases where you are spelling something more than just<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;private&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Public<br>&gt;&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the<br>&gt;&gt;&gt;&gt;&gt;&gt; use of external, as public to me is external since it exports outside of<br>&gt;&gt;&gt;&gt;&gt;&gt; the module, whereas what you’re proposing is in fact just limited to the<br>&gt;&gt;&gt;&gt;&gt;&gt; module itself. I dislike the current internal keyword too, but at least it<br>&gt;&gt;&gt;&gt;&gt;&gt; reads as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt;&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt;&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt;&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt;&gt;&gt;&gt; private(scope) new visibility type, item is private to the current<br>&gt;&gt;&gt;&gt;&gt;&gt; scope<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later<br>&gt;&gt;&gt;&gt;&gt;&gt; for sub-classes such as private(type), as it doesn’t even require a new<br>&gt;&gt;&gt;&gt;&gt;&gt; keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/92c1d629/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 11:40, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; I still don&#39;t understand your reasoning here. If a private member can be used in a member function, and in closures inside that member function, why can&#39;t it be used in a member type?<br>&gt; <br>&gt; The simplest answer is that it&#39;s the most private access level, and also one that doesn&#39;t create any confusion. We already discussed several times here whether inner should have access to outer or the other way around. With this design, the answer is neither.<br>&gt; <br>&gt; A longer answer is that if you move a function into a type and make it a member function, you change the semantics. It&#39;s no longer the same function. If you move the type inside another type, the semantics is the same. The only difference is that we get shorter names. Also, if you move a function to be a member function, that changes the class API. If you move a class to become a nested class, that does not change the outer class API. Both classes can be used the same way but with different spelling of the name of the inner class.<br>&gt; <br>&gt; Also, I think that the terminology of access level really comes from OOP. The problem with the current state of things is that it mixes this terminology with export levels. This proposal makes &quot;private&quot; mean what it means in OOP and extends it so that it makes sense with Swift extensions.<br>&gt; <br>&gt; If we were talking about &quot;scoped&quot; level access, the immediate scope addition would be wrong. But if we are talking about &quot;private&quot;, it&#39;s a different matter.<br></p><p>I don&#39;t buy this argument. Before Swift, there have been plenty of OO languages with extensions and plenty with access control, but no major ones with both except Ruby (discounting Objective-C&#39;s @private instance variables). And, ignoring extensions, the behavior of &#39;private&#39; in all of these languages is to include access from member types:<br></p><p>- C++: yes<br>- Java: yes<br>- C#: yes<br></p><p>- Ruby: no, but even the outer class can&#39;t invoke private methods on a different instance of itself<br>- D: yes, but D&#39;s &quot;private&quot; is closer to Swift&#39;s current &quot;private&quot; than anything else<br></p><p>- Kotlin: yes<br>- Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access control or no nested types, AFAICT<br></p><p>So &quot;private&quot; in these languages doesn&#39;t seem to mean &quot;restricted to this type&quot;, and that shouldn&#39;t be considered the &quot;obvious&quot; meaning when several of us have considered it decidedly non-obvious.<br></p><p>Best,<br>Jordan<br></p><p>P.S. &quot;If you move the type inside another type, the semantics is the same.&quot; This already isn&#39;t true if the new member type is used to satisfy a protocol requirement (which, because of retroactive modeling, counts as &quot;changing the class&#39;s API&quot;), but it especially won&#39;t be true if/when we start allowing member types inside generic types. In that case, the inner type now has extra generic parameterization that it wouldn&#39;t have had before.<br></p><p>P.S. Extensions do make things a little more complicated, but again, there&#39;s almost no precedent here, and pretty much everyone agrees that this new scope-private access level shouldn&#39;t give access to extensions. That also means there&#39;s an option to keep yourself from accidentally accessing scope-private members in a member type: put the member type in an extension.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/2f616d10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 2:30 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; P.S. Extensions do make things a little more complicated, but again, there&#39;s almost no precedent here, and pretty much everyone agrees that this new scope-private access level shouldn&#39;t give access to extensions. That also means there&#39;s an option to keep yourself from accidentally accessing scope-private members in a member type: put the member type in an extension.<br></p><p>The only example that comes to mind is Ruby, where I can add new methods to an existing class, and those new methods indeed have access to existing ‘private’ methods:<br></p><p>class A<br>  private def foo()<br>    puts “foo called”<br>  end<br>end<br></p><p>A.new.foo() # error<br></p><p>class A<br>  def bar() # add new bar method<br>    foo()<br>  end<br>end<br></p><p>A.new.bar() # prints “foo called”<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/bda73bb9/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/bda73bb9/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 14:23, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 28, 2016, at 2:30 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; P.S. Extensions do make things a little more complicated, but again, there&#39;s almost no precedent here, and pretty much everyone agrees that this new scope-private access level shouldn&#39;t give access to extensions. That also means there&#39;s an option to keep yourself from accidentally accessing scope-private members in a member type: put the member type in an extension.<br>&gt; <br>&gt; The only example that comes to mind is Ruby, where I can add new methods to an existing class, and those new methods indeed have access to existing ‘private’ methods:<br>&gt; <br>&gt; class A<br>&gt;   private def foo()<br>&gt;     puts “foo called”<br>&gt;   end<br>&gt; end<br>&gt; <br>&gt; A.new.foo() # error<br>&gt; <br>&gt; class A<br>&gt;   def bar() # add new bar method<br>&gt;     foo()<br>&gt;   end<br>&gt; end<br>&gt; <br>&gt; A.new.bar() # prints “foo called”<br></p><p>Yeah, I tried to sweep that under the rug by noting that Ruby&#39;s definition of &quot;private&quot; didn&#39;t match up with either Java-private or current-Swift-private anyway, but it&#39;s true that someone coming from Ruby might expect this to work.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/ca50d6c2/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Ok, I guess I never used nested types much in C++. If this is standard, I<br>don&#39;t want to change it. I&#39;ll revert back to the pure &quot;scoped&quot; meaning.<br>Thank you, this was very useful.<br></p><p>On Mon, Mar 28, 2016 at 4:30 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; On Mar 28, 2016, at 11:40, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; I *still* don&#39;t understand your reasoning here. If a private member can<br>&gt; be used in a member function, and in closures inside that member function,<br>&gt; why can&#39;t it be used in a member type?<br>&gt;<br>&gt; The simplest answer is that it&#39;s the most private access level, and also<br>&gt; one that doesn&#39;t create any confusion. We already discussed several times<br>&gt; here whether inner should have access to outer or the other way around.<br>&gt; With this design, the answer is neither.<br>&gt;<br>&gt; A longer answer is that if you move a function into a type and make it a<br>&gt; member function, you change the semantics. It&#39;s no longer the same<br>&gt; function. If you move the type inside another type, the semantics is the<br>&gt; same. The only difference is that we get shorter names. Also, if you move a<br>&gt; function to be a member function, that changes the class API. If you move a<br>&gt; class to become a nested class, that does not change the outer class API.<br>&gt; Both classes can be used the same way but with different spelling of the<br>&gt; name of the inner class.<br>&gt;<br>&gt; Also, I think that the terminology of access level really comes from OOP.<br>&gt; The problem with the current state of things is that it mixes this<br>&gt; terminology with export levels. This proposal makes &quot;private&quot; mean what it<br>&gt; means in OOP and extends it so that it makes sense with Swift extensions.<br>&gt;<br>&gt; If we were talking about &quot;scoped&quot; level access, the immediate scope<br>&gt; addition would be wrong. But if we are talking about &quot;private&quot;, it&#39;s a<br>&gt; different matter.<br>&gt;<br>&gt;<br>&gt; I don&#39;t buy this argument. Before Swift, there have been plenty of OO<br>&gt; languages with extensions and plenty with access control, but no major ones<br>&gt; with both except Ruby (discounting Objective-C&#39;s @private instance<br>&gt; variables). And, ignoring extensions, the behavior of &#39;private&#39; in all of<br>&gt; these languages is to include access from member types:<br>&gt;<br>&gt; - C++: yes<br>&gt; - Java: yes<br>&gt; - C#: yes<br>&gt;<br>&gt; - Ruby: no, but even the outer class can&#39;t invoke private methods on a<br>&gt; different instance of itself<br>&gt; - D: yes, but D&#39;s &quot;private&quot; is closer to Swift&#39;s current &quot;private&quot; than<br>&gt; anything else<br>&gt;<br>&gt; - Kotlin: yes<br>&gt; - Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access<br>&gt; control or no nested types, AFAICT<br>&gt;<br>&gt; So &quot;private&quot; in these languages doesn&#39;t seem to mean &quot;restricted to this<br>&gt; type&quot;, and that shouldn&#39;t be considered the &quot;obvious&quot; meaning when several<br>&gt; of us have considered it decidedly non-obvious.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt; P.S. &quot;If you move the type inside another type, the semantics is the<br>&gt; same.&quot; This already isn&#39;t true if the new member type is used to satisfy a<br>&gt; protocol requirement (which, because of retroactive modeling, counts as<br>&gt; &quot;changing the class&#39;s API&quot;), but it especially won&#39;t be true if/when we<br>&gt; start allowing member types inside generic types. In that case, the inner<br>&gt; type now has extra generic parameterization that it wouldn&#39;t have had<br>&gt; before.<br>&gt;<br>&gt; P.S. Extensions do make things a little more complicated, but again,<br>&gt; there&#39;s almost no precedent here, and pretty much everyone agrees that this<br>&gt; new scope-private access level shouldn&#39;t give access to extensions. That<br>&gt; also means there&#39;s an option to keep yourself from accidentally accessing<br>&gt; scope-private members in a member type: put the member type in an extension.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/50c6622c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 28, 2016 at 09:00:00pm</p></header><div class="content"><p>There are two different  questions that we keep bouncing back and forth between. Given:<br></p><p>class Outer {<br>    private var outerVar: Int<br>    class Inner {<br>        private var innerVar: Int<br>    }<br>}<br></p><p>Is outerVar visible inside Inner? To me this seems &#39;obvious&#39;... Yes.<br></p><p>Is innerVar visible to Outer? The answer to this impacts what I think the access modifiers should be called.<br></p><p>&gt; On Mar 28, 2016, at 18:05, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, I guess I never used nested types much in C++. If this is standard, I don&#39;t want to change it. I&#39;ll revert back to the pure &quot;scoped&quot; meaning. Thank you, this was very useful.<br>&gt; <br>&gt; On Mon, Mar 28, 2016 at 4:30 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Mar 28, 2016, at 11:40, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; &gt; I still don&#39;t understand your reasoning here. If a private member can be used in a member function, and in closures inside that member function, why can&#39;t it be used in a member type?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The simplest answer is that it&#39;s the most private access level, and also one that doesn&#39;t create any confusion. We already discussed several times here whether inner should have access to outer or the other way around. With this design, the answer is neither.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A longer answer is that if you move a function into a type and make it a member function, you change the semantics. It&#39;s no longer the same function. If you move the type inside another type, the semantics is the same. The only difference is that we get shorter names. Also, if you move a function to be a member function, that changes the class API. If you move a class to become a nested class, that does not change the outer class API. Both classes can be used the same way but with different spelling of the name of the inner class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, I think that the terminology of access level really comes from OOP. The problem with the current state of things is that it mixes this terminology with export levels. This proposal makes &quot;private&quot; mean what it means in OOP and extends it so that it makes sense with Swift extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we were talking about &quot;scoped&quot; level access, the immediate scope addition would be wrong. But if we are talking about &quot;private&quot;, it&#39;s a different matter.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I don&#39;t buy this argument. Before Swift, there have been plenty of OO languages with extensions and plenty with access control, but no major ones with both except Ruby (discounting Objective-C&#39;s @private instance variables). And, ignoring extensions, the behavior of &#39;private&#39; in all of these languages is to include access from member types:<br>&gt;&gt; <br>&gt;&gt; - C++: yes<br>&gt;&gt; - Java: yes<br>&gt;&gt; - C#: yes<br>&gt;&gt; <br>&gt;&gt; - Ruby: no, but even the outer class can&#39;t invoke private methods on a different instance of itself<br>&gt;&gt; - D: yes, but D&#39;s &quot;private&quot; is closer to Swift&#39;s current &quot;private&quot; than anything else<br>&gt;&gt; <br>&gt;&gt; - Kotlin: yes<br>&gt;&gt; - Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access control or no nested types, AFAICT<br>&gt;&gt; <br>&gt;&gt; So &quot;private&quot; in these languages doesn&#39;t seem to mean &quot;restricted to this type&quot;, and that shouldn&#39;t be considered the &quot;obvious&quot; meaning when several of us have considered it decidedly non-obvious.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. &quot;If you move the type inside another type, the semantics is the same.&quot; This already isn&#39;t true if the new member type is used to satisfy a protocol requirement (which, because of retroactive modeling, counts as &quot;changing the class&#39;s API&quot;), but it especially won&#39;t be true if/when we start allowing member types inside generic types. In that case, the inner type now has extra generic parameterization that it wouldn&#39;t have had before.<br>&gt;&gt; <br>&gt;&gt; P.S. Extensions do make things a little more complicated, but again, there&#39;s almost no precedent here, and pretty much everyone agrees that this new scope-private access level shouldn&#39;t give access to extensions. That also means there&#39;s an option to keep yourself from accidentally accessing scope-private members in a member type: put the member type in an extension.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/17cc89e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 18:20, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt; <br>&gt; There are two different  questions that we keep bouncing back and forth between. Given:<br>&gt; <br>&gt; class Outer {<br>&gt;     private var outerVar: Int<br>&gt;     class Inner {<br>&gt;         private var innerVar: Int<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Is outerVar visible inside Inner? To me this seems &#39;obvious&#39;... Yes.<br>&gt; <br>&gt; Is innerVar visible to Outer? The answer to this impacts what I think the access modifiers should be called.<br></p><p>Fair question. Data:<br></p><p>- C++: no, but the language has &quot;friend&quot;.<br>- Java: yes<br>- C#: no<br></p><p>- Ruby: no, but &quot;private&quot; means something slightly different<br>- D: yes, but &quot;private&quot; means something more like Swift&#39;s current &quot;private&quot;<br></p><p>- Kotlin: no<br>- Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access control or no nested types, AFAICT<br></p><p>So it&#39;s tending towards &quot;no&quot; but it&#39;s not as consistent. I agree that if we pick &quot;yes&quot; then (for example) &quot;scoped&quot; would be a confusing name.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 8:32 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 28, 2016, at 18:20, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are two different  questions that we keep bouncing back and forth between. Given:<br>&gt;&gt; <br>&gt;&gt; class Outer {<br>&gt;&gt;    private var outerVar: Int<br>&gt;&gt;    class Inner {<br>&gt;&gt;        private var innerVar: Int<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is outerVar visible inside Inner? To me this seems &#39;obvious&#39;... Yes.<br>&gt;&gt; <br>&gt;&gt; Is innerVar visible to Outer? The answer to this impacts what I think the access modifiers should be called.<br>&gt; <br>&gt; Fair question. Data:<br>&gt; <br>&gt; - C++: no, but the language has &quot;friend&quot;.<br>&gt; - Java: yes<br>&gt; - C#: no<br>&gt; <br>&gt; - Ruby: no, but &quot;private&quot; means something slightly different<br>&gt; - D: yes, but &quot;private&quot; means something more like Swift&#39;s current &quot;private&quot;<br>&gt; <br>&gt; - Kotlin: no<br>&gt; - Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access control or no nested types, AFAICT<br>&gt; <br>&gt; So it&#39;s tending towards &quot;no&quot; but it&#39;s not as consistent. I agree that if we pick &quot;yes&quot; then (for example) &quot;scoped&quot; would be a confusing name.<br></p><p>No is the only answer that is consistent with Swift’s other access modifiers - i.e. strictly based on lexical scope.  My opinion is that we should stick to strict lexical scoping.  It is a simple and consistent principle that is easy to understand and explain.<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 28, 2016 at 11:00:00pm</p></header><div class="content"><p>I lean towards no as well, but this implies an infinite level of access modifiers:<br>public<br>private(module) // current internal<br>private(file) // current private<br>private(Outer) // all of the rest are the new private<br>private(Inner)<br>private(InnersInner)<br>etc.<br></p><p>The bike shedding has been focused on renaming the current private (and maybe the current internal)  and all of the remaining levels will be called private. I don&#39;t see private(file) and private(module) as special cases, just the most common ones... along with private(Outer).<br></p><p>(Note: private(Outer) and the like aren&#39;t meant as proposed syntax and have problems, but hopefully the meaning is clear in context.)<br></p><p>&gt; On Mar 28, 2016, at 21:38, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 28, 2016, at 8:32 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 28, 2016, at 18:20, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two different  questions that we keep bouncing back and forth between. Given:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;   private var outerVar: Int<br>&gt;&gt;&gt;   class Inner {<br>&gt;&gt;&gt;       private var innerVar: Int<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is outerVar visible inside Inner? To me this seems &#39;obvious&#39;... Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is innerVar visible to Outer? The answer to this impacts what I think the access modifiers should be called.<br>&gt;&gt; <br>&gt;&gt; Fair question. Data:<br>&gt;&gt; <br>&gt;&gt; - C++: no, but the language has &quot;friend&quot;.<br>&gt;&gt; - Java: yes<br>&gt;&gt; - C#: no<br>&gt;&gt; <br>&gt;&gt; - Ruby: no, but &quot;private&quot; means something slightly different<br>&gt;&gt; - D: yes, but &quot;private&quot; means something more like Swift&#39;s current &quot;private&quot;<br>&gt;&gt; <br>&gt;&gt; - Kotlin: no<br>&gt;&gt; - Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access control or no nested types, AFAICT<br>&gt;&gt; <br>&gt;&gt; So it&#39;s tending towards &quot;no&quot; but it&#39;s not as consistent. I agree that if we pick &quot;yes&quot; then (for example) &quot;scoped&quot; would be a confusing name.<br>&gt; <br>&gt; No is the only answer that is consistent with Swift’s other access modifiers - i.e. strictly based on lexical scope.  My opinion is that we should stick to strict lexical scoping.  It is a simple and consistent principle that is easy to understand and explain.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 28, 2016 at 08:00:00pm</p></header><div class="content"><p>I like this, it has been suggested already, single words for easy reading (just looks nicer). follows precedent in other languages for existing words, new words for new concepts. Internal gets demoted from current swift but since that was a swift concept we have more control. <br></p><p>public - outside module<br>external - external to file - default - need to look up first time they see it, but once learned, won’t forget.<br>internal - file internal - people need to look it up first time they see it, but once learned, won’t forget. <br>private - private to class.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 6:38 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Mar 28, 2016, at 18:20, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two different  questions that we keep bouncing back and forth between. Given:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;   private var outerVar: Int<br>&gt;&gt;&gt;   class Inner {<br>&gt;&gt;&gt;       private var innerVar: Int<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is outerVar visible inside Inner? To me this seems &#39;obvious&#39;... Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is innerVar visible to Outer? The answer to this impacts what I think the access modifiers should be called.<br>&gt;&gt; <br>&gt;&gt; Fair question. Data:<br>&gt;&gt; <br>&gt;&gt; - C++: no, but the language has &quot;friend&quot;.<br>&gt;&gt; - Java: yes<br>&gt;&gt; - C#: no<br>&gt;&gt; <br>&gt;&gt; - Ruby: no, but &quot;private&quot; means something slightly different<br>&gt;&gt; - D: yes, but &quot;private&quot; means something more like Swift&#39;s current &quot;private&quot;<br>&gt;&gt; <br>&gt;&gt; - Kotlin: no<br>&gt;&gt; - Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access control or no nested types, AFAICT<br>&gt;&gt; <br>&gt;&gt; So it&#39;s tending towards &quot;no&quot; but it&#39;s not as consistent. I agree that if we pick &quot;yes&quot; then (for example) &quot;scoped&quot; would be a confusing name.<br>&gt; <br>&gt; No is the only answer that is consistent with Swift’s other access modifiers - i.e. strictly based on lexical scope.  My opinion is that we should stick to strict lexical scoping.  It is a simple and consistent principle that is easy to understand and explain.<br></p><p>+1<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 30, 2016 at 10:00:00am</p></header><div class="content"><p>Scala has a sophisticated and interesting access level that might well be<br>good fit to Swift (since the two languages are very similar), e.g<br>Swiftizing some Scala:<br></p><p>class society {<br></p><p>class professional {<br></p><p>class Executive {<br></p><p>private(society) var friends = ...<br></p><p>private(professional) var workDetails = ...<br></p><p>private var secrets = ...<br></p><p><br>func executive() {<br></p><p>print(friends) // OK inside society<br></p><p>print(workDetails) // OK inside professional<br></p><p>print(secrets) // OK inside Executive<br></p><p>}<br></p><p>}<br></p><p>func professional() {<br></p><p>           print(friends) // OK inside society<br></p><p>           print(workDetails) // OK inside professional<br></p><p>           print(secrets) // ERROR outside Executive<br></p><p>}<br></p><p>}<br></p><p>func society() {<br></p><p>           print(friends) // OK inside society<br></p><p>           print(workDetails) // ERROR outside professional<br></p><p>           print(secrets) // ERROR outside Executive<br></p><p>}<br></p><p>}<br></p><p>var exec = society.professional.Executive()<br></p><p><br>print(exec.friends) // ERROR outside society<br>print(exec.workDetails) // ERROR outside professional<br>print(exec.secrets) // ERROR outside Executive<br></p><p><br>In Scala access is:<br></p><p>   1. public, private, or private(S); plus protected for abstract classes<br>   and private(self) for generic classes with generic variance - neither<br>   relevant to this discussion<br>   2. public behaves as expected<br>   3. The default is public, therefore in the example above society,<br>   professional, Executive, and the functions are all public<br>   4. private is scoped so that is only visible within its enclosing scope,<br>   hence secrets is only visible inside Executive<br>   5. private(S) extends the visibility to the named enclosing scope S,<br>   hence workDetails is visible inside professional&#39;s scope because it is<br>   declared private(professional)<br></p><p>If Scala style access modifiers were adopted for Swift then a private(file)<br>modifier would also be necessary to give the current private functionality.<br></p><p>Note Scala has modules, called packages, and in the Scala example I copied<br>and converted to Swift above the society and professional classes were<br>packages and hence there lower-case spelling. Class was the nearest<br>substitute in Swift for a scala package. The original Scala is from:<br>http://www.tutorialspoint.com/scala/scala_access_modifiers.htm<br></p><p>  -- Howard.<br></p><p>On 29 March 2016 at 07:30, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 28, 2016, at 11:40, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; I *still* don&#39;t understand your reasoning here. If a private member can<br>&gt; be used in a member function, and in closures inside that member function,<br>&gt; why can&#39;t it be used in a member type?<br>&gt;<br>&gt; The simplest answer is that it&#39;s the most private access level, and also<br>&gt; one that doesn&#39;t create any confusion. We already discussed several times<br>&gt; here whether inner should have access to outer or the other way around.<br>&gt; With this design, the answer is neither.<br>&gt;<br>&gt; A longer answer is that if you move a function into a type and make it a<br>&gt; member function, you change the semantics. It&#39;s no longer the same<br>&gt; function. If you move the type inside another type, the semantics is the<br>&gt; same. The only difference is that we get shorter names. Also, if you move a<br>&gt; function to be a member function, that changes the class API. If you move a<br>&gt; class to become a nested class, that does not change the outer class API.<br>&gt; Both classes can be used the same way but with different spelling of the<br>&gt; name of the inner class.<br>&gt;<br>&gt; Also, I think that the terminology of access level really comes from OOP.<br>&gt; The problem with the current state of things is that it mixes this<br>&gt; terminology with export levels. This proposal makes &quot;private&quot; mean what it<br>&gt; means in OOP and extends it so that it makes sense with Swift extensions.<br>&gt;<br>&gt; If we were talking about &quot;scoped&quot; level access, the immediate scope<br>&gt; addition would be wrong. But if we are talking about &quot;private&quot;, it&#39;s a<br>&gt; different matter.<br>&gt;<br>&gt;<br>&gt; I don&#39;t buy this argument. Before Swift, there have been plenty of OO<br>&gt; languages with extensions and plenty with access control, but no major ones<br>&gt; with both except Ruby (discounting Objective-C&#39;s @private instance<br>&gt; variables). And, ignoring extensions, the behavior of &#39;private&#39; in all of<br>&gt; these languages is to include access from member types:<br>&gt;<br>&gt; - C++: yes<br>&gt; - Java: yes<br>&gt; - C#: yes<br>&gt;<br>&gt; - Ruby: no, but even the outer class can&#39;t invoke private methods on a<br>&gt; different instance of itself<br>&gt; - D: yes, but D&#39;s &quot;private&quot; is closer to Swift&#39;s current &quot;private&quot; than<br>&gt; anything else<br>&gt;<br>&gt; - Kotlin: yes<br>&gt; - Scala, Python, Go, Rust, Objective-C, Smalltalk: either no access<br>&gt; control or no nested types, AFAICT<br>&gt;<br>&gt; So &quot;private&quot; in these languages doesn&#39;t seem to mean &quot;restricted to this<br>&gt; type&quot;, and that shouldn&#39;t be considered the &quot;obvious&quot; meaning when several<br>&gt; of us have considered it decidedly non-obvious.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt; P.S. &quot;If you move the type inside another type, the semantics is the<br>&gt; same.&quot; This already isn&#39;t true if the new member type is used to satisfy a<br>&gt; protocol requirement (which, because of retroactive modeling, counts as<br>&gt; &quot;changing the class&#39;s API&quot;), but it especially won&#39;t be true if/when we<br>&gt; start allowing member types inside generic types. In that case, the inner<br>&gt; type now has extra generic parameterization that it wouldn&#39;t have had<br>&gt; before.<br>&gt;<br>&gt; P.S. Extensions do make things a little more complicated, but again,<br>&gt; there&#39;s almost no precedent here, and pretty much everyone agrees that this<br>&gt; new scope-private access level shouldn&#39;t give access to extensions. That<br>&gt; also means there&#39;s an option to keep yourself from accidentally accessing<br>&gt; scope-private members in a member type: put the member type in an extension.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/b6b8c83a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br></p><p>I could imagine having these options:<br></p><p>	public							// visible to all everyone<br>	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>	private							// visible only to current scope<br></p><p>scope-name could perhaps be:<br></p><p>* A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>* A module name (or #module for the current module)<br>* A file name string (or #file for the current file)<br></p><p>And then the default would simply be `private(#module)`.<br></p><p>Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 30, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes, #module would be a nice addition and I like the #file and #modules<br>scope names since they can&#39;t clash with user defined names.<br></p><p>  -- Howard.<br></p><p>On 30 March 2016 at 11:47, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; If Scala style access modifiers were adopted for Swift then a<br>&gt; private(file) modifier would also be necessary to give the current private<br>&gt; functionality.<br>&gt;<br>&gt; I could imagine having these options:<br>&gt;<br>&gt;         public                                                  // visible<br>&gt; to all everyone<br>&gt;         private(scope-name, scope-name, …)      // visible to specified<br>&gt; scopes (plus current scope)<br>&gt;         private                                                 // visible<br>&gt; only to current scope<br>&gt;<br>&gt; scope-name could perhaps be:<br>&gt;<br>&gt; * A type name (or Self, which would mimic C++-style private, or perhaps<br>&gt; even C++-style protected depending on how we treat inheritance)<br>&gt; * A module name (or #module for the current module)<br>&gt; * A file name string (or #file for the current file)<br>&gt;<br>&gt; And then the default would simply be `private(#module)`.<br>&gt;<br>&gt; Alternatively, the parameterized level could be given a different name,<br>&gt; like `internal` or `shared`. If that were the case, then `#module` might<br>&gt; simply be the default.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/d6dc9294/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 30, 2016 at 05:00:00am</p></header><div class="content"><p>On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt; <br>&gt; I could imagine having these options:<br>&gt; <br>&gt;    public                            // visible to all everyone<br>&gt;    private(scope-name, scope-name, …)    // visible to specified scopes (plus current scope)<br>&gt;    private                            // visible only to current scope<br>&gt; <br></p><p>Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but not sure it&#39;s useful/worthwhile.<br></p><p> For the current discussion, I would think &quot;scope-name&quot; should be limited to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot; from within ClassB. <br></p><p>(This would also solve the ambiguity of how to reference the main ClassA or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to whichever scope of ClassA you are currently in.)<br></p><p>&gt; scope-name could perhaps be:<br>&gt; <br>&gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br></p><p>But, this is getting into type-based access which is beyond the scope of SE-0025 right?<br></p><p>&gt; * A module name (or #module for the current module)<br>&gt; * A file name string (or #file for the current file)<br>&gt; <br>&gt; And then the default would simply be `private(#module)`.<br>&gt; <br>&gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 30, 2016 at 01:00:00pm</p></header><div class="content"><p>I am not sure if we will ever get another access level. If we do, great,<br>but given how long this discussion has been already, I am not counting on<br>it :-)<br></p><p>Most likely, if we get more, it will be possible to describe it with a<br>simple word, or a combination of words or with some common abbreviations,<br>so I am not worried about extensibility. I think that the names in the<br>proposal are very consistent with Swift as it is today and will serve us<br>well. They are also completely unambiguous and don&#39;t depend on the reading<br>context, so if we come up with other ways to label access levels, it should<br>still be possible to either use these names for backward compatibility or<br>migrate them automatically to new names without any difference in semantics.<br></p><p>We also needed to pick something. I waited for about a week to get<br>everybody&#39;s vote, and I think that I picked a compromise that we can all be<br>at least ok with. (I also originally wanted short single word names). I<br>think we should close the naming thread at this point.<br>On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a<br>&gt; private(file) modifier would also be necessary to give the current private<br>&gt; functionality.<br>&gt; &gt;<br>&gt; &gt; I could imagine having these options:<br>&gt; &gt;<br>&gt; &gt;    public                            // visible to all everyone<br>&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes<br>&gt; (plus current scope)<br>&gt; &gt;    private                            // visible only to current scope<br>&gt; &gt;<br>&gt;<br>&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but not<br>&gt; sure it&#39;s useful/worthwhile.<br>&gt;<br>&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited<br>&gt; to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner<br>&gt; class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot;<br>&gt; from within ClassB.<br>&gt;<br>&gt; (This would also solve the ambiguity of how to reference the main ClassA<br>&gt; or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to<br>&gt; whichever scope of ClassA you are currently in.)<br>&gt;<br>&gt; &gt; scope-name could perhaps be:<br>&gt; &gt;<br>&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps<br>&gt; even C++-style protected depending on how we treat inheritance)<br>&gt;<br>&gt; But, this is getting into type-based access which is beyond the scope of<br>&gt; SE-0025 right?<br>&gt;<br>&gt; &gt; * A module name (or #module for the current module)<br>&gt; &gt; * A file name string (or #file for the current file)<br>&gt; &gt;<br>&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt; &gt;<br>&gt; &gt; Alternatively, the parameterized level could be given a different name,<br>&gt; like `internal` or `shared`. If that were the case, then `#module` might<br>&gt; simply be the default.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/012f628f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 30, 2016 at 07:00:00am</p></header><div class="content"><p>I believe we will need another non-type access level if frameworks are ever divided into submodules.<br></p><p>-DW<br></p><p>&gt; On Mar 30, 2016, at 7:13 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am not sure if we will ever get another access level. If we do, great, but given how long this discussion has been already, I am not counting on it :-)<br>&gt; <br>&gt; Most likely, if we get more, it will be possible to describe it with a simple word, or a combination of words or with some common abbreviations, so I am not worried about extensibility. I think that the names in the proposal are very consistent with Swift as it is today and will serve us well. They are also completely unambiguous and don&#39;t depend on the reading context, so if we come up with other ways to label access levels, it should still be possible to either use these names for backward compatibility or migrate them automatically to new names without any difference in semantics.<br>&gt; <br>&gt; We also needed to pick something. I waited for about a week to get everybody&#39;s vote, and I think that I picked a compromise that we can all be at least ok with. (I also originally wanted short single word names). I think we should close the naming thread at this point.<br>&gt; On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt; &gt;<br>&gt; &gt; I could imagine having these options:<br>&gt; &gt;<br>&gt; &gt;    public                            // visible to all everyone<br>&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes (plus current scope)<br>&gt; &gt;    private                            // visible only to current scope<br>&gt; &gt;<br>&gt; <br>&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but not sure it&#39;s useful/worthwhile.<br>&gt; <br>&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot; from within ClassB.<br>&gt; <br>&gt; (This would also solve the ambiguity of how to reference the main ClassA or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to whichever scope of ClassA you are currently in.)<br>&gt; <br>&gt; &gt; scope-name could perhaps be:<br>&gt; &gt;<br>&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt; <br>&gt; But, this is getting into type-based access which is beyond the scope of SE-0025 right?<br>&gt; <br>&gt; &gt; * A module name (or #module for the current module)<br>&gt; &gt; * A file name string (or #file for the current file)<br>&gt; &gt;<br>&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt; &gt;<br>&gt; &gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/f36c544b/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/f36c544b/attachment-0001.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>So, just so I&#39;m understanding correctly what the new system would be<br>(taking into account Chris Lattner&#39;s comments).<br></p><p>A symbol specified as &#39;public&#39; is visible outside the module.<br>A symbol with no specifier, or specified as &#39;moduleprivate&#39;, is visible<br>only within the module, but anywhere within it. This default lets us start<br>coding first and refine visibility later; &#39;moduleprivate&#39; replaces<br>&#39;internal&#39;.<br>A symbol specified as &#39;fileprivate&#39; is visible only within the file in<br>which it is declared.<br>A symbol specified as &#39;private&#39; is *as private as possible* given its type.<br></p><p>So, if a constant, variable, property, func, enum, struct, etc. is defined<br>inside of a scope, &#39;private&#39; makes it visible only within that scope. All<br>private properties of a nested inner type are visible throughout the scope<br>of the outer type which contains it, and the inner type can see any private<br>properties in the scope which contains it.<br></p><p>If a constant, variable, protocol, class etc. is defined outside of a<br>scope, &#39;private&#39; is synonymous with &#39;fileprivate&#39;. (I don&#39;t know if using<br>&#39;fileprivate&#39; on a type which cannot be &quot;scope-private&quot; should generate a<br>warning.)<br></p><p>Extending to the future: if we add any more levels, they must fit within<br>the hierarchy (i.e. all levels must be expressible as concentric rings in a<br>Venn Diagram, no overlapping) and there must be an objective specifier<br>which signifies its visibility.<br>So if we add a &#39;submodule&#39; level, then a submodule must comprise a set of<br>whole files which is a subset of the containing module. A<br>&#39;submoduleprivate&#39; symbol is visible anywhere in any of the files it<br>consists of - there would be no way to mark part of a file as being within<br>the submodule, and part of the file outside of it.<br></p><p><br>On Wed, Mar 30, 2016 at 2:33 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I believe we will need another non-type access level if frameworks are<br>&gt; ever divided into submodules.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Mar 30, 2016, at 7:13 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I am not sure if we will ever get another access level. If we do, great,<br>&gt; but given how long this discussion has been already, I am not counting on<br>&gt; it :-)<br>&gt;<br>&gt; Most likely, if we get more, it will be possible to describe it with a<br>&gt; simple word, or a combination of words or with some common abbreviations,<br>&gt; so I am not worried about extensibility. I think that the names in the<br>&gt; proposal are very consistent with Swift as it is today and will serve us<br>&gt; well. They are also completely unambiguous and don&#39;t depend on the reading<br>&gt; context, so if we come up with other ways to label access levels, it should<br>&gt; still be possible to either use these names for backward compatibility or<br>&gt; migrate them automatically to new names without any difference in semantics.<br>&gt;<br>&gt; We also needed to pick something. I waited for about a week to get<br>&gt; everybody&#39;s vote, and I think that I picked a compromise that we can all be<br>&gt; at least ok with. (I also originally wanted short single word names). I<br>&gt; think we should close the naming thread at this point.<br>&gt; On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a<br>&gt;&gt; private(file) modifier would also be necessary to give the current private<br>&gt;&gt; functionality.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I could imagine having these options:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    public                            // visible to all everyone<br>&gt;&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes<br>&gt;&gt; (plus current scope)<br>&gt;&gt; &gt;    private                            // visible only to current scope<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but<br>&gt;&gt; not sure it&#39;s useful/worthwhile.<br>&gt;&gt;<br>&gt;&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited<br>&gt;&gt; to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner<br>&gt;&gt; class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot;<br>&gt;&gt; from within ClassB.<br>&gt;&gt;<br>&gt;&gt; (This would also solve the ambiguity of how to reference the main ClassA<br>&gt;&gt; or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to<br>&gt;&gt; whichever scope of ClassA you are currently in.)<br>&gt;&gt;<br>&gt;&gt; &gt; scope-name could perhaps be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps<br>&gt;&gt; even C++-style protected depending on how we treat inheritance)<br>&gt;&gt;<br>&gt;&gt; But, this is getting into type-based access which is beyond the scope of<br>&gt;&gt; SE-0025 right?<br>&gt;&gt;<br>&gt;&gt; &gt; * A module name (or #module for the current module)<br>&gt;&gt; &gt; * A file name string (or #file for the current file)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatively, the parameterized level could be given a different name,<br>&gt;&gt; like `internal` or `shared`. If that were the case, then `#module` might<br>&gt;&gt; simply be the default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/1e19ca3c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 07:00:00am</p></header><div class="content"><p>I understand the desire to wrap this up as it has gone on for a long time.<br></p><p>I just don’t like the length and readability of the moduleprivate and fileprivate names (and how auto correct is always “fixing” it for me when I try to write about it). As I mentioned these will likely be used very often in code and just don’t look very nice. These are potentially used on almost every method, class, property and struct. I don’t think that we should use something that is perhaps a little clearer in meaning but hard to read for something that is used so frequently through the code. There are plenty of places where you have to look something up the first time you encounter it in any programming language and this explicitness is not a big enough win to sacrifice readability. A single word keyword is a requirement for me. <br></p><p><br> <br>&gt; On Mar 30, 2016, at 6:13 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am not sure if we will ever get another access level. If we do, great, but given how long this discussion has been already, I am not counting on it :-)<br>&gt; <br>&gt; Most likely, if we get more, it will be possible to describe it with a simple word, or a combination of words or with some common abbreviations, so I am not worried about extensibility. I think that the names in the proposal are very consistent with Swift as it is today and will serve us well. They are also completely unambiguous and don&#39;t depend on the reading context, so if we come up with other ways to label access levels, it should still be possible to either use these names for backward compatibility or migrate them automatically to new names without any difference in semantics.<br>&gt; <br>&gt; We also needed to pick something. I waited for about a week to get everybody&#39;s vote, and I think that I picked a compromise that we can all be at least ok with. (I also originally wanted short single word names). I think we should close the naming thread at this point.<br>&gt; On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt; &gt;<br>&gt; &gt; I could imagine having these options:<br>&gt; &gt;<br>&gt; &gt;    public                            // visible to all everyone<br>&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes (plus current scope)<br>&gt; &gt;    private                            // visible only to current scope<br>&gt; &gt;<br>&gt; <br>&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but not sure it&#39;s useful/worthwhile.<br>&gt; <br>&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot; from within ClassB.<br>&gt; <br>&gt; (This would also solve the ambiguity of how to reference the main ClassA or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to whichever scope of ClassA you are currently in.)<br>&gt; <br>&gt; &gt; scope-name could perhaps be:<br>&gt; &gt;<br>&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt; <br>&gt; But, this is getting into type-based access which is beyond the scope of SE-0025 right?<br>&gt; <br>&gt; &gt; * A module name (or #module for the current module)<br>&gt; &gt; * A file name string (or #file for the current file)<br>&gt; &gt;<br>&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt; &gt;<br>&gt; &gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/c64994ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>I understand. The same is true about associatedtype. My iPhone just<br>suggested it as a one word completion! I think the same will happen with<br>these names. Chris Lattner already described the rationale in this thread,<br>so I won&#39;t repeat it. I also originally wanted short names, but I think<br>that we ended up with a good compromise (crystal clear, searchable keywords<br>that are consistent with other keywords).<br></p><p>On Wed, Mar 30, 2016 at 10:54 AM Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; I understand the desire to wrap this up as it has gone on for a long time.<br>&gt;<br>&gt; I just don’t like the length and readability of the moduleprivate and<br>&gt; fileprivate names (and how auto correct is always “fixing” it for me when I<br>&gt; try to write about it). As I mentioned these will likely be used very often<br>&gt; in code and just don’t look very nice. These are potentially used on almost<br>&gt; every method, class, property and struct. I don’t think that we should use<br>&gt; something that is perhaps a little clearer in meaning but hard to read for<br>&gt; something that is used so frequently through the code. There are plenty of<br>&gt; places where you have to look something up the first time you encounter it<br>&gt; in any programming language and this explicitness is not a big enough win<br>&gt; to sacrifice readability. A single word keyword is a requirement for me.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mar 30, 2016, at 6:13 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I am not sure if we will ever get another access level. If we do, great,<br>&gt; but given how long this discussion has been already, I am not counting on<br>&gt; it :-)<br>&gt;<br>&gt; Most likely, if we get more, it will be possible to describe it with a<br>&gt; simple word, or a combination of words or with some common abbreviations,<br>&gt; so I am not worried about extensibility. I think that the names in the<br>&gt; proposal are very consistent with Swift as it is today and will serve us<br>&gt; well. They are also completely unambiguous and don&#39;t depend on the reading<br>&gt; context, so if we come up with other ways to label access levels, it should<br>&gt; still be possible to either use these names for backward compatibility or<br>&gt; migrate them automatically to new names without any difference in semantics.<br>&gt;<br>&gt; We also needed to pick something. I waited for about a week to get<br>&gt; everybody&#39;s vote, and I think that I picked a compromise that we can all be<br>&gt; at least ok with. (I also originally wanted short single word names). I<br>&gt; think we should close the naming thread at this point.<br>&gt; On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a<br>&gt;&gt; private(file) modifier would also be necessary to give the current private<br>&gt;&gt; functionality.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I could imagine having these options:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    public                            // visible to all everyone<br>&gt;&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes<br>&gt;&gt; (plus current scope)<br>&gt;&gt; &gt;    private                            // visible only to current scope<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but<br>&gt;&gt; not sure it&#39;s useful/worthwhile.<br>&gt;&gt;<br>&gt;&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited<br>&gt;&gt; to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner<br>&gt;&gt; class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot;<br>&gt;&gt; from within ClassB.<br>&gt;&gt;<br>&gt;&gt; (This would also solve the ambiguity of how to reference the main ClassA<br>&gt;&gt; or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to<br>&gt;&gt; whichever scope of ClassA you are currently in.)<br>&gt;&gt;<br>&gt;&gt; &gt; scope-name could perhaps be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps<br>&gt;&gt; even C++-style protected depending on how we treat inheritance)<br>&gt;&gt;<br>&gt;&gt; But, this is getting into type-based access which is beyond the scope of<br>&gt;&gt; SE-0025 right?<br>&gt;&gt;<br>&gt;&gt; &gt; * A module name (or #module for the current module)<br>&gt;&gt; &gt; * A file name string (or #file for the current file)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatively, the parameterized level could be given a different name,<br>&gt;&gt; like `internal` or `shared`. If that were the case, then `#module` might<br>&gt;&gt; simply be the default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/3a036ac4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 09:00:00am</p></header><div class="content"><p>Associatedtype won’t be used nearly as often as these operators, I support the rational there but not in this case as it will be seen far more often. <br></p><p>- Paul<br>&gt; On Mar 30, 2016, at 8:28 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; I understand. The same is true about associatedtype. My iPhone just suggested it as a one word completion! I think the same will happen with these names. Chris Lattner already described the rationale in this thread, so I won&#39;t repeat it. I also originally wanted short names, but I think that we ended  up with a good compromise (crystal clear, searchable keywords  that are consistent with other keywords). <br>&gt; <br>&gt; On Wed, Mar 30, 2016 at 10:54 AM Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt; I understand the desire to wrap this up as it has gone on for a long time.<br>&gt; <br>&gt; I just don’t like the length and readability of the moduleprivate and fileprivate names (and how auto correct is always “fixing” it for me when I try to write about it). As I mentioned these will likely be used very often in code and just don’t look very nice. These are potentially used on almost every method, class, property and struct. I don’t think that we should use something that is perhaps a little clearer in meaning but hard to read for something that is used so frequently through the code. There are plenty of places where you have to look something up the first time you encounter it in any programming language and this explicitness is not a big enough win to sacrifice readability. A single word keyword is a requirement for me. <br>&gt; <br>&gt; <br>&gt;  <br>&gt;&gt; On Mar 30, 2016, at 6:13 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am not sure if we will ever get another access level. If we do, great, but given how long this discussion has been already, I am not counting on it :-)<br>&gt;&gt; <br>&gt;&gt; Most likely, if we get more, it will be possible to describe it with a simple word, or a combination of words or with some common abbreviations, so I am not worried about extensibility. I think that the names in the proposal are very consistent with Swift as it is today and will serve us well. They are also completely unambiguous and don&#39;t depend on the reading context, so if we come up with other ways to label access levels, it should still be possible to either use these names for backward compatibility or migrate them automatically to new names without any difference in semantics.<br>&gt;&gt; <br>&gt;&gt; We also needed to pick something. I waited for about a week to get everybody&#39;s vote, and I think that I picked a compromise that we can all be at least ok with. (I also originally wanted short single word names). I think we should close the naming thread at this point.<br>&gt;&gt; On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I could imagine having these options:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    public                            // visible to all everyone<br>&gt;&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes (plus current scope)<br>&gt;&gt; &gt;    private                            // visible only to current scope<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but not sure it&#39;s useful/worthwhile.<br>&gt;&gt; <br>&gt;&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot; from within ClassB.<br>&gt;&gt; <br>&gt;&gt; (This would also solve the ambiguity of how to reference the main ClassA or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to whichever scope of ClassA you are currently in.)<br>&gt;&gt; <br>&gt;&gt; &gt; scope-name could perhaps be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt;&gt; <br>&gt;&gt; But, this is getting into type-based access which is beyond the scope of SE-0025 right?<br>&gt;&gt; <br>&gt;&gt; &gt; * A module name (or #module for the current module)<br>&gt;&gt; &gt; * A file name string (or #file for the current file)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/bdd39e4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 9:06 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Associatedtype won’t be used nearly as often as these operators, I support the rational there but not in this case as it will be seen far more often. <br></p><p>What do you mean?  No-one needs to write out “moduleprivate” (because it is the default) and “fileprivate” is rarely needed.  Since it is rare, it is *better* for it to be explicit.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; - Paul<br>&gt;&gt; On Mar 30, 2016, at 8:28 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I understand. The same is true about associatedtype. My iPhone just suggested it as a one word completion! I think the same will happen with these names. Chris Lattner already described the rationale in this thread, so I won&#39;t repeat it. I also originally wanted short names, but I think that we ended  up with a good compromise (crystal clear, searchable keywords  that are consistent with other keywords). <br>&gt;&gt; <br>&gt;&gt; On Wed, Mar 30, 2016 at 10:54 AM Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I understand the desire to wrap this up as it has gone on for a long time.<br>&gt;&gt; <br>&gt;&gt; I just don’t like the length and readability of the moduleprivate and fileprivate names (and how auto correct is always “fixing” it for me when I try to write about it). As I mentioned these will likely be used very often in code and just don’t look very nice. These are potentially used on almost every method, class, property and struct. I don’t think that we should use something that is perhaps a little clearer in meaning but hard to read for something that is used so frequently through the code. There are plenty of places where you have to look something up the first time you encounter it in any programming language and this explicitness is not a big enough win to sacrifice readability. A single word keyword is a requirement for me. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; On Mar 30, 2016, at 6:13 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not sure if we will ever get another access level. If we do, great, but given how long this discussion has been already, I am not counting on it :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most likely, if we get more, it will be possible to describe it with a simple word, or a combination of words or with some common abbreviations, so I am not worried about extensibility. I think that the names in the proposal are very consistent with Swift as it is today and will serve us well. They are also completely unambiguous and don&#39;t depend on the reading context, so if we come up with other ways to label access levels, it should still be possible to either use these names for backward compatibility or migrate them automatically to new names without any difference in semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We also needed to pick something. I waited for about a week to get everybody&#39;s vote, and I think that I picked a compromise that we can all be at least ok with. (I also originally wanted short single word names). I think we should close the naming thread at this point.<br>&gt;&gt;&gt; On Wed, Mar 30, 2016 at 5:26 AM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 20:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I could imagine having these options:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;    public                            // visible to all everyone<br>&gt;&gt;&gt; &gt;    private(scope-name, scope-name, …)    // visible to specified scopes (plus current scope)<br>&gt;&gt;&gt; &gt;    private                            // visible only to current scope<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing multiple &quot;scope-name&quot;s is a lot of flexibility and power, but not sure it&#39;s useful/worthwhile.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  For the current discussion, I would think &quot;scope-name&quot; should be limited to an enclosing scope only.  So you can say &quot;private(Outer)&quot; from an Inner class or &quot;private(#file)&quot; from within a class, but not &quot;private(ClassA)&quot; from within ClassB.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (This would also solve the ambiguity of how to reference the main ClassA or a specific extension to ClassA... &quot;private(ClassA)&quot; can only refer to whichever scope of ClassA you are currently in.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; scope-name could perhaps be:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But, this is getting into type-based access which is beyond the scope of SE-0025 right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; * A module name (or #module for the current module)<br>&gt;&gt;&gt; &gt; * A file name string (or #file for the current file)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; And then the default would simply be `private(#module)`.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/0026dd14/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 07:00:00am</p></header><div class="content"><p>The scala idea is interesting, has anyone used it extensively to understand how well it works in practice? Is it too fiddly? Do you spend too much time thinking about access levels. <br></p><p>&gt; On Mar 29, 2016, at 5:47 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt; <br>&gt; I could imagine having these options:<br>&gt; <br>&gt; 	public							// visible to all everyone<br>&gt; 	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>&gt; 	private							// visible only to current scope<br>&gt; <br>&gt; scope-name could perhaps be:<br>&gt; <br>&gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt; * A module name (or #module for the current module)<br>&gt; * A file name string (or #file for the current file)<br>&gt; <br>&gt; And then the default would simply be `private(#module)`.<br>&gt; <br>&gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt; <br>&gt; I could imagine having these options:<br>&gt; <br>&gt; 	public							// visible to all everyone<br>&gt; 	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>&gt; 	private							// visible only to current scope<br>&gt; <br>&gt; scope-name could perhaps be:<br>&gt; <br>&gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt; * A module name (or #module for the current module)<br>&gt; * A file name string (or #file for the current file)<br>&gt; <br>&gt; And then the default would simply be `private(#module)`.<br>&gt; <br>&gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br></p><p>I&#39;ve actually thought about this before (well, at least at the module level) and ultimately decided it was a bad idea for it to be part of the access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing with another module, even if it&#39;s just one other module.<br></p><p>- You don&#39;t get any secrecy because you have to publish all symbols and metadata as public.<br>- You can&#39;t optimize based on knowledge of how the declaration is used.<br>- Exposing something to another module can be viral, just like making something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances are exposed, a class&#39;s superclass must be exposed, all the types in a function signature have to be exposed (or already public).<br></p><p>All of this means that this behaves more like &quot;public&quot; than like &quot;private&quot;; it&#39;s &quot;public, but not the entire public&quot;. The restriction on use sites is an artificial one.<br></p><p>Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br></p><p><br>At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/7cb1da30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 30, 2016 at 08:00:00pm</p></header><div class="content"><p>Damn, and I thought it was clear all this time that &#39;private(module)&#39;, or<br>&#39;private(#module)&#39;, or &#39;moduleprivate&#39;, meant that the symbol is visible<br>only inside the module. It&#39;s always been a suggested replacement specifier<br>for &#39;internal&#39;.<br></p><p>On Wed, Mar 30, 2016 at 6:33 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; If Scala style access modifiers were adopted for Swift then a<br>&gt; private(file) modifier would also be necessary to give the current private<br>&gt; functionality.<br>&gt;<br>&gt;<br>&gt; I could imagine having these options:<br>&gt;<br>&gt; public // visible to all everyone<br>&gt; private(scope-name, scope-name, …) // visible to specified scopes (plus<br>&gt; current scope)<br>&gt; private // visible only to current scope<br>&gt;<br>&gt; scope-name could perhaps be:<br>&gt;<br>&gt; * A type name (or Self, which would mimic C++-style private, or perhaps<br>&gt; even C++-style protected depending on how we treat inheritance)<br>&gt; * A module name (or #module for the current module)<br>&gt; * A file name string (or #file for the current file)<br>&gt;<br>&gt; And then the default would simply be `private(#module)`.<br>&gt;<br>&gt; Alternatively, the parameterized level could be given a different name,<br>&gt; like `internal` or `shared`. If that were the case, then `#module` might<br>&gt; simply be the default.<br>&gt;<br>&gt;<br>&gt; I&#39;ve actually thought about this before (well, at least at the module<br>&gt; level) and ultimately decided it was a bad idea for it to be part of the<br>&gt; access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing<br>&gt; with another module, even if it&#39;s just *one* other module.<br>&gt;<br>&gt; - You don&#39;t get any secrecy because you have to publish all symbols and<br>&gt; metadata as public.<br>&gt; - You can&#39;t optimize based on knowledge of how the declaration is used.<br>&gt; - Exposing something to another module can be viral, just like making<br>&gt; something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances<br>&gt; are exposed, a class&#39;s superclass must be exposed, all the types in a<br>&gt; function signature have to be exposed (or already public).<br>&gt;<br>&gt; All of this means that this behaves more like &quot;public&quot; than like<br>&gt; &quot;private&quot;; it&#39;s &quot;public, but not the *entire* public&quot;. The restriction on<br>&gt; use sites is an artificial one.<br>&gt;<br>&gt; Now, it *is* a very useful feature! Apple, of course, does this all the<br>&gt; time with its &quot;SPI&quot;. But I think the right form of the feature is to be<br>&gt; able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or<br>&gt; &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then<br>&gt; have a tool to *strip them out* of the swiftmodule file when you&#39;re ready<br>&gt; to ship this module to people. That way you&#39;re enforcing your limitations<br>&gt; as much as possible, while still using the same binaries for both internal<br>&gt; and external clients. (Remember that the swiftmodule file serves<br>&gt; essentially the same purpose as header files in C.)<br>&gt;<br>&gt;<br>&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but I<br>&gt; don&#39;t think there&#39;s enough gain to writing file strings directly in source<br>&gt; files. Pointing to a future &quot;comprehensive submodules model&quot; would be<br>&gt; disingenuous because that&#39;s a *huge* feature with a lot of subtlety, but<br>&gt; I think &quot;just make this accessible to one other file&quot; is additional<br>&gt; complexity for not much gain. It&#39;s also subject to slippery-slope: once one<br>&gt; file is added, I don&#39;t think anyone would think too hard about adding a<br>&gt; *second* file, and then…<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/08de35d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 30, 2016 at 12:00:00pm</p></header><div class="content"><p>Ah, sorry! Those are all clear to me; it&#39;s the possibility of writing some other module name there that would have the wrong implications.<br></p><p>Jordan<br></p><p>&gt; On Mar 30, 2016, at 12:38 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Damn, and I thought it was clear all this time that &#39;private(module)&#39;, or &#39;private(#module)&#39;, or &#39;moduleprivate&#39;, meant that the symbol is visible only inside the module. It&#39;s always been a suggested replacement specifier for &#39;internal&#39;.<br>&gt; <br>&gt; On Wed, Mar 30, 2016 at 6:33 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt;&gt; <br>&gt;&gt; I could imagine having these options:<br>&gt;&gt; <br>&gt;&gt; 	public							// visible to all everyone<br>&gt;&gt; 	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>&gt;&gt; 	private							// visible only to current scope<br>&gt;&gt; <br>&gt;&gt; scope-name could perhaps be:<br>&gt;&gt; <br>&gt;&gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt;&gt; * A module name (or #module for the current module)<br>&gt;&gt; * A file name string (or #file for the current file)<br>&gt;&gt; <br>&gt;&gt; And then the default would simply be `private(#module)`.<br>&gt;&gt; <br>&gt;&gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt; <br>&gt; I&#39;ve actually thought about this before (well, at least at the module level) and ultimately decided it was a bad idea for it to be part of the access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing with another module, even if it&#39;s just one other module.<br>&gt; <br>&gt; - You don&#39;t get any secrecy because you have to publish all symbols and metadata as public.<br>&gt; - You can&#39;t optimize based on knowledge of how the declaration is used.<br>&gt; - Exposing something to another module can be viral, just like making something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances are exposed, a class&#39;s superclass must be exposed, all the types in a function signature have to be exposed (or already public).<br>&gt; <br>&gt; All of this means that this behaves more like &quot;public&quot; than like &quot;private&quot;; it&#39;s &quot;public, but not the entire public&quot;. The restriction on use sites is an artificial one.<br>&gt; <br>&gt; Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br>&gt; <br>&gt; <br>&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/72b1473a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March 30, 2016 at 07:00:00pm</p></header><div class="content"><p>What about local for a file only or scope definition ? <br></p><p>Sent from Supmenow.com<br></p><p><br></p><p><br>On Wed, Mar 30, 2016 at 12:39 PM -0700, &quot;Jordan Rose via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>Ah, sorry! Those are all clear to me; it&#39;s the possibility of writing some other module name there that would have the wrong implications.<br>Jordan<br>On Mar 30, 2016, at 12:38 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>Damn, and I thought it was clear all this time that &#39;private(module)&#39;, or &#39;private(#module)&#39;, or &#39;moduleprivate&#39;, meant that the symbol is visible only inside the module. It&#39;s always been a suggested replacement specifier for &#39;internal&#39;.<br>On Wed, Mar 30, 2016 at 6:33 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br></p><p>I could imagine having these options:<br></p><p>	public							// visible to all everyone<br>	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>	private							// visible only to current scope<br></p><p>scope-name could perhaps be:<br></p><p>* A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>* A module name (or #module for the current module)<br>* A file name string (or #file for the current file)<br></p><p>And then the default would simply be `private(#module)`.<br></p><p>Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br></p><p>I&#39;ve actually thought about this before (well, at least at the module level) and ultimately decided it was a bad idea for it to be part of the access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing with another module, even if it&#39;s just one other module.<br>- You don&#39;t get any secrecy because you have to publish all symbols and metadata as public.- You can&#39;t optimize based on knowledge of how the declaration is used.- Exposing something to another module can be viral, just like making something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances are exposed, a class&#39;s superclass must be exposed, all the types in a function signature have to be exposed (or already public).<br>All of this means that this behaves more like &quot;public&quot; than like &quot;private&quot;; it&#39;s &quot;public, but not the entire public&quot;. The restriction on use sites is an artificial one.<br>Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br></p><p>At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br>Jordan<br>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/b3235a95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>How about public, private, private(#file), and private(#module)? At a later<br>date, if needed, private(S1, S3, ...) could be added. This would be a<br>minimal change and not stop an extension in the future if requested.<br></p><p>On Thursday, 31 March 2016, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What about local for a file only or scope definition ?<br>&gt;<br>&gt; Sent from Supmenow.com &lt;http://supmenow.com&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Mar 30, 2016 at 12:39 PM -0700, &quot;Jordan Rose via swift-evolution&quot;<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Ah, sorry! Those are all clear to me; it&#39;s the possibility of writing some<br>&gt;&gt; *other* module name there that would have the wrong implications.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On Mar 30, 2016, at 12:38 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;narrativium%2Bswift at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Damn, and I thought it was clear all this time that &#39;private(module)&#39;, or<br>&gt;&gt; &#39;private(#module)&#39;, or &#39;moduleprivate&#39;, meant that the symbol is visible<br>&gt;&gt; only inside the module. It&#39;s always been a suggested replacement specifier<br>&gt;&gt; for &#39;internal&#39;.<br>&gt;&gt;<br>&gt;&gt; On Wed, Mar 30, 2016 at 6:33 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;brent at architechies.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If Scala style access modifiers were adopted for Swift then a<br>&gt;&gt;&gt; private(file) modifier would also be necessary to give the current private<br>&gt;&gt;&gt; functionality.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I could imagine having these options:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public // visible to all everyone<br>&gt;&gt;&gt; private(scope-name, scope-name, …) // visible to specified scopes (plus<br>&gt;&gt;&gt; current scope)<br>&gt;&gt;&gt; private // visible only to current scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; scope-name could perhaps be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * A type name (or Self, which would mimic C++-style private, or perhaps<br>&gt;&gt;&gt; even C++-style protected depending on how we treat inheritance)<br>&gt;&gt;&gt; * A module name (or #module for the current module)<br>&gt;&gt;&gt; * A file name string (or #file for the current file)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And then the default would simply be `private(#module)`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatively, the parameterized level could be given a different name,<br>&gt;&gt;&gt; like `internal` or `shared`. If that were the case, then `#module` might<br>&gt;&gt;&gt; simply be the default.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve actually thought about this before (well, at least at the module<br>&gt;&gt;&gt; level) and ultimately decided it was a bad idea for it to be part of the<br>&gt;&gt;&gt; access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing<br>&gt;&gt;&gt; with another module, even if it&#39;s just *one* other module.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - You don&#39;t get any secrecy because you have to publish all symbols and<br>&gt;&gt;&gt; metadata as public.<br>&gt;&gt;&gt; - You can&#39;t optimize based on knowledge of how the declaration is used.<br>&gt;&gt;&gt; - Exposing something to another module can be viral, just like making<br>&gt;&gt;&gt; something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances<br>&gt;&gt;&gt; are exposed, a class&#39;s superclass must be exposed, all the types in a<br>&gt;&gt;&gt; function signature have to be exposed (or already public).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; All of this means that this behaves more like &quot;public&quot; than like<br>&gt;&gt;&gt; &quot;private&quot;; it&#39;s &quot;public, but not the *entire* public&quot;. The restriction<br>&gt;&gt;&gt; on use sites is an artificial one.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now, it *is* a very useful feature! Apple, of course, does this all the<br>&gt;&gt;&gt; time with its &quot;SPI&quot;. But I think the right form of the feature is to be<br>&gt;&gt;&gt; able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or<br>&gt;&gt;&gt; &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then<br>&gt;&gt;&gt; have a tool to *strip them out* of the swiftmodule file when you&#39;re<br>&gt;&gt;&gt; ready to ship this module to people. That way you&#39;re enforcing your<br>&gt;&gt;&gt; limitations as much as possible, while still using the same binaries for<br>&gt;&gt;&gt; both internal and external clients. (Remember that the swiftmodule file<br>&gt;&gt;&gt; serves essentially the same purpose as header files in C.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but<br>&gt;&gt;&gt; I don&#39;t think there&#39;s enough gain to writing file strings directly in<br>&gt;&gt;&gt; source files. Pointing to a future &quot;comprehensive submodules model&quot; would<br>&gt;&gt;&gt; be disingenuous because that&#39;s a *huge* feature with a lot of subtlety,<br>&gt;&gt;&gt; but I think &quot;just make this accessible to one other file&quot; is additional<br>&gt;&gt;&gt; complexity for not much gain. It&#39;s also subject to slippery-slope: once one<br>&gt;&gt;&gt; file is added, I don&#39;t think anyone would think too hard about adding a<br>&gt;&gt;&gt; *second* file, and then…<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/e10dcd41/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 30, 2016 at 09:00:00pm</p></header><div class="content"><p>Some other module name would seem to suggest &quot;public(scope-name)&quot;<br></p><p>I agree &quot;private(scope-name)&quot; should only be used to disambiguate between the concentric scope circles (if I declare something in the main class it is visible in the main class declaration scope, the file scope, and the module scope... And I can declare something private to any of those scopes).<br></p><p>&gt; On Mar 30, 2016, at 15:39, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ah, sorry! Those are all clear to me; it&#39;s the possibility of writing some other module name there that would have the wrong implications.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 12:38 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Damn, and I thought it was clear all this time that &#39;private(module)&#39;, or &#39;private(#module)&#39;, or &#39;moduleprivate&#39;, meant that the symbol is visible only inside the module. It&#39;s always been a suggested replacement specifier for &#39;internal&#39;.<br>&gt;&gt; <br>&gt;&gt; On Wed, Mar 30, 2016 at 6:33 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could imagine having these options:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	public							// visible to all everyone<br>&gt;&gt;&gt;&gt; 	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>&gt;&gt;&gt;&gt; 	private							// visible only to current scope<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; scope-name could perhaps be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt;&gt;&gt;&gt; * A module name (or #module for the current module)<br>&gt;&gt;&gt;&gt; * A file name string (or #file for the current file)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And then the default would simply be `private(#module)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve actually thought about this before (well, at least at the module level) and ultimately decided it was a bad idea for it to be part of the access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing with another module, even if it&#39;s just one other module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - You don&#39;t get any secrecy because you have to publish all symbols and metadata as public.<br>&gt;&gt;&gt; - You can&#39;t optimize based on knowledge of how the declaration is used.<br>&gt;&gt;&gt; - Exposing something to another module can be viral, just like making something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances are exposed, a class&#39;s superclass must be exposed, all the types in a function signature have to be exposed (or already public).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All of this means that this behaves more like &quot;public&quot; than like &quot;private&quot;; it&#39;s &quot;public, but not the entire public&quot;. The restriction on use sites is an artificial one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/9b9c5225/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 30, 2016 at 08:00:00pm</p></header><div class="content"><p>I wonder if perhaps it would be clearer if public was used for indicating something was published, even if it is published to a restricted set:<br></p><p>public(#all)		- expose outside the framework, shortened to public<br>public(#module)	- exposed module-wide, default if omitted<br>public(#file)		- expose to other code within the file<br>private			- not exposed outside lexical scope<br></p><p>named contexts such as a particular type or other module would be possible in the future via non-# names, and multiple contexts could be possible in the future via comma-separated values<br></p><p>-DW<br></p><p>&gt; On Mar 30, 2016, at 7:24 PM, Matthew Judge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some other module name would seem to suggest &quot;public(scope-name)&quot;<br>&gt; <br>&gt; I agree &quot;private(scope-name)&quot; should only be used to disambiguate between the concentric scope circles (if I declare something in the main class it is visible in the main class declaration scope, the file scope, and the module scope... And I can declare something private to any of those scopes).<br>&gt; <br>&gt; On Mar 30, 2016, at 15:39, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Ah, sorry! Those are all clear to me; it&#39;s the possibility of writing some other module name there that would have the wrong implications.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 12:38 , Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium+swift at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Damn, and I thought it was clear all this time that &#39;private(module)&#39;, or &#39;private(#module)&#39;, or &#39;moduleprivate&#39;, meant that the symbol is visible only inside the module. It&#39;s always been a suggested replacement specifier for &#39;internal&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Mar 30, 2016 at 6:33 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 29, 2016, at 17:47 , Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If Scala style access modifiers were adopted for Swift then a private(file) modifier would also be necessary to give the current private functionality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could imagine having these options:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	public							// visible to all everyone<br>&gt;&gt;&gt;&gt; 	private(scope-name, scope-name, …) 	// visible to specified scopes (plus current scope)<br>&gt;&gt;&gt;&gt; 	private							// visible only to current scope<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; scope-name could perhaps be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * A type name (or Self, which would mimic C++-style private, or perhaps even C++-style protected depending on how we treat inheritance)<br>&gt;&gt;&gt;&gt; * A module name (or #module for the current module)<br>&gt;&gt;&gt;&gt; * A file name string (or #file for the current file)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And then the default would simply be `private(#module)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, the parameterized level could be given a different name, like `internal` or `shared`. If that were the case, then `#module` might simply be the default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve actually thought about this before (well, at least at the module level) and ultimately decided it was a bad idea for it to be part of the access control system. Why? Because there&#39;s nothing &quot;private&quot; about sharing with another module, even if it&#39;s just one other module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - You don&#39;t get any secrecy because you have to publish all symbols and metadata as public.<br>&gt;&gt;&gt; - You can&#39;t optimize based on knowledge of how the declaration is used.<br>&gt;&gt;&gt; - Exposing something to another module can be viral, just like making something &#39;public&#39; would be viral: all of a type&#39;s protocol conformances are exposed, a class&#39;s superclass must be exposed, all the types in a function signature have to be exposed (or already public).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All of this means that this behaves more like &quot;public&quot; than like &quot;private&quot;; it&#39;s &quot;public, but not the entire public&quot;. The restriction on use sites is an artificial one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/17337e56/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br></p><p>Actually, I can think of one very interesting boundary that roughly parallels the SPI/API boundary: the boundary between resilience domains. In other words, &quot;public within resilience domain&quot; may be a useful access level.<br></p><p>However, that obviously is not the same as exposing to different modules. I understand why you might not think that&#39;s a good idea.<br></p><p>&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br></p><p>It does offer a solution to the stored property problem (because you can only define stored properties in the type&#39;s main definition, all stored properties must be able to see each others&#39; private state); you could put each extension in a separate file and then expose the relevant stored properties only to the file for the extension that needs it. But I do understand why you might not like that idea; there is a certain smell associated with embedding source file names in your code.<br></p><p>Mostly, it just bothers me that we have these two middle access levels (`moduleprivate` and `fileprivate`) which seem closely related compared to new-`private`, yet are both completely ad-hoc and elude decent naming. Calling them, say, `internal` and having `internal(#file)` be a special case of `internal(file names here)` seems like a nice way to rationalize them.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 15:20, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Now, it is a very useful feature! Apple, of course, does this all the time with its &quot;SPI&quot;. But I think the right form of the feature is to be able to tag a bunch of public declarations as &quot;SPI&quot; or &quot;limited&quot; or &quot;limited to group &#39;X&#39;&quot; or possibly even &quot;limited to module &#39;X&#39;&quot;, and then have a tool to strip them out of the swiftmodule file when you&#39;re ready to ship this module to people. That way you&#39;re enforcing your limitations as much as possible, while still using the same binaries for both internal and external clients. (Remember that the swiftmodule file serves essentially the same purpose as header files in C.)<br>&gt; <br>&gt; Actually, I can think of one very interesting boundary that roughly parallels the SPI/API boundary: the boundary between resilience domains. In other words, &quot;public within resilience domain&quot; may be a useful access level.<br>&gt; <br>&gt; However, that obviously is not the same as exposing to different modules. I understand why you might not think that&#39;s a good idea.<br></p><p>Hm. That may indeed be useful because it allows the compiler to omit resilient information about the declaration. I&#39;m worried that&#39;s just adding more knobs that won&#39;t really be a benefit in practice, though.<br></p><p>(For anyone wondering what this is, it&#39;s part of the very long design document for future &quot;Library Evolution Support in Swift &lt;http://jrose-apple.github.io/swift-library-evolution/&gt;&quot;.)<br></p><p><br>&gt; <br>&gt;&gt; At the file level, there&#39;s nothing inherently wrong with this idea, but I don&#39;t think there&#39;s enough gain to writing file strings directly in source files. Pointing to a future &quot;comprehensive submodules model&quot; would be disingenuous because that&#39;s a huge feature with a lot of subtlety, but I think &quot;just make this accessible to one other file&quot; is additional complexity for not much gain. It&#39;s also subject to slippery-slope: once one file is added, I don&#39;t think anyone would think too hard about adding a second file, and then…<br>&gt; <br>&gt; It does offer a solution to the stored property problem (because you can only define stored properties in the type&#39;s main definition, all stored properties must be able to see each others&#39; private state); you could put each extension in a separate file and then expose the relevant stored properties only to the file for the extension that needs it. But I do understand why you might not like that idea; there is a certain smell associated with embedding source file names in your code.<br>&gt; <br>&gt; Mostly, it just bothers me that we have these two middle access levels (`moduleprivate` and `fileprivate`) which seem closely related compared to new-`private`, yet are both completely ad-hoc and elude decent naming. Calling them, say, `internal` and having `internal(#file)` be a special case of `internal(file names here)` seems like a nice way to rationalize them.<br></p><p>Can you elaborate on why &quot;moduleprivate&quot; and &quot;fileprivate&quot; are closely related for you? To me all three of the proposed non-public levels are &quot;concentric circles&quot;; one of them is bounded by braces, one by the filesystem, and one by the files in your target (as described by Xcode or the package manager or an ad hoc build).<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/e8900c51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; Actually, I can think of one very interesting boundary that roughly parallels the SPI/API boundary: the boundary between resilience domains. In other words, &quot;public within resilience domain&quot; may be a useful access level.<br>&gt; <br>&gt; Hm. That may indeed be useful because it allows the compiler to omit resilient information about the declaration. I&#39;m worried that&#39;s just adding more knobs that won&#39;t really be a benefit in practice, though.<br></p><p>I think it would be a benefit because it could be used to model the distinction between SPI and API and to omit SPIs entirely from the released swiftmodule, as you suggested Apple (and perhaps others) would need. It&#39;d be nice to have that as a formal part of the language, natively supported by all the tools.<br></p><p>&gt;&gt; Mostly, it just bothers me that we have these two middle access levels (`moduleprivate` and `fileprivate`) which seem closely related compared to new-`private`, yet are both completely ad-hoc and elude decent naming. Calling them, say, `internal` and having `internal(#file)` be a special case of `internal(file names here)` seems like a nice way to rationalize them.<br>&gt; <br>&gt; Can you elaborate on why &quot;moduleprivate&quot; and &quot;fileprivate&quot; are closely related for you? To me all three of the proposed non-public levels are &quot;concentric circles&quot;; one of them is bounded by braces, one by the filesystem, and one by the files in your target (as described by Xcode or the package manager or an ad hoc build).<br></p><p>I guess the way I see it is this:<br></p><p>Consider the inside of a function body. The things in it are lexically scoped: they are visible within the scope, including in nested scopes, but not outside it. Inner blocks can access the variables of outer blocks, but not vice versa. Because a function body is built from anonymous stack frames, it cannot really be made more globally visible, so we don&#39;t need to explicitly ask for this behavior.<br></p><p>Named module-wide entities, on the other hand, *are* nailed down to a stable location, so they *can* be made more globally visible. Thus, we do need access control keywords.<br></p><p>In my view, `private` is basically asking for the same behavior seen elsewhere in the language: lexically scoped access. The others—`fileprivate`, `moduleprivate`, and `public`—are asking for that behavior to be varied by exposing the symbol they&#39;re decorating more widely than normal.<br></p><p>Now, there is a very important distinction between `public` and the others. A public symbol is exposed to the world; at compile time, it is impossible to know what will use it. `public` represents a veil of ignorance for the optimizer.<br></p><p>But between these two natural boundaries—the complete visibility and ignorance of `public` and the strict, natural lexical scope of `private`—any access levels we introduce are artificial. Especially now that we have WMO, `fileprivate` is just `moduleprivate` with an artificial visibility limit. That limit could just as easily be to an enumerated list of files, to direct ancestor scopes (and their non-type child scopes), to extensions, to subclasses, to particular symbols, or to odd-numbered lines. We choose &quot;the current file&quot; because that happens to frequently be useful, but there&#39;s nothing magical about the current file that makes it especially appropriate.<br></p><p>I guess that&#39;s why I keep wanting to unify `fileprivate` and `moduleprivate` somehow: because I see `fileprivate` as an artificial limitation of `moduleprivate`, and it seems to me that other such limitations would be equally valid.<br></p><p>* * *<br></p><p>While working that out, I also came up with a new suggestion for keywording if we keep just these four levels and don&#39;t generalize `fileprivate` into an &quot;internal, with limitations&quot; mechanism:<br></p><p>* public<br>* moduleinternal<br>* internal<br>* private<br></p><p>This version saddles only the module access level, which rarely needs to be typed explicitly, with an awkward compound keyword. The file access level (which I suspect is more often necessary than many in this thread believe) gets a single, simple keyword. Additionally, by having only one gobbledygook access level, when you *do* see the gobbledygook keyword you don&#39;t have to try to parse it.<br></p><p>This does have the disadvantage of not matching C#&#39;s meaning of `internal`; we could do something else, like `shared`/`moduleshared`, instead. But I&#39;m not sure how valuable that correspondence is.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 16:30, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; While working that out, I also came up with a new suggestion for keywording if we keep just these four levels and don&#39;t generalize `fileprivate` into an &quot;internal, with limitations&quot; mechanism:<br>&gt; <br>&gt; * public<br>&gt; * moduleinternal<br>&gt; * internal<br>&gt; * private<br>&gt; <br>&gt; This version saddles only the module access level, which rarely needs to be typed explicitly, with an awkward compound keyword. The file access level (which I suspect is more often necessary than many in this thread believe) gets a single, simple keyword. Additionally, by having only one gobbledygook access level, when you *do* see the gobbledygook keyword you don&#39;t have to try to parse it.<br>&gt; <br>&gt; This does have the disadvantage of not matching C#&#39;s meaning of `internal`; we could do something else, like `shared`/`moduleshared`, instead. But I&#39;m not sure how valuable that correspondence is.<br></p><p>I maintain that anyone with a coding convention of &quot;always write an access modifier&quot; will be very upset with this.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I maintain that anyone with a coding convention of &quot;always write an access modifier&quot; will be very upset with this.<br></p><p>I doubt they&#39;ll be too pleased with `moduleprivate`, either.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0acf75deb034e62d9e8c18c2d3680b54?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Michael Wells</string> &lt;michael at michaelwells.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>I know that it’s been suggested a while back, but what is/was the reasoning for rejecting:<br></p><p>public<br>module (same as internal in Swift 2.2)<br>file (same as private in Swift 2.2)<br>private<br></p><p>It seems pretty simple, clear, and understandable. It doesn’t make itself very useful as search terms (module or file are pretty generic), but I would assume that would be a learn-once-and-your-done thing.<br>—<br>Michael Wells<br></p><p><br>&gt; On Mar 30, 2016, at 5:24 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I maintain that anyone with a coding convention of &quot;always write an access modifier&quot; will be very upset with this.<br>&gt; <br>&gt; I doubt they&#39;ll be too pleased with `moduleprivate`, either.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/9dc021a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I know that it’s been suggested a while back, but what is/was the reasoning for rejecting:<br>&gt; <br>&gt; 	• public<br>&gt; 	• module (same as internal in Swift 2.2)<br>&gt; 	• file (same as private in Swift 2.2)<br>&gt; 	• private<br></p><p>I know; I was one of the people who suggested it. I believe I saw two reasons for rejecting it:<br></p><p>1. This might be read as declaring a module/file, or attaching it to a module/file (a la `class func`), rather than scoping it.<br>2. `private` and `public` are adjectives; `module` and `file` are nouns.<br></p><p>I&#39;m not entirely convinced by #1; #2 could be addressed by using, for instance, `modulewide` and `filewide`. In any case, though, the discussion seems to have moved elsewhere.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 08:00:00pm</p></header><div class="content"><p>public<br>filewide <br>modulewide <br>private<br></p><p>Don’t bother me because they seem to be part of the word. The way “nationwide” does, they are made up words but intent is clear.<br></p><p>OK violating my own statement of only having single words, but very short words. How about?<br></p><p>public <br>inmodule<br>infile<br>private<br> <br>I think this is good too.<br></p><p>&gt; * public<br>&gt; * moduleinternal<br>&gt; * internal<br>&gt; * private<br></p><p>people who insist on always specifying access will either live with it or make one exception. <br></p><p>&gt; On Mar 30, 2016, at 6:47 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I know that it’s been suggested a while back, but what is/was the reasoning for rejecting:<br>&gt;&gt; <br>&gt;&gt; 	• public<br>&gt;&gt; 	• module (same as internal in Swift 2.2)<br>&gt;&gt; 	• file (same as private in Swift 2.2)<br>&gt;&gt; 	• private<br>&gt; <br>&gt; I know; I was one of the people who suggested it. I believe I saw two reasons for rejecting it:<br>&gt; <br>&gt; 1. This might be read as declaring a module/file, or attaching it to a module/file (a la `class func`), rather than scoping it.<br>&gt; 2. `private` and `public` are adjectives; `module` and `file` are nouns.<br>&gt; <br>&gt; I&#39;m not entirely convinced by #1; #2 could be addressed by using, for instance, `modulewide` and `filewide`. In any case, though, the discussion seems to have moved elsewhere.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 31, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; public<br>&gt; filewide <br>&gt; modulewide <br>&gt; private<br>&gt; <br>&gt; Don’t bother me because they seem to be part of the word. The way “nationwide” does, they are made up words but intent is clear.<br></p><p>I could live with filewide and modulewide instead of fileprivate and moduleprivate.<br></p><p>I still prefer the latter ones, but I wonder if -wide ones will be a happier compromise? Those unhappy with xxxprivate, please speak up!<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 09:00:00pm</p></header><div class="content"><p>Ok speaking up, not a fan of fileprivate and moduleprivate because <br></p><p>1) very long<br>2) doesn’t flow. <br>3) not really private. <br></p><p>I would be fine with filewide and modulewide and infile and inmodule with a slight preference for the infile and inmodule because it is shorter and conveys the same meaning and flows about the same. <br></p><p>&gt; I still prefer the latter ones, but I wonder if -wide ones will be a happier compromise? Those unhappy with xxxprivate, please speak up!<br>&gt; <br>&gt; A.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 09:00:00pm</p></header><div class="content"><p>One more possibility:<br></p><p>public<br>intermodule<br>interfile <br>private<br></p><p>slightly longer but reads well.<br></p><p>&gt; On Mar 30, 2016, at 9:11 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ok speaking up, not a fan of fileprivate and moduleprivate because <br>&gt; <br>&gt; 1) very long<br>&gt; 2) doesn’t flow. <br>&gt; 3) not really private. <br>&gt; <br>&gt; I would be fine with filewide and modulewide and infile and inmodule with a slight preference for the infile and inmodule because it is shorter and conveys the same meaning and flows about the same. <br>&gt; <br>&gt;&gt; I still prefer the latter ones, but I wonder if -wide ones will be a happier compromise? Those unhappy with xxxprivate, please speak up!<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Ilya said:<br>&gt; &quot;public&quot;, &quot;protected&quot;, and &quot;private&quot; have a very well defined meaning in<br>OOP. We shouldn&#39;t redefine them without a good reason.<br></p><p>I agree. Swift has a scope-based visibility system, not a type-based<br>visibility system, but because Swift redefines the terms &#39;public&#39; and<br>&#39;private&#39;, programmers keep getting confused about how they&#39;re used in<br>Swift.<br></p><p>Over the last few posts, since Chris Lattner proposed switching to:<br>&#39;public, internal, X, private&#39;, we&#39;ve had several new scales proposed. (In<br>every scale in this post, there are four terms in order of decreasing<br>visibility, with the second term being the default.)<br></p><p>public, external, internal, private.<br>public, internal, private, secret.<br>external, internal, public, private.<br>public, internal, private, secret.<br>public, internal, private, local.<br></p><p>At this point, respectfully, I think we can dismiss the idea that labelling<br>any given level as &#39;public&#39; or &#39;private&#39; is right or obvious. Swift is<br>built around clarity at the point of use. &#39;private&#39; is not as clear as you<br>maintain it is.<br></p><p>&gt; Swift allows extensions, so &quot;private&quot; in its standard form doesn&#39;t work<br>well -- you could just define an extension and get access to anything. The<br>scope based private seems to be the most natural extension (pun intended<br>:–)).<br></p><p>We&#39;re redefining terms from a type-based visibility scale to a scope-based<br>visibility scale. I&#39;m not disagreeing that an extension would allow access<br>to type-visible symbols and that this might not be the programmer&#39;s<br>intention, but that &#39;private&#39; has a clear meaning in OOP and repurposing<br>&#39;private&#39; is not resolving any confusion.<br></p><p>&gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class<br>injection to gain access, but this is an edge case that could be argued<br>either way. I can definitely live with a pure scoped access  for<br>consistency and don&#39;t want to argue the edge case in a never ending<br>discussion.<br></p><p>As far as I know, it&#39;s not an edge case in Swift, it&#39;s a non-case. Swift<br>doesn&#39;t have type-based visibility. Using Swift&#39;s system, I do understand<br>that you want &#39;private&#39; to refer to the least-visible level in the<br>hierarchy.<br></p><p>However, as has already been pointed out, the scope-visible level is not<br>the least-visible conceivable. There&#39;s already discussion over whether the<br>properties of inner types should be visible to their outer types. If that<br>ever made its way to a proposal, would that level become &#39;private&#39;? I think<br>we can agree that another bikeshedding conversation like this would rather<br>be avoided.<br></p><p>There&#39;s also the possibility of a &#39;submodule&#39; level. Chris Lattner<br>suggested that the &#39;private(foo.bar)&#39; syntax might be best for this, but I<br>don&#39;t know what that means - whether &#39;submodule&#39; would be within the Swift<br>hierarchy or not - but it&#39;s a possibility for the future.<br></p><p>I&#39;m repeating myself, but: inclusion of the terms &#39;module&#39;, &#39;file&#39;, and<br>&#39;scope&#39; in our symbols is winning out in clarity. None of those terms has<br>changed meaning in the entire discussion. The only question is exactly how<br>they should be welded to the term &#39;private&#39;. There&#39;ve been three<br>suggestions for doing this so far and they&#39;re all awkward, either because<br>they have parentheses or they&#39;re conjoined, but they&#39;re unambiguous in<br>meaning and no-one&#39;s suggested any single-word ideas with the same clarity.<br></p><p>public, private(module), private(file) and private(scope).<br>public, moduleprivate, fileprivate, scopeprivate.<br>public, privatetomodule, privatetofile, privatetoscope.<br></p><p>I&#39;m tempted to go one further, but if you want to ignore that one further,<br>skip the next two paragraphs:<br></p><p>Abandon the words &#39;public&#39; and &#39;private&#39;. Let&#39;s just accept that, together<br>with &#39;protected&#39;, these are well-defined terms of type-based visibility in<br>OOP which are orthogonal to Swift&#39;s hierarchy, and that redefining them<br>leads to confusion. Embrace &#39;external&#39; and &#39;internal&#39; in their places:<br></p><p>external, internal(module), internal(file), internal(scope).<br>external, moduleinternal, fileinternal, scopeinternal.<br>external, internaltomodule, internaltofile, internaltoscope.<br></p><p>If you ignored that, welcome back.<br></p><p>I hope I&#39;ve not been too antagonistic about this. I really want Swift to<br>use terms with clear meaning, and if that breaks code, I want a clean break<br>that can be easily healed / migrated.<br></p><p>Every suggestion for relabelling this hierarchy, bar &#39;public, internal,<br>private, local/scope&#39;, breaks code.<br></p><p>Adding the scope-visible level allows for greater control, but I don&#39;t<br>believe module-visible and file-visible levels would be uncommon with its<br>inclusion, so the terms for all three - all four, really - should be<br>balanced in their &#39;ugliness&#39;.<br></p><p>What the proposal as it stands does need to make clear is what would change<br>and what would be left behind.<br></p><p>If &#39;internal&#39; is renamed to &#39;moduleprivate&#39;, explicit uses of &#39;internal&#39;<br>need to be replaced.<br></p><p>If there are constants, &#39;global&#39; functions, operators, or anything that can<br>be defined outside of a scope, their least visible level is fileprivate.<br>They can never be &#39;scope-private&#39;.<br></p><p>If &#39;private&#39; is redefined, it is no nearer to its meaning in other<br>languages than it is now.<br></p><p><br>On Mon, Mar 28, 2016 at 12:30 PM, Matthew Judge via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; func f() {<br>&gt;&gt;   let outer = 0<br>&gt;&gt;  // f cannot use inner<br>&gt;&gt;    func g() {<br>&gt;&gt;        let inner = 1<br>&gt;&gt;        // g can use outer<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what<br>&gt; you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;<br>&gt;<br>&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt; not include this in the proposal.<br>&gt;&gt;<br>&gt;<br>&gt; So as the proposal stands now, what is the scope that innerVar is visible<br>&gt; to in the following code: Inner or Outer?<br>&gt;<br>&gt; class Outer {<br>&gt;     class Inner {<br>&gt;         private var innerVar: Int<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;<br>&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be<br>&gt;&gt;&gt; the same as private (private to the enclosing scope... which happens to be<br>&gt;&gt;&gt; the file).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt;&gt;&gt; There would still need to be a way to reference scopes other than the<br>&gt;&gt;&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt;&gt;&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt;&gt;&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt;&gt;&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Public<br>&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt; Internal<br>&gt;&gt;&gt; Private<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use<br>&gt;&gt;&gt; of external, as public to me is external since it exports outside of the<br>&gt;&gt;&gt; module, whereas what you’re proposing is in fact just limited to the module<br>&gt;&gt;&gt; itself. I dislike the current internal keyword too, but at least it reads<br>&gt;&gt;&gt; as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt; private(scope) new visibility type, item is private to the current scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/8dd830f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>Let&#39;s say that we go with <br>public, moduleprivate, fileprivate, scopeprivate<br></p><p>Would it really make sense to allow extensions in other files to access fileprivate members/funcs?  The inclusion of the word &#39;file&#39; in the name would make it confusing that extensions have the special power to reach into a fileprivate from another file. This almost begs for another access like typeprivate (I am not proposing this).<br></p><p>My understating is that scopeprivate came about as a way to deal with extensions, perhaps the author needs to look into a way to tag methods/members as not extendable or hidden from extensions only. The solution would probably be swift specific and it should probably brake out from the norm of other languages. <br></p><p><br></p><p><br></p><p><br></p><p>&gt; On Mar 28, 2016, at 5:46 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ilya said:<br>&gt; &gt; &quot;public&quot;, &quot;protected&quot;, and &quot;private&quot; have a very well defined meaning in OOP. We shouldn&#39;t redefine them without a good reason.<br>&gt; <br>&gt; I agree. Swift has a scope-based visibility system, not a type-based visibility system, but because Swift redefines the terms &#39;public&#39; and &#39;private&#39;, programmers keep getting confused about how they&#39;re used in Swift.<br>&gt; <br>&gt; Over the last few posts, since Chris Lattner proposed switching to: &#39;public, internal, X, private&#39;, we&#39;ve had several new scales proposed. (In every scale in this post, there are four terms in order of decreasing visibility, with the second term being the default.)<br>&gt; <br>&gt; public, external, internal, private.<br>&gt; public, internal, private, secret.<br>&gt; external, internal, public, private.<br>&gt; public, internal, private, secret.<br>&gt; public, internal, private, local.<br>&gt; <br>&gt; At this point, respectfully, I think we can dismiss the idea that labelling any given level as &#39;public&#39; or &#39;private&#39; is right or obvious. Swift is built around clarity at the point of use. &#39;private&#39; is not as clear as you maintain it is.<br>&gt; <br>&gt; &gt; Swift allows extensions, so &quot;private&quot; in its standard form doesn&#39;t work well -- you could just define an extension and get access to anything. The scope based private seems to be the most natural extension (pun intended :–)).<br>&gt; <br>&gt; We&#39;re redefining terms from a type-based visibility scale to a scope-based visibility scale. I&#39;m not disagreeing that an extension would allow access to type-visible symbols and that this might not be the programmer&#39;s intention, but that &#39;private&#39; has a clear meaning in OOP and repurposing &#39;private&#39; is not resolving any confusion.<br>&gt; <br>&gt; &gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class injection to gain access, but this is an edge case that could be argued either way. I can definitely live with a pure scoped access  for consistency and don&#39;t want to argue the edge case in a never ending discussion.<br>&gt; <br>&gt; As far as I know, it&#39;s not an edge case in Swift, it&#39;s a non-case. Swift doesn&#39;t have type-based visibility. Using Swift&#39;s system, I do understand that you want &#39;private&#39; to refer to the least-visible level in the hierarchy.<br>&gt; <br>&gt; However, as has already been pointed out, the scope-visible level is not the least-visible conceivable. There&#39;s already discussion over whether the properties of inner types should be visible to their outer types. If that ever made its way to a proposal, would that level become &#39;private&#39;? I think we can agree that another bikeshedding conversation like this would rather be avoided.<br>&gt; <br>&gt; There&#39;s also the possibility of a &#39;submodule&#39; level. Chris Lattner suggested that the &#39;private(foo.bar)&#39; syntax might be best for this, but I don&#39;t know what that means - whether &#39;submodule&#39; would be within the Swift hierarchy or not - but it&#39;s a possibility for the future.<br>&gt; <br>&gt; I&#39;m repeating myself, but: inclusion of the terms &#39;module&#39;, &#39;file&#39;, and &#39;scope&#39; in our symbols is winning out in clarity. None of those terms has changed meaning in the entire discussion. The only question is exactly how they should be welded to the term &#39;private&#39;. There&#39;ve been three suggestions for doing this so far and they&#39;re all awkward, either because they have parentheses or they&#39;re conjoined, but they&#39;re unambiguous in meaning and no-one&#39;s suggested any single-word ideas with the same clarity.<br>&gt; <br>&gt; public, private(module), private(file) and private(scope).<br>&gt; public, moduleprivate, fileprivate, scopeprivate.<br>&gt; public, privatetomodule, privatetofile, privatetoscope.<br>&gt; <br>&gt; I&#39;m tempted to go one further, but if you want to ignore that one further, skip the next two paragraphs:<br>&gt; <br>&gt; Abandon the words &#39;public&#39; and &#39;private&#39;. Let&#39;s just accept that, together with &#39;protected&#39;, these are well-defined terms of type-based visibility in OOP which are orthogonal to Swift&#39;s hierarchy, and that redefining them leads to confusion. Embrace &#39;external&#39; and &#39;internal&#39; in their places:<br>&gt; <br>&gt; external, internal(module), internal(file), internal(scope).<br>&gt; external, moduleinternal, fileinternal, scopeinternal.<br>&gt; external, internaltomodule, internaltofile, internaltoscope.<br>&gt; <br>&gt; If you ignored that, welcome back.<br>&gt; <br>&gt; I hope I&#39;ve not been too antagonistic about this. I really want Swift to use terms with clear meaning, and if that breaks code, I want a clean break that can be easily healed / migrated.<br>&gt; <br>&gt; Every suggestion for relabelling this hierarchy, bar &#39;public, internal, private, local/scope&#39;, breaks code.<br>&gt; <br>&gt; Adding the scope-visible level allows for greater control, but I don&#39;t believe module-visible and file-visible levels would be uncommon with its inclusion, so the terms for all three - all four, really - should be balanced in their &#39;ugliness&#39;.<br>&gt; <br>&gt; What the proposal as it stands does need to make clear is what would change and what would be left behind.<br>&gt; <br>&gt; If &#39;internal&#39; is renamed to &#39;moduleprivate&#39;, explicit uses of &#39;internal&#39; need to be replaced.<br>&gt; <br>&gt; If there are constants, &#39;global&#39; functions, operators, or anything that can be defined outside of a scope, their least visible level is fileprivate. They can never be &#39;scope-private&#39;.<br>&gt; <br>&gt; If &#39;private&#39; is redefined, it is no nearer to its meaning in other languages than it is now.<br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 12:30 PM, Matthew Judge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;  <br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather not include this in the proposal.<br>&gt;&gt; <br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible to in the following code: Inner or Outer?<br>&gt;&gt; <br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I personally would prefer a completely private version where you cannot inject a class into a scope to get access to the scope internals, but it&#39;s an edge case that could be argued either way, and I don&#39;t want to start another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My understanding is that the new private would be: <br>&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt; - not visible to an extension <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Public <br>&gt;&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt;&gt;&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt;&gt;&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/74f97342/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Would it really make sense to allow extensions in other files to access<br>fileprivate members/funcs?<br></p><p>no, fileprivate is limited to the specific file in which it is used.<br></p><p>On Mon, Mar 28, 2016 at 1:13 PM Cheyo Ximenez &lt;cheyo at masters3d.com&gt; wrote:<br></p><p>&gt; Let&#39;s say that we go with<br>&gt; public, moduleprivate, fileprivate, scopeprivate<br>&gt;<br>&gt; Would it really make sense to allow extensions in other files to access<br>&gt; fileprivate members/funcs?  The inclusion of the word &#39;file&#39; in the name<br>&gt; would make it confusing that extensions have the special power to reach<br>&gt; into a fileprivate from another file. This almost begs for another access<br>&gt; like typeprivate (I am not proposing this).<br>&gt;<br>&gt; My understating is that scopeprivate came about as a way to deal with<br>&gt; extensions, perhaps the author needs to look into a way to tag<br>&gt; methods/members as not extendable or hidden from extensions only. The<br>&gt; solution would probably be swift specific and it should probably brake out<br>&gt; from the norm of other languages.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mar 28, 2016, at 5:46 AM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Ilya said:<br>&gt; &gt; &quot;public&quot;, &quot;protected&quot;, and &quot;private&quot; have a very well defined meaning<br>&gt; in OOP. We shouldn&#39;t redefine them without a good reason.<br>&gt;<br>&gt; I agree. Swift has a scope-based visibility system, not a type-based<br>&gt; visibility system, but because Swift redefines the terms &#39;public&#39; and<br>&gt; &#39;private&#39;, programmers keep getting confused about how they&#39;re used in<br>&gt; Swift.<br>&gt;<br>&gt; Over the last few posts, since Chris Lattner proposed switching to:<br>&gt; &#39;public, internal, X, private&#39;, we&#39;ve had several new scales proposed. (In<br>&gt; every scale in this post, there are four terms in order of decreasing<br>&gt; visibility, with the second term being the default.)<br>&gt;<br>&gt; public, external, internal, private.<br>&gt; public, internal, private, secret.<br>&gt; external, internal, public, private.<br>&gt; public, internal, private, secret.<br>&gt; public, internal, private, local.<br>&gt;<br>&gt; At this point, respectfully, I think we can dismiss the idea that<br>&gt; labelling any given level as &#39;public&#39; or &#39;private&#39; is right or obvious.<br>&gt; Swift is built around clarity at the point of use. &#39;private&#39; is not as<br>&gt; clear as you maintain it is.<br>&gt;<br>&gt; &gt; Swift allows extensions, so &quot;private&quot; in its standard form doesn&#39;t work<br>&gt; well -- you could just define an extension and get access to anything. The<br>&gt; scope based private seems to be the most natural extension (pun intended<br>&gt; :–)).<br>&gt;<br>&gt; We&#39;re redefining terms from a type-based visibility scale to a scope-based<br>&gt; visibility scale. I&#39;m not disagreeing that an extension would allow access<br>&gt; to type-visible symbols and that this might not be the programmer&#39;s<br>&gt; intention, but that &#39;private&#39; has a clear meaning in OOP and repurposing<br>&gt; &#39;private&#39; is not resolving any confusion.<br>&gt;<br>&gt; &gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class<br>&gt; injection to gain access, but this is an edge case that could be argued<br>&gt; either way. I can definitely live with a pure scoped access  for<br>&gt; consistency and don&#39;t want to argue the edge case in a never ending<br>&gt; discussion.<br>&gt;<br>&gt; As far as I know, it&#39;s not an edge case in Swift, it&#39;s a non-case. Swift<br>&gt; doesn&#39;t have type-based visibility. Using Swift&#39;s system, I do understand<br>&gt; that you want &#39;private&#39; to refer to the least-visible level in the<br>&gt; hierarchy.<br>&gt;<br>&gt; However, as has already been pointed out, the scope-visible level is not<br>&gt; the least-visible conceivable. There&#39;s already discussion over whether the<br>&gt; properties of inner types should be visible to their outer types. If that<br>&gt; ever made its way to a proposal, would that level become &#39;private&#39;? I think<br>&gt; we can agree that another bikeshedding conversation like this would rather<br>&gt; be avoided.<br>&gt;<br>&gt; There&#39;s also the possibility of a &#39;submodule&#39; level. Chris Lattner<br>&gt; suggested that the &#39;private(foo.bar)&#39; syntax might be best for this, but I<br>&gt; don&#39;t know what that means - whether &#39;submodule&#39; would be within the Swift<br>&gt; hierarchy or not - but it&#39;s a possibility for the future.<br>&gt;<br>&gt; I&#39;m repeating myself, but: inclusion of the terms &#39;module&#39;, &#39;file&#39;, and<br>&gt; &#39;scope&#39; in our symbols is winning out in clarity. None of those terms has<br>&gt; changed meaning in the entire discussion. The only question is exactly how<br>&gt; they should be welded to the term &#39;private&#39;. There&#39;ve been three<br>&gt; suggestions for doing this so far and they&#39;re all awkward, either because<br>&gt; they have parentheses or they&#39;re conjoined, but they&#39;re unambiguous in<br>&gt; meaning and no-one&#39;s suggested any single-word ideas with the same clarity.<br>&gt;<br>&gt; public, private(module), private(file) and private(scope).<br>&gt; public, moduleprivate, fileprivate, scopeprivate.<br>&gt; public, privatetomodule, privatetofile, privatetoscope.<br>&gt;<br>&gt; I&#39;m tempted to go one further, but if you want to ignore that one further,<br>&gt; skip the next two paragraphs:<br>&gt;<br>&gt; Abandon the words &#39;public&#39; and &#39;private&#39;. Let&#39;s just accept that, together<br>&gt; with &#39;protected&#39;, these are well-defined terms of type-based visibility in<br>&gt; OOP which are orthogonal to Swift&#39;s hierarchy, and that redefining them<br>&gt; leads to confusion. Embrace &#39;external&#39; and &#39;internal&#39; in their places:<br>&gt;<br>&gt; external, internal(module), internal(file), internal(scope).<br>&gt; external, moduleinternal, fileinternal, scopeinternal.<br>&gt; external, internaltomodule, internaltofile, internaltoscope.<br>&gt;<br>&gt; If you ignored that, welcome back.<br>&gt;<br>&gt; I hope I&#39;ve not been too antagonistic about this. I really want Swift to<br>&gt; use terms with clear meaning, and if that breaks code, I want a clean break<br>&gt; that can be easily healed / migrated.<br>&gt;<br>&gt; Every suggestion for relabelling this hierarchy, bar &#39;public, internal,<br>&gt; private, local/scope&#39;, breaks code.<br>&gt;<br>&gt; Adding the scope-visible level allows for greater control, but I don&#39;t<br>&gt; believe module-visible and file-visible levels would be uncommon with its<br>&gt; inclusion, so the terms for all three - all four, really - should be<br>&gt; balanced in their &#39;ugliness&#39;.<br>&gt;<br>&gt; What the proposal as it stands does need to make clear is what would<br>&gt; change and what would be left behind.<br>&gt;<br>&gt; If &#39;internal&#39; is renamed to &#39;moduleprivate&#39;, explicit uses of &#39;internal&#39;<br>&gt; need to be replaced.<br>&gt;<br>&gt; If there are constants, &#39;global&#39; functions, operators, or anything that<br>&gt; can be defined outside of a scope, their least visible level is<br>&gt; fileprivate. They can never be &#39;scope-private&#39;.<br>&gt;<br>&gt; If &#39;private&#39; is redefined, it is no nearer to its meaning in other<br>&gt; languages than it is now.<br>&gt;<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 12:30 PM, Matthew Judge via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For<br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what<br>&gt;&gt; you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather<br>&gt;&gt;&gt; not include this in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible<br>&gt;&gt; to in the following code: Inner or Outer?<br>&gt;&gt;<br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I<br>&gt;&gt;&gt; personally would prefer a completely private version where you cannot<br>&gt;&gt;&gt; inject a class into a scope to get access to the scope internals, but it&#39;s<br>&gt;&gt;&gt; an edge case that could be argued either way, and I don&#39;t want to start<br>&gt;&gt;&gt; another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread,<br>&gt;&gt;&gt;&gt; but it might be good to clarify how the new private is going to work (or at<br>&gt;&gt;&gt;&gt; least what is currently envisioned).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My understanding is that the new private would be:<br>&gt;&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt;&gt; - not visible to an extension<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ----------<br>&gt;&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to<br>&gt;&gt;&gt;&gt; be the same as private (private to the enclosing scope... which happens to<br>&gt;&gt;&gt;&gt; be the file).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate.<br>&gt;&gt;&gt;&gt; There would still need to be a way to reference scopes other than the<br>&gt;&gt;&gt;&gt; immediate one (especially since there is no way to say &quot;private&quot; and mean<br>&gt;&gt;&gt;&gt; moduleprivate), though I think it would strengthen the argument for<br>&gt;&gt;&gt;&gt; something along the lines of &quot;private(file)&quot;, since it would even further<br>&gt;&gt;&gt;&gt; reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Public<br>&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the<br>&gt;&gt;&gt;&gt; use of external, as public to me is external since it exports outside of<br>&gt;&gt;&gt;&gt; the module, whereas what you’re proposing is in fact just limited to the<br>&gt;&gt;&gt;&gt; module itself. I dislike the current internal keyword too, but at least it<br>&gt;&gt;&gt;&gt; reads as “internal to this module&quot;, this is why the more specific terms are<br>&gt;&gt;&gt;&gt; better like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt; private(module) or private current internal, item is private to this<br>&gt;&gt;&gt;&gt; module, would be the default<br>&gt;&gt;&gt;&gt; private(file) current private, item is private to this file<br>&gt;&gt;&gt;&gt; private(scope) new visibility type, item is private to the current<br>&gt;&gt;&gt;&gt; scope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for<br>&gt;&gt;&gt;&gt; sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/a0e4aab9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 28, 2016 at 11:00:00am</p></header><div class="content"><p>That is a deal breaker for me and it is a departure of of the current swift model of localprivate aka private.<br></p><p>I don’t like it. The introduction of a first class scopeprivate is not worth it if that is one of the tradeoffs. <br></p><p>There are other ways to hide implementation now using nested functions. <br></p><p>func outside() -&gt; Int{<br>    func insidelocalfunc() -&gt; Int {return 2}<br>    return insidelocalfunc()<br>}<br></p><p><br></p><p>&gt; On Mar 28, 2016, at 11:16 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; Would it really make sense to allow extensions in other files to access fileprivate members/funcs? <br>&gt; <br>&gt; no, fileprivate is limited to the specific file in which it is used.<br>&gt; <br>&gt; On Mon, Mar 28, 2016 at 1:13 PM Cheyo Ximenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt; Let&#39;s say that we go with <br>&gt; public, moduleprivate, fileprivate, scopeprivate<br>&gt; <br>&gt; Would it really make sense to allow extensions in other files to access fileprivate members/funcs?  The inclusion of the word &#39;file&#39; in the name would make it confusing that extensions have the special power to reach into a fileprivate from another file. This almost begs for another access like typeprivate (I am not proposing this).<br>&gt; <br>&gt; My understating is that scopeprivate came about as a way to deal with extensions, perhaps the author needs to look into a way to tag methods/members as not extendable or hidden from extensions only. The solution would probably be swift specific and it should probably brake out from the norm of other languages. <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mar 28, 2016, at 5:46 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Ilya said:<br>&gt;&gt; &gt; &quot;public&quot;, &quot;protected&quot;, and &quot;private&quot; have a very well defined meaning in OOP. We shouldn&#39;t redefine them without a good reason.<br>&gt;&gt; <br>&gt;&gt; I agree. Swift has a scope-based visibility system, not a type-based visibility system, but because Swift redefines the terms &#39;public&#39; and &#39;private&#39;, programmers keep getting confused about how they&#39;re used in Swift.<br>&gt;&gt; <br>&gt;&gt; Over the last few posts, since Chris Lattner proposed switching to: &#39;public, internal, X, private&#39;, we&#39;ve had several new scales proposed. (In every scale in this post, there are four terms in order of decreasing visibility, with the second term being the default.)<br>&gt;&gt; <br>&gt;&gt; public, external, internal, private.<br>&gt;&gt; public, internal, private, secret.<br>&gt;&gt; external, internal, public, private.<br>&gt;&gt; public, internal, private, secret.<br>&gt;&gt; public, internal, private, local.<br>&gt;&gt; <br>&gt;&gt; At this point, respectfully, I think we can dismiss the idea that labelling any given level as &#39;public&#39; or &#39;private&#39; is right or obvious. Swift is built around clarity at the point of use. &#39;private&#39; is not as clear as you maintain it is.<br>&gt;&gt; <br>&gt;&gt; &gt; Swift allows extensions, so &quot;private&quot; in its standard form doesn&#39;t work well -- you could just define an extension and get access to anything. The scope based private seems to be the most natural extension (pun intended :–)).<br>&gt;&gt; <br>&gt;&gt; We&#39;re redefining terms from a type-based visibility scale to a scope-based visibility scale. I&#39;m not disagreeing that an extension would allow access to type-visible symbols and that this might not be the programmer&#39;s intention, but that &#39;private&#39; has a clear meaning in OOP and repurposing &#39;private&#39; is not resolving any confusion.<br>&gt;&gt; <br>&gt;&gt; &gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class injection to gain access, but this is an edge case that could be argued either way. I can definitely live with a pure scoped access  for consistency and don&#39;t want to argue the edge case in a never ending discussion.<br>&gt;&gt; <br>&gt;&gt; As far as I know, it&#39;s not an edge case in Swift, it&#39;s a non-case. Swift doesn&#39;t have type-based visibility. Using Swift&#39;s system, I do understand that you want &#39;private&#39; to refer to the least-visible level in the hierarchy.<br>&gt;&gt; <br>&gt;&gt; However, as has already been pointed out, the scope-visible level is not the least-visible conceivable. There&#39;s already discussion over whether the properties of inner types should be visible to their outer types. If that ever made its way to a proposal, would that level become &#39;private&#39;? I think we can agree that another bikeshedding conversation like this would rather be avoided.<br>&gt;&gt; <br>&gt;&gt; There&#39;s also the possibility of a &#39;submodule&#39; level. Chris Lattner suggested that the &#39;private(foo.bar)&#39; syntax might be best for this, but I don&#39;t know what that means - whether &#39;submodule&#39; would be within the Swift hierarchy or not - but it&#39;s a possibility for the future.<br>&gt;&gt; <br>&gt;&gt; I&#39;m repeating myself, but: inclusion of the terms &#39;module&#39;, &#39;file&#39;, and &#39;scope&#39; in our symbols is winning out in clarity. None of those terms has changed meaning in the entire discussion. The only question is exactly how they should be welded to the term &#39;private&#39;. There&#39;ve been three suggestions for doing this so far and they&#39;re all awkward, either because they have parentheses or they&#39;re conjoined, but they&#39;re unambiguous in meaning and no-one&#39;s suggested any single-word ideas with the same clarity.<br>&gt;&gt; <br>&gt;&gt; public, private(module), private(file) and private(scope).<br>&gt;&gt; public, moduleprivate, fileprivate, scopeprivate.<br>&gt;&gt; public, privatetomodule, privatetofile, privatetoscope.<br>&gt;&gt; <br>&gt;&gt; I&#39;m tempted to go one further, but if you want to ignore that one further, skip the next two paragraphs:<br>&gt;&gt; <br>&gt;&gt; Abandon the words &#39;public&#39; and &#39;private&#39;. Let&#39;s just accept that, together with &#39;protected&#39;, these are well-defined terms of type-based visibility in OOP which are orthogonal to Swift&#39;s hierarchy, and that redefining them leads to confusion. Embrace &#39;external&#39; and &#39;internal&#39; in their places:<br>&gt;&gt; <br>&gt;&gt; external, internal(module), internal(file), internal(scope).<br>&gt;&gt; external, moduleinternal, fileinternal, scopeinternal.<br>&gt;&gt; external, internaltomodule, internaltofile, internaltoscope.<br>&gt;&gt; <br>&gt;&gt; If you ignored that, welcome back.<br>&gt;&gt; <br>&gt;&gt; I hope I&#39;ve not been too antagonistic about this. I really want Swift to use terms with clear meaning, and if that breaks code, I want a clean break that can be easily healed / migrated.<br>&gt;&gt; <br>&gt;&gt; Every suggestion for relabelling this hierarchy, bar &#39;public, internal, private, local/scope&#39;, breaks code.<br>&gt;&gt; <br>&gt;&gt; Adding the scope-visible level allows for greater control, but I don&#39;t believe module-visible and file-visible levels would be uncommon with its inclusion, so the terms for all three - all four, really - should be balanced in their &#39;ugliness&#39;.<br>&gt;&gt; <br>&gt;&gt; What the proposal as it stands does need to make clear is what would change and what would be left behind.<br>&gt;&gt; <br>&gt;&gt; If &#39;internal&#39; is renamed to &#39;moduleprivate&#39;, explicit uses of &#39;internal&#39; need to be replaced.<br>&gt;&gt; <br>&gt;&gt; If there are constants, &#39;global&#39; functions, operators, or anything that can be defined outside of a scope, their least visible level is fileprivate. They can never be &#39;scope-private&#39;.<br>&gt;&gt; <br>&gt;&gt; If &#39;private&#39; is redefined, it is no nearer to its meaning in other languages than it is now.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 12:30 PM, Matthew Judge via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br>&gt;&gt; <br>&gt;&gt; func f() {<br>&gt;&gt;   let outer = 0<br>&gt;&gt;  // f cannot use inner<br>&gt;&gt;    func g() {<br>&gt;&gt;        let inner = 1<br>&gt;&gt;        // g can use outer<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;  <br>&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather not include this in the proposal.<br>&gt;&gt; <br>&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible to in the following code: Inner or Outer?<br>&gt;&gt; <br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner {<br>&gt;&gt;         private var innerVar: Int<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; The only change that the core team requested was the name changes. I personally would prefer a completely private version where you cannot inject a class into a scope to get access to the scope internals, but it&#39;s an edge case that could be argued either way, and I don&#39;t want to start another lengthy discussion. We already had quite a few.<br>&gt;&gt; <br>&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br>&gt;&gt; <br>&gt;&gt; My understanding is that the new private would be: <br>&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt; - not visible to an extension <br>&gt;&gt; <br>&gt;&gt; Said in code (all in the same file):<br>&gt;&gt; ----------<br>&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt; <br>&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;     }<br>&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt; }<br>&gt;&gt; ----------<br>&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br>&gt;&gt; <br>&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Public <br>&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/30072599/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>This is incorrect; the current Swift model for &quot;private&quot; does not privilege anything in other files (or other modules), even extensions. This proposal does not change that, either for the existing file-private level being renamed, or for the new scope-private level being proposed.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 28, 2016, at 11:54, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That is a deal breaker for me and it is a departure of of the current swift model of localprivate aka private.<br>&gt; <br>&gt; I don’t like it. The introduction of a first class scopeprivate is not worth it if that is one of the tradeoffs. <br>&gt; <br>&gt; There are other ways to hide implementation now using nested functions. <br>&gt; <br>&gt; func outside() -&gt; Int{<br>&gt;     func insidelocalfunc() -&gt; Int {return 2}<br>&gt;     return insidelocalfunc()<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 28, 2016, at 11:16 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Would it really make sense to allow extensions in other files to access fileprivate members/funcs? <br>&gt;&gt; <br>&gt;&gt; no, fileprivate is limited to the specific file in which it is used.<br>&gt;&gt; <br>&gt;&gt; On Mon, Mar 28, 2016 at 1:13 PM Cheyo Ximenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt; Let&#39;s say that we go with <br>&gt;&gt; public, moduleprivate, fileprivate, scopeprivate<br>&gt;&gt; <br>&gt;&gt; Would it really make sense to allow extensions in other files to access fileprivate members/funcs?  The inclusion of the word &#39;file&#39; in the name would make it confusing that extensions have the special power to reach into a fileprivate from another file. This almost begs for another access like typeprivate (I am not proposing this).<br>&gt;&gt; <br>&gt;&gt; My understating is that scopeprivate came about as a way to deal with extensions, perhaps the author needs to look into a way to tag methods/members as not extendable or hidden from extensions only. The solution would probably be swift specific and it should probably brake out from the norm of other languages. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 28, 2016, at 5:46 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Ilya said:<br>&gt;&gt;&gt; &gt; &quot;public&quot;, &quot;protected&quot;, and &quot;private&quot; have a very well defined meaning in OOP. We shouldn&#39;t redefine them without a good reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree. Swift has a scope-based visibility system, not a type-based visibility system, but because Swift redefines the terms &#39;public&#39; and &#39;private&#39;, programmers keep getting confused about how they&#39;re used in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Over the last few posts, since Chris Lattner proposed switching to: &#39;public, internal, X, private&#39;, we&#39;ve had several new scales proposed. (In every scale in this post, there are four terms in order of decreasing visibility, with the second term being the default.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public, external, internal, private.<br>&gt;&gt;&gt; public, internal, private, secret.<br>&gt;&gt;&gt; external, internal, public, private.<br>&gt;&gt;&gt; public, internal, private, secret.<br>&gt;&gt;&gt; public, internal, private, local.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At this point, respectfully, I think we can dismiss the idea that labelling any given level as &#39;public&#39; or &#39;private&#39; is right or obvious. Swift is built around clarity at the point of use. &#39;private&#39; is not as clear as you maintain it is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Swift allows extensions, so &quot;private&quot; in its standard form doesn&#39;t work well -- you could just define an extension and get access to anything. The scope based private seems to be the most natural extension (pun intended :–)).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re redefining terms from a type-based visibility scale to a scope-based visibility scale. I&#39;m not disagreeing that an extension would allow access to type-visible symbols and that this might not be the programmer&#39;s intention, but that &#39;private&#39; has a clear meaning in OOP and repurposing &#39;private&#39; is not resolving any confusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class injection to gain access, but this is an edge case that could be argued either way. I can definitely live with a pure scoped access  for consistency and don&#39;t want to argue the edge case in a never ending discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I know, it&#39;s not an edge case in Swift, it&#39;s a non-case. Swift doesn&#39;t have type-based visibility. Using Swift&#39;s system, I do understand that you want &#39;private&#39; to refer to the least-visible level in the hierarchy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, as has already been pointed out, the scope-visible level is not the least-visible conceivable. There&#39;s already discussion over whether the properties of inner types should be visible to their outer types. If that ever made its way to a proposal, would that level become &#39;private&#39;? I think we can agree that another bikeshedding conversation like this would rather be avoided.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s also the possibility of a &#39;submodule&#39; level. Chris Lattner suggested that the &#39;private(foo.bar)&#39; syntax might be best for this, but I don&#39;t know what that means - whether &#39;submodule&#39; would be within the Swift hierarchy or not - but it&#39;s a possibility for the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m repeating myself, but: inclusion of the terms &#39;module&#39;, &#39;file&#39;, and &#39;scope&#39; in our symbols is winning out in clarity. None of those terms has changed meaning in the entire discussion. The only question is exactly how they should be welded to the term &#39;private&#39;. There&#39;ve been three suggestions for doing this so far and they&#39;re all awkward, either because they have parentheses or they&#39;re conjoined, but they&#39;re unambiguous in meaning and no-one&#39;s suggested any single-word ideas with the same clarity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public, private(module), private(file) and private(scope).<br>&gt;&gt;&gt; public, moduleprivate, fileprivate, scopeprivate.<br>&gt;&gt;&gt; public, privatetomodule, privatetofile, privatetoscope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m tempted to go one further, but if you want to ignore that one further, skip the next two paragraphs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Abandon the words &#39;public&#39; and &#39;private&#39;. Let&#39;s just accept that, together with &#39;protected&#39;, these are well-defined terms of type-based visibility in OOP which are orthogonal to Swift&#39;s hierarchy, and that redefining them leads to confusion. Embrace &#39;external&#39; and &#39;internal&#39; in their places:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; external, internal(module), internal(file), internal(scope).<br>&gt;&gt;&gt; external, moduleinternal, fileinternal, scopeinternal.<br>&gt;&gt;&gt; external, internaltomodule, internaltofile, internaltoscope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you ignored that, welcome back.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope I&#39;ve not been too antagonistic about this. I really want Swift to use terms with clear meaning, and if that breaks code, I want a clean break that can be easily healed / migrated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Every suggestion for relabelling this hierarchy, bar &#39;public, internal, private, local/scope&#39;, breaks code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding the scope-visible level allows for greater control, but I don&#39;t believe module-visible and file-visible levels would be uncommon with its inclusion, so the terms for all three - all four, really - should be balanced in their &#39;ugliness&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What the proposal as it stands does need to make clear is what would change and what would be left behind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &#39;internal&#39; is renamed to &#39;moduleprivate&#39;, explicit uses of &#39;internal&#39; need to be replaced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there are constants, &#39;global&#39; functions, operators, or anything that can be defined outside of a scope, their least visible level is fileprivate. They can never be &#39;scope-private&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &#39;private&#39; is redefined, it is no nearer to its meaning in other languages than it is now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 12:30 PM, Matthew Judge via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 6:41 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; lexical scope is the other way around: &quot;inner&quot; can see &quot;outer&quot;. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f() {<br>&gt;&gt;&gt;   let outer = 0<br>&gt;&gt;&gt;  // f cannot use inner<br>&gt;&gt;&gt;    func g() {<br>&gt;&gt;&gt;        let inner = 1<br>&gt;&gt;&gt;        // g can use outer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe I&#39;m off in my terminology, but I think my code example matches what you are saying here (outer is visible to g() but inner is not visible to f()<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; It would work the same way for the access level. That said, I&#39;d rather not include this in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So as the proposal stands now, what is the scope that innerVar is visible to in the following code: Inner or Outer?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Outer {<br>&gt;&gt;&gt;     class Inner {<br>&gt;&gt;&gt;         private var innerVar: Int<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The only change that the core team requested was the name changes. I personally would prefer a completely private version where you cannot inject a class into a scope to get access to the scope internals, but it&#39;s an edge case that could be argued either way, and I don&#39;t want to start another lengthy discussion. We already had quite a few.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Mar 27, 2016 at 11:17 PM Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I know it was suggested that it be the subject of a different thread, but it might be good to clarify how the new private is going to work (or at least what is currently envisioned).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding is that the new private would be: <br>&gt;&gt;&gt; - visible only to the immediately enclosing scope<br>&gt;&gt;&gt; - including the scope of a inner nested scope<br>&gt;&gt;&gt; - not including the scope of an outer nested scope<br>&gt;&gt;&gt; - not visible to an extension <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Said in code (all in the same file):<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; class Outer { // Outer visible to module<br>&gt;&gt;&gt;     private var a: Int // visible to Outer, Inner1, &amp; Inner2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     class Inner1 { // Inner1 visible to module<br>&gt;&gt;&gt;         private var b: Int // visible to Inner1 only<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     private class Inner2 { // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;         var c: Int // visible to Outer &amp; Inner(s)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Outer { // visible to module<br>&gt;&gt;&gt;     // &#39;a&#39;, &#39;b&#39;, and &#39;Inner2&#39; NOT visible<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ----------<br>&gt;&gt;&gt; If this is the intended meaning of private, then fileprivate seems to be the same as private (private to the enclosing scope... which happens to be the file).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something declared &quot;private&quot; at the top level of a file is fileprivate. There would still need to be a way to reference scopes other than the immediate one (especially since there is no way to say &quot;private&quot; and mean moduleprivate), though I think it would strengthen the argument for something along the lines of &quot;private(file)&quot;, since it would even further reduce the cases where you are spelling something more than just &quot;private&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 27, 2016, at 17:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Mar 2016, at 19:34, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Public <br>&gt;&gt;&gt;&gt;&gt; External (default)<br>&gt;&gt;&gt;&gt;&gt; Internal<br>&gt;&gt;&gt;&gt;&gt; Private<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still feel like these are still too vague; I’m not sure I like the use of external, as public to me is external since it exports outside of the module, whereas what you’re proposing is in fact just limited to the module itself. I dislike the current internal keyword too, but at least it reads as “internal to this module&quot;, this is why the more specific terms are better like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt;&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt;&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt;&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Assuming I’m understanding the restriction properly this time =)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s also the easiest method if we do add another visibility later for sub-classes such as private(type), as it doesn’t even require a new keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/e7c6bf60/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>March 28, 2016 at 11:00:00am</p></header><div class="content"><p>If the following parenthesized access keywords are still on the table as an option,<br></p><p>&gt; On Mar 27, 2016, at 14:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	public				as-is, item is public/exported outside of module<br>&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt; 	private(file)			current private, item is private to this file<br>&gt; 	private(scope)			new visibility type, item is private to the current scope<br></p><p><br></p><p>I would prefer them over these ones:<br></p><p>	public<br>        moduleprivate<br>        fileprivate<br>        private<br></p><p>To my eyes, the parenthesized ones are more readable and understandable.<br></p><p>-Matt<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/b5dea0a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 12:41 PM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If the following parenthesized access keywords are still on the table as an option,<br>&gt; <br>&gt;&gt; On Mar 27, 2016, at 14:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	public				as-is, item is public/exported outside of module<br>&gt;&gt; 	private(module) or private	current internal, item is private to this module, would be the default<br>&gt;&gt; 	private(file)			current private, item is private to this file<br>&gt;&gt; 	private(scope)			new visibility type, item is private to the current scope<br>&gt; <br>&gt; <br>&gt; <br>&gt; I would prefer them over these ones:<br>&gt; <br>&gt; 	public<br>&gt;         moduleprivate<br>&gt;         fileprivate<br>&gt;         private<br>&gt; <br>&gt; To my eyes, the parenthesized ones are more readable and understandable.<br></p><p>+1 to paren syntax for readability, private(module) being the default if nothing declared, private with no parenthesized access keyword can default to either file or scope.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/63ecd90d/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/63ecd90d/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>&quot;public&quot;, &quot;protected&quot;, and &quot;private&quot; have a very well defined meaning in<br>OOP. We shouldn&#39;t redefine them without a good reason.<br></p><p>Swift allows extensions, so &quot;private&quot; in its standard form doesn&#39;t work<br>well -- you could just define an extension and get access to anything. The<br>scope based private seems to be the most natural extension (pun intended<br>:–)).<br></p><p>On Sat, Mar 26, 2016 at 3:14 AM Cheyo Ximenez &lt;cheyo at masters3d.com&gt; wrote:<br></p><p>&gt; I agree with Ross. Swift already redefined the common access modifiers<br>&gt; meanings.<br>&gt; Why not use the word &#39;protected&#39; to mean &#39;local&#39;?<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; private<br>&gt; protected // Java got it wrong. :) This is &quot;protected&quot; against extensions.<br>&gt;<br>&gt;<br>&gt; On Mar 25, 2016, at 6:57 PM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages<br>&gt; refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and<br>&gt; Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent<br>&gt; to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt;<br>&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this<br>&gt; is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is<br>&gt; &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding<br>&gt; in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt;<br>&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants<br>&gt; what a Brit calls crisps; a Brit who wants chips wants what an American<br>&gt; calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the<br>&gt; one you grew up with.<br>&gt;<br>&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; all of these names (public, internal, private, local) have specific<br>&gt;&gt; meaning in the context of computer languages.<br>&gt;&gt;<br>&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s<br>&gt;&gt; an access level. It usually has something to do with declaring variables<br>&gt;&gt; inside a function.<br>&gt;&gt;<br>&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML<br>&gt;&gt; uses it to create a scope (roughly). Lua and Julia use it to declare<br>&gt;&gt; lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new<br>&gt;&gt; access level is specifically *not* supposed to allow.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If<br>&gt;&gt; you&#39;re aware of an analogous use in another language, I&#39;d be interested to<br>&gt;&gt; see it. But the examples I&#39;ve found if anything *undermine* the suggestion<br>&gt;&gt; that `local` would be a good keyword choice.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/16d42a6b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>I understand the analogy, but I think that it doesn&#39;t apply here. If Swift<br>was 30 years old, the argument would work, but right now there are many<br>more people in the world who use the terms differently. Originally, I<br>suggested using another name for backward compatibility, but I am glad that<br>the core team decided to use the standard names.<br></p><p>On Fri, Mar 25, 2016 at 9:57 PM Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>wrote:<br></p><p>&gt; The specific meaning of &#39;public&#39; and &#39;private&#39; in programming languages<br>&gt; refers to type-based symbol visibility. I&#39;m thinking of C++, C#, Java and<br>&gt; Objective C; their &#39;public&#39; is Swift&#39;s &#39;internal&#39;. They have no equivalent<br>&gt; to Swift&#39;s &#39;public&#39;. Swift has no equivalent to their &#39;private&#39;.<br>&gt;<br>&gt; Possibly my familiarity with other languages isn&#39;t broad enough, but this<br>&gt; is why I haven&#39;t understood the idea that Swift&#39;s use of &#39;private&#39; is<br>&gt; &quot;right&quot; or &quot;obvious&quot;. You learn Swift&#39;s meanings of these terms by coding<br>&gt; in Swift, you don&#39;t learn these meanings anywhere else first.<br>&gt;<br>&gt; To use a hopefully recognised example: an American who wants &#39;chips&#39; wants<br>&gt; what a Brit calls crisps; a Brit who wants chips wants what an American<br>&gt; calls french fries. Which meaning of &#39;chips&#39; is more intuitive? Answer: the<br>&gt; one you grew up with.<br>&gt;<br>&gt; On Sat, Mar 26, 2016 at 1:10 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; all of these names (public, internal, private, local) have specific<br>&gt;&gt; meaning in the context of computer languages.<br>&gt;&gt;<br>&gt;&gt; Yes, `local` has a meaning, but that meaning is generally *not* that it&#39;s<br>&gt;&gt; an access level. It usually has something to do with declaring variables<br>&gt;&gt; inside a function.<br>&gt;&gt;<br>&gt;&gt; For instance, Perl uses it to back up and restore a global variable. ML<br>&gt;&gt; uses it to create a scope (roughly). Lua and Julia use it to declare<br>&gt;&gt; lexical variables which are visible in enclosed scopes, which SE-0025&#39;s new<br>&gt;&gt; access level is specifically *not* supposed to allow.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know of any language where `local` is used as an access level. If<br>&gt;&gt; you&#39;re aware of an analogous use in another language, I&#39;d be interested to<br>&gt;&gt; see it. But the examples I&#39;ve found if anything *undermine* the suggestion<br>&gt;&gt; that `local` would be a good keyword choice.<br>&gt;&gt;<br>&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/f8e5b0ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Sure, but is that worth 7 to 9 extra characters at every single use site for something that&#39;s actually pretty common?<br></p><p>Yes.<br></p><p>These are special cases — both file-private and module-private is something that is fairly unusual and should stick out a bit, so the length helps here. (Unless you&#39;re writing your entire app in module-private mode, in which case you won&#39;t use the modifier at all.)<br></p><p>I think Chris has explicitly stated that brevity for the sake of typing less is not a goal of Swift. There&#39;s software like Keyboard Maestro that I really recommend when typing code; just assign keyboard shortcuts (GW-BASIC-style) to the common keywords, and the length won&#39;t matter. <br></p><p>&gt; We call the type `Int32`, not `SignedIntegerBetweenNegative2ToThe31stPowerAnd2ToThe31stPowerMinus1`<br></p><p>Perhaps the new modifiers look worse to you than to me. &quot;fileprivate var&quot; reads just fine to my ears, exactly the right balance of length and brevity, and &quot;file var&quot; invokes wrong associations in my head, akin to being a static var, and generally feels way too short.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br></p><p>afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br></p><p>I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br></p><p>In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br></p><p>None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br>&gt; <br>&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt; That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br>&gt; <br>&gt; I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br>&gt; <br>&gt; In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br>&gt; <br>&gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>&gt; I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br></p><p>I cannot come up with a single use-case in my code for fileprivate and would love<br>some real world examples where you&#39;d want visibility in a single file but not across<br>an entire module.<br></p><p>The fileprivate behavior has been a bugaboo of mine for some time, particularly in <br>playground use. <br></p><p>As far as I&#39;m concerned, the control I really want is public,  intra-modular, private, and <br>private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March 25, 2016 at 10:00:00am</p></header><div class="content"><p>I have types where I declare their members (some public, some private) and use extensions to provide the API implementations of protocols. <br></p><p>These implementations use data that is not public to the type. A file-based access level is the only one that works for me. <br></p><p>This is actually the common case for me. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 25, 2016, at 10:11 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br>&gt;&gt; <br>&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt;&gt; That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br>&gt;&gt; <br>&gt;&gt; I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br>&gt;&gt; <br>&gt;&gt; In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br>&gt;&gt; <br>&gt;&gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>&gt;&gt; I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br>&gt; <br>&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt; an entire module.<br>&gt; <br>&gt; The fileprivate behavior has been a bugaboo of mine for some time, particularly in <br>&gt; playground use. <br>&gt; <br>&gt; As far as I&#39;m concerned, the control I really want is public,  intra-modular, private, and <br>&gt; private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March 25, 2016 at 12:00:00pm</p></header><div class="content"><p>I have many situations where related, and usually, nested types should have<br>access to implementation details of each other but I want to avoid any<br>other types having access to these details. The simplest example that I<br>have are value types that wrap one or two values. &#39;Unrelated&#39; types<br>shouldn&#39;t have access to these `rawValue`s at all.<br>TJ<br></p><p><br>On Fri, Mar 25, 2016 at 12:11 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; These are special cases — both file-private and module-private is<br>&gt; something that is fairly unusual<br>&gt; &gt;<br>&gt; &gt; afaics this is the third time someone mentions that &quot;file-private&quot; is<br>&gt; uncommon — so I think it&#39;s time someone dissents:<br>&gt; &gt; That statement is at least subjective… right now, &quot;file-private&quot; is one<br>&gt; of three access levels, and I wouldn&#39;t dare to say either is more or less<br>&gt; important than the others.<br>&gt; &gt;<br>&gt; &gt; I never encountered situations with the current model where I missed a<br>&gt; new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the<br>&gt; code I&#39;ll be writing.<br>&gt; &gt;<br>&gt; &gt; In my existing code, the new meaning of private wouldn&#39;t break much, but<br>&gt; the current meaning doesn&#39;t hurt me, and there are cases where<br>&gt; &quot;file-private&quot; is needed.<br>&gt; &gt;<br>&gt; &gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; —<br>&gt; but not because I perceive it as unusual:<br>&gt; &gt; I just expect that code completion will do the typing for me, so maybe<br>&gt; &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br>&gt;<br>&gt; I cannot come up with a single use-case in my code for fileprivate and<br>&gt; would love<br>&gt; some real world examples where you&#39;d want visibility in a single file but<br>&gt; not across<br>&gt; an entire module.<br>&gt;<br>&gt; The fileprivate behavior has been a bugaboo of mine for some time,<br>&gt; particularly in<br>&gt; playground use.<br>&gt;<br>&gt; As far as I&#39;m concerned, the control I really want is public,<br>&gt; intra-modular, private, and<br>&gt; private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/8836f6f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>March 25, 2016 at 01:00:00pm</p></header><div class="content"><p>I use the file-private scope a fair amount for top-level constants that are intended to be used within the file, possibly across types. Doing things this way is more concise than embedding them as static members in the type itself since I don&#39;t need to qualify them with the name of the type at the front.<br></p><p>Kevin Lundberg<br>kevin at klundberg.com<br></p><p><br></p><p>&gt; On Mar 25, 2016, at 1:11 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br>&gt;&gt; <br>&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt;&gt; That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br>&gt;&gt; <br>&gt;&gt; I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br>&gt;&gt; <br>&gt;&gt; In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br>&gt;&gt; <br>&gt;&gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>&gt;&gt; I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br>&gt; <br>&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt; an entire module.<br>&gt; <br>&gt; The fileprivate behavior has been a bugaboo of mine for some time, particularly in <br>&gt; playground use. <br>&gt; <br>&gt; As far as I&#39;m concerned, the control I really want is public,  intra-modular, private, and <br>&gt; private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 29, 2016 at 10:00:00am</p></header><div class="content"><p>On Mar 25, 2016, at 10:37 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I use the file-private scope a fair amount for top-level constants that are intended to be used within the file, possibly across types. Doing things this way is more concise than embedding them as static members in the type itself since I don&#39;t need to qualify them with the name of the type at the front.<br></p><p>This is a great point, and perhaps should be made more clear.  In the degenerate case of a top level declaration, “private” and “fileprivate” are the same thing, since the scope that “private” refers to is the whole file.<br></p><p>	private let c = 42   // usable within the current file.<br></p><p>	private struct X { init(a : Int) {…} }  // usable within the current file.<br></p><p>	func foo() { <br>	        let thing = X(a: c)<br>	}<br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; Kevin Lundberg<br>&gt; kevin at klundberg.com<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 1:11 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt;&gt;&gt; That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>&gt;&gt;&gt; I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br>&gt;&gt; <br>&gt;&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt;&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt;&gt; an entire module.<br>&gt;&gt; <br>&gt;&gt; The fileprivate behavior has been a bugaboo of mine for some time, particularly in <br>&gt;&gt; playground use. <br>&gt;&gt; <br>&gt;&gt; As far as I&#39;m concerned, the control I really want is public,  intra-modular, private, and <br>&gt;&gt; private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 30, 2016 at 05:00:00am</p></header><div class="content"><p>&gt;&gt; On Mar 29, 2016, at 13:54, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mar 25, 2016, at 10:37 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I use the file-private scope a fair amount for top-level constants that are intended to be used within the file, possibly across types. Doing things this way is more concise than embedding them as static members in the type itself since I don&#39;t need to qualify them with the name of the type at the front.<br>&gt; <br>&gt; This is a great point, and perhaps should be made more clear.  In the degenerate case of a top level declaration, “private” and “fileprivate” are the same thing, since the scope that “private” refers to is the whole file.<br>&gt; <br>&gt;   private let c = 42   // usable within the current file.<br>&gt; <br>&gt;   private struct X { init(a : Int) {…} }  // usable within the current file.<br>&gt; <br>&gt;   func foo() { <br>&gt;           let thing = X(a: c)<br>&gt;   }<br>&gt; <br>&gt; -Chris<br></p><p>This seems to be a strong argument for &quot;private(file)&quot; or &quot;private(#file)&quot; <br></p><p>There are really just two access levels:<br>- public // visible everywhere<br>- private // only visible to current scope<br></p><p>The parenthetical is a way to refer to some enclosing scope broader than the current scope.<br></p><p>- Matt<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Kevin Lundberg<br>&gt;&gt; kevin at klundberg.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 25, 2016, at 1:11 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt;&gt;&gt;&gt; That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>&gt;&gt;&gt;&gt; I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt;&gt;&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt;&gt;&gt; an entire module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fileprivate behavior has been a bugaboo of mine for some time, particularly in <br>&gt;&gt;&gt; playground use. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I&#39;m concerned, the control I really want is public,  intra-modular, private, and <br>&gt;&gt;&gt; private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt; an entire module.<br></p><p>Glad I&#39;m not the only one to reply that request ;-), and I have something to add as well:<br>Operators.<br>Afair there&#39;s a discussion about including operator-methods as part of a type, but until this is possible, we have to rely on the current &quot;private&quot; if the operator needs full access (or methods that are called by the operator — I actually like this pattern, but others may disagree on that).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fa5f52f699e07a98fefcf30fb95354?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James Richard</string> &lt;ketzu at me.com&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Erica,<br></p><p>I use &quot;file private&quot; extensively for keys. We have a set of models that are loaded from a server into core data. We use a common method to load the values in, and we define the keys as a file private &quot;keys&quot; tuple (originally a struct with private static constants, but the tuple was simpler). This allows us to reuse the word keys throughout the module, which is short, clear, and doesn&#39;t pollute the rest of the module with key identifiers where they are not necessary.<br></p><p>I&#39;m sure there are other ways to do this, but I&#39;ve come to quite enjoy the file private system we have.<br></p><p>~James<br></p><p>Sent from my iPad<br></p><p>&gt; On Mar 25, 2016, at 10:11 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 10:57 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; These are special cases — both file-private and module-private is something that is fairly unusual<br>&gt;&gt; <br>&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt;&gt; That statement is at least subjective… right now, &quot;file-private&quot; is one of three access levels, and I wouldn&#39;t dare to say either is more or less important than the others.<br>&gt;&gt; <br>&gt;&gt; I never encountered situations with the current model where I missed a new &quot;private&quot;-level, and maybe &quot;private&quot; will become fairly unusual for the code I&#39;ll be writing.<br>&gt;&gt; <br>&gt;&gt; In my existing code, the new meaning of private wouldn&#39;t break much, but the current meaning doesn&#39;t hurt me, and there are cases where &quot;file-private&quot; is needed.<br>&gt;&gt; <br>&gt;&gt; None the less, I don&#39;t care much about the &quot;ugliness&quot; of &quot;fileprivate&quot; — but not because I perceive it as unusual:<br>&gt;&gt; I just expect that code completion will do the typing for me, so maybe &quot;f&quot; will be all I have to write (half the characters of &quot;pr&quot; ;-)<br>&gt; <br>&gt; I cannot come up with a single use-case in my code for fileprivate and would love<br>&gt; some real world examples where you&#39;d want visibility in a single file but not across<br>&gt; an entire module.<br>&gt; <br>&gt; The fileprivate behavior has been a bugaboo of mine for some time, particularly in <br>&gt; playground use. <br>&gt; <br>&gt; As far as I&#39;m concerned, the control I really want is public,  intra-modular, private, and <br>&gt; private-even-to-extensions-and-subclasses. I assume the latter is a no-go.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>March 25, 2016 at 01:00:00pm</p></header><div class="content"><p>Le 25 mars 2016 à 12:57, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br></p><p>I&#39;ll do the same. There&#39;s many instances in my code where I rely on the file-private behavior of Swift 2&#39;s private. Mostly this happens when I have a pair of coupled classes that are meant to be used together and that need to access internal details of each other. Most declarations can be scope-private without problem, but it&#39;s not that uncommon for me to take advantage of file-private. <br></p><p>There&#39;s another aspect that is bothering me about these long names. It seems that everyone agrees that writing internal is a rare thing. Still, if you look at generated headers in Xcode you&#39;ll see internal everywhere, like this:<br></p><p>internal class ItemDataModel {<br>    internal var storage: ItemStorage { get set }<br>    internal let fileType: String<br>    required internal init(fileType: String, storage: ItemStorage = default)<br>}<br></p><p>Since internal is the default, it&#39;s quite common in generated headers. &quot;moduleprivate&quot; wouldn&#39;t be an improvement for legibility here. But perhaps no one but me looks at generated headers for my own project.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/fe9b7b80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 29, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 25.03.2016 um 18:36 schrieb Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Le 25 mars 2016 à 12:57, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; afaics this is the third time someone mentions that &quot;file-private&quot; is uncommon — so I think it&#39;s time someone dissents:<br>&gt; <br>&gt; I&#39;ll do the same. There&#39;s many instances in my code where I rely on the file-private behavior of Swift 2&#39;s private. Mostly this happens when I have a pair of coupled classes that are meant to be used together and that need to access internal details of each other. Most declarations can be scope-private without problem, but it&#39;s not that uncommon for me to take advantage of file-private. <br></p><p>+1<br></p><p><br>&gt; <br>&gt; There&#39;s another aspect that is bothering me about these long names. It seems that everyone agrees that writing internal is a rare thing. Still, if you look at generated headers in Xcode you&#39;ll see internal everywhere, like this:<br>&gt; <br>&gt; internal class ItemDataModel {<br>&gt;     internal var storage: ItemStorage { get set }<br>&gt;     internal let fileType: String<br>&gt;     required internal init(fileType: String, storage: ItemStorage = default)<br>&gt; }<br>&gt; <br>&gt; Since internal is the default, it&#39;s quite common in generated headers. &quot;moduleprivate&quot; wouldn&#39;t be an improvement for legibility here. But perhaps no one but me looks at generated headers for my own project.<br></p><p>Additionally Jordan noted that there might be a policy to always use explicit access control. In our Java projects we certainly do this because the default &quot;package&quot; level is quite unusual there and omitting it is easily intepreted as being an oversight instead of intentional.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/c72be105/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>March 24, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mar 24, 2016, at 6:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Honestly, though, I&#39;m not sure why people are working so hard to cram `private` in there. Does `moduleprivate` or `private(module)` really convey more information than `module`? Particularly once you&#39;ve looked it up and know that it&#39;s an access modifier?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I&#39;m with you here too. I&#39;m not opposed to it but it strikes me as being hypertechnical and unnecessarily verbose. <br></p><p>It&#39;s also not symmetrical: where is modulepublic and filepublic? Those don&#39;t make sense? Then module and file stand on their own if private is implied (you know people will wonder when they see moduleprivate if a public one exists)<br></p><p>Brandon<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 24, 2016 at 10:00:00pm</p></header><div class="content"><p>On Mar 24, 2016, at 6:02 AM, John Siracusa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt;         public<br>&gt;         moduleprivate<br>&gt;         fileprivate<br>&gt;         private<br>&gt; <br>&gt; Why is it important to highlight word boundaries in so many other conventions in Swift but not in this one? What would be lost with this alternative?<br>&gt; <br>&gt; public<br>&gt; module_private<br>&gt; file_private<br>&gt; private<br>&gt; <br>&gt; Is it just the extra (chorded, on US keyboards) keystroke? I think the readability benefits of clear word boundaries far outweigh the keystroke cost (especially with good editor auto-complete).<br>&gt; <br>&gt; I also think the precedent of nameslikethis is a dangerous one for readability. It&#39;s easy to say this is &quot;just for this limited area of the language,&quot; but witness how associatedtype is already used to support moduleprivate and friends. Precedents matter, and I think this is not a good one.<br></p><p>Hi John,<br></p><p>Great question.  The core team has discussed this (extensively, on multiple occasions, sigh.. :-).  The conclusion is to standardize on a simple and consistent schema of:<br></p><p>1. Keywords &amp; declaration modifiers all lower case, conjoined when multi-word.<br>2. Attributes and values (which includes methods and enum cases) being lower camel case.<br>3. Types being upper camel case.<br></p><p>This approach eliminates the “snake&quot; case we had before, but “camel fans&quot; often raise the question of why we don’t apply lower camel case to keywords.  There are a couple of reasons for this:<br></p><p>1. Keywords, as part of the language, are extremely carefully considered and scrutinized by a large community of smart folks on swift-evolution.  Taking a word (e.g. “in” or “for”) is something that has to be carefully balanced vs the impact on real world code in various domains.  It isn’t done lightly.<br></p><p>2. Lower camel case is already used for values.  Keyword/value conflicts are a real thing, particularly when it comes to expressive APIs.   We have solved this for keyword arguments to methods, but conflicts on property names are still a very real thing.<br></p><p>3. We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers. It is reasonable to expect a Swift programmer to grok (as they incrementally gain mastery of the language) the builtin language keywords.  Syntax highlighting and other IDE features also help here.<br></p><p>That said, to be fair, there is more work to be done here in Swift 3, because we still have the legacy dynamicType keyword - it should be renamed to “dynamictype&quot; IMO.<br></p><p>4. Declaration modifiers (like public/private/moduleprivate/etc) don’t have to live by the same rules as keywords necessarily (the grammar of Swift allows us to precisely disambiguate decl-modifiers based on the keyword they hang off of), but Swift programmers think of them as keywords, and so it is most consistent for them to follow the naming scheme of keywords.<br></p><p>5. In contrast, attributes are intentionally “demoted” in prominence for various reasons, and require an @ prefix.  We also expect and hope to support user defined attributes at some point.  As such, lower-camel-case (when not containing a framework prefix like NS or UI) is the best approach for them.<br></p><p>These are all reasons why we go with conjoined keywords instead of lower-camel-case.  If you are really asking why we don’t go with *snake* case, the answer is somewhat simpler: Swift is an “opinionated” language and we find snake case to be ugly (YMMV of course).<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/f9a6cb09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/afb1af7924cbadd912a8b5b2f1308bba?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>John Siracusa</string> &lt;siracusa at gmail.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>That&#39;s for the explanation. I think this last part gets at the heart of my<br>question: Why isn&#39;t it important to highlight word boundaries in this case?<br></p><p>On Fri, Mar 25, 2016 at 1:24 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; Swift is an “opinionated” language and we find snake case to be ugly (YMMV<br>&gt; of course).<br>&gt;<br></p><p>My attempt to summarize/rephrase the overall answer: &quot;We used up all the<br>word-boundary-highlighting conventions that we don&#39;t find ugly on other<br>parts of the language, and we don&#39;t want to reuse any of them due to the<br>potential for conflict and confusion.&quot;<br></p><p>As for snake case being ugly, my mileage does vary (obviously). Ithink<br>thereadability costofnot highlightingwordboundaries outweighsthe<br>aestheticconcerns. But them&#39;s the breaks when it comes to aesthetic issues,<br>I suppose. And in the grand scheme of things, at least the total number of<br>declaration modifiers should be small… :)<br></p><p>-John<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/e0797d53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 25, 2016, at 6:34 AM, John Siracusa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the explanation. I think this last part gets at the heart of my question: Why isn&#39;t it important to highlight word boundaries in this case?<br>&gt; <br>&gt; On Fri, Mar 25, 2016 at 1:24 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; Swift is an “opinionated” language and we find snake case to be ugly (YMMV of course).<br>&gt; <br>&gt; My attempt to summarize/rephrase the overall answer: &quot;We used up all the word-boundary-highlighting conventions that we don&#39;t find ugly on other parts of the language, and we don&#39;t want to reuse any of them due to the potential for conflict and confusion.”<br></p><p>I’m sorry for the confusion.  There are two issues: whether it is important to highlight word boundaries, and if so, what approach to use.  The first (and longer) part of the email was intended to justify why we don’t highlight word boundaries for keywords.  My overly snarky answer at the end was an attempt to answer why we don’t use snake case, but it wasn’t very effective :-)<br></p><p>Here is a different way to look at it: if we were going to highlight word boundaries, we would do it with camel case.  We use camel case in other places, and it has advantages over snake case (shorter identifiers), so we wouldn’t introduce a new way to do it.  <br></p><p>&gt; As for snake case being ugly, my mileage does vary (obviously). Ithink thereadability costofnot highlightingwordboundaries outweighsthe aestheticconcerns. But them&#39;s the breaks when it comes to aesthetic issues, I suppose. And in the grand scheme of things, at least the total number of declaration modifiers should be small… :)<br></p><p>I understand the concern.  The short version of the argument is that multiword keywords and declmodifiers are rare , primitive, and used in idiomatic ways so the opportunity for confusion is low.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/3917e588/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Mar 24, 2016, at 12:13 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt; <br>&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt; <br>&gt; I’ve seen several proposals that seem promising:<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt; <br>&gt;&gt;    private            symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;    private(module)    symbol visible within the current module.<br>&gt;&gt;    private(file)        symbol visible within the current file.<br>&gt; <br>&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; public<br>&gt;&gt; private-module<br>&gt;&gt; private-file<br>&gt;&gt; private<br>&gt; <br>&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt; <br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt;    public<br>&gt;    moduleprivate<br>&gt;    fileprivate<br>&gt;    private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br></p><p>+1.  This is probably the best option so far.  We need to pick something and move on at this point.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt;    public<br>&gt;    moduleprivate<br>&gt;    fileprivate<br>&gt;    private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I&#39;m not sure my wording will be perfect here, but I will try: I still believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is in the name of the plain &quot;private&quot; keyword. <br></p><p>You may say private is obvious, but when you have moduleprivate and fileprivate, the natural question I ask is &quot;What remaining kind of private is there?&quot; so private&#39;s obviousness is muddied for me when next to moduleprivate and fileprivate. <br></p><p>I will say I would prefer these keywords to the proposed parameter keywords. I just think:<br></p><p>file -&gt; implies file only<br>module -&gt; implies module only <br></p><p>where adding private to them only adds noise (I.e. fileprivate and moduleprivate)<br></p><p>Brandon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s<br>intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for<br>&#39;declaration only&#39;.<br></p><p>I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms.<br>I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br></p><p>On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;<br>&gt; &gt;    public<br>&gt; &gt;    moduleprivate<br>&gt; &gt;    fileprivate<br>&gt; &gt;    private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt; &gt;<br>&gt; &gt; What do you all think?<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still<br>&gt; believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is<br>&gt; in the name of the plain &quot;private&quot; keyword.<br>&gt;<br>&gt; You may say private is obvious, but when you have moduleprivate and<br>&gt; fileprivate, the natural question I ask is &quot;What remaining kind of private<br>&gt; is there?&quot; so private&#39;s obviousness is muddied for me when next to<br>&gt; moduleprivate and fileprivate.<br>&gt;<br>&gt; I will say I would prefer these keywords to the proposed parameter<br>&gt; keywords. I just think:<br>&gt;<br>&gt; file -&gt; implies file only<br>&gt; module -&gt; implies module only<br>&gt;<br>&gt; where adding private to them only adds noise (I.e. fileprivate and<br>&gt; moduleprivate)<br>&gt;<br>&gt; Brandon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/af3f9afb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>This is why I&#39;d like private to mean exactly that (no nested class should<br>get access). Then the meaning is clear: it&#39;s as private as it can be :-)<br></p><p>Private and public have well defined meaning. We<br>On Thu, Mar 24, 2016 at 11:33 AM Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s<br>&gt; intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for<br>&gt; &#39;declaration only&#39;.<br>&gt;<br>&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms.<br>&gt; I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br>&gt;<br>&gt; On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    public<br>&gt;&gt; &gt;    moduleprivate<br>&gt;&gt; &gt;    fileprivate<br>&gt;&gt; &gt;    private<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What do you all think?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still<br>&gt;&gt; believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is<br>&gt;&gt; in the name of the plain &quot;private&quot; keyword.<br>&gt;&gt;<br>&gt;&gt; You may say private is obvious, but when you have moduleprivate and<br>&gt;&gt; fileprivate, the natural question I ask is &quot;What remaining kind of private<br>&gt;&gt; is there?&quot; so private&#39;s obviousness is muddied for me when next to<br>&gt;&gt; moduleprivate and fileprivate.<br>&gt;&gt;<br>&gt;&gt; I will say I would prefer these keywords to the proposed parameter<br>&gt;&gt; keywords. I just think:<br>&gt;&gt;<br>&gt;&gt; file -&gt; implies file only<br>&gt;&gt; module -&gt; implies module only<br>&gt;&gt;<br>&gt;&gt; where adding private to them only adds noise (I.e. fileprivate and<br>&gt;&gt; moduleprivate)<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/cf7fd5a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 10:40 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is why I&#39;d like private to mean exactly that (no nested class should get access). Then the meaning is clear: it&#39;s as private as it can be :-)<br></p><p>In that case, you want a type-based access control mechanism, not a scope-based access control mechanism.  Your proposal that was provisionally accepted is for a scope-based mechanism.  <br></p><p>Chris’s request for bikeshedding on names did not include a request to bikeshed on semantics.  Any discussion about type-based access control should happen in a different thread IMO.<br></p><p>&gt; <br>&gt; Private and public have well defined meaning. We <br>&gt; On Thu, Mar 24, 2016 at 11:33 AM Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for &#39;declaration only&#39;.<br>&gt; <br>&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms. I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br>&gt; <br>&gt; On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; &gt;<br>&gt; &gt;    public<br>&gt; &gt;    moduleprivate<br>&gt; &gt;    fileprivate<br>&gt; &gt;    private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; &gt;<br>&gt; &gt; What do you all think?<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is in the name of the plain &quot;private&quot; keyword.<br>&gt; <br>&gt; You may say private is obvious, but when you have moduleprivate and fileprivate, the natural question I ask is &quot;What remaining kind of private is there?&quot; so private&#39;s obviousness is muddied for me when next to moduleprivate and fileprivate.<br>&gt; <br>&gt; I will say I would prefer these keywords to the proposed parameter keywords. I just think:<br>&gt; <br>&gt; file -&gt; implies file only<br>&gt; module -&gt; implies module only<br>&gt; <br>&gt; where adding private to them only adds noise (I.e. fileprivate and moduleprivate)<br>&gt; <br>&gt; Brandon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/87dcc09b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 26, 2016 at 12:00:00am</p></header><div class="content"><p>no, I still want extensions to be able to hide their implementation details<br>from anything else (including other extensions of the same type or the<br>&quot;root&quot; class definition). And I also want to be able to hide stuff in the<br>root class definition from extensions of the same type. I just don&#39;t want<br>an ability to inject new class in a scope to get access to its<br>implementation details.<br></p><p>That said, I will not include it in the updated proposal (i&#39;ll only update<br>the names) and will start a new thread after SE-0025. Also, I think that<br>it&#39;s an edge case, and it could be argued either way.<br></p><p>On Thu, Mar 24, 2016 at 11:47 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On Mar 24, 2016, at 10:40 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is why I&#39;d like private to mean exactly that (no nested class should<br>&gt; get access). Then the meaning is clear: it&#39;s as private as it can be :-)<br>&gt;<br>&gt;<br>&gt; In that case, you want a type-based access control mechanism, not a<br>&gt; scope-based access control mechanism.  Your proposal that was provisionally<br>&gt; accepted is for a scope-based mechanism.<br>&gt;<br>&gt; Chris’s request for bikeshedding on names did not include a request to<br>&gt; bikeshed on semantics.  Any discussion about type-based access control<br>&gt; should happen in a different thread IMO.<br>&gt;<br>&gt;<br>&gt; Private and public have well defined meaning. We<br>&gt; On Thu, Mar 24, 2016 at 11:33 AM Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s<br>&gt;&gt; intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for<br>&gt;&gt; &#39;declaration only&#39;.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms.<br>&gt;&gt; I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br>&gt;&gt;<br>&gt;&gt; On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt;&gt; and use:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;    public<br>&gt;&gt;&gt; &gt;    moduleprivate<br>&gt;&gt;&gt; &gt;    fileprivate<br>&gt;&gt;&gt; &gt;    private<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What do you all think?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Chris<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still<br>&gt;&gt;&gt; believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is<br>&gt;&gt;&gt; in the name of the plain &quot;private&quot; keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You may say private is obvious, but when you have moduleprivate and<br>&gt;&gt;&gt; fileprivate, the natural question I ask is &quot;What remaining kind of private<br>&gt;&gt;&gt; is there?&quot; so private&#39;s obviousness is muddied for me when next to<br>&gt;&gt;&gt; moduleprivate and fileprivate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I will say I would prefer these keywords to the proposed parameter<br>&gt;&gt;&gt; keywords. I just think:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; file -&gt; implies file only<br>&gt;&gt;&gt; module -&gt; implies module only<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; where adding private to them only adds noise (I.e. fileprivate and<br>&gt;&gt;&gt; moduleprivate)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/07150849/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>The last sentence was meant to be:<br>Private and public have well defined meaning, we should keep the same<br>semantics.<br></p><p>Still, this is an edge case. Maybe we can separate it into another proposal.<br></p><p>On Thu, Mar 24, 2016 at 11:42 AM Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is why I&#39;d like private to mean exactly that (no nested class should<br>&gt; get access). Then the meaning is clear: it&#39;s as private as it can be :-)<br>&gt;<br>&gt; Private and public have well defined meaning. We<br>&gt; On Thu, Mar 24, 2016 at 11:33 AM Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s<br>&gt;&gt; intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for<br>&gt;&gt; &#39;declaration only&#39;.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms.<br>&gt;&gt; I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br>&gt;&gt;<br>&gt;&gt; On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt;&gt; and use:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;    public<br>&gt;&gt;&gt; &gt;    moduleprivate<br>&gt;&gt;&gt; &gt;    fileprivate<br>&gt;&gt;&gt; &gt;    private<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What do you all think?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Chris<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still<br>&gt;&gt;&gt; believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is<br>&gt;&gt;&gt; in the name of the plain &quot;private&quot; keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You may say private is obvious, but when you have moduleprivate and<br>&gt;&gt;&gt; fileprivate, the natural question I ask is &quot;What remaining kind of private<br>&gt;&gt;&gt; is there?&quot; so private&#39;s obviousness is muddied for me when next to<br>&gt;&gt;&gt; moduleprivate and fileprivate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I will say I would prefer these keywords to the proposed parameter<br>&gt;&gt;&gt; keywords. I just think:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; file -&gt; implies file only<br>&gt;&gt;&gt; module -&gt; implies module only<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; where adding private to them only adds noise (I.e. fileprivate and<br>&gt;&gt;&gt; moduleprivate)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/4b235153/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 10:52 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The last sentence was meant to be:<br>&gt; Private and public have well defined meaning, we should keep the same semantics.<br>&gt; <br>&gt; Still, this is an edge case. Maybe we can separate it into another proposal.<br></p><p>I think any change in semantics should absolutely be a separate proposal.  I support scope-based access semantics.  My opinion about other access semantics would depend on the details of a specific proposal, but I think there is a very high hurdle to clear for introducing any other access semantics.<br></p><p>&gt; <br>&gt; On Thu, Mar 24, 2016 at 11:42 AM Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This is why I&#39;d like private to mean exactly that (no nested class should get access). Then the meaning is clear: it&#39;s as private as it can be :-)<br>&gt; <br>&gt; Private and public have well defined meaning. We <br>&gt; On Thu, Mar 24, 2016 at 11:33 AM Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for &#39;declaration only&#39;.<br>&gt; <br>&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms. I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br>&gt; <br>&gt; On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; &gt;<br>&gt; &gt;    public<br>&gt; &gt;    moduleprivate<br>&gt; &gt;    fileprivate<br>&gt; &gt;    private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; &gt;<br>&gt; &gt; What do you all think?<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is in the name of the plain &quot;private&quot; keyword.<br>&gt; <br>&gt; You may say private is obvious, but when you have moduleprivate and fileprivate, the natural question I ask is &quot;What remaining kind of private is there?&quot; so private&#39;s obviousness is muddied for me when next to moduleprivate and fileprivate.<br>&gt; <br>&gt; I will say I would prefer these keywords to the proposed parameter keywords. I just think:<br>&gt; <br>&gt; file -&gt; implies file only<br>&gt; module -&gt; implies module only<br>&gt; <br>&gt; where adding private to them only adds noise (I.e. fileprivate and moduleprivate)<br>&gt; <br>&gt; Brandon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/14274ab0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>Perhaps internal is valuable here then?<br>Maybe: public, moduleinternal, fileinternal, private.<br>Or just: public, internal, fileinternal, private.<br>Or, more radically: public, internal, internal(#file), private.<br></p><p>On Thu, Mar 24, 2016 at 10:32 AM Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s<br>&gt; intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for<br>&gt; &#39;declaration only&#39;.<br>&gt;<br>&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms.<br>&gt; I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br>&gt;<br>&gt; On Thu, Mar 24, 2016 at 3:21 PM, Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    public<br>&gt;&gt; &gt;    moduleprivate<br>&gt;&gt; &gt;    fileprivate<br>&gt;&gt; &gt;    private<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What do you all think?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure my wording will be perfect here, but I will try: I still<br>&gt;&gt; believe that private is implied in &quot;module&quot; and &quot;file&quot; and the problem is<br>&gt;&gt; in the name of the plain &quot;private&quot; keyword.<br>&gt;&gt;<br>&gt;&gt; You may say private is obvious, but when you have moduleprivate and<br>&gt;&gt; fileprivate, the natural question I ask is &quot;What remaining kind of private<br>&gt;&gt; is there?&quot; so private&#39;s obviousness is muddied for me when next to<br>&gt;&gt; moduleprivate and fileprivate.<br>&gt;&gt;<br>&gt;&gt; I will say I would prefer these keywords to the proposed parameter<br>&gt;&gt; keywords. I just think:<br>&gt;&gt;<br>&gt;&gt; file -&gt; implies file only<br>&gt;&gt; module -&gt; implies module only<br>&gt;&gt;<br>&gt;&gt; where adding private to them only adds noise (I.e. fileprivate and<br>&gt;&gt; moduleprivate)<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/e771e292/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 24 Mar 2016, at 15:32, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that &#39;private&#39; still feels too subjective on its own. It&#39;s intuitively &#39;not public&#39;; it&#39;s not intuitively the access term for &#39;declaration only&#39;.<br>&gt; <br>&gt; I&#39;m not opposed to fileprivate and moduleprivate, if we like those terms. I&#39;d just prefer a corresponding scopeprivate or declarationprivate.<br></p><p>This is why I like the idea of declaring private(file), private(module) or private(type), as all are a form of privacy as none are available externally, but the parameter clarifies in what way they are limited internally, though private(type) could be the default if no parameter is given.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9db7e0c3d3ce86e2bf80675a61fbc49c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James Berry</string> &lt;jberry at rogueorbit.com&gt;<p>March 24, 2016 at 08:00:00am</p></header><div class="content"><p>Thanks, Chris, for summing up and pulling this back together.<br></p><p>I’m +1 on your suggestion of public, moduleprivate, fileprivate, and private.  I share your feeling of slight awkwardness about the parens in my previous suggestion.<br></p><p>As to other’s expressed concerns about smashedlowerkeywords, they don’t bother me too much. I prefer consistency here. As an alternative I’d find lower_snake_case acceptable, but would like to see it applied consistently, and thus also to associatedtype, etc. I don’t like lowerCamelCase for keywords. But if I had my druthers it would be to maintain the status quo of smashedlower.<br></p><p>James<br></p><p><br>&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; <br>&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt; <br>&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt; <br>&gt; I’ve seen several proposals that seem promising:<br>&gt; <br>&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt; <br>&gt;&gt; 	private			symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; 	private(module)	symbol visible within the current module.<br>&gt;&gt; 	private(file)		symbol visible within the current file.<br>&gt; <br>&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br>&gt; <br>&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; public<br>&gt;&gt; private-module<br>&gt;&gt; private-file<br>&gt;&gt; private<br>&gt; <br>&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt; <br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>March 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Le 24 mars 2016 à 06:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; <br>&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt; <br>&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt; <br>&gt; I’ve seen several proposals that seem promising:<br>&gt; <br>&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt; <br>&gt;&gt; 	private			symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; 	private(module)	symbol visible within the current module.<br>&gt;&gt; 	private(file)		symbol visible within the current file.<br>&gt; <br>&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br>&gt; <br>&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; public<br>&gt;&gt; private-module<br>&gt;&gt; private-file<br>&gt;&gt; private<br>&gt; <br>&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt; <br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Chris<br></p><p><br>I like the way it goes,  but I don’t like the nospacebetweenwords convention. module_private and file_private look better IMHO.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 11:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br></p><p>I support this for all the enumerated reasons. This is clean, simple, and obvious. <br>It retains the benefits and avoids the negatives of the parenthesized versions.<br></p><p>One correction: &quot;googlable&quot; not &quot;googable&quot;, because that&#39;s how pedants roll. <br>(cite: https://en.wikipedia.org/wiki/Muphry%27s_law &lt;https://en.wikipedia.org/wiki/Muphry&#39;s_law&gt;)<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/8442a102/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 1:13 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br></p><p>+1. It also has the advantage of getting rid of the confusing distinction between “private” and “internal”—which is backwards from the usual “API/SPI/IPI” terminology.<br></p><p>-Colin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/67fd47ec/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 01:13, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; What we do with private setters is orthogonal from this proposal, so I’m going to ignore it in this thread.  After SE-0025 is resolved, it would be great to have another thread/proposal that discusses reskinning private(set) - presumably as just a modifier on the setter.<br>&gt; <br>&gt; Similarly, this proposal has nothing to do with “protected” or any other type based access control, so I don’t delve into that at all either.<br>&gt; <br>&gt; I’ve seen several proposals that seem promising:<br>&gt; <br>&gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt;&gt; I like fileprivate, if that’s the only change. On the other hand, if we want to consider a broader change, what about:<br>&gt;&gt; <br>&gt;&gt;    private            symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;    private(module)    symbol visible within the current module.<br>&gt;&gt;    private(file)        symbol visible within the current file.<br>&gt; <br>&gt; I love how this establishes a family with different levels of access control, and unites them under the idea of &quot;levels of being private”.  I also like how people would commonly only ever write public and private (because “private(module)” is the default, and &quot;private(file)&quot; is obscure).  However, parenthesized modifiers that take a keyword (as opposed to an identifier) are a bit weird and awkward, so it would be nice to avoid them if possible.<br></p><p>If we borrow the &quot;drop in&quot; from below of private(foo.bar.baz), then maybe: <br></p><p>private(#module) // expands to current module<br>private(#file) // expands to current file<br></p><p>This is slightly more awkward/one character longer, but now it&#39;s an identifier in parentheses (or something that expands to an identifier). <br></p><p>I&#39;m not sure I like this in practice unless it is fairly rare to actually have to type. If &quot;private&quot; at the top level of a file meant fileprivate (as I suggested in my other reply a few minutes ago) that would significantly reduce the need to type something other than just private.<br></p><p>&gt; <br>&gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; public<br>&gt;&gt; private-module<br>&gt;&gt; private-file<br>&gt;&gt; private<br>&gt; <br>&gt; This follows the same sort of structure as James’ proposal, without the parens.  It has the same advantages, but trades them with hyphenated decl modifiers.  We don’t do that, but it is a good direction.<br>&gt; <br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt;    public<br>&gt;    moduleprivate<br>&gt;    fileprivate<br>&gt;    private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>this is more in line with other naming conventions, but the names in the<br>updated proposal seem to match the closest to everything else in Swift. I<br>waited for about a week to get everyone&#39;s opinion, but I think that we are<br>past the name discussions at this point.<br></p><p>On Sun, Mar 27, 2016 at 11:50 PM Matthew Judge via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; &gt; On Mar 24, 2016, at 01:13, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &lt;responding to several posts in this thread at once&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 14, 2016, at 5:18 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Per Doug’s email, the core team agrees we should make a change here,<br>&gt; but would like some bikeshedding to happen on the replacement name for<br>&gt; private.<br>&gt; &gt;<br>&gt; &gt; What we do with private setters is orthogonal from this proposal, so I’m<br>&gt; going to ignore it in this thread.  After SE-0025 is resolved, it would be<br>&gt; great to have another thread/proposal that discusses reskinning<br>&gt; private(set) - presumably as just a modifier on the setter.<br>&gt; &gt;<br>&gt; &gt; Similarly, this proposal has nothing to do with “protected” or any other<br>&gt; type based access control, so I don’t delve into that at all either.<br>&gt; &gt;<br>&gt; &gt; I’ve seen several proposals that seem promising:<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 14, 2016, at 5:49 PM, James Berry &lt;jberry at rogueorbit.com&gt; wrote:<br>&gt; &gt;&gt; I like fileprivate, if that’s the only change. On the other hand, if we<br>&gt; want to consider a broader change, what about:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    private            symbol visible within the current declaration<br>&gt; (class, extension, etc).<br>&gt; &gt;&gt;    private(module)    symbol visible within the current module.<br>&gt; &gt;&gt;    private(file)        symbol visible within the current file.<br>&gt; &gt;<br>&gt; &gt; I love how this establishes a family with different levels of access<br>&gt; control, and unites them under the idea of &quot;levels of being private”.  I<br>&gt; also like how people would commonly only ever write public and private<br>&gt; (because “private(module)” is the default, and &quot;private(file)&quot; is<br>&gt; obscure).  However, parenthesized modifiers that take a keyword (as opposed<br>&gt; to an identifier) are a bit weird and awkward, so it would be nice to avoid<br>&gt; them if possible.<br>&gt;<br>&gt; If we borrow the &quot;drop in&quot; from below of private(foo.bar.baz), then maybe:<br>&gt;<br>&gt; private(#module) // expands to current module<br>&gt; private(#file) // expands to current file<br>&gt;<br>&gt; This is slightly more awkward/one character longer, but now it&#39;s an<br>&gt; identifier in parentheses (or something that expands to an identifier).<br>&gt;<br>&gt; I&#39;m not sure I like this in practice unless it is fairly rare to actually<br>&gt; have to type. If &quot;private&quot; at the top level of a file meant fileprivate (as<br>&gt; I suggested in my other reply a few minutes ago) that would significantly<br>&gt; reduce the need to type something other than just private.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 15, 2016, at 3:39 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; public<br>&gt; &gt;&gt; private-module<br>&gt; &gt;&gt; private-file<br>&gt; &gt;&gt; private<br>&gt; &gt;<br>&gt; &gt; This follows the same sort of structure as James’ proposal, without the<br>&gt; parens.  It has the same advantages, but trades them with hyphenated decl<br>&gt; modifiers.  We don’t do that, but it is a good direction.<br>&gt; &gt;<br>&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;<br>&gt; &gt;    public<br>&gt; &gt;    moduleprivate<br>&gt; &gt;    fileprivate<br>&gt; &gt;    private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt; &gt;<br>&gt; &gt; What do you all think?<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/d37f800f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 30, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; <br>&gt; 	public<br>&gt; 	moduleprivate<br>&gt; 	fileprivate<br>&gt; 	private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; 4) The unusual ones would be “googable”.<br>&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br></p><p>I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br></p><p>public<br>internal<br>fileprivate<br>private<br></p><p>The advantages, as I see them are:<br>1) We keep public and private meaning the “right” and “obvious” things.<br>2) The declmodifiers “read” correctly.<br>3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br></p><p>Thoughts?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 06:00:00am</p></header><div class="content"><p>Looks good to me.<br></p><p>-Thorsten <br></p><p>&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt;    public<br>&gt;&gt;    moduleprivate<br>&gt;&gt;    fileprivate<br>&gt;&gt;    private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 10:00:00pm</p></header><div class="content"><p>public<br>internal<br>interfile<br>private<br></p><p>still googleable and very clear its scope and meaning, nice latin root. Doesn’t overload “private”, slightly shorter. <br></p><p><br>&gt; On Mar 30, 2016, at 9:46 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Looks good to me.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public<br>&gt;&gt;&gt;   moduleprivate<br>&gt;&gt;&gt;   fileprivate<br>&gt;&gt;&gt;   private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt; <br>&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt;&gt; <br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 30, 2016 at 10:00:00pm</p></header><div class="content"><p>One bonus it is a real word so autocorrect doesn’t fix it! I checked the dictionary and there are no negative or misleading meaning. <br></p><p>It is a verb though, this is not being used as a verb in this case. <br></p><p>http://www.dictionary.com/browse/interfile &lt;http://www.dictionary.com/browse/interfile&gt;<br></p><p>&gt; On Mar 30, 2016, at 10:04 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; interfile<br>&gt; private<br>&gt; <br>&gt; still googleable and very clear its scope and meaning, nice latin root. Doesn’t overload “private”, slightly shorter. <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 9:46 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Looks good to me.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  public<br>&gt;&gt;&gt;&gt;  moduleprivate<br>&gt;&gt;&gt;&gt;  fileprivate<br>&gt;&gt;&gt;&gt;  private<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public<br>&gt;&gt;&gt; internal<br>&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt; private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt;&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt;&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/30cd762d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; public<br>&gt; internal<br>&gt; interfile<br>&gt; private<br></p><p>Linguistically, I really like this direction. &#39;interfile&#39; is one word, it<br>reads as an adjective, it can be used in conversation (this has interfile<br>visibility), and it&#39;s clear about where its visibility ends.<br></p><p>It just doesn&#39;t mean what you think it means.<br></p><p>&#39;inter&#39; means &#39;between&#39;. See: &#39;intergalactic&#39;, &#39;interstellar&#39;,<br>&#39;international&#39;, &#39;internet&#39;. So &#39;interfile&#39; would have to mean &#39;visible<br>between files&#39; - i.e. an interfile symbol in one file is visible in another<br>file. The prefix you&#39;re looking for, meaning &#39;internal&#39;, is &#39;intra&#39; (see:<br>&#39;intravenous&#39;, &#39;intranet&#39;).<br></p><p>So the scale would become:<br></p><p>public / intermodule<br>internal / intramodule / interfile<br>intrafile<br>private<br></p><p><br>On Thu, Mar 31, 2016 at 6:04 AM, Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; public<br>&gt; internal<br>&gt; interfile<br>&gt; private<br>&gt;<br>&gt; still googleable and very clear its scope and meaning, nice latin root.<br>&gt; Doesn’t overload “private”, slightly shorter.<br>&gt;<br>&gt;<br>&gt; &gt; On Mar 30, 2016, at 9:46 PM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Looks good to me.<br>&gt; &gt;<br>&gt; &gt; -Thorsten<br>&gt; &gt;<br>&gt; &gt;&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;   public<br>&gt; &gt;&gt;&gt;   moduleprivate<br>&gt; &gt;&gt;&gt;   fileprivate<br>&gt; &gt;&gt;&gt;   private<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt; &gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and<br>&gt; how it penalizes folks who want to explicitly write their access control.<br>&gt; I’ve come to think that there is yes-another possible path forward here<br>&gt; (which I haven’t seen mentioned so far):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public<br>&gt; &gt;&gt; internal<br>&gt; &gt;&gt; fileprivate<br>&gt; &gt;&gt; private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt;&gt; 4) fileprivate is the unusual and<br>&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt; “googable”.<br>&gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that<br>&gt; several people are concerned with.<br>&gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt; “internal”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/a7b1dc8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>I like :<br></p><p>- public<br>- modulewide or moduleprivate or internal<br>- filewide or fileprivate<br>- private<br></p><p>I really dislike interfile because the word exists and means something else<br>I dislike intermodule, inmodule and infile because I don&#39;t find them intuitive at all.<br></p><p>I prefer the -wide flavors because they&#39;re shorter than the -private flavors, and because -wide is an existing suffix in english.<br>Internal has the advantage of no modification but if we want to change it, now is the time.<br></p><p><br>&gt; Le 31 mars 2016 à 11:10, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &gt; public<br>&gt; &gt; internal<br>&gt; &gt; interfile<br>&gt; &gt; private<br>&gt; <br>&gt; Linguistically, I really like this direction. &#39;interfile&#39; is one word, it reads as an adjective, it can be used in conversation (this has interfile visibility), and it&#39;s clear about where its visibility ends.<br>&gt; <br>&gt; It just doesn&#39;t mean what you think it means.<br>&gt; <br>&gt; &#39;inter&#39; means &#39;between&#39;. See: &#39;intergalactic&#39;, &#39;interstellar&#39;, &#39;international&#39;, &#39;internet&#39;. So &#39;interfile&#39; would have to mean &#39;visible between files&#39; - i.e. an interfile symbol in one file is visible in another file. The prefix you&#39;re looking for, meaning &#39;internal&#39;, is &#39;intra&#39; (see: &#39;intravenous&#39;, &#39;intranet&#39;).<br>&gt; <br>&gt; So the scale would become:<br>&gt; <br>&gt; public / intermodule<br>&gt; internal / intramodule / interfile<br>&gt; intrafile<br>&gt; private<br>&gt; <br>&gt; <br>&gt; On Thu, Mar 31, 2016 at 6:04 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; public<br>&gt; internal<br>&gt; interfile<br>&gt; private<br>&gt; <br>&gt; still googleable and very clear its scope and meaning, nice latin root. Doesn’t overload “private”, slightly shorter.<br>&gt; <br>&gt; <br>&gt; &gt; On Mar 30, 2016, at 9:46 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Looks good to me.<br>&gt; &gt;<br>&gt; &gt; -Thorsten<br>&gt; &gt;<br>&gt; &gt;&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;   public<br>&gt; &gt;&gt;&gt;   moduleprivate<br>&gt; &gt;&gt;&gt;   fileprivate<br>&gt; &gt;&gt;&gt;   private<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; &gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt; &gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public<br>&gt; &gt;&gt; internal<br>&gt; &gt;&gt; fileprivate<br>&gt; &gt;&gt; private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/4ccfcd7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>What about private, fileonly, moduleonly, public ?<br></p><p>*___________________________________*<br></p><p>*James⎥Future Prime Minister*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Thu, Mar 31, 2016 at 1:24 PM, Pierre Monod-Broca via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like :<br>&gt;<br>&gt; - public<br>&gt; - modulewide or moduleprivate or internal<br>&gt; - filewide or fileprivate<br>&gt; - private<br>&gt;<br>&gt; I really dislike interfile because the word exists and means something else<br>&gt; I dislike intermodule, inmodule and infile because I don&#39;t find them<br>&gt; intuitive at all.<br>&gt;<br>&gt; I prefer the -wide flavors because they&#39;re shorter than the -private<br>&gt; flavors, and because -wide is an existing suffix in english.<br>&gt; Internal has the advantage of no modification but if we want to change it,<br>&gt; now is the time.<br>&gt;<br>&gt;<br>&gt; Le 31 mars 2016 à 11:10, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; &gt; public<br>&gt; &gt; internal<br>&gt; &gt; interfile<br>&gt; &gt; private<br>&gt;<br>&gt; Linguistically, I really like this direction. &#39;interfile&#39; is one word, it<br>&gt; reads as an adjective, it can be used in conversation (this has interfile<br>&gt; visibility), and it&#39;s clear about where its visibility ends.<br>&gt;<br>&gt; It just doesn&#39;t mean what you think it means.<br>&gt;<br>&gt; &#39;inter&#39; means &#39;between&#39;. See: &#39;intergalactic&#39;, &#39;interstellar&#39;,<br>&gt; &#39;international&#39;, &#39;internet&#39;. So &#39;interfile&#39; would have to mean &#39;visible<br>&gt; between files&#39; - i.e. an interfile symbol in one file is visible in another<br>&gt; file. The prefix you&#39;re looking for, meaning &#39;internal&#39;, is &#39;intra&#39; (see:<br>&gt; &#39;intravenous&#39;, &#39;intranet&#39;).<br>&gt;<br>&gt; So the scale would become:<br>&gt;<br>&gt; public / intermodule<br>&gt; internal / intramodule / interfile<br>&gt; intrafile<br>&gt; private<br>&gt;<br>&gt;<br>&gt; On Thu, Mar 31, 2016 at 6:04 AM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; interfile<br>&gt;&gt; private<br>&gt;&gt;<br>&gt;&gt; still googleable and very clear its scope and meaning, nice latin root.<br>&gt;&gt; Doesn’t overload “private”, slightly shorter.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 30, 2016, at 9:46 PM, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Looks good to me.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Thorsten<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;   public<br>&gt;&gt; &gt;&gt;&gt;   moduleprivate<br>&gt;&gt; &gt;&gt;&gt;   fileprivate<br>&gt;&gt; &gt;&gt;&gt;   private<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; &gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious”<br>&gt;&gt; things.<br>&gt;&gt; &gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt; &gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; &gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and<br>&gt;&gt; how it penalizes folks who want to explicitly write their access control.<br>&gt;&gt; I’ve come to think that there is yes-another possible path forward here<br>&gt;&gt; (which I haven’t seen mentioned so far):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; public<br>&gt;&gt; &gt;&gt; internal<br>&gt;&gt; &gt;&gt; fileprivate<br>&gt;&gt; &gt;&gt; private<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The advantages, as I see them are:<br>&gt;&gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing<br>&gt;&gt; that changes is that some uses of Swift 2 “private” will be migrated to<br>&gt;&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; &gt;&gt; 4) fileprivate is the unusual and<br>&gt;&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt;&gt; “googable”.<br>&gt;&gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that<br>&gt;&gt; several people are concerned with.<br>&gt;&gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by<br>&gt;&gt; parameterizing “internal”.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Thoughts?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Chris<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/e9f9aa83/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 31, 2016 at 07:00:00am</p></header><div class="content"><p>Yep good point Ross. Should have double checked that.(I think it is because kids in school kept saying intermural instead of intramural You would think the latin I took would have broken me of that. :-). <br></p><p>I think all of the proposals below are clear and I like any of them except 3, too long. The parenthesized ones are if we want consistency between the middle two scopes.  <br></p><p>So, proposal one (and 1b), more technical sounding<br></p><p>public<br>internal (or intramodule)<br>intrafile<br>private<br></p><p>Proposal two infile (and 2b). Shortest, eye pleasing, non technical sounding <br></p><p>public<br>internal (or inmodule) <br>infile<br>private<br></p><p>Proposal three: (and 3b) longest names, multiword. reusing private, unpleasing compound words.. <br></p><p>public <br>internal (or moduleprivate)<br>fileprivate<br>private<br></p><p>proposal four: (and 4b):kind of needs the 4b form, to show pattern (I think)<br></p><p>private<br>internal (modulewide)<br>filewide<br>private<br></p><p>proposal five (and 5b) short eye pleasing. <br></p><p>private<br>internal (moduleonly)<br>fileonly<br>private<br></p><p><br>&gt; On Mar 31, 2016, at 2:10 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; public<br>&gt; &gt; internal<br>&gt; &gt; interfile<br>&gt; &gt; private<br>&gt; <br>&gt; Linguistically, I really like this direction. &#39;interfile&#39; is one word, it reads as an adjective, it can be used in conversation (this has interfile visibility), and it&#39;s clear about where its visibility ends.<br>&gt; <br>&gt; It just doesn&#39;t mean what you think it means.<br>&gt; <br>&gt; &#39;inter&#39; means &#39;between&#39;. See: &#39;intergalactic&#39;, &#39;interstellar&#39;, &#39;international&#39;, &#39;internet&#39;. So &#39;interfile&#39; would have to mean &#39;visible between files&#39; - i.e. an interfile symbol in one file is visible in another file. The prefix you&#39;re looking for, meaning &#39;internal&#39;, is &#39;intra&#39; (see: &#39;intravenous&#39;, &#39;intranet&#39;).<br>&gt; <br>&gt; So the scale would become:<br>&gt; <br>&gt; public / intermodule<br>&gt; internal / intramodule / interfile<br>&gt; intrafile<br>&gt; private<br>&gt; <br>&gt; <br>&gt; On Thu, Mar 31, 2016 at 6:04 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; public<br>&gt; internal<br>&gt; interfile<br>&gt; private<br>&gt; <br>&gt; still googleable and very clear its scope and meaning, nice latin root. Doesn’t overload “private”, slightly shorter.<br>&gt; <br>&gt; <br>&gt; &gt; On Mar 30, 2016, at 9:46 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Looks good to me.<br>&gt; &gt;<br>&gt; &gt; -Thorsten<br>&gt; &gt;<br>&gt; &gt;&gt; Am 31.03.2016 um 06:22 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;   public<br>&gt; &gt;&gt;&gt;   moduleprivate<br>&gt; &gt;&gt;&gt;   fileprivate<br>&gt; &gt;&gt;&gt;   private<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt; &gt;&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt; &gt;&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public<br>&gt; &gt;&gt; internal<br>&gt; &gt;&gt; fileprivate<br>&gt; &gt;&gt; private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/144a388a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>March 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; So, proposal one (and 1b), more technical sounding<br>&gt; <br>&gt; public<br>&gt; internal (or intramodule)<br>&gt; intrafile<br>&gt; private<br>`intrafile` and `intramodule` sound esoteric to me.<br></p><p>I like these ones better:<br></p><p>public<br>moduleonly<br>fileonly<br>private//aka, scopeonly? unfortunate that this isn’t automatically clear <br></p><p><br></p><p>Tino’s suggestion is also interesting:<br></p><p>visible(public)<br>visible(module)<br>visible(file)<br>visible(scope)<br>visible(file, ModuleA, File.swift)<br></p><p>But I think the paren syntax suggested earlier is equivalent, and would be the clearest to both experienced and beginning developers:<br></p><p>public<br>private(module)<br>private(file)<br>private(scope)<br></p><p>If parens are a no-go, perhaps the following could work:<br></p><p>public<br>privatetomodule<br>privatetofile<br>privatetoscope<br></p><p>I’m not a huge fan of `fileprivate` or `moduleprivate`, because they seem like strange non-words.<br></p><p>-Matt<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/c45a29d6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/428f8fdcf0f70e585363d23a6ec2121d?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Jesse Squires</string> &lt;jesse.d.squires at gmail.com&gt;<p>March 30, 2016 at 11:00:00pm</p></header><div class="content"><p>I really like this. +1 for the following:<br></p><p>public<br>internal<br>fileprivate<br>private<br></p><p>-Jesse<br></p><p>On Wed, Mar 30, 2016 at 9:22 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;<br>&gt; &gt;       public<br>&gt; &gt;       moduleprivate<br>&gt; &gt;       fileprivate<br>&gt; &gt;       private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt;<br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt; come to think that there is yes-another possible path forward here (which I<br>&gt; haven’t seen mentioned so far):<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and<br>&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt; “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several<br>&gt; people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt; “internal”.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Jesse Squires<br></p><p>*blog* | jessesquires.com &lt;http://www.jessesquires.com&gt;<br>*github* | github.com/jessesquires &lt;http://www.github.com/jessesquires&gt;<br>*hexedbits* | hexedbits.com &lt;http://www.hexedbits.com&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/f3bf443c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>public<br>internal<br>(fileprivate | interfile)<br>private<br></p><p>Either choice is fine with me<br></p><p>On Thu, Mar 31, 2016 at 11:33 AM, Jesse Squires via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I really like this. +1 for the following:<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; -Jesse<br>&gt;<br>&gt; On Wed, Mar 30, 2016 at 9:22 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public<br>&gt;&gt; &gt;       moduleprivate<br>&gt;&gt; &gt;       fileprivate<br>&gt;&gt; &gt;       private<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;<br>&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt;&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt;&gt; come to think that there is yes-another possible path forward here (which I<br>&gt;&gt; haven’t seen mentioned so far):<br>&gt;&gt;<br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt;&gt;<br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt;&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt;&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; 4) fileprivate is the unusual and<br>&gt;&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt;&gt; “googable”.<br>&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several<br>&gt;&gt; people are concerned with.<br>&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt;&gt; “internal”.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Jesse Squires<br>&gt;<br>&gt; *blog* | jessesquires.com &lt;http://www.jessesquires.com&gt;<br>&gt; *github* | github.com/jessesquires &lt;http://www.github.com/jessesquires&gt;<br>&gt; *hexedbits* | hexedbits.com &lt;http://www.hexedbits.com&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/e444a069/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>Perhaps it&#39;s because I&#39;m not a native English speaker, but interfile doesn&#39;t read well at all to me whereas fileprivate is crystal-clear.<br></p><p>&gt; On 31 Mar 2016, at 08:21, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; (fileprivate | interfile)<br>&gt; private<br>&gt; <br>&gt; Either choice is fine with me<br>&gt; <br>&gt;&gt; On Thu, Mar 31, 2016 at 11:33 AM, Jesse Squires via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I really like this. +1 for the following:<br>&gt;&gt; <br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt;&gt; <br>&gt;&gt; -Jesse<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Mar 30, 2016 at 9:22 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       public<br>&gt;&gt;&gt; &gt;       moduleprivate<br>&gt;&gt;&gt; &gt;       fileprivate<br>&gt;&gt;&gt; &gt;       private<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public<br>&gt;&gt;&gt; internal<br>&gt;&gt;&gt; fileprivate<br>&gt;&gt;&gt; private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The advantages, as I see them are:<br>&gt;&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt;&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt;&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Jesse Squires<br>&gt;&gt; <br>&gt;&gt; blog | jessesquires.com<br>&gt;&gt; github | github.com/jessesquires<br>&gt;&gt; hexedbits | hexedbits.com<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/2bbdc93a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>I love those. And internal corresponds to the meaning it has in other languages.<br></p><p>+1<br></p><p>&gt; On 31 Mar 2016, at 06:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt;    public<br>&gt;&gt;    moduleprivate<br>&gt;&gt;    fileprivate<br>&gt;&gt;    private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March 31, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 31 Mar 2016, at 07:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br></p><p>+1, I like it.<br></p><p>There&#39;s one source of confusion though: at file scope, `private` would have the same meaning as `fileprivate`.<br></p><p>// At file scope, these keywords are synonymous unless we specify otherwise:<br>private let someConstant = &quot;foo&quot;<br>fileprivate let anotherConstant = &quot;bar&quot;<br></p><p>That can be seen in positive light too—the shorter keyword is tempting—, but wouldn&#39;t it make things clearer if `private` was only allowed inside data types?<br></p><p>Then, file-wide constants, helper functions, and types would then all be at least `fileprivate`, and never `private`. I think that would best document their intent. Maybe just a warning with a fixit to use `fileprivate` would be enough.<br></p><p>— Pyry Jahkola<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/fe6ebd04/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 31, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br></p><p>I don&#39;t like how this ends up penalizing `fileprivate` with an ugly compound keyword. I feel like, with the way I tend to factor my code, I would continue using it reasonably often, and it would suck to have to use an ugly keyword.<br></p><p>Consider some of the places where we&#39;re still going to need `fileprivate`:<br></p><p>* Members used by operators or other free functions.<br>* Members of nested types meant to be used only by the containing type.<br>* Code which splits a type up into extensions. (We want to encourage this.)<br>* Code which pairs a type with an extension adding an API using that type to another type. (We want to encourage this too.)<br></p><p>These are all things we want to encourage, and things where just making them `internal` is going to be tempting. Access control is a delicate thing; using tight access control imposes obvious short-term costs for subtle long-term gains, and so you&#39;re always tempted to cheat by making things broader than they should be for your own convenience. The only thing keeping you from cheating is your own discipline.<br></p><p>I worry that, if `fileprivate` is a long, ugly, obscure, and cumbersome keyword, and `internal` works just as well but requires no typing at all, a lot of people are going to do the wrong thing. We don&#39;t want that to happen.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 31, 2016 at 01:00:00am</p></header><div class="content"><p>If not interfile I can suggest infile again too.<br></p><p>&gt; On Mar 31, 2016, at 12:38 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt;&gt; <br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt; <br>&gt; I don&#39;t like how this ends up penalizing `fileprivate` with an ugly compound keyword. I feel like, with the way I tend to factor my code, I would continue using it reasonably often, and it would suck to have to use an ugly keyword.<br>&gt; <br>&gt; Consider some of the places where we&#39;re still going to need `fileprivate`:<br>&gt; <br>&gt; * Members used by operators or other free functions.<br>&gt; * Members of nested types meant to be used only by the containing type.<br>&gt; * Code which splits a type up into extensions. (We want to encourage this.)<br>&gt; * Code which pairs a type with an extension adding an API using that type to another type. (We want to encourage this too.)<br>&gt; <br>&gt; These are all things we want to encourage, and things where just making them `internal` is going to be tempting. Access control is a delicate thing; using tight access control imposes obvious short-term costs for subtle long-term gains, and so you&#39;re always tempted to cheat by making things broader than they should be for your own convenience. The only thing keeping you from cheating is your own discipline.<br>&gt; <br>&gt; I worry that, if `fileprivate` is a long, ugly, obscure, and cumbersome keyword, and `internal` works just as well but requires no typing at all, a lot of people are going to do the wrong thing. We don&#39;t want that to happen.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>I&#39;ve seen this argument numerous times, and fear that &quot;googleability&quot; receives more attention than it deserves:<br>It&#39;s ok to take it into account when choosing between alternatives that are on par with each other, but we have great documentation to look for the meaning of special words.<br>It would be a pity if a more expressive term is discarded just because another one is more unique (that does not only apply to this thread — the argument has come up before)<br></p><p>&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>I still don&#39;t like the idea of parameterizing some levels while keeping others in a single form — but parameterizing everything would look better to me:<br></p><p>visible(public)<br>visible(module)<br>visible(file)<br>visible(scope)<br>visible(file, ModuleA, File.swift)<br></p><p>I think one benefit of this scheme is that there is no ambiguity with &quot;privat&quot; and its meaning in other languages.<br></p><p>Tino<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>March 31, 2016 at 09:00:00am</p></header><div class="content"><p>Or maybe we could just abolish of file-private. It&#39;s not like it&#39;d be 100% gone: private declarations at the root of a file will always be equivalent to file-private. For non-root things that need to be accessible within the file you can use `internal`, which is more accessible than before but still bounded to the current module.<br></p><p><br>&gt; Le 31 mars 2016 à 0:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt; 	public<br>&gt;&gt; 	moduleprivate<br>&gt;&gt; 	fileprivate<br>&gt;&gt; 	private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 30 mars 2016, at 22:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br></p><p>Yes. I see no need to get rid of “internal”.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;d be okay with this, but I do think having a private and fileprivate will confuse people considering they both have private in their names<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On Mar 31, 2016, at 12:22 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; How about we continue this trend, and follow other existing Swift keywords that merge two lowercase words (associatedtype, typealias, etc), and use:<br>&gt;&gt; <br>&gt;&gt;    public<br>&gt;&gt;    moduleprivate<br>&gt;&gt;    fileprivate<br>&gt;&gt;    private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the awkward parenthesized keyword approach.<br>&gt;&gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; 5) Support for named submodules could be “dropped in” by putting the submodule name/path in parens: private(foo.bar.baz) or moduleprivate(foo.bar).  Putting an identifier in the parens is much more natural than putting keywords in parens.<br>&gt; <br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>April  1, 2016 at 01:00:00am</p></header><div class="content"><p>I have to say, I&#39;m not very happy with the progress of this topic ..<br>Let me explain:<br>I&#39;m Swift user from day 1. A few weeks after, even with the limitations of<br>language, had an application in production.<br></p><p>One of the &quot;cool&quot; features that regularly use in my application is the<br>&quot;file private&quot; access level. Is very better (in practice) than C++<br>friendly, and enable a lot of different manners to think in our code design.<br></p><p>For example: I have a &quot;hand shake&quot; file, wen two specific types extension<br>knows about specift (and private) functions to do this &quot;hand shake&quot;.<br></p><p>So, my problem is, after almost two years using Swift, &quot;public&quot;, &quot;internal&quot;<br>and &quot;private&quot; is just &quot;so obvious&quot; and very easy to understand, change the<br>&quot;old&quot; private to something else is not very good.<br></p><p>I can understand the need to &quot;more private&quot; than current private, but who<br>need this feature?<br>* devs which do not want declare this &quot;important&quot; type in a different file.<br>* devs which want to declare more than one type per file to make some &quot;<br>*friendly*&quot; relationship, but not share some other specific information.<br>* devs which want to declare more than one type per file and *not* make any<br>relationship with these types different than public.<br></p><p>Also, I&#39;m not expert, but the actual swift access control appear to enable<br>some good compiler optimizations, and works very well with top level<br>objects.<br></p><p>So my proposal is:<br></p><p>- *public* (do not change)<br>- *internal* (do not change)<br>- *private* (do not change)<br>- *protect* (new)<br></p><p>Why protect?<br></p><p>*First*, I believe that is a good word to identify a property that will be<br>accessed in a specific scope.<br>*Second*, it will only be used when the person declaring more than one type<br>in a single file and does not want to share any specific property. I think<br>this person opt to share the same file for more than one type, the &quot;scope&quot;<br>access control will be less used than current private (file based) because<br>a think there less &quot;super private&quot; properties between between those types<br>for the rest of the module.<br>*Third*, although I believe that Swift not need (and will not get) access<br>control only to subtypes, simply update this &quot;protect&quot; is enough (task for<br>another proposal). And even if the protect switch to &quot;also&quot; share<br>properties between subtypes, only those who want to put all subtypes in the<br>same file will lose.<br></p><p>Is impossible to make everyone happy anyway... And i think is good choose<br>the path which &quot;extends&quot; the rationale of the Swift access control over<br>these two years instead say &quot;file based access control is now not so<br>important&quot;.<br></p><p><br></p><p>Em qui, 31 de mar de 2016 às 01:22, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;<br>&gt; &gt;       public<br>&gt; &gt;       moduleprivate<br>&gt; &gt;       fileprivate<br>&gt; &gt;       private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt;<br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt; come to think that there is yes-another possible path forward here (which I<br>&gt; haven’t seen mentioned so far):<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and<br>&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt; “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several<br>&gt; people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt; “internal”.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/5d8f14c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>April  1, 2016 at 03:00:00am</p></header><div class="content"><p>private means something different in OOP. Providing scoped access level and<br>calling it something other than private is good for backward compatibility,<br>but is not good for many people coming from other languages and who are<br>used to the OOP terminology (they would expect &quot;scoped&quot; to be &quot;private&quot;.)<br></p><p>protected also means something different in OOP.<br></p><p>On Thu, Mar 31, 2016 at 9:54 PM Wallacy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I have to say, I&#39;m not very happy with the progress of this topic ..<br>&gt; Let me explain:<br>&gt; I&#39;m Swift user from day 1. A few weeks after, even with the limitations of<br>&gt; language, had an application in production.<br>&gt;<br>&gt; One of the &quot;cool&quot; features that regularly use in my application is the<br>&gt; &quot;file private&quot; access level. Is very better (in practice) than C++<br>&gt; friendly, and enable a lot of different manners to think in our code design.<br>&gt;<br>&gt; For example: I have a &quot;hand shake&quot; file, wen two specific types extension<br>&gt; knows about specift (and private) functions to do this &quot;hand shake&quot;.<br>&gt;<br>&gt; So, my problem is, after almost two years using Swift, &quot;public&quot;,<br>&gt; &quot;internal&quot; and &quot;private&quot; is just &quot;so obvious&quot; and very easy to understand,<br>&gt; change the &quot;old&quot; private to something else is not very good.<br>&gt;<br>&gt; I can understand the need to &quot;more private&quot; than current private, but who<br>&gt; need this feature?<br>&gt; * devs which do not want declare this &quot;important&quot; type in a different file.<br>&gt; * devs which want to declare more than one type per file to make some &quot;<br>&gt; *friendly*&quot; relationship, but not share some other specific information.<br>&gt; * devs which want to declare more than one type per file and *not* make<br>&gt; any relationship with these types different than public.<br>&gt;<br>&gt; Also, I&#39;m not expert, but the actual swift access control appear to enable<br>&gt; some good compiler optimizations, and works very well with top level<br>&gt; objects.<br>&gt;<br>&gt; So my proposal is:<br>&gt;<br>&gt; - *public* (do not change)<br>&gt; - *internal* (do not change)<br>&gt; - *private* (do not change)<br>&gt; - *protect* (new)<br>&gt;<br>&gt; Why protect?<br>&gt;<br>&gt; *First*, I believe that is a good word to identify a property that will<br>&gt; be accessed in a specific scope.<br>&gt; *Second*, it will only be used when the person declaring more than one<br>&gt; type in a single file and does not want to share any specific property. I<br>&gt; think this person opt to share the same file for more than one type, the<br>&gt; &quot;scope&quot; access control will be less used than current private (file based)<br>&gt; because a think there less &quot;super private&quot; properties between between those<br>&gt; types for the rest of the module.<br>&gt; *Third*, although I believe that Swift not need (and will not get) access<br>&gt; control only to subtypes, simply update this &quot;protect&quot; is enough (task for<br>&gt; another proposal). And even if the protect switch to &quot;also&quot; share<br>&gt; properties between subtypes, only those who want to put all subtypes in the<br>&gt; same file will lose.<br>&gt;<br>&gt; Is impossible to make everyone happy anyway... And i think is good choose<br>&gt; the path which &quot;extends&quot; the rationale of the Swift access control over<br>&gt; these two years instead say &quot;file based access control is now not so<br>&gt; important&quot;.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Em qui, 31 de mar de 2016 às 01:22, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; escreveu:<br>&gt;<br>&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public<br>&gt;&gt; &gt;       moduleprivate<br>&gt;&gt; &gt;       fileprivate<br>&gt;&gt; &gt;       private<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;<br>&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt;&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt;&gt; come to think that there is yes-another possible path forward here (which I<br>&gt;&gt; haven’t seen mentioned so far):<br>&gt;&gt;<br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt;&gt;<br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt;&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt;&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; 4) fileprivate is the unusual and<br>&gt;&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt;&gt; “googable”.<br>&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several<br>&gt;&gt; people are concerned with.<br>&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt;&gt; “internal”.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/41477a96/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>April  1, 2016 at 04:00:00am</p></header><div class="content"><p>With these names we lose consistency. The current scheme makes it very<br>clear that each next level is a subset of the previous level. With<br>&quot;internal&quot;, fileprivate looks out of place.<br></p><p>We have several goals for all the names:<br>1) obvious<br>2) using standard terms<br>3) short<br>4) consistent<br></p><p>This discussion shows that we cannot have all of them. We have to pick<br>something at the expense of something else.<br></p><p>For me, the order of importance is 2, 4, 1, 3, and I am pretty sure that<br>with this order<br></p><p>public<br>moduleprivate<br>fileprivate<br>private<br></p><p>is the best so far.<br></p><p>public<br>internal<br>fileprivate<br>private<br></p><p>is not as consistent. It&#39;s also not as obvious, given that many people<br>proposed to use internal to mean fileprivate. The biggest advantages of<br>these names are that there is less change and short words. If these are the<br>most important goals, then my original proposal is even better:<br></p><p>public<br>internal<br>private<br>scoped<br></p><p>It&#39;s a non-breaking change, everything retains its meaning, the added name<br>is very clear, and all the names are very short. The biggest problem here<br>is &quot;private&quot; -- it&#39;s not the most private that the language provides, and<br>most people would expect that.<br></p><p>Here is another one like that (it solves the &quot;private&quot; problem at the<br>expense of using non-standard terms):<br></p><p>public<br>internal<br>local<br>scoped<br></p><p>My main point is that we cannot have everything. We have to pick the order<br>of importance.<br></p><p>We heard many times that &quot;short&quot; is not the goal of Swift. Instead, it&#39;s<br>clarity. If this is the case, then I think<br></p><p>public<br>moduleprivate<br>fileprivate<br>private<br></p><p>is the clearest we&#39;ve seen. Nobody could possibly be confused about the<br>meaning of these names. I doubt that moduleprivate will be required to<br>spell out in any style guide, but even so, it&#39;s not so bad. We have many<br>frequently used class names that are much longer.<br></p><p>On Thu, Mar 31, 2016 at 12:22 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt; and use:<br>&gt; &gt;<br>&gt; &gt;       public<br>&gt; &gt;       moduleprivate<br>&gt; &gt;       fileprivate<br>&gt; &gt;       private<br>&gt; &gt;<br>&gt; &gt; The advantages, as I see them are:<br>&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt; awkward parenthesized keyword approach.<br>&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt; natural than putting keywords in parens.<br>&gt;<br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt; come to think that there is yes-another possible path forward here (which I<br>&gt; haven’t seen mentioned so far):<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and<br>&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt; “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several<br>&gt; people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt; “internal”.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/114092c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>April  1, 2016 at 08:00:00pm</p></header><div class="content"><p>Em sex, 1 de abr de 2016 às 01:31, Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; With these names we lose consistency. The current scheme makes it very<br>&gt; clear that each next level is a subset of the previous level. With<br>&gt; &quot;internal&quot;, fileprivate looks out of place.<br>&gt;<br>&gt; We have several goals for all the names:<br>&gt; 1) obvious<br>&gt; 2) using standard terms<br>&gt; 3) short<br>&gt; 4) consistent<br>&gt;<br>&gt; This discussion shows that we cannot have all of them. We have to pick<br>&gt; something at the expense of something else.<br>&gt;<br>&gt; For me, the order of importance is 2, 4, 1, 3, and I am pretty sure that<br>&gt; with this order<br>&gt;<br>&gt; public<br>&gt; moduleprivate<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; is the best so far.<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; is not as consistent. It&#39;s also not as obvious, given that many people<br>&gt; proposed to use internal to mean fileprivate. The biggest advantages of<br>&gt; these names are that there is less change and short words. If these are the<br>&gt; most important goals, then my original proposal is even better:<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; private<br>&gt; scoped<br>&gt;<br>&gt;<br>For me this is good, keep  untouched the actual public/internal/private and<br>just add a new word for the new access level.<br></p><p>It&#39;s a non-breaking change, everything retains its meaning, the added name<br>&gt; is very clear, and all the names are very short. The biggest problem here<br>&gt; is &quot;private&quot; -- it&#39;s not the most private that the language provides, and<br>&gt; most people would expect that.<br>&gt;<br>&gt; Here is another one like that (it solves the &quot;private&quot; problem at the<br>&gt; expense of using non-standard terms):<br>&gt;<br>&gt; public<br>&gt; internal<br>&gt; local<br>&gt; scoped<br>&gt;<br>&gt; My main point is that we cannot have everything. We have to pick the order<br>&gt; of importance.<br>&gt;<br>&gt; We heard many times that &quot;short&quot; is not the goal of Swift. Instead, it&#39;s<br>&gt; clarity. If this is the case, then I think<br>&gt;<br>&gt; public<br>&gt; moduleprivate<br>&gt; fileprivate<br>&gt; private<br>&gt;<br>&gt; is the clearest we&#39;ve seen. Nobody could possibly be confused about the<br>&gt; meaning of these names. I doubt that moduleprivate will be required to<br>&gt; spell out in any style guide, but even so, it&#39;s not so bad. We have many<br>&gt; frequently used class names that are much longer.<br>&gt;<br>&gt; On Thu, Mar 31, 2016 at 12:22 AM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Mar 23, 2016, at 10:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt; How about we continue this trend, and follow other existing Swift<br>&gt;&gt; keywords that merge two lowercase words (associatedtype, typealias, etc),<br>&gt;&gt; and use:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public<br>&gt;&gt; &gt;       moduleprivate<br>&gt;&gt; &gt;       fileprivate<br>&gt;&gt; &gt;       private<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantages, as I see them are:<br>&gt;&gt; &gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; &gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt; 3) The unusual ones (moduleprivate and fileprivate) don’t use the<br>&gt;&gt; awkward parenthesized keyword approach.<br>&gt;&gt; &gt; 4) The unusual ones would be “googable”.<br>&gt;&gt; &gt; 5) Support for named submodules could be “dropped in” by putting the<br>&gt;&gt; submodule name/path in parens: private(foo.bar.baz) or<br>&gt;&gt; moduleprivate(foo.bar).  Putting an identifier in the parens is much more<br>&gt;&gt; natural than putting keywords in parens.<br>&gt;&gt;<br>&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt;&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt;&gt; come to think that there is yes-another possible path forward here (which I<br>&gt;&gt; haven’t seen mentioned so far):<br>&gt;&gt;<br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt;&gt;<br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt;&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt;&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; 4) fileprivate is the unusual and<br>&gt;&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt;&gt; “googable”.<br>&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several<br>&gt;&gt; people are concerned with.<br>&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt;&gt; “internal”.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/9aeb3a21/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>April  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br>&gt; <br>&gt; The advantages, as I see them are:<br>&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; 2) The declmodifiers “read” correctly.<br>&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; <br>&gt; Thoughts?<br></p><p>+1<br></p><p>Following on from my experience with Delphi adding &quot;strict private&quot; for &quot;OO private&quot; members of classes, I would totally agree with your proposition.<br></p><p>Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to those of us who were brought up on the OO concept of private, and having &quot;private&quot; mean file scope simply encouraged very bad, large, files with lots of classes; especially for those who were new to programming.<br></p><p>This proposal means that folks coming from other OO languages will instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br></p><p>To my mind, the only extra scope that might be useful is the OO concept of &quot;protected&quot; on a class, but I would like to see a discussion purely centred on the effect of more protocols and less class inheritance, with its attendant impact on whether protected could also suit extending (otherwise private) scope to extensions.<br></p><p>In recent experiments of adapting the GOF Design Patterns to Swift, I have found using protocols and extensions to greatly reduce the need for class inheritance, if not removing the need for classes at all in favour of structs.<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  1, 2016 at 09:00:00am</p></header><div class="content"><p>I know this is kind of winding down, and there seems to be a kind of begrudging acceptance of “fileprivate” emerging (perhaps due to fatigue), but I still really don’t like it so I’m going to toss out my current favorite configuration and try to stop caring and defer to the core team to make an executive decision so we can all move on with our lives. :P<br></p><p>public - unchanged, visible “everywhere&quot;<br>external - visible outside of the file (module, the default)<br>internal - visible only within the file<br>private - visible only within the scope<br></p><p>I really like the existing private and I use it a lot to build collections of small classes and structs that work together rather than a large class/struct that tries to “be everything”. In those scenarios, traditional OO private would be too restrictive and even a “protected” access type wouldn’t work because I’m trying to avoid building inheritance hierarchies. I really need something like “friend” (ugly) or the, imo, much more elegant file-scoped access and if that one is renamed “fileprivate” I’ll be really sad seeing such an ugly label all over the place. I’d go so far as to suggest that an ugly name for this access level would actively discourage its use and while some might have that as a goal, to me that would encourage the creation of larger “do everything” classes instead of clusters of smaller classes and structs and protocols.<br></p><p>l8r<br>Sean<br></p><p>&gt; On Apr 1, 2016, at 7:17 AM, Joanna Carter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt;&gt; <br>&gt;&gt; public<br>&gt;&gt; internal<br>&gt;&gt; fileprivate<br>&gt;&gt; private<br>&gt;&gt; <br>&gt;&gt; The advantages, as I see them are:<br>&gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; Following on from my experience with Delphi adding &quot;strict private&quot; for &quot;OO private&quot; members of classes, I would totally agree with your proposition.<br>&gt; <br>&gt; Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to those of us who were brought up on the OO concept of private, and having &quot;private&quot; mean file scope simply encouraged very bad, large, files with lots of classes; especially for those who were new to programming.<br>&gt; <br>&gt; This proposal means that folks coming from other OO languages will instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br>&gt; <br>&gt; To my mind, the only extra scope that might be useful is the OO concept of &quot;protected&quot; on a class, but I would like to see a discussion purely centred on the effect of more protocols and less class inheritance, with its attendant impact on whether protected could also suit extending (otherwise private) scope to extensions.<br>&gt; <br>&gt; In recent experiments of adapting the GOF Design Patterns to Swift, I have found using protocols and extensions to greatly reduce the need for class inheritance, if not removing the need for classes at all in favour of structs.<br>&gt; <br>&gt; Joanna<br>&gt; <br>&gt; --<br>&gt; Joanna Carter<br>&gt; Carter Consulting<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  1, 2016 at 03:00:00pm</p></header><div class="content"><p>A new type is implicitly internal to a module. Implicitly specifying it as<br>&#39;external&#39; is just plain confusing.<br></p><p>On Fri, Apr 1, 2016 at 3:01 PM, Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I know this is kind of winding down, and there seems to be a kind of<br>&gt; begrudging acceptance of “fileprivate” emerging (perhaps due to fatigue),<br>&gt; but I still really don’t like it so I’m going to toss out my current<br>&gt; favorite configuration and try to stop caring and defer to the core team to<br>&gt; make an executive decision so we can all move on with our lives. :P<br>&gt;<br>&gt; public - unchanged, visible “everywhere&quot;<br>&gt; external - visible outside of the file (module, the default)<br>&gt; internal - visible only within the file<br>&gt; private - visible only within the scope<br>&gt;<br>&gt; I really like the existing private and I use it a lot to build collections<br>&gt; of small classes and structs that work together rather than a large<br>&gt; class/struct that tries to “be everything”. In those scenarios, traditional<br>&gt; OO private would be too restrictive and even a “protected” access type<br>&gt; wouldn’t work because I’m trying to avoid building inheritance hierarchies.<br>&gt; I really need something like “friend” (ugly) or the, imo, much more elegant<br>&gt; file-scoped access and if that one is renamed “fileprivate” I’ll be really<br>&gt; sad seeing such an ugly label all over the place. I’d go so far as to<br>&gt; suggest that an ugly name for this access level would actively discourage<br>&gt; its use and while some might have that as a goal, to me that would<br>&gt; encourage the creation of larger “do everything” classes instead of<br>&gt; clusters of smaller classes and structs and protocols.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; &gt; On Apr 1, 2016, at 7:17 AM, Joanna Carter via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and<br>&gt; how it penalizes folks who want to explicitly write their access control.<br>&gt; I’ve come to think that there is yes-another possible path forward here<br>&gt; (which I haven’t seen mentioned so far):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public<br>&gt; &gt;&gt; internal<br>&gt; &gt;&gt; fileprivate<br>&gt; &gt;&gt; private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that<br>&gt; changes is that some uses of Swift 2 “private” will be migrated to<br>&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt;&gt; 4) fileprivate is the unusual and<br>&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt; “googable”.<br>&gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that<br>&gt; several people are concerned with.<br>&gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing<br>&gt; “internal”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;<br>&gt; &gt; +1<br>&gt; &gt;<br>&gt; &gt; Following on from my experience with Delphi adding &quot;strict private&quot; for<br>&gt; &quot;OO private&quot; members of classes, I would totally agree with your<br>&gt; proposition.<br>&gt; &gt;<br>&gt; &gt; Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to those<br>&gt; of us who were brought up on the OO concept of private, and having<br>&gt; &quot;private&quot; mean file scope simply encouraged very bad, large, files with<br>&gt; lots of classes; especially for those who were new to programming.<br>&gt; &gt;<br>&gt; &gt; This proposal means that folks coming from other OO languages will<br>&gt; instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br>&gt; &gt;<br>&gt; &gt; To my mind, the only extra scope that might be useful is the OO concept<br>&gt; of &quot;protected&quot; on a class, but I would like to see a discussion purely<br>&gt; centred on the effect of more protocols and less class inheritance, with<br>&gt; its attendant impact on whether protected could also suit extending<br>&gt; (otherwise private) scope to extensions.<br>&gt; &gt;<br>&gt; &gt; In recent experiments of adapting the GOF Design Patterns to Swift, I<br>&gt; have found using protocols and extensions to greatly reduce the need for<br>&gt; class inheritance, if not removing the need for classes at all in favour of<br>&gt; structs.<br>&gt; &gt;<br>&gt; &gt; Joanna<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Joanna Carter<br>&gt; &gt; Carter Consulting<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/74261c5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  1, 2016 at 09:00:00am</p></header><div class="content"><p>A new type is implicitly visible *outside* of the file it is defined in and hence it is “external” from that point of view. This arrangement seems more “human” to me. Someone just learning isn’t going to know about modules or how the compiler is treating things anyway and they would almost never run into “external” because it’s the default and there’s no reason to specify it most of the time. IMO, this “fits” how I think about source code while I’m writing it - where do I want to be able to use this symbol? Either hidden away and safe (private), inside this file I’m working with (internal), or within my whole program (external). <br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Apr 1, 2016, at 9:20 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; A new type is implicitly internal to a module. Implicitly specifying it as &#39;external&#39; is just plain confusing.<br>&gt; <br>&gt; On Fri, Apr 1, 2016 at 3:01 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I know this is kind of winding down, and there seems to be a kind of begrudging acceptance of “fileprivate” emerging (perhaps due to fatigue), but I still really don’t like it so I’m going to toss out my current favorite configuration and try to stop caring and defer to the core team to make an executive decision so we can all move on with our lives. :P<br>&gt; <br>&gt; public - unchanged, visible “everywhere&quot;<br>&gt; external - visible outside of the file (module, the default)<br>&gt; internal - visible only within the file<br>&gt; private - visible only within the scope<br>&gt; <br>&gt; I really like the existing private and I use it a lot to build collections of small classes and structs that work together rather than a large class/struct that tries to “be everything”. In those scenarios, traditional OO private would be too restrictive and even a “protected” access type wouldn’t work because I’m trying to avoid building inheritance hierarchies. I really need something like “friend” (ugly) or the, imo, much more elegant file-scoped access and if that one is renamed “fileprivate” I’ll be really sad seeing such an ugly label all over the place. I’d go so far as to suggest that an ugly name for this access level would actively discourage its use and while some might have that as a goal, to me that would encourage the creation of larger “do everything” classes instead of clusters of smaller classes and structs and protocols.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; &gt; On Apr 1, 2016, at 7:17 AM, Joanna Carter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public<br>&gt; &gt;&gt; internal<br>&gt; &gt;&gt; fileprivate<br>&gt; &gt;&gt; private<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;<br>&gt; &gt; +1<br>&gt; &gt;<br>&gt; &gt; Following on from my experience with Delphi adding &quot;strict private&quot; for &quot;OO private&quot; members of classes, I would totally agree with your proposition.<br>&gt; &gt;<br>&gt; &gt; Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to those of us who were brought up on the OO concept of private, and having &quot;private&quot; mean file scope simply encouraged very bad, large, files with lots of classes; especially for those who were new to programming.<br>&gt; &gt;<br>&gt; &gt; This proposal means that folks coming from other OO languages will instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br>&gt; &gt;<br>&gt; &gt; To my mind, the only extra scope that might be useful is the OO concept of &quot;protected&quot; on a class, but I would like to see a discussion purely centred on the effect of more protocols and less class inheritance, with its attendant impact on whether protected could also suit extending (otherwise private) scope to extensions.<br>&gt; &gt;<br>&gt; &gt; In recent experiments of adapting the GOF Design Patterns to Swift, I have found using protocols and extensions to greatly reduce the need for class inheritance, if not removing the need for classes at all in favour of structs.<br>&gt; &gt;<br>&gt; &gt; Joanna<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Joanna Carter<br>&gt; &gt; Carter Consulting<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&quot;or within my whole program (external)&quot;. That caused a double-take on its<br>own.<br></p><p>external things are not within, they are outside. &#39;external&#39; could be a<br>replacement term for &#39;public&#39;, not for &#39;internal&#39;.<br></p><p>This may well be a subjective thing, but I don&#39;t think in files, I think in<br>modules because that&#39;s been the default for several years now. If I create<br>a new type I am implicitly making it visible to everywhere within this<br>module; it is not outside the module so it is not external. I may then<br>choose to make it less visible, but it does not &#39;go inside&#39; when I do this.<br></p><p>If you think in files, I cannot say you are wrong, because it is<br>subjective. But this is why I have been arguing for non-subjective<br>keywords. I cannot make &#39;fileprivate&#39; pretty for you but I do know that<br>when we both read it we both understand what it means. That&#39;s why it hasn&#39;t<br>gone away: it satisfies the criterion of clarity.<br></p><p>Find a pretty alternative with the word &#39;file&#39; baked into it and I&#39;m with<br>you.<br></p><p>On Fri, Apr 1, 2016 at 3:31 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; A new type is implicitly visible *outside* of the file it is defined in<br>&gt; and hence it is “external” from that point of view. This arrangement seems<br>&gt; more “human” to me. Someone just learning isn’t going to know about modules<br>&gt; or how the compiler is treating things anyway and they would almost never<br>&gt; run into “external” because it’s the default and there’s no reason to<br>&gt; specify it most of the time. IMO, this “fits” how I think about source code<br>&gt; while I’m writing it - where do I want to be able to use this symbol?<br>&gt; Either hidden away and safe (private), inside this file I’m working with<br>&gt; (internal), or within my whole program (external).<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Apr 1, 2016, at 9:20 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; A new type is implicitly internal to a module. Implicitly specifying it<br>&gt; as &#39;external&#39; is just plain confusing.<br>&gt; &gt;<br>&gt; &gt; On Fri, Apr 1, 2016 at 3:01 PM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I know this is kind of winding down, and there seems to be a kind of<br>&gt; begrudging acceptance of “fileprivate” emerging (perhaps due to fatigue),<br>&gt; but I still really don’t like it so I’m going to toss out my current<br>&gt; favorite configuration and try to stop caring and defer to the core team to<br>&gt; make an executive decision so we can all move on with our lives. :P<br>&gt; &gt;<br>&gt; &gt; public - unchanged, visible “everywhere&quot;<br>&gt; &gt; external - visible outside of the file (module, the default)<br>&gt; &gt; internal - visible only within the file<br>&gt; &gt; private - visible only within the scope<br>&gt; &gt;<br>&gt; &gt; I really like the existing private and I use it a lot to build<br>&gt; collections of small classes and structs that work together rather than a<br>&gt; large class/struct that tries to “be everything”. In those scenarios,<br>&gt; traditional OO private would be too restrictive and even a “protected”<br>&gt; access type wouldn’t work because I’m trying to avoid building inheritance<br>&gt; hierarchies. I really need something like “friend” (ugly) or the, imo, much<br>&gt; more elegant file-scoped access and if that one is renamed “fileprivate”<br>&gt; I’ll be really sad seeing such an ugly label all over the place. I’d go so<br>&gt; far as to suggest that an ugly name for this access level would actively<br>&gt; discourage its use and while some might have that as a goal, to me that<br>&gt; would encourage the creation of larger “do everything” classes instead of<br>&gt; clusters of smaller classes and structs and protocols.<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt; &gt; On Apr 1, 2016, at 7:17 AM, Joanna Carter via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and<br>&gt; how it penalizes folks who want to explicitly write their access control.<br>&gt; I’ve come to think that there is yes-another possible path forward here<br>&gt; (which I haven’t seen mentioned so far):<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; public<br>&gt; &gt; &gt;&gt; internal<br>&gt; &gt; &gt;&gt; fileprivate<br>&gt; &gt; &gt;&gt; private<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious”<br>&gt; things.<br>&gt; &gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing<br>&gt; that changes is that some uses of Swift 2 “private” will be migrated to<br>&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt; &gt;&gt; 4) fileprivate is the unusual and<br>&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt; “googable”.<br>&gt; &gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that<br>&gt; several people are concerned with.<br>&gt; &gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by<br>&gt; parameterizing “internal”.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Thoughts?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; +1<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Following on from my experience with Delphi adding &quot;strict private&quot;<br>&gt; for &quot;OO private&quot; members of classes, I would totally agree with your<br>&gt; proposition.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to<br>&gt; those of us who were brought up on the OO concept of private, and having<br>&gt; &quot;private&quot; mean file scope simply encouraged very bad, large, files with<br>&gt; lots of classes; especially for those who were new to programming.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This proposal means that folks coming from other OO languages will<br>&gt; instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; To my mind, the only extra scope that might be useful is the OO<br>&gt; concept of &quot;protected&quot; on a class, but I would like to see a discussion<br>&gt; purely centred on the effect of more protocols and less class inheritance,<br>&gt; with its attendant impact on whether protected could also suit extending<br>&gt; (otherwise private) scope to extensions.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; In recent experiments of adapting the GOF Design Patterns to Swift, I<br>&gt; have found using protocols and extensions to greatly reduce the need for<br>&gt; class inheritance, if not removing the need for classes at all in favour of<br>&gt; structs.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Joanna<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; --<br>&gt; &gt; &gt; Joanna Carter<br>&gt; &gt; &gt; Carter Consulting<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/06f23ab4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>April  1, 2016 at 09:00:00am</p></header><div class="content"><p>How about: <br></p><p>notprivateatall<br>notveryprivate<br>mostlyprivate<br>stayout!!!private<br></p><p>Sorry. April fools.. :-) <br></p><p>&gt; On Apr 1, 2016, at 8:00 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;or within my whole program (external)&quot;. That caused a double-take on its own.<br>&gt; <br>&gt; external things are not within, they are outside. &#39;external&#39; could be a replacement term for &#39;public&#39;, not for &#39;internal&#39;.<br>&gt; <br>&gt; This may well be a subjective thing, but I don&#39;t think in files, I think in modules because that&#39;s been the default for several years now. If I create a new type I am implicitly making it visible to everywhere within this module; it is not outside the module so it is not external. I may then choose to make it less visible, but it does not &#39;go inside&#39; when I do this.<br>&gt; <br>&gt; If you think in files, I cannot say you are wrong, because it is subjective. But this is why I have been arguing for non-subjective keywords. I cannot make &#39;fileprivate&#39; pretty for you but I do know that when we both read it we both understand what it means. That&#39;s why it hasn&#39;t gone away: it satisfies the criterion of clarity.<br>&gt; <br>&gt; Find a pretty alternative with the word &#39;file&#39; baked into it and I&#39;m with you.<br>&gt; <br>&gt; On Fri, Apr 1, 2016 at 3:31 PM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt; A new type is implicitly visible *outside* of the file it is defined in and hence it is “external” from that point of view. This arrangement seems more “human” to me. Someone just learning isn’t going to know about modules or how the compiler is treating things anyway and they would almost never run into “external” because it’s the default and there’s no reason to specify it most of the time. IMO, this “fits” how I think about source code while I’m writing it - where do I want to be able to use this symbol? Either hidden away and safe (private), inside this file I’m working with (internal), or within my whole program (external).<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Apr 1, 2016, at 9:20 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium%2Bswift at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; A new type is implicitly internal to a module. Implicitly specifying it as &#39;external&#39; is just plain confusing.<br>&gt; &gt;<br>&gt; &gt; On Fri, Apr 1, 2016 at 3:01 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I know this is kind of winding down, and there seems to be a kind of begrudging acceptance of “fileprivate” emerging (perhaps due to fatigue), but I still really don’t like it so I’m going to toss out my current favorite configuration and try to stop caring and defer to the core team to make an executive decision so we can all move on with our lives. :P<br>&gt; &gt;<br>&gt; &gt; public - unchanged, visible “everywhere&quot;<br>&gt; &gt; external - visible outside of the file (module, the default)<br>&gt; &gt; internal - visible only within the file<br>&gt; &gt; private - visible only within the scope<br>&gt; &gt;<br>&gt; &gt; I really like the existing private and I use it a lot to build collections of small classes and structs that work together rather than a large class/struct that tries to “be everything”. In those scenarios, traditional OO private would be too restrictive and even a “protected” access type wouldn’t work because I’m trying to avoid building inheritance hierarchies. I really need something like “friend” (ugly) or the, imo, much more elegant file-scoped access and if that one is renamed “fileprivate” I’ll be really sad seeing such an ugly label all over the place. I’d go so far as to suggest that an ugly name for this access level would actively discourage its use and while some might have that as a goal, to me that would encourage the creation of larger “do everything” classes instead of clusters of smaller classes and structs and protocols.<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt; &gt; On Apr 1, 2016, at 7:17 AM, Joanna Carter via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; public<br>&gt; &gt; &gt;&gt; internal<br>&gt; &gt; &gt;&gt; fileprivate<br>&gt; &gt; &gt;&gt; private<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; The advantages, as I see them are:<br>&gt; &gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious” things.<br>&gt; &gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt; &gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing that changes is that some uses of Swift 2 “private” will be migrated to “fileprivate”, which makes the intent of the code much more clear.<br>&gt; &gt; &gt;&gt; 4) fileprivate is the unusual and not-really-precedented-in-other-languages modifier, and it would still be “googable”.<br>&gt; &gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that several people are concerned with.<br>&gt; &gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by parameterizing “internal”.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Thoughts?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; +1<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Following on from my experience with Delphi adding &quot;strict private&quot; for &quot;OO private&quot; members of classes, I would totally agree with your proposition.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to those of us who were brought up on the OO concept of private, and having &quot;private&quot; mean file scope simply encouraged very bad, large, files with lots of classes; especially for those who were new to programming.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This proposal means that folks coming from other OO languages will instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; To my mind, the only extra scope that might be useful is the OO concept of &quot;protected&quot; on a class, but I would like to see a discussion purely centred on the effect of more protocols and less class inheritance, with its attendant impact on whether protected could also suit extending (otherwise private) scope to extensions.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; In recent experiments of adapting the GOF Design Patterns to Swift, I have found using protocols and extensions to greatly reduce the need for class inheritance, if not removing the need for classes at all in favour of structs.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Joanna<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; --<br>&gt; &gt; &gt; Joanna Carter<br>&gt; &gt; &gt; Carter Consulting<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/ec615792/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  1, 2016 at 05:00:00pm</p></header><div class="content"><p>In terms of alternatives to fileprivate, I just want to chime in to say<br>that &quot;filewide&quot; seems to be a term that people seem to reach for in<br>describing this scope, based on a quick Google search.<br></p><p>It&#39;s readable, IMO, and definitely an adjective, it breaks no new ground in<br>terms of coining a new term, and it is adequately descriptive. Plus, it<br>avoids the issue of having two things named fileprivate and [bona fide]<br>private.<br></p><p>For those reasons, it&#39;s got my vote over &quot;file&quot;, &quot;fileprivate&quot;, &quot;infile&quot;,<br>&quot;intrafile&quot;, etc.<br></p><p>On Fri, Apr 1, 2016 at 11:11 AM Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; How about:<br>&gt;<br>&gt; notprivateatall<br>&gt; notveryprivate<br>&gt; mostlyprivate<br>&gt; stayout!!!private<br>&gt;<br>&gt; Sorry. April fools.. :-)<br>&gt;<br>&gt; On Apr 1, 2016, at 8:00 AM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &quot;or within my whole program (external)&quot;. That caused a double-take on its<br>&gt; own.<br>&gt;<br>&gt; external things are not within, they are outside. &#39;external&#39; could be a<br>&gt; replacement term for &#39;public&#39;, not for &#39;internal&#39;.<br>&gt;<br>&gt; This may well be a subjective thing, but I don&#39;t think in files, I think<br>&gt; in modules because that&#39;s been the default for several years now. If I<br>&gt; create a new type I am implicitly making it visible to everywhere within<br>&gt; this module; it is not outside the module so it is not external. I may then<br>&gt; choose to make it less visible, but it does not &#39;go inside&#39; when I do this.<br>&gt;<br>&gt; If you think in files, I cannot say you are wrong, because it is<br>&gt; subjective. But this is why I have been arguing for non-subjective<br>&gt; keywords. I cannot make &#39;fileprivate&#39; pretty for you but I do know that<br>&gt; when we both read it we both understand what it means. That&#39;s why it hasn&#39;t<br>&gt; gone away: it satisfies the criterion of clarity.<br>&gt;<br>&gt; Find a pretty alternative with the word &#39;file&#39; baked into it and I&#39;m with<br>&gt; you.<br>&gt;<br>&gt; On Fri, Apr 1, 2016 at 3:31 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt;&gt; A new type is implicitly visible *outside* of the file it is defined in<br>&gt;&gt; and hence it is “external” from that point of view. This arrangement seems<br>&gt;&gt; more “human” to me. Someone just learning isn’t going to know about modules<br>&gt;&gt; or how the compiler is treating things anyway and they would almost never<br>&gt;&gt; run into “external” because it’s the default and there’s no reason to<br>&gt;&gt; specify it most of the time. IMO, this “fits” how I think about source code<br>&gt;&gt; while I’m writing it - where do I want to be able to use this symbol?<br>&gt;&gt; Either hidden away and safe (private), inside this file I’m working with<br>&gt;&gt; (internal), or within my whole program (external).<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Apr 1, 2016, at 9:20 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A new type is implicitly internal to a module. Implicitly specifying it<br>&gt;&gt; as &#39;external&#39; is just plain confusing.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Fri, Apr 1, 2016 at 3:01 PM, Sean Heber via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I know this is kind of winding down, and there seems to be a kind of<br>&gt;&gt; begrudging acceptance of “fileprivate” emerging (perhaps due to fatigue),<br>&gt;&gt; but I still really don’t like it so I’m going to toss out my current<br>&gt;&gt; favorite configuration and try to stop caring and defer to the core team to<br>&gt;&gt; make an executive decision so we can all move on with our lives. :P<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public - unchanged, visible “everywhere&quot;<br>&gt;&gt; &gt; external - visible outside of the file (module, the default)<br>&gt;&gt; &gt; internal - visible only within the file<br>&gt;&gt; &gt; private - visible only within the scope<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I really like the existing private and I use it a lot to build<br>&gt;&gt; collections of small classes and structs that work together rather than a<br>&gt;&gt; large class/struct that tries to “be everything”. In those scenarios,<br>&gt;&gt; traditional OO private would be too restrictive and even a “protected”<br>&gt;&gt; access type wouldn’t work because I’m trying to avoid building inheritance<br>&gt;&gt; hierarchies. I really need something like “friend” (ugly) or the, imo, much<br>&gt;&gt; more elegant file-scoped access and if that one is renamed “fileprivate”<br>&gt;&gt; I’ll be really sad seeing such an ugly label all over the place. I’d go so<br>&gt;&gt; far as to suggest that an ugly name for this access level would actively<br>&gt;&gt; discourage its use and while some might have that as a goal, to me that<br>&gt;&gt; would encourage the creation of larger “do everything” classes instead of<br>&gt;&gt; clusters of smaller classes and structs and protocols.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; l8r<br>&gt;&gt; &gt; Sean<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &gt; On Apr 1, 2016, at 7:17 AM, Joanna Carter via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt;&gt; I’ve seen a number of concerns on this list about moduleprivate, and<br>&gt;&gt; how it penalizes folks who want to explicitly write their access control.<br>&gt;&gt; I’ve come to think that there is yes-another possible path forward here<br>&gt;&gt; (which I haven’t seen mentioned so far):<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt; public<br>&gt;&gt; &gt; &gt;&gt; internal<br>&gt;&gt; &gt; &gt;&gt; fileprivate<br>&gt;&gt; &gt; &gt;&gt; private<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt; The advantages, as I see them are:<br>&gt;&gt; &gt; &gt;&gt; 1) We keep public and private meaning the “right” and “obvious”<br>&gt;&gt; things.<br>&gt;&gt; &gt; &gt;&gt; 2) The declmodifiers “read” correctly.<br>&gt;&gt; &gt; &gt;&gt; 3) Compared to Swift 2, there is almost no change.  The only thing<br>&gt;&gt; that changes is that some uses of Swift 2 “private” will be migrated to<br>&gt;&gt; “fileprivate”, which makes the intent of the code much more clear.<br>&gt;&gt; &gt; &gt;&gt; 4) fileprivate is the unusual and<br>&gt;&gt; not-really-precedented-in-other-languages modifier, and it would still be<br>&gt;&gt; “googable”.<br>&gt;&gt; &gt; &gt;&gt; 5) The addresses the “excessively long” declmodifier problem that<br>&gt;&gt; several people are concerned with.<br>&gt;&gt; &gt; &gt;&gt; 6) Support for named submodules could be “dropped in” by<br>&gt;&gt; parameterizing “internal”.<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt; Thoughts?<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; +1<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; Following on from my experience with Delphi adding &quot;strict private&quot;<br>&gt;&gt; for &quot;OO private&quot; members of classes, I would totally agree with your<br>&gt;&gt; proposition.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; Having to use Delphi&#39;s &quot;strict private&quot; never really felt right to<br>&gt;&gt; those of us who were brought up on the OO concept of private, and having<br>&gt;&gt; &quot;private&quot; mean file scope simply encouraged very bad, large, files with<br>&gt;&gt; lots of classes; especially for those who were new to programming.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; This proposal means that folks coming from other OO languages will<br>&gt;&gt; instantly understand &quot;private&quot;; &quot;fileprivate&quot; does what it says on the tin.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; To my mind, the only extra scope that might be useful is the OO<br>&gt;&gt; concept of &quot;protected&quot; on a class, but I would like to see a discussion<br>&gt;&gt; purely centred on the effect of more protocols and less class inheritance,<br>&gt;&gt; with its attendant impact on whether protected could also suit extending<br>&gt;&gt; (otherwise private) scope to extensions.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; In recent experiments of adapting the GOF Design Patterns to Swift, I<br>&gt;&gt; have found using protocols and extensions to greatly reduce the need for<br>&gt;&gt; class inheritance, if not removing the need for classes at all in favour of<br>&gt;&gt; structs.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; Joanna<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; --<br>&gt;&gt; &gt; &gt; Joanna Carter<br>&gt;&gt; &gt; &gt; Carter Consulting<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/2c8f3022/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0025: Scoped Access Level (DECISION)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  1, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mar 30, 2016, at 9:22 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; <br>&gt; public<br>&gt; internal<br>&gt; fileprivate<br>&gt; private<br></p><p>Hi Everyone,<br></p><p>Thank you for all of the input.  I know that this was a highly contentious topic, that it is impossible to make everyone happy.  Getting the different inputs and perspectives has been very very useful.<br></p><p>The core team met to discuss this, and settled on the list above: public/internal/fileprivate/private.  This preserves the benefit of the “fileprivate” concept that we have today in Swift, while aligning the “private” keyword with common expectations of people coming to Swift. This also makes “private&quot; the &quot;safe default” for cases where you don’t think about which one you want to use, and this schema will cause minimal churn for existing Swift code.<br></p><p>Thank you again for all of the input and discussion!<br></p><p>-Chris<br></p><p>btw, to be clear, this is *not* an April 1 joke.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level (DECISION)</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>April  1, 2016 at 09:00:00pm</p></header><div class="content"><p>Great! Glad that we have a decision.<br></p><p>On Fri, Apr 1, 2016 at 4:34 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 30, 2016, at 9:22 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’ve seen a number of concerns on this list about moduleprivate, and how<br>&gt; it penalizes folks who want to explicitly write their access control.  I’ve<br>&gt; come to think that there is yes-another possible path forward here (which I<br>&gt; haven’t seen mentioned so far):<br>&gt; &gt;<br>&gt; &gt; public<br>&gt; &gt; internal<br>&gt; &gt; fileprivate<br>&gt; &gt; private<br>&gt;<br>&gt; Hi Everyone,<br>&gt;<br>&gt; Thank you for all of the input.  I know that this was a highly contentious<br>&gt; topic, that it is impossible to make everyone happy.  Getting the different<br>&gt; inputs and perspectives has been very very useful.<br>&gt;<br>&gt; The core team met to discuss this, and settled on the list above:<br>&gt; public/internal/fileprivate/private.  This preserves the benefit of the<br>&gt; “fileprivate” concept that we have today in Swift, while aligning the<br>&gt; “private” keyword with common expectations of people coming to Swift. This<br>&gt; also makes “private&quot; the &quot;safe default” for cases where you don’t think<br>&gt; about which one you want to use, and this schema will cause minimal churn<br>&gt; for existing Swift code.<br>&gt;<br>&gt; Thank you again for all of the input and discussion!<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; btw, to be clear, this is *not* an April 1 joke.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/422dfddb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level (DECISION)</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>April  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Just to double check: do I need to do anything with the proposal? It sounds<br>like it was decided, and Doug will update the proposal, but I &#39;d like to<br>make sure that there is nothing to be done on my end.<br></p><p>On Fri, Apr 1, 2016 at 5:07 PM Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>wrote:<br></p><p>&gt; Great! Glad that we have a decision.<br>&gt;<br>&gt; On Fri, Apr 1, 2016 at 4:34 PM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Mar 30, 2016, at 9:22 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’ve seen a number of concerns on this list about moduleprivate, and<br>&gt;&gt; how it penalizes folks who want to explicitly write their access control.<br>&gt;&gt; I’ve come to think that there is yes-another possible path forward here<br>&gt;&gt; (which I haven’t seen mentioned so far):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public<br>&gt;&gt; &gt; internal<br>&gt;&gt; &gt; fileprivate<br>&gt;&gt; &gt; private<br>&gt;&gt;<br>&gt;&gt; Hi Everyone,<br>&gt;&gt;<br>&gt;&gt; Thank you for all of the input.  I know that this was a highly<br>&gt;&gt; contentious topic, that it is impossible to make everyone happy.  Getting<br>&gt;&gt; the different inputs and perspectives has been very very useful.<br>&gt;&gt;<br>&gt;&gt; The core team met to discuss this, and settled on the list above:<br>&gt;&gt; public/internal/fileprivate/private.  This preserves the benefit of the<br>&gt;&gt; “fileprivate” concept that we have today in Swift, while aligning the<br>&gt;&gt; “private” keyword with common expectations of people coming to Swift. This<br>&gt;&gt; also makes “private&quot; the &quot;safe default” for cases where you don’t think<br>&gt;&gt; about which one you want to use, and this schema will cause minimal churn<br>&gt;&gt; for existing Swift code.<br>&gt;&gt;<br>&gt;&gt; Thank you again for all of the input and discussion!<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; btw, to be clear, this is *not* an April 1 joke.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/9e1904f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SE-0025: Scoped Access Level (DECISION)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 7:54 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just to double check: do I need to do anything with the proposal? It sounds like it was decided, and Doug will update the proposal, but I &#39;d like to make sure that there is nothing to be done on my end.<br></p><p>I’ll handle the update to the proposal, thank you!<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; On Fri, Apr 1, 2016 at 5:07 PM Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt; Great! Glad that we have a decision.<br>&gt; <br>&gt; On Fri, Apr 1, 2016 at 4:34 PM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Mar 30, 2016, at 9:22 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’ve seen a number of concerns on this list about moduleprivate, and how it penalizes folks who want to explicitly write their access control.  I’ve come to think that there is yes-another possible path forward here (which I haven’t seen mentioned so far):<br>&gt; &gt;<br>&gt; &gt; public<br>&gt; &gt; internal<br>&gt; &gt; fileprivate<br>&gt; &gt; private<br>&gt; <br>&gt; Hi Everyone,<br>&gt; <br>&gt; Thank you for all of the input.  I know that this was a highly contentious topic, that it is impossible to make everyone happy.  Getting the different inputs and perspectives has been very very useful.<br>&gt; <br>&gt; The core team met to discuss this, and settled on the list above: public/internal/fileprivate/private.  This preserves the benefit of the “fileprivate” concept that we have today in Swift, while aligning the “private” keyword with common expectations of people coming to Swift. This also makes “private&quot; the &quot;safe default” for cases where you don’t think about which one you want to use, and this schema will cause minimal churn for existing Swift code.<br>&gt; <br>&gt; Thank you again for all of the input and discussion!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; btw, to be clear, this is *not* an April 1 joke.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/63d5eb61/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 02:00:00am</p></header><div class="content"><p>I created a pull request with the updated proposal:<br>https://github.com/apple/swift-evolution/pull/234<br></p><p>On Mon, Mar 14, 2016 at 8:18 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;<br>&gt; To summarize the place we’d like to end up:<br>&gt;<br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt; extension, etc).<br>&gt;<br>&gt; The rationale here is that this aligns Swift with common art seen in other<br>&gt; languages, and that many people using private today don’t *want* visibility<br>&gt; out of their current declaration.  It also encourages “extension oriented<br>&gt; programming”, at least it will when some of the other restrictions on<br>&gt; extensions are lifted.  We discussed dropping the third one entirely, but<br>&gt; think it *is* a useful and important level of access control, and when/if<br>&gt; we ever get the ability to write unit tests inside of the file that defines<br>&gt; the functionality, they will be a nicer solution to @testable.<br>&gt;<br>&gt; The thing we need to know is what the spelling should be for the third<br>&gt; one.  Off hand, perhaps:<br>&gt;<br>&gt; fileprivate<br>&gt; private(file)<br>&gt; internal(file)<br>&gt; fileaccessible<br>&gt; etc<br>&gt;<br>&gt; Some other thoughts on the choice:<br>&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt; googlable keyword.<br>&gt;<br>&gt; Thoughts appreciated.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/174dc663/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; I created a pull request with the updated proposal:<br>&gt; https://github.com/apple/swift-evolution/pull/234<br></p><p>As long as you&#39;re updating the proposal, I&#39;d like to suggest you explain more explicitly the visibility of members marked with your new access level. I know I was surprised that nested types cannot see a parent type&#39;s members, and I&#39;ve seen other people in this thread who seem to believe this behaves like the classic C++/Java `private`, where extensions can see the members. I&#39;m sure you think it&#39;s fully specified, but it just seems to be a point of confusion.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;d like to keep &quot;private&quot; to be completely private and not allow class<br>injection to gain access, but this is an edge case that could be argued<br>either way. I can definitely live with a pure scoped access  for<br>consistency and don&#39;t want to argue the edge case in a never ending<br>discussion.<br></p><p>I think that lexical scope is a well defined concept. The core team<br>requested only the change in names for access levels. At this point, I&#39;d<br>like to limit the changes to that. We already had a very long discussion<br>about all of these topics.<br></p><p>On Sun, Mar 27, 2016 at 10:19 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I created a pull request with the updated proposal:<br>&gt; &gt; https://github.com/apple/swift-evolution/pull/234<br>&gt;<br>&gt; As long as you&#39;re updating the proposal, I&#39;d like to suggest you explain<br>&gt; more explicitly the visibility of members marked with your new access<br>&gt; level. I know I was surprised that nested types cannot see a parent type&#39;s<br>&gt; members, and I&#39;ve seen other people in this thread who seem to believe this<br>&gt; behaves like the classic C++/Java `private`, where extensions can see the<br>&gt; members. I&#39;m sure you think it&#39;s fully specified, but it just seems to be a<br>&gt; point of confusion.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/6e0d2a62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 28, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; We already had a very long discussion about all of these topics.<br></p><p>I am not suggesting you change the design. I am suggesting you clarify the description of your existing design so that everyone understands what it means, because confusion is rampant.<br></p><p>&gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class injection to gain access, but this is an edge case that could be argued either way. I can definitely live with a pure scoped access  for consistency and don&#39;t want to argue the edge case in a never ending discussion.<br></p><p><br>So what you&#39;re saying is, you are purposefully writing the proposal vaguely so that everyone can assume it says whatever they imagine it says, and thus more people will support the proposal?<br></p><p>This is no way to design a programming language.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 11:00:00am</p></header><div class="content"><p>The proposal is not vague. Most questions / misunderstanding is not due to<br>the proposal itself but due to how these terms are used in other languages.<br></p><p>It does have one unintended conclusion (the potential class injection to<br>get access). My position on it is not to change it because it&#39;s an edge<br>case that some people want and that makes the design simpler and more<br>consistent with the terms that it uses (scope).<br></p><p>If my proposal was to disallow adding an inner class to gain access to<br>outer class, I&#39;d make it explicit. But I am not proposing it, so there<br>doesn&#39;t seem to be a need to include it and cause more confusion (we<br>already had plenty of emails about the most common use cases). Also, the<br>core team did not request a clarification on this, so I think it is clear<br>to anybody who wants to go to that level of detail.<br></p><p>On Mon, Mar 28, 2016 at 7:27 AM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; We already had a very long discussion about all of these topics.<br>&gt;<br>&gt; I am not suggesting you change the design. I am suggesting you clarify the<br>&gt; description of your existing design so that everyone understands what it<br>&gt; means, because confusion is rampant.<br>&gt;<br>&gt; &gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class<br>&gt; injection to gain access, but this is an edge case that could be argued<br>&gt; either way. I can definitely live with a pure scoped access  for<br>&gt; consistency and don&#39;t want to argue the edge case in a never ending<br>&gt; discussion.<br>&gt;<br>&gt;<br>&gt; So what you&#39;re saying is, you are purposefully writing the proposal<br>&gt; vaguely so that everyone can assume it says whatever they imagine it says,<br>&gt; and thus more people will support the proposal?<br>&gt;<br>&gt; This is no way to design a programming language.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/05c0a02b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Maybe it&#39;s good thing that we just discussed it. After replying to Matthew,<br>this meaning private feels so wrong that I will update  the proposal<br>to disallow this. Private should mean private.<br></p><p>On Mon, Mar 28, 2016 at 7:27 AM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; We already had a very long discussion about all of these topics.<br>&gt;<br>&gt; I am not suggesting you change the design. I am suggesting you clarify the<br>&gt; description of your existing design so that everyone understands what it<br>&gt; means, because confusion is rampant.<br>&gt;<br>&gt; &gt; I&#39;d like to keep &quot;private&quot; to be completely private and not allow class<br>&gt; injection to gain access, but this is an edge case that could be argued<br>&gt; either way. I can definitely live with a pure scoped access  for<br>&gt; consistency and don&#39;t want to argue the edge case in a never ending<br>&gt; discussion.<br>&gt;<br>&gt;<br>&gt; So what you&#39;re saying is, you are purposefully writing the proposal<br>&gt; vaguely so that everyone can assume it says whatever they imagine it says,<br>&gt; and thus more people will support the proposal?<br>&gt;<br>&gt; This is no way to design a programming language.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/2bb3247f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>after a brief discussion, updated the proposal to limit `private` only to<br>the immediate scope.<br>https://github.com/apple/swift-evolution/pull/234<br></p><p>On Sun, Mar 27, 2016 at 10:03 PM Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I created a pull request with the updated proposal:<br>&gt; https://github.com/apple/swift-evolution/pull/234<br>&gt;<br>&gt; On Mon, Mar 14, 2016 at 8:18 PM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt;&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;<br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;<br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt;&gt; extension, etc).<br>&gt;&gt;<br>&gt;&gt; The rationale here is that this aligns Swift with common art seen in<br>&gt;&gt; other languages, and that many people using private today don’t *want*<br>&gt;&gt; visibility out of their current declaration.  It also encourages “extension<br>&gt;&gt; oriented programming”, at least it will when some of the other restrictions<br>&gt;&gt; on extensions are lifted.  We discussed dropping the third one entirely,<br>&gt;&gt; but think it *is* a useful and important level of access control, and<br>&gt;&gt; when/if we ever get the ability to write unit tests inside of the file that<br>&gt;&gt; defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;<br>&gt;&gt; The thing we need to know is what the spelling should be for the third<br>&gt;&gt; one.  Off hand, perhaps:<br>&gt;&gt;<br>&gt;&gt; fileprivate<br>&gt;&gt; private(file)<br>&gt;&gt; internal(file)<br>&gt;&gt; fileaccessible<br>&gt;&gt; etc<br>&gt;&gt;<br>&gt;&gt; Some other thoughts on the choice:<br>&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt;&gt; googlable keyword.<br>&gt;&gt;<br>&gt;&gt; Thoughts appreciated.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/be701091/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 29, 2016 at 03:00:00am</p></header><div class="content"><p>After today&#39;s discussion, I changed the proposal back to only describe the<br>new names (fileprivate etc.)  and keep the lexical scope (I still want the<br>immediate scope, but after Jordan&#39;s explanation that it&#39;s not standard and<br>that other major languages don&#39;t do this, I decided to remove it.)<br>https://github.com/apple/swift-evolution/pull/235<br>(I am not a git expert, so I created a new pull request)<br></p><p>On Sun, Mar 27, 2016 at 10:03 PM Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I created a pull request with the updated proposal:<br>&gt; https://github.com/apple/swift-evolution/pull/234<br>&gt;<br>&gt; On Mon, Mar 14, 2016 at 8:18 PM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but<br>&gt;&gt; would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;<br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;<br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class,<br>&gt;&gt; extension, etc).<br>&gt;&gt;<br>&gt;&gt; The rationale here is that this aligns Swift with common art seen in<br>&gt;&gt; other languages, and that many people using private today don’t *want*<br>&gt;&gt; visibility out of their current declaration.  It also encourages “extension<br>&gt;&gt; oriented programming”, at least it will when some of the other restrictions<br>&gt;&gt; on extensions are lifted.  We discussed dropping the third one entirely,<br>&gt;&gt; but think it *is* a useful and important level of access control, and<br>&gt;&gt; when/if we ever get the ability to write unit tests inside of the file that<br>&gt;&gt; defines the functionality, they will be a nicer solution to @testable.<br>&gt;&gt;<br>&gt;&gt; The thing we need to know is what the spelling should be for the third<br>&gt;&gt; one.  Off hand, perhaps:<br>&gt;&gt;<br>&gt;&gt; fileprivate<br>&gt;&gt; private(file)<br>&gt;&gt; internal(file)<br>&gt;&gt; fileaccessible<br>&gt;&gt; etc<br>&gt;&gt;<br>&gt;&gt; Some other thoughts on the choice:<br>&gt;&gt; - this will be a declaration modifier, so it will not “burn” a keyword.<br>&gt;&gt; - if will be a uniquely Swift thing, so there is virtue in it being a<br>&gt;&gt; googlable keyword.<br>&gt;&gt;<br>&gt;&gt; Thoughts appreciated.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/5c0de78f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br></p><p>won’t that break *every* single member written today, given that “no specifier” is used for internal (i.e. most code in most apps), currently?<br></p><p>—marc<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
