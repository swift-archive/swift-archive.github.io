<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; To me it seems logical that comparing Optional&lt;Int&gt; with Int (or another<br>&gt; Optional&lt;Int&gt;), if it&#39;s allowed at all, should return Optional&lt;Bool&gt;. Since<br>&gt; conditional statements only accept Bool, the user is forced to handle the<br>&gt; nil case explicitly.<br>I disagree that comparing Optional values should have a return value of Optional&lt;Bool&gt;.<br>If the following were to be true:<br></p><p>.None &lt; .Some(0) == .None<br></p><p>Then logically, this would be too:<br></p><p>[] &lt; [1,2,3] == []<br></p><p>I think most people would agree that the correct result to that comparison should be ‚Äòtrue‚Äô, not [].<br></p><p>When comparing ‚Äòcontainer‚Äô types I think it‚Äôs important to have a simple Bool result, otherwise things get very peculiar (conceptually the Optional type is really just a container with a maximum count of 1).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/d6ef1c45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c03900bc3f7eec944f7675bebb78ef0?s=50"></div><header><strong>? suffix for &lt;, &gt;, =?utf-8?Q?&lt;=3D=2C &gt;=3D_?=comparisons with optionals to prevent subtle bugs</strong> from <string>Lucas Derraugh</string> &lt;lucas.derraugh at me.com&gt;<p>December  9, 2015 at 06:00:00am</p></header><div class="content"><p>This is related to a question I asked on SO a while back:¬†http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value<br></p><p>Seems that many others have had confusion with the same problem, and it can sneak into your code without being aware of it. The simple case that I ran into was comparing an Optional Int to an Int. It is a very subtle bug and one that I don‚Äôt think should be allowed to occur. To me the intent isn&#39;t clear in this situation. I don‚Äôt think nil should be considered true or false if compared against. The only alternative I can think of is if comparing anything to a nil value, the result would be false; this would probably still lead to unexpected behavior though.<br></p><p>Lucas Derraugh<br>lucas.derraugh at me.com<br>607-793-3517		<br></p><p>On December 9, 2015 at 6:10:40 AM, Al Skipp via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>To me it seems logical that comparing Optional&lt;Int&gt; with Int (or another<br>Optional&lt;Int&gt;), if it&#39;s allowed at all, should return Optional&lt;Bool&gt;. Since<br>conditional statements only accept Bool, the user is forced to handle the<br>nil case explicitly.<br>I disagree that comparing Optional values should have a return value of Optional&lt;Bool&gt;.<br>If the following were to be true:<br></p><p>.None &lt; .Some(0) == .None<br></p><p>Then logically, this would be too:<br></p><p>[] &lt; [1,2,3] == []<br></p><p>I think most people would agree that the correct result to that comparison should be ‚Äòtrue‚Äô, not [].<br></p><p>When comparing ‚Äòcontainer‚Äô types I think it‚Äôs important to have a simple Bool result, otherwise things get very peculiar (conceptually the Optional type is really just a container with a maximum count of 1).<br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/ffcf5242/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>I don‚Äôt have a problem with Optionals being comparable, but I do see the potential for bugs occurring as Swift automatically wraps values as Optionals when required. Not sure what the solution would be here, other than to make the wrapping of values explicit?<br></p><p>Here‚Äôs an example of when automatic Optional wrapping can cause unexpected results:<br></p><p>struct Pet {<br>  let age: Int<br>}<br></p><p>struct Person {<br>  let name: String<br>  let pet: Pet?<br>}<br></p><p>let peeps = [<br>  Person(name: &quot;Fred&quot;, pet: Pet(age: 5)),<br>  Person(name: &quot;Jill&quot;, pet: .None), // no pet here<br>  Person(name: &quot;Burt&quot;, pet: Pet(age: 10)),<br>]<br></p><p>let ps = peeps.filter { $0.pet?.age &lt; 6 }<br></p><p>ps == [Fred, Jill] // if you don‚Äôt own a pet, your non-existent pet is considered to be younger than any actual pet  üê∂<br></p><p><br>If the Optional wrapping of ‚Äò6‚Äô in the comparison had to be explicit, then the result wouldn&#39;t be so unexpected.<br></p><p>Al<br></p><p><br>&gt; On 9 Dec 2015, at 11:31, Lucas Derraugh &lt;lucas.derraugh at me.com&gt; wrote:<br>&gt; <br>&gt; This is related to a question I asked on SO a while back: http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value &lt;http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value&gt;<br>&gt; <br>&gt; Seems that many others have had confusion with the same problem, and it can sneak into your code without being aware of it. The simple case that I ran into was comparing an Optional Int to an Int. It is a very subtle bug and one that I don‚Äôt think should be allowed to occur. To me the intent isn&#39;t clear in this situation. I don‚Äôt think nil should be considered true or false if compared against. The only alternative I can think of is if comparing anything to a nil value, the result would be false; this would probably still lead to unexpected behavior though.<br>&gt; <br>&gt; Lucas Derraugh<br>&gt; lucas.derraugh at me.com &lt;mailto:lucas.derraugh at me.com&gt;<br>&gt; 607-793-3517	<br>&gt; <br>&gt; On December 9, 2015 at 6:10:40 AM, Al Skipp via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt; <br>&gt;&gt;&gt; To me it seems logical that comparing Optional&lt;Int&gt; with Int (or another<br>&gt;&gt;&gt; Optional&lt;Int&gt;), if it&#39;s allowed at all, should return Optional&lt;Bool&gt;. Since<br>&gt;&gt;&gt; conditional statements only accept Bool, the user is forced to handle the<br>&gt;&gt;&gt; nil case explicitly.<br>&gt;&gt; I disagree that comparing Optional values should have a return value of Optional&lt;Bool&gt;.<br>&gt;&gt; If the following were to be true:<br>&gt;&gt; <br>&gt;&gt; .None &lt; .Some(0) == .None<br>&gt;&gt; <br>&gt;&gt; Then logically, this would be too:<br>&gt;&gt; <br>&gt;&gt; [] &lt; [1,2,3] == []<br>&gt;&gt; <br>&gt;&gt; I think most people would agree that the correct result to that comparison should be ‚Äòtrue‚Äô, not [].<br>&gt;&gt; <br>&gt;&gt; When comparing ‚Äòcontainer‚Äô types I think it‚Äôs important to have a simple Bool result, otherwise things get very peculiar (conceptually the Optional type is really just a container with a maximum count of 1).<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/2ef68bcc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>That&#39;s why I would prefer that optionals are not comparable by default.<br></p><p>Then I would simply have to write<br></p><p>let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br></p><p>making the intended semantics explicit, which is necessary IMHO because there is no default semantics for comparing nil with something else (depending on my specific use case I might have chosen to return true in the nil case).<br></p><p>-Thorsten <br></p><p><br>&gt; Am 09.12.2015 um 13:03 schrieb Al Skipp via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I don‚Äôt have a problem with Optionals being comparable, but I do see the potential for bugs occurring as Swift automatically wraps values as Optionals when required. Not sure what the solution would be here, other than to make the wrapping of values explicit?<br>&gt; <br>&gt; Here‚Äôs an example of when automatic Optional wrapping can cause unexpected results:<br>&gt; <br>&gt; struct Pet {<br>&gt;   let age: Int<br>&gt; }<br>&gt; <br>&gt; struct Person {<br>&gt;   let name: String<br>&gt;   let pet: Pet?<br>&gt; }<br>&gt; <br>&gt; let peeps = [<br>&gt;   Person(name: &quot;Fred&quot;, pet: Pet(age: 5)),<br>&gt;   Person(name: &quot;Jill&quot;, pet: .None), // no pet here<br>&gt;   Person(name: &quot;Burt&quot;, pet: Pet(age: 10)),<br>&gt; ]<br>&gt; <br>&gt; let ps = peeps.filter { $0.pet?.age &lt; 6 }<br>&gt; <br>&gt; ps == [Fred, Jill] // if you don‚Äôt own a pet, your non-existent pet is considered to be younger than any actual pet  üê∂<br>&gt; <br>&gt; <br>&gt; If the Optional wrapping of ‚Äò6‚Äô in the comparison had to be explicit, then the result wouldn&#39;t be so unexpected.<br>&gt; <br>&gt; Al<br>&gt; <br>&gt; <br>&gt;&gt; On 9 Dec 2015, at 11:31, Lucas Derraugh &lt;lucas.derraugh at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is related to a question I asked on SO a while back: http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value<br>&gt;&gt; <br>&gt;&gt; Seems that many others have had confusion with the same problem, and it can sneak into your code without being aware of it. The simple case that I ran into was comparing an Optional Int to an Int. It is a very subtle bug and one that I don‚Äôt think should be allowed to occur. To me the intent isn&#39;t clear in this situation. I don‚Äôt think nil should be considered true or false if compared against. The only alternative I can think of is if comparing anything to a nil value, the result would be false; this would probably still lead to unexpected behavior though.<br>&gt;&gt; <br>&gt;&gt; Lucas Derraugh<br>&gt;&gt; lucas.derraugh at me.com<br>&gt;&gt; 607-793-3517	<br>&gt;&gt; <br>&gt;&gt;&gt; On December 9, 2015 at 6:10:40 AM, Al Skipp via swift-evolution (swift-evolution at swift.org) wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me it seems logical that comparing Optional&lt;Int&gt; with Int (or another<br>&gt;&gt;&gt;&gt; Optional&lt;Int&gt;), if it&#39;s allowed at all, should return Optional&lt;Bool&gt;. Since<br>&gt;&gt;&gt;&gt; conditional statements only accept Bool, the user is forced to handle the<br>&gt;&gt;&gt;&gt; nil case explicitly.<br>&gt;&gt;&gt; I disagree that comparing Optional values should have a return value of Optional&lt;Bool&gt;.<br>&gt;&gt;&gt; If the following were to be true:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .None &lt; .Some(0) == .None<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then logically, this would be too:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [] &lt; [1,2,3] == []<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think most people would agree that the correct result to that comparison should be ‚Äòtrue‚Äô, not [].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When comparing ‚Äòcontainer‚Äô types I think it‚Äôs important to have a simple Bool result, otherwise things get very peculiar (conceptually the Optional type is really just a container with a maximum count of 1).<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/5c6ab5d2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>It‚Äôs curious that your example won‚Äôt compile (didn‚Äôt when I tried it in a Playground), however the following does:<br></p><p>let ps = peeps.filter { $0.pet.map { pet in pet.age &lt; 6 } ?? false }<br></p><p><br>My perspective is still that the issue isn‚Äôt with Optionals being comparable, but in certain edge cases the auto wrapping of non Optionals is what causes the confusion, as it‚Äôs not obvious that the comparison is between Optionals.<br></p><p>Regarding the default semantics, I‚Äôd say the semantics of Optional comparison is pretty reasonable and fits with:<br></p><p>&quot;&quot; &lt; &quot;abc&quot; == true<br>[] &lt; [1,2,3] == true<br>.None &lt; .Some(0) == true<br></p><p><br>Al<br></p><p><br></p><p>&gt; On 9 Dec 2015, at 17:44, thorsten at portableinnovations.de wrote:<br>&gt; <br>&gt; That&#39;s why I would prefer that optionals are not comparable by default.<br>&gt; <br>&gt; Then I would simply have to write<br>&gt; <br>&gt; let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br>&gt; <br>&gt; making the intended semantics explicit, which is necessary IMHO because there is no default semantics for comparing nil with something else (depending on my specific use case I might have chosen to return true in the nil case).<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; Am 09.12.2015 um 13:03 schrieb Al Skipp via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I don‚Äôt have a problem with Optionals being comparable, but I do see the potential for bugs occurring as Swift automatically wraps values as Optionals when required. Not sure what the solution would be here, other than to make the wrapping of values explicit?<br>&gt;&gt; <br>&gt;&gt; Here‚Äôs an example of when automatic Optional wrapping can cause unexpected results:<br>&gt;&gt; <br>&gt;&gt; struct Pet {<br>&gt;&gt;   let age: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Person {<br>&gt;&gt;   let name: String<br>&gt;&gt;   let pet: Pet?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let peeps = [<br>&gt;&gt;   Person(name: &quot;Fred&quot;, pet: Pet(age: 5)),<br>&gt;&gt;   Person(name: &quot;Jill&quot;, pet: .None), // no pet here<br>&gt;&gt;   Person(name: &quot;Burt&quot;, pet: Pet(age: 10)),<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; let ps = peeps.filter { $0.pet?.age &lt; 6 }<br>&gt;&gt; <br>&gt;&gt; ps == [Fred, Jill] // if you don‚Äôt own a pet, your non-existent pet is considered to be younger than any actual pet  üê∂<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If the Optional wrapping of ‚Äò6‚Äô in the comparison had to be explicit, then the result wouldn&#39;t be so unexpected.<br>&gt;&gt; <br>&gt;&gt; Al<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 9 Dec 2015, at 11:31, Lucas Derraugh &lt;lucas.derraugh at me.com &lt;mailto:lucas.derraugh at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is related to a question I asked on SO a while back: http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value &lt;http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems that many others have had confusion with the same problem, and it can sneak into your code without being aware of it. The simple case that I ran into was comparing an Optional Int to an Int. It is a very subtle bug and one that I don‚Äôt think should be allowed to occur. To me the intent isn&#39;t clear in this situation. I don‚Äôt think nil should be considered true or false if compared against. The only alternative I can think of is if comparing anything to a nil value, the result would be false; this would probably still lead to unexpected behavior though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lucas Derraugh<br>&gt;&gt;&gt; lucas.derraugh at me.com &lt;mailto:lucas.derraugh at me.com&gt;<br>&gt;&gt;&gt; 607-793-3517	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On December 9, 2015 at 6:10:40 AM, Al Skipp via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To me it seems logical that comparing Optional&lt;Int&gt; with Int (or another<br>&gt;&gt;&gt;&gt;&gt; Optional&lt;Int&gt;), if it&#39;s allowed at all, should return Optional&lt;Bool&gt;. Since<br>&gt;&gt;&gt;&gt;&gt; conditional statements only accept Bool, the user is forced to handle the<br>&gt;&gt;&gt;&gt;&gt; nil case explicitly.<br>&gt;&gt;&gt;&gt; I disagree that comparing Optional values should have a return value of Optional&lt;Bool&gt;.<br>&gt;&gt;&gt;&gt; If the following were to be true:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .None &lt; .Some(0) == .None<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then logically, this would be too:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [] &lt; [1,2,3] == []<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think most people would agree that the correct result to that comparison should be ‚Äòtrue‚Äô, not [].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When comparing ‚Äòcontainer‚Äô types I think it‚Äôs important to have a simple Bool result, otherwise things get very peculiar (conceptually the Optional type is really just a container with a maximum count of 1).<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/fcf09343/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br>&gt; <br></p><p>&gt; It‚Äôs curious that your example won‚Äôt compile (didn‚Äôt when I tried it in a Playground)<br></p><p>You are right, the example does not compile (wrote it in the train far away from Xcode). It gives an error of ‚Äûvalue of type ‚ÄöInt‚Äò has no member ‚Äömap‚Äò‚Äú.<br></p><p>Hmm, I consider that as a bug in the definition of optional chaining, as the documentation clearly states <br>&quot;Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.‚Äú (note the last sentence).<br></p><p>So if $0.pet?.age should return nil in case of $0.pet being nil, the type of $0.pet?.age has to be Int? and therefore understand map().<br></p><p>peeps[0].pet?.age.dynamicType      // =&gt; Int.Type this is wrong!! Should be Optional&lt;Int&gt;.Type<br>let y: Int = peeps[1].pet?.age     // This gives a type error which is right (but inconsistent with the dynamicType just claimed)<br>let x = peeps[1].pet?.age          // Now let‚Äôs see what the type is after assigning the expression<br>x.dynamicType                      // =&gt; Optional&lt;Int&gt;.Type as expected<br>x.map { age in age &lt; 6 } ?? false  // =&gt; false as expected<br></p><p>So, obviously a bug in the compiler.<br></p><p>&gt; My perspective is still that the issue isn‚Äôt with Optionals being comparable, but in certain edge cases the auto wrapping of non Optionals is what causes the confusion, as it‚Äôs not obvious that the comparison is between Optionals.<br></p><p>You are certainly right that the real issue is with auto wrapping.<br></p><p>&gt; Regarding the default semantics, I‚Äôd say the semantics of Optional comparison is pretty reasonable and fits with:<br>&gt; <br>&gt; &quot;&quot; &lt; &quot;abc&quot; == true<br>&gt; [] &lt; [1,2,3] == true<br>&gt; .None &lt; .Some(0) == true<br></p><p>You have me convinced here as the cases for the String and the List are quite convincing and the analogy with .None and .Some compelling.<br>Thanks!<br></p><p>Just checked: Haskell defines the same order for its Maybe monad, i.e. (Nothing &lt; Just 0) == True.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/adc72a36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 9:30 AM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br>&gt;&gt; <br>&gt; <br>&gt;&gt; It‚Äôs curious that your example won‚Äôt compile (didn‚Äôt when I tried it in a Playground)<br>&gt; <br>&gt; You are right, the example does not compile (wrote it in the train far away from Xcode). It gives an error of ‚Äûvalue of type ‚ÄöInt‚Äò has no member ‚Äömap‚Äò‚Äú.<br>&gt; <br>&gt; Hmm, I consider that as a bug in the definition of optional chaining, as the documentation clearly states <br>&gt; &quot;Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.‚Äú (note the last sentence).<br>&gt; <br>&gt; So if $0.pet?.age should return nil in case of $0.pet being nil, the type of $0.pet?.age has to be Int? and therefore understand map().<br>&gt; <br>&gt; peeps[0].pet?.age.dynamicType      // =&gt; Int.Type this is wrong!! Should be Optional&lt;Int&gt;.Type<br>&gt; let y: Int = peeps[1].pet?.age     // This gives a type error which is right (but inconsistent with the dynamicType just claimed)<br>&gt; let x = peeps[1].pet?.age          // Now let‚Äôs see what the type is after assigning the expression<br>&gt; x.dynamicType                      // =&gt; Optional&lt;Int&gt;.Type as expected<br>&gt; x.map { age in age &lt; 6 } ?? false  // =&gt; false as expected<br>&gt; <br>&gt; So, obviously a bug in the compiler.<br>&gt; <br></p><p>This works: <br></p><p>let ps = peeps.filter { ($0.pet?.age).map { age in age &lt; 6 } ?? false }<br></p><p>Essentially the ‚Äú?.‚Äù operator unwraps the optional, and any further ‚Äú.‚Äù in the chain get applied with the non-optional types as long as the results are non-nil. In order to get an optional result again, you need to break the ‚Äú.‚Äù chain, as with the parens in this case.<br></p><p>I‚Äôm not sure: is this actually a compiler bug, and the type constraint system ought to consider binding to members of ‚ÄúT?&quot; as well as ‚ÄúT&quot; at each further ‚Äú.‚Äù, or is this an expected (but obscure) part of the language, in which case the bug is maybe just that if no members match for ‚ÄúT&quot; the error could suggest this paren fix if there is a member match for ‚ÄúT?‚Äù?<br></p><p>	- Greg<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/8d0ee782/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>Interesting stuff!<br></p><p>It did confuse me too, as I was expecting your initial code sample to work. My understanding is that ‚Äò?‚Äô is syntactic sugar for ‚Äòmap‚Äô in this context. Anything following the ‚Äò?‚Äô is inside the Optional context.<br></p><p>Here is a comparison between ‚Äòmap‚Äô and optional chaining (with and without parentheses).<br></p><p>let type1 = peeps[0].pet.map { $0.age }.dynamicType // Optional&lt;Int&gt;.Type<br>let type2 = peeps[0].pet.map { $0.age.dynamicType } // Int.Type<br></p><p>(peeps[0].pet?.age).dynamicType // Optional&lt;Int&gt;.Type<br>peeps[0].pet?.age.dynamicType // Int.Type<br></p><p><br>&gt; On 10 Dec 2015, at 18:01, Greg Titus &lt;greg at omnigroup.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:30 AM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; It‚Äôs curious that your example won‚Äôt compile (didn‚Äôt when I tried it in a Playground)<br>&gt;&gt; <br>&gt;&gt; You are right, the example does not compile (wrote it in the train far away from Xcode). It gives an error of ‚Äûvalue of type ‚ÄöInt‚Äò has no member ‚Äömap‚Äò‚Äú.<br>&gt;&gt; <br>&gt;&gt; Hmm, I consider that as a bug in the definition of optional chaining, as the documentation clearly states <br>&gt;&gt; &quot;Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.‚Äú (note the last sentence).<br>&gt;&gt; <br>&gt;&gt; So if $0.pet?.age should return nil in case of $0.pet being nil, the type of $0.pet?.age has to be Int? and therefore understand map().<br>&gt;&gt; <br>&gt;&gt; peeps[0].pet?.age.dynamicType      // =&gt; Int.Type this is wrong!! Should be Optional&lt;Int&gt;.Type<br>&gt;&gt; let y: Int = peeps[1].pet?.age     // This gives a type error which is right (but inconsistent with the dynamicType just claimed)<br>&gt;&gt; let x = peeps[1].pet?.age          // Now let‚Äôs see what the type is after assigning the expression<br>&gt;&gt; x.dynamicType                      // =&gt; Optional&lt;Int&gt;.Type as expected<br>&gt;&gt; x.map { age in age &lt; 6 } ?? false  // =&gt; false as expected<br>&gt;&gt; <br>&gt;&gt; So, obviously a bug in the compiler.<br>&gt;&gt; <br>&gt; <br>&gt; This works: <br>&gt; <br>&gt; let ps = peeps.filter { ($0.pet?.age).map { age in age &lt; 6 } ?? false }<br>&gt; <br>&gt; Essentially the ‚Äú?.‚Äù operator unwraps the optional, and any further ‚Äú.‚Äù in the chain get applied with the non-optional types as long as the results are non-nil. In order to get an optional result again, you need to break the ‚Äú.‚Äù chain, as with the parens in this case.<br>&gt; <br>&gt; I‚Äôm not sure: is this actually a compiler bug, and the type constraint system ought to consider binding to members of ‚ÄúT?&quot; as well as ‚ÄúT&quot; at each further ‚Äú.‚Äù, or is this an expected (but obscure) part of the language, in which case the bug is maybe just that if no members match for ‚ÄúT&quot; the error could suggest this paren fix if there is a member match for ‚ÄúT?‚Äù?<br>&gt; <br>&gt; 	- Greg<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/33a947cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 10, 2015 at 07:00:00pm</p></header><div class="content"><p>Interesting stuff indeed!<br></p><p>&gt; Am 10.12.2015 um 19:21 schrieb Al Skipp &lt;al_skipp at fastmail.fm&gt;:<br>&gt; <br>&gt; Interesting stuff!<br>&gt; <br>&gt; It did confuse me too, as I was expecting your initial code sample to work. My understanding is that ‚Äò?‚Äô is syntactic sugar for ‚Äòmap‚Äô in this context. Anything following the ‚Äò?‚Äô is inside the Optional context.<br></p><p>That is a great insight! Of course, ?. is map! That does make sense! And using parentheses to mark the end of the Optional context introduced by ?. makes sense, too.<br></p><p>Thanks, Greg and Al!<br></p><p>-Thorsten<br> <br></p><p>&gt; <br>&gt; Here is a comparison between ‚Äòmap‚Äô and optional chaining (with and without parentheses).<br>&gt; <br>&gt; let type1 = peeps[0].pet.map { $0.age }.dynamicType // Optional&lt;Int&gt;.Type<br>&gt; let type2 = peeps[0].pet.map { $0.age.dynamicType } // Int.Type<br>&gt; <br>&gt; (peeps[0].pet?.age).dynamicType // Optional&lt;Int&gt;.Type<br>&gt; peeps[0].pet?.age.dynamicType // Int.Type<br>&gt; <br>&gt; <br>&gt;&gt; On 10 Dec 2015, at 18:01, Greg Titus &lt;greg at omnigroup.com &lt;mailto:greg at omnigroup.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 9:30 AM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It‚Äôs curious that your example won‚Äôt compile (didn‚Äôt when I tried it in a Playground)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You are right, the example does not compile (wrote it in the train far away from Xcode). It gives an error of ‚Äûvalue of type ‚ÄöInt‚Äò has no member ‚Äömap‚Äò‚Äú.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm, I consider that as a bug in the definition of optional chaining, as the documentation clearly states <br>&gt;&gt;&gt; &quot;Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.‚Äú (note the last sentence).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So if $0.pet?.age should return nil in case of $0.pet being nil, the type of $0.pet?.age has to be Int? and therefore understand map().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; peeps[0].pet?.age.dynamicType      // =&gt; Int.Type this is wrong!! Should be Optional&lt;Int&gt;.Type<br>&gt;&gt;&gt; let y: Int = peeps[1].pet?.age     // This gives a type error which is right (but inconsistent with the dynamicType just claimed)<br>&gt;&gt;&gt; let x = peeps[1].pet?.age          // Now let‚Äôs see what the type is after assigning the expression<br>&gt;&gt;&gt; x.dynamicType                      // =&gt; Optional&lt;Int&gt;.Type as expected<br>&gt;&gt;&gt; x.map { age in age &lt; 6 } ?? false  // =&gt; false as expected<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, obviously a bug in the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This works: <br>&gt;&gt; <br>&gt;&gt; let ps = peeps.filter { ($0.pet?.age).map { age in age &lt; 6 } ?? false }<br>&gt;&gt; <br>&gt;&gt; Essentially the ‚Äú?.‚Äù operator unwraps the optional, and any further ‚Äú.‚Äù in the chain get applied with the non-optional types as long as the results are non-nil. In order to get an optional result again, you need to break the ‚Äú.‚Äù chain, as with the parens in this case.<br>&gt;&gt; <br>&gt;&gt; I‚Äôm not sure: is this actually a compiler bug, and the type constraint system ought to consider binding to members of ‚ÄúT?&quot; as well as ‚ÄúT&quot; at each further ‚Äú.‚Äù, or is this an expected (but obscure) part of the language, in which case the bug is maybe just that if no members match for ‚ÄúT&quot; the error could suggest this paren fix if there is a member match for ‚ÄúT?‚Äù?<br>&gt;&gt; <br>&gt;&gt; 	- Greg<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/c4eb95f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>Just to add further salt, (or perhaps more appropriately, sugar) to optional chaining, it&#39;s not just map, it‚Äôs also flatMap, as and when required. Here‚Äôs a very silly example demonstrating it:<br></p><p>enum Hat { case Cap, Stetson, Helmet }<br></p><p>struct Pet { let age: Int, hat: Hat? } // a pet might wear a hat?!<br></p><p>struct Person { let name: String, pet: Pet? }<br></p><p>let p = Person(name: &quot;Burt&quot;, pet: Pet(age: 10, hat: .Stetson))<br></p><p>(p.pet?.hat).dynamicType // Optional&lt;Hat&gt;.Type<br>p.pet.map { $0.hat }.dynamicType // Optional&lt;Optional&lt;Hat&gt;&gt;.Type<br>p.pet.flatMap { $0.hat }.dynamicType // Optional&lt;Hat&gt;.Type<br></p><p><br>This topic is going somewhat off-piste, so I‚Äôll stop now!<br></p><p>Al<br></p><p><br>&gt; On 10 Dec 2015, at 18:40, thorsten at portableinnovations.de wrote:<br>&gt; <br>&gt; Interesting stuff indeed!<br>&gt; <br>&gt;&gt; Am 10.12.2015 um 19:21 schrieb Al Skipp &lt;al_skipp at fastmail.fm &lt;mailto:al_skipp at fastmail.fm&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Interesting stuff!<br>&gt;&gt; <br>&gt;&gt; It did confuse me too, as I was expecting your initial code sample to work. My understanding is that ‚Äò?‚Äô is syntactic sugar for ‚Äòmap‚Äô in this context. Anything following the ‚Äò?‚Äô is inside the Optional context.<br>&gt; <br>&gt; That is a great insight! Of course, ?. is map! That does make sense! And using parentheses to mark the end of the Optional context introduced by ?. makes sense, too.<br>&gt; <br>&gt; Thanks, Greg and Al!<br>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/2e2f1a05/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>December 15, 2015 at 08:00:00pm</p></header><div class="content"><p>The pet example took a while to digest. Not really intuitive, but makes sense when thinking it through.<br></p><p>BTW, thank you for &quot;Swift Adventures In Monad Land&quot;, Al :-)<br></p><p><br></p><p>On 09.12.2015, at 19:30, Al Skipp via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>It‚Äôs curious that your example won‚Äôt compile (didn‚Äôt when I tried it in a Playground), however the following does:<br></p><p>let ps = peeps.filter { $0.pet.map { pet in pet.age &lt; 6 } ?? false }<br></p><p><br>My perspective is still that the issue isn‚Äôt with Optionals being comparable, but in certain edge cases the auto wrapping of non Optionals is what causes the confusion, as it‚Äôs not obvious that the comparison is between Optionals.<br></p><p>Regarding the default semantics, I‚Äôd say the semantics of Optional comparison is pretty reasonable and fits with:<br></p><p>&quot;&quot; &lt; &quot;abc&quot; == true<br>[] &lt; [1,2,3] == true<br>.None &lt; .Some(0) == true<br></p><p><br>Al<br></p><p><br></p><p>On 9 Dec 2015, at 17:44, thorsten at portableinnovations.de&lt;mailto:thorsten at portableinnovations.de&gt; wrote:<br></p><p>That&#39;s why I would prefer that optionals are not comparable by default.<br></p><p>Then I would simply have to write<br></p><p>let ps = peeps.filter { $0.pet?.age.map { age in age &lt; 6 } ?? false }<br></p><p>making the intended semantics explicit, which is necessary IMHO because there is no default semantics for comparing nil with something else (depending on my specific use case I might have chosen to return true in the nil case).<br></p><p>-Thorsten<br></p><p><br>Am 09.12.2015 um 13:03 schrieb Al Skipp via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;:<br></p><p>I don‚Äôt have a problem with Optionals being comparable, but I do see the potential for bugs occurring as Swift automatically wraps values as Optionals when required. Not sure what the solution would be here, other than to make the wrapping of values explicit?<br></p><p>Here‚Äôs an example of when automatic Optional wrapping can cause unexpected results:<br></p><p>struct Pet {<br>  let age: Int<br>}<br></p><p>struct Person {<br>  let name: String<br>  let pet: Pet?<br>}<br></p><p>let peeps = [<br>  Person(name: &quot;Fred&quot;, pet: Pet(age: 5)),<br>  Person(name: &quot;Jill&quot;, pet: .None), // no pet here<br>  Person(name: &quot;Burt&quot;, pet: Pet(age: 10)),<br>]<br></p><p>let ps = peeps.filter { $0.pet?.age &lt; 6 }<br></p><p>ps == [Fred, Jill] // if you don‚Äôt own a pet, your non-existent pet is considered to be younger than any actual pet  üê∂<br></p><p><br>If the Optional wrapping of ‚Äò6‚Äô in the comparison had to be explicit, then the result wouldn&#39;t be so unexpected.<br></p><p>Al<br></p><p><br>On 9 Dec 2015, at 11:31, Lucas Derraugh &lt;lucas.derraugh at me.com&lt;mailto:lucas.derraugh at me.com&gt;&gt; wrote:<br></p><p>This is related to a question I asked on SO a while back: http://stackoverflow.com/questions/26172911/swift-nil-has-a-numeric-value<br></p><p>Seems that many others have had confusion with the same problem, and it can sneak into your code without being aware of it. The simple case that I ran into was comparing an Optional Int to an Int. It is a very subtle bug and one that I don‚Äôt think should be allowed to occur. To me the intent isn&#39;t clear in this situation. I don‚Äôt think nil should be considered true or false if compared against. The only alternative I can think of is if comparing anything to a nil value, the result would be false; this would probably still lead to unexpected behavior though.<br></p><p>Lucas Derraugh<br>lucas.derraugh at me.com&lt;mailto:lucas.derraugh at me.com&gt;<br>607-793-3517<br></p><p><br>On December 9, 2015 at 6:10:40 AM, Al Skipp via swift-evolution (swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;) wrote:<br></p><p>To me it seems logical that comparing Optional&lt;Int&gt; with Int (or another<br>Optional&lt;Int&gt;), if it&#39;s allowed at all, should return Optional&lt;Bool&gt;. Since<br>conditional statements only accept Bool, the user is forced to handle the<br>nil case explicitly.<br></p><p><br>I disagree that comparing Optional values should have a return value of Optional&lt;Bool&gt;.<br>If the following were to be true:<br></p><p>.None &lt; .Some(0) == .None<br></p><p>Then logically, this would be too:<br></p><p>[] &lt; [1,2,3] == []<br></p><p>I think most people would agree that the correct result to that comparison should be ‚Äòtrue‚Äô, not [].<br></p><p>When comparing ‚Äòcontainer‚Äô types I think it‚Äôs important to have a simple Bool result, otherwise things get very peculiar (conceptually the Optional type is really just a container with a maximum count of 1).<br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/c463722b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>? suffix for &lt;, &gt;, &lt;=, &gt;= comparisons with optionals to prevent subtle bugs</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 15 Dec 2015, at 20:28, Fabian Ehrentraud &lt;Fabian.Ehrentraud at willhaben.at&gt; wrote:<br>&gt; <br>&gt; The pet example took a while to digest. Not really intuitive, but makes sense when thinking it through.<br>&gt; <br>&gt; BTW, thank you for &quot;Swift Adventures In Monad Land&quot;, Al :-)<br></p><p>Thanks : ) Glad you found it useful, though it needs updating for Swift 2, and then Swift 3‚Ä¶ üò¨<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/f257f067/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
