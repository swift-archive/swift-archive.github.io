<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>June 20, 2016 at 11:00:00am</p></header><div class="content"><p>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2199/focus=18327&gt;<br></p><p>I hope it&#39;s not too late to submit a proposal.<br></p><p>[stdlib/public/core/FloatingPointTypes.swift.gyb]<br></p><p>	public struct Float32: BinaryFloatingPoint<br>	public struct Float64: BinaryFloatingPoint<br>	public struct Float80: BinaryFloatingPoint<br></p><p>[stdlib/public/core/CTypes.swift]<br></p><p>	public typealias CFloat      = Float32<br>	public typealias CDouble     = Float64<br>	public typealias CLongDouble = Float80<br></p><p>[stdlib/public/core/Policy.swift]<br></p><p>	/// The default type for an otherwise-<br>	/// unconstrained floating point literal.<br>	public typealias FloatLiteralType = Float64<br></p><p>Clang importer example:<br></p><p>	/// The measurement value, represented as a<br>	/// double-precision floating-point number.<br>	public var doubleValue: CDouble { get }<br></p><p>Alternatives:<br></p><p>* IEEE 754 names: `Binary64` (or `Bin64`), etc.<br></p><p>* DEC64 &lt;http://dec64.com&gt; as the default number type!<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 20, 2016 at 10:00:00am</p></header><div class="content"><p>On Jun 20, 2016, at 7:22 AM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; DEC64 &lt;http://dec64.com &lt;http://dec64.com/&gt;&gt; as the default number type!<br></p><p>At some danger of going off on a tangent, I should point out that DEC64 has very little to recommend it.  It’s not much more efficient performance-wise than IEEE-754 decimal types and has significantly less exponent range (it effectively throws away almost three bits in order to have the exponent fit in a byte; 2**56 is ~7.2E16, which means that it can represent some, but not all, 17-digit significands; the effective working precision is 16 digits, which actually requires only ~53.15 bits.  Even if you weren’t going to use those extra bits for exponent, they could be profitably used for other purposes.  The fact that the dec-64 scheme allows one to use byte operations has only a tiny benefit, and really only on x86).<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/d03e972e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>June 21, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 20 Jun 2016, at 15:44, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; At some danger of going off on a tangent, I should point out that DEC64 has very little to recommend it.  It’s not much more efficient performance-wise than IEEE-754 decimal types and has significantly less exponent range (it effectively throws away almost three bits in order to have the exponent fit in a byte; 2**56 is ~7.2E16, which means that it can represent some, but not all, 17-digit significands; the effective working precision is 16 digits, which actually requires only ~53.15 bits.  Even if you weren’t going to use those extra bits for exponent, they could be profitably used for other purposes.  The fact that the dec-64 scheme allows one to use byte operations has only a tiny benefit, and really only on x86).<br></p><p>Fair enough, I just thought the idea of a single number type was interesting.<br></p><p>As for the proposal, there&#39;s a FIXME comment which suggests the original plan:<br></p><p>&lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Policy.swift&gt;<br></p><p>	//===----------------------------------------------------------------------===//<br>	// Aliases for floating point types<br>	//===----------------------------------------------------------------------===//<br>	// FIXME: it should be the other way round, Float = Float32, Double = Float64,<br>	// but the type checker loses sugar currently, and ends up displaying &#39;FloatXX&#39;<br>	// in diagnostics.<br>	/// A 32-bit floating point type.<br>	public typealias Float32 = Float<br>	/// A 64-bit floating point type.<br>	public typealias Float64 = Double<br></p><p>I think CFloat and CDouble are clearer, so Float and Double could be made unavailable:<br></p><p>	@available(*, unavailable, renamed: &quot;Float32&quot;)<br>	public typealias Float = Float32<br></p><p>	@available(*, unavailable, renamed: &quot;Float64&quot;)<br>	public typealias Double = Float64<br></p><p>Clang importer already seems to be using the correct names:<br></p><p>&lt;https://github.com/apple/swift/blob/master/include/swift/ClangImporter/BuiltinMappedTypes.def&gt;<br>&lt;https://github.com/apple/swift/blob/master/lib/ClangImporter/MappedTypes.def&gt;<br></p><p>-- Ben<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 4:22 AM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2199/focus=18327&gt;<br>&gt; <br>&gt; I hope it&#39;s not too late to submit a proposal.<br>&gt; <br>&gt; [stdlib/public/core/FloatingPointTypes.swift.gyb]<br>&gt; <br>&gt; 	public struct Float32: BinaryFloatingPoint<br>&gt; 	public struct Float64: BinaryFloatingPoint<br>&gt; 	public struct Float80: BinaryFloatingPoint<br></p><p>FWIW, I think it is extremely unlikely that we would go away from Float/Double.<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
