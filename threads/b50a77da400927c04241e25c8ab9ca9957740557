<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>Making asynchronous operations first-class citizens in Swift</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>Dear all,<br></p><p>In the past few months I have been using Swift to write Warp (http://warp.one &lt;http://warp.one/&gt;) a data analysis/ETL app for OS X (±80k LOC). In this app I make heavy use of GCD (dispatch queues) and asynchronous calls. Although Swift has greatly simplified working with asynchronous operations for me compared to Objective C, asynchronous operations are still not really first-class citizens;<br></p><p>The standard library does not really define how errors should be handled in asynchronous scenarios. The throw/catch mechanism obviously doesn&#39;t work for asynchronous operations. <br>While the compiler checks if a function that returns a value returns one in all possible code paths, the compiler currently doesn&#39;t check whether an asynchronous function always &#39;calls back&#39;. Also, while the compiler prevents you from returning twice from a function, it currently does not prevent you from calling a callback more than once (some callbacks actually are intended to be called more than once of course, but in most cases, but many aren&#39;t).<br>Currently you cannot make any assumptions about the queue/thread on which a callback will be called. This is especially problematic when you want to make UI updates from a callback - all you can do is dispatch_async your updates to the main queue. <br></p><p>Re 1, Error handling:  in my own code I have defined a type that represents a &#39;failable&#39; operation (more or less an Optional&lt;T&gt; with either a result object or an error message). I propose the standard library defines such a type before library authors all invent one themselves. My current version is listed below.<br></p><p><br>/** Fallible&lt;T&gt; represents the outcome of an operation that can either fail (with an error message) or succeed<br>(returning an instance of T). */<br>public enum Fallible&lt;T&gt; {<br>	case Success(T)<br>	case Failure(String)<br></p><p>	public init&lt;P&gt;(_ other: Fallible&lt;P&gt;) {<br>		switch other {<br>		case .Success(let s):<br>			self = .Success(s as! T)<br></p><p>		case .Failure(let e):<br>			self = .Failure(e)<br>		}<br>	}<br></p><p>	@warn_unused_result(message=&quot;Deal with potential failure returned by .use, .require to force success or .maybe to ignore failure.&quot;)<br>	public func use&lt;P&gt;(@noescape block: T -&gt; Fallible&lt;P&gt;) -&gt; Fallible&lt;P&gt; {<br>		switch self {<br>		case Success(let box):<br>			return block(box)<br></p><p>		case Failure(let errString):<br>			return .Failure(errString)<br>		}<br>	}<br>}<br></p><p>Re 2 (callbacks and returns): the way I currently &#39;solve&#39; this is to wrap callbacks as follows, so that I get an assertion failure each time a callback is called more than once, so at least I find this out in testing. This doesn&#39;t solve the problem of functions not calling back at all:<br></p><p>public func Once&lt;P, R&gt;(block: ((P) -&gt; (R))) -&gt; ((P) -&gt; (R)) {<br>	var run = false<br></p><p>	#if DEBUG<br>	return {(p: P) -&gt; (R) in<br>		assert(!run, &quot;callback called twice!&quot;)<br>		run = true<br>		return block(p)<br>	}<br>	#else<br>		return block<br>	#endif<br>}<br></p><p>it would be great if closures (or callback parameters) could be annotated with an attribute that indicates how many times the callback should be called under normal circumstances, e.g.:<br></p><p>func foo(callback: @once (Result) -&gt; ()) { ... }<br></p><p>In this example, the callback must either be called exactly once in the body of the foo function, or passed exactly once to another function expecting an @once callback, or should be captured in one closure that always calls the callback once. The compiler should check whether all code paths lead to a single callback, and that no code paths lead to multiple callback invocations. The dispatch_sync and dispatch_async functions are examples of asynchronous functions with @once semantics.<br></p><p>Re 3 (the thread on which a callback is invoked): I currently &#39;solve&#39; this by adding an assert to functions that can only be called on the main thread to ensure they are not called on another thread. <br></p><p>public func AssertMainThread(file: StaticString = __FILE__, line: UInt = __LINE__) {<br>	assert(NSThread.isMainThread(), &quot;Code at \(file):\(line) must run on main thread!&quot;)<br>}<br></p><p>It might be worthwhile to add an attribute to mark functions as &#39;must always execute on main thread&#39; (or &#39;must never execute on main thread&#39; for blocking operations). &#39;Proving&#39; that such a call actually never happens is more difficult however (but at least the attribute provides proper documentation and we can add assertions that check it automatically in debug mode).<br></p><p>Curious to see what you think. I would be willing to write a more formal/complete proposal for these suggestions, if you think they might be valuable additions to the Swift language and standard library.<br></p><p>Best regards,<br>Tommy.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/b50a0557/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making asynchronous operations first-class citizens in Swift</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>Hi, Tommy. Just to make things clear: it&#39;s fine for people to discuss this as brainstorming on the list, but addressing concurrency issues is an explicit non-goal for Swift 3 &lt;https://github.com/apple/swift-evolution#out-of-scope&gt;. We&#39;ll probably come back to it in the future, but that&#39;s still a ways off.<br></p><p>Best,<br>Jordan<br></p><p>&gt; On Dec 9, 2015, at 8:14, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear all,<br>&gt; <br>&gt; In the past few months I have been using Swift to write Warp (http://warp.one &lt;http://warp.one/&gt;) a data analysis/ETL app for OS X (±80k LOC). In this app I make heavy use of GCD (dispatch queues) and asynchronous calls. Although Swift has greatly simplified working with asynchronous operations for me compared to Objective C, asynchronous operations are still not really first-class citizens;<br>&gt; <br>&gt; The standard library does not really define how errors should be handled in asynchronous scenarios. The throw/catch mechanism obviously doesn&#39;t work for asynchronous operations. <br>&gt; While the compiler checks if a function that returns a value returns one in all possible code paths, the compiler currently doesn&#39;t check whether an asynchronous function always &#39;calls back&#39;. Also, while the compiler prevents you from returning twice from a function, it currently does not prevent you from calling a callback more than once (some callbacks actually are intended to be called more than once of course, but in most cases, but many aren&#39;t).<br>&gt; Currently you cannot make any assumptions about the queue/thread on which a callback will be called. This is especially problematic when you want to make UI updates from a callback - all you can do is dispatch_async your updates to the main queue. <br>&gt; <br>&gt; Re 1, Error handling:  in my own code I have defined a type that represents a &#39;failable&#39; operation (more or less an Optional&lt;T&gt; with either a result object or an error message). I propose the standard library defines such a type before library authors all invent one themselves. My current version is listed below.<br>&gt; <br>&gt; <br>&gt; /** Fallible&lt;T&gt; represents the outcome of an operation that can either fail (with an error message) or succeed<br>&gt; (returning an instance of T). */<br>&gt; public enum Fallible&lt;T&gt; {<br>&gt; 	case Success(T)<br>&gt; 	case Failure(String)<br>&gt; <br>&gt; 	public init&lt;P&gt;(_ other: Fallible&lt;P&gt;) {<br>&gt; 		switch other {<br>&gt; 		case .Success(let s):<br>&gt; 			self = .Success(s as! T)<br>&gt; <br>&gt; 		case .Failure(let e):<br>&gt; 			self = .Failure(e)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; 	@warn_unused_result(message=&quot;Deal with potential failure returned by .use, .require to force success or .maybe to ignore failure.&quot;)<br>&gt; 	public func use&lt;P&gt;(@noescape block: T -&gt; Fallible&lt;P&gt;) -&gt; Fallible&lt;P&gt; {<br>&gt; 		switch self {<br>&gt; 		case Success(let box):<br>&gt; 			return block(box)<br>&gt; <br>&gt; 		case Failure(let errString):<br>&gt; 			return .Failure(errString)<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Re 2 (callbacks and returns): the way I currently &#39;solve&#39; this is to wrap callbacks as follows, so that I get an assertion failure each time a callback is called more than once, so at least I find this out in testing. This doesn&#39;t solve the problem of functions not calling back at all:<br>&gt; <br>&gt; public func Once&lt;P, R&gt;(block: ((P) -&gt; (R))) -&gt; ((P) -&gt; (R)) {<br>&gt; 	var run = false<br>&gt; <br>&gt; 	#if DEBUG<br>&gt; 	return {(p: P) -&gt; (R) in<br>&gt; 		assert(!run, &quot;callback called twice!&quot;)<br>&gt; 		run = true<br>&gt; 		return block(p)<br>&gt; 	}<br>&gt; 	#else<br>&gt; 		return block<br>&gt; 	#endif<br>&gt; }<br>&gt; <br>&gt; it would be great if closures (or callback parameters) could be annotated with an attribute that indicates how many times the callback should be called under normal circumstances, e.g.:<br>&gt; <br>&gt; func foo(callback: @once (Result) -&gt; ()) { ... }<br>&gt; <br>&gt; In this example, the callback must either be called exactly once in the body of the foo function, or passed exactly once to another function expecting an @once callback, or should be captured in one closure that always calls the callback once. The compiler should check whether all code paths lead to a single callback, and that no code paths lead to multiple callback invocations. The dispatch_sync and dispatch_async functions are examples of asynchronous functions with @once semantics.<br>&gt; <br>&gt; Re 3 (the thread on which a callback is invoked): I currently &#39;solve&#39; this by adding an assert to functions that can only be called on the main thread to ensure they are not called on another thread. <br>&gt; <br>&gt; public func AssertMainThread(file: StaticString = __FILE__, line: UInt = __LINE__) {<br>&gt; 	assert(NSThread.isMainThread(), &quot;Code at \(file):\(line) must run on main thread!&quot;)<br>&gt; }<br>&gt; <br>&gt; It might be worthwhile to add an attribute to mark functions as &#39;must always execute on main thread&#39; (or &#39;must never execute on main thread&#39; for blocking operations). &#39;Proving&#39; that such a call actually never happens is more difficult however (but at least the attribute provides proper documentation and we can add assertions that check it automatically in debug mode).<br>&gt; <br>&gt; Curious to see what you think. I would be willing to write a more formal/complete proposal for these suggestions, if you think they might be valuable additions to the Swift language and standard library.<br>&gt; <br>&gt; Best regards,<br>&gt; Tommy.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/ae0e5990/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Making asynchronous operations first-class citizens in Swift</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; The standard library does not really define how errors should be handled in asynchronous scenarios. The throw/catch mechanism obviously doesn&#39;t work for asynchronous operations. <br>&gt; While the compiler checks if a function that returns a value returns one in all possible code paths, the compiler currently doesn&#39;t check whether an asynchronous function always &#39;calls back&#39;. Also, while the compiler prevents you from returning twice from a function, it currently does not prevent you from calling a callback more than once (some callbacks actually are intended to be called more than once of course, but in most cases, but many aren&#39;t).<br></p><p>+1.  I made a thread earlier about establishing guidelines for asynchronous callbacks, but long term, it would be great to see these promoted to being language constructs.  According to the swift-evolution GitHub page, concurrency support is in the works, but is out of scope for Swift 3.0.<br></p><p>&gt; Currently you cannot make any assumptions about the queue/thread on which a callback will be called. This is especially problematic when you want to make UI updates from a callback - all you can do is dispatch_async your updates to the main queue. <br></p><p>I have reservations about this, as I usually see most users (when provided with classes that expose their underlying queue properties) over-abusing the main thread.  For the specific issue you’re referencing, I’d rather see that addressed in the UI update model of AppKit/UIKit.<br></p><p>Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/16749595/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
