<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 15, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1. Looks much better than the previous version and makes a lot of sense to me. <br></p><p>A quick clarification question (I didn’t find any mention of this in the proposal, but I might have missed it): what happens if a class is declared open, but does not contain any open member declarations? Is this legal? <br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Most likely<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>A quick reading. I was also following the previous discussion. <br></p><p><br>&gt; On 16 Jul 2016, at 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 12:33 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1. Looks much better than the previous version and makes a lot of sense to me. <br>&gt; <br>&gt; A quick clarification question (I didn’t find any mention of this in the proposal, but I might have missed it): what happens if a class is declared open, but does not contain any open member declarations? Is this legal? <br></p><p>Yes.  Subclasses can extend the API of the class and add new properties, but they can&#39;t modify the core behavior of the superclass.  That&#39;s not an implausible class design, especially as a first step, since it would still be source/binary-compatible to make a method open in a later release.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Most likely<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; A quick reading. I was also following the previous discussion. <br>&gt; <br>&gt; <br>&gt;&gt; On 16 Jul 2016, at 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 02:00:00am</p></header><div class="content"><p>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>This is improved from the previous iteration. The code example needs<br>updating, as both instances of `open func bar()` should be `public open<br>func bar()` as outlined in the Proposed Design section.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes, mostly. There is one comment in the code example that describes a<br>restriction which does not fit with the direction of Swift. It is not the<br>main focus of the proposal but I think should be changed. Namely, the<br>proposal comments:<br></p><p>&quot;[The declaration `[public] open func bar()` inside a class not marked<br>`open`] raises a compilation error: a method can&#39;t be marked `open` if the<br>class it belongs to can&#39;t be subclassed.&quot;<br></p><p>This is discordant with the direction resolved by the core team in the<br>SE-0025 revisions, where it was stated with regard to access modifiers:<br></p><p>&quot;The compiler should not warn when a broader level of access control is<br>used within a type with more restrictive access, such as `internal` within<br>a `private` type. This allows the owner of the type to design the access<br>they would use were they to make the type more widely accessible.&quot;<br></p><p>Applying the same rationale here would suggest that the compiler should not<br>raise an error if a method is marked `open` inside a non-`open` type, in<br>order to allow the owner of the type to design as though to make it<br>subclassable without actually having to do so.<br></p><p>        * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>Yes, I&#39;ve used OOP in other languages. As discussed, this approach is<br>different from that taken by many of those but is a deliberate step.<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Followed the discussion, read proposal carefully.<br></p><p><br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/2ae02e9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 12:59 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; This is improved from the previous iteration. The code example needs updating, as both instances of `open func bar()` should be `public open func bar()` as outlined in the Proposed Design section.<br></p><p>Good catch.  I&#39;ll fix this.<br> <br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, mostly. There is one comment in the code example that describes a restriction which does not fit with the direction of Swift. It is not the main focus of the proposal but I think should be changed. Namely, the proposal comments:<br>&gt; <br>&gt; &quot;[The declaration `[public] open func bar()` inside a class not marked `open`] raises a compilation error: a method can&#39;t be marked `open` if the class it belongs to can&#39;t be subclassed.&quot;<br>&gt; <br>&gt; This is discordant with the direction resolved by the core team in the SE-0025 revisions, where it was stated with regard to access modifiers:<br>&gt; <br>&gt; &quot;The compiler should not warn when a broader level of access control is used within a type with more restrictive access, such as `internal` within a `private` type. This allows the owner of the type to design the access they would use were they to make the type more widely accessible.&quot;<br>&gt; <br>&gt; Applying the same rationale here would suggest that the compiler should not raise an error if a method is marked `open` inside a non-`open` type, in order to allow the owner of the type to design as though to make it subclassable without actually having to do so.<br></p><p>That&#39;s true.  We&#39;ll consider this.<br></p><p>John.<br></p><p>&gt; <br>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Yes, I&#39;ve used OOP in other languages. As discussed, this approach is different from that taken by many of those but is a deliberate step.<br>&gt;  <br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Followed the discussion, read proposal carefully.<br>&gt;  <br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/221bfba5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; 2016/07/16 14:52、Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>+1 for the improved keywords and purgatory for objc imported modules.<br></p><p>This is much cleaner than the previous proposal, and cant wait to actually get to use this (as a framework author it literally makes me giddy).<br></p><p>Like others, I slightly wonder what will happen in The Real World™ (as a framework consumer) but if things end up too restrictive, it can always be changed down the road I would expect…?<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>Yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>This seems closer to Kotlin; not that I am much of a user of that language so maybe I am unqualified to say, but I think its nice to align with a good design that exists elsewhere… <br>Objc is of course the exact opposite of this, so it remains to be seen what the effect will be in this community...<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Been following this intensely since last year’s initial discussion, finally came out of the shadows to comment when it came up for review, and have been weighing and listening to arguments for and against; my only &quot;against&quot; feelings came about as a consumer of APIs not as a writer, so I want to make sure its apparent that any negatives I had in the past were from that perspective; I very much support the spirit of this proposal and appreciate those that took time to explain and assuage those concerns! What an amazing process this is. ^o^<br></p><p>-----------<br></p><p>One thing in the proposal:<br>The superclass of an open class must be open. &lt;snip/&gt;. These are conservative restrictions that reduce the scope of this proposal; it will be possible to revisit them in a later proposal.<br>Yes, maybe its an anit-pattern, but I definitely have made many private parent classes and have the child public… the above would mean that I cant do that, as open needs public… it would definitely be appreciated if that is revisited or at least the reasoning (e.g we really shouldn&#39;t be making subclasses of private superclasses public because XYZABC etc).<br></p><p>-----------<br></p><p>Thanks!!<br></p><p><br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/5f05fa99/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 as before but I do have concerns<br></p><p>	* Why do open classes need to have also have open superclasses? <br>	* I don’t think sealed methods/properties as default is the right default. <br>	* If the default was open for methods/properties, then do we really need the sealed keyword? Could’t we just use final for that?<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Requiring super classes to also be Open seems wrong. <br></p><p>I agree with Kevin Ballard on being open by default for methods/ properties http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/&gt;<br></p><p>If we are open by default for methods/properties then we could simplify things by just using final for methods that need to be sealed; I don’t see the need to have sealed methods/properties outside of the module ONLY. <br></p><p>We already have to mark all public methods/properties as public, if I need something not the be overridable then I can just use final. This would work the same across all classes. <br></p><p>If I was a framework author that initially just had a library that was sealed but then somebody asked me to make it open; All I would want to do is add open to the class only, I would not want to spend the time to go back an add open to all public methods/properties specially if I am already using final. I think having method/properties open by default is the best compromised. I can see framework authors switching a class to be open and expecting that everything in the class in open and if they don’t open any methods, then what possible use is a subclass than an extension could not provide? I think that is an overreach to make the framework author have to add open to every public method in addition to having to open every super class. As a framework author if I think my clients could use subclassing, all I want to do is flip a switch on the classes that I want to make subclass able  and then just push a new version. As a framework user I want to be able to tell my framework author “can you just add open to classes abs and deca etc.” I think it is more likely that I will get my request if it is easy vs it the framework author needs to touch every class in the hierarchy. <br></p><p><br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>n/a<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>reviewed previously and followed the update. <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/1ec5a9bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Le 16 juil. 2016 à 18:05, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 as before but I do have concerns<br>&gt; <br>&gt; 	* Why do open classes need to have also have open superclasses? <br>&gt; 	* I don’t think sealed methods/properties as default is the right default. <br>&gt; 	* If the default was open for methods/properties, then do we really need the sealed keyword? Could’t we just use final for that?<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Requiring super classes to also be Open seems wrong. <br></p><p>&gt; <br>&gt; I agree with Kevin Ballard on being open by default for methods/ properties http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/&gt;<br>&gt; <br>&gt; If we are open by default for methods/properties then we could simplify things by just using final for methods that need to be sealed; I don’t see the need to have sealed methods/properties outside of the module ONLY. <br>&gt; <br>&gt; We already have to mark all public methods/properties as public, if I need something not the be overridable then I can just use final. This would work the same across all classes. <br>&gt; <br>&gt; If I was a framework author that initially just had a library that was sealed but then somebody asked me to make it open; All I would want to do is add open to the class only, I would not want to spend the time to go back an add open to all public methods/properties specially if I am already using final. I think having method/properties open by default is the best compromised. I can see framework authors switching a class to be open and expecting that everything in the class in open and if they don’t open any methods, then what possible use is a subclass than an extension could not provide?<br></p><p>Extensions do not support stored properties (yet?). Subclasses do. That said, I agree that having an open class without any open member does not has much benefit, but I’m sure we can find a valid use case for such class.<br></p><p>&gt; I think that is an overreach to make the framework author have to add open to every public method in addition to having to open every super class. As a framework author if I think my clients could use subclassing, all I want to do is flip a switch on the classes that I want to make subclass able  and then just push a new version. As a framework user I want to be able to tell my framework author “can you just add open to classes abs and deca etc.” I think it is more likely that I will get my request if it is easy vs it the framework author needs to touch every class in the hierarchy. <br>&gt; <br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; n/a<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; reviewed previously and followed the update. <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/f67660ff/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 16 Jul 2016, at 18:05, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with Kevin Ballard on being open by default for methods/ properties http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/&gt;<br>&gt; <br>&gt; If we are open by default for methods/properties then we could simplify things by just using final for methods that need to be sealed; I don’t see the need to have sealed methods/properties outside of the module ONLY. <br></p><p>The proposal (and additional comments) explain this point fairly well. Usually, it makes sense to be overridable only for few select members — and compiler can’t easily figure out which entry points these are as the API invariants are not explicit. By making members sealed by default, the API contracts are made more clear.  Second (and a very important reason) is performance — if everything is open by default, the compiler can’t devirtualize property accessors even though it would be appropriate most of the time. The compiler can infer the ‚final‘ status of definitions within a module easily and optimise accordingly, which wot work if these definitions can be overridden externally. To put it differently, its much easier for the compiler to determine what can be safely considered final than what can be safely considered sealed. The design choices in the proposal follow naturally from these considerations. <br></p><p>The final keyword still has its use, although I think its utility will be somewhat diminished after this proposal. You can still use it for things that can’t be overridden internally. Like classes that are intended only to be used as ‚structs  with reference semantics‘. <br></p><p>— T<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/4b77c72a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 9:18 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 Jul 2016, at 18:05, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree with Kevin Ballard on being open by default for methods/ properties http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/&gt;<br>&gt;&gt; <br>&gt;&gt; If we are open by default for methods/properties then we could simplify things by just using final for methods that need to be sealed; I don’t see the need to have sealed methods/properties outside of the module ONLY. <br>&gt; <br>&gt; The proposal (and additional comments) explain this point fairly well. Usually, it makes sense to be overridable only for few select members — and compiler can’t easily figure out which entry points these are as the API invariants are not explicit. By making members sealed by default, the API contracts are made more clear.  Second (and a very important reason) is performance — if everything is open by default, the compiler can’t devirtualize property accessors even though it would be appropriate most of the time. The compiler can infer the ‚final‘ status of definitions within a module easily and optimise accordingly, which wot work if these definitions can be overridden externally. To put it differently, its much easier for the compiler to determine what can be safely considered final than what can be safely considered sealed. The design choices in the proposal follow naturally from these considerations. <br></p><p>The compiler is welcome to optimize my sealed classes but once I slap `open` on the class, I am telling the compiler that I am not interested in the automatic optimizations imo.<br></p><p>&gt; <br>&gt; The final keyword still has its use, although I think its utility will be somewhat diminished after this proposal. You can still use it for things that can’t be overridden internally. Like classes that are intended only to be used as ‚structs  with reference semantics’. <br>struct with reference semantics is what sealed classes are, but once I make the class open, i’d like for it to act like a regular subclassable class.<br></p><p><br>&gt; <br>&gt; — T<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/4885965d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 9:05 AM, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 as before but I do have concerns<br>&gt; <br>&gt; 	* Why do open classes need to have also have open superclasses?<br></p><p>I talk about this in the proposal; this is a possible avenue of future extension.  I wanted to keep this proposal small, and requiring the whole hierarchy to be open avoids a number of design problems.<br> <br>&gt; 	* I don’t think sealed methods/properties as default is the right default. <br>&gt; 	* If the default was open for methods/properties, then do we really need the sealed keyword? Could’t we just use final for that?<br></p><p>There is no &quot;sealed&quot; keyword in the proposal.<br></p><p>Since we&#39;re naming open &quot;open&quot;, if we need a reverse, we would probably use &quot;closed&quot; or &quot;nonopen&quot; for it.  &quot;sealed&quot; is a common term for this kind of feature, and it&#39;s the one we&#39;ve been using in this discussion, but unfortunately &quot;sealed&quot; is not a natural opposite of &quot;open&quot;.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Requiring super classes to also be Open seems wrong. <br>&gt; <br>&gt; I agree with Kevin Ballard on being open by default for methods/ properties http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23467/&gt;<br>&gt; <br>&gt; If we are open by default for methods/properties then we could simplify things by just using final for methods that need to be sealed; I don’t see the need to have sealed methods/properties outside of the module ONLY. <br>&gt; <br>&gt; We already have to mark all public methods/properties as public, if I need something not the be overridable then I can just use final. This would work the same across all classes. <br>&gt; <br>&gt; If I was a framework author that initially just had a library that was sealed but then somebody asked me to make it open; All I would want to do is add open to the class only, I would not want to spend the time to go back an add open to all public methods/properties specially if I am already using final. I think having method/properties open by default is the best compromised. I can see framework authors switching a class to be open and expecting that everything in the class in open and if they don’t open any methods, then what possible use is a subclass than an extension could not provide? I think that is an overreach to make the framework author have to add open to every public method in addition to having to open every super class. As a framework author if I think my clients could use subclassing, all I want to do is flip a switch on the classes that I want to make subclass able  and then just push a new version. As a framework user I want to be able to tell my framework author “can you just add open to classes abs and deca etc.” I think it is more likely that I will get my request if it is easy vs it the framework author needs to touch every class in the hierarchy. <br>&gt; <br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; n/a<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; reviewed previously and followed the update. <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/eba357a5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 17, 2016 at 04:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 16, 2016, at 7:52 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br></p><p>Part of a series of increasingly compelling arguments for switching other languages for writting ios/osx application, provided that that is not also prohibited in the various stores in the near future<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No. I&#39;ll self censor the rest as it is not flatering<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Feel: not surewhat the feel of swifft is supposed to be anymore<br>Direction: yes... training wheels all around, limited abilitiy to organize &amp; structure code (other key features missing for that &amp; plenty of real life examples on github to show this is actually the case)<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The bulk my professional experience has been mostly with asm x86, c, c++, perl, java, scala, tcl/tk, go, xtend, vb, c#, fortran, cobol, javascript and recently TypeScript. None have something equivalent. I recently started toying with kotlin, that looks at inheritence in a similar light, but do not have enough real life experience yet to speak.<br>As for TypeScript, I only recently started writing large amounts of it professionally, and I am absolutely blown away: it has been the easiest language to learn and become extremely productive with, thanks to the most sound generic type system I have ever used (for bkgrnd, I love and makes very heavy use of the java/c# generics). <br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A lot.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 17, 2016 at 04:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 17, 2016, at 4:24 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jul 16, 2016, at 7:52 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;   * What is your evaluation of the proposal?<br>&gt; <br>&gt; Part of a series of increasingly compelling arguments for switching other languages for writting ios/osx application, provided that that is not also prohibited in the various stores in the near future<br>&gt; <br>&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; No. I&#39;ll self censor the rest as it is not flatering<br></p><p>The jist is that, as demonstrated by the discussions in the original thread, the proposal as it is worded is incomplete, paving the way to a 0111 scenario if rushed to approval as is. <br></p><p>&gt; <br>&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Feel: not surewhat the feel of swifft is supposed to be anymore<br>&gt; Direction: yes... training wheels all around, limited abilitiy to organize &amp; structure code (other key features missing for that &amp; plenty of real life examples on github to show this is actually the case)<br>&gt; <br>&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; The bulk my professional experience has been mostly with asm x86, c, c++, perl, java, scala, tcl/tk, go, xtend, vb, c#, fortran, cobol, javascript and recently TypeScript. None have something equivalent. I recently started toying with kotlin, that looks at inheritence in a similar light, but do not have enough real life experience yet to speak.<br>&gt; As for TypeScript, I only recently started writing large amounts of it professionally, and I am absolutely blown away: it has been the easiest language to learn and become extremely productive with, thanks to the most sound generic type system I have ever used (for bkgrnd, I love and makes very heavy use of the java/c# generics). <br>&gt; <br>&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A lot.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 17, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jul 15, 2016, at 10:52 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I agree with the core team that closed by default for classes is the right move.<br></p><p>I also think that it makes sense for methods to be closed by default. **However**, I am seriously concerned about the source-code impact of this change. I believe there are at least an order of magnitude more public member declarations than public class declarations in most projects. For instance, I attempted (using crude, most likely imperfect regex-based algorithms) to estimate the number of classes, methods, properties, and subscripts in Corelibs Foundation, and got these results:<br></p><p>	class: 120<br>	func: 1277<br>	subscript: 6<br>	var: 707<br></p><p>(Note: I removed obviously incorrect things like top-level constants and functions, but these numbers probably still count some struct and enum members.)<br></p><p>Annotating 120 types is not that big a deal relative to the size of Foundation. Annotating 1,990 members introduces much more clutter and tremendously increases the burden of closed-by-default. I don&#39;t think I can support burdening that many declarations with extra syntax; it seems like a lot of red tape for a case where you&#39;ve already explicitly opted in to subclassing.<br></p><p>That&#39;s why I prefer the alternative design of having `open` as a separate access level. I don&#39;t think it is a serious burden to have to search for &quot;public|open&quot; when you want to see all public APIs. Nor do I think it&#39;s a problem that `open` is short. A short keyword would be a problem if our goal is to actually *discourage* subclassing, but if we merely want people to *think* before they subclass, we should be happy that permitting subclassing and overriding is not encumbered with heavyweight keywords.<br></p><p>Meanwhile, the benefits of an `open` access level are manifold:<br></p><p>* It ensures that unsealing is no more burdensome than sealing.<br></p><p>* There&#39;s no need for a &quot;you can&#39;t declare it open because it&#39;s not public&quot; diagnostic.<br></p><p>* It defuses one of the complaints about this change from its critics, easing acceptance.<br></p><p>As an alternative to having `open` as a separate access level, we could instead have it merely imply `public`: the canonical form would be `public open`, but source code could just say `open`. Generated interfaces would always say `public open`, so searching for `public` in those would work as you want it to.<br></p><p>So, in short:<br></p><p>1. Yes on closed classes by default.<br></p><p>2. No on closed members by default, unless we use a syntax less burdensome than `public open`.<br></p><p>3. I think the arguments against standalone `open` are weak, and I would strongly prefer it to `public open`.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve used OO languages, but not sealing ones.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading of this draft, but deep involvement in previous reviews and discussions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 17, 2016 at 04:00:00pm</p></header><div class="content"><p>As an alternative to having `open` as a separate access level, we could instead have it merely imply `public`: the canonical form would be `public open`, but source code could just say `open`. Generated interfaces would always say `public open`, so searching for `public` in those would work as you want it to.<br> <br> <br> <br> <br> <br>I would not support this. Open and public are orthogonal concepts, just like final and public are today.<br> <br></p><p> <br>Just because your internal implementation details involve classes and subclasses, you shouldn&#39;t have to expose that to the whole world.<br> <br></p><p> <br>I think it should be an attribute/qualifier on the access level (similar to mutability for properties). You may wish to allow internal subclassing while preventing external subclassing (e.g. The API isn&#39;t stable yet, you&#39;re thinking of opening it publicly later but you want to refine it through internal usage first).<br> <br></p><p> <br>Or, as I mentioned before, perhaps you are forced to return an &quot;abstract&quot; class because we don&#39;t have sealed protocols.<br> <br></p><p> <br>These are all decisions for the API author, and by having the openness scopes to access level we give them ultimate flexibility to annotate which parts of their API can be replaced and by whom.<br> <br></p><p> <br>Karl<br> <br> <br> <br>&gt;  <br>&gt;  <br>&gt;  <br>&gt;<br>&gt;        <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160717/b5f05898/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 17, 2016 at 12:00:00pm</p></header><div class="content"><p>Is there a summary somewhere of the motivation for allowing methods to be declared non-overridable within open classes?<br></p><p>I’m not asking about any particular syntax or default, just why you&#39;d want this facility at all. The proposal doesn’t mention this, and the discussion of the initial version never really seemed to reach the issue, either.<br></p><p>I can see that there’s a potential for static dispatch on non-overridable methods when called from outside the module. But presumably there’s an architectural argument in favor of this restriction as well.<br></p><p>Garth<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 17, 2016 at 03:00:00pm</p></header><div class="content"><p>I too would be interested in this info. Brent&#39;s numbers look daunting<br>indeed (nearly 2000 annotations for methods and properties in<br>corelibs-foundation alone). What use cases are supported by<br>sealed-but-not-final public methods in open classes?<br></p><p><br>On Sun, Jul 17, 2016 at 2:14 PM, Garth Snyder via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is there a summary somewhere of the motivation for allowing methods to be<br>&gt; declared non-overridable within open classes?<br>&gt;<br>&gt; I’m not asking about any particular syntax or default, just why you&#39;d want<br>&gt; this facility at all. The proposal doesn’t mention this, and the discussion<br>&gt; of the initial version never really seemed to reach the issue, either.<br>&gt;<br>&gt; I can see that there’s a potential for static dispatch on non-overridable<br>&gt; methods when called from outside the module. But presumably there’s an<br>&gt; architectural argument in favor of this restriction as well.<br>&gt;<br>&gt; Garth<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160717/ea14a729/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 05:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a summary somewhere of the motivation for allowing methods to be declared non-overridable within open classes?<br>&gt; <br>&gt; I’m not asking about any particular syntax or default, just why you&#39;d want this facility at all. The proposal doesn’t mention this, and the discussion of the initial version never really seemed to reach the issue, either.<br>&gt; <br>&gt; I can see that there’s a potential for static dispatch on non-overridable methods when called from outside the module. But presumably there’s an architectural argument in favor of this restriction as well.<br></p><p>Because 1) someone woke up one morning and thought it would be great 2) it goes into the direction of making swift a language for non programmers 3) the core team wants it<br></p><p><br>&gt; <br>&gt; Garth<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 18, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a summary somewhere of the motivation for allowing methods to be declared non-overridable within open classes?<br>&gt; <br>&gt; Because 1) someone woke up one morning and thought it would be great 2) it goes into the direction of making swift a language for non programmers 3) the core team wants it<br></p><p>Laurent: This is not a fair characterization of the actual position of the proposal&#39;s supporters. If you can&#39;t be civil about this topic, perhaps you shouldn&#39;t be discussing it at all.<br></p><p>Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The mere fact that a class allows subclassing doesn&#39;t necessarily mean that every member in it is designed to be subclassed. Consider `UIViewController`: It&#39;s obviously designed to be subclassed, and some methods in it (such as `loadView`) are intended to be overridden, but others (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 04:00:00am</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is there a summary somewhere of the motivation for allowing methods to<br>&gt; be declared non-overridable within open classes?<br>&gt; &gt;<br>&gt; &gt; Because 1) someone woke up one morning and thought it would be great 2)<br>&gt; it goes into the direction of making swift a language for non programmers<br>&gt; 3) the core team wants it<br>&gt;<br>&gt; Laurent: This is not a fair characterization of the actual position of the<br>&gt; proposal&#39;s supporters. If you can&#39;t be civil about this topic, perhaps you<br>&gt; shouldn&#39;t be discussing it at all.<br>&gt;<br>&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The<br>&gt; mere fact that a class allows subclassing doesn&#39;t necessarily mean that<br>&gt; every member in it is designed to be subclassed. Consider<br>&gt; `UIViewController`: It&#39;s obviously designed to be subclassed, and some<br>&gt; methods in it (such as `loadView`) are intended to be overridden, but<br>&gt; others (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br></p><p><br>And [if UIViewController were to be written in Swift] there&#39;d be a good<br>reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final?<br></p><p><br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/ba535f7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 18 Jul 2016, at 11:11, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a summary somewhere of the motivation for allowing methods to be declared non-overridable within open classes?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Because 1) someone woke up one morning and thought it would be great 2) it goes into the direction of making swift a language for non programmers 3) the core team wants it<br>&gt;&gt; <br>&gt;&gt; Laurent: This is not a fair characterization of the actual position of the proposal&#39;s supporters. If you can&#39;t be civil about this topic, perhaps you shouldn&#39;t be discussing it at all.<br>&gt;&gt; <br>&gt;&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The mere fact that a class allows subclassing doesn&#39;t necessarily mean that every member in it is designed to be subclassed. Consider `UIViewController`: It&#39;s obviously designed to be subclassed, and some methods in it (such as `loadView`) are intended to be overridden, but others (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt; <br>&gt; And [if UIViewController were to be written in Swift] there&#39;d be a good reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final? <br></p><p>I don&#39;t know UIKit internals, but I could imagine loadViewIfNeeded be overridden internally, if one knows the precise internal workings of UIViewController. That would require open, to allow overriding internally but not externally.<br></p><p>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/4aa8a469/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>On Jul 18, 2016, at 10:27 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a summary somewhere of the motivation for allowing methods to be declared non-overridable within open classes?<br>&gt;&gt; <br>&gt;&gt; Because 1) someone woke up one morning and thought it would be great 2) it goes into the direction of making swift a language for non programmers 3) the core team wants it<br>&gt; <br>&gt; Laurent: This is not a fair characterization of the actual position of the proposal&#39;s supporters. If you can&#39;t be civil about this topic, perhaps you shouldn&#39;t be discussing it at all.<br></p><p>It was not my intention to depict the intentions of the community but simply to state a couple facts. 1) Some proposal are born out of the evolution of another proposal, while others evolve as a subset of something more complex that needs to be broken down. This one did not, and was simply presented one morning. 2) The wwdc this year was very clear on the fact that one of the goals of the platform via swift is to put the language into the hands of non-professional programmers. The video was very well done and very inspirational. The new ipad playground app is a key part of this strategy, the other one being the language. The language has undergone great simplifications since the days of 1.xx with advanced features like tupple splatting or currying now removed, and confusing naming or constructs also gradually removed (3.0 is a very big step in ghat direction). 3) the core team was very clear that it is the direction they want for the language.<br></p><p>&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The mere fact that a class allows subclassing doesn&#39;t necessarily mean that every member in it is designed to be subclassed. Consider `UIViewController`: It&#39;s obviously designed to be subclassed, and some methods in it (such as `loadView`) are intended to be overridden, but others (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 17, 2016, at 7:29 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; Open and public are orthogonal concepts, just like final and public are today.<br></p><p>Are they? Given that &quot;open&quot; *means* &quot;subclassable/overridable in public scope&quot;, what would it mean for something to be open, but not public? `final` *is* orthogonal, but I&#39;m not sure `open` is.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 20, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 17 Jul 2016, at 23:37, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 17, 2016, at 7:29 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Open and public are orthogonal concepts, just like final and public are today.<br>&gt; <br>&gt; Are they? Given that &quot;open&quot; *means* &quot;subclassable/overridable in public scope&quot;, what would it mean for something to be open, but not public? `final` *is* orthogonal, but I&#39;m not sure `open` is.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p><br>Well that’s the point - we disagree on what “open” means. I don’t agree that the “in public scope” qualifier is necessary.<br></p><p>Why are we doing this at all? Because we recognise that writing good base classes is hard.<br>Why is writing good base classes hard? Because it’s difficult to locally reason about your code when members may be substituted by third parties.<br></p><p>So what does this solution do? It explicitly annotates those members which may be substituted.<br></p><p>This is a general problem - it doesn’t just affect publicly-accessible base classes, but also internal ones. It’s okay to be a bit sloppy with only-internally-open classes because you completely control every substitution, so you can fix any bugs later with an isolated library update. That is the only reason anybody could have for limiting “open” to public scope, as far as I’ve been able to tell — because it makes it easier to be sloppier.<br></p><p>Still, I believe it would not do us any harm, and would actually do quite a bit of good (in light of the Swift API Design guidelines, which promote code which is easy to locally-reason about) if we applied this reasoning to all access scopes.<br></p><p>That is to say, we basically introduce “open&quot; as an inverted “final”, and make all classes non-open by default. That is analogous to enabling whole-module-optimisation by default, in my opinion. The cost of an extra four-letter word isn’t that great, but the benefits to readability and reasonability all-around make it worthwhile.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b82ec7032daa9f5ac2c8aa489770557?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Peter Livesey</string> &lt;pdlivesey at gmail.com&gt;<p>July 20, 2016 at 03:00:00am</p></header><div class="content"><p>Just to clarify Karl, with your idea here, final wouldn&#39;t be necessary<br>right? Since everything is already final by default?<br>On Tue, Jul 19, 2016 at 6:15 PM Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 17 Jul 2016, at 23:37, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 17, 2016, at 7:29 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Open and public are orthogonal concepts, just like final and public are<br>&gt; today.<br>&gt; &gt;<br>&gt; &gt; Are they? Given that &quot;open&quot; *means* &quot;subclassable/overridable in public<br>&gt; scope&quot;, what would it mean for something to be open, but not public?<br>&gt; `final` *is* orthogonal, but I&#39;m not sure `open` is.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; Well that’s the point - we disagree on what “open” means. I don’t agree<br>&gt; that the “in public scope” qualifier is necessary.<br>&gt;<br>&gt; Why are we doing this at all? Because we recognise that writing good base<br>&gt; classes is hard.<br>&gt; Why is writing good base classes hard? Because it’s difficult to locally<br>&gt; reason about your code when members may be substituted by third parties.<br>&gt;<br>&gt; So what does this solution do? It explicitly annotates those members which<br>&gt; may be substituted.<br>&gt;<br>&gt; This is a general problem - it doesn’t just affect publicly-accessible<br>&gt; base classes, but also internal ones. It’s okay to be a bit sloppy with<br>&gt; only-internally-open classes because you completely control every<br>&gt; substitution, so you can fix any bugs later with an isolated library<br>&gt; update. That is the only reason anybody could have for limiting “open” to<br>&gt; public scope, as far as I’ve been able to tell — because it makes it easier<br>&gt; to be sloppier.<br>&gt;<br>&gt; Still, I believe it would not do us any harm, and would actually do quite<br>&gt; a bit of good (in light of the Swift API Design guidelines, which promote<br>&gt; code which is easy to locally-reason about) if we applied this reasoning to<br>&gt; all access scopes.<br>&gt;<br>&gt; That is to say, we basically introduce “open&quot; as an inverted “final”, and<br>&gt; make all classes non-open by default. That is analogous to enabling<br>&gt; whole-module-optimisation by default, in my opinion. The cost of an extra<br>&gt; four-letter word isn’t that great, but the benefits to readability and<br>&gt; reasonability all-around make it worthwhile.<br>&gt;<br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/620a86c3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 20, 2016 at 12:00:00am</p></header><div class="content"><p>I am ok with moving the public requirement for sealed-by-default. I have<br>one qualm though. This would actually make starting out with the language a<br>suboptimal experience. As (before, really) I teach what subclassing is, I<br>have to explain this keyword to make subclassing possible. That sounds good<br>until I realize that I should explain when you would want to add this<br>keyword and I still haven&#39;t even gotten into what subclassing is yet.<br></p><p>On Tue, Jul 19, 2016 at 9:14 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 17 Jul 2016, at 23:37, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 17, 2016, at 7:29 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Open and public are orthogonal concepts, just like final and public are<br>&gt; today.<br>&gt; &gt;<br>&gt; &gt; Are they? Given that &quot;open&quot; *means* &quot;subclassable/overridable in public<br>&gt; scope&quot;, what would it mean for something to be open, but not public?<br>&gt; `final` *is* orthogonal, but I&#39;m not sure `open` is.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; Well that’s the point - we disagree on what “open” means. I don’t agree<br>&gt; that the “in public scope” qualifier is necessary.<br>&gt;<br>&gt; Why are we doing this at all? Because we recognise that writing good base<br>&gt; classes is hard.<br>&gt; Why is writing good base classes hard? Because it’s difficult to locally<br>&gt; reason about your code when members may be substituted by third parties.<br>&gt;<br>&gt; So what does this solution do? It explicitly annotates those members which<br>&gt; may be substituted.<br>&gt;<br>&gt; This is a general problem - it doesn’t just affect publicly-accessible<br>&gt; base classes, but also internal ones. It’s okay to be a bit sloppy with<br>&gt; only-internally-open classes because you completely control every<br>&gt; substitution, so you can fix any bugs later with an isolated library<br>&gt; update. That is the only reason anybody could have for limiting “open” to<br>&gt; public scope, as far as I’ve been able to tell — because it makes it easier<br>&gt; to be sloppier.<br>&gt;<br>&gt; Still, I believe it would not do us any harm, and would actually do quite<br>&gt; a bit of good (in light of the Swift API Design guidelines, which promote<br>&gt; code which is easy to locally-reason about) if we applied this reasoning to<br>&gt; all access scopes.<br>&gt;<br>&gt; That is to say, we basically introduce “open&quot; as an inverted “final”, and<br>&gt; make all classes non-open by default. That is analogous to enabling<br>&gt; whole-module-optimisation by default, in my opinion. The cost of an extra<br>&gt; four-letter word isn’t that great, but the benefits to readability and<br>&gt; reasonability all-around make it worthwhile.<br>&gt;<br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/6f21a3fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 19, 2016 at 09:00:00pm</p></header><div class="content"><p>The keyword `open` would only be required to allow subclassing **outside** of the module. You will still be able to subclass inside the module as long as it isn’t marked as `final`.<br></p><p>This proposal wants classes to be `final`-by-default **outside** of the module and subclassable by default inside the module.<br></p><p>This is about making sure developers don’t accidentally release an API promising a more than they’re able to support. Once they decide that (a) a class won’t break when subclassed and (b) they’d like to support subclassing for that class until the next breaking change, they annotate the class with `open`.<br></p><p>&gt; On Jul 19, 2016, at 9:42 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am ok with moving the public requirement for sealed-by-default. I have one qualm though. This would actually make starting out with the language a suboptimal experience. As (before, really) I teach what subclassing is, I have to explain this keyword to make subclassing possible. That sounds good until I realize that I should explain when you would want to add this keyword and I still haven&#39;t even gotten into what subclassing is yet. <br>&gt; <br>&gt; On Tue, Jul 19, 2016 at 9:14 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On 17 Jul 2016, at 23:37, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 17, 2016, at 7:29 AM, Karl Wagner &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Open and public are orthogonal concepts, just like final and public are today.<br>&gt; &gt;<br>&gt; &gt; Are they? Given that &quot;open&quot; *means* &quot;subclassable/overridable in public scope&quot;, what would it mean for something to be open, but not public? `final` *is* orthogonal, but I&#39;m not sure `open` is.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; <br>&gt; <br>&gt; Well that’s the point - we disagree on what “open” means. I don’t agree that the “in public scope” qualifier is necessary.<br>&gt; <br>&gt; Why are we doing this at all? Because we recognise that writing good base classes is hard.<br>&gt; Why is writing good base classes hard? Because it’s difficult to locally reason about your code when members may be substituted by third parties.<br>&gt; <br>&gt; So what does this solution do? It explicitly annotates those members which may be substituted.<br>&gt; <br>&gt; This is a general problem - it doesn’t just affect publicly-accessible base classes, but also internal ones. It’s okay to be a bit sloppy with only-internally-open classes because you completely control every substitution, so you can fix any bugs later with an isolated library update. That is the only reason anybody could have for limiting “open” to public scope, as far as I’ve been able to tell — because it makes it easier to be sloppier.<br>&gt; <br>&gt; Still, I believe it would not do us any harm, and would actually do quite a bit of good (in light of the Swift API Design guidelines, which promote code which is easy to locally-reason about) if we applied this reasoning to all access scopes.<br>&gt; <br>&gt; That is to say, we basically introduce “open&quot; as an inverted “final”, and make all classes non-open by default. That is analogous to enabling whole-module-optimisation by default, in my opinion. The cost of an extra four-letter word isn’t that great, but the benefits to readability and reasonability all-around make it worthwhile.<br>&gt; <br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/d1edad1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 20 Jul 2016, at 06:57, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt; <br>&gt; The keyword `open` would only be required to allow subclassing **outside** of the module. You will still be able to subclass inside the module as long as it isn’t marked as `final`.<br>&gt; <br>&gt; This proposal wants classes to be `final`-by-default **outside** of the module and subclassable by default inside the module.<br>&gt; <br>&gt; This is about making sure developers don’t accidentally release an API promising a more than they’re able to support. Once they decide that (a) a class won’t break when subclassed and (b) they’d like to support subclassing for that class until the next breaking change, they annotate the class with `open`.<br></p><p>Yeah, I very much do not support that. It creates additional complexity - all of these strange esoteric discussions we’re having about what should be, really, a pretty simple thing. I don’t want to have to remember all kinds of complicated rules what becomes ‘final’ and what becomes ‘open’ or what the defaults might be (if they’re not obvious) and how all of these other complex subclass rules apply. Just tag the things that can be subclassed - it’s all scoped to existing access scopes. Simple and easy to remember.<br></p><p>@Peter: Yes, final would be implied on all classes. You would be able to “open” them to remove that restriction, and it would be scoped to existing access scopes (as we do already for setter visibility). I.e.:<br></p><p>public internal(open) class MyAbstractBaseClass {<br></p><p>	// Contains some members which all fatalError()<br>}<br></p><p>private MySpecialisedClass : MyAbstractBaseClass { <br></p><p>	// Specialised stuff here<br>}<br></p><p>Compare with the modifiers for class members:<br></p><p>public internal(set) myInternalVariable : Int32<br></p><p>Not only that, but it’s immediately clear by looking at MyAbstractBaseClass who is subclassing it. Compare with an implicit internal open and non-implicit public open (as in the proposal):<br></p><p>public class MyAbstractBaseClass {<br></p><p>	// Contains some members which all fatalError()<br>}<br></p><p>I think my suggestion improves local reasonability and simplifies the syntax requires considerably.<br></p><p>Like I said, I can’t see the reasoning behind limiting “open” to public classes. It’s just a concession to allow sloppiness inside of your own module, but even then - for complex internal classes with a mixture of overridable and non-overridable members, having to declare those “open” could even be of benefit. If it’s such a big problem, perhaps we can invent some kind of shorthand on the class attribute to declare all of its members overridable (like &quot;open-all” or something).<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/fd50afe4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 20, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jul 19, 2016, at 6:14 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is to say, we basically introduce “open&quot; as an inverted “final”, and make all classes non-open by default. That is analogous to enabling whole-module-optimisation by default, in my opinion. The cost of an extra four-letter word isn’t that great, but the benefits to readability and reasonability all-around make it worthwhile.<br></p><p>Okay, but this ignores an important difference between sealed and final.<br></p><p>Sealed is *non-committal*. It makes no promises to wider scopes about whether there are other subclasses/overrides; it merely states that code outside the module may not subclass/override. `final`, on the other hand, is an *affirmative* statement: there are no subclasses/overrides and there never will be. Code outside the module is permitted to rely on that fact—for instance, it can generate static calls and conflate dynamic Self with static Self in conformances.<br></p><p>But this distinction only really makes sense at the `public` boundary, because that&#39;s where the compiler—and even the developer—faces an impenetrable encapsulation barrier. If you want to require `open` even on non-public declarations, you thus need to choose one of these designs:<br></p><p>	1. `final` is still available, but only on public APIs.<br></p><p>	2. All non-public classes have to be explicitly declared either `open` or `final`.<br></p><p>	3. Sealed has some sort of complex, scope-specific design (for instance, an `internal` class can be subclassed in `fileprivate` but not in `internal` scope).<br></p><p>Of these three, I think that #2 is overly bureaucratic and #3 is overly complicated, so only #1 is a viable option. And then we&#39;re just choosing whether we have internal subclassing by default and an odd public-only `open` keyword, or no internal subclassing by default and an odd public-only `final` keyword. No viable option avoids some kind of asymmetry at the `public` boundary.<br></p><p>Open-by-default with a `final` keyword is the traditional design. It is simpler for people learning to program and more familiar for people new to Swift. It is more convenient. And you just don&#39;t need the same rigorous, formal definition of semantics in internal scope, where you can alter a problematic invariant rather than having to live with it.<br></p><p>All that said, there most likely *is* value in declaring, even internally, which classes are meant to be subclassed and which members are meant to be overridden. Perhaps what we ought to do is permit `open` even on non-public APIs, but not enforce it (or rather, leave enforcement to linters). That would allow people and teams to explicitly document internal overriding behavior if they want to, without burdening the teams that don&#39;t want to go to the effort.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 20 Jul 2016, at 11:07, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 19, 2016, at 6:14 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That is to say, we basically introduce “open&quot; as an inverted “final”, and make all classes non-open by default. That is analogous to enabling whole-module-optimisation by default, in my opinion. The cost of an extra four-letter word isn’t that great, but the benefits to readability and reasonability all-around make it worthwhile.<br>&gt; <br>&gt; Okay, but this ignores an important difference between sealed and final.<br>&gt; <br>&gt; Sealed is *non-committal*. It makes no promises to wider scopes about whether there are other subclasses/overrides; it merely states that code outside the module may not subclass/override. `final`, on the other hand, is an *affirmative* statement: there are no subclasses/overrides and there never will be. Code outside the module is permitted to rely on that fact—for instance, it can generate static calls and conflate dynamic Self with static Self in conformances.<br>&gt; <br>&gt; But this distinction only really makes sense at the `public` boundary, because that&#39;s where the compiler—and even the developer—faces an impenetrable encapsulation barrier. If you want to require `open` even on non-public declarations, you thus need to choose one of these designs:<br>&gt; <br>&gt; 	1. `final` is still available, but only on public APIs.<br>&gt; <br>&gt; 	2. All non-public classes have to be explicitly declared either `open` or `final`.<br>&gt; <br>&gt; 	3. Sealed has some sort of complex, scope-specific design (for instance, an `internal` class can be subclassed in `fileprivate` but not in `internal` scope).<br>&gt; <br>&gt; Of these three, I think that #2 is overly bureaucratic and #3 is overly complicated, so only #1 is a viable option. And then we&#39;re just choosing whether we have internal subclassing by default and an odd public-only `open` keyword, or no internal subclassing by default and an odd public-only `final` keyword. No viable option avoids some kind of asymmetry at the `public` boundary.<br>&gt; <br>&gt; Open-by-default with a `final` keyword is the traditional design. It is simpler for people learning to program and more familiar for people new to Swift. It is more convenient. And you just don&#39;t need the same rigorous, formal definition of semantics in internal scope, where you can alter a problematic invariant rather than having to live with it.<br>&gt; <br>&gt; All that said, there most likely *is* value in declaring, even internally, which classes are meant to be subclassed and which members are meant to be overridden. Perhaps what we ought to do is permit `open` even on non-public APIs, but not enforce it (or rather, leave enforcement to linters). That would allow people and teams to explicitly document internal overriding behavior if they want to, without burdening the teams that don&#39;t want to go to the effort.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p><br>This is exactly what I&#39;m talking about - this is actually a very simple discussion. Throwing around words like “non-committal” and “affirmative” and speaking abstractly doesn’t disguise the brunt of what you’re saying: limiting “open” to public classes only lets you be sloppy inside your own module. That’s the only reason to make it like that. If I were describing the concept of “sloppiness” while trying my hardest not to use the word itself, I would probably say pretty much what you just wrote - wanting to remain non-committal, avoid definite, affirmative statements, etc.<br></p><p>If we think it is important for people who write classes to locally reason about their code, it’s important full stop. The conflation between if it’s publicly accessible and whether or not is a staggeringly massive regression in read&amp;reason-ability, no matter how matter how you want to phrase it. It’s a general problem which deserves a general solution - not some ‘non-committal’ proposal which can&#39;t even commit to the problem it is trying to help with.<br></p><p>If you’ve ever had to deal with complex base classes, consisting of a mixture of internal (and possibly internally subclassed) members and public ones, you would know that annotating which members are to be used by what (and knowing that it’s enforced by the compiler) would be a massive improvement to our language syntax. Sometimes you didn’t write all the code you have to work with, so it’s handy to have code which annotates this stuff.<br></p><p><br>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>July 21, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;  limiting “open” to public classes only lets you be sloppy inside your<br>own module.<br></p><p>I don&#39;t find that idea bad actually.<br></p><p>In the similar vein one can say &quot;it&#39;s ok to be sloppy with local variable<br>names, it&#39;s not ok to be sloppy with instance variable names&quot;.<br></p><p>Again, tradeoffs. You can require that things are perfect, so that all<br>methods are thoughtfully annotated, and all variables have wonderful<br>self-descriptive names, but you&#39;ll get most bang for the buck by requiring<br>that for the interface (public classes / instance variables) rather than<br>for the implementation (non-public classes / local variables).<br></p><p><br></p><p><br>On Thu, Jul 21, 2016 at 12:26 AM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 20 Jul 2016, at 11:07, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 19, 2016, at 6:14 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That is to say, we basically introduce “open&quot; as an inverted “final”,<br>&gt; and make all classes non-open by default. That is analogous to enabling<br>&gt; whole-module-optimisation by default, in my opinion. The cost of an extra<br>&gt; four-letter word isn’t that great, but the benefits to readability and<br>&gt; reasonability all-around make it worthwhile.<br>&gt; &gt;<br>&gt; &gt; Okay, but this ignores an important difference between sealed and final.<br>&gt; &gt;<br>&gt; &gt; Sealed is *non-committal*. It makes no promises to wider scopes about<br>&gt; whether there are other subclasses/overrides; it merely states that code<br>&gt; outside the module may not subclass/override. `final`, on the other hand,<br>&gt; is an *affirmative* statement: there are no subclasses/overrides and there<br>&gt; never will be. Code outside the module is permitted to rely on that<br>&gt; fact—for instance, it can generate static calls and conflate dynamic Self<br>&gt; with static Self in conformances.<br>&gt; &gt;<br>&gt; &gt; But this distinction only really makes sense at the `public` boundary,<br>&gt; because that&#39;s where the compiler—and even the developer—faces an<br>&gt; impenetrable encapsulation barrier. If you want to require `open` even on<br>&gt; non-public declarations, you thus need to choose one of these designs:<br>&gt; &gt;<br>&gt; &gt;       1. `final` is still available, but only on public APIs.<br>&gt; &gt;<br>&gt; &gt;       2. All non-public classes have to be explicitly declared either<br>&gt; `open` or `final`.<br>&gt; &gt;<br>&gt; &gt;       3. Sealed has some sort of complex, scope-specific design (for<br>&gt; instance, an `internal` class can be subclassed in `fileprivate` but not in<br>&gt; `internal` scope).<br>&gt; &gt;<br>&gt; &gt; Of these three, I think that #2 is overly bureaucratic and #3 is overly<br>&gt; complicated, so only #1 is a viable option. And then we&#39;re just choosing<br>&gt; whether we have internal subclassing by default and an odd public-only<br>&gt; `open` keyword, or no internal subclassing by default and an odd<br>&gt; public-only `final` keyword. No viable option avoids some kind of asymmetry<br>&gt; at the `public` boundary.<br>&gt; &gt;<br>&gt; &gt; Open-by-default with a `final` keyword is the traditional design. It is<br>&gt; simpler for people learning to program and more familiar for people new to<br>&gt; Swift. It is more convenient. And you just don&#39;t need the same rigorous,<br>&gt; formal definition of semantics in internal scope, where you can alter a<br>&gt; problematic invariant rather than having to live with it.<br>&gt; &gt;<br>&gt; &gt; All that said, there most likely *is* value in declaring, even<br>&gt; internally, which classes are meant to be subclassed and which members are<br>&gt; meant to be overridden. Perhaps what we ought to do is permit `open` even<br>&gt; on non-public APIs, but not enforce it (or rather, leave enforcement to<br>&gt; linters). That would allow people and teams to explicitly document internal<br>&gt; overriding behavior if they want to, without burdening the teams that don&#39;t<br>&gt; want to go to the effort.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; This is exactly what I&#39;m talking about - this is actually a very simple<br>&gt; discussion. Throwing around words like “non-committal” and “affirmative”<br>&gt; and speaking abstractly doesn’t disguise the brunt of what you’re saying:<br>&gt; limiting “open” to public classes only lets you be sloppy inside your own<br>&gt; module. That’s the only reason to make it like that. If I were describing<br>&gt; the concept of “sloppiness” while trying my hardest not to use the word<br>&gt; itself, I would probably say pretty much what you just wrote - wanting to<br>&gt; remain non-committal, avoid definite, affirmative statements, etc.<br>&gt;<br>&gt; If we think it is important for people who write classes to locally reason<br>&gt; about their code, it’s important full stop. The conflation between if it’s<br>&gt; publicly accessible and whether or not is a staggeringly massive regression<br>&gt; in read&amp;reason-ability, no matter how matter how you want to phrase it.<br>&gt; It’s a general problem which deserves a general solution - not some<br>&gt; ‘non-committal’ proposal which can&#39;t even commit to the problem it is<br>&gt; trying to help with.<br>&gt;<br>&gt; If you’ve ever had to deal with complex base classes, consisting of a<br>&gt; mixture of internal (and possibly internally subclassed) members and public<br>&gt; ones, you would know that annotating which members are to be used by what<br>&gt; (and knowing that it’s enforced by the compiler) would be a massive<br>&gt; improvement to our language syntax. Sometimes you didn’t write all the code<br>&gt; you have to work with, so it’s handy to have code which annotates this<br>&gt; stuff.<br>&gt;<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/c02a8ca6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b82ec7032daa9f5ac2c8aa489770557?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Peter Livesey</string> &lt;pdlivesey at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>+1 to Karl&#39;s suggestion<br></p><p>I&#39;ve come around to the idea of not allowing subclassing by default (well,<br>50/50) because I rarely see final used in swift code (read: it&#39;s<br>underused). However, I think the special casing of 3rd party libraries is<br>weird.<br></p><p>Let&#39;s assume this is true: &quot;It&#39;s really bad for developers to subclass<br>things which weren&#39;t intended to be subclassed by the developer who wrote<br>the class.&quot;<br></p><p>Given this, we want to turn off subclassability by default (reasonable). So<br>why is it ok for internal classes to incorrectly subclass things? The main<br>argument against this seems like it&#39;s hard for swift beginners to learn<br>this rule (but somehow, this proposal isn&#39;t?). Or that public APIs are<br>&#39;more important&#39; (disagree with this generalization. it totally depends on<br>the library/app. And even if they are more important, if it&#39;s better, then<br>it&#39;s better for everything). Am I missing other arguments for why this<br>would be bad for internal classes?<br></p><p><br>One other note:<br></p><p>*From and API perspective, *if the developer does everything right and<br>thinks about subclassing, there is no difference between this proposal and<br>what we have today. As in, the developer correctly decides to add<br>final/open (note: I know theres a different in the module itself, but from<br>an API perspective they are the same).<br></p><p>This proposal only matter when a developer &quot;makes a mistake&quot;. It only<br>applies to developers who forget to take subclassing into consideration.<br></p><p>I&#39;ve learned that you shouldn&#39;t optimize for bad developers. It seems like<br>adding complexity to the language and a new keyword just so when developers<br>make a mistake, it&#39;s not as bad seems strange to me. I think languages in<br>general should optimize for good code, not bad.<br></p><p>On Wed, Jul 20, 2016 at 4:53 PM ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;  limiting “open” to public classes only lets you be sloppy inside your<br>&gt; own module.<br>&gt;<br>&gt; I don&#39;t find that idea bad actually.<br>&gt;<br>&gt; In the similar vein one can say &quot;it&#39;s ok to be sloppy with local variable<br>&gt; names, it&#39;s not ok to be sloppy with instance variable names&quot;.<br>&gt;<br>&gt; Again, tradeoffs. You can require that things are perfect, so that all<br>&gt; methods are thoughtfully annotated, and all variables have wonderful<br>&gt; self-descriptive names, but you&#39;ll get most bang for the buck by requiring<br>&gt; that for the interface (public classes / instance variables) rather than<br>&gt; for the implementation (non-public classes / local variables).<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 12:26 AM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 20 Jul 2016, at 11:07, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 19, 2016, at 6:14 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; That is to say, we basically introduce “open&quot; as an inverted “final”,<br>&gt;&gt; and make all classes non-open by default. That is analogous to enabling<br>&gt;&gt; whole-module-optimisation by default, in my opinion. The cost of an extra<br>&gt;&gt; four-letter word isn’t that great, but the benefits to readability and<br>&gt;&gt; reasonability all-around make it worthwhile.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Okay, but this ignores an important difference between sealed and final.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sealed is *non-committal*. It makes no promises to wider scopes about<br>&gt;&gt; whether there are other subclasses/overrides; it merely states that code<br>&gt;&gt; outside the module may not subclass/override. `final`, on the other hand,<br>&gt;&gt; is an *affirmative* statement: there are no subclasses/overrides and there<br>&gt;&gt; never will be. Code outside the module is permitted to rely on that<br>&gt;&gt; fact—for instance, it can generate static calls and conflate dynamic Self<br>&gt;&gt; with static Self in conformances.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But this distinction only really makes sense at the `public` boundary,<br>&gt;&gt; because that&#39;s where the compiler—and even the developer—faces an<br>&gt;&gt; impenetrable encapsulation barrier. If you want to require `open` even on<br>&gt;&gt; non-public declarations, you thus need to choose one of these designs:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       1. `final` is still available, but only on public APIs.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       2. All non-public classes have to be explicitly declared either<br>&gt;&gt; `open` or `final`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       3. Sealed has some sort of complex, scope-specific design (for<br>&gt;&gt; instance, an `internal` class can be subclassed in `fileprivate` but not in<br>&gt;&gt; `internal` scope).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Of these three, I think that #2 is overly bureaucratic and #3 is overly<br>&gt;&gt; complicated, so only #1 is a viable option. And then we&#39;re just choosing<br>&gt;&gt; whether we have internal subclassing by default and an odd public-only<br>&gt;&gt; `open` keyword, or no internal subclassing by default and an odd<br>&gt;&gt; public-only `final` keyword. No viable option avoids some kind of asymmetry<br>&gt;&gt; at the `public` boundary.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Open-by-default with a `final` keyword is the traditional design. It is<br>&gt;&gt; simpler for people learning to program and more familiar for people new to<br>&gt;&gt; Swift. It is more convenient. And you just don&#39;t need the same rigorous,<br>&gt;&gt; formal definition of semantics in internal scope, where you can alter a<br>&gt;&gt; problematic invariant rather than having to live with it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; All that said, there most likely *is* value in declaring, even<br>&gt;&gt; internally, which classes are meant to be subclassed and which members are<br>&gt;&gt; meant to be overridden. Perhaps what we ought to do is permit `open` even<br>&gt;&gt; on non-public APIs, but not enforce it (or rather, leave enforcement to<br>&gt;&gt; linters). That would allow people and teams to explicitly document internal<br>&gt;&gt; overriding behavior if they want to, without burdening the teams that don&#39;t<br>&gt;&gt; want to go to the effort.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is exactly what I&#39;m talking about - this is actually a very simple<br>&gt;&gt; discussion. Throwing around words like “non-committal” and “affirmative”<br>&gt;&gt; and speaking abstractly doesn’t disguise the brunt of what you’re saying:<br>&gt;&gt; limiting “open” to public classes only lets you be sloppy inside your own<br>&gt;&gt; module. That’s the only reason to make it like that. If I were describing<br>&gt;&gt; the concept of “sloppiness” while trying my hardest not to use the word<br>&gt;&gt; itself, I would probably say pretty much what you just wrote - wanting to<br>&gt;&gt; remain non-committal, avoid definite, affirmative statements, etc.<br>&gt;&gt;<br>&gt;&gt; If we think it is important for people who write classes to locally<br>&gt;&gt; reason about their code, it’s important full stop. The conflation between<br>&gt;&gt; if it’s publicly accessible and whether or not is a staggeringly massive<br>&gt;&gt; regression in read&amp;reason-ability, no matter how matter how you want to<br>&gt;&gt; phrase it. It’s a general problem which deserves a general solution - not<br>&gt;&gt; some ‘non-committal’ proposal which can&#39;t even commit to the problem it is<br>&gt;&gt; trying to help with.<br>&gt;&gt;<br>&gt;&gt; If you’ve ever had to deal with complex base classes, consisting of a<br>&gt;&gt; mixture of internal (and possibly internally subclassed) members and public<br>&gt;&gt; ones, you would know that annotating which members are to be used by what<br>&gt;&gt; (and knowing that it’s enforced by the compiler) would be a massive<br>&gt;&gt; improvement to our language syntax. Sometimes you didn’t write all the code<br>&gt;&gt; you have to work with, so it’s handy to have code which annotates this<br>&gt;&gt; stuff.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/496c9919/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 3:26 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; Sealed is *non-committal*. It makes no promises to wider scopes about whether there are other subclasses/overrides; it merely states that code outside the module may not subclass/override. `final`, on the other hand, is an *affirmative* statement: there are no subclasses/overrides and there never will be. Code outside the module is permitted to rely on that fact—for instance, it can generate static calls and conflate dynamic Self with static Self in conformances.<br>&gt; <br>&gt; This is exactly what I&#39;m talking about - this is actually a very simple discussion. Throwing around words like “non-committal” and “affirmative” and speaking abstractly doesn’t disguise the brunt of what you’re saying: limiting “open” to public classes only lets you be sloppy inside your own module. That’s the only reason to make it like that. If I were describing the concept of “sloppiness” while trying my hardest not to use the word itself, I would probably say pretty much what you just wrote - wanting to remain non-committal, avoid definite, affirmative statements, etc.<br></p><p>No, that is *not* the only reason. The other reason is library evolution.<br></p><p>A class that is closed in 1.0 can be opened in 1.1; a class that is `final` in 1.0 *cannot* be opened in 1.1 (or at least it&#39;s a breaking change if it is). This is a really important distinction for binary compatibility—but binary compatibility only matters at the public boundary. An `internal`-or-less class does not have to worry about maintaining a compatible binary interface between different versions, but a `public` class does.<br></p><p>When I say it&#39;s &quot;non-commital&quot;, that&#39;s what I mean: It does not commit future versions of the module to either permit or forbid subclasses. A future version can either make it `open` or `final` as the module&#39;s evolving design demands. A `final` class must remain `final` forever. It&#39;s the difference between a door that&#39;s locked and a door that&#39;s bricked up.<br></p><p>Yes, it is *also* true that sealed-by-default permits sloppiness as long as it&#39;s contained to internal scope. But that&#39;s quite typical of Swift. It&#39;s why the default access control is `internal`, not `private` (the minimally-sloppy solution) or `public` (the minimally-bureaucratic solution). But these are two independent arguments for sealed. Railing against internal sloppiness doesn&#39;t change the library evolution argument.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 21, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 21.07.2016 um 03:41 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; A class that is closed in 1.0 can be opened in 1.1; a class that is `final` in 1.0 *cannot* be opened in 1.1 (or at least it&#39;s a breaking change if it is).<br>Wait a moment: Aren&#39;t &quot;closed&quot;, &quot;sealed&quot; and &quot;final&quot; basically all the same as soon as you cross module borders? (but I guess it&#39;s just that some words are in wrong order…)<br></p><p>But anyways, the imho important part is between the parenthesis:<br>Of course you can rename public properties, mark methods as final, rename all your classes or delete the repository of your library easily.<br>It might break other peoples code and make them angry, but if this is the driving motivation for SE-0117, the whole proposal is a paradox:<br>Changing the default for subclassability will break other peoples code on a gigantic scale — not only single methods or classes, but nearly every framework.<br></p><p>Just imagine this fear of breaking changes had been applied to Swift… do you think it would have been better for the progress of the language?<br>I don&#39;t think so, and I think that libraries aren&#39;t that different in this aspect:<br>When you start something new, you want breaking changes happen as soon as possible, when there is the most tolerance for them.<br></p><p>As I keep saying for a long time, I think that attitude is an aspect that is terribly neglected here, and imho there are already enough established languages which are pulled down by fear of breaking changes.<br>Although I have problems sorting out what &quot;swifty&quot; actually means, I might have a longer history as an Apple-customer than most other discussants here, and all marketing aside, there is one distinguishing principle that can be illustrated with many examples:<br>Better products are preferable over stable products.<br></p><p>- Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 21, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 3:13 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 21.07.2016 um 03:41 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; A class that is closed in 1.0 can be opened in 1.1; a class that is `final` in 1.0 *cannot* be opened in 1.1 (or at least it&#39;s a breaking change if it is).<br>&gt; Wait a moment: Aren&#39;t &quot;closed&quot;, &quot;sealed&quot; and &quot;final&quot; basically all the same as soon as you cross module borders? (but I guess it&#39;s just that some words are in wrong order…)<br></p><p>Not at all - `closed` and `sealed` are two different names proposed for the same thing but `final` is very different.  If you are using a `final` type from a library you (and the compiler) know all variables of that type reference instances of *exactly* that type.  You do not get that guarantee with `closed` / `sealed`.  In that case a variable may reference a subclass defined in the same module as the type of the variable.<br></p><p>The similarity is that outside the defining module you cannot subclass `final` or `closed` types.  But the rest of the semantics are quite different.<br></p><p>&gt; <br>&gt; But anyways, the imho important part is between the parenthesis:<br>&gt; Of course you can rename public properties, mark methods as final, rename all your classes or delete the repository of your library easily.<br>&gt; It might break other peoples code and make them angry, but if this is the driving motivation for SE-0117, the whole proposal is a paradox:<br>&gt; Changing the default for subclassability will break other peoples code on a gigantic scale — not only single methods or classes, but nearly every framework.<br>&gt; <br>&gt; Just imagine this fear of breaking changes had been applied to Swift… do you think it would have been better for the progress of the language?<br>&gt; I don&#39;t think so, and I think that libraries aren&#39;t that different in this aspect:<br>&gt; When you start something new, you want breaking changes happen as soon as possible, when there is the most tolerance for them.<br>&gt; <br>&gt; As I keep saying for a long time, I think that attitude is an aspect that is terribly neglected here, and imho there are already enough established languages which are pulled down by fear of breaking changes.<br>&gt; Although I have problems sorting out what &quot;swifty&quot; actually means, I might have a longer history as an Apple-customer than most other discussants here, and all marketing aside, there is one distinguishing principle that can be illustrated with many examples:<br>&gt; Better products are preferable over stable products.<br>&gt; <br>&gt; - Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 21, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 21 Jul 2016, at 03:41, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 3:26 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Sealed is *non-committal*. It makes no promises to wider scopes about whether there are other subclasses/overrides; it merely states that code outside the module may not subclass/override. `final`, on the other hand, is an *affirmative* statement: there are no subclasses/overrides and there never will be. Code outside the module is permitted to rely on that fact—for instance, it can generate static calls and conflate dynamic Self with static Self in conformances.<br>&gt;&gt; <br>&gt;&gt; This is exactly what I&#39;m talking about - this is actually a very simple discussion. Throwing around words like “non-committal” and “affirmative” and speaking abstractly doesn’t disguise the brunt of what you’re saying: limiting “open” to public classes only lets you be sloppy inside your own module. That’s the only reason to make it like that. If I were describing the concept of “sloppiness” while trying my hardest not to use the word itself, I would probably say pretty much what you just wrote - wanting to remain non-committal, avoid definite, affirmative statements, etc.<br>&gt; <br>&gt; No, that is *not* the only reason. The other reason is library evolution.<br>&gt; <br>&gt; A class that is closed in 1.0 can be opened in 1.1; a class that is `final` in 1.0 *cannot* be opened in 1.1 (or at least it&#39;s a breaking change if it is). This is a really important distinction for binary compatibility—but binary compatibility only matters at the public boundary. An `internal`-or-less class does not have to worry about maintaining a compatible binary interface between different versions, but a `public` class does.<br>&gt; <br>&gt; When I say it&#39;s &quot;non-commital&quot;, that&#39;s what I mean: It does not commit future versions of the module to either permit or forbid subclasses. A future version can either make it `open` or `final` as the module&#39;s evolving design demands. A `final` class must remain `final` forever. It&#39;s the difference between a door that&#39;s locked and a door that&#39;s bricked up.<br>&gt; <br>&gt; Yes, it is *also* true that sealed-by-default permits sloppiness as long as it&#39;s contained to internal scope. But that&#39;s quite typical of Swift. It&#39;s why the default access control is `internal`, not `private` (the minimally-sloppy solution) or `public` (the minimally-bureaucratic solution). But these are two independent arguments for sealed. Railing against internal sloppiness doesn&#39;t change the library evolution argument.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>I would be okay with the inferred situation for classes being a semantic “final”. That is, that they cannot be subclassed, but they won’t be automatically optimised in a fragile way either. We could call it “sealed” if you want to explicitly specify it - the difference is that it doesn’t only apply at the module boundary, and it’s just an annotation for the external modules’ type-checker that it shouldn’t allow this - it’s not license for the internal module’s compiler to give up flexibility. So:<br></p><p>public class Foo {}                        // Implicitly “sealed”. Cannot be subclassed anywhere. Does not provide optimiser guarantees of “final”.<br>public(sealed) class Foo {}           // as above<br></p><p>public final class Foo {}                // Implicitly “sealed”. Cannot be subclassed anywhere. Allows resilience-breaking optimisations.<br>public(sealed) final class Foo {}   // as above<br></p><p>public internal(open) class Foo {}                       // “open” overrides “sealed” for the internal scope. Cannot be subclassed externally; may be subclassed internally. Does not provide optimiser guarantees of “final”.<br>public(sealed) internal(open) class Foo {}          // as above<br></p><p>public(sealed) internal(open) final class Foo {}  // Error: A class cannot be both open and final<br></p><p>I believe that would meet the goals of:<br></p><p>- Not allowing subclassing from external modules unless explicitly allowed (the original goal)<br>- Making classes which are internally-subclassed easier to locally reason about (my nice-to-have)<br>- Maintain binary compatibility<br>- Do not give up binary flexibility unless the user explicitly asks for it (in the LibraryEvolution docs)<br></p><p>Is there anything I missed?<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/ad78b73c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 17, 2016 at 12:00:00pm</p></header><div class="content"><p>I naturally assumed that &quot;public&quot; and &quot;open&quot; would be two separate concepts, as it has been expressed that orthogonality* is favored.<br>But actually reading the proposal, it says:<br>&quot;open is invalid on declarations that are not also public&quot;, which imho not only is an unnecessary mingling of the two concepts, it also blocks the option to declare methods that can&#39;t be called outside the framework, which isn&#39;t that uncommon in Cocoa (methods like UIView.drawRect wouldn&#39;t show up in autocompletion lists anymore).<br></p><p>The whole proposal is about limitation whose rationale is incomprehensible for many, but for this &quot;restriction of the restriction&quot;, I can&#39;t see any rationale at all.<br></p><p>- Tino<br></p><p>* At class-level, there is afaics no orthogonality planned as well (a class that is abstract outside its module… might be useful as well)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 17, 2016 at 12:00:00pm</p></header><div class="content"><p>I naturally assumed that &quot;public&quot; and &quot;open&quot; would be two separate concepts, as it has been expressed that orthogonality* is favored.<br>But actually reading the proposal, it says:<br>&quot;open is invalid on declarations that are not also public&quot;, which imho not only is an unnecessary mingling of the two concepts, it also blocks the option to declare methods that can&#39;t be called outside the framework, which isn&#39;t that uncommon in Cocoa (methods like UIView.drawRect wouldn&#39;t show up in autocompletion lists anymore).<br></p><p>The whole proposal is about limitation whose rationale is incomprehensible for many, but for this &quot;restriction of the restriction&quot;, I can&#39;t see any rationale at all.<br></p><p>- Tino<br></p><p>* At class-level, there is afaics no orthogonality planned as well (a class that is abstract outside its module… might be useful as well)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 2016-07-16, at 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1, with notes:<br></p><p>1. The interaction of open with the dynamic keyword should be specified. Does &quot;public dynamic&quot; imply “open”? Dynamic provides a level of flexibility beyond mere subclassing, so I believe it should. Dynamic already conflicts with “final”, so there is precedent for this kind of interaction in the language. Note that “public dynamic” implying “open” means that we can’t have public dynamic members in a public class that’s not also open. I think this restriction is reasonable.<br></p><p>2. What about @objc methods? The docs say that it makes a name available but doesn’t guarantee dynamic dispatch on its own; so, it looks mostly irrelevant to this proposal.<br></p><p>3. The problem of code migration should be addressed. For example, we might want the auto-translator to automatically add open to non-final public methods/properties in existing code, to make it less painful to upgrade. People who simply accept the conversion results will get stuck with un-audited open stuff all over their public APIs, which is not ideal. On the other hand, this is no different to how their existing code behaved in Swift 2, so perhaps it is the best choice.<br></p><p>4. I don’t have a strong opinion on whether “open&quot; should imply “public&quot;. If we accept that “public dynamic” is a stronger promise than “public open&quot;, then it would look strange that the former requires public, while the latter doesn’t. On the other hand, “public open” is going to be much more frequently used than “public dynamic”, so arguably it deserves special treatment.<br></p><p>5. I was suprised by the restriction that the superclass of open classes must also be open. But I don’t have a convincing usecase against it, so I guess it’s fine. I like that we have the option to revisit this later.<br></p><p><br>For fun, here are the distinct combinations of access levels and dispatch clauses for members in a &quot;public open&quot; class after this proposal:<br></p><p>public dynamic         // plus “public dynamic open” if we keep it separate.<br>[public] open          // assuming “open” implies “public&quot;<br>public<br>public final<br>[internal] dynamic<br>[internal]<br>[internal] final<br>private dynamic<br>private<br>private final<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Absolutely.<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>Yep.<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>“Don’t use public subclassing&quot; has been my policy for years, but I have not had the pleasure to use a language that helps me enforce this.<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>In-depth study broken across many short sessions.<br></p><p>-- <br>Karoly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 17, 2016, at 5:16 AM, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On 2016-07-16, at 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1, with notes:<br>&gt; <br>&gt; 1. The interaction of open with the dynamic keyword should be specified. Does &quot;public dynamic&quot; imply “open”? Dynamic provides a level of flexibility beyond mere subclassing, so I believe it should. Dynamic already conflicts with “final”, so there is precedent for this kind of interaction in the language. Note that “public dynamic” implying “open” means that we can’t have public dynamic members in a public class that’s not also open. I think this restriction is reasonable.<br></p><p>Right.  I think the right way of thinking about &quot;dynamic&quot; is as a fourth member of this category of polymorphism control modifiers: &quot;dynamic&quot;, &quot;open&quot;, nonopen (currently unspellable in the proposal), and &quot;final&quot;.  Depending on where we ultimately go with &quot;dynamic&quot;, it&#39;s *possible* that we&#39;ll want the ability to say &quot;this method can be dynamically changed in-place but not overridden&quot;, but... frankly, I doubt we&#39;ll do that, and even if we do, it doesn&#39;t seem like the right default for &quot;dynamic&quot; alone (possibly &quot;dynamic final&quot;).  So I think the answer is that &quot;dynamic&quot; permits overriding.<br></p><p>&gt; 2. What about @objc methods? The docs say that it makes a name available but doesn’t guarantee dynamic dispatch on its own; so, it looks mostly irrelevant to this proposal.<br></p><p>Correct.  @objc just means the method is usable from Objective-C.<br></p><p>&gt; 3. The problem of code migration should be addressed. For example, we might want the auto-translator to automatically add open to non-final public methods/properties in existing code, to make it less painful to upgrade. People who simply accept the conversion results will get stuck with un-audited open stuff all over their public APIs, which is not ideal. On the other hand, this is no different to how their existing code behaved in Swift 2, so perhaps it is the best choice.<br></p><p>That&#39;s a good question.  My intuition is that the philosophy of this change suggests that we should leave existing public classes non-open.<br></p><p>&gt; 4. I don’t have a strong opinion on whether “open&quot; should imply “public&quot;. If we accept that “public dynamic” is a stronger promise than “public open&quot;, then it would look strange that the former requires public, while the latter doesn’t. On the other hand, “public open” is going to be much more frequently used than “public dynamic”, so arguably it deserves special treatment.<br>&gt; <br>&gt; 5. I was suprised by the restriction that the superclass of open classes must also be open. But I don’t have a convincing usecase against it, so I guess it’s fine. I like that we have the option to revisit this later.<br></p><p>Right.  It&#39;s fully source-compatible to allow this later.<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt; For fun, here are the distinct combinations of access levels and dispatch clauses for members in a &quot;public open&quot; class after this proposal:<br>&gt; <br>&gt; public dynamic         // plus “public dynamic open” if we keep it separate.<br>&gt; [public] open          // assuming “open” implies “public&quot;<br>&gt; public<br>&gt; public final<br>&gt; [internal] dynamic<br>&gt; [internal]<br>&gt; [internal] final<br>&gt; private dynamic<br>&gt; private<br>&gt; private final<br>&gt; <br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Absolutely.<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; Yep.<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; “Don’t use public subclassing&quot; has been my policy for years, but I have not had the pleasure to use a language that helps me enforce this.<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; In-depth study broken across many short sessions.<br>&gt; <br>&gt; -- <br>&gt; Karoly<br>&gt; @lorentey<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July 17, 2016 at 03:00:00pm</p></header><div class="content"><p>I reviewed the original proposal, and this revised text is a much better step forwards; I still think there are a few changes I’d like to see before fully getting behind it.<br></p><p>Consider this a +0.5.<br></p><p>I like the use of the additional `open` keyword on top of `public`, it has a nice symmetry to the use of the additional `final` keyword for the opposite effect. I’m not totally sold on the actual name of the keyword, but I’m not going to argue over the color of that bikeshed.<br></p><p>That `open` is invalid on declarations that are `final` feels to me like these are keywords of the same family, just as `public` and `private` make no sense together. I like that.<br></p><p><br>I disagree that an `open` method overridden from a superclass is implicitly `open`.<br></p><p>As the rationale for the proposal states, overridability is hard to get right, and there is no guarantee that the consumer of an API is going to think about it. The default for override methods should not be `open` or `final`, it should be the internal equivalent.<br></p><p>A coder subclassing a public API, who themselves wants their subclass to be subclassable, should need to restate `open` where appropriate.<br></p><p>This also seems to be a general conflict in that you can always reduce the access, e.g. an API might have a `public open` method, but the subclass should be able to declare that as `override private` and thus the `open` keyword would be invalid in this context.<br></p><p><br>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 17, 2016, at 3:12 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I disagree that an `open` method overridden from a superclass is implicitly `open`.<br>&gt; <br>&gt; As the rationale for the proposal states, overridability is hard to get right, and there is no guarantee that the consumer of an API is going to think about it. The default for override methods should not be `open` or `final`, it should be the internal equivalent.<br>&gt; <br>&gt; A coder subclassing a public API, who themselves wants their subclass to be subclassable, should need to restate `open` where appropriate.<br></p><p>I don&#39;t think that defaulting to non-open would be a good idea.  Like I covered in the proposal, inherited open methods remain open; letting an override implicitly close off an open method would create a pretty unfortunate error-of-omission situation.<br></p><p>We could remove the default here and require the method to be explicitly open/nonopen/final, but then we really do pile up the modifiers:<br></p><p>  public open override func foo()<br></p><p>To me, the fact that it&#39;s already marked with &quot;override&quot; suggests the possibility of open-ness enough to remove the need to re-state it.  I can see why you might disagree, though.<br></p><p>John.<br></p><p>&gt; <br>&gt; This also seems to be a general conflict in that you can always reduce the access, e.g. an API might have a `public open` method, but the subclass should be able to declare that as `override private` and thus the `open` keyword would be invalid in this context.<br>&gt; <br>&gt; <br>&gt; Scott<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Then we would need another keyword to close the method again should we<br>need/want.<br></p><p>   public sealed override func foo()<br></p><p>I don&#39;t see any association between override and open/sealed as they<br>relate to two different aspects of class inheritance. One declares the<br>method is overriding a superclass method; the other that this method<br>can(not) be further overriden. With inherited openness, it should be<br>possible to revert it and defaulting to inherited openness will demand<br>the introduction of another keword (sealed/closed/nonopen).<br></p><p>It would be simpler to have one global default and one keyword only.<br>Two keywords add to complexity to learn the language.<br></p><p>L<br></p><p>On 18 July 2016 at 14:12, John McCall via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jul 17, 2016, at 3:12 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I disagree that an `open` method overridden from a superclass is implicitly `open`.<br>&gt;&gt;<br>&gt;&gt; As the rationale for the proposal states, overridability is hard to get right, and there is no guarantee that the consumer of an API is going to think about it. The default for override methods should not be `open` or `final`, it should be the internal equivalent.<br>&gt;&gt;<br>&gt;&gt; A coder subclassing a public API, who themselves wants their subclass to be subclassable, should need to restate `open` where appropriate.<br>&gt;<br>&gt; I don&#39;t think that defaulting to non-open would be a good idea.  Like I covered in the proposal, inherited open methods remain open; letting an override implicitly close off an open method would create a pretty unfortunate error-of-omission situation.<br>&gt;<br>&gt; We could remove the default here and require the method to be explicitly open/nonopen/final, but then we really do pile up the modifiers:<br>&gt;<br>&gt;   public open override func foo()<br>&gt;<br>&gt; To me, the fact that it&#39;s already marked with &quot;override&quot; suggests the possibility of open-ness enough to remove the need to re-state it.  I can see why you might disagree, though.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; This also seems to be a general conflict in that you can always reduce the access, e.g. an API might have a `public open` method, but the subclass should be able to declare that as `override private` and thus the `open` keyword would be invalid in this context.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Scott<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 10:12 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 17, 2016, at 3:12 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I disagree that an `open` method overridden from a superclass is implicitly `open`.<br>&gt;&gt; <br>&gt;&gt; As the rationale for the proposal states, overridability is hard to get right, and there is no guarantee that the consumer of an API is going to think about it. The default for override methods should not be `open` or `final`, it should be the internal equivalent.<br>&gt;&gt; <br>&gt;&gt; A coder subclassing a public API, who themselves wants their subclass to be subclassable, should need to restate `open` where appropriate.<br>&gt; <br>&gt; I don&#39;t think that defaulting to non-open would be a good idea.  Like I covered in the proposal, inherited open methods remain open; letting an override implicitly close off an open method would create a pretty unfortunate error-of-omission situation.<br>&gt; <br>&gt; We could remove the default here and require the method to be explicitly open/nonopen/final, but then we really do pile up the modifiers:<br>&gt; <br>&gt;  public open override func foo()<br>&gt; <br>&gt; To me, the fact that it&#39;s already marked with &quot;override&quot; suggests the possibility of open-ness enough to remove the need to re-state it.  I can see why you might disagree, though.<br>&gt; <br></p><p>I think that this explicitness is more Swifty.<br></p><p>First consider why `open` is a bad inherited default:<br></p><p>  public class Superclass {<br>    public func foo() { }<br>  }<br></p><p>  class Subclass : Superclass {<br>    override func foo() { }<br>  }<br></p><p>Subclass is `internal` not `public`, likewise Subclass.foo is `internal` and not `public`. If the default was that these became `open`, the default would be compiler errors at every definition (and compiler errors for everything that was defined in the superclass that you haven’t overridden) because Subclass cannot be `open` and `internal`, and Subclass.foo cannot be `open` and `internal`.<br></p><p>And requiring that your derivation from a public API be also public seems exactly opposite to the intent of “apply thought before making things public,” and very much against “apply even more thought before making public things open.&quot;<br></p><p><br>To make anything public, even a subclass, you have to be explicit in Swift already not just at the class level:<br></p><p>  public class Superclass {<br>    public func foo() { }<br>  }<br></p><p>  public class Subclass : Superclass {<br>    override func foo() { }  // Error: Overriding instance method must be accessible as the declaration it overrides.<br>  }<br></p><p>But the function level too:<br></p><p>  public class Superclass {<br>    public func foo() { }<br>  }<br></p><p>  public class Subclass : Superclass {<br>    override public func foo() { }<br>  }<br></p><p><br>So I really don’t agree that `open` suggests anything, in fact I think consistently in Swift restating things is the norm.<br></p><p>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 10:59 AM, Scott James Remnant &lt;scott at netsplit.com&gt; wrote:<br>&gt;&gt; On Jul 18, 2016, at 10:12 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 17, 2016, at 3:12 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I disagree that an `open` method overridden from a superclass is implicitly `open`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As the rationale for the proposal states, overridability is hard to get right, and there is no guarantee that the consumer of an API is going to think about it. The default for override methods should not be `open` or `final`, it should be the internal equivalent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A coder subclassing a public API, who themselves wants their subclass to be subclassable, should need to restate `open` where appropriate.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that defaulting to non-open would be a good idea.  Like I covered in the proposal, inherited open methods remain open; letting an override implicitly close off an open method would create a pretty unfortunate error-of-omission situation.<br>&gt;&gt; <br>&gt;&gt; We could remove the default here and require the method to be explicitly open/nonopen/final, but then we really do pile up the modifiers:<br>&gt;&gt; <br>&gt;&gt; public open override func foo()<br>&gt;&gt; <br>&gt;&gt; To me, the fact that it&#39;s already marked with &quot;override&quot; suggests the possibility of open-ness enough to remove the need to re-state it.  I can see why you might disagree, though.<br>&gt;&gt; <br>&gt; <br>&gt; I think that this explicitness is more Swifty.<br>&gt; <br>&gt; First consider why `open` is a bad inherited default:<br>&gt; <br>&gt;  public class Superclass {<br>&gt;    public func foo() { }<br>&gt;  }<br>&gt; <br>&gt;  class Subclass : Superclass {<br>&gt;    override func foo() { }<br>&gt;  }<br>&gt; <br>&gt; Subclass is `internal` not `public`, likewise Subclass.foo is `internal` and not `public`. If the default was that these became `open`, the default would be compiler errors at every definition (and compiler errors for everything that was defined in the superclass that you haven’t overridden) because Subclass cannot be `open` and `internal`, and Subclass.foo cannot be `open` and `internal`.<br></p><p>This was covered in a different sub-thread, but this is not a real thing.  The restriction against writing &quot;open&quot; on a non-public declaration was only ever intended to apply to explicit &quot;open&quot;; also, as Xiaodi Wu pointed out, it is inconsistent with the resolution of SE-0025 and should be removed.<br></p><p>&gt; And requiring that your derivation from a public API be also public seems exactly opposite to the intent of “apply thought before making things public,” and very much against “apply even more thought before making public things open.&quot;<br>&gt; <br>&gt; <br>&gt; To make anything public, even a subclass, you have to be explicit in Swift already not just at the class level:<br>&gt; <br>&gt;  public class Superclass {<br>&gt;    public func foo() { }<br>&gt;  }<br>&gt; <br>&gt;  public class Subclass : Superclass {<br>&gt;    override func foo() { }  // Error: Overriding instance method must be accessible as the declaration it overrides.<br>&gt;  }<br>&gt; <br>&gt; But the function level too:<br>&gt; <br>&gt;  public class Superclass {<br>&gt;    public func foo() { }<br>&gt;  }<br>&gt; <br>&gt;  public class Subclass : Superclass {<br>&gt;    override public func foo() { }<br>&gt;  }<br>&gt; <br>&gt; <br>&gt; So I really don’t agree that `open` suggests anything, in fact I think consistently in Swift restating things is the norm.<br></p><p>Perhaps.<br></p><p>John.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>On Jul 18, 2016, at 7:12 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 17, 2016, at 3:12 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I disagree that an `open` method overridden from a superclass is implicitly `open`.<br>&gt;&gt; <br>&gt;&gt; As the rationale for the proposal states, overridability is hard to get right, and there is no guarantee that the consumer of an API is going to think about it. The default for override methods should not be `open` or `final`, it should be the internal equivalent.<br>&gt;&gt; <br>&gt;&gt; A coder subclassing a public API, who themselves wants their subclass to be subclassable, should need to restate `open` where appropriate.<br>&gt; <br>&gt; I don&#39;t think that defaulting to non-open would be a good idea.  Like I covered in the proposal, inherited open methods remain open; letting an override implicitly close off an open method would create a pretty unfortunate error-of-omission situation.<br>&gt; <br>&gt; We could remove the default here and require the method to be explicitly open/nonopen/final, but then we really do pile up the modifiers:<br>&gt; <br>&gt;  public open override func foo()<br>&gt; <br>&gt; To me, the fact that it&#39;s already marked with &quot;override&quot; suggests the possibility of open-ness enough to remove the need to re-state it.  I can see why you might disagree, though.<br></p><p>the fact that someone thought that something could be extended does not imply that the one who extended it also carefully planed for her own code to be extensible... and even if one particular method A which was declared extensible has not been altered directly in a subclass, through extending others that are related and not having planned carefully the interplay, method A may have now been rendered unfit for further extension. <br></p><p>So simply as a matter of following the logic of the proposal, every subsequent extension of something explicitely marked as open for subclassing should defacto be placed back into the default non-subclassable state, forcing the author to have to explicitely validate the new set of relationships existing between the methods in the subclass. Otherwise the logic does not hold, and the original proposal does not hold water: that which cannot be assumed as safe on level 0, cannot be suddenly assumed safe at level 1 of subclassing, because the outer API surface of level-n subclasing forms no more implicite guaranty of soundness than existed at level n-1. The proposal is all about the fact that it is the developer who MUST PROVIDE the soundness guaranty.<br></p><p><br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; This also seems to be a general conflict in that you can always reduce the access, e.g. an API might have a `public open` method, but the subclass should be able to declare that as `override private` and thus the `open` keyword would be invalid in this context.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Scott<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4999557a32c7643c05382d265ec7e58b?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Amber, SimpleTouch</string> &lt;amber at simpletouchsoftware.com&gt;<p>July 18, 2016 at 11:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p><br>Quoting Motivation : &quot;The major observation here is that not all classes<br>make sense to subclass, and it takes real thought and design work to make a<br>class subclassable *well*. As such, being able to subclass a public class<br>should be an additional &quot;promise&quot; beyond the class just being<br>marked public.&quot;<br></p><p><br>There seems to be two questions.<br></p><p>   1. should a class being designed  be sealed or not?  ’final’ already<br>   works, changing defaults seems unnecessary.<br>   2. how does the class designer go about selecting what to expose for<br>   possible overriding in sub-classes.  I agree with the proposal.<br>   Selectively publishing members is a better way to think about the class<br>   design, and will result in clearer intent and better design.<br></p><p>Suggestions:<br></p><p>   1. leave `final` as is<br>   2. require explicit annotation of members for overriding. ( `default`,<br>   `published`, `open` )<br>   3. whether a class or member is public, internal, or private should have<br>   no bearing on number 1 or  2.<br>   4. if there are no `published` members, class is implicitly final.<br></p><p>        * Does this proposal fit well with the feel and direction of Swift?<br></p><p><br>As proposed the ideas are very much in line with Swift,  hopefully as<br>suggested even more so.<br></p><p><br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>A moderate amount of thought and experimentation. I did not have time to<br>read historical discussions.<br></p><p><br>Amber<br></p><p>On Sat, Jul 16, 2016 at 1:52 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable<br>&gt; publicly&quot; begins now and runs through July 22. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/83c3e7d7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/20f1e33718d4d6201de42c25511779ee?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Juan Laube</string> &lt;juanlaube at fastmail.com&gt;<p>July 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>-1, I really think this a step in the wrong direction.<br>I recognise the problem around this, and why something is needed. However, I don’t like the idea of restricting things by default. In the attempt to solve a problem, we will create more problems by introducing more workarounds to replace what now is being overridden.<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p><br>No. I think the defaults should not be changed, but restricting subclassing (and overriding) should be opt-in.<br></p><p><br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. I think this kind of restrictions make Swift worst.<br></p><p><br>&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>This is the opposite of how other languages solves this kind of restrictions.<br></p><p><br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read in-depth the updated proposal and most of the discussion.<br></p><p><br></p><p>&gt; On Jul 16, 2016, at 2:52 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>July 19, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 00:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>With all respect to those who have put a lot of work into this proposal, I’m reluctantly and immensely against it.<br></p><p>The reasoning from the core team that working with vendors replaces the ability to subclass to work around problems simply doesn’t hold water for me. This is a very real and very common issue, and there are endless cases where vendors won’t or even *can’t* solve the problem, especially in closed-source code. And it’s not just a matter of GUI applications; I’ve run into the need to subclass (especially in order to deliver working results in reasonable time) in projects as low-level and open-source as LLVM.<br></p><p>In short, saying &quot;filing a bug will work&quot; isn’t good enough to justify locking out the ability of developers to deal with problems in vendor code. It’s simply not true - it’s certainly almost never been true of Apple frameworks, and even when it has, that doesn’t help anyone &quot;now&quot;. (To be clear, I’m not suggesting Apple is unresponsive to Radars. However, I am saying that there’s no transparency, no confidence in getting fixes, and no hope of any kind of reasonable (from a local perspective) timeline for deployment of fixes.)<br></p><p>In a perfect world, I agree this would be the case and *then* this proposal would be a fantastic concept that I’d be completely behind. Unfortunately, this is not a perfect world and the gains in encouraging good design and cleanliness of applying LSP (among other things) do not make up for the burden of implementation time and cost on framework users.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. But the change is too extreme and the ugly truth of the real world makes this proposal an inferior solution.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Absolutely. If not for the practical considerations, I’d love it! Conceptually speaking, I find it elegant, even harmonious. But again, in practice, the result isn’t so pretty.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Denial of subclassing has always been opt-in in ever other language I’ve used (C++ and Java, to name two, and Objective-C (and older C++) don’t even have that much). Sealing a class against subclassing is one thing, but not providing any kind of escape hatch, any kind of IUnderstandThatSubclassingMayCauseSunsToGoNovaOrGalaxiesToExplode marker, hamstrings all users of the code. Opt-in sealing at least constrains this scenario to places where the framework writer thought it was worth adding the extra protection against horrible horribleness.<br></p><p>For example, it makes sense to seal NSSomeCryptographicInterface because you’re making it that much harder for something to deliberately interfere with or accidentally break crypto. It makes less sense to seal NSSplitViewController - I’d much rather Apple just said &quot;tough noogies, your subclass breaks in this version because you did something unsupported&quot; when fixing bugs!<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve been watching the discussion on this topic back and forth for some time now, and I read both revisions of the proposal carefully. I’m very much conceptually in favor of it, and I regret that I can’t stand behind it! But the fact remains that I think it’s a bad idea.<br></p><p>-- Gwynne Raskind<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 19, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 11:04 PM, Gwynne Raskind via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Denial of subclassing has always been opt-in in ever other language I’ve used (C++ and Java, to name two, and Objective-C (and older C++) don’t even have that much). Sealing a class against subclassing is one thing, but not providing any kind of escape hatch, any kind of IUnderstandThatSubclassingMayCauseSunsToGoNovaOrGalaxiesToExplode marker, hamstrings all users of the code. Opt-in sealing at least constrains this scenario to places where the framework writer thought it was worth adding the extra protection against horrible horribleness.<br></p><p>You know, one thing I haven&#39;t seen mentioned is that, just as sealed-by-default preserves the options of library programmers, it also preserves the options of the language itself.<br></p><p>Suppose the people who think this is a huge mistake are correct, and we ultimately conclude that sealed-by-default is a disaster. What can we do about it? Well, we change Swift 3+n to open all classes by default. This would be source- and binary-compatible with all existing code; the only wrinkle is that classes compiled with a sealed-by-default compiler would still be sealed. (And that&#39;s not even a problem yet, since stable ABIs are not a thing yet.)<br></p><p>The reverse, however, is *not* true. Going from open-by-default to sealed-by-default is source- and binary-incompatible. If we don&#39;t do it now, we may never be able to do it.<br></p><p>That means this is our one chance to try this. The outcome is uncertain; there are good arguments that it will improve things, but there are also good arguments that it will make things worse. But if we&#39;re afraid to try this now, we&#39;ll never be able to try it again, and we won&#39;t know if it would have worked. Whereas if we *do* try it now, we can always roll it back later.<br></p><p>Software quality is one of the biggest problems our profession faces. We handle crushing amounts of complexity, teetering towers of abstraction, intertwined code that&#39;s at the ragged edge of our ability to comprehend it. Quite possibly the most urgent need in our industry is tools to help us manage it.<br></p><p>Sealed-by-default might turn out to be a powerful tool for managing complexity, helping us prevent unexpected interactions between the implementation details of separate modules. Or it might not. But we ought to find out. If we always take the conservative option, if we always stick to the tried and true, we will never advance the state of the art, never find solutions to the problems that make &quot;all software sucks&quot; a truism.<br></p><p>We need to be bold and take a chance. If it doesn&#39;t work out, we can undo it. But if it does work out, we&#39;ll be better for it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 19.07.2016 um 09:43 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; We need to be bold and take a chance. If it doesn&#39;t work out, we can undo it. But if it does work out, we&#39;ll be better for it.<br>It&#39;s hard for me to associate a proposal that is grounded on fear with the word &quot;bold&quot;, yet the essence of the message is correct — but Imho it is another &quot;in a perfect world&quot; statement:<br>In reality, nobody will measure the effect of this change, and those in favor of the proposal might even call the absent of a horrible catastrophe a &quot;proof&quot; for their opinion.<br>So, what could this catastrophe actually be? Supporters of 0117 educated us that forking is a good thing, and that&#39;s about the worst thing I can imagine (exorbitant pessimism left aside)…<br>We won&#39;t have a &quot;free&quot; Swift and a &quot;restricted&quot; Swift to check what people actually prefer, and even if we had, there would be those saying that their opinion is the only truth, no matter what the majority thinks.<br></p><p>The bad effects of the proposal are no obvious danger, like a wild crocodile that threatens you — it is more like a swarm of mosquitos that feasts on your blood and dampens your mood.<br>I&#39;m am convinced this change will be a source of constant annoyance, but people are very good at accepting constant annoyance (they have even a noticeable track record in accepting things that are much worse than annoyance: It took us hundreds of years to realize that burning old ladies with a talent for leechcraft might not be the smartest idea...).<br></p><p>Despite claims by others, this is not about proofs or facts at all, it is just about attitude, and attitude is hard to change. This article (http://martinfowler.com/bliki/DirectingAttitude.html) was a big help for me to understand the underlying motives which were absolutely alien to me, and convinced me that there is no merit in discussion anymore:<br>It&#39;s misfortune for our party that those who decide the default belong to the other camp, but that&#39;s life, and we have to accept it.<br></p><p>So, regarding the problem of wether subclassing and overriding should be discouraged, we have two contrary positions, and Swift clearly discarded the &quot;enabling attitude&quot;… for those who share this point of view, it is a frustrating decision after a frustrating debate on a frustrating topic, so please be patient with us who walk the narrow path between cynicism and resignation ;-)<br></p><p>Swift is a new language and a projection surface for those taking part in the discussion here, and it is unavoidable that there will be situations that are disappointing for parts of the community*.<br></p><p>- Tino<br></p><p>* although I think that asking an ornithologist for counsel on the choice for the name could have saved us from some irritation... &quot;Cagebird&quot; sounds nice as well, and it is a much better fit for the goals of of 0117, which really don&#39;t match with the characteristics of its eponymist ;-)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f457a34009ca0638b3c1640b3b923a82?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at mac.com&gt;<p>July 19, 2016 at 11:00:00pm</p></header><div class="content"><p>2016/07/19 16:43、Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt;&gt; On Jul 18, 2016, at 11:04 PM, Gwynne Raskind via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Denial of subclassing has always been opt-in in ever other language I’ve used (C++ and Java, to name two, and Objective-C (and older C++) don’t even have that much). Sealing a class against subclassing is one thing, but not providing any kind of escape hatch, any kind of IUnderstandThatSubclassingMayCauseSunsToGoNovaOrGalaxiesToExplode marker, hamstrings all users of the code. Opt-in sealing at least constrains this scenario to places where the framework writer thought it was worth adding the extra protection against horrible horribleness.<br>&gt; <br>&gt; You know, one thing I haven&#39;t seen mentioned is that, just as sealed-by-default preserves the options of library programmers, it also preserves the options of the language itself.<br>&gt; <br>&gt; Suppose the people who think this is a huge mistake are correct, and we ultimately conclude that sealed-by-default is a disaster. What can we do about it? Well, we change Swift 3+n to open all classes by default. This would be source- and binary-compatible with all existing code; the only wrinkle is that classes compiled with a sealed-by-default compiler would still be sealed. (And that&#39;s not even a problem yet, since stable ABIs are not a thing yet.)<br>This is exactly my thought as well, if it does end up not optimal it can always be changed back in a subsequent update.<br></p><p>&gt; The reverse, however, is *not* true. Going from open-by-default to sealed-by-default is source- and binary-incompatible. If we don&#39;t do it now, we may never be able to do it.<br>&gt; <br>&gt; That means this is our one chance to try this. The outcome is uncertain; there are good arguments that it will improve things, but there are also good arguments that it will make things worse. But if we&#39;re afraid to try this now, we&#39;ll never be able to try it again, and we won&#39;t know if it would have worked. Whereas if we *do* try it now, we can always roll it back later.<br>I got the feeling that&#39;s why this is being pushed now and not swift 3.1 or 4...<br></p><p>&gt; Software quality is one of the biggest problems our profession faces. We handle crushing amounts of complexity, teetering towers of abstraction, intertwined code that&#39;s at the ragged edge of our ability to comprehend it. Quite possibly the most urgent need in our industry is tools to help us manage it.<br>This is implicitly the reason that I changed my +0 to +1, alot of software is crap and it&#39;s crap because we don&#39;t get a handle on complexity, and this has a potential to reign some things in and bring a little discipline where it&#39;s needed.<br></p><p>I was originally very very against this, but as I thought about it I realized my only &quot;real&quot; reason at the end of the day was fear: fear of loosing certain flexibility, fear of loosing a tool I have used in the past, fear of change (again only speaking for myself) ... and really what I&#39;m getting in return for that change though is the potential for some real increase in reliability (and maybe a lot of performance) on all sides. <br></p><p>Things really teeter out of control I think because we can do all this crazy stuff behind the back of everything else and while this gives great flexibility to do some truly remarkable things,  it also piles up on top of itself and mucks things up... it works until it doesn&#39;t... and while the objc world is much more disciplined than others, my experience in the PHP/JavaScript side of things makes me never want to go back to that place... infinite regresses into over-complexity... <br></p><p>&gt; Sealed-by-default might turn out to be a powerful tool for managing complexity, helping us prevent unexpected interactions between the implementation details of separate modules. Or it might not. But we ought to find out. If we always take the conservative option, if we always stick to the tried and true, we will never advance the state of the art, never find solutions to the problems that make &quot;all software sucks&quot; a truism.<br>Agreed, and I&#39;m ironically reminded of the old days (as a barely conscious human being) where everyone was poopooing objective-c and why don&#39;t we just stick to codewarrior and metrowerks and c++... new is bad and what we had is just fine, interface builder is weird, oh and those square brackets what are those etc etc... I&#39;m not saying this is the same thing or that arguments against this proposal are not merited (of course they&#39;re merited) but it&#39;s a trade off and I think what we would get in return would be huge and potentially more useful in the long run. (wow have i come full circle...)<br></p><p>Maybe we do need to be able to unscrew the bottle and be able to override something forcefully as a last resort and maybe I should have not voted a full +1 because I agree with others that it&#39;s an important function... but in any case I think we should take a deep breath and long term think about what is really trying to be accomplished.... <br></p><p>&gt; We need to be bold and take a chance. If it doesn&#39;t work out, we can undo it. But if it does work out, we&#39;ll be better for it.<br>+1000 yes<br></p><p>Andre<br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/a75dd349/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 19 Jul 2016, at 15:36, Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Agreed, and I&#39;m ironically reminded of the old days (as a barely conscious human being) where everyone was poopooing objective-c [...], interface builder is weird, oh and those square brackets what are those etc etc...<br></p><p>Ironically we are back to the same dismissive attitude when taking about Objective-C now it seems lol, history does likes cycles sometimes ;).<br></p><p>I am in favour of Swift taking chances, but throwing away with disgust everything which is not the brand new hope does a major disservice to the achievements and productivity the previous instruments bring and the lessons they teach.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>July 19, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 to Brent’s reasoning. <br>&gt; On Jul 19, 2016, at 3:43 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 11:04 PM, Gwynne Raskind via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Denial of subclassing has always been opt-in in ever other language I’ve used (C++ and Java, to name two, and Objective-C (and older C++) don’t even have that much). Sealing a class against subclassing is one thing, but not providing any kind of escape hatch, any kind of IUnderstandThatSubclassingMayCauseSunsToGoNovaOrGalaxiesToExplode marker, hamstrings all users of the code. Opt-in sealing at least constrains this scenario to places where the framework writer thought it was worth adding the extra protection against horrible horribleness.<br>&gt; <br>&gt; You know, one thing I haven&#39;t seen mentioned is that, just as sealed-by-default preserves the options of library programmers, it also preserves the options of the language itself.<br>&gt; <br>&gt; Suppose the people who think this is a huge mistake are correct, and we ultimately conclude that sealed-by-default is a disaster. What can we do about it? Well, we change Swift 3+n to open all classes by default. This would be source- and binary-compatible with all existing code; the only wrinkle is that classes compiled with a sealed-by-default compiler would still be sealed. (And that&#39;s not even a problem yet, since stable ABIs are not a thing yet.)<br>&gt; <br>&gt; The reverse, however, is *not* true. Going from open-by-default to sealed-by-default is source- and binary-incompatible. If we don&#39;t do it now, we may never be able to do it.<br>&gt; <br>&gt; That means this is our one chance to try this. The outcome is uncertain; there are good arguments that it will improve things, but there are also good arguments that it will make things worse. But if we&#39;re afraid to try this now, we&#39;ll never be able to try it again, and we won&#39;t know if it would have worked. Whereas if we *do* try it now, we can always roll it back later.<br>&gt; <br>&gt; Software quality is one of the biggest problems our profession faces. We handle crushing amounts of complexity, teetering towers of abstraction, intertwined code that&#39;s at the ragged edge of our ability to comprehend it. Quite possibly the most urgent need in our industry is tools to help us manage it.<br>&gt; <br>&gt; Sealed-by-default might turn out to be a powerful tool for managing complexity, helping us prevent unexpected interactions between the implementation details of separate modules. Or it might not. But we ought to find out. If we always take the conservative option, if we always stick to the tried and true, we will never advance the state of the art, never find solutions to the problems that make &quot;all software sucks&quot; a truism.<br>&gt; <br>&gt; We need to be bold and take a chance. If it doesn&#39;t work out, we can undo it. But if it does work out, we&#39;ll be better for it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>July 19, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 I&#39;m sold by Brent&#39;s reasoning that sealed is the only way to keep options open, both for any given library and for the whole Swift language. I&#39;ve stayed quiet until now because while philosophically inclined to final by default I was concerned about potential complexity and confusion.<br></p><p>I haven&#39;t read everything on the mailing list but I&#39;ve read several blog posts on both sides.<br></p><p>In terms of the necessity of subclassing it feels to me that subclassing where not designed for it is a similar in principle to using private APIs which may at times be the only way to achieve certain things but at least on iOS the App Store policies prevent that.<br></p><p>I don&#39;t have very strong views about the syntax I&#39;m afraid but if this is something that could be reversed there should be an explicit version of the default sealed case (like internal is with for access controls).<br></p><p>Joseph<br></p><p>On Jul 19, 2016, at 8:43 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 18, 2016, at 11:04 PM, Gwynne Raskind via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Denial of subclassing has always been opt-in in ever other language I’ve used (C++ and Java, to name two, and Objective-C (and older C++) don’t even have that much). Sealing a class against subclassing is one thing, but not providing any kind of escape hatch, any kind of IUnderstandThatSubclassingMayCauseSunsToGoNovaOrGalaxiesToExplode marker, hamstrings all users of the code. Opt-in sealing at least constrains this scenario to places where the framework writer thought it was worth adding the extra protection against horrible horribleness.<br>&gt; <br>&gt; You know, one thing I haven&#39;t seen mentioned is that, just as sealed-by-default preserves the options of library programmers, it also preserves the options of the language itself.<br>&gt; <br>&gt; Suppose the people who think this is a huge mistake are correct, and we ultimately conclude that sealed-by-default is a disaster. What can we do about it? Well, we change Swift 3+n to open all classes by default. This would be source- and binary-compatible with all existing code; the only wrinkle is that classes compiled with a sealed-by-default compiler would still be sealed. (And that&#39;s not even a problem yet, since stable ABIs are not a thing yet.)<br>&gt; <br>&gt; The reverse, however, is *not* true. Going from open-by-default to sealed-by-default is source- and binary-incompatible. If we don&#39;t do it now, we may never be able to do it.<br>&gt; <br>&gt; That means this is our one chance to try this. The outcome is uncertain; there are good arguments that it will improve things, but there are also good arguments that it will make things worse. But if we&#39;re afraid to try this now, we&#39;ll never be able to try it again, and we won&#39;t know if it would have worked. Whereas if we *do* try it now, we can always roll it back later.<br>&gt; <br>&gt; Software quality is one of the biggest problems our profession faces. We handle crushing amounts of complexity, teetering towers of abstraction, intertwined code that&#39;s at the ragged edge of our ability to comprehend it. Quite possibly the most urgent need in our industry is tools to help us manage it.<br>&gt; <br>&gt; Sealed-by-default might turn out to be a powerful tool for managing complexity, helping us prevent unexpected interactions between the implementation details of separate modules. Or it might not. But we ought to find out. If we always take the conservative option, if we always stick to the tried and true, we will never advance the state of the art, never find solutions to the problems that make &quot;all software sucks&quot; a truism.<br>&gt; <br>&gt; We need to be bold and take a chance. If it doesn&#39;t work out, we can undo it. But if it does work out, we&#39;ll be better for it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July 20, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1<br></p><p>I don’t necessarily like the idea of sealed-by-default overridability of members, although I will admit it goes along well with the general philosophy of reducing the need for modifiers on internal API. I would prefer final-by-default, and the final keyword being removed.<br></p><p>I did not see anything within the proposal, but I assume that overridability of initializers was evaluated and deemed sufficient with existing mechanisms?<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>Generally yes<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Sure, I would say C# follows this reasonably well with its virtual keyword, although I don’t believe they are sealed by default at the class level<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Followed most of comments, In-depth study<br></p><p>-DW<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>Hello to all of the community.<br></p><p>*        * What is your evaluation of the proposal?*<br>+0.5<br>Agree on the motivation and &#39;public open class&#39;<br>Let&#39;s discuss &#39;public open func&#39; + application to dynamic runtime<br></p><p><br>*        * Is the problem being addressed significant enough to warrant a<br>change to Swift?*<br>*        * Does this proposal fit well with the feel and direction of<br>Swift?*<br>*        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?*<br></p><p>My perspective is as follows.<br></p><p>We are designing a language that has a concept of classes and overrides.<br>Let&#39;s create a class and put some functions into it with the default<br>modifiers.<br></p><p>*Should it be possible to override those functions in the other parts of<br>the code?*<br></p><p>This is a deep question of language design. An answer will have profound<br>ramifications regarding the code that the compiler is allowed to produce.<br>It&#39;s not surprising that different languages give different answers:<br></p><p>- Java and Objective-C say &quot;Yes&quot;<br>- C++ and C# say &quot;No&quot;<br></p><p>Now, it doesn&#39;t look to me like it&#39;s &quot;impossible to use libraries&quot; in those<br>last two languages or that one has &quot;less fun&quot;, or that they are<br>&quot;disadvantaged on the server&quot; because of their design choices.<br></p><p>What it looks like is a tradeoff. A freedom in one place is a requirement<br>in another place – if you say &quot;one should be able to override those<br>methods&quot;, it means &quot;a compiler should be required to perform virtual<br>dispatch on any call to those methods&quot;.<br></p><p>A smart compiler will be able to perform some guaranteed optimizations if<br>it knows that the calls can be devirtualized. This is a good thing, because<br>you can perfrom refactoring &quot;for free&quot;.<br></p><p>As an example, in the scenario below Pyramid.computeVolume() can be<br>devirtualized even if you refactor this class as a subclass of an abstract<br>&quot;Geometric-Body&quot; class and make computeBase() overrideable.<br></p><p>    class Pyramid {<br>         func computeVolume() { return computeBase() * height / 3}<br>         func computeBase() { return π * radius * radius }<br>    }<br></p><p>This ability to extract away the code without the performance penalty and<br>without turning it into an unwanted override point is a benefit of the &quot;No&quot;<br>answer to the aforementioned question.<br></p><p>The ability to quickly design a hierarchy of classes without worrying first<br>about making them virtual is a benefit of the &quot;Yes&quot; answer to the<br>aforementioned question.<br></p><p>What would a good tradeoff then look like? It would combine the advantages<br>of both approaches. I believe that a default &quot;Yes&quot; answer within a module<br>and &quot;No&quot; across the boundary does that.<br></p><p>Therefore I feel like this proposal moves Swift in the right direction.<br></p><p>However, I&#39;m not sure that &#39;open&#39; is the right keyword for functions and<br>would prefer to see more discussion regarding it.<br></p><p>It&#39;s less clear what the benefits of non-open classes are in the dynamic<br>runtime, as we can&#39;t really promise that they will not be subclassed.<br>Incidentally, a lot of the criticism of the proposal touches the usage in<br>Swift of Cocoa Touch APIs. Maybe there is value in leaving things exactly<br>as they currently are in the Objective-C.<br></p><p>*        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?*<br></p><p>This is the first proposal I feel compelled to respond to.<br></p><p>Many interesting points regarding the proposal have been raised. I&#39;ve spent<br>some time trying to read most of the thread and thought about this question<br>during a day. I also refreshed my memory regarding other languages, and the<br>design patterns of inheritance in general, e.g. here:<br></p><p>- https://codeblog.jonskeet.uk/2006/03/04/inheritancetax/<br>-<br>http://blog.berniesumption.com/software/inheritance-is-evil-and-must-be-destroyed/<br>- http://www.artima.com/intv/nonvirtualP.html<br>- http://stackoverflow.com/a/14451437/115200 (Eric Lippert)<br></p><p>Thank you if you got up to here,<br>Ilya.<br></p><p>On Sat, Jul 16, 2016 at 7:52 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable<br>&gt; publicly&quot; begins now and runs through July 22. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/3d110bfa/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
