<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br>A **strong** -1<br></p><p>First, I have often found that you can’t always predict the way which something will need to be extended.  You think you know, but are then surprised by creative uses.  My favorite features of Swift/Cocoa involve retroactive modeling.<br></p><p>Second, I don’t think this proposal will achieve its stated objective of forcing people to think about subclassing more.  It will just add confusing boilerplate.  <br></p><p>Things like Swift optionals work well because they make the (often forgotten) choices explicit in the context that they are used.  In the world of Human Factors, we call it a forcing function.  This proposal has the inverse structure, and will be ineffective, because the “forcing” part of it shows up in a different context (i.e. trying to use a framework) than the decision is being made in (writing the framework).  This type of thinking leads to things like Java and the DMV.<br></p><p>As Tino said:<br>&gt; No matter what the defaults are, good libraries are hard to build, so I predict this proposal would not only fail in increasing framework quality, but also will make it much harder for users of those frameworks to work around their flaws, which are just a natural part of every software.<br></p><p>I think he is right on here.  Those who were prone to be thoughtful about their design would have been anyway.  Those who are not thoughtful about their design will just leave these annotations off… leaving us with no recourse to extend/modify classes.  When people complain, they will add the annotations without actually thinking about the meaning (i.e. stack overflow / the fixit tells me I need to add this word to make the compiler happy).  All this does is put framework users at the mercy of the framework writers.<br></p><p><br>Finally, this proposal is missing important aspects of the problem space.  If we truly want to solve the issue of subclassing, we need to consider all of the common issues which arise.  Looking at the cocoa documentation you will see several types of annotations:<br>	1) This method MUST be overridden<br>	2) This method should NOT be overridden<br>	3) This method MUST be called<br>	3) This method should NOT be called except by subclasses<br>	4) This method should NOT be called except by a method override calling super<br>	5) This method MUST call super<br>	6) Overrides of this method should NOT call super<br></p><p>If we are attempting to bring thoughtfulness to the design of classes, I would like to see things be extendable by default, but with annotations that thoughtful framework designers can use to designate how a particular method should be used.  In most cases, it should not explicitly forbid the end user from subclassing, but require them to acknowledge that what they are doing is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That would feel 1000x more swifty to me.  Opt-out safety.<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>No. It doesn’t actually solve the problem... and I haven’t actually run into this problem in the real world.<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>No, it gives Swift more of a feeling of busywork and unnecessary boilerplate while failing to achieve its objective.  It goes against the retroactive modeling allowed by other areas of Swift.<br></p><p>&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I tend to avoid languages which require this sort of thing.  In other languages that lock things down, there is a need to unlock things soon after (e.g. friend classes).  <br></p><p>I predict the same thing will happen here.  People will quickly be asking for the ability to patch/override in cases where the framework designer was wrong.  That shows a problem inherent with the design...<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Read the proposal &amp; discussion.  Read earlier discussions around access control that touched on this subject as well.  I have been designing frameworks for years.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/727e0ea7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 07.07.2016 um 02:27 schrieb Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; 	1) This method MUST be overridden<br>&gt; 	2) This method should NOT be overridden<br>&gt; 	3) This method MUST be called<br>&gt; 	3) This method should NOT be called except by subclasses<br>&gt; 	4) This method should NOT be called except by a method override calling super<br>&gt; 	5) This method MUST call super<br>&gt; 	6) Overrides of this method should NOT call super<br>&gt; <br>&gt; If we are attempting to bring thoughtfulness to the design of classes, I would like to see things be extendable by default, but with annotations that thoughtful framework designers can use to designate how a particular method should be used.  In most cases, it should not explicitly forbid the end user from subclassing, but require them to acknowledge that what they are doing is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That would feel 1000x more swifty to me.  Opt-out safety.<br>totally agree:<br>I&#39;m not sure what 3) should mean, but imho several points on this list are much more useful than the ability to seal a class.<br>Imho it is not necessary to forbid overloading at all, it&#39;s better to make sure everyone trying to do so is aware of the dangers (imho exclamation marks would be a &quot;swifty&quot; choice: &quot;override! func(…)).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/50569c5c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July  7, 2016 at 06:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>Strong -1 too.<br></p><p>I can’t count the number of times it save my hours tone able to override arbitrary classes and methods. <br></p><p>Sometimes to simply add log point to understand how the API work. Other times to workaround bugs in the library. Or even to extends the library in a way that the author did not intent in the first place, but that was perfectly supported anyway.<br></p><p>I already see how libraries author will react to that new default. They will either don’t care and mark all classes as subclassable, or find to burdensome to get subclassability right and prohibit subclassing all classes.<br></p><p><br>&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt; A **strong** -1<br>&gt; <br>&gt; First, I have often found that you can’t always predict the way which something will need to be extended.  You think you know, but are then surprised by creative uses.  My favorite features of Swift/Cocoa involve retroactive modeling.<br>&gt; <br>&gt; Second, I don’t think this proposal will achieve its stated objective of forcing people to think about subclassing more.  It will just add confusing boilerplate.  <br>&gt; <br>&gt; Things like Swift optionals work well because they make the (often forgotten) choices explicit in the context that they are used.  In the world of Human Factors, we call it a forcing function.  This proposal has the inverse structure, and will be ineffective, because the “forcing” part of it shows up in a different context (i.e. trying to use a framework) than the decision is being made in (writing the framework).  This type of thinking leads to things like Java and the DMV.<br>&gt; <br>&gt; As Tino said:<br>&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I predict this proposal would not only fail in increasing framework quality, but also will make it much harder for users of those frameworks to work around their flaws, which are just a natural part of every software.<br>&gt; <br>&gt; I think he is right on here.  Those who were prone to be thoughtful about their design would have been anyway.  Those who are not thoughtful about their design will just leave these annotations off… leaving us with no recourse to extend/modify classes.  When people complain, they will add the annotations without actually thinking about the meaning (i.e. stack overflow / the fixit tells me I need to add this word to make the compiler happy).  All this does is put framework users at the mercy of the framework writers.<br>&gt; <br>&gt; <br>&gt; Finally, this proposal is missing important aspects of the problem space.  If we truly want to solve the issue of subclassing, we need to consider all of the common issues which arise.  Looking at the cocoa documentation you will see several types of annotations:<br>&gt; 	1) This method MUST be overridden<br>&gt; 	2) This method should NOT be overridden<br>&gt; 	3) This method MUST be called<br>&gt; 	3) This method should NOT be called except by subclasses<br>&gt; 	4) This method should NOT be called except by a method override calling super<br>&gt; 	5) This method MUST call super<br>&gt; 	6) Overrides of this method should NOT call super<br>&gt; <br>&gt; If we are attempting to bring thoughtfulness to the design of classes, I would like to see things be extendable by default, but with annotations that thoughtful framework designers can use to designate how a particular method should be used.  In most cases, it should not explicitly forbid the end user from subclassing, but require them to acknowledge that what they are doing is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That would feel 1000x more swifty to me.  Opt-out safety.<br>&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into this problem in the real world.<br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate while failing to achieve its objective.  It goes against the retroactive modeling allowed by other areas of Swift.<br>&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; I tend to avoid languages which require this sort of thing.  In other languages that lock things down, there is a need to unlock things soon after (e.g. friend classes).  <br>&gt; <br>&gt; I predict the same thing will happen here.  People will quickly be asking for the ability to patch/override in cases where the framework designer was wrong.  That shows a problem inherent with the design...<br>&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; Read the proposal &amp; discussion.  Read earlier discussions around access control that touched on this subject as well.  I have been designing frameworks for years.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/8ef16af8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  7, 2016 at 01:00:00pm</p></header><div class="content"><p>Jean, IMO marking every class as subclassable means the creator does<br>not care for you to design and develop a great library because s/he is<br>not caring for the library at all. I right now have to go through the<br>burdensome activity of marking too many classes/methods as final to<br>prevent misuse of my libraries and find good design workarounds when I<br>need to subclass internally what I don&#39;t want you to subclass.<br></p><p>IMO the usage of a library is to be crafted/planned/designed by their<br>developers not their users. Mine is the opinion of a library-maker,<br>yours of the user of poorly designed/developed libraries. By pushing<br>this proposal, developer of such libraries will have much burden to<br>make/keep a poor library or will have to work on better<br>design/implementation for it to suit its purpose.<br></p><p>L<br></p><p>On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  * What is your evaluation of the proposal?<br>&gt;<br>&gt; Strong -1 too.<br>&gt;<br>&gt; I can’t count the number of times it save my hours tone able to override<br>&gt; arbitrary classes and methods.<br>&gt;<br>&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt; way that the author did not intent in the first place, but that was<br>&gt; perfectly supported anyway.<br>&gt;<br>&gt; I already see how libraries author will react to that new default. They will<br>&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt; classes.<br>&gt;<br>&gt;<br>&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt; A **strong** -1<br>&gt;<br>&gt; First, I have often found that you can’t always predict the way which<br>&gt; something will need to be extended.  You think you know, but are then<br>&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt; retroactive modeling.<br>&gt;<br>&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt; boilerplate.<br>&gt;<br>&gt; Things like Swift optionals work well because they make the (often<br>&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt; leads to things like Java and the DMV.<br>&gt;<br>&gt; As Tino said:<br>&gt;<br>&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt; but also will make it much harder for users of those frameworks to work<br>&gt; around their flaws, which are just a natural part of every software.<br>&gt;<br>&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt; their design will just leave these annotations off… leaving us with no<br>&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;<br>&gt;<br>&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt; will see several types of annotations:<br>&gt; 1) This method MUST be overridden<br>&gt; 2) This method should NOT be overridden<br>&gt; 3) This method MUST be called<br>&gt; 3) This method should NOT be called except by subclasses<br>&gt; 4) This method should NOT be called except by a method override calling<br>&gt; super<br>&gt; 5) This method MUST call super<br>&gt; 6) Overrides of this method should NOT call super<br>&gt;<br>&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt; would like to see things be extendable by default, but with annotations that<br>&gt; thoughtful framework designers can use to designate how a particular method<br>&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;<br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt; this problem in the real world.<br>&gt;<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt; modeling allowed by other areas of Swift.<br>&gt;<br>&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?<br>&gt;<br>&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt; (e.g. friend classes).<br>&gt;<br>&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt; for the ability to patch/override in cases where the framework designer was<br>&gt; wrong.  That shows a problem inherent with the design...<br>&gt;<br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt; control that touched on this subject as well.  I have been designing<br>&gt; frameworks for years.<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt; manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br></p><p>Seriously though<br></p><p>&gt; Mine is the opinion of a library-maker,<br>&gt; yours of the user of poorly designed/developed libraries.<br></p><p>this kind of attitude on this list got to stop.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt; not care for you to design and develop a great library because s/he is<br>&gt; not caring for the library at all. I right now have to go through the<br>&gt; burdensome activity of marking too many classes/methods as final to<br>&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt; <br>&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt; this proposal, developer of such libraries will have much burden to<br>&gt; make/keep a poor library or will have to work on better<br>&gt; design/implementation for it to suit its purpose.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; Strong -1 too.<br>&gt;&gt; <br>&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt; arbitrary classes and methods.<br>&gt;&gt; <br>&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt; perfectly supported anyway.<br>&gt;&gt; <br>&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt; classes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; A **strong** -1<br>&gt;&gt; <br>&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt; retroactive modeling.<br>&gt;&gt; <br>&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt; boilerplate.<br>&gt;&gt; <br>&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt; <br>&gt;&gt; As Tino said:<br>&gt;&gt; <br>&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt; <br>&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt; will see several types of annotations:<br>&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt; 3) This method MUST be called<br>&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt; super<br>&gt;&gt; 5) This method MUST call super<br>&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt; <br>&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt; <br>&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt; this problem in the real world.<br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt; (e.g. friend classes).<br>&gt;&gt; <br>&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt; frameworks for years.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt; manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt; <br>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/26734734/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>Goffredo, sorry if it felt offensive. It was not my intention. I&#39;ve dealt with so many different libraries where, as many already pointed out here, has to rely on &quot;fixing&quot; the library themselves. This is not what a library was supposed to be and I might have left a few of my bad experiences speak louder.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Goffredo Marocchi&quot; &lt;panajev at gmail.com&gt;<br>Sent: ‎07/‎07/‎2016 01:39 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Jean-Daniel Dupas&quot; &lt;mailing at xenonium.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Review] SE-0117: Default classes to benon-subclassable publicly<br></p><p>I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br></p><p><br>Seriously though<br></p><p><br>Mine is the opinion of a library-maker,<br>yours of the user of poorly designed/developed libraries.<br></p><p><br>this kind of attitude on this list got to stop.<br></p><p>Sent from my iPhone<br></p><p>On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>Jean, IMO marking every class as subclassable means the creator does<br>not care for you to design and develop a great library because s/he is<br>not caring for the library at all. I right now have to go through the<br>burdensome activity of marking too many classes/methods as final to<br>prevent misuse of my libraries and find good design workarounds when I<br>need to subclass internally what I don&#39;t want you to subclass.<br></p><p>IMO the usage of a library is to be crafted/planned/designed by their<br>developers not their users. Mine is the opinion of a library-maker,<br>yours of the user of poorly designed/developed libraries. By pushing<br>this proposal, developer of such libraries will have much burden to<br>make/keep a poor library or will have to work on better<br>design/implementation for it to suit its purpose.<br></p><p>L<br></p><p>On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br></p><p>* What is your evaluation of the proposal?<br></p><p><br></p><p>Strong -1 too.<br></p><p><br></p><p>I can’t count the number of times it save my hours tone able to override<br></p><p>arbitrary classes and methods.<br></p><p><br></p><p>Sometimes to simply add log point to understand how the API work. Other<br></p><p>times to workaround bugs in the library. Or even to extends the library in a<br></p><p>way that the author did not intent in the first place, but that was<br></p><p>perfectly supported anyway.<br></p><p><br></p><p>I already see how libraries author will react to that new default. They will<br></p><p>either don’t care and mark all classes as subclassable, or find to<br></p><p>burdensome to get subclassability right and prohibit subclassing all<br></p><p>classes.<br></p><p><br></p><p><br></p><p>Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br></p><p>&lt;swift-evolution at swift.org&gt; a écrit :<br></p><p><br></p><p>* What is your evaluation of the proposal?<br></p><p><br></p><p>A **strong** -1<br></p><p><br></p><p>First, I have often found that you can’t always predict the way which<br></p><p>something will need to be extended.  You think you know, but are then<br></p><p>surprised by creative uses.  My favorite features of Swift/Cocoa involve<br></p><p>retroactive modeling.<br></p><p><br></p><p>Second, I don’t think this proposal will achieve its stated objective of<br></p><p>forcing people to think about subclassing more.  It will just add confusing<br></p><p>boilerplate.<br></p><p><br></p><p>Things like Swift optionals work well because they make the (often<br></p><p>forgotten) choices explicit in the context that they are used.  In the world<br></p><p>of Human Factors, we call it a forcing function.  This proposal has the<br></p><p>inverse structure, and will be ineffective, because the “forcing” part of it<br></p><p>shows up in a different context (i.e. trying to use a framework) than the<br></p><p>decision is being made in (writing the framework).  This type of thinking<br></p><p>leads to things like Java and the DMV.<br></p><p><br></p><p>As Tino said:<br></p><p><br></p><p>No matter what the defaults are, good libraries are hard to build, so I<br></p><p>predict this proposal would not only fail in increasing framework quality,<br></p><p>but also will make it much harder for users of those frameworks to work<br></p><p>around their flaws, which are just a natural part of every software.<br></p><p><br></p><p>I think he is right on here.  Those who were prone to be thoughtful about<br></p><p>their design would have been anyway.  Those who are not thoughtful about<br></p><p>their design will just leave these annotations off… leaving us with no<br></p><p>recourse to extend/modify classes.  When people complain, they will add the<br></p><p>annotations without actually thinking about the meaning (i.e. stack overflow<br></p><p>/ the fixit tells me I need to add this word to make the compiler happy).<br></p><p>All this does is put framework users at the mercy of the framework writers.<br></p><p><br></p><p><br></p><p>Finally, this proposal is missing important aspects of the problem space.<br></p><p>If we truly want to solve the issue of subclassing, we need to consider all<br></p><p>of the common issues which arise.  Looking at the cocoa documentation you<br></p><p>will see several types of annotations:<br></p><p>1) This method MUST be overridden<br></p><p>2) This method should NOT be overridden<br></p><p>3) This method MUST be called<br></p><p>3) This method should NOT be called except by subclasses<br></p><p>4) This method should NOT be called except by a method override calling<br></p><p>super<br></p><p>5) This method MUST call super<br></p><p>6) Overrides of this method should NOT call super<br></p><p><br></p><p>If we are attempting to bring thoughtfulness to the design of classes, I<br></p><p>would like to see things be extendable by default, but with annotations that<br></p><p>thoughtful framework designers can use to designate how a particular method<br></p><p>should be used.  In most cases, it should not explicitly forbid the end user<br></p><p>from subclassing, but require them to acknowledge that what they are doing<br></p><p>is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br></p><p>would feel 1000x more swifty to me.  Opt-out safety.<br></p><p><br></p><p>* Is the problem being addressed significant enough to warrant a change to<br></p><p>Swift?<br></p><p><br></p><p>No. It doesn’t actually solve the problem... and I haven’t actually run into<br></p><p>this problem in the real world.<br></p><p><br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p><br></p><p>No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br></p><p>while failing to achieve its objective.  It goes against the retroactive<br></p><p>modeling allowed by other areas of Swift.<br></p><p><br></p><p>* If you have used other languages or libraries with a similar feature, how<br></p><p>do you feel that this proposal compares to those?<br></p><p><br></p><p>I tend to avoid languages which require this sort of thing.  In other<br></p><p>languages that lock things down, there is a need to unlock things soon after<br></p><p>(e.g. friend classes).<br></p><p><br></p><p>I predict the same thing will happen here.  People will quickly be asking<br></p><p>for the ability to patch/override in cases where the framework designer was<br></p><p>wrong.  That shows a problem inherent with the design...<br></p><p><br></p><p>* How much effort did you put into your review? A glance, a quick reading,<br></p><p>or an in-depth study?<br></p><p><br></p><p>Read the proposal &amp; discussion.  Read earlier discussions around access<br></p><p>control that touched on this subject as well.  I have been designing<br></p><p>frameworks for years.<br></p><p><br></p><p>Thanks,<br></p><p>Jon<br></p><p><br></p><p>Hello Swift community,<br></p><p><br></p><p>The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br></p><p>begins now and runs through July 11. The proposal is available here:<br></p><p><br></p><p>   https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p><br></p><p>Reviews are an important part of the Swift evolution process. All reviews<br></p><p>should be sent to the swift-evolution mailing list at<br></p><p><br></p><p>   https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>or, if you would like to keep your feedback private, directly to the review<br></p><p>manager.<br></p><p><br></p><p>What goes into a review?<br></p><p><br></p><p>The goal of the review process is to improve the proposal under review<br></p><p>through constructive criticism and contribute to the direction of Swift.<br></p><p>When writing your review, here are some questions you might want to answer<br></p><p>in your review:<br></p><p><br></p><p>   * What is your evaluation of the proposal?<br></p><p>   * Is the problem being addressed significant enough to warrant a change to<br></p><p>Swift?<br></p><p>   * Does this proposal fit well with the feel and direction of Swift?<br></p><p>   * If you have used other languages or libraries with a similar feature, how<br></p><p>do you feel that this proposal compares to those?<br></p><p>   * How much effort did you put into your review? A glance, a quick reading,<br></p><p>or an in-depth study?<br></p><p><br></p><p>More information about the Swift evolution process is available at<br></p><p><br></p><p>   https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p><br></p><p>Thank you,<br></p><p><br></p><p>-Chris Lattner<br></p><p>Review Manager<br></p><p><br></p><p><br></p><p>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br></p><p>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/f166d893/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br></p><p>Making classes harder to work with is not a specific goal, no. :)<br></p><p>I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br></p><p>I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br></p><p>Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br></p><p>John.<br></p><p>&gt; <br>&gt; Seriously though<br>&gt; <br>&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt; <br>&gt; this kind of attitude on this list got to stop.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt; <br>&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt; <br>&gt;&gt; L<br>&gt;&gt; <br>&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt; classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt; super<br>&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt; manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/64ea7d2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  8, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt; <br>&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt; <br>&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt; <br>&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt; <br>&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt; <br></p><p>Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br></p><p>It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br></p><p>1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br></p><p>2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br></p><p>In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br></p><p>-Matthew<br></p><p>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Seriously though<br>&gt;&gt; <br>&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt; <br>&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; L<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/c8a0cd9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July  8, 2016 at 11:00:00pm</p></header><div class="content"><p>* What is your evaluation of this proposal?<br></p><p>A reluctant +1. I’m reluctant because I actually do love the flexibility in Obj-C to subclass where I feel appropriate, and feel the limitations of this are going to be difficult to get used to.<br></p><p>From what I see, however, “final” as a concept makes this more compelling. Being able to retroactively add final to a class is a great benefit for libraries, and this won’t be possible if we allow subclassing by default. Additionally, designing for subclassing is important and really should be considered at design time. I also think we need to flesh out the subclassing in this proposal where there are requirements to the override etc, but I agree in general with this concept.<br></p><p><br>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>There are multiple problems that this addresses. A change is definitely needed here to resolve them, whatever the form these changes take.<br></p><p><br>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Clarity at requirements for subclassing, and being more specific, seems in the direction of Swift.<br></p><p><br>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve used plenty of languages with subclassing, focusing most on Obj-C. I love the freedom to subclass in this language, but it’s fair that this is not the safest practice. Obj-C seems to be the wild west for subclassing.<br></p><p><br>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve read the proposal, followed the conversation, and was involved in the first discussions about this earlier in the year.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt; <br>&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt; <br>&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.<br>It is dramatic, and your whole argument is flawed because you miss the imho most important point.<br>This is not only a question of &quot;will I be able to override this tiny method of UIView in the future?&quot;, but a question of attitude:<br>When you do away with the rule of lenity and change it to &quot;guilty by default&quot;, the direct impact is marginal as well — but it is a drastic change for the society as a whole.<br></p><p>Defaults matter, because they transmit a message:<br>Every rule and obstacle we add to Swift is a statement that says &quot;we favor bureaucracy over freedom&quot;, and this will affect the community evolving around the language.<br>When you use a library in a way that wasn&#39;t anticipated by its author, you&#39;ll ran into issues occasionally; nonetheless, I think we should struggle for an open ecosystem that encourages others to experiment and fail, rather than to limit their possibilities in a futile attempt to protect them.<br></p><p>Everyone should ask himself a simple question:<br>When was the last time you you thought &quot;I really wish the author of that library had restricted my options to use it&quot;?<br>As a matter of fact, open by default forces nobody to subclass and override, so it&#39;s easy to avoid any problems caused by excessive hacking — closed by default, on the other hand, has impact not only on those who believe in restrictions, but on those who dislike them as well.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/68892368/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  8, 2016 at 06:00:00pm</p></header><div class="content"><p>You are correct that this is not a very agile - people over processes - move. <br></p><p>Sent from my iPhone<br></p><p>&gt; On 8 Jul 2016, at 18:30, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt; <br>&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt; <br>&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.<br>&gt; It is dramatic, and your whole argument is flawed because you miss the imho most important point.<br>&gt; This is not only a question of &quot;will I be able to override this tiny method of UIView in the future?&quot;, but a question of attitude:<br>&gt; When you do away with the rule of lenity and change it to &quot;guilty by default&quot;, the direct impact is marginal as well — but it is a drastic change for the society as a whole.<br>&gt; <br>&gt; Defaults matter, because they transmit a message:<br>&gt; Every rule and obstacle we add to Swift is a statement that says &quot;we favor bureaucracy over freedom&quot;, and this will affect the community evolving around the language.<br>&gt; When you use a library in a way that wasn&#39;t anticipated by its author, you&#39;ll ran into issues occasionally; nonetheless, I think we should struggle for an open ecosystem that encourages others to experiment and fail, rather than to limit their possibilities in a futile attempt to protect them.<br>&gt; <br>&gt; Everyone should ask himself a simple question:<br>&gt; When was the last time you you thought &quot;I really wish the author of that library had restricted my options to use it&quot;?<br>&gt; As a matter of fact, open by default forces nobody to subclass and override, so it&#39;s easy to avoid any problems caused by excessive hacking — closed by default, on the other hand, has impact not only on those who believe in restrictions, but on those who dislike them as well.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/a1b1a9bf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 8, 2016, at 12:30 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt; <br>&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt; <br>&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.<br>&gt; It is dramatic, and your whole argument is flawed because you miss the imho most important point.<br></p><p>I didn&#39;t say it isn&#39;t dramatic, only that it isn&#39;t as dramatic a change as some commenters seem to suggest.<br></p><p>&gt; This is not only a question of &quot;will I be able to override this tiny method of UIView in the future?&quot;, but a question of attitude:<br>&gt; When you do away with the rule of lenity and change it to &quot;guilty by default&quot;, the direct impact is marginal as well — but it is a drastic change for the society as a whole.<br></p><p>It&#39;s not about guilt or innocence, or any kind of lenience or punishment.  <br></p><p>It&#39;s mostly about whether we want to foster an ecosystem where public API contracts have been explicitly considered or not.  There are some ancillary benefits as well but those are much less important.<br></p><p>&gt; <br>&gt; Defaults matter, because they transmit a message:<br></p><p>I agree.<br></p><p>&gt; Every rule and obstacle we add to Swift is a statement that says &quot;we favor bureaucracy over freedom&quot;, and this will affect the community evolving around the language.<br>&gt; When you use a library in a way that wasn&#39;t anticipated by its author, you&#39;ll ran into issues occasionally; nonetheless, I think we should struggle for an open ecosystem that encourages others to experiment and fail, rather than to limit their possibilities in a futile attempt to protect them.<br></p><p>In a majority of cases today this openness is better fostered by Github than &quot;anything goes&quot; public API.<br></p><p>&gt; <br>&gt; Everyone should ask himself a simple question:<br>&gt; When was the last time you you thought &quot;I really wish the author of that library had restricted my options to use it&quot;?<br></p><p>I really wish Objective-C had this feature from the start.  I believe there would have been significant benefits to Apple&#39;s platforms and ecosystem.  The reasons for believing (or not believing) this have been discussed in depth so there isn&#39;t a need to rehash them now.<br></p><p>&gt; As a matter of fact, open by default forces nobody to subclass and override, so it&#39;s easy to avoid any problems caused by excessive hacking — closed by default, on the other hand, has impact not only on those who believe in restrictions, but on those who dislike them as well.<br></p><p>Actually open by default has caused some very nontrivial difficulties for Apple&#39;s framework maintainers.  We all pay the price for this whether we engage in such subclassing and overriding or not.  I find that pretty unfortunate, especially for those of us who do find other ways to solve our problems.<br></p><p>-Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/9489bd6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Just to relax a bit, from reading this thread I cannot help but feel a<br>relation to Civil War. One can even say on which side everyone here<br>would stand for real. #TeamIronMan<br></p><p>L<br></p><p>On 8 July 2016 at 15:13, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jul 8, 2016, at 12:30 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;<br>&gt;<br>&gt; 1. As you point out, the majority of the surface area of idiomatic Swift<br>&gt; APIs are unlikely to be impacted (value types, protocols, and final<br>&gt; classes).  This is very likely to apply to future Swift-native APIs from<br>&gt; Apple regardless of the outcome of this proposal.<br>&gt;<br>&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;<br>&gt; In the context of these facts, this proposal is not nearly as dramatic a<br>&gt; change as many seem to be suggesting.<br>&gt;<br>&gt; It is dramatic, and your whole argument is flawed because you miss the imho<br>&gt; most important point.<br>&gt;<br>&gt;<br>&gt; I didn&#39;t say it isn&#39;t dramatic, only that it isn&#39;t as dramatic a change as<br>&gt; some commenters seem to suggest.<br>&gt;<br>&gt; This is not only a question of &quot;will I be able to override this tiny method<br>&gt; of UIView in the future?&quot;, but a question of attitude:<br>&gt; When you do away with the rule of lenity and change it to &quot;guilty by<br>&gt; default&quot;, the direct impact is marginal as well — but it is a drastic change<br>&gt; for the society as a whole.<br>&gt;<br>&gt;<br>&gt; It&#39;s not about guilt or innocence, or any kind of lenience or punishment.<br>&gt;<br>&gt; It&#39;s mostly about whether we want to foster an ecosystem where public API<br>&gt; contracts have been explicitly considered or not.  There are some ancillary<br>&gt; benefits as well but those are much less important.<br>&gt;<br>&gt;<br>&gt; Defaults matter, because they transmit a message:<br>&gt;<br>&gt;<br>&gt; I agree.<br>&gt;<br>&gt; Every rule and obstacle we add to Swift is a statement that says &quot;we favor<br>&gt; bureaucracy over freedom&quot;, and this will affect the community evolving<br>&gt; around the language.<br>&gt; When you use a library in a way that wasn&#39;t anticipated by its author,<br>&gt; you&#39;ll ran into issues occasionally; nonetheless, I think we should struggle<br>&gt; for an open ecosystem that encourages others to experiment and fail, rather<br>&gt; than to limit their possibilities in a futile attempt to protect them.<br>&gt;<br>&gt;<br>&gt; In a majority of cases today this openness is better fostered by Github than<br>&gt; &quot;anything goes&quot; public API.<br>&gt;<br>&gt;<br>&gt; Everyone should ask himself a simple question:<br>&gt; When was the last time you you thought &quot;I really wish the author of that<br>&gt; library had restricted my options to use it&quot;?<br>&gt;<br>&gt;<br>&gt; I really wish Objective-C had this feature from the start.  I believe there<br>&gt; would have been significant benefits to Apple&#39;s platforms and ecosystem.<br>&gt; The reasons for believing (or not believing) this have been discussed in<br>&gt; depth so there isn&#39;t a need to rehash them now.<br>&gt;<br>&gt; As a matter of fact, open by default forces nobody to subclass and override,<br>&gt; so it&#39;s easy to avoid any problems caused by excessive hacking — closed by<br>&gt; default, on the other hand, has impact not only on those who believe in<br>&gt; restrictions, but on those who dislike them as well.<br>&gt;<br>&gt;<br>&gt; Actually open by default has caused some very nontrivial difficulties for<br>&gt; Apple&#39;s framework maintainers.  We all pay the price for this whether we<br>&gt; engage in such subclassing and overriding or not.  I find that pretty<br>&gt; unfortunate, especially for those of us who do find other ways to solve our<br>&gt; problems.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; When was the last time you you thought &quot;I really wish the author of that library had restricted my options to use it&quot;?<br>&gt; <br>&gt; I really wish Objective-C had this feature from the start.  I believe there would have been significant benefits to Apple&#39;s platforms and ecosystem.  The reasons for believing (or not believing) this have been discussed in depth so there isn&#39;t a need to rehash them now.<br>I&#39;m not asking for reasons but for a single persuasive example…<br></p><p>It is easy to claim that everything will be better if we add restrictions, but so far, I haven&#39;t heard of any real problems cause by the current defaults:<br>The motivation to change them is not because of actual experience, it&#39;s just the trendy opinion that inheritance is evil.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/11e1a4ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  8, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;ve sent one I currently have myself. Look back on the thread posts.<br></p><p>L<br></p><p><br>On 8 July 2016 at 18:14, Tino Heth via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; When was the last time you you thought &quot;I really wish the author of that<br>&gt; library had restricted my options to use it&quot;?<br>&gt;<br>&gt;<br>&gt; I really wish Objective-C had this feature from the start.  I believe there<br>&gt; would have been significant benefits to Apple&#39;s platforms and ecosystem.<br>&gt; The reasons for believing (or not believing) this have been discussed in<br>&gt; depth so there isn&#39;t a need to rehash them now.<br>&gt;<br>&gt; I&#39;m not asking for reasons but for a single persuasive example…<br>&gt;<br>&gt; It is easy to claim that everything will be better if we add restrictions,<br>&gt; but so far, I haven&#39;t heard of any real problems cause by the current<br>&gt; defaults:<br>&gt; The motivation to change them is not because of actual experience, it&#39;s just<br>&gt; the trendy opinion that inheritance is evil.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  8, 2016 at 04:00:00pm</p></header><div class="content"><p>The stories I’ve seen about things Apple’s frameworks need to deal with are another.  I don’t have links handy but they shouldn’t be too hard to find for anyone interested in looking.<br></p><p>&gt; On Jul 8, 2016, at 4:21 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve sent one I currently have myself. Look back on the thread posts.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; <br>&gt; On 8 July 2016 at 18:14, Tino Heth via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When was the last time you you thought &quot;I really wish the author of that<br>&gt;&gt; library had restricted my options to use it&quot;?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I really wish Objective-C had this feature from the start.  I believe there<br>&gt;&gt; would have been significant benefits to Apple&#39;s platforms and ecosystem.<br>&gt;&gt; The reasons for believing (or not believing) this have been discussed in<br>&gt;&gt; depth so there isn&#39;t a need to rehash them now.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not asking for reasons but for a single persuasive example…<br>&gt;&gt; <br>&gt;&gt; It is easy to claim that everything will be better if we add restrictions,<br>&gt;&gt; but so far, I haven&#39;t heard of any real problems cause by the current<br>&gt;&gt; defaults:<br>&gt;&gt; The motivation to change them is not because of actual experience, it&#39;s just<br>&gt;&gt; the trendy opinion that inheritance is evil.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Two days ago, I challenged the supporters of this proposal to show a singe persuasive example to illustrate that this proposal could actually improve something.<br>I got a single reply — which did not contain an example, but just the claim that there is one…<br>Imho that alone should be enough to cancel the whole thing, because even if there are cases which cannot be repelled with the simple advice &quot;just don&#39;t subclass&quot;, this would only be a basis to start talking about the actual pros and cons.<br></p><p>So for me, the promised benefits are less likely than the existence of Bigfoot:<br>I guess there are at least several hundred people who swore they have seen him, and there are even some blurry photos ;-)<br></p><p>Of course, it is impossible to come up with an unquestionable argument for the change — and it&#39;s also impossible to prove the opposite, because the whole debate makes as much sense as arguing wether raisins are tasteful or terrible; it&#39;s nothing but personal preference, and the only thing we can hope for is that the bias of those who will decide this proposal isn&#39;t at odds with the needs of the majority.<br></p><p>If we can agree that it is not about facts, but about opinion, there are still fundamental arguments against SE-0117:<br>Those who have issues with subclassing can just resign from it (as users of a library), and they can annotate their classes to dictate their usage (as an author) — but if you think subclassing is still a good tool, you can&#39;t do anything with a sealed class.<br>Additionally, please note that those who ask for stricter rules and more regulation have many reasons to be happy with the status quo:<br>You can subclass neither structs nor enums, and by default, you can&#39;t inherit from a framework-class as well, because it is internal — and yet they yell for more.<br></p><p>Swift claims to be opinionated, not to aim for compromise — but if plain old OO isn&#39;t compatible with the ideals of the language, it would be more honest to just completely remove inheritance instead of slowly crippling it&#39;s possibilities.<br></p><p>- Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br></p><p>I&#39;m currently working on an app which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br></p><p>There may be several more examples but this is one I&#39;m facing right now, so I can assure you it is a true example. IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br></p><p>Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br></p><p>About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br></p><p>Swift doesn&#39;t have to follow on the footsteps of any language but what is best for the intention the language was created for. If sealed by default goes in that direction, then we should have it not looking back. The same goes if we decide this is not taking the language in its intended direction. If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Tino Heth via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎10/‎07/‎2016 01:55 PM<br>To: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Cc: &quot;Jean-Daniel Dupas&quot; &lt;mailing at xenonium.com&gt;<br>Subject: Re: [swift-evolution] [Review] SE-0117: Default classes to benon-subclassable publicly<br></p><p>Two days ago, I challenged the supporters of this proposal to show a singe persuasive example to illustrate that this proposal could actually improve something.<br>I got a single reply — which did not contain an example, but just the claim that there is one…<br>Imho that alone should be enough to cancel the whole thing, because even if there are cases which cannot be repelled with the simple advice &quot;just don&#39;t subclass&quot;, this would only be a basis to start talking about the actual pros and cons.<br></p><p>So for me, the promised benefits are less likely than the existence of Bigfoot:<br>I guess there are at least several hundred people who swore they have seen him, and there are even some blurry photos ;-)<br></p><p>Of course, it is impossible to come up with an unquestionable argument for the change — and it&#39;s also impossible to prove the opposite, because the whole debate makes as much sense as arguing wether raisins are tasteful or terrible; it&#39;s nothing but personal preference, and the only thing we can hope for is that the bias of those who will decide this proposal isn&#39;t at odds with the needs of the majority.<br></p><p>If we can agree that it is not about facts, but about opinion, there are still fundamental arguments against SE-0117:<br>Those who have issues with subclassing can just resign from it (as users of a library), and they can annotate their classes to dictate their usage (as an author) — but if you think subclassing is still a good tool, you can&#39;t do anything with a sealed class.<br>Additionally, please note that those who ask for stricter rules and more regulation have many reasons to be happy with the status quo:<br>You can subclass neither structs nor enums, and by default, you can&#39;t inherit from a framework-class as well, because it is internal — and yet they yell for more.<br></p><p>Swift claims to be opinionated, not to aim for compromise — but if plain old OO isn&#39;t compatible with the ideals of the language, it would be more honest to just completely remove inheritance instead of slowly crippling it&#39;s possibilities.<br></p><p>- Tino<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/9e088ed5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br>This list has thousands of messages, this topic alone is split into at least six threads… I tried, but how much time should I spend searching without any helpful hint?<br>But let&#39;s see what we got now...<br></p><p>&gt; I&#39;m currently working on an app<br>wait a minute: An app, not a library? What difference will sealed make here at all?<br></p><p>&gt; which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br>So, how many types of directories may exist that you would have to mark as final? (serious question — please don&#39;t ignore it)<br>I don&#39;t know about you specific model, but for me, invisible directories and bundles would be all I&#39;d be worried about — and those are basically all normal folders as well…<br>So, do those subclasses each have special properties? There is only a limited set of metadata a directory can have, so I expect there is no need for subclassing at all: Is there a special reason why it can&#39;t be a single class, or an enum?<br>This may all be useless advice that doesn&#39;t work for your case — but if I stick with the Sasquatch-metapher, this is a very blurred picture...<br></p><p>&gt; IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br>How is this statement connected to the proposal?<br>The only way to prevent misuse of software is not to write it; and what harm is done to you as the author of a PDF-lib (btw: been there, done that — nasty format ;-) if some stupid user turns your composer into Emacs?<br></p><p>&gt; Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br>good point… Oracle is widely known for its instinctive knowledge about the needs and problems of their customers — which they than tend to ignore and do something different ;-) <br></p><p>&gt; About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br>As long as we don&#39;t speak about commercial libraries, which are a curiosity in the Swift-cosmos:<br>There is no lock, there is not even a door — there is only a tiny sign that says &quot;please don&#39;t enter&quot;, and the worst thing that could happen if you ignore it is that the original owner stops doing the housework.<br></p><p>&gt; If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br>Isn&#39;t this exactly what this proposal is about? Replacing freedom with control? Stop trying to keep control of everything is actually a good idea in the light of this proposal.<br></p><p>I appreciate that you described your case, but it didn&#39;t do anything to convince me.<br></p><p>Tino<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/4a74093c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes tobenon-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Yes, app. Apps can be extended through plugins and you cannot write a plugin to an app without a library that exposes what you can do. That alone can expand my simple sample into a variety of examples: plugins.<br></p><p>For the many types of folders I cannot enter details of my app now but check macOS&#39; folders: aside the basics you have smart folders, disks, remote folders and so forth. They follow the same basics but some specificities will vary. You can create as many different files you want but can you create a new type of folder there? Same here.<br></p><p>Too bad my example did not convince you but subclassing to fix bugs also don&#39;t convince me. I really believed this is the behaviour that leads bugs in a library not to be fixed: because instead of helping improving the library for everyone you fix it for yourself and let it go. The developer of the library doesn&#39;t even care to fix the bug since everyone uses your subclass fix or he finds out purple doing this, fixes the bug and puts a final there breaking everyone&#39;s app.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Tino Heth&quot; &lt;2th at gmx.de&gt;<br>Sent: ‎10/‎07/‎2016 05:47 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;; &quot;Jean-Daniel Dupas&quot; &lt;mailing at xenonium.com&gt;<br>Subject: Re: [swift-evolution] [Review] SE-0117: Default classes tobenon-subclassable publicly<br></p><p><br></p><p>Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br></p><p>This list has thousands of messages, this topic alone is split into at least six threads… I tried, but how much time should I spend searching without any helpful hint?<br>But let&#39;s see what we got now...<br></p><p><br>I&#39;m currently working on an app <br>wait a minute: An app, not a library? What difference will sealed make here at all?<br></p><p><br>which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br></p><p>So, how many types of directories may exist that you would have to mark as final? (serious question — please don&#39;t ignore it)<br>I don&#39;t know about you specific model, but for me, invisible directories and bundles would be all I&#39;d be worried about — and those are basically all normal folders as well…<br>So, do those subclasses each have special properties? There is only a limited set of metadata a directory can have, so I expect there is no need for subclassing at all: Is there a special reason why it can&#39;t be a single class, or an enum?<br>This may all be useless advice that doesn&#39;t work for your case — but if I stick with the Sasquatch-metapher, this is a very blurred picture...<br></p><p><br>IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br></p><p>How is this statement connected to the proposal?<br>The only way to prevent misuse of software is not to write it; and what harm is done to you as the author of a PDF-lib (btw: been there, done that — nasty format ;-) if some stupid user turns your composer into Emacs?<br></p><p><br>Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br></p><p>good point… Oracle is widely known for its instinctive knowledge about the needs and problems of their customers — which they than tend to ignore and do something different ;-) <br></p><p><br>About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br></p><p>As long as we don&#39;t speak about commercial libraries, which are a curiosity in the Swift-cosmos:<br>There is no lock, there is not even a door — there is only a tiny sign that says &quot;please don&#39;t enter&quot;, and the worst thing that could happen if you ignore it is that the original owner stops doing the housework.<br></p><p><br>If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br></p><p>Isn&#39;t this exactly what this proposal is about? Replacing freedom with control? Stop trying to keep control of everything is actually a good idea in the light of this proposal.<br></p><p><br>I appreciate that you described your case, but it didn&#39;t do anything to convince me.<br></p><p><br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/adbb50f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Review] SE-0117: Default classes tobenon-subclassable publicly</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>IMHO SE-0117 is one of the worst Swift 3 proposals that have ever been proposed. It has the potential to make the language much worse. I haven&#39;t seen any problems at all that are caused by people trying to subclass classes that they shouldn&#39;t, so I&#39;m wondering where this fear of bad subclass behavior comes from. And for the performance argument: there is no performance benefit of this proposal. I cannot prove this of course, but you&#39;ll remember my words in a year or so, when this proposal has been adopted and we can measure the alleged benefits of it. I can already see how this &quot;feature&quot; will be rolled back for Swift 4 ;)<br></p><p>I&#39;m not against change in general. I think going from Swift 1 to Swift 2 was a big improvement. Swift 2 to Swift 3 is overall okay, but it gets worse by introducing things like NoReturn/Never or sealed subclasses.<br></p><p>-Michael<br></p><p>&gt; Am 11.07.2016 um 00:53 schrieb Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Yes, app. Apps can be extended through plugins and you cannot write a plugin to an app without a library that exposes what you can do. That alone can expand my simple sample into a variety of examples: plugins.<br>&gt; <br>&gt; For the many types of folders I cannot enter details of my app now but check macOS&#39; folders: aside the basics you have smart folders, disks, remote folders and so forth. They follow the same basics but some specificities will vary. You can create as many different files you want but can you create a new type of folder there? Same here.<br>&gt; <br>&gt; Too bad my example did not convince you but subclassing to fix bugs also don&#39;t convince me. I really believed this is the behaviour that leads bugs in a library not to be fixed: because instead of helping improving the library for everyone you fix it for yourself and let it go. The developer of the library doesn&#39;t even care to fix the bug since everyone uses your subclass fix or he finds out purple doing this, fixes the bug and puts a final there breaking everyone&#39;s app.<br>&gt; <br>&gt; L<br>&gt; From: Tino Heth<br>&gt; Sent: ‎10/‎07/‎2016 05:47 PM<br>&gt; To: Leonardo Pessoa<br>&gt; Cc: swift-evolution; Jean-Daniel Dupas<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0117: Default classes tobenon-subclassable publicly<br>&gt; <br>&gt; <br>&gt;&gt; Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br>&gt; This list has thousands of messages, this topic alone is split into at least six threads… I tried, but how much time should I spend searching without any helpful hint?<br>&gt; But let&#39;s see what we got now...<br>&gt; <br>&gt;&gt; I&#39;m currently working on an app<br>&gt; wait a minute: An app, not a library? What difference will sealed make here at all?<br>&gt; <br>&gt;&gt; which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br>&gt; So, how many types of directories may exist that you would have to mark as final? (serious question — please don&#39;t ignore it)<br>&gt; I don&#39;t know about you specific model, but for me, invisible directories and bundles would be all I&#39;d be worried about — and those are basically all normal folders as well…<br>&gt; So, do those subclasses each have special properties? There is only a limited set of metadata a directory can have, so I expect there is no need for subclassing at all: Is there a special reason why it can&#39;t be a single class, or an enum?<br>&gt; This may all be useless advice that doesn&#39;t work for your case — but if I stick with the Sasquatch-metapher, this is a very blurred picture...<br>&gt; <br>&gt;&gt; IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br>&gt; How is this statement connected to the proposal?<br>&gt; The only way to prevent misuse of software is not to write it; and what harm is done to you as the author of a PDF-lib (btw: been there, done that — nasty format ;-) if some stupid user turns your composer into Emacs?<br>&gt; <br>&gt;&gt; Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br>&gt; good point… Oracle is widely known for its instinctive knowledge about the needs and problems of their customers — which they than tend to ignore and do something different ;-) <br>&gt; <br>&gt;&gt; About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br>&gt; As long as we don&#39;t speak about commercial libraries, which are a curiosity in the Swift-cosmos:<br>&gt; There is no lock, there is not even a door — there is only a tiny sign that says &quot;please don&#39;t enter&quot;, and the worst thing that could happen if you ignore it is that the original owner stops doing the housework.<br>&gt; <br>&gt;&gt; If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br>&gt; Isn&#39;t this exactly what this proposal is about? Replacing freedom with control? Stop trying to keep control of everything is actually a good idea in the light of this proposal.<br>&gt; <br>&gt; I appreciate that you described your case, but it didn&#39;t do anything to convince me.<br>&gt; <br>&gt; Tino<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>To share some perspective, I come from working on 200k to 500k LOC systems, with the largest (aside linux kernel drivers) being ~2M loc/20,000 cpp files. I have done my share of objc coding, much of it for my own usage. My interest in swift has to do with finding a scalable solution for client server systems where code would be shared between the two sides. Currently I do that with c# and started experimenting with phonegap&amp;node using typescript (I share Anders Hejlsberg&#39;s view that past a few 1000 locs javascript becomes readonly). <br>If I can appreciate that as an app-only language a number of tradeoffs are not terribly important in the long run, I question whether the same choices are equally inconsequential at the other end of the scale. I took seriously that apple will let swift become credible on the server side, but it might require that this community remembers to consider both ends of the scale when helping shape this language. I have read a lot past discussions of the last month, and I do wonder where people see this language go, and more importantly where they want to see it go. I do hope the future of swift is not just made of apps.<br>Regards<br>(From mobile)<br>&gt; On Jul 10, 2016, at 10:47 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br>&gt; This list has thousands of messages, this topic alone is split into at least six threads… I tried, but how much time should I spend searching without any helpful hint?<br>&gt; But let&#39;s see what we got now...<br>&gt; <br>&gt;&gt; I&#39;m currently working on an app<br>&gt; wait a minute: An app, not a library? What difference will sealed make here at all?<br>&gt; <br>&gt;&gt; which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br>&gt; So, how many types of directories may exist that you would have to mark as final? (serious question — please don&#39;t ignore it)<br>&gt; I don&#39;t know about you specific model, but for me, invisible directories and bundles would be all I&#39;d be worried about — and those are basically all normal folders as well…<br>&gt; So, do those subclasses each have special properties? There is only a limited set of metadata a directory can have, so I expect there is no need for subclassing at all: Is there a special reason why it can&#39;t be a single class, or an enum?<br>&gt; This may all be useless advice that doesn&#39;t work for your case — but if I stick with the Sasquatch-metapher, this is a very blurred picture...<br>&gt; <br>&gt;&gt; IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br>&gt; How is this statement connected to the proposal?<br>&gt; The only way to prevent misuse of software is not to write it; and what harm is done to you as the author of a PDF-lib (btw: been there, done that — nasty format ;-) if some stupid user turns your composer into Emacs?<br>&gt; <br>&gt;&gt; Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br>&gt; good point… Oracle is widely known for its instinctive knowledge about the needs and problems of their customers — which they than tend to ignore and do something different ;-) <br>&gt; <br>&gt;&gt; About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br>&gt; As long as we don&#39;t speak about commercial libraries, which are a curiosity in the Swift-cosmos:<br>&gt; There is no lock, there is not even a door — there is only a tiny sign that says &quot;please don&#39;t enter&quot;, and the worst thing that could happen if you ignore it is that the original owner stops doing the housework.<br>&gt; <br>&gt;&gt; If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br>&gt; Isn&#39;t this exactly what this proposal is about? Replacing freedom with control? Stop trying to keep control of everything is actually a good idea in the light of this proposal.<br>&gt; <br>&gt; I appreciate that you described your case, but it didn&#39;t do anything to convince me.<br>&gt; <br>&gt; Tino<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/719552e9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36603be464733b58cc53cecd480eeae8?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>let var go</string> &lt;letvargo at gmail.com&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>Leonardo&#39;s example makes the case for why Swift should adopt a &#39;sealed&#39;<br>keyword that can be used to make public classes non-subclassable outside<br>the module where they are defined, but not for why this should be the<br>default.<br></p><p>Others have made these points before, but these are the two biggest reasons<br>I can see against making public classes non-subclassable by default:<br></p><p>1. It is the opposite of nearly every other OOP language&#39;s behavior and the<br>opposite of what anyone will expect who is coming to Swift after doing any<br>OOP programming anywhere else. While I believe that Swift should be free to<br>buck the trends of other languages where there are significant advantages,<br>changing something this fundamental will introduce a new learning curve for<br>even experienced programmers. The advantages better be significant,<br>otherwise you are introducing a frustrating quirk into the language without<br>any great benefit in exchange. But the advantages of default<br>non-subclassability are marginal at best. Whatever advantage there is can<br>be achieved by making it opt-in using a &#39;sealed&#39; keywrod, instead of by<br>making it the default.<br></p><p>2. The motivation seems to be that it will force better API design. On<br>average, I can&#39;t believe that it will. Assume that there are two kinds of<br>developers: Those that make careful decisions about their API design and<br>those that don&#39;t. The ones that make careful decisions about their API<br>design will continue to do so - I don&#39;t see any significant improvement to<br>their code by making non-subclassability the default. The developers who<br>don&#39;t make careful design decisions will just go with the default - in this<br>case they will just leave the default in place, and their public classes<br>will not be subclassable. That doesn&#39;t improve anything, it just makes<br>sloppy, poorly written code harder to fix in the off-chance that you are<br>stuck working with it. In other words, quality will not improve, but<br>productivity will suffer, because it will be harder to develop workarounds<br>for the problems that will inevitably appear in even the best-designed APIs.<br></p><p>3. It is a bad interpretation of the stated goal that Swift should help<br>developers produce &quot;safe code.&quot; Some folks seem to believe that this means<br>that the language should protect people from themselves. If I am using your<br>API in my code and I screw it up by subclassing something that I shouldn&#39;t<br>have, that is somehow a language defect. It is not a language defect - it<br>is me being an idiot. Don&#39;t spend a lot of time trying to make a language<br>idiot-proof - idiots are geniuses and you will never outsmart them.<br>Personally, when I read that Swift helps produce &quot;safe code&quot;, what that<br>means primarily is that it has a type system that helps reveal the vast<br>majority of bugs that would otherwise go unnoticed until runtime. In other<br>words, safety is related to discovering hidden flaws in the program. (Type<br>safety isn&#39;t the only feature that helps with this, but it is perhaps the<br>main one.) But this whole issue of default non-subclassability doesn&#39;t fall<br>into that category of &quot;safety&quot; at all. It doesn&#39;t help a programmer produce<br>safer code. The same hidden flaws will persist whether non-subclassability<br>is the default or not. The difference is that those same hidden flaws will<br>be more difficult to deal with after the fact.<br></p><p>To sum it up, +1 for introducing a &#39;sealed&#39; keyword, but -1 for making it<br>the default behavior for public classes.<br></p><p>On Sun, Jul 10, 2016 at 12:18 PM Leonardo Pessoa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Should I assume then you want so much this proposal to be dropped you<br>&gt; didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this<br>&gt; proposal is needed? Fine, here is the whole of that example.<br>&gt;<br>&gt; I&#39;m currently working on an app which will have object representations of<br>&gt; Files and Folders (both come from a common class called Entry). You as a<br>&gt; developer for this system will be entitled to extend from File and Entry<br>&gt; freely but you can only work with Folders and its subclasses (specialised<br>&gt; folders) but to this system it is important you don&#39;t subclass any type of<br>&gt; folder. Without this proposal I would have to create workarounds to prevent<br>&gt; you from doing that while still allowing me to subclass while playing a lot<br>&gt; of finals everywhere. And so far I would have to allow you to subclass<br>&gt; Folder itself (at least) but you would complain (and possibly file a bug<br>&gt; report to me) because it would not be working properly because your classes<br>&gt; would not benefit from the workaround. In this case, if I could subclass<br>&gt; internally but prevent you from doing it, you could complain I&#39;m not<br>&gt; allowing you to do whatever you want but you wouldn&#39;t complain my code<br>&gt; doesn&#39;t work properly (it does, you just won&#39;t know it).<br>&gt;<br>&gt; There may be several more examples but this is one I&#39;m facing right now,<br>&gt; so I can assure you it is a true example. IMO libraries are to be written<br>&gt; with intention in mind and I don&#39;t think it is right to use a library<br>&gt; written to compose a PDF file to send an email (even if you&#39;re sending the<br>&gt; PDF file attached, the right way to do it is by composition not<br>&gt; subclassing).<br>&gt;<br>&gt; Additionally, someone mentioned and I went in to check about a<br>&gt; recommendation for Java to intentionally document and enable classes to be<br>&gt; subclasses explicitly otherwise forbid it at all and that recommendation<br>&gt; seems to come from Oracle itself. I believe Oracle would do it to Java if<br>&gt; it had great interest in it without consulting anyone&#39;s opinion.<br>&gt;<br>&gt; About the addition to the proposal to enable force unsealing, I&#39;m<br>&gt; completely opposed as it is just like not having any of this protection at<br>&gt; all (why putting a lock on the door to your house if the key is under the<br>&gt; mat?)<br>&gt;<br>&gt; Swift doesn&#39;t have to follow on the footsteps of any language but what is<br>&gt; best for the intention the language was created for. If sealed by default<br>&gt; goes in that direction, then we should have it not looking back. The same<br>&gt; goes if we decide this is not taking the language in its intended<br>&gt; direction. If I&#39;m not wrong at least one member of the core team already<br>&gt; mentioned in this thread this is completely aligned with the intention of<br>&gt; the language, so I think we should give it a go and stop trying to<br>&gt; have/keep control of everything we touch.<br>&gt;<br>&gt; L<br>&gt; ------------------------------<br>&gt; From: Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Sent: ‎10/‎07/‎2016 01:55 PM<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Cc: Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0117: Default classes to<br>&gt; benon-subclassable publicly<br>&gt;<br>&gt; Two days ago, I challenged the supporters of this proposal to show a singe<br>&gt; persuasive example to illustrate that this proposal could actually improve<br>&gt; something.<br>&gt; I got a single reply — which did not contain an example, but just the<br>&gt; claim that there is one…<br>&gt; Imho that alone should be enough to cancel the whole thing, because even<br>&gt; if there are cases which cannot be repelled with the simple advice &quot;just<br>&gt; don&#39;t subclass&quot;, this would only be a basis to start talking about the<br>&gt; actual pros and cons.<br>&gt;<br>&gt; So for me, the promised benefits are less likely than the existence of<br>&gt; Bigfoot:<br>&gt; I guess there are at least several hundred people who swore they have seen<br>&gt; him, and there are even some blurry photos ;-)<br>&gt;<br>&gt; Of course, it is impossible to come up with an unquestionable argument for<br>&gt; the change — and it&#39;s also impossible to prove the opposite, because the<br>&gt; whole debate makes as much sense as arguing wether raisins are tasteful or<br>&gt; terrible; it&#39;s nothing but personal preference, and the only thing we can<br>&gt; hope for is that the bias of those who will decide this proposal isn&#39;t at<br>&gt; odds with the needs of the majority.<br>&gt;<br>&gt; If we can agree that it is not about facts, but about opinion, there are<br>&gt; still fundamental arguments against SE-0117:<br>&gt; Those who have issues with subclassing can just resign from it (as users<br>&gt; of a library), and they can annotate their classes to dictate their usage<br>&gt; (as an author) — but if you think subclassing is still a good tool, you<br>&gt; can&#39;t do anything with a sealed class.<br>&gt; Additionally, please note that those who ask for stricter rules and more<br>&gt; regulation have many reasons to be happy with the status quo:<br>&gt; You can subclass neither structs nor enums, and by default, you can&#39;t<br>&gt; inherit from a framework-class as well, because it is internal — and yet<br>&gt; they yell for more.<br>&gt;<br>&gt; Swift claims to be opinionated, not to aim for compromise — but if plain<br>&gt; old OO isn&#39;t compatible with the ideals of the language, it would be more<br>&gt; honest to just completely remove inheritance instead of slowly crippling<br>&gt; it&#39;s possibilities.<br>&gt;<br>&gt; - Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/ae1d7384/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 8:49 PM, let var go via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2. The motivation seems to be that it will force better API design.<br></p><p>No, that wasn’t my motivation in giving it a +1. This seems to be a common misunderstanding in the “no” camp, so I’ll address it.<br></p><p>Accepting this proposal won’t turn bad API designers into good ones. Crappy APIs are still going to be crappy with or without this. In the immortal quote apparently due to Lawrence Flon: “There is not now, nor has there ever been, nor will there ever be, any programming language in which it is the least bit difficult to write bad code.”<br></p><p>The justification for this proposal is all about supporting the people who are working to design library APIs right, and about maintaining consistency with the design philosophy of Swift. To wit: in Swift, where there’s a default choice, it’s the safe one; where there’s a consequential design decision, it’s explicit.<br></p><p>Rod Brown hit the crux of it: sealed → open is safe for existing API clients, but open → sealed is a breaking change. “Sealed” is thus the safer choice, and “open” is a consequential design decision. Given the general precedent and philosophy of Swift, competent API designers might reasonably be taken aback that open is the default. In fact, given the habit Swift encourages of leaning on compiler verification, this is a potential source of designer error.<br></p><p>• • •<br></p><p>For those who think that discouraging inheritance by default is something recent, or a fad, or a quirk of Swift: Josh Bloch spent over 5 pages of Effective Java arguing against “subclassable just in case.” That was in 2001, and it was old news even back then.<br></p><p>Those looking for a more detailed analysis of the problems caused by APIs allowing inheritance without designing for it should read his analysis. It’s 15 years old, it’s Java, but it still stands. (He even gives instructions toward the end for simulating something very much like the here-proposed “sealed” in Java using package-private initializers.) It’s item 15 in the book, “Design and document for inheritance or else prohibit it.”<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 9:53 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 10, 2016, at 8:49 PM, let var go via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2. The motivation seems to be that it will force better API design.<br>&gt; <br>&gt; No, that wasn’t my motivation in giving it a +1. This seems to be a common misunderstanding in the “no” camp, so I’ll address it.<br>&gt; <br>&gt; Accepting this proposal won’t turn bad API designers into good ones. Crappy APIs are still going to be crappy with or without this. In the immortal quote apparently due to Lawrence Flon: “There is not now, nor has there ever been, nor will there ever be, any programming language in which it is the least bit difficult to write bad code.”<br>&gt; <br>&gt; The justification for this proposal is all about supporting the people who are working to design library APIs right, and about maintaining consistency with the design philosophy of Swift. To wit: in Swift, where there’s a default choice, it’s the safe one; where there’s a consequential design decision, it’s explicit.<br></p><p>+1.  This is exactly why sealed is the default that fits best with the rest of the defaults in Swift.  They are permissive within a module and require explicit choices where external contracts are involved.<br></p><p>&gt; <br>&gt; Rod Brown hit the crux of it: sealed → open is safe for existing API clients, but open → sealed is a breaking change. “Sealed” is thus the safer choice, and “open” is a consequential design decision. Given the general precedent and philosophy of Swift, competent API designers might reasonably be taken aback that open is the default. In fact, given the habit Swift encourages of leaning on compiler verification, this is a potential source of designer error.<br>&gt; <br>&gt; • • •<br>&gt; <br>&gt; For those who think that discouraging inheritance by default is something recent, or a fad, or a quirk of Swift: Josh Bloch spent over 5 pages of Effective Java arguing against “subclassable just in case.” That was in 2001, and it was old news even back then.<br>&gt; <br>&gt; Those looking for a more detailed analysis of the problems caused by APIs allowing inheritance without designing for it should read his analysis. It’s 15 years old, it’s Java, but it still stands. (He even gives instructions toward the end for simulating something very much like the here-proposed “sealed” in Java using package-private initializers.) It’s item 15 in the book, “Design and document for inheritance or else prohibit it.”<br></p><p>Agree.  The best practice has been around for some time, although it sounds like it is not yet widespread as it could be (especially in-depth knowledge of the rationale behind it).  <br></p><p>What is relatively new is the opportunity to embrace it in the design of a (sure to be) popular and widely used language that carries most of the traditional OO facilities.  This is a great opportunity IMO.<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 11, 2016, at 5:00 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 10, 2016, at 9:53 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 10, 2016, at 8:49 PM, let var go via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The motivation seems to be that it will force better API design.<br>&gt;&gt; <br>&gt;&gt; No, that wasn’t my motivation in giving it a +1. This seems to be a common misunderstanding in the “no” camp, so I’ll address it.<br>&gt;&gt; <br>&gt;&gt; Accepting this proposal won’t turn bad API designers into good ones. Crappy APIs are still going to be crappy with or without this. In the immortal quote apparently due to Lawrence Flon: “There is not now, nor has there ever been, nor will there ever be, any programming language in which it is the least bit difficult to write bad code.”<br>&gt;&gt; <br>&gt;&gt; The justification for this proposal is all about supporting the people who are working to design library APIs right, and about maintaining consistency with the design philosophy of Swift. To wit: in Swift, where there’s a default choice, it’s the safe one; where there’s a consequential design decision, it’s explicit.<br>&gt; <br>&gt; +1.  This is exactly why sealed is the default that fits best with the rest of the defaults in Swift.  They are permissive within a module and require explicit choices where external contracts are involved.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Rod Brown hit the crux of it: sealed → open is safe for existing API clients, but open → sealed is a breaking change. “Sealed” is thus the safer choice, and “open” is a consequential design decision. Given the general precedent and philosophy of Swift, competent API designers might reasonably be taken aback that open is the default. In fact, given the habit Swift encourages of leaning on compiler verification, this is a potential source of designer error.<br>&gt;&gt; <br>&gt;&gt; • • •<br>&gt;&gt; <br>&gt;&gt; For those who think that discouraging inheritance by default is something recent, or a fad, or a quirk of Swift: Josh Bloch spent over 5 pages of Effective Java arguing against “subclassable just in case.” That was in 2001, and it was old news even back then.<br>&gt;&gt; <br>&gt;&gt; Those looking for a more detailed analysis of the problems caused by APIs allowing inheritance without designing for it should read his analysis. It’s 15 years old, it’s Java, but it still stands. (He even gives instructions toward the end for simulating something very much like the here-proposed “sealed” in Java using package-private initializers.) It’s item 15 in the book, “Design and document for inheritance or else prohibit it.”<br>&gt; <br>&gt; Agree.  The best practice has been around for some time, although it sounds like it is not yet widespread as it could be (especially in-depth knowledge of the rationale behind it).  <br>&gt; <br>&gt; What is relatively new is the opportunity to embrace it in the design of a (sure to be) popular and widely used language that carries most of the traditional OO facilities.  This is a great opportunity IMO.<br></p><p>I find surprising to that one would sign up for what basically amounts to &#39;compiler take my freedom away as I do not feel I can bare the responsibility it places on me&#39;. To me, Joshua Bloch&#39;s message was never as an appeal to the javac teams to suppress freedom, but to developers to become cognizant of its consequences and strive to write better code. But it seems to be a human trait throughout history to want to relinquish our individual freedom for the comfort of someone else being responsible.<br></p><p>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 11, 2016 at 03:00:00am</p></header><div class="content"><p>Well stated and has pushed me into favoring the closed be default case. I<br>favor being explicit and the default being safe (you can always unseal in a<br>future revision if a need arises).<br></p><p>Also as you note it won&#39;t prevent bad implementations but it will help<br>library developers better bound their external surface and contract...which<br>if leveraged well will help with robustness, testability, and flexibility<br>in future revisions.<br></p><p>-Shawn<br></p><p>On Sun, Jul 10, 2016 at 10:53 PM Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 10, 2016, at 8:49 PM, let var go via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; 2. The motivation seems to be that it will force better API design.<br>&gt;<br>&gt; No, that wasn’t my motivation in giving it a +1. This seems to be a common<br>&gt; misunderstanding in the “no” camp, so I’ll address it.<br>&gt;<br>&gt; Accepting this proposal won’t turn bad API designers into good ones.<br>&gt; Crappy APIs are still going to be crappy with or without this. In the<br>&gt; immortal quote apparently due to Lawrence Flon: “There is not now, nor has<br>&gt; there ever been, nor will there ever be, any programming language in which<br>&gt; it is the least bit difficult to write bad code.”<br>&gt;<br>&gt; The justification for this proposal is all about supporting the people who<br>&gt; are working to design library APIs right, and about maintaining consistency<br>&gt; with the design philosophy of Swift. To wit: in Swift, where there’s a<br>&gt; default choice, it’s the safe one; where there’s a consequential design<br>&gt; decision, it’s explicit.<br>&gt;<br>&gt; Rod Brown hit the crux of it: sealed → open is safe for existing API<br>&gt; clients, but open → sealed is a breaking change. “Sealed” is thus the safer<br>&gt; choice, and “open” is a consequential design decision. Given the general<br>&gt; precedent and philosophy of Swift, competent API designers might reasonably<br>&gt; be taken aback that open is the default. In fact, given the habit Swift<br>&gt; encourages of leaning on compiler verification, this is a potential source<br>&gt; of designer error.<br>&gt;<br>&gt; • • •<br>&gt;<br>&gt; For those who think that discouraging inheritance by default is something<br>&gt; recent, or a fad, or a quirk of Swift: Josh Bloch spent over 5 pages of<br>&gt; Effective Java arguing against “subclassable just in case.” That was in<br>&gt; 2001, and it was old news even back then.<br>&gt;<br>&gt; Those looking for a more detailed analysis of the problems caused by APIs<br>&gt; allowing inheritance without designing for it should read his analysis.<br>&gt; It’s 15 years old, it’s Java, but it still stands. (He even gives<br>&gt; instructions toward the end for simulating something very much like the<br>&gt; here-proposed “sealed” in Java using package-private initializers.) It’s<br>&gt; item 15 in the book, “Design and document for inheritance or else prohibit<br>&gt; it.”<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/19848426/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; The justification for this proposal is all about supporting the people who are working to design library APIs right, and about maintaining consistency with the design philosophy of Swift. To wit: in Swift, where there’s a default choice, it’s the safe one;<br>I challenge this claim:<br>Safety is valued, but Swift cares (and should care!) about pragmatism as well… the most obvious example that comes to my mind are arrays, which have no safeguards that stop you from accessing elements that aren&#39;t there.<br></p><p>&gt; where there’s a consequential design decision, it’s explicit.<br>When there is no explicit statement about subclassiblily, it&#39;s reasonable to assume that there hasn&#39;t been a consequential design decision… but sadly, discussion like this mainly driven by dogmatism, because there is no evidence for either side.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 11 Jul 2016, at 09:42, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The justification for this proposal is all about supporting the people who are working to design library APIs right, and about maintaining consistency with the design philosophy of Swift. To wit: in Swift, where there’s a default choice, it’s the safe one;<br>&gt; I challenge this claim:<br>&gt; Safety is valued, but Swift cares (and should care!) about pragmatism as well… the most obvious example that comes to my mind are arrays, which have no safeguards that stop you from accessing elements that aren&#39;t there.<br>&gt; <br>&gt;&gt; where there’s a consequential design decision, it’s explicit.<br>&gt; When there is no explicit statement about subclassiblily, it&#39;s reasonable to assume that there hasn&#39;t been a consequential design decision… but sadly, discussion like this mainly driven by dogmatism,<br></p><p>Hence why it is important to recognise this, whether it is us doing it or others, and nip it in the bud. I do not want orthodoxy wars with people yelling at each other about who is the truest Swiftiest supporter of the one true Swift dogma :P.<br></p><p>&gt; because there is no evidence for either side.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Hence why it is important to recognise this, whether it is us doing it or others, and nip it in the bud. I do not want orthodoxy wars<br>there has been war for a long time — but it&#39;s fought with weapons that are hard to recognize ;-) (no, actually :-(<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 11 Jul 2016, at 03:49, let var go via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Leonardo&#39;s example makes the case for why Swift should adopt a &#39;sealed&#39; keyword that can be used to make public classes non-subclassable outside the module where they are defined, but not for why this should be the default.<br>&gt; <br>&gt; Others have made these points before, but these are the two biggest reasons I can see against making public classes non-subclassable by default:<br>&gt; <br>&gt; 1. It is the opposite of nearly every other OOP language&#39;s behavior and the opposite of what anyone will expect who is coming to Swift after doing any OOP programming anywhere else. While I believe that Swift should be free to buck the trends of other languages where there are significant advantages, changing something this fundamental will introduce a new learning curve for even experienced programmers. The advantages better be significant, otherwise you are introducing a frustrating quirk into the language without any great benefit in exchange. But the advantages of default non-subclassability are marginal at best. Whatever advantage there is can be achieved by making it opt-in using a &#39;sealed&#39; keywrod, instead of by making it the default.<br></p><p>As stated previously in this thread, modern languages like Kotlin do have this behaviour and base themselves on what is recommended good design in Java. So we this behaviour is not necessarily new or orthogonal to nearly every other OOP language. Secondly, I don’t agree that the advantage of default non-subclassability is marginal at best. It will have very real repercussions on the robustness and documentation of third-party libraries.<br></p><p>&gt; 2. The motivation seems to be that it will force better API design. On average, I can&#39;t believe that it will. Assume that there are two kinds of developers: Those that make careful decisions about their API design and those that don&#39;t. The ones that make careful decisions about their API design will continue to do so - I don&#39;t see any significant improvement to their code by making non-subclassability the default.<br></p><p>The improvement is that extension points will be clearly and explicitly marked, instead of having to rely only on documentation (which can be lacking, even from developers that make careful decisions about their API design).<br></p><p>&gt; The developers who don&#39;t make careful design decisions will just go with the default - in this case they will just leave the default in place, and their public classes will not be subclassable. That doesn&#39;t improve anything, it just makes sloppy, poorly written code harder to fix in the off-chance that you are stuck working with it. In other words, quality will not improve, but productivity will suffer, because it will be harder to develop workarounds for the problems that will inevitably appear in even the best-designed APIs.<br></p><p>Here, I also disagree. Imagine we are talking about an open-source library on GitHub. People will complain about the lack of sub-classability through issues and pull-requests. This will hopefully be enough to get discussions going on what is wrong with the API to warrant subclassing and exactly what the subclassing extension points should be. This discussion will happen around many libraries and will help educate people to think carefully about subclassing.<br></p><p>&gt; 3. It is a bad interpretation of the stated goal that Swift should help developers produce &quot;safe code.&quot; Some folks seem to believe that this means that the language should protect people from themselves. If I am using your API in my code and I screw it up by subclassing something that I shouldn&#39;t have, that is somehow a language defect. It is not a language defect - it is me being an idiot.<br></p><p>This argument could very well be transposed to defend C&#39;s memory-management and does not stand for me. A language should always strive to protect developers from their own mistakes. If that was not the case, languages would never have introduced garbage collection, ARC, optionals, etc...<br></p><p>&gt; Don&#39;t spend a lot of time trying to make a language idiot-proof - idiots are geniuses and you will never outsmart them. Personally, when I read that Swift helps produce &quot;safe code&quot;, what that means primarily is that it has a type system that helps reveal the vast majority of bugs that would otherwise go unnoticed until runtime. In other words, safety is related to discovering hidden flaws in the program. (Type safety isn&#39;t the only feature that helps with this, but it is perhaps the main one.) But this whole issue of default non-subclassability doesn&#39;t fall into that category of &quot;safety&quot; at all. It doesn&#39;t help a programmer produce safer code. The same hidden flaws will persist whether non-subclassability is the default or not. The difference is that those same hidden flaws will be more difficult to deal with after the fact.<br></p><p>How can it not help programmers produce safer code? By not subclassing a brittle class, it does protect them from internal modifications in that superclass.<br></p><p>&gt; To sum it up, +1 for introducing a &#39;sealed&#39; keyword, but -1 for making it the default behavior for public classes.<br>&gt; <br>&gt; On Sun, Jul 10, 2016 at 12:18 PM Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br>&gt; <br>&gt; I&#39;m currently working on an app which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br>&gt; <br>&gt; There may be several more examples but this is one I&#39;m facing right now, so I can assure you it is a true example. IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br>&gt; <br>&gt; Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br>&gt; <br>&gt; About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br>&gt; <br>&gt; Swift doesn&#39;t have to follow on the footsteps of any language but what is best for the intention the language was created for. If sealed by default goes in that direction, then we should have it not looking back. The same goes if we decide this is not taking the language in its intended direction. If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br>&gt; <br>&gt; L<br>&gt; From: Tino Heth via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎10/‎07/‎2016 01:55 PM<br>&gt; To: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Cc: Jean-Daniel Dupas &lt;mailto:mailing at xenonium.com&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0117: Default classes to benon-subclassable publicly<br>&gt; <br>&gt; Two days ago, I challenged the supporters of this proposal to show a singe persuasive example to illustrate that this proposal could actually improve something.<br>&gt; I got a single reply — which did not contain an example, but just the claim that there is one…<br>&gt; Imho that alone should be enough to cancel the whole thing, because even if there are cases which cannot be repelled with the simple advice &quot;just don&#39;t subclass&quot;, this would only be a basis to start talking about the actual pros and cons.<br>&gt; <br>&gt; So for me, the promised benefits are less likely than the existence of Bigfoot:<br>&gt; I guess there are at least several hundred people who swore they have seen him, and there are even some blurry photos ;-)<br>&gt; <br>&gt; Of course, it is impossible to come up with an unquestionable argument for the change — and it&#39;s also impossible to prove the opposite, because the whole debate makes as much sense as arguing wether raisins are tasteful or terrible; it&#39;s nothing but personal preference, and the only thing we can hope for is that the bias of those who will decide this proposal isn&#39;t at odds with the needs of the majority.<br>&gt; <br>&gt; If we can agree that it is not about facts, but about opinion, there are still fundamental arguments against SE-0117:<br>&gt; Those who have issues with subclassing can just resign from it (as users of a library), and they can annotate their classes to dictate their usage (as an author) — but if you think subclassing is still a good tool, you can&#39;t do anything with a sealed class.<br>&gt; Additionally, please note that those who ask for stricter rules and more regulation have many reasons to be happy with the status quo:<br>&gt; You can subclass neither structs nor enums, and by default, you can&#39;t inherit from a framework-class as well, because it is internal — and yet they yell for more.<br>&gt; <br>&gt; Swift claims to be opinionated, not to aim for compromise — but if plain old OO isn&#39;t compatible with the ideals of the language, it would be more honest to just completely remove inheritance instead of slowly crippling it&#39;s possibilities.<br>&gt; <br>&gt; - Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/30003d55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Here, I also disagree. Imagine we are talking about an open-source library on GitHub. People will complain about the lack of sub-classability through issues and pull-requests. This will hopefully be enough to get discussions going on what is wrong with the API to warrant subclassing and exactly what the subclassing extension points should be. This discussion will happen around many libraries and will help educate people to think carefully about subclassing.<br>That&#39;s one of the false assumptions:<br>Many people don&#39;t want be lectured, but simply get their work done… as it has been said before, this list is a quite exotic bubble, and it can be fatal to assume that it is representative for the mass of developers that have to deal with the consequences of its discussions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/b33bcc06/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 11, 2016 at 08:00:00am</p></header><div class="content"><p>Interesting example but it only explain that a sealed keyword is needed (which I agree), and not why sealed should be the default (which I disagree).<br></p><p>&gt; Le 10 juil. 2016 à 21:18, Leonardo Pessoa &lt;me at lmpessoa.com&gt; a écrit :<br>&gt; <br>&gt; Should I assume then you want so much this proposal to be dropped you didn&#39;t even mind to look for the example so you wouldn&#39;t have to admit this proposal is needed? Fine, here is the whole of that example.<br>&gt; <br>&gt; I&#39;m currently working on an app which will have object representations of Files and Folders (both come from a common class called Entry). You as a developer for this system will be entitled to extend from File and Entry freely but you can only work with Folders and its subclasses (specialised folders) but to this system it is important you don&#39;t subclass any type of folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br>&gt; <br>&gt; There may be several more examples but this is one I&#39;m facing right now, so I can assure you it is a true example. IMO libraries are to be written with intention in mind and I don&#39;t think it is right to use a library written to compose a PDF file to send an email (even if you&#39;re sending the PDF file attached, the right way to do it is by composition not subclassing).<br>&gt; <br>&gt; Additionally, someone mentioned and I went in to check about a recommendation for Java to intentionally document and enable classes to be subclasses explicitly otherwise forbid it at all and that recommendation seems to come from Oracle itself. I believe Oracle would do it to Java if it had great interest in it without consulting anyone&#39;s opinion.<br>&gt; <br>&gt; About the addition to the proposal to enable force unsealing, I&#39;m completely opposed as it is just like not having any of this protection at all (why putting a lock on the door to your house if the key is under the mat?)<br>&gt; <br>&gt; Swift doesn&#39;t have to follow on the footsteps of any language but what is best for the intention the language was created for. If sealed by default goes in that direction, then we should have it not looking back. The same goes if we decide this is not taking the language in its intended direction. If I&#39;m not wrong at least one member of the core team already mentioned in this thread this is completely aligned with the intention of the language, so I think we should give it a go and stop trying to have/keep control of everything we touch.<br>&gt; <br>&gt; L<br>&gt; From: Tino Heth via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎10/‎07/‎2016 01:55 PM<br>&gt; To: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Cc: Jean-Daniel Dupas &lt;mailto:mailing at xenonium.com&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0117: Default classes to benon-subclassable publicly<br>&gt; <br>&gt; Two days ago, I challenged the supporters of this proposal to show a singe persuasive example to illustrate that this proposal could actually improve something.<br>&gt; I got a single reply — which did not contain an example, but just the claim that there is one…<br>&gt; Imho that alone should be enough to cancel the whole thing, because even if there are cases which cannot be repelled with the simple advice &quot;just don&#39;t subclass&quot;, this would only be a basis to start talking about the actual pros and cons.<br>&gt; <br>&gt; So for me, the promised benefits are less likely than the existence of Bigfoot:<br>&gt; I guess there are at least several hundred people who swore they have seen him, and there are even some blurry photos ;-)<br>&gt; <br>&gt; Of course, it is impossible to come up with an unquestionable argument for the change — and it&#39;s also impossible to prove the opposite, because the whole debate makes as much sense as arguing wether raisins are tasteful or terrible; it&#39;s nothing but personal preference, and the only thing we can hope for is that the bias of those who will decide this proposal isn&#39;t at odds with the needs of the majority.<br>&gt; <br>&gt; If we can agree that it is not about facts, but about opinion, there are still fundamental arguments against SE-0117:<br>&gt; Those who have issues with subclassing can just resign from it (as users of a library), and they can annotate their classes to dictate their usage (as an author) — but if you think subclassing is still a good tool, you can&#39;t do anything with a sealed class.<br>&gt; Additionally, please note that those who ask for stricter rules and more regulation have many reasons to be happy with the status quo:<br>&gt; You can subclass neither structs nor enums, and by default, you can&#39;t inherit from a framework-class as well, because it is internal — and yet they yell for more.<br>&gt; <br>&gt; Swift claims to be opinionated, not to aim for compromise — but if plain old OO isn&#39;t compatible with the ideals of the language, it would be more honest to just completely remove inheritance instead of slowly crippling it&#39;s possibilities.<br>&gt; <br>&gt; - Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/53b60d34/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Tino Heth wrote: ...I challenged [supporters] to show a singe persuasive example to illustrate that this proposal could actually improve something...even if there are cases which cannot be repelled with the simple advice &quot;just don&#39;t subclass&quot;, this would only be a basis to start talking about the actual pros and cons.<br></p><p>&gt; Leonardo Pessoa responded: ...an app which will have object representations of Files and Folders (both come from a common class called Entry). You [can] extend from File and Entry freely but...it is important you don&#39;t subclass any type of Folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br></p><p><br>To me, this scenario seems like an example of why the proposal should be rejected.<br></p><p>Correct me if I’m wrong, but your (Leonardo’s) narrative suggests that the subclassability of File and Entry is incidental. If the intent was actively to allow people to provide their own implementations of filesystem objects, you would presumably have taken whatever steps were necessary to make Folder subclassable as well.<br></p><p>This scenario ends up defining a perfectly commonplace mix of classes. Some of them behave reasonably when subclassed and some don’t. The question is, should Swift — as a matter of default policy and community style — actively push you to seal ALL of these classes?<br></p><p>No, it shouldn’t. You’d be removing the possibility of functionality that’s potentially useful to some clients, without gaining much in return.<br></p><p>A “sealed” keyword or equivalent seems plausible, but it shouldn’t be the default. <br></p><p>Even an affirmative “sealed&quot; feels prone to abuse, however. In this case, for example, I would imagine there would be considerable temptation to mark all objects (Entry, File, Folder, etc.) as sealed, just because Folder needs it. API designers (and clients!) dislike unexplained asymmetry.<br></p><p>Garth<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/d7e1e9f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 10, 2016 at 07:00:00pm</p></header><div class="content"><p>You asked me to correct you and I shall: you&#39;re wrong. Although it seems like a filesystem representation here, this is not it and the subclassability of Entry and File is intended but Folder is a special type and I cannot allow more than the base type and a few controlled subclasses due to the nature of the system. It was intended to be exactly like this and there was nothing incidental about them. IMO a well designed library is like an app with plugins: you&#39;re not entitled to do whatever you want in the app through a plugin but the app controls and dictates what it allows you to do.<br></p><p>You asked for an example where this feature would be needed and I&#39;ve provided. As I said, a concrete and real example. But I haven&#39;t seen anyone give the slightest concrete technical reason not to approve it and please don&#39;t come saying fix bugs in a library by subclassing because that&#39;s not what subclassing is for. That is a misuse of object orientation in whichever language you&#39;re working with.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Garth Snyder via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎10/‎07/‎2016 05:47 PM<br>To: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Review] SE-0117: Default classes to benon-subclassable publicly<br></p><p>Tino Heth wrote: ...I challenged [supporters] to show a singe persuasive example to illustrate that this proposal could actually improve something...even if there are cases which cannot be repelled with the simple advice &quot;just don&#39;t subclass&quot;, this would only be a basis to start talking about the actual pros and cons.<br></p><p><br>Leonardo Pessoa responded: ...an app which will have object representations of Files and Folders (both come from a common class called Entry). You [can] extend from File and Entry freely but...it is important you don&#39;t subclass any type of Folder. Without this proposal I would have to create workarounds to prevent you from doing that while still allowing me to subclass while playing a lot of finals everywhere. And so far I would have to allow you to subclass Folder itself (at least) but you would complain (and possibly file a bug report to me) because it would not be working properly because your classes would not benefit from the workaround. In this case, if I could subclass internally but prevent you from doing it, you could complain I&#39;m not allowing you to do whatever you want but you wouldn&#39;t complain my code doesn&#39;t work properly (it does, you just won&#39;t know it).<br></p><p><br></p><p>To me, this scenario seems like an example of why the proposal should be rejected.<br></p><p><br>Correct me if I’m wrong, but your (Leonardo’s) narrative suggests that the subclassability of File and Entry is incidental. If the intent was actively to allow people to provide their own implementations of filesystem objects, you would presumably have taken whatever steps were necessary to make Folder subclassable as well.<br></p><p><br>This scenario ends up defining a perfectly commonplace mix of classes. Some of them behave reasonably when subclassed and some don’t. The question is, should Swift — as a matter of default policy and community style — actively push you to seal ALL of these classes?<br></p><p><br>No, it shouldn’t. You’d be removing the possibility of functionality that’s potentially useful to some clients, without gaining much in return.<br></p><p><br>A “sealed” keyword or equivalent seems plausible, but it shouldn’t be the default. <br></p><p><br>Even an affirmative “sealed&quot; feels prone to abuse, however. In this case, for example, I would imagine there would be considerable temptation to mark all objects (Entry, File, Folder, etc.) as sealed, just because Folder needs it. API designers (and clients!) dislike unexplained asymmetry.<br></p><p><br>Garth<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/64ac1cb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; You asked me to correct you and I shall:<br>Well, in the first place, I asked how many subclasses you have to &quot;seal&quot; manually… may I assume that it is a low number?<br></p><p>&gt; You asked for an example where this feature would be needed and I&#39;ve provided.<br>No, actually you provided an example where you think the feature would be needed… but wait:<br>How could you write it then? Do I have a wrong interpretation of &quot;needed&quot;, or did you write this thing in an apocalyptic future? ;-)<br></p><p>&gt; As I said, a concrete and real example. But I haven&#39;t seen anyone give the slightest concrete technical reason not to approve it and please don&#39;t come saying fix bugs in a library by subclassing because that&#39;s not what subclassing is for. That is a misuse of object orientation in whichever language you&#39;re working with.<br>At least there are many real (at least I think so) examples of problems that could be solved because sealed isn&#39;t the default now…<br>But as I said in another message:<br>All of this is not about technical reasons, but only about personal preference — and my preference is to have fun writing software, instead of struggling with bureaucracy.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/f65b8c57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review] SE-0117: Default classes to benon-subclassable publicly</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 11, 2016 at 12:00:00am</p></header><div class="content"><p>I think folks are going in an unprofessional direction in this thread, let<br>bring it back to a more positive direction please.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/fc93b0b9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>July  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Personally I think a great compromise is just forcing the user to use the<br>`override` keyword when subclassing in these cases. That way the library<br>maker can mark classes that aren&#39;t supported or are internal and ideally<br>shouldn&#39;t be used by the programmer.<br></p><p>However we shouldn&#39;t baby sit programmers, we are smart people after all.<br>So if there is a huge catastrophic bug that just happens to be easily<br>solvable by subclassing or whatever then we should allow them to do so.<br></p><p>An `override` keyword would be a great compromise, take this class:<br></p><p>public class NonSubclassableParentClass {<br></p><p>}<br></p><p><br>If the programmer subclasses it normally, the compiler will throw an error<br>telling them to use the `override` keyword to subclass non-subclassble<br>classes:<br></p><p>override class  MySubclass: NonSubclassableParentClass {<br></p><p>}<br></p><p><br>Now there is a clear indicator that we are doing something not safe or<br>ideal here. This is similar how the &quot;!&quot; in IUO indicates we have a unsafe<br>value. We are grown-ups we should be able to know when to subclass but this<br>doesn&#39;t mean there couldn&#39;t be something like this to indicate to the user<br>that they may want to revaluate this in the future.<br></p><p>So in the future other programmers can see this marker and think &quot;Oh we are<br>using this class in a non recommended way, so when it breaks when I upgrade<br>the library it&#39;s our fault.&quot; hopefully making them continue to upgrade<br>rather than not upgrading because it breaks &quot;my subclass&quot;.<br></p><p>Whats great about this feature is it also allows linters or the compiler to<br>also show warnings when this is used as well, that way those of us that are<br>bugged by the amount of warnings we have in our app can endevour to fix it.<br></p><p>In Ruby there is a convention to have these sort of monkey patches and<br>subclasses to fix bugs in a special folder with &quot;_ext&quot; after it to indicate<br>that this an extension to a class from a library, this indicates to the<br>programmer that it&#39;s something we should ideally remove as soon as the app<br>can work without that hack.<br></p><p>So I can&#39;t see why we can&#39;t have this `override` keyword to tell the<br>library developer that we like to live life on the edge a litte ;)<br></p><p><br>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 8 July 2016 at 22:14, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; When was the last time you you thought &quot;I really wish the author of that<br>&gt; library had restricted my options to use it&quot;?<br>&gt;<br>&gt;<br>&gt; I really wish Objective-C had this feature from the start.  I believe<br>&gt; there would have been significant benefits to Apple&#39;s platforms and<br>&gt; ecosystem.  The reasons for believing (or not believing) this have been<br>&gt; discussed in depth so there isn&#39;t a need to rehash them now.<br>&gt;<br>&gt; I&#39;m not asking for reasons but for a single persuasive example…<br>&gt;<br>&gt; It is easy to claim that everything will be better if we add restrictions,<br>&gt; but so far, I haven&#39;t heard of any real problems cause by the current<br>&gt; defaults:<br>&gt; The motivation to change them is not because of actual experience, it&#39;s<br>&gt; just the trendy opinion that inheritance is evil.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/7f0a8cdb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Strong -1 from me.<br></p><p>I think most of my thoughts on this have already been well covered by others. I’ll just note that this proposal reminds me of the fortune file entry, “Whenever you see a sign that says ‘no exit’, it means there is an exit there.”<br></p><p>Specifically, under this proposal, whenever you see a nonsubclassable, non-final class (which I suppose would in fact be any class not explicitly marked as subclassable), it would mean that the library implementor IS in fact subclassing it. Otherwise, it would just be final. Therefore, it’s by definition a perfectly reasonable class to specialize. The implementor just doesn’t want YOU doing it.<br></p><p>Maybe the implementor has a very good reason for this. But in the modal case, probably not. As the ladies on Jerry Springer say: you don’t know me; you don’t know my life. You really have no idea how I’ll be using your API or what I’ll be trying to achieve. In most cases, I&#39;ll have both your library source code and intimate knowledge of the application domain, so I’m probably in a better position than you to make these types of architectural assessments. You’re working with nothing but speculation, or even worse, your own myopic perspective of what your library is and how it ought be used. You think you know all about it because it’s Your Damn Library, but so very often, that conception turns out not to be not entirely accurate.<br></p><p>There’s a strong argument for allowing classes to be final, namely, static binding and performance. There’s a strong argument for allowing API to be nonpublic, namely, the ability to be clear about what’s included in the API and what’s not.<br></p><p>Beyond that, I really see no value in being able to schoolmarmishly forbid subclassing and overriding just out of conservatism, regardless of the syntax for this feature or the default behavior. If you want this, go write Ada code.<br></p><p>There should absolutely be a way to say “don’t subclass this.” But do you really need anything more than a comment that says “don’t subclass this?” Perhaps as a compromise, and as a concession to the value of automated checking, this feature could be reformulated as a warning system. A class marked as nonsubclassable could be extended only be including a corresponding acknowledgment keyword in the extending class, a kind of Swift version of -IHaveBeenWarnedThatAPFSIsPreReleaseAndThatIMayLoseData.<br></p><p>Either way, I would be sad to see nonextentability become the default behavior of Swift. That just doesn’t seem like it’s in anyone’s best interest.<br></p><p>Garth<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 12:30 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Defaults matter, because they transmit a message:<br>&gt; Every rule and obstacle we add to Swift is a statement that says &quot;we favor bureaucracy over freedom&quot;, and this will affect the community evolving around the language.<br></p><p>…or “we favor mindfulness over carelessness,” or “we favor static type safety over runtime bug discovery.”<br></p><p>There are many ways of recoloring that thought.<br></p><p>&gt; Everyone should ask himself a simple question:<br>&gt; When was the last time you you thought &quot;I really wish the author of that library had restricted my options to use it&quot;?<br></p><p>The correct question is:<br></p><p>When was the last time you thought, “I really wish the author of that library had thought carefully about where and how they expected people to extend it?”<br></p><p>I spend a lot of time in the Ruby world as well, where there is no static type safety at all, and the entire type structure of your program and all of its libraries is open for rewiring the whole time the program is running. And you know what? It works just fine in practice! I’d say it favors rapid prototyping at the expense of subtle bugs staying hidden longer than they otherwise might. That’s a tradeoff that’s worth it for many projects. Pros and cons aside, though, people build good software this way. Ruby’s “nothing is sealed, everything is Play-Doh” approach really does work in practice.<br></p><p>The interesting question is not _whether_ this works, but _why_ it works. Ruby coders know not to expect any correctness help from the compiler, and know what kinds of testing they need to do to verify that correctness by other means. They build systems with the expectation of unit correctness being no guarantee of integrated system correctness. An entire ecosystem of culture, habit, and expectations supports the language’s looseness.<br></p><p>Swift already — today, right now, even without this proposal — sets very different expectations. Developers _do_ expect certain kinds of help from the compiler. In particular, they expect that consequential design decisions are explicitly declared, and that where is is a default, it is the one that favors static verification. Subclassibility is a consequential design decision, and it is one that precludes certain kinds of static verification (because how overriding methods can break encapsulation). Making it the default thus contradicts the developer expectations that the language has already established.<br></p><p>The question is not whether sealed or open is the One True Way. The question is which fits into Swift’s particular ecosystem of culture, habit, and expectations.<br></p><p>This is engineering, folks. No gospel truths here; it’s all tradeoffs. Open by default can be the right tradeoff for one language, and the wrong one for another.<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 7 juil. 2016 à 18:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt; not care for you to design and develop a great library because s/he is<br>&gt; not caring for the library at all. I right now have to go through the<br>&gt; burdensome activity of marking too many classes/methods as final to<br>&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt; <br>&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt; yours of the user of poorly designed/developed libraries.<br></p><p>If you consider Cocoa and other Apple frameworks as poorly design, then I guess you’re right…<br></p><p>Nonetheless, being able to subclass any class allowed me to solve a bunch of very bad memory leaks in the new NSCollectionView implementation, and made it usable for my project.<br></p><p>Thinking than you will have to work only with perfectly design libraries without any bug is utopian.<br>And thinking you can predict every usages of your library by users is short sighted IMHO.<br></p><p>&gt; By pushing<br>&gt; this proposal, developer of such libraries will have much burden to<br>&gt; make/keep a poor library or will have to work on better<br>&gt; design/implementation for it to suit its purpose.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; Strong -1 too.<br>&gt;&gt; <br>&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt; arbitrary classes and methods.<br>&gt;&gt; <br>&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt; perfectly supported anyway.<br>&gt;&gt; <br>&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt; classes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; A **strong** -1<br>&gt;&gt; <br>&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt; retroactive modeling.<br>&gt;&gt; <br>&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt; boilerplate.<br>&gt;&gt; <br>&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt; <br>&gt;&gt; As Tino said:<br>&gt;&gt; <br>&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt; <br>&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt; will see several types of annotations:<br>&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt; 3) This method MUST be called<br>&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt; super<br>&gt;&gt; 5) This method MUST call super<br>&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt; <br>&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt; <br>&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt; this problem in the real world.<br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt; (e.g. friend classes).<br>&gt;&gt; <br>&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt; frameworks for years.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt; manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how<br>&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  8, 2016 at 12:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 7, 2016, at 6:23 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt; not care for you to design and develop a great library because s/he is<br>&gt; not caring for the library at all.<br></p><p>That is a grotesque depiction.<br></p><p>&gt; I right now have to go through the<br>&gt; burdensome activity of marking too many classes/methods as final to<br>&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt; need to subclass internally what I don&#39;t want you to subclass.<br></p><p>If one does not have the patience to review one&#39;s own work to increase its quality, and would instead prefer to hand off the responsibility of finishing writing it to the compiler (i.e. making the compiler lock things down to avoid having to type &quot;final&quot;), perhaps a happier solution for everyone might be easier to keep this work private? <br>I noticed in recent years that the quality of some open source code has gone down, seemingly under the social pressure of having to be &quot;one of the kool-ones&quot; with code hanging in the breeze on github. Personally I don&#39;t mind if less code makes its way to github because it is more difficult to finish it properly.<br></p><p><br>&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt; this proposal, developer of such libraries will have much burden to<br>&gt; make/keep a poor library or will have to work on better<br>&gt; design/implementation for it to suit its purpose.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; Strong -1 too.<br>&gt;&gt; <br>&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt; arbitrary classes and methods.<br>&gt;&gt; <br>&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt; perfectly supported anyway.<br>&gt;&gt; <br>&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt; classes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; A **strong** -1<br>&gt;&gt; <br>&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt; retroactive modeling.<br>&gt;&gt; <br>&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt; boilerplate.<br>&gt;&gt; <br>&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt; <br>&gt;&gt; As Tino said:<br>&gt;&gt; <br>&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt; <br>&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt; will see several types of annotations:<br>&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt; 3) This method MUST be called<br>&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt; super<br>&gt;&gt; 5) This method MUST call super<br>&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt; <br>&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt; <br>&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt; this problem in the real world.<br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt; (e.g. friend classes).<br>&gt;&gt; <br>&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt; frameworks for years.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt; manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt; <br>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
