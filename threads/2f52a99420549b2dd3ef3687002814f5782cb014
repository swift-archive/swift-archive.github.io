<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add StaticString.UnicodeScalarView</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  6, 2015 at 01:00:00am</p></header><div class="content"><p>There&#39;s no way to create a substring of `StaticString` that&#39;s still<br>typed as `StaticString`. This is occasionally desirable, for example if<br>you want to extract the filename from `__FILE__` to pass to another API<br>that requires a `StaticString`.<br></p><p>I believe the best solution to this is to add a type<br>`StaticString.UnicodeScalarView`, similar to `String.UnicodeScalarView`.<br>`StaticString` would also be extended with a property `unicodeScalars`<br>and two initializers to construct a `StaticString` from a<br>`String.UnicodeScalarView`. The full proposed API looks like:<br></p><p>extension StaticString {  /// The value of `self` as a collection of<br>[Unicode scalar values]<br>(http://www.unicode.org/glossary/#unicode_scalar_value).  public var<br>unicodeScalars: UnicodeScalarView<br></p><p>/// Construct the `StaticString` corresponding to the given  ///<br>`UnicodeScalarView`.  public init(_: UnicodeScalarView)<br></p><p>/// Construct the `StaticString` corresponding to the given  ///<br>`UnicodeScalarView` slice.  public init(_: Slice&lt;UnicodeScalarView&gt;)<br></p><p>/// A collection of [Unicode scalar values]<br>(http://www.unicode.org/glossary/#unicode_scalar_value) that  /// encode<br>a `StaticString`.  public struct UnicodeScalarView : CollectionType {<br></p><p>init(_: StaticString)<br></p><p>/// A position in a `StaticString.UnicodeScalarView`.    public struct<br>Index : BidirectionalIndexType, Comparable {      /// Returns the next<br>consecutive value after `self`.      ///      /// - Requires: The next<br>value is representable.      @warn_unused_result      public func<br>successor() -&gt; Index<br></p><p>/// Returns the previous consecutive value before `self`.      ///<br>/// - Requires: The previous value is representable.<br>@warn_unused_result      public func predecessor() -&gt; Index    }<br></p><p>/// The position of the first `UnicodeScalar` if the `StaticString` is<br>/// non-empty; identical to `endIndex` otherwise.    public var<br>startIndex: Index<br></p><p>/// The &quot;past the end&quot; position.    ///    /// `endIndex` is not a valid<br>argument to `subscript`, and is always    /// reachable from<br>`startIndex` by zero or more applications of    /// `successor()`.<br>public var endIndex: Index<br></p><p>/// Returns `true` iff `self` is empty.    public var isEmpty: Bool<br></p><p>public subscript(position: Index) -&gt; UnicodeScalar  } }<br></p><p>An alternative would be to make StaticString itself conform to<br>CollectionType, but this is a bad idea for the same reasons that String<br>doesn&#39;t conform to CollectionType.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2f52b014/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add StaticString.UnicodeScalarView</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  6, 2015 at 01:00:00am</p></header><div class="content"><p>I&#39;ve submitted a proposal for this as<br></p><p>https://github.com/apple/swift-evolution/pull/32<br></p><p>I also have an implementation written as<br></p><p>https://github.com/apple/swift/pull/277<br></p><p>-Kevin Ballard<br></p><p>On Sun, Dec 6, 2015, at 01:21 AM, Kevin Ballard wrote:<br>&gt; There&#39;s no way to create a substring of `StaticString` that&#39;s still<br>&gt; typed as `StaticString`. This is occasionally desirable, for example<br>&gt; if you want to extract the filename from `__FILE__` to pass to another<br>&gt; API that requires a `StaticString`.<br>&gt;<br>&gt; I believe the best solution to this is to add a type<br>&gt; `StaticString.UnicodeScalarView`, similar to<br>&gt; `String.UnicodeScalarView`. `StaticString` would also be extended with<br>&gt; a property `unicodeScalars` and two initializers to construct a<br>&gt; `StaticString` from a `String.UnicodeScalarView`. The full proposed<br>&gt; API looks like:<br>&gt;<br>&gt; extension StaticString {  /// The value of `self` as a collection of<br>&gt; [Unicode scalar values]<br>&gt; (http://www.unicode.org/glossary/#unicode_scalar_value).  public var<br>&gt; unicodeScalars: UnicodeScalarView<br>&gt;<br>&gt; /// Construct the `StaticString` corresponding to the given  ///<br>&gt; `UnicodeScalarView`.  public init(_: UnicodeScalarView)<br>&gt;<br>&gt; /// Construct the `StaticString` corresponding to the given  ///<br>&gt; `UnicodeScalarView` slice.  public init(_: Slice&lt;UnicodeScalarView&gt;)<br>&gt;<br>&gt; /// A collection of [Unicode scalar values]<br>&gt; (http://www.unicode.org/glossary/#unicode_scalar_value) that  ///<br>&gt; encode a `StaticString`.  public struct UnicodeScalarView :<br>&gt; CollectionType {<br>&gt;<br>&gt; init(_: StaticString)<br>&gt;<br>&gt; /// A position in a `StaticString.UnicodeScalarView`.    public struct<br>&gt; Index : BidirectionalIndexType, Comparable {      /// Returns the next<br>&gt; consecutive value after `self`.      ///      /// - Requires: The next<br>&gt; value is representable.      @warn_unused_result      public func<br>&gt; successor() -&gt; Index<br>&gt;<br>&gt; /// Returns the previous consecutive value before `self`.      ///<br>&gt; /// - Requires: The previous value is representable.<br>&gt; @warn_unused_result      public func predecessor() -&gt; Index    }<br>&gt;<br>&gt; /// The position of the first `UnicodeScalar` if the `StaticString` is<br>&gt; /// non-empty; identical to `endIndex` otherwise.    public var<br>&gt; startIndex: Index<br>&gt;<br>&gt; /// The &quot;past the end&quot; position.    ///    /// `endIndex` is not a<br>&gt; valid argument to `subscript`, and is always    /// reachable from<br>&gt; `startIndex` by zero or more applications of    /// `successor()`.<br>&gt; public var endIndex: Index<br>&gt;<br>&gt; /// Returns `true` iff `self` is empty.    public var isEmpty: Bool<br>&gt;<br>&gt; public subscript(position: Index) -&gt; UnicodeScalar  } }<br>&gt;<br>&gt; An alternative would be to make StaticString itself conform to<br>&gt; CollectionType, but this is a bad idea for the same reasons that<br>&gt; String doesn&#39;t conform to CollectionType.<br>&gt;<br>&gt; -Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/103dd1b8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add StaticString.UnicodeScalarView</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  6, 2015 at 02:00:00am</p></header><div class="content"><p>Hi Kevin,<br></p><p>Thank you for the proposal.  This is in line with the current design of<br>String.  One of the Swift 3 goals is a redesign of String, to make the API<br>easier to use.  I don&#39;t think that should block this improvement, since<br>whatever the new design is, it should provide the UnicodeScalar view<br>functionality for String, and the same API should be exposed on<br>StaticString.<br></p><p>On Sun, Dec 6, 2015 at 1:21 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There&#39;s no way to create a substring of `StaticString` that&#39;s still typed<br>&gt; as `StaticString`. This is occasionally desirable, for example if you want<br>&gt; to extract the filename from `__FILE__` to pass to another API that<br>&gt; requires a `StaticString`.<br>&gt;<br>&gt; I believe the best solution to this is to add a type<br>&gt; `StaticString.UnicodeScalarView`, similar to `String.UnicodeScalarView`.<br>&gt; `StaticString` would also be extended with a property `unicodeScalars` and<br>&gt; two initializers to construct a `StaticString` from a<br>&gt; `String.UnicodeScalarView`. The full proposed API looks like:<br>&gt;<br>&gt; extension StaticString {<br>&gt;   /// The value of `self` as a collection of [Unicode scalar values](<br>&gt; http://www.unicode.org/glossary/#unicode_scalar_value).<br>&gt;   public var unicodeScalars: UnicodeScalarView<br>&gt;<br>&gt;   /// Construct the `StaticString` corresponding to the given<br>&gt;   /// `UnicodeScalarView`.<br>&gt;   public init(_: UnicodeScalarView)<br>&gt;<br>&gt;   /// Construct the `StaticString` corresponding to the given<br>&gt;   /// `UnicodeScalarView` slice.<br>&gt;   public init(_: Slice&lt;UnicodeScalarView&gt;)<br>&gt;<br>&gt;   /// A collection of [Unicode scalar values](<br>&gt; http://www.unicode.org/glossary/#unicode_scalar_value) that<br>&gt;   /// encode a `StaticString`.<br>&gt;   public struct UnicodeScalarView : CollectionType {<br>&gt;<br></p><p>UnicodeScalarView should be a slice type, that is,<br>UnicodeScalarView.SubSequence == UnicodeScalarView.<br></p><p>Then, you will be able to remove the<br>StaticString.init(Slice&lt;UnicodeScalarView&gt;) initializer.<br></p><p>It should also be CustomStringConvertible, CustomDebugStringConvertible,<br>with the same behavior as String.<br></p><p>Please also add a CustomReflectable conformance, that extracts the string<br>value and reflects that.<br></p><p>    init(_: StaticString)<br>&gt;<br>&gt;     /// A position in a `StaticString.UnicodeScalarView`.<br>&gt;     public struct Index : BidirectionalIndexType, Comparable {<br>&gt;       /// Returns the next consecutive value after `self`.<br>&gt;       ///<br>&gt;       /// - Requires: The next value is representable.<br>&gt;       @warn_unused_result<br>&gt;       public func successor() -&gt; Index<br>&gt;<br>&gt;       /// Returns the previous consecutive value before `self`.<br>&gt;       ///<br>&gt;       /// - Requires: The previous value is representable.<br>&gt;       @warn_unused_result<br>&gt;       public func predecessor() -&gt; Index<br>&gt;     }<br>&gt;<br>&gt;     /// The position of the first `UnicodeScalar` if the `StaticString` is<br>&gt;     /// non-empty; identical to `endIndex` otherwise.<br>&gt;     public var startIndex: Index<br>&gt;<br>&gt;     /// The &quot;past the end&quot; position.<br>&gt;     ///<br>&gt;     /// `endIndex` is not a valid argument to `subscript`, and is always<br>&gt;     /// reachable from `startIndex` by zero or more applications of<br>&gt;     /// `successor()`.<br>&gt;     public var endIndex: Index<br>&gt;<br>&gt;     /// Returns `true` iff `self` is empty.<br>&gt;     public var isEmpty: Bool<br>&gt;<br>&gt;     public subscript(position: Index) -&gt; UnicodeScalar<br>&gt;   }<br>&gt; }<br>&gt;<br></p><p>You omitted == and &lt; APIs for indices.<br></p><p><br>&gt; An alternative would be to make StaticString itself conform to<br>&gt; CollectionType, but this is a bad idea for the same reasons that String<br>&gt; doesn&#39;t conform to CollectionType.<br>&gt;<br></p><p>Agreed.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/3a6a427d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
