<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a02fb5c94ea077d3576e3e830309bee?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Daniel Höpfl</string> &lt;daniel at hoepfl.de&gt;<p>April 21, 2016 at 09:00:00am</p></header><div class="content"><p>Hi there!<br></p><p>TL;DR: Here’s my idea for a better localized strings handling in Swift.<br>It includes both, support for string interpolation support for<br>NSLocalizedString, and a new string delimiter `...` that can be used<br>instead of NSLocalizedString(&quot;...&quot;).<br></p><p>Markdown hard to read? See<br>&lt;https://gist.github.com/dhoepfl/203f8b9bb8014593772a3b12d807ebce&gt;<br></p><p>Greetings,<br>   Daniel<br></p><p><br># Localization support for string interpolation<br></p><p>## Introduction<br></p><p>I&#39;d like to see some kind of advanced localization support in the Swift<br>standard library. Currently all we have is what Cocoa provides but that<br>does not work well with string interpolation. More or less, you can not<br>use string interpolation if you have to use `NSLocalizedString` and friends.<br></p><p>[I implemented a proof of<br>concept](https://github.com/dhoepfl/DHLocalizedString),<br>`DHLocalizedString`, that fills this gap. I would like to see something<br>similar being part of the Swift standard library. While it is possible<br>to implement localized strings as a custom library, this lacks support<br>from genstring and other tools.<br></p><p>I’m not sure if `NSLocalizedString` is considered part of the Swift<br>standard library (being part of Foundation Functions). Since there is<br>decent Unicode-string support in Swift, I would like to see localization<br>as part of the language, too. This proposal also includes a new string<br>delimiter `` ` `` that deeply integrate localized strings in the language.<br></p><p>## Motivation<br></p><p>String interpolation greatly simplyfies text handling but makes it hard<br>to localize. You can not pass a string with interpolation to<br>`NSLocalizedString` because the key could be unpredictable.<br></p><p>## Proposed solution<br></p><p>`NSLocalizedString` should be extended to work with string interpolation:<br></p><p>```swift<br>let quote = &quot;Never trust the internet!&quot;<br>let person = &quot;Albert Einstein&quot;<br>print(NSLocalizedString(&quot;&lt;\(quote)&gt; by &lt;\(person)&gt;&quot;));<br>```<br></p><p>should look up the key:<br></p><p>```&quot;&lt;%@&gt; by &lt;%@&gt;&quot; = &quot;%2$@ said: “%1$@”&quot;;```<br></p><p>and print:<br></p><p>```Albert Einstein said: “Never trust the internet!”```<br></p><p>So, `NSLocalizedString` (and friends) would “just work” with string<br>interpolation. I’m not sure about the key format to use but my proof of<br>concept simply replaces every interpolation with `%@` which seems<br>reasonable.<br></p><p>The proof of concept also includes an postfix operator `|~` (think of a<br>flag) to reduce the impact localized strings have in line length.<br>Actually, I would love to replace `&quot;` by a different marker (e.g.<br>`~|string|~`, `&#39;&#39;string&#39;&#39;`, ``` ``string`` ```, or `` `string` ``?) for<br>localized strings. Imagine you could write the previous example as:<br></p><p>```swift<br>print(`&lt;\(quote)&gt; by &lt;\(person)&gt;`);<br>```<br></p><p>This syntax needs some work on how to specify `tableName:`, `bundle:`,<br>and `comment:`. For `tableName:` and `bundle:`, I&#39;d love to have a<br>construct to specify it for all localization tags within the file (e.g.<br>`#localization(tableName: ..., bundle: ...)`).<br></p><p>If Swift gets multiline strings (`&quot;&quot;&quot;string&quot;&quot;&quot;`), `` `string` `` could<br>also have ```` ```multiline``` ````.<br></p><p>## Impact on existing code<br></p><p>I see very little impact. There might be code out there that uses a<br>interpolated string as argument for `NSLocalizedString`. The key used in<br>this case would change, breaking the translation. It would be possible<br>to include a check for interpolated strings as arguments to<br>`NSLocalizedString` calls in the code update tool.<br></p><p>## Alternatives considered<br></p><p>### Use `NSLocalizedString` as is<br></p><p>One can use `NSLocalizedString` as it was used in Objective-C but this<br>means that string interpolation cannot be used.<br></p><p>### `localized()` function for String class<br></p><p>I did not find a way how to get the function called before the string<br>interpolation took place. (`&quot;&lt;\(quote)&gt; by &lt;\(person)&gt;&quot;.localized()`)<br></p><p>### Custom function<br></p><p>See above: The drawbacks are: Not having support in standard tools and<br>the operator syntax not being as good as it could be.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/369d2e2eccdbec4dcebf5bd6f99abb3a?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Uli Kusterer</string> &lt;kusterer at orangejuiceliberationfront.com&gt;<p>April 21, 2016 at 12:00:00pm</p></header><div class="content"><p>Daniel, thanks for posting this. As you already know from Twitter, I&#39;m very much in favor of this proposal. I can pretty much not use string interpolation because it doesn&#39;t localize properly.<br></p><p>On 21 Apr 2016, at 09:42, Daniel Höpfl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; So, `NSLocalizedString` (and friends) would “just work” with string<br>&gt; interpolation. I’m not sure about the key format to use but my proof of<br>&gt; concept simply replaces every interpolation with `%@` which seems<br>&gt; reasonable.<br></p><p> One request: Could you perhaps use positional syntax? In some languages, the word order of the placeholders needs to change, and there needs to be a way to detect that the translator swapped two placeholders. In NSLocalizedString, that is done via %1$@, %2$@.<br></p><p>— Uli Kusterer<br>“The Witnesses of TeachText are everywhere...&quot;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 21, 2016, at 12:42 AM, Daniel Höpfl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; TL;DR: Here’s my idea for a better localized strings handling in Swift.<br>&gt; It includes both, support for string interpolation support for<br>&gt; NSLocalizedString, and a new string delimiter `...` that can be used<br>&gt; instead of NSLocalizedString(&quot;...”).<br></p><p>FWIW, this is closely related to the idea of extending string interpolation to support generalized “printf” style modifiers, which would allow very expressive formatting inline in a string interpolation.  This has not yet come to pass, but a write up of the ideas are available here:<br>https://github.com/apple/swift/blob/master/docs/TextFormatting.rst<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 2:33 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 21, 2016, at 12:42 AM, Daniel Höpfl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there!<br>&gt;&gt; <br>&gt;&gt; TL;DR: Here’s my idea for a better localized strings handling in Swift.<br>&gt;&gt; It includes both, support for string interpolation support for<br>&gt;&gt; NSLocalizedString, and a new string delimiter `...` that can be used<br>&gt;&gt; instead of NSLocalizedString(&quot;...”).<br>&gt; <br>&gt; FWIW, this is closely related to the idea of extending string interpolation to support generalized “printf” style modifiers, which would allow very expressive formatting inline in a string interpolation.  This has not yet come to pass, but a write up of the ideas are available here:<br>&gt; https://github.com/apple/swift/blob/master/docs/TextFormatting.rst<br></p><p>Actually, it looks like the interesting point didn’t make it into the formal writeup.  The idea was to enable something like this (just a sketch):<br></p><p>public protocol CustomStringConvertible {<br>  /// A textual representation of `self`.<br>  var description: String { get }<br></p><p>  func formattedDescription(format: String) -&gt; String { get }<br>}<br></p><p><br>Int could then implement support for “x” to print hexadecimal, we could support left/right whitespace padding, and custom types could provide their own custom formatters (e.g. a string could have a title case formatter, or a &quot;look up localized form of” modifier).  We could then provide a “printf” that would allow traditional “%x0” substitutions.  It could also be incorporated into the string literal syntax by allowing something like:<br></p><p>	let hashValue = 42  // not a good hash function<br>	print(“Hashcode = \(hashValue:x)”)<br></p><p>This is just a sketch, but that’s the idea.  It never went anywhere because we didn’t have the language features in place to make it work, notably defaulted implementations in protocols were missing at the time.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/369d2e2eccdbec4dcebf5bd6f99abb3a?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Uli Kusterer</string> &lt;kusterer at orangejuiceliberationfront.com&gt;<p>April 27, 2016 at 03:00:00am</p></header><div class="content"><p>On 24 Apr 2016, at 23:40, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Int could then implement support for “x” to print hexadecimal, we could support left/right whitespace padding, and custom types could provide their own custom formatters (e.g. a string could have a title case formatter, or a &quot;look up localized form of” modifier).  We could then provide a “printf” that would allow traditional “%x0” substitutions.<br></p><p> I&#39;m not quite sure why we&#39;d want to support printf-style syntax in the first place? Interpolation is more readable, as the formats contain their descriptive variable names, and you don&#39;t have to worry about matching up format string placeholder order and types with those of what you&#39;re actually passing. I.e. string interpolation is to printf what type inference is to explicit declarations, and what labeled parameters are to old-style C initializer lists.<br></p><p> So I&#39;d say Swift should come at this from the other direction and ensure that anything you were able to do with printf is also possible with interpolation (if that means specifying some sort of format flag in-line as well, I could live with that).<br></p><p> I do see the utility in allowing any custom type to be printed out via interpolation though, and to allow them to at the least query the existing flags as well. But should we really use single-character flags? C++, apart from overloading bitshift, has the right idea:<br></p><p>	cout &lt;&lt; &quot;foo&quot; &lt;&lt; hex &lt;&lt; 123 &lt;&lt; &quot;\n&quot;;<br></p><p>is much more readable than<br></p><p>	printf( &quot;foo%x\n&quot;, 123 );<br></p><p>Maybe we could just use a function as the flag?<br></p><p>	print( &quot;foo\(hex(123))\n&quot; )<br></p><p>would then expand into &quot;foo&quot; hex(123) &quot;\n&quot;, where hex would just be an object or function that takes an Int and returns a hex-formatted string? Though this&#39;d pollute the namespace I suppose. 123.hex() maybe? Then it could be an arbitrary method on Int, added with a category.<br></p><p>Cheers,<br>-- Uli Kusterer<br>&quot;The Witnesses of TeachText are everywhere...&quot;<br>http://orangejuiceliberationfront.com<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a02fb5c94ea077d3576e3e830309bee?s=50"></div><header><strong>Localization support for string interpolation</strong> from <string>Daniel Höpfl</string> &lt;daniel at hoepfl.de&gt;<p>April 26, 2016 at 09:00:00am</p></header><div class="content"><p>On 24.04.16 23:33, Chris Lattner wrote:<br>&gt; <br>&gt;&gt; On Apr 21, 2016, at 12:42 AM, Daniel Höpfl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi there!<br>&gt;&gt;<br>&gt;&gt; TL;DR: Here’s my idea for a better localized strings handling in Swift.<br>&gt;&gt; It includes both, support for string interpolation support for<br>&gt;&gt; NSLocalizedString, and a new string delimiter `...` that can be used<br>&gt;&gt; instead of NSLocalizedString(&quot;...”).<br>&gt; <br>&gt; FWIW, this is closely related to the idea of extending string interpolation to support generalized “printf” style modifiers, which would allow very expressive formatting inline in a string interpolation.  This has not yet come to pass, but a write up of the ideas are available here:<br>&gt; https://github.com/apple/swift/blob/master/docs/TextFormatting.rst<br></p><p>As I understand it, TextFormatting is focused on what happens inside the<br>interpolation brackets. The localization support has its focus on the<br>string parts outside the brackets.<br></p><p>I left out how to localize the parts inside the brackets on purpose<br>because that always involves developer’s decision. How to find the<br>translation of the string parts does not have to.<br></p><p>My proposal is just a Swiftyfied version of NSLocalizedString and, as<br>TextFormatting says: &quot;Cocoa programmers can still use Cocoa localization<br>APIs for localization jobs&quot;<br></p><p>So: Yes, these two proposals are related but IMO not that closely.<br></p><p>Greetings,<br>   Daniel<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
