<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 10, 2016 at 01:00:00am</p></header><div class="content"><p>On 2016-07-09 04:39:01 +0000, Jordan Rose via swift-evolution said:<br></p><p>&gt; I wanted to share a concrete use case that Daniel Dunbar relayed to me. <br>&gt; He was working on a closed class hierarchy like the ones discussed <br>&gt; here, where all of the subclasses are within a single module, but they <br>&gt; are all public. The class also has a required initializer for dynamic <br>&gt; construction, so that they could write something like this:<br>&gt; <br>&gt; internal struct ModelContext { /*…*/ }<br>&gt; <br>&gt; public class ModelBase {<br>&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;   // …<br>&gt; }<br>&gt; public class SimpleModel: ModelBase {<br>&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt; }<br>&gt; public class MoreComplicatedModel: ModelBase { /*…*/ }<br>&gt; <br>&gt; // (within some other type)<br>&gt; public func instantiateModelObject&lt;Model: ModelBase&gt;(_ type: Model) -&gt; Model {<br>&gt;   return type.init(context: self.context)<br>&gt; }<br>&gt; <br>&gt; That is, a public entry point calls a required initializer with an <br>&gt; internal argument type. This is the only way to instantiate Model <br>&gt; objects, and the internal context type doesn’t leak out into the public <br>&gt; API.<br>&gt; <br>&gt; Of course, Swift doesn’t allow this. If someone outside of the module <br>&gt; subclasses ModelBase, there’s no way for them to provide the <br>&gt; dynamically-dispatched &#39;init(context:)’, because they don’t have access <br>&gt; to the internal ModelContext. The author of the library has to make the <br>&gt; required initializers public, and either set the ModelContext <br>&gt; separately or make it public as well. Even though no one outside the <br>&gt; module should be using these APIs.<br></p><p>Can you remind us why does Swift need required initializers to have the <br>same access as the containing class?<br></p><p>Having only package-internal constructors in the public base class is <br>the usual pattern for exporting a sealed class hierarchy in some other <br>languages, like Java.<br></p><p>-- <br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 10, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 1:37 AM, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 2016-07-09 04:39:01 +0000, Jordan Rose via swift-evolution said:<br>&gt; <br>&gt;&gt; I wanted to share a concrete use case that Daniel Dunbar relayed to me. He was working on a closed class hierarchy like the ones discussed here, where all of the subclasses are within a single module, but they are all public. The class also has a required initializer for dynamic construction, so that they could write something like this:<br>&gt;&gt; internal struct ModelContext { /*…*/ }<br>&gt;&gt; public class ModelBase {<br>&gt;&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;&gt;   // …<br>&gt;&gt; }<br>&gt;&gt; public class SimpleModel: ModelBase {<br>&gt;&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;&gt; }<br>&gt;&gt; public class MoreComplicatedModel: ModelBase { /*…*/ }<br>&gt;&gt; // (within some other type)<br>&gt;&gt; public func instantiateModelObject&lt;Model: ModelBase&gt;(_ type: Model) -&gt; Model {<br>&gt;&gt;   return type.init(context: self.context)<br>&gt;&gt; }<br>&gt;&gt; That is, a public entry point calls a required initializer with an internal argument type. This is the only way to instantiate Model objects, and the internal context type doesn’t leak out into the public API.<br>&gt;&gt; Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext. The author of the library has to make the required initializers public, and either set the ModelContext separately or make it public as well. Even though no one outside the module should be using these APIs.<br>&gt; <br>&gt; Can you remind us why does Swift need required initializers to have the same access as the containing class?<br></p><p>Because without required initializers you can&#39;t do something like:<br></p><p>let cl: MyClass.Type = ...<br>let instance = cl.init(value: 0)<br></p><p>where MyClass has a required init(value: Int).<br></p><p>The issue here is that in order to be able to do this, subclasses that implement another initializer must implement this one as well - so it must be visible outside of the module if it is public.<br></p><p>&gt; <br>&gt; Having only package-internal constructors in the public base class is the usual pattern for exporting a sealed class hierarchy in some other languages, like Java.<br>&gt; <br>&gt; -- <br>&gt; Károly<br>&gt; @lorentey<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 16:37, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 2016-07-09 04:39:01 +0000, Jordan Rose via swift-evolution said:<br>&gt; <br>&gt;&gt; I wanted to share a concrete use case that Daniel Dunbar relayed to me. He was working on a closed class hierarchy like the ones discussed here, where all of the subclasses are within a single module, but they are all public. The class also has a required initializer for dynamic construction, so that they could write something like this:<br>&gt;&gt; internal struct ModelContext { /*…*/ }<br>&gt;&gt; public class ModelBase {<br>&gt;&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;&gt;   // …<br>&gt;&gt; }<br>&gt;&gt; public class SimpleModel: ModelBase {<br>&gt;&gt;   internal required init(context: ModelContext) { /*…*/ }<br>&gt;&gt; }<br>&gt;&gt; public class MoreComplicatedModel: ModelBase { /*…*/ }<br>&gt;&gt; // (within some other type)<br>&gt;&gt; public func instantiateModelObject&lt;Model: ModelBase&gt;(_ type: Model) -&gt; Model {<br>&gt;&gt;   return type.init(context: self.context)<br>&gt;&gt; }<br>&gt;&gt; That is, a public entry point calls a required initializer with an internal argument type. This is the only way to instantiate Model objects, and the internal context type doesn’t leak out into the public API.<br>&gt;&gt; Of course, Swift doesn’t allow this. If someone outside of the module subclasses ModelBase, there’s no way for them to provide the dynamically-dispatched &#39;init(context:)’, because they don’t have access to the internal ModelContext. The author of the library has to make the required initializers public, and either set the ModelContext separately or make it public as well. Even though no one outside the module should be using these APIs.<br>&gt; <br>&gt; Can you remind us why does Swift need required initializers to have the same access as the containing class?<br>&gt; <br>&gt; Having only package-internal constructors in the public base class is the usual pattern for exporting a sealed class hierarchy in some other languages, like Java.<br></p><p>Sure. A required initializer is one that will be invoked on an unknown subclass of the type, as in the instantiateModelObject method above. That means that it must be present on all subclasses, because it’s generally impossible to prove that a particular subclass will not be passed to instantiateModelObject.<br></p><p>Swift currently doesn’t allow this at all, but we could imagine making it a run-time error instead of a compile-time error, i.e. if instantiateModelObject is called on a class that doesn’t provide its own implementation of init(context:), the program would trap. That’d be giving up some compiler-provided safety for run-time flexibility, which can certainly be desirable.<br></p><p>However, this is just the tip of the iceberg. In the implementation of the subclass, there has to be a call to one of the superclass&#39;s initializers. If all of the superclass’s initializers are non-public, then there’s no way to write your own initializer. (This is actually true in Swift today.) This isn’t quite the same as sealed-by-default because the subclass could just inherit the superclass’s initializers, but it’s very close: the only way to instantiate such a class would be through a required initializer, which you couldn’t customize.<br></p><p>In that sense, Swift already has something very similar to sealed-by-default, which just doesn’t work very well in the particular use case where you also need to use dynamic initialization.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/c919bde4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; In the implementation of the subclass, there has to be a call to one of the superclass&#39;s initializers. If all of the superclass’s initializers are non-public, then there’s no way to write your own initializer. (This is actually true in Swift today.)<br>I want to point out that this strange behavior can actually be useful:<br>As of now, you cannot create a public subclass with internal ancestors — it&#39;s all or nothing.<br>When you keep the initializer of the base class internal, you practically seal this class, but it&#39;s still possible for framework clients to access the public subclasses supplied for them.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/39594b7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 00:50, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; In the implementation of the subclass, there has to be a call to one of the superclass&#39;s initializers. If all of the superclass’s initializers are non-public, then there’s no way to write your own initializer. (This is actually true in Swift today.)<br>&gt; I want to point out that this strange behavior can actually be useful:<br>&gt; As of now, you cannot create a public subclass with internal ancestors — it&#39;s all or nothing.<br>&gt; When you keep the initializer of the base class internal, you practically seal this class, but it&#39;s still possible for framework clients to access the public subclasses supplied for them.<br></p><p>Yes. My point was that we already have something equivalent to what’s being proposed, but it’s ad hoc, and interacts poorly with some other features of the language.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/c1610464/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
