<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Suggestion] Case-based dispatch for enum methods</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Recently, I have been working on implementing some non-trivial data structures in Swift (its about storing polygons in a space-partitioning tree). I am using enums to represent different types of parent nodes and leafs and I had some ideas to make them more fit for this kind of work. I expect that I will write multiple enum-related emails, each one concentrating on one particular feature. A usual disclaimer: these are random, quite rough ideas that might or not make sense, but I’d like to get some feedback  from the community. <br></p><p>Case-based dispatch for enum methods<br></p><p>Often, behaviour of enum method depends on the enum value. For instance, imagine a tree structure with an insert(value:) method: the way how the inserting is handled depends on the type of the node. Usually, you’d implement it as a switch operation:<br></p><p>func insert(value:T) {<br>  switch self {<br>    case let Leaf1(a, b, c): …<br>    case let Leaf2(a, b): …<br>    case let Parent1(x, y): …<br>  }<br>}<br></p><p>If the insert operation is non-trivial, this becomes quite convoluted. You can of course define private helper methods or functions that perform the specific functionality, but I don’t find it to be a very satisfying solution: there is still the switch boilerplate + you need to be careful to call the correct helper, so there are some safety issues. <br></p><p>Now, suppose there was a way to add a method implementation that is case-specific:<br></p><p>enum MyTree {<br>  case Leaf1(Float, Float) {<br>    mutating  func insert(value: T) {<br>       let (a, b) = self.Leaf1 // or something like that<br>       // handle insert for the case that node is of type Parent1<br></p><p>       ...<br>     }<br>  }<br></p><p> case Parent1(Int, Float) {<br>     mutating func insert(value: T) {<br>       let (x, y) = self.Parent1 // or something like that<br>       // handle insert for the case that node is of type Parent1<br>       ...<br>     }<br>  }<br></p><p>default {<br>   mutating func insert(value: T) {<br>      // handle insert for all other cases <br>       ...<br>     }<br>}<br>}<br></p><p>etc. The case method specification needs to be exhaustive and adhere to the same signature. It is a compile-time error to specify a method or property only in some cases but not in the other ones (that is why we have the default implementation). Outer scope definitions apply to all cases and cannot be overridden by a case-specific implementation. <br></p><p>Basically, the compiler would synthesise an outer-scope method that does a switch operator to dispatch to the particular implementation. This is thus mostly syntactic sugar which also promotes safety (as it becomes impossible to call the wrong implementation). These would make the case-specific methods fully compatible with protocols etc. (e.g. a protocol Insertable { mutating func insert(value:) }<br></p><p>Looking forward to your thoughts on this!<br></p><p>Best, <br></p><p> Taras<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/d91bf1db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Suggestion] Case-based dispatch for enum methods</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April  5, 2016 at 07:00:00am</p></header><div class="content"><p>Is the lack of comments due to general disinterest in such a thing or did my mail go amiss somehow? ;)<br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; On 31 Mar 2016, at 14:39, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; Recently, I have been working on implementing some non-trivial data structures in Swift (its about storing polygons in a space-partitioning tree). I am using enums to represent different types of parent nodes and leafs and I had some ideas to make them more fit for this kind of work. I expect that I will write multiple enum-related emails, each one concentrating on one particular feature. A usual disclaimer: these are random, quite rough ideas that might or not make sense, but I’d like to get some feedback  from the community. <br>&gt; <br>&gt; Case-based dispatch for enum methods<br>&gt; <br>&gt; Often, behaviour of enum method depends on the enum value. For instance, imagine a tree structure with an insert(value:) method: the way how the inserting is handled depends on the type of the node. Usually, you’d implement it as a switch operation:<br>&gt; <br>&gt; func insert(value:T) {<br>&gt;   switch self {<br>&gt;     case let Leaf1(a, b, c): …<br>&gt;     case let Leaf2(a, b): …<br>&gt;     case let Parent1(x, y): …<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If the insert operation is non-trivial, this becomes quite convoluted. You can of course define private helper methods or functions that perform the specific functionality, but I don’t find it to be a very satisfying solution: there is still the switch boilerplate + you need to be careful to call the correct helper, so there are some safety issues. <br>&gt; <br>&gt; Now, suppose there was a way to add a method implementation that is case-specific:<br>&gt; <br>&gt; enum MyTree {<br>&gt;   case Leaf1(Float, Float) {<br>&gt;     mutating  func insert(value: T) {<br>&gt;        let (a, b) = self.Leaf1 // or something like that<br>&gt;        // handle insert for the case that node is of type Parent1<br>&gt; <br>&gt;        ...<br>&gt;      }<br>&gt;   }<br>&gt; <br>&gt;  case Parent1(Int, Float) {<br>&gt;      mutating func insert(value: T) {<br>&gt;        let (x, y) = self.Parent1 // or something like that<br>&gt;        // handle insert for the case that node is of type Parent1<br>&gt;        ...<br>&gt;      }<br>&gt;   }<br>&gt; <br>&gt; default {<br>&gt;    mutating func insert(value: T) {<br>&gt;       // handle insert for all other cases <br>&gt;        ...<br>&gt;      }<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; etc. The case method specification needs to be exhaustive and adhere to the same signature. It is a compile-time error to specify a method or property only in some cases but not in the other ones (that is why we have the default implementation). Outer scope definitions apply to all cases and cannot be overridden by a case-specific implementation. <br>&gt; <br>&gt; Basically, the compiler would synthesise an outer-scope method that does a switch operator to dispatch to the particular implementation. This is thus mostly syntactic sugar which also promotes safety (as it becomes impossible to call the wrong implementation). These would make the case-specific methods fully compatible with protocols etc. (e.g. a protocol Insertable { mutating func insert(value:) }<br>&gt; <br>&gt; Looking forward to your thoughts on this!<br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/495c55c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Suggestion] Case-based dispatch for enum methods</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April  5, 2016 at 02:00:00am</p></header><div class="content"><p>I missed it the first time around.<br></p><p>I like this idea but worry that it will invite some difficult to follow<br>implementations.<br></p><p>I think that there would need to exist some restrictions on how methods<br>could be broken up. One such restriction might be that these<br>implementations could not be broken up between extensions for a given<br>method. I don&#39;t know if the added complexity of reading this pays off<br>though. you get something like this if you call a method in each case of<br>the enum.<br></p><p>Would keeping track of exhaustiveness be more of a technical issue with<br>this feature? On the user side, this feature would be a pain without<br>improving the &#39;switch must be exhaustive&#39; message to include the cases that<br>the compiler believes are missing.<br></p><p>TJ<br></p><p>On Tue, Apr 5, 2016 at 1:57 AM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is the lack of comments due to general disinterest in such a thing or did<br>&gt; my mail go amiss somehow? ;)<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt; On 31 Mar 2016, at 14:39, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;<br>&gt; Recently, I have been working on implementing some non-trivial data<br>&gt; structures in Swift (its about storing polygons in a space-partitioning<br>&gt; tree). I am using enums to represent different types of parent nodes and<br>&gt; leafs and I had some ideas to make them more fit for this kind of work. I<br>&gt; expect that I will write multiple enum-related emails, each one<br>&gt; concentrating on one particular feature. A usual disclaimer: these are<br>&gt; random, quite rough ideas that might or not make sense, but I’d like to get<br>&gt; some feedback  from the community.<br>&gt;<br>&gt; *Case-based dispatch for enum methods*<br>&gt;<br>&gt; Often, behaviour of enum method depends on the enum value. For instance,<br>&gt; imagine a tree structure with an insert(value:) method: the way how the<br>&gt; inserting is handled depends on the type of the node. Usually, you’d<br>&gt; implement it as a switch operation:<br>&gt;<br>&gt; func insert(value:T) {<br>&gt;   switch self {<br>&gt;     case let Leaf1(a, b, c): …<br>&gt;     case let Leaf2(a, b): …<br>&gt;     case let Parent1(x, y): …<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; If the insert operation is non-trivial, this becomes quite convoluted. You<br>&gt; can of course define private helper methods or functions that perform the<br>&gt; specific functionality, but I don’t find it to be a very satisfying<br>&gt; solution: there is still the switch boilerplate + you need to be careful to<br>&gt; call the correct helper, so there are some safety issues.<br>&gt;<br>&gt; Now, suppose there was a way to add a method implementation that is<br>&gt; case-specific:<br>&gt;<br>&gt; enum MyTree {<br>&gt;   case Leaf1(Float, Float) {<br>&gt;     mutating  func insert(value: T) {<br>&gt;        let (a, b) = self.Leaf1 // or something like that<br>&gt;        // handle insert for the case that node is of type Parent1<br>&gt;<br>&gt;        ...<br>&gt;      }<br>&gt;   }<br>&gt;<br>&gt;  case Parent1(Int, Float) {<br>&gt;      mutating func insert(value: T) {<br>&gt;        let (x, y) = self.Parent1 // or something like that<br>&gt;        // handle insert for the case that node is of type Parent1<br>&gt;        ...<br>&gt;      }<br>&gt;   }<br>&gt;<br>&gt; default {<br>&gt;    mutating func insert(value: T) {<br>&gt;       // handle insert for all other cases<br>&gt;        ...<br>&gt;      }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; etc. The case method specification needs to be exhaustive and adhere to<br>&gt; the same signature. It is a compile-time error to specify a method or<br>&gt; property only in some cases but not in the other ones (that is why we have<br>&gt; the default implementation). Outer scope definitions apply to all cases and<br>&gt; cannot be overridden by a case-specific implementation.<br>&gt;<br>&gt; Basically, the compiler would synthesise an outer-scope method that does a<br>&gt; switch operator to dispatch to the particular implementation. This is thus<br>&gt; mostly syntactic sugar which also promotes safety (as it becomes impossible<br>&gt; to call the wrong implementation). These would make the case-specific<br>&gt; methods fully compatible with protocols etc. (e.g. a protocol Insertable {<br>&gt; mutating func insert(value:) }<br>&gt;<br>&gt; Looking forward to your thoughts on this!<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/bf9957d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Suggestion] Case-based dispatch for enum methods</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April  5, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 05 Apr 2016, at 08:19, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I missed it the first time around.<br>&gt; <br>&gt; I like this idea but worry that it will invite some difficult to follow implementations. <br></p><p>True. I think, the question is how flexible one wants enum to be. Right now, Swift enums are nice for representing compact state, but they are quite awkward when trying to do more (e.g. complex recursive data structures with polymorphic behavior). This might be by design,  or this could be simply because enums are still incomplete. Extending enum functionality would effectively make then another alternative to class hierarchies/protocols, only that in the enum case the polymorphic structure is constrained initially. I think it might make sense for enum to be used to implement highly specialised polymorphic data structures, but its more a question of language design. It would be fine in my book if one said ‘no, we really don’t want enums to be that powerful use protocols/structs or classes for complex cases like that’.<br></p><p>This is something where I’d like to have more input from the core team, how do they envision the enum future?<br></p><p>&gt; <br>&gt; I think that there would need to exist some restrictions on how methods could be broken up. One such restriction might be that these implementations could not be broken up between extensions for a given method. I don&#39;t know if the added complexity of reading this pays off though. you get something like this if you call a method in each case of the enum. <br></p><p>A restriction like this would make perfect sense. Tracking of exhaustiveness could (should) be done at a declaration scope level, i.e. declarations must be exhaustive after every enum definition/extension. <br></p><p>&gt; <br>&gt; Would keeping track of exhaustiveness be more of a technical issue with this feature? On the user side, this feature would be a pain without improving the &#39;switch must be exhaustive&#39; message to include the cases that the compiler believes are missing.<br></p><p>I imagine a compiler error along the lines of ‘missing implementation for func() for case A, B, C&#39;<br></p><p>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Tue, Apr 5, 2016 at 1:57 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Is the lack of comments due to general disinterest in such a thing or did my mail go amiss somehow? ;)<br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt;&gt; On 31 Mar 2016, at 14:39, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I have been working on implementing some non-trivial data structures in Swift (its about storing polygons in a space-partitioning tree). I am using enums to represent different types of parent nodes and leafs and I had some ideas to make them more fit for this kind of work. I expect that I will write multiple enum-related emails, each one concentrating on one particular feature. A usual disclaimer: these are random, quite rough ideas that might or not make sense, but I’d like to get some feedback  from the community. <br>&gt;&gt; <br>&gt;&gt; Case-based dispatch for enum methods<br>&gt;&gt; <br>&gt;&gt; Often, behaviour of enum method depends on the enum value. For instance, imagine a tree structure with an insert(value:) method: the way how the inserting is handled depends on the type of the node. Usually, you’d implement it as a switch operation:<br>&gt;&gt; <br>&gt;&gt; func insert(value:T) {<br>&gt;&gt;   switch self {<br>&gt;&gt;     case let Leaf1(a, b, c): …<br>&gt;&gt;     case let Leaf2(a, b): …<br>&gt;&gt;     case let Parent1(x, y): …<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If the insert operation is non-trivial, this becomes quite convoluted. You can of course define private helper methods or functions that perform the specific functionality, but I don’t find it to be a very satisfying solution: there is still the switch boilerplate + you need to be careful to call the correct helper, so there are some safety issues. <br>&gt;&gt; <br>&gt;&gt; Now, suppose there was a way to add a method implementation that is case-specific:<br>&gt;&gt; <br>&gt;&gt; enum MyTree {<br>&gt;&gt;   case Leaf1(Float, Float) {<br>&gt;&gt;     mutating  func insert(value: T) {<br>&gt;&gt;        let (a, b) = self.Leaf1 // or something like that<br>&gt;&gt;        // handle insert for the case that node is of type Parent1<br>&gt;&gt; <br>&gt;&gt;        ...<br>&gt;&gt;      }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;  case Parent1(Int, Float) {<br>&gt;&gt;      mutating func insert(value: T) {<br>&gt;&gt;        let (x, y) = self.Parent1 // or something like that<br>&gt;&gt;        // handle insert for the case that node is of type Parent1<br>&gt;&gt;        ...<br>&gt;&gt;      }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; default {<br>&gt;&gt;    mutating func insert(value: T) {<br>&gt;&gt;       // handle insert for all other cases <br>&gt;&gt;        ...<br>&gt;&gt;      }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; etc. The case method specification needs to be exhaustive and adhere to the same signature. It is a compile-time error to specify a method or property only in some cases but not in the other ones (that is why we have the default implementation). Outer scope definitions apply to all cases and cannot be overridden by a case-specific implementation. <br>&gt;&gt; <br>&gt;&gt; Basically, the compiler would synthesise an outer-scope method that does a switch operator to dispatch to the particular implementation. This is thus mostly syntactic sugar which also promotes safety (as it becomes impossible to call the wrong implementation). These would make the case-specific methods fully compatible with protocols etc. (e.g. a protocol Insertable { mutating func insert(value:) }<br>&gt;&gt; <br>&gt;&gt; Looking forward to your thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best, <br>&gt;&gt; <br>&gt;&gt;  Taras<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/52d6896e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Suggestion] Case-based dispatch for enum methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  4, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Is the lack of comments due to general disinterest in such a thing or did my mail go amiss somehow? ;)<br></p><p>I suspect it has something to do with the very similar thread I started about a week before you. :^) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160321/013153.html&gt; Your use of `default` is new and very interesting, though.<br></p><p>I&#39;ve actually been thinking about this a little more, and it occurred to me that we might be able to borrow Joe Groff&#39;s accessor idea from the property behaviors proposal. As you may recall, accessors are a way to specify a method (or, perhaps, a computed property) that can be implemented by the property to customize the behavior; accessors are implemented in a curly-bracket-enclosed block attached to the property. In property behaviors, they look something like this:<br></p><p>	var behavior getObserver&lt;Value&gt;: Value {<br>		accessor func willGet() {}<br>		accessor func didGet() {}<br>		<br>		var value: Value<br>		<br>		get {<br>			willGet()<br>			let v = value<br>			didGet()<br>			return v<br>		}<br>		set {<br>			value = newValue<br>		}<br>		...<br>	}<br>	<br>	@getObserver var x: Int {<br>		willGet { print(&quot;Getting x&quot;) }<br>	} <br></p><p>Using the same mechanism in enums might remove the redundant boilerplate caused by redeclaring the same methods in every case, and also reduce the appearance that cases are types. Your example might look like:<br></p><p>	enum MyTree {<br>		mutating accessor func insert(value: T)<br>		<br>		case Leaf1(Float, Float) {<br>			insert {<br>				…<br>			}<br>		}<br>		case Parent1(Int, Float) {<br>			insert {<br>				…<br>			}<br>		}<br>		default {<br>			insert {<br>				…<br>			}<br>		}<br>	}<br></p><p>Or, to use my example:<br></p><p>	enum Suit: Int {<br>		accessor var isRed: Bool { get }<br>		accessor var description: String { get }<br>		<br>		case hearts {<br>			description { return &quot;♥️&quot; }<br>			isRed { return true }<br>		}<br>		case spades {<br>			description { return  &quot;♠️&quot; }<br>		}<br>		case diamonds {<br>			description { return  &quot;♦️&quot; }<br>			isRed { return true }<br>		}<br>		case clubs {<br>			description { return  &quot;♣️&quot; }<br>		}<br>		default {<br>			isRed { return false }<br>		}<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
