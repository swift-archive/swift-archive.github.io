<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 30, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jan 29 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It suddenly occurs to me it&#39;s almost the 31st and I haven&#39;t actually<br>&gt; responded to the proposal as a proposal. <br></p><p>Thanks for taking the time to do this, Erica.  I&#39;m going to take issue<br>with some of your feedback below, but please know this is motivated by a<br>desire to make the most of your contribution.  I think your feedback is<br>valuable, but much of the signal is getting lost.<br></p><p>&gt; I heartily endorse a general set of API guidelines and I appreciate<br>&gt; this first approach towards satisfying that goal. I have issues with<br>&gt; two sections.<br>&gt;<br>&gt; First, I&#39;d entirely eliminate the guidance in the &quot;Be Grammatical&quot;<br>&gt; section and move the section with boolean assertions and property<br>&gt; names to Special Instructions.<br></p><p>I *think* I may know why you want to eliminate the first part, but I<br>have no clue why you think it&#39;d be better to move the other part.<br>Statements like these don&#39;t really provide much useful feedback, because<br>we can&#39;t tell what problems you think you&#39;re solving.<br></p><p>&gt; * I disagree with the mutating/non-mutating differentiation. I started<br>&gt; writing about this here before personally abandoning it as too big a<br>&gt; question: Grammatical.md<br>&gt; &lt;https://github.com/erica/SwiftStyle/blob/master/Grammatical.md&gt;. In a<br>&gt; nutshell, side-effects and pure functionality are not considered the<br>&gt; way I&#39;d want them to be and the ed/ing naming is problematic.<br></p><p>I still don&#39;t really understand this objection.  I do believe that<br>generalizing beyond &quot;mutating&quot; to cover &quot;anything with side-effects&quot;<br>would improve the guideline quite a lot.  I don&#39;t understand any of the<br>rest of your beef with this guideline.<br></p><p>&gt; * The protocol question is big and wide as well, and I have written<br>&gt; on-list: it&#39;s not &quot;the role of a protocol to describe implementation<br>&gt; details...Going that way leads you to over-designated hungarian-esque<br>&gt; guidelines that I&#39;d rather keep loose, friendly, and sensible.&quot;<br></p><p>You have written that, but nothing in the guidelines suggests describing<br>implementation details.<br>&gt;<br>&gt; In &quot;Conventions&quot;:<br>&gt;<br>&gt; * I don&#39;t like endorsing that any property could or should not be O(1)<br>&gt; (vs recommending using a function instead)<br></p><p>We don&#39;t do that.  We merely say that if it&#39;s not O(1) it should be<br>documented as such.<br></p><p>&gt; * The case convention for enumerations remains conventional without a<br>&gt; guiding principle. I&#39;d rather have a firm &quot;use lower camel case for<br>&gt; members&quot; that I can complain about (because it feels to me like &quot;pick<br>&gt; a type layout for this memory&quot;, so upper camel) rather than &quot;use upper<br>&gt; camel and let everyone on the Swift team complain about it&quot; once and<br>&gt; for all.  <br></p><p>Understood.<br></p><p>* With regard to argument labels, I&#39;d like to add two rules,<br>&gt; as detailed in-thread and written about here: ArgumentLabels.md<br>&gt; &lt;https://github.com/erica/SwiftStyle/blob/master/ArgumentLabels.md&gt;<br>&gt;<br>&gt; Differentiate related calls whose implementations are distinguished by<br>&gt; their parameters, as you would with initializers, using first<br>&gt; parameter labels. Instead of loginWithUserName(&quot;blah&quot;, password:<br>&gt; &quot;...&quot;) and loginWithCredential(myCredential), prefer:<br>&gt;<br>&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt; login(credential: myCredential)<br>&gt; This approach emphasizes the action being taken (login) and demotes<br>&gt; the actual arguments involved in performing that action. In doing so,<br>&gt; they require labels to differentiate which implementation of that<br>&gt; action is to be used.<br>&gt;<br>&gt; and<br>&gt;<br>&gt; Prefer external names for the first parameter when the natural<br>&gt; semantic relationship between the parameters is stronger than their<br>&gt; relation to the operation.<br></p><p>That rule doesn&#39;t work for any one-parameter methods, unless you think<br>they should never have first argument labels.<br></p><p>&gt; For example, the following calls use labels for the first parameter:<br>&gt;<br>&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt; moveTo(x: 50.0, y: 30.0)<br>&gt; constructColor(red: 0.2, green: 0.3, blue: 0.1)<br>&gt;<br>&gt; This example is contrary to Swift&#39;s normal naming scheme which<br>&gt; integrates the first argument into the function or method name, for<br>&gt; example:<br>&gt;<br>&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt; moveToX(50.0, y: 30.0)<br>&gt; constructColorWithRed(0.2, green: 0.3, blue: 0.1)<br>&gt;<br>&gt; The relationships between (x, y), (username, password), and (red,<br>&gt; green, blue) are strong enough to allow you to make a judgement call<br>&gt; to employ an external label.<br>&gt;<br>&gt; The following shows a counter-example.<br>&gt;<br>&gt; addLineTo(p1, withWidth: 25.0)<br>&gt;<br>&gt; In this call, the point and width have no natural<br>&gt; relationship. There&#39;s no reason to create an external label for the<br>&gt; first argument so this example follows the standard Swift call<br>&gt; approach.<br></p><p>Thanks again for your feedback, Erica.  If you&#39;d care to clarify any of<br>the points above, that&#39;d be extra awesome.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 8:49 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jan 29 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; It suddenly occurs to me it&#39;s almost the 31st and I haven&#39;t actually<br>&gt;&gt; responded to the proposal as a proposal. <br>&gt; <br>&gt; Thanks for taking the time to do this, Erica.  I&#39;m going to take issue<br>&gt; with some of your feedback below, but please know this is motivated by a<br>&gt; desire to make the most of your contribution.  I think your feedback is<br>&gt; valuable, but much of the signal is getting lost.<br></p><p>No worries. &quot;Low SNR&quot; is my street name.<br></p><p>&gt;&gt; First, I&#39;d entirely eliminate the guidance in the &quot;Be Grammatical&quot;<br>&gt;&gt; section and move the section with boolean assertions and property<br>&gt;&gt; names to Special Instructions.<br>&gt; <br>&gt; I *think* I may know why you want to eliminate the first part, but I<br>&gt; have no clue why you think it&#39;d be better to move the other part.<br>&gt; Statements like these don&#39;t really provide much useful feedback, because<br>&gt; we can&#39;t tell what problems you think you&#39;re solving.<br></p><p>I consider the great Hungarian war settled and am happy with its outcome<br>as discussed in the other email.<br></p><p>&gt;&gt; * The protocol question is big and wide as well, and I have written<br>&gt;&gt; on-list: it&#39;s not &quot;the role of a protocol to describe implementation<br>&gt;&gt; details...Going that way leads you to over-designated hungarian-esque<br>&gt;&gt; guidelines that I&#39;d rather keep loose, friendly, and sensible.&quot;<br>&gt; <br>&gt; You have written that, but nothing in the guidelines suggests describing<br>&gt; implementation details.<br></p><p>I think this mostly got settled under separate thread. Pulling stuff together.<br></p><p>The guidance says: &quot;Protocols that describe what something is should read as nouns (e.g. ). <br>Protocols that describe a capability should be named using the suffixes ,<br>ible , or ing (e.g. Equatable , ProgressReporting ).&quot;<br></p><p>Nitpickage: <br></p><p>&quot;should be named using -ble or -ing suffixes (e.g. Equatable, ProgressReporting)&quot;. (no &quot;a/i&quot; mismatch, easier to read, http://thespellingblog.blogspot.com/2008/12/spelling-words-ending-in-able-and-ible.html)<br></p><p>Substance, mostly picking up from stuff you&#39;ve said in response:<br></p><p>Protocols should express well-defined, testable semantics. Their names should express those<br>semantics in a clear and succinct matter., specifically by naming what a conforming type is (use nouns), <br>does (use -ing suffixes), or a capacity it provides (use -ble suffixes). For example, a protocol can be a `Collection` <br>or `DataSource`. It can do `ProgressReporting` or `DownloadProcessing`. It can provide the capability for being <br>`Equatable` or `IntegerInitializable`.<br></p><p>Additionalage:<br></p><p>Matthew J and I add: https://github.com/apple/swift-evolution/pull/60 &lt;https://github.com/apple/swift-evolution/pull/60&gt; to introduce precise conventional<br>meanings for conversion suffixes. (Createable, Convertible, Representable), which I&#39;d love for you to consider<br>under the SE-0023 API Design Guidelines review. I think it&#39;s applicable.<br></p><p>&gt;&gt; <br>&gt; * With regard to argument labels, I&#39;d like to add two rules,<br>&gt;&gt; as detailed in-thread and written about here: ArgumentLabels.md<br>&gt;&gt; &lt;https://github.com/erica/SwiftStyle/blob/master/ArgumentLabels.md&gt;<br>&gt;&gt; <br>&gt;&gt; Differentiate related calls whose implementations are distinguished by<br>&gt;&gt; their parameters, as you would with initializers, using first<br>&gt;&gt; parameter labels. Instead of loginWithUserName(&quot;blah&quot;, password:<br>&gt;&gt; &quot;...&quot;) and loginWithCredential(myCredential), prefer:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; login(credential: myCredential)<br>&gt;&gt; This approach emphasizes the action being taken (login) and demotes<br>&gt;&gt; the actual arguments involved in performing that action. In doing so,<br>&gt;&gt; they require labels to differentiate which implementation of that<br>&gt;&gt; action is to be used.<br>&gt;&gt; <br>&gt;&gt; and<br>&gt;&gt; <br>&gt;&gt; Prefer external names for the first parameter when the natural<br>&gt;&gt; semantic relationship between the parameters is stronger than their<br>&gt;&gt; relation to the operation.<br>&gt; <br>&gt; That rule doesn&#39;t work for any one-parameter methods, unless you think<br>&gt; they should never have first argument labels.<br></p><p>The rule only applies to tightly coupled arguments so by definition there have to be at least 2 of them<br>for this rule to make any sense.<br></p><p>&gt; <br>&gt;&gt; For example, the following calls use labels for the first parameter:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveTo(x: 50.0, y: 30.0)<br>&gt;&gt; constructColor(red: 0.2, green: 0.3, blue: 0.1)<br>&gt;&gt; <br>&gt;&gt; This example is contrary to Swift&#39;s normal naming scheme which<br>&gt;&gt; integrates the first argument into the function or method name, for<br>&gt;&gt; example:<br>&gt;&gt; <br>&gt;&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveToX(50.0, y: 30.0)<br>&gt;&gt; constructColorWithRed(0.2, green: 0.3, blue: 0.1)<br>&gt;&gt; <br>&gt;&gt; The relationships between (x, y), (username, password), and (red,<br>&gt;&gt; green, blue) are strong enough to allow you to make a judgement call<br>&gt;&gt; to employ an external label.<br>&gt;&gt; <br>&gt;&gt; The following shows a counter-example.<br>&gt;&gt; <br>&gt;&gt; addLineTo(p1, withWidth: 25.0)<br>&gt;&gt; <br>&gt;&gt; In this call, the point and width have no natural<br>&gt;&gt; relationship. There&#39;s no reason to create an external label for the<br>&gt;&gt; first argument so this example follows the standard Swift call<br>&gt;&gt; approach.<br>&gt; <br>&gt; Thanks again for your feedback, Erica.  If you&#39;d care to clarify any of<br>&gt; the points above, that&#39;d be extra awesome.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/aa426017/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
