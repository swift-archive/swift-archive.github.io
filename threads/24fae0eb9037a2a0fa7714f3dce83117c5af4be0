<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>Would it make sense to abstract the hash functions into a protocol?<br></p><p>The limit of the Hashable protocol is that it forces a type to commit to a specific ‘canonical’ hash implementation, while there might be more efficient implementations depending on the application.<br></p><p>To truly support composition patterns, it would seem appropriate for the standard library to support decoupling the hashing functionality from the type of the container element.<br></p><p>E.g.<br></p><p>protocol Hash {<br>    typealias Element<br></p><p>    static func equal(lhs: Element, _ rhs: Element) -&gt; Bool<br>    static func hashValue(x: Element) -&gt; Int<br>}<br></p><p>// now we can define a generic box<br>struct HashableBox&lt;T, H: Hash where H.Element == T&gt; : Hashable {<br>    let value: T<br>    <br>    var hashValue: Int {<br>        return H.hashValue(value)<br>    }<br>}<br>func ==&lt;T, H&gt;(lhs: HashableBox&lt;T, H&gt;, rhs: HashableBox&lt;T, H&gt;) -&gt; Bool {<br>    return H.equal(lhs.value, rhs.value)<br>}<br></p><p>// now we can define a wrapper around Set, using an explicit Hash<br>struct CustomHashSet&lt;Element, H: Hash where H.Element == Element&gt; {<br>    // this is an implementation detail; if CustomHashSet was part of the standard library,<br>    // the .gyb could produce a more efficient implementation<br>    private var set: Set&lt;HashableBox&lt;Element, H&gt;&gt;<br>    <br>    init() {}<br>    init&lt;S: SequenceType where S.Generator.Element == Element&gt;(_ sequence: S) {<br>        set = Set(sequence.lazy.map { HashableBox&lt;Element, H&gt;(value: $0) })<br>    }<br>    // etc.<br>}<br></p><p><br>// Example usage<br>struct NaiveCollectionHash&lt;C: CollectionType where C.Generator.Element: Hashable&gt;: Hash {<br>    typealias Element = C<br>    <br>    static func equal(lhs: Element, _ rhs: Element) -&gt; Bool {<br>        guard lhs.count == rhs.count else { return false }<br>        return zip(lhs, rhs).lazy.reduce(true) { $0 &amp;&amp; ($1.0 == $1.1) }<br>    }<br>    static func hashValue(x: Element) -&gt; Int {<br>        return x.reduce(0) { $0 ^ $1.hashValue }    // a bad hash just as an example<br>    }<br>}<br></p><p>let arrays = [[1],[2]]<br></p><p>// This doesn&#39;t work because Array is not Hashable (yet)<br>var s1 = Set(arrays) // Error<br></p><p>// This works but we need to explicitly specify all the types<br>var s2 = CustomHashSet&lt;Array&lt;Int&gt;, NaiveCollectionHash&lt;Array&lt;Int&gt;&gt;&gt;(arrays) // ok<br></p><p>// Generic typealiases would help reducing the boilerplate, e.g.<br>// it would be useful if we could do<br>typealias NaiveHashSet&lt;T&gt; = CustomHashSet&lt;T, NaiveCollectionHash&lt;T&gt;&gt;    // Error<br>// then Swift&#39;s type inference should be able to automatically handle this:<br>var s3 = NaiveHashSet(arrays)   // Error<br></p><p><br>Nicola<br></p><p>&gt; Cc:swift-evolution&lt;swift-evolution at swift.org&gt;<br>&gt; Subject:[swift-evolution] Custom equality/hash for Sets<br>&gt; Date:19 February 2016 at 05:04:51 GMT+1<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt; On Feb 18, 2016, at 16:09 , Dave Abrahams via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; on Thu Feb 18 2016, Jacob Bandes-Storch&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; &gt; Would it make sense for the standard library Set to provide variants (or<br>&gt; &gt; &gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt; &gt; &gt; implementations at init time (functions taking in Elements), rather than<br>&gt; &gt; &gt; relying on Hashable/Comparable protocols?<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt; &gt; &gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt; &gt; &gt; creating some sort of wrapper object.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; This particular case would be analogous to using NSHashTable with<br>&gt; &gt; &gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt; &gt; &gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt; &gt; &gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Similarly, C++&#39;s unordered_map<br>&gt; &gt; &gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt;and friends have<br>&gt; &gt; &gt; template parameters specifying the hash function and equality comparator,<br>&gt; &gt; &gt; which use std::hash and == by default.<br>&gt; &gt; <br>&gt; &gt; It might make sense.How bad is the wrapper solution for user code?<br>&gt; &gt; struct CustomHashableFoo: Hashable {<br>&gt; &gt; var value: Foo<br>&gt; &gt; func hash() -&gt;Int {<br>&gt; &gt; // custom hash function here<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt; func ==(a: CustomHashableWrapped, b: CustomHashableWrapped) {<br>&gt; &gt; // custom == here<br>&gt; &gt; }<br>&gt; Really not that bad, although you do have to get &#39;value&#39; in and out of the box. It&#39;s also not reusable code—you have to rewrite the box for every type.<br>&gt; <br>&gt; I&#39;d say you usuallydon&#39;twant to allow custom hash/== closures because (a) then you have to store them somewhere, and (b) the compiler won&#39;t usually be able to inline them away. You also end up with a Set&lt;Foo&gt;that doesn&#39;t behave like a normal Set&lt;Foo&gt;—maybe you can insert equal-but-not-identical elements—which is bad if anyone&#39;s relying on normal Set-like guarantees.<br>&gt; <br>&gt; -1 from me until we can put functions in generics, if ever.<br>&gt; <br>&gt; Jordan_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/24fa4be0/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
