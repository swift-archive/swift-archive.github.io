<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Make unsafe pointer nullability explicit using Optional&quot; begins now and runs through March 29th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>	https://lists.swift.org/mailman/listinfo/swift-evolution<br>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p><br>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/08e0e501c1b7f3d2ee6d0ed52f560702?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Richard Ross</string> &lt;richardross at fb.com&gt;<p>March 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>Currently, I&#39;m -0.8 on this, for a few reasons.<br></p><p>Firstly, UnsafePointers are explicitly &#39;Unsafe&#39; already. Making them more &#39;safe&#39; could encourage more widespread usage of them, when in reality they&#39;re not necessary for 90% of cases.<br></p><p>Secondly, we will run into the IOU situation for C (and hopefully eventually C++) APIs, that now need to be audited and updated to reflect nullability status, which I&#39;d wager that most existing headers *won&#39;t* be audited, especially on linux.<br></p><p>Thirdly, as mentioned in the prior discussion it&#39;s certainly possible on some platforms to remap the memory page at address 0x0 and make it usable to userland code. Even if we don&#39;t currently support any such platforms, we shouldn&#39;t lock ourselves into a situation where we need to be able to do this.<br></p><p>Finally, having nullable UnsafePointers currently is the only way from swift code to convert an UnsafePointer to an Int of its raw address, short of using another level of indirection:<br></p><p>let rawAddress: Int = UnsafePointer&lt;UInt8&gt;(nil).distanceTo(myPointer)<br></p><p>Unless the other proposal that&#39;s in the works to get the raw address of an UnsafePointer goes through (which I&#39;m a supporter of), this would remove a very important functionality from the swift language, especially when dealing with lower level APIs that can take pointers as integers.<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p><br>I think the goal of being able to write safer code is a noble one, and one we should strive for overall in the language. However, I don&#39;t believe that this is enough of an approach, nor is it inherently &#39;safer&#39; (as nothing stops you from creating another invalid pointer that crashes rather than just NULL). Unless we plan on having some way to confirm that a pointer is, in fact, valid, I think we should leave UnsafePointer in its &#39;unsafe&#39; state.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>I actually think it does. This will provide a swift-ier interface with raw pointers (and causing less confusion amongst beginners (who probably shouldn&#39;t be using UnsafePointer, but still) and improving API contracts). Again, however, UnsafePointer, while powerful, is rarely the proper tool for the job, and I think should be left in its current state - powerful, but difficult to use, to prevent a foot-gun scenario like we see in C++ and references (ask any C++ beginner about the lifetime of a reference...)<br></p><p>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;m actually unsure of any other languages that have explicit nullability on a raw pointer type. (Maybe rust has it? I&#39;m not very familiar with rust).<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve been following the proposal since day 1, and have put a lot of thought into it (one of my current projects uses UnsafePointer quite a bit). I&#39;d like to think that I did a rather in-depth review of the subject.<br></p><p>If you&#39;ve made it this far, thanks for reading my thesis on UnsafePointer :)<br>--<br>Richard<br></p><p>&gt; On Mar 24, 2016, at 11:00 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Make unsafe pointer nullability explicit using Optional&quot; begins now and runs through March 29th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://urldefense.proofpoint.com/v2/url?u=https-3A__lists.swift.org_mailman_listinfo_swift-2Devolution&amp;d=CwIGaQ&amp;c=5VD0RTtNlTh3ycd41b3MUw&amp;r=Ezje1IF3xGXfUMfsj4fBc7oM7BcJys1dhQ6psfXzLMU&amp;m=_MgWpo4MYLScsGzB9CqrI-eCyzjjkWNyv8hjBeDANw0&amp;s=HZtE3Eh63CLwxWA4MExIZyp1Dn7CsH2Te9eRrsFZNfE&amp;e= <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://urldefense.proofpoint.com/v2/url?u=https-3A__lists.swift.org_mailman_listinfo_swift-2Devolution&amp;d=CwIGaQ&amp;c=5VD0RTtNlTh3ycd41b3MUw&amp;r=Ezje1IF3xGXfUMfsj4fBc7oM7BcJys1dhQ6psfXzLMU&amp;m=_MgWpo4MYLScsGzB9CqrI-eCyzjjkWNyv8hjBeDANw0&amp;s=HZtE3Eh63CLwxWA4MExIZyp1Dn7CsH2Te9eRrsFZNfE&amp;e=<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Thirdly, as mentioned in the prior discussion it&#39;s certainly possible on some platforms to remap the memory page at address 0x0 and make it usable to userland code. Even if we don&#39;t currently support any such platforms, we shouldn&#39;t lock ourselves into a situation where we need to be able to do this.<br></p><p>I don&#39;t think this is mentioned in the proposal itself, but it came up in the discussion.<br></p><p>The C standard requires that there be a &quot;null&quot; pointer address which can be stored into any pointer but which can never actually be valid. It does *not* require that the null pointer address be 0x0. Most platforms do use 0x0, and clang doesn&#39;t support a non-0x0 null pointer, but this is not required by the C standard.<br></p><p>I believe Swift should mimic this behavior. On platforms where 0x0 is a valid address, Swift should not use 0x0 as the null pointer, but rather use some other address which isn&#39;t valid (perhaps ~0x0). Pointer types should treat this address as an unused value, which the enum machinery will then exploit to represent Optional.none.<br></p><p>For now, this design should probably just be documented somewhere, perhaps in a porting guide; actually implementing it is not really a priority.<br></p><p>&gt; Finally, having nullable UnsafePointers currently is the only way from swift code to convert an UnsafePointer to an Int of its raw address, short of using another level of indirection:<br>&gt; <br>&gt; let rawAddress: Int = UnsafePointer&lt;UInt8&gt;(nil).distanceTo(myPointer)<br></p><p>Given what I discussed about `nil` not necessarily being 0x0, this construct is not necessarily valid anyway.<br></p><p>Besides, we *do* have a construct which converts between pointers and integers without any semantic confusion about `nil`—and it even expresses what it&#39;s doing more clearly than your `distanceTo` trick:<br></p><p>	unsafeBitCast(pointer, Int.self)<br></p><p>&gt; I&#39;m actually unsure of any other languages that have explicit nullability on a raw pointer type. (Maybe rust has it? I&#39;m not very familiar with rust).<br></p><p>Apple variants of C, C++, and Objective-C now do. Actually, I believe they had some nullability control even before the recent keywords through __attribute__.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 3:50 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Thirdly, as mentioned in the prior discussion it&#39;s certainly possible on some platforms to remap the memory page at address 0x0 and make it usable to userland code. Even if we don&#39;t currently support any such platforms, we shouldn&#39;t lock ourselves into a situation where we need to be able to do this.<br>&gt; <br>&gt; I don&#39;t think this is mentioned in the proposal itself, but it came up in the discussion.<br>&gt; <br>&gt; The C standard requires that there be a &quot;null&quot; pointer address which can be stored into any pointer but which can never actually be valid. It does *not* require that the null pointer address be 0x0. Most platforms do use 0x0, and clang doesn&#39;t support a non-0x0 null pointer, but this is not required by the C standard.<br>&gt; <br>&gt; I believe Swift should mimic this behavior. On platforms where 0x0 is a valid address, Swift should not use 0x0 as the null pointer, but rather use some other address which isn&#39;t valid (perhaps ~0x0). Pointer types should treat this address as an unused value, which the enum machinery will then exploit to represent Optional.none.<br></p><p>It is already a known constraint that the representation of an imported type (ignoring bridging conversions) has to match up with the representation of the original C type.  If we supported a target with a non-zero null value, we would have to ensure that Optionals of the appropriate pointer type were represented that way.<br></p><p>I&#39;d actually be much more concerned about the pervasive assumptions about pointer representation in Clang and LLVM than I would be with Swift.<br></p><p>Now, it would probably be very annoying to support a platform where different pointer types had different null values, but the last of those died awhile ago, I believe.<br></p><p>All that said, I have negligible interest in putting any effort into supporting the ability to write to address zero in Swift.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 24, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mar 24, 2016, at 7:28 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I&#39;d actually be much more concerned about the pervasive assumptions about pointer representation in Clang and LLVM than I would be with Swift.<br>&gt; <br>&gt; Now, it would probably be very annoying to support a platform where different pointer types had different null values, but the last of those died awhile ago, I believe.<br></p><p>The last significant one IIRC was Itanium, in the case of C++ member pointers (themselves an odd beast), which had a different representation than data pointers (-1 is null).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 9:43 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On Mar 24, 2016, at 7:28 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I&#39;d actually be much more concerned about the pervasive assumptions about pointer representation in Clang and LLVM than I would be with Swift.<br>&gt;&gt; <br>&gt;&gt; Now, it would probably be very annoying to support a platform where different pointer types had different null values, but the last of those died awhile ago, I believe.<br>&gt; <br>&gt; The last significant one IIRC was Itanium, in the case of C++ member pointers (themselves an odd beast), which had a different representation than data pointers (-1 is null).<br></p><p>That&#39;s not really target-specific; it&#39;s equally true for everybody using that C++ ABI, including us.  But member pointers are a fundamentally different concept from C pointers, despite the name.<br></p><p>John.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>March 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Le 24 mars 2016 à 18:50, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; Thirdly, as mentioned in the prior discussion it&#39;s certainly possible on some platforms to remap the memory page at address 0x0 and make it usable to userland code. Even if we don&#39;t currently support any such platforms, we shouldn&#39;t lock ourselves into a situation where we need to be able to do this.<br>&gt; <br>&gt; I don&#39;t think this is mentioned in the proposal itself, but it came up in the discussion.<br>&gt; <br>&gt; The C standard requires that there be a &quot;null&quot; pointer address which can be stored into any pointer but which can never actually be valid. It does *not* require that the null pointer address be 0x0. Most platforms do use 0x0, and clang doesn&#39;t support a non-0x0 null pointer, but this is not required by the C standard.<br>&gt; <br>&gt; I believe Swift should mimic this behavior. On platforms where 0x0 is a valid address, Swift should not use 0x0 as the null pointer, but rather use some other address which isn&#39;t valid (perhaps ~0x0). Pointer types should treat this address as an unused value, which the enum machinery will then exploit to represent Optional.none.<br></p><p>In the low level world, there is no such thing as an invalid address; both 0x0 and ~0x0 are perfectly valid byte pointers. So using something else than 0x0 for Swift invalid pointer just shuffle the problem around.<br></p><p>Dany<br></p><p>&gt; For now, this design should probably just be documented somewhere, perhaps in a porting guide; actually implementing it is not really a priority.<br>&gt; <br>&gt;&gt; Finally, having nullable UnsafePointers currently is the only way from swift code to convert an UnsafePointer to an Int of its raw address, short of using another level of indirection:<br>&gt;&gt; <br>&gt;&gt; let rawAddress: Int = UnsafePointer&lt;UInt8&gt;(nil).distanceTo(myPointer)<br>&gt; <br>&gt; Given what I discussed about `nil` not necessarily being 0x0, this construct is not necessarily valid anyway.<br>&gt; <br>&gt; Besides, we *do* have a construct which converts between pointers and integers without any semantic confusion about `nil`—and it even expresses what it&#39;s doing more clearly than your `distanceTo` trick:<br>&gt; <br>&gt; 	unsafeBitCast(pointer, Int.self)<br>&gt; <br>&gt;&gt; I&#39;m actually unsure of any other languages that have explicit nullability on a raw pointer type. (Maybe rust has it? I&#39;m not very familiar with rust).<br>&gt; <br>&gt; Apple variants of C, C++, and Objective-C now do. Actually, I believe they had some nullability control even before the recent keywords through __attribute__.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; In the low level world, there is no such thing as an invalid address; both 0x0 and ~0x0 are perfectly valid byte pointers. So using something else than 0x0 for Swift invalid pointer just shuffle the problem around.<br></p><p>Let me state it this way: You cannot write a fully-conforming C compiler for a platform which does not have some way to represent an invalid pointer. However C does it, Swift can do the same thing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>March 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 25 Mar 2016, at 23:00, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; In the low level world, there is no such thing as an invalid address; both 0x0 and ~0x0 are perfectly valid byte pointers. So using something else than 0x0 for Swift invalid pointer just shuffle the problem around.<br>&gt; <br>&gt; Let me state it this way: You cannot write a fully-conforming C compiler for a platform which does not have some way to represent an invalid pointer.<br></p><p>This is not true.<br></p><p>In both C99 and C11, the result of dereferencing an invalid pointer (of which the null pointer is one example) is undefined behaviour. This means it is perfectly fine for the null pointer to be represented by a bit pattern that is also a valid address and for the compiler not to bother generating a check that the pointer is not null. <br></p><p>&gt; However C does it, Swift can do the same thing.<br></p><p>C does it by sweeping the problem under the carpet of undefined behaviour.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 3:11 , Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Mar 2016, at 23:00, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; In the low level world, there is no such thing as an invalid address; both 0x0 and ~0x0 are perfectly valid byte pointers. So using something else than 0x0 for Swift invalid pointer just shuffle the problem around.<br>&gt;&gt; <br>&gt;&gt; Let me state it this way: You cannot write a fully-conforming C compiler for a platform which does not have some way to represent an invalid pointer.<br>&gt; <br>&gt; This is not true.<br>&gt; <br>&gt; In both C99 and C11, the result of dereferencing an invalid pointer (of which the null pointer is one example) is undefined behaviour. This means it is perfectly fine for the null pointer to be represented by a bit pattern that is also a valid address and for the compiler not to bother generating a check that the pointer is not null.<br></p><p>Clever! I worked through this for the benefit of the list:<br></p><p>C11 6.3.2.3p3: If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.<br></p><p>C11 6.3.2.3p4: Conversion of a null pointer to another pointer type yields a null pointer of that type. Any two null pointers shall compare equal.<br></p><p>So there must be at least one bit pattern recognizable as a null pointer…<br></p><p>C11 6.5.3.2p1: The operand of the unary &amp; operator shall be either a function designator, the result of a [] or unary * operator, or an lvalue that designates an object that is not a bit-field and is not declared with the &#39;register&#39; storage-class specifier.<br></p><p>C11 6.5.3.2p3: […] Otherwise [when not using [] or *], the result is a pointer to the object or function designated by its operand.<br></p><p>…and it must not have the same representation as a bit pattern of an object or function declared in C…<br></p><p>C11 6.5.3.2p4: If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.<br></p><p>C11 6.3.2.1p1: An lvalue is an expression (with an object type other than &#39;void&#39;) that potentially designates an object; if an lvalue does not designate an object when it is evaluated, the behavior is undefined.<br></p><p>…but as you say there&#39;s nothing stopping a particular compiler from giving the dereference defined behavior.<br></p><p>However, what this can&#39;t do is remove its use as a sentinel value. For example:<br></p><p>C11 7.24.5.1p3: The &#39;memchr&#39; function returns a pointer to the located character, or a null pointer if the character does not occur in the object.<br></p><p>So ultimately I see Swift as being just as compatible as C in this case. Both languages designate a certain bit pattern for use as a placeholder. Swift is a little more aggressive in keeping you from loading from it, but on such a platform the standard library could certainly expose a &quot;safely load from this optional pointer&quot; builtin, which could then perhaps be exposed as a member on &quot;Optional where Wrapped: _Pointer&quot;. (I&#39;m not sure if that&#39;s the best way to do it, but it&#39;s an idea.)<br></p><p>As Chris has said previously, both Clang and LLVM themselves have a lot of assumptions about what can and can&#39;t be done with a null pointer, so porting to any such platform would include a fair amount of work simply extricating that logic and placing it behind a flag.<br></p><p>Best,<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/5605b769/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 3:11 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On 25 Mar 2016, at 23:00, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; In the low level world, there is no such thing as an invalid address; both 0x0 and ~0x0 are perfectly valid byte pointers. So using something else than 0x0 for Swift invalid pointer just shuffle the problem around.<br>&gt;&gt; <br>&gt;&gt; Let me state it this way: You cannot write a fully-conforming C compiler for a platform which does not have some way to represent an invalid pointer.<br>&gt; <br>&gt; This is not true.<br>&gt; <br>&gt; In both C99 and C11, the result of dereferencing an invalid pointer (of which the null pointer is one example) is undefined behaviour. This means it is perfectly fine for the null pointer to be represented by a bit pattern that is also a valid address and for the compiler not to bother generating a check that the pointer is not null. <br></p><p>This is not correct.  Two pointers are not permitted to compare equal when one operand is a null pointer and the other is a pointer to an object.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; However C does it, Swift can do the same thing.<br>&gt; <br>&gt; C does it by sweeping the problem under the carpet of undefined behaviour.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;         * What is your evaluation of the proposal?<br></p><p><br>&gt; Good idea, much more logical<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br></p><p><br>&gt; Yes, it is an anomaly<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br></p><p><br>&gt; Yes, optional a are used to express nullability<br></p><p><br>&gt;         * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br></p><p><br>&gt; No<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; Followed discussions on swift-evolution<br></p><p><br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/d91ae883/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I&#39;m in favor. The ability of UnsafePointer to represent nil pointers has always been an odd duck, introducing an unmarked (and undocumented!) implicit trap in `memory` (now `pointee`), preventing the use of Optional constructs, and making Swift pointer types less expressive than C, which is just *wrong*. Making nullability explicit is a good move.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The nullability specifiers introduced recently in clang have markedly removed my Objective-C code, both by better documenting system APIs and by forcing me to improve my own calls.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal, participated in discussion.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 25, 2016 at 04:00:00pm</p></header><div class="content"><p>You said it better than I could. <br></p><p>+1 on the proposal. <br></p><p><br>Russ<br></p><p>On Mar 24, 2016, at 3:56 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt; <br>&gt; I&#39;m in favor. The ability of UnsafePointer to represent nil pointers has always been an odd duck, introducing an unmarked (and undocumented!) implicit trap in `memory` (now `pointee`), preventing the use of Optional constructs, and making Swift pointer types less expressive than C, which is just *wrong*. Making nullability explicit is a good move.<br>&gt; <br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt;    * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; The nullability specifiers introduced recently in clang have markedly removed my Objective-C code, both by better documenting system APIs and by forcing me to improve my own calls.<br>&gt; <br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Read the proposal, participated in discussion.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1.  This is a very nice improvement for code that needs to work directly with pointers.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much so.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>It aligns well with languages that improve safety by explicitly modeling null. <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Followed the discussion and read the proposal.  I was very pleased to see Jordan propose this.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
