<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I think that Swift could use the &#39;double modulo&#39; operator which is for<br>example in CoffeeScript (some discussion can be found here<br>https://github.com/jashkenas/coffeescript/issues/1971).<br></p><p>This operator, unlike normal modulo, takes sign from the divisor, not the<br>dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br></p><p>In practice, this operator is useful for &#39;cyclical&#39; indexing. For example,<br>it would be useful for calculating the real index into a collection when we<br>are using an index outside of the range of valid indices and could be used<br>to index into a collection using a negative index à la Python and Ruby<br>(where [1,2,3,4][-1] == 4).<br></p><p><br>The implementation would probably be something along these lines:<br></p><p>infix operator %% {<br>  associativity left<br>  precedence 150<br>}<br></p><p>func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>  return (lhs % rhs + rhs) % rhs<br>}<br></p><p>If accepted, this could be later incorporated into a method or operator<br>that works directly with collections using their count property.<br>Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br></p><p>Ideas, suggestions?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/2e1f3437/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 21, 2016 at 05:00:00pm</p></header><div class="content"><p>Adam, I think this is a very particular case and not something that needs<br>to be added to the language. As you pointed out this already can be<br>implemented using resources already available in the language when needed.<br></p><p><br></p><p>On 21 May 2016 at 17:22, Adam Nemecek via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for<br>&gt; example in CoffeeScript (some discussion can be found here<br>&gt; https://github.com/jashkenas/coffeescript/issues/1971).<br>&gt;<br>&gt; This operator, unlike normal modulo, takes sign from the divisor, not the<br>&gt; dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt;<br>&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For example,<br>&gt; it would be useful for calculating the real index into a collection when we<br>&gt; are using an index outside of the range of valid indices and could be used<br>&gt; to index into a collection using a negative index à la Python and Ruby<br>&gt; (where [1,2,3,4][-1] == 4).<br>&gt;<br>&gt;<br>&gt; The implementation would probably be something along these lines:<br>&gt;<br>&gt; infix operator %% {<br>&gt;   associativity left<br>&gt;   precedence 150<br>&gt; }<br>&gt;<br>&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt;   return (lhs % rhs + rhs) % rhs<br>&gt; }<br>&gt;<br>&gt; If accepted, this could be later incorporated into a method or operator<br>&gt; that works directly with collections using their count property.<br>&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt;<br>&gt; Ideas, suggestions?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/5cfa5317/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I think this is a very particular case<br></p><p>I disagree. Swift has the concept of a range all over the place and this is<br>a fundamental range operation.<br></p><p>&gt;  As you pointed out this already can be implemented using resources<br>already available in the language when needed.<br></p><p>Right. A lot of things in the standard library can be implemented using<br>resources already available, it&#39;s about the ergonomics.<br></p><p><br></p><p>On Sat, May 21, 2016 at 1:44 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>&gt; Adam, I think this is a very particular case and not something that needs<br>&gt; to be added to the language. As you pointed out this already can be<br>&gt; implemented using resources already available in the language when needed.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 21 May 2016 at 17:22, Adam Nemecek via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for<br>&gt;&gt; example in CoffeeScript (some discussion can be found here<br>&gt;&gt; https://github.com/jashkenas/coffeescript/issues/1971).<br>&gt;&gt;<br>&gt;&gt; This operator, unlike normal modulo, takes sign from the divisor, not the<br>&gt;&gt; dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt;&gt;<br>&gt;&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For<br>&gt;&gt; example, it would be useful for calculating the real index into a<br>&gt;&gt; collection when we are using an index outside of the range of valid indices<br>&gt;&gt; and could be used to index into a collection using a negative index à la<br>&gt;&gt; Python and Ruby (where [1,2,3,4][-1] == 4).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The implementation would probably be something along these lines:<br>&gt;&gt;<br>&gt;&gt; infix operator %% {<br>&gt;&gt;   associativity left<br>&gt;&gt;   precedence 150<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt;&gt;   return (lhs % rhs + rhs) % rhs<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; If accepted, this could be later incorporated into a method or operator<br>&gt;&gt; that works directly with collections using their count property.<br>&gt;&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt;&gt;<br>&gt;&gt; Ideas, suggestions?<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/4550d9c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 21, 2016 at 06:00:00pm</p></header><div class="content"><p>Adam, there is no need for an operator to compute the real index using<br>a negative index. You can simply use arr.endIndex.advancedBy(-1) for<br>that or, in this particular case, arr.endIndex.predecessor(). Right<br>now this is the standard, although I&#39;&#39;d rather use int indices<br>directly.<br></p><p>On 21 May 2016 at 17:56, Adam Nemecek &lt;adamnemecek at gmail.com&gt; wrote:<br>&gt;&gt; I think this is a very particular case<br>&gt;<br>&gt; I disagree. Swift has the concept of a range all over the place and this is<br>&gt; a fundamental range operation.<br>&gt;<br>&gt;&gt;  As you pointed out this already can be implemented using resources<br>&gt;&gt; already available in the language when needed.<br>&gt;<br>&gt; Right. A lot of things in the standard library can be implemented using<br>&gt; resources already available, it&#39;s about the ergonomics.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, May 21, 2016 at 1:44 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Adam, I think this is a very particular case and not something that needs<br>&gt;&gt; to be added to the language. As you pointed out this already can be<br>&gt;&gt; implemented using resources already available in the language when needed.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 21 May 2016 at 17:22, Adam Nemecek via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for<br>&gt;&gt;&gt; example in CoffeeScript (some discussion can be found here<br>&gt;&gt;&gt; https://github.com/jashkenas/coffeescript/issues/1971).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This operator, unlike normal modulo, takes sign from the divisor, not the<br>&gt;&gt;&gt; dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For<br>&gt;&gt;&gt; example, it would be useful for calculating the real index into a collection<br>&gt;&gt;&gt; when we are using an index outside of the range of valid indices and could<br>&gt;&gt;&gt; be used to index into a collection using a negative index à la Python and<br>&gt;&gt;&gt; Ruby (where [1,2,3,4][-1] == 4).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The implementation would probably be something along these lines:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; infix operator %% {<br>&gt;&gt;&gt;   associativity left<br>&gt;&gt;&gt;   precedence 150<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt;&gt;&gt;   return (lhs % rhs + rhs) % rhs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If accepted, this could be later incorporated into a method or operator<br>&gt;&gt;&gt; that works directly with collections using their count property.<br>&gt;&gt;&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ideas, suggestions?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>It&#39;s a fundamental mathematical operator (it&#39;s actually the &#39;true modulo&#39;<br>operation), the % operator is the remainder operation. This distinction is<br>not a made up distinction (e.g.<br>https://blogs.msdn.microsoft.com/ericlippert/2011/12/05/whats-the-difference-remainder-vs-modulus/<br>)<br></p><p>&gt; You can simply use arr.endIndex.advancedBy(-1) for<br></p><p>You are not taking into account when a function is passed an argument and<br>needs it to be in some range. It&#39;s not that it&#39;s impossible to implement,<br>it&#39;s just that this is more ergonomic.<br></p><p><br></p><p><br></p><p>On Sat, May 21, 2016 at 2:09 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>&gt; Adam, there is no need for an operator to compute the real index using<br>&gt; a negative index. You can simply use arr.endIndex.advancedBy(-1) for<br>&gt; that or, in this particular case, arr.endIndex.predecessor(). Right<br>&gt; now this is the standard, although I&#39;&#39;d rather use int indices<br>&gt; directly.<br>&gt;<br>&gt; On 21 May 2016 at 17:56, Adam Nemecek &lt;adamnemecek at gmail.com&gt; wrote:<br>&gt; &gt;&gt; I think this is a very particular case<br>&gt; &gt;<br>&gt; &gt; I disagree. Swift has the concept of a range all over the place and this<br>&gt; is<br>&gt; &gt; a fundamental range operation.<br>&gt; &gt;<br>&gt; &gt;&gt;  As you pointed out this already can be implemented using resources<br>&gt; &gt;&gt; already available in the language when needed.<br>&gt; &gt;<br>&gt; &gt; Right. A lot of things in the standard library can be implemented using<br>&gt; &gt; resources already available, it&#39;s about the ergonomics.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Sat, May 21, 2016 at 1:44 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Adam, I think this is a very particular case and not something that<br>&gt; needs<br>&gt; &gt;&gt; to be added to the language. As you pointed out this already can be<br>&gt; &gt;&gt; implemented using resources already available in the language when<br>&gt; needed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On 21 May 2016 at 17:22, Adam Nemecek via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Hello,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for<br>&gt; &gt;&gt;&gt; example in CoffeeScript (some discussion can be found here<br>&gt; &gt;&gt;&gt; https://github.com/jashkenas/coffeescript/issues/1971).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This operator, unlike normal modulo, takes sign from the divisor, not<br>&gt; the<br>&gt; &gt;&gt;&gt; dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For<br>&gt; &gt;&gt;&gt; example, it would be useful for calculating the real index into a<br>&gt; collection<br>&gt; &gt;&gt;&gt; when we are using an index outside of the range of valid indices and<br>&gt; could<br>&gt; &gt;&gt;&gt; be used to index into a collection using a negative index à la Python<br>&gt; and<br>&gt; &gt;&gt;&gt; Ruby (where [1,2,3,4][-1] == 4).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The implementation would probably be something along these lines:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; infix operator %% {<br>&gt; &gt;&gt;&gt;   associativity left<br>&gt; &gt;&gt;&gt;   precedence 150<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt; &gt;&gt;&gt;   return (lhs % rhs + rhs) % rhs<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If accepted, this could be later incorporated into a method or operator<br>&gt; &gt;&gt;&gt; that works directly with collections using their count property.<br>&gt; &gt;&gt;&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Ideas, suggestions?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/38157152/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; You are not taking into account when a function is passed an argument and needs it to be in some range.<br></p><p>If you pass an out-of-range argument, you should reject it using a precondition, thrown error, or nil return value. And if for some reason you really *do* want to force the value into the range, clamping it to the bounds of the range seems like a more sensible solution than modulo. I&#39;m sure there are cases where you *would* want to do this, but they seem like they&#39;d be few and far between.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 21, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; If you pass an out-of-range argument, you should reject it using a<br>precondition<br></p><p>Different use case. I have a circular buffer.<br></p><p>&gt; . And if for some reason you really *do* want to force the value into the<br>range, clamping it to the bounds of the range seems like a more sensible<br>solution than modulo<br></p><p>I have a circular buffer, I don&#39;t want to be clamping it to the bounds of<br>the range.<br></p><p>&gt; I&#39;m sure there are cases where you *would* want to do this, but they seem<br>like they&#39;d be few and far between.<br></p><p>It&#39;s the &#39;correct&#39; implementation of modulo.<br></p><p>On Sat, May 21, 2016 at 4:40 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; You are not taking into account when a function is passed an argument<br>&gt; and needs it to be in some range.<br>&gt;<br>&gt; If you pass an out-of-range argument, you should reject it using a<br>&gt; precondition, thrown error, or nil return value. And if for some reason you<br>&gt; really *do* want to force the value into the range, clamping it to the<br>&gt; bounds of the range seems like a more sensible solution than modulo. I&#39;m<br>&gt; sure there are cases where you *would* want to do this, but they seem like<br>&gt; they&#39;d be few and far between.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/c7adf3f1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 21, 2016 at 07:00:00pm</p></header><div class="content"><p>This is one of those things that takes very little to add, I would use it if it existed (having written workarounds), but it isn&#39;t horrible not having it there. <br></p><p>The only place off the top of my head that I consistently use it for is wrapping, but that&#39;s a really nice use case.<br></p><p>-- E<br></p><p><br>&gt; On May 21, 2016, at 2:22 PM, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, <br>&gt; <br>&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for example in CoffeeScript (some discussion can be found here https://github.com/jashkenas/coffeescript/issues/1971 &lt;https://github.com/jashkenas/coffeescript/issues/1971&gt;).<br>&gt; <br>&gt; This operator, unlike normal modulo, takes sign from the divisor, not the dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt; <br>&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For example, it would be useful for calculating the real index into a collection when we are using an index outside of the range of valid indices and could be used to index into a collection using a negative index à la Python and Ruby (where [1,2,3,4][-1] == 4).<br>&gt; <br>&gt; <br>&gt; The implementation would probably be something along these lines:<br>&gt; <br>&gt; infix operator %% {<br>&gt;   associativity left<br>&gt;   precedence 150<br>&gt; }<br>&gt; <br>&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt;   return (lhs % rhs + rhs) % rhs<br>&gt; }<br>&gt; <br>&gt; If accepted, this could be later incorporated into a method or operator that works directly with collections using their count property. <br>&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt; <br>&gt; Ideas, suggestions?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/f20fb460/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>I’m not really sold on the `%%` spelling, but I think the operation itself is worth exposing.  This is the remainder of a “flooring” division (as opposed to the C-family “truncating” division[1]).  If we do provide it, we should also provide the accompanying divide operation.<br></p><p>– Steve<br></p><p>[1] there are several other ways to define division beyond these two: remainder is always positive, remainder is closest to zero, etc.  Truncating and flooring division are the most common by a wide margin, however.<br></p><p>&gt; On May 21, 2016, at 4:22 PM, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, <br>&gt; <br>&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for example in CoffeeScript (some discussion can be found here https://github.com/jashkenas/coffeescript/issues/1971 &lt;https://github.com/jashkenas/coffeescript/issues/1971&gt;).<br>&gt; <br>&gt; This operator, unlike normal modulo, takes sign from the divisor, not the dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt; <br>&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For example, it would be useful for calculating the real index into a collection when we are using an index outside of the range of valid indices and could be used to index into a collection using a negative index à la Python and Ruby (where [1,2,3,4][-1] == 4).<br>&gt; <br>&gt; <br>&gt; The implementation would probably be something along these lines:<br>&gt; <br>&gt; infix operator %% {<br>&gt;   associativity left<br>&gt;   precedence 150<br>&gt; }<br>&gt; <br>&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt;   return (lhs % rhs + rhs) % rhs<br>&gt; }<br>&gt; <br>&gt; If accepted, this could be later incorporated into a method or operator that works directly with collections using their count property. <br>&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt; <br>&gt; Ideas, suggestions?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/e728ecc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 23, 2016 at 10:00:00am</p></header><div class="content"><p>Would you want to make this a function? Or an operator but a different one?<br></p><p>On Mon, May 23, 2016 at 7:30 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; I’m not really sold on the `%%` spelling, but I think the operation itself<br>&gt; is worth exposing.  This is the remainder of a “flooring” division (as<br>&gt; opposed to the C-family “truncating” division[1]).  If we do provide it, we<br>&gt; should also provide the accompanying divide operation.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt; [1] there are several other ways to define division beyond these two:<br>&gt; remainder is always positive, remainder is closest to zero, etc.<br>&gt; Truncating and flooring division are the most common by a wide margin,<br>&gt; however.<br>&gt;<br>&gt; On May 21, 2016, at 4:22 PM, Adam Nemecek via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello,<br>&gt;<br>&gt; I think that Swift could use the &#39;double modulo&#39; operator which is for<br>&gt; example in CoffeeScript (some discussion can be found here<br>&gt; https://github.com/jashkenas/coffeescript/issues/1971).<br>&gt;<br>&gt; This operator, unlike normal modulo, takes sign from the divisor, not the<br>&gt; dividend e.g. -10 % 3 == -1, but -10 %% 3 == 2.<br>&gt;<br>&gt; In practice, this operator is useful for &#39;cyclical&#39; indexing. For example,<br>&gt; it would be useful for calculating the real index into a collection when we<br>&gt; are using an index outside of the range of valid indices and could be used<br>&gt; to index into a collection using a negative index à la Python and Ruby<br>&gt; (where [1,2,3,4][-1] == 4).<br>&gt;<br>&gt;<br>&gt; The implementation would probably be something along these lines:<br>&gt;<br>&gt; infix operator %% {<br>&gt;   associativity left<br>&gt;   precedence 150<br>&gt; }<br>&gt;<br>&gt; func %%&lt;T: IntegerArithmeticType&gt;(lhs:T, rhs:T) -&gt; T {<br>&gt;   return (lhs % rhs + rhs) % rhs<br>&gt; }<br>&gt;<br>&gt; If accepted, this could be later incorporated into a method or operator<br>&gt; that works directly with collections using their count property.<br>&gt; Maybe the syntax could be something like [1,2,3,4] %% -1 == 4.<br>&gt;<br>&gt; Ideas, suggestions?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/06cb45bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>I wouldn&#39;t mind if the standard `%` operator worked like this and there would be another top-level function `mod(p, q)` that worked like `%` in C. The only times that I&#39;ve ever needed the modulo operation (https://en.wikipedia.org/wiki/Modulo_operation) to behave some way on negative values it&#39;s always been the suggested remainder-of-flooring-division way.<br></p><p>On the other hand, there&#39;s a performance penalty (avoidable by using the other mod operation), so I can understand if not everyone agrees.<br></p><p>And like Steve said below, then we&#39;ll need a flooring division function (or operator) as well. And a flooring `(f, r) = divmod(p, q)` too, I suppose.<br></p><p>In any case, I&#39;m probably +1 if a well-thought proposal is brought to the table.<br></p><p>— Pyry<br></p><p>&gt; Adam Nemecek wrote:<br>&gt; <br>&gt; Would you want to make this a function? Or an operator but a different one?<br>&gt; <br>&gt;&gt; On Mon, May 23, 2016 at 7:30 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; I’m not really sold on the `%%` spelling, but I think the operation itself is worth exposing.  This is the remainder of a “flooring” division (as opposed to the C-family “truncating” division[1]).  If we do provide it, we should also provide the accompanying divide operation.<br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt;&gt; <br>&gt;&gt; [1] there are several other ways to define division beyond these two: remainder is always positive, remainder is closest to zero, etc.  Truncating and flooring division are the most common by a wide margin, however.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/a1bff379/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>That kind of breaks backwards compatibility.<br></p><p>Also currently in swift, the % operator is called the remainder operator,<br>not the modulo operator, so technically the current implementation is<br>correct. In Haskell for example, there are two functions, rem (as in<br>remainder) and mod (as in modulo). I guess we could leave % to mean<br>remainder and introduce a mod function?<br></p><p><br></p><p>On Mon, May 23, 2016 at 11:59 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br></p><p>&gt; I wouldn&#39;t mind if the standard `%` operator worked like this and there<br>&gt; would be another top-level function `mod(p, q)` that worked like `%` in C.<br>&gt; The only times that I&#39;ve ever needed the modulo operation (<br>&gt; https://en.wikipedia.org/wiki/Modulo_operation) to behave *some way* on<br>&gt; negative values it&#39;s always been the suggested<br>&gt; remainder-of-flooring-division way.<br>&gt;<br>&gt; On the other hand, there&#39;s a performance penalty (avoidable by using the<br>&gt; other mod operation), so I can understand if not everyone agrees.<br>&gt;<br>&gt; And like Steve said below, then we&#39;ll need a flooring division function<br>&gt; (or operator) as well. And a flooring `(f, r) = divmod(p, q)` too, I<br>&gt; suppose.<br>&gt;<br>&gt; In any case, I&#39;m probably +1 if a well-thought proposal is brought to the<br>&gt; table.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt; Adam Nemecek wrote:<br>&gt;<br>&gt; Would you want to make this a function? Or an operator but a different one?<br>&gt;<br>&gt; On Mon, May 23, 2016 at 7:30 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; I’m not really sold on the `%%` spelling, but I think the operation<br>&gt;&gt; itself is worth exposing.  This is the remainder of a “flooring” division<br>&gt;&gt; (as opposed to the C-family “truncating” division[1]).  If we do provide<br>&gt;&gt; it, we should also provide the accompanying divide operation.<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; [1] there are several other ways to define division beyond these two:<br>&gt;&gt; remainder is always positive, remainder is closest to zero, etc.<br>&gt;&gt; Truncating and flooring division are the most common by a wide margin,<br>&gt;&gt; however.<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/05764d7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;ve had to write a &quot;true mod&quot; function enough times across different<br>projects (usually for circular buffer indexing or angular arithmetic) that<br>it would absolutely support its inclusion in stdlib (for both integer and<br>floating point types).<br></p><p>The `%` operator historically has been implemented as &quot;remainder&quot; though<br>(even when called &quot;modulus&quot;), so while it would be nice to be &quot;pure&quot; and<br>have `%` do the right thing, I think it would be too confusing for users to<br>have the operator have a subtly different meaning compared to every other<br>programming language that looks like it.<br></p><p>I&#39;m not crazy about the `%%` spelling, but I can&#39;t think of anything better<br>either at the moment.<br></p><p>On Mon, May 23, 2016 at 12:24 PM Adam Nemecek via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That kind of breaks backwards compatibility.<br>&gt;<br>&gt; Also currently in swift, the % operator is called the remainder operator,<br>&gt; not the modulo operator, so technically the current implementation is<br>&gt; correct. In Haskell for example, there are two functions, rem (as in<br>&gt; remainder) and mod (as in modulo). I guess we could leave % to mean<br>&gt; remainder and introduce a mod function?<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, May 23, 2016 at 11:59 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I wouldn&#39;t mind if the standard `%` operator worked like this and there<br>&gt;&gt; would be another top-level function `mod(p, q)` that worked like `%` in C.<br>&gt;&gt; The only times that I&#39;ve ever needed the modulo operation (<br>&gt;&gt; https://en.wikipedia.org/wiki/Modulo_operation) to behave *some way* on<br>&gt;&gt; negative values it&#39;s always been the suggested<br>&gt;&gt; remainder-of-flooring-division way.<br>&gt;&gt;<br>&gt;&gt; On the other hand, there&#39;s a performance penalty (avoidable by using the<br>&gt;&gt; other mod operation), so I can understand if not everyone agrees.<br>&gt;&gt;<br>&gt;&gt; And like Steve said below, then we&#39;ll need a flooring division function<br>&gt;&gt; (or operator) as well. And a flooring `(f, r) = divmod(p, q)` too, I<br>&gt;&gt; suppose.<br>&gt;&gt;<br>&gt;&gt; In any case, I&#39;m probably +1 if a well-thought proposal is brought to the<br>&gt;&gt; table.<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt;<br>&gt;&gt; Adam Nemecek wrote:<br>&gt;&gt;<br>&gt;&gt; Would you want to make this a function? Or an operator but a different<br>&gt;&gt; one?<br>&gt;&gt;<br>&gt;&gt; On Mon, May 23, 2016 at 7:30 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I’m not really sold on the `%%` spelling, but I think the operation<br>&gt;&gt;&gt; itself is worth exposing.  This is the remainder of a “flooring” division<br>&gt;&gt;&gt; (as opposed to the C-family “truncating” division[1]).  If we do provide<br>&gt;&gt;&gt; it, we should also provide the accompanying divide operation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [1] there are several other ways to define division beyond these two:<br>&gt;&gt;&gt; remainder is always positive, remainder is closest to zero, etc.<br>&gt;&gt;&gt; Truncating and flooring division are the most common by a wide margin,<br>&gt;&gt;&gt; however.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/b79a6d30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>You have both good points.<br></p><p>In that case, if we still want to define new operators here (which might not please everybody), then I&#39;d suggest finding a common prefix or suffix character (e.g. `^/` and `^%`) for both the floored division and floored modulo (for one, because we can&#39;t define `//` as an operator).<br></p><p>But I think it&#39;d be clearest to just make them both top-level functions, e.g. `floordiv(p, q)` and `floormod(p, q)`. If anyone uses either a lot, and likes to make it terse, it&#39;s easy to define a private operator wrapper for it.<br></p><p>— Pyry<br></p><p>&gt; Tony Allevato wrote:<br>&gt; <br>&gt; I&#39;ve had to write a &quot;true mod&quot; function enough times across different projects (usually for circular buffer indexing or angular arithmetic) that it would absolutely support its inclusion in stdlib (for both integer and floating point types).<br>&gt; <br>&gt; The `%` operator historically has been implemented as &quot;remainder&quot; though (even when called &quot;modulus&quot;), so while it would be nice to be &quot;pure&quot; and have `%` do the right thing, I think it would be too confusing for users to have the operator have a subtly different meaning compared to every other programming language that looks like it.<br>&gt; <br>&gt; I&#39;m not crazy about the `%%` spelling, but I can&#39;t think of anything better either at the moment.<br>&gt; <br>&gt;&gt; On Mon, May 23, 2016 at 12:24 PM Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; That kind of breaks backwards compatibility. <br>&gt;&gt; <br>&gt;&gt; Also currently in swift, the % operator is called the remainder operator, not the modulo operator, so technically the current implementation is correct. In Haskell for example, there are two functions, rem (as in remainder) and mod (as in modulo). I guess we could leave % to mean remainder and introduce a mod function?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, May 23, 2016 at 11:59 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;&gt;&gt; I wouldn&#39;t mind if the standard `%` operator worked like this and there would be another top-level function `mod(p, q)` that worked like `%` in C. The only times that I&#39;ve ever needed the modulo operation (https://en.wikipedia.org/wiki/Modulo_operation) to behave some way on negative values it&#39;s always been the suggested remainder-of-flooring-division way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, there&#39;s a performance penalty (avoidable by using the other mod operation), so I can understand if not everyone agrees.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And like Steve said below, then we&#39;ll need a flooring division function (or operator) as well. And a flooring `(f, r) = divmod(p, q)` too, I suppose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case, I&#39;m probably +1 if a well-thought proposal is brought to the table.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adam Nemecek wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would you want to make this a function? Or an operator but a different one?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mon, May 23, 2016 at 7:30 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I’m not really sold on the `%%` spelling, but I think the operation itself is worth exposing.  This is the remainder of a “flooring” division (as opposed to the C-family “truncating” division[1]).  If we do provide it, we should also provide the accompanying divide operation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [1] there are several other ways to define division beyond these two: remainder is always positive, remainder is closest to zero, etc.  Truncating and flooring division are the most common by a wide margin, however.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/8eb15a78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] &#39;Double modulo&#39; operator</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>Seems like making it an operator will cause more issues than it solves. I think that floordiv and mod functions are probably the way to go. I&#39;m going to wait a little longer for more feedback and write up a proposal at some point. <br></p><p><br></p><p><br></p><p><br>On Mon, May 23, 2016 at 1:20 PM -0700, &quot;Pyry Jahkola&quot; &lt;pyry.jahkola at iki.fi&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>You have both good points.<br>In that case, if we still want to define new operators here (which might not please everybody), then I&#39;d suggest finding a common prefix or suffix character (e.g. `^/` and `^%`) for both the floored division and floored modulo (for one, because we can&#39;t define `//` as an operator).<br>But I think it&#39;d be clearest to just make them both top-level functions, e.g. `floordiv(p, q)` and `floormod(p, q)`. If anyone uses either a lot, and likes to make it terse, it&#39;s easy to define a private operator wrapper for it.<br>— Pyry<br></p><p>Tony Allevato wrote:<br></p><p>I&#39;ve had to write a &quot;true mod&quot; function enough times across different projects (usually for circular buffer indexing or angular arithmetic) that it would absolutely support its inclusion in stdlib (for both integer and floating point types).<br>The `%` operator historically has been implemented as &quot;remainder&quot; though (even when called &quot;modulus&quot;), so while it would be nice to be &quot;pure&quot; and have `%` do the right thing, I think it would be too confusing for users to have the operator have a subtly different meaning compared to every other programming language that looks like it.<br>I&#39;m not crazy about the `%%` spelling, but I can&#39;t think of anything better either at the moment.<br>On Mon, May 23, 2016 at 12:24 PM Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>That kind of breaks backwards compatibility. <br>Also currently in swift, the % operator is called the remainder operator, not the modulo operator, so technically the current implementation is correct. In Haskell for example, there are two functions, rem (as in remainder) and mod (as in modulo). I guess we could leave % to mean remainder and introduce a mod function?<br></p><p><br></p><p>On Mon, May 23, 2016 at 11:59 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>I wouldn&#39;t mind if the standard `%` operator worked like this and there would be another top-level function `mod(p, q)` that worked like `%` in C. The only times that I&#39;ve ever needed the modulo operation (https://en.wikipedia.org/wiki/Modulo_operation) to behave some way on negative values it&#39;s always been the suggested remainder-of-flooring-division way.<br>On the other hand, there&#39;s a performance penalty (avoidable by using the other mod operation), so I can understand if not everyone agrees.<br>And like Steve said below, then we&#39;ll need a flooring division function (or operator) as well. And a flooring `(f, r) = divmod(p, q)` too, I suppose.<br>In any case, I&#39;m probably +1 if a well-thought proposal is brought to the table.<br>— Pyry<br>Adam Nemecek wrote:<br></p><p>Would you want to make this a function? Or an operator but a different one?<br>On Mon, May 23, 2016 at 7:30 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>I’m not really sold on the `%%` spelling, but I think the operation itself is worth exposing.  This is the remainder of a “flooring” division (as opposed to the C-family “truncating” division[1]).  If we do provide it, we should also provide the accompanying divide operation.<br>– Steve<br>[1] there are several other ways to define division beyond these two: remainder is always positive, remainder is closest to zero, etc.  Truncating and flooring division are the most common by a wide margin, however.<br></p><p>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/8c14b412/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
