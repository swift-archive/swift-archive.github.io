<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>March 14, 2016 at 08:00:00pm</p></header><div class="content"><p>I think it would be great if throws -&gt; Foo were a syntactic sugar of -&gt;<br>Result&lt;Foo&gt;. Without affecting existing codes, it makes it possible to go<br>back and forth between *Manual Propagation* and *Automatic Propagation*<br> seamlessly.<br></p><p>// I wish if the first `makeFoo` were// a syntactic sugar of the<br>second onefunc makeFoo(x: Int) throws -&gt; Foo {<br>  guard ... else {<br>    throw FooError()<br>  }<br>  return Foo(x)<br>}// @warn_unused_result// func makeFoo(x: Int) -&gt; Result&lt;Foo&gt; {//<br>guard ... else {//     return Result(error: FooError())//   }//<br>return Result(Foo(x))// }<br>// Manual propagationlet result: Result&lt;Foo&gt; = makeFoo(42) // without<br>`try`switch result {<br>  case let .Success(foo):<br>    ...<br>  case let .Failure(error):<br>    ...<br>}<br>// Automatic propagationdo {<br>  let foo: Foo = try makeFoo(42) // with `try`: a kind of unwrapping<br>  ...<br>} catch let error {<br>  ...<br>}<br></p><p>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#for-what&gt;For what?<br></p><p>I want to unify throws and Result into one feature to keep the language<br>simple.<br></p><p>As referred in &quot;Error Handling Rationale and Proposal&quot;<br>&lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#automatic-propagation&gt;,<br>I think Swift should provide something like Result. It means we would have<br>similar two features: throws and Result. We need a way to covert them to<br>each other. For examples, it can be done in the following way.<br></p><p>// What I DON&#39;T wantfunc makeFoo(x: Int) throws -&gt; Foo { ... } // -&gt; Result&lt;Foo&gt;<br>let a: Result&lt;Foo&gt; = try| makeFoo(42)<br>  // `try|` for `Result` like `try?` for `Optional`<br>do {<br>  let b = try a.throwIfError()<br>  ...<br>} catch let error {<br>  ...<br>}<br></p><p>If throws were a syntactic sugar of returning a Result, it would be simpler.<br></p><p>// What I wantfunc makeFoo(x: Int) throws -&gt; Foo { ... } // -&gt; Result&lt;Foo&gt;<br>let a: Result&lt;Foo&gt; = makeFoo(42)<br>do {<br>  let b = try a<br>  ...<br>} catch let error {<br>  ...<br>}<br></p><p>In Addition, it prevents that APIs of third-party libraries diverge. If we<br>had similar but different two features, throws and Result, some libraries<br>would use throws and others would use Result. Actually it has already<br>happened. Some popular libraries use antitypical/Result<br>&lt;https://github.com/antitypical/Result&gt; or their own Result types. If<br>throws were<br>a syntactic sugar of returning a Result, using throws or Result would<br>affect only the appearance of codes, and we could use those libraries in<br>the same way.<br></p><p><br>-- Yuta<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/12602764/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>March 14, 2016 at 08:00:00pm</p></header><div class="content"><p>This is some supplementary explanations about throws as returning a Result.<br></p><p>   - What&#39;s Result?<br>   - Why we need both throws and Result<br>   - Result&lt;Value&gt; vs Result&lt;Value, Error&gt;<br>   - When forgets try<br>   - With side effects<br>   - Why not Either, union types nor tuples<br>   - Return value of do<br>   - Complication with rethrows<br></p><p>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#whats-result&gt;What&#39;s<br>Result?<br></p><p>It&#39;s an enum declared in a following way.<br></p><p>enum Result&lt;Value&gt; {<br>  case Success(Value)<br>  case Failure(ErrorType)<br>}<br></p><p>It also should have map, flatMap and some convenient methods like Optional.<br>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#why-we-need-both-throws-and-result&gt;Why<br>we need both throws and Result<br></p><p>Result provides more flexible way to handle errors than throws though they<br>provide similar functionalities. It can be assigned to a variable, passed<br>to a function and stored in a property while an error must be handled<br>immediately after it is thrown. It is useful especially for asynchronous<br>operations.<br></p><p>For example, think about map or flatMap (or then) method of Promise&lt;Value&gt;<br> (or Future&lt;Value&gt;). They cannot receive a function with throws.<br></p><p>extension Promise {<br>  func map&lt;T&gt;(transform: Value -&gt; T) -&gt; Promise&lt;T&gt; { ... }<br>}<br></p><p>Because the transform is executed asynchronously, this map method cannot<br>throw an error immediately. If we had throws as returning a Result, we can<br>pass a function with throws to the map.<br></p><p>func toInt(x: String) throws -&gt; Int { ... } // -&gt; Result&lt;Int&gt;<br>let string: Promise&lt;String&gt; = ...let number: Promise&lt;Result&lt;Int&gt;&gt; =<br>string.map(toInt)<br></p><p>It also caused a problem when I implemented lazily evaluated List&lt;Element&gt;s.<br></p><p>extension List {<br>  func map&lt;T&gt;(transform: Element -&gt; T) -&gt; List&lt;T&gt; { ... }<br>}<br></p><p>It cannot throw an error because the transform is evaluated lazily. With<br>throws as returning a Result, it could be used with a function with throws<br> too.<br></p><p>func toInt(x: String) throws -&gt; Int { ... } // -&gt; Result&lt;Int&gt;<br>let strings: List&lt;String&gt; = ... // Infinite listlet numbers:<br>List&lt;Result&lt;Int&gt;&gt; = strings.map(toInt)let first10: List&lt;Result&lt;Int&gt;&gt; =<br>numbers.take(10)let result: Result&lt;List&lt;Int&gt;&gt; = sequence(first10) //<br>List&lt;Result&lt;...&gt;&gt; -&gt; Result&lt;List&lt;...&gt;&gt;do {<br>  let mapped: List&lt;Int&gt; = try result<br>  ...<br>} catch let error {<br>  ...<br>}<br></p><p>If Result is more flexible than throws, why do we need throws? Handling<br>Results manually with *manual propagation *costs more. We should have a way<br>to handle errors with *automatic propagation*.<br></p><p>So we need both throws and Result.<br>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#resultvalue-vs-resultvalue-error&gt;<br>Result&lt;Value&gt; vs Result&lt;Value, Error&gt;<br></p><p>I know it is discussed which of *untyped throws* and *typed throws* are<br>better. If *typed throws* is accepted, Result&lt;Value, Error&gt; should be<br>provided instead of Result&lt;Value&gt;<br></p><p>However the proposal about *typed throws*<br>&lt;https://github.com/apple/swift-evolution/pull/68&gt; has been left for<br>several months. I&#39;m not sure if the discussion is continued. So I started<br>this thread with Result&lt;Value&gt;. And even if *typed throws* is accepted, we<br>just need to change Result&lt;Value&gt; to Result&lt;Value, Error&gt;. The discussion<br>for throws as returning a Result can be applied for *typed throws* and<br>Result&lt;Value,<br>Error&gt; as it is.<br>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#when-forgets-try&gt;When<br>forgets try<br></p><p>If we forget to write try, what will happen? This is a downside of throws as<br>returning a Result.<br></p><p>Even if we forget to write try, it can raise an compilation error with<br>throws as returning a Result. However the error sites are confusing and<br>nonintuitive.<br></p><p>func toInt(x: String) throws -&gt; Int { ... } // -&gt; Result&lt;Int&gt;<br>let a = toInt(aString) // Compilation error here with Swift 2.Xlet b =<br>toInt(bString)let sum = a + b // Compilation error here with `throws`<br>as returning a `Result`<br></p><p>I think it can be eased by improved error messages.<br>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#with-side-effects&gt;With<br>side effects<br></p><p>If a function has side effects, its error should not be ignored implicitly.<br></p><p>func update(x: Int) throws { ... } // -&gt; Result&lt;()&gt;<br></p><p>update(42) // No compilation error =&gt; dangerous!!<br></p><p>So I think throws should add the @warn_unused_result attribute to the<br>function automatically. If we had a kind of at error_unused_result attribute,<br>it would be better.<br></p><p>update(42) // Warning or Error<br>_ = update(42) // Ignores error explicitly<br>// Manual propagationswitch update(42) {<br>  case .Success:<br>    ...<br>  case .Failure(error):<br>    ...<br>}<br>// Automatic propagationdo {<br>  try update(42)<br>  ...<br>} catch let error {<br>  ...<br>}<br></p><p>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#why-not-either-union-types-nor-tuples&gt;Why<br>not Either, union types nor tuples<br></p><p>Result is preferred to Either as discussed on this thread<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007728.html&gt;<br>.<br></p><p>Either is a tagged union. However its tags are meaningless: Left and Right.<br>I think it is much better to have something like *union types* in Ceylon<br>and some other languages than to have Either.<br></p><p>However *union types* make a significant impact on the type system.<br>Subtyping gets much more complicated. We should also think about *intersection<br>types* in addition to *uniton types*. If we had *union types*, I think it<br>would be better that Optional&lt;Foo&gt; is a sugar of Foo|Nil like in Ceylon.<br>Changing all of them is not practical.<br></p><p>How about tuples? Tuples like (Value?, Error?) is an easy way. However it<br>results four cases: (value, nil), (nil, error), (value, error) and (nil,<br>nil). We don&#39;t need the last two.<br></p><p>Therefore I think Result is the best way.<br>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#return-value-of-do&gt;Return<br>value of do<br></p><p>We easily think of a return value of do statement/expression like Haskell&#39;s<br>do notation.<br></p><p>func toInt(x: String) throws -&gt; Int { ... } // -&gt; Result&lt;Int&gt;<br>let sum: Result&lt;Int&gt; = do {<br>  let a: Int = try toInt(&quot;2&quot;)<br>  let b: Int = try toInt(&quot;3&quot;)<br>  a + b<br>} // Result(5)<br></p><p>It can be regarded as a syntactic sugar of nested flatMaps.<br></p><p>However it causes following problems.<br></p><p>   1. It made it impossible to return, break nor continue inside the do<br>    statement/expression.<br>   2. Returning the evaluated value of the last expression in braces is not<br>   Swifty.<br></p><p>I think the following can be the alternative.<br></p><p>let sum: Result&lt;Int&gt; = { () throws -&gt; Int in<br>  let a: Int = try toInt(&quot;2&quot;)<br>  let b: Int = try toInt(&quot;3&quot;)<br>  return  a + b<br>}()<br></p><p>&lt;https://gist.github.com/koher/e6a8b128bd7ad6898ac9#complication-with-rethrows&gt;Complication<br>with rethrows<br></p><p>With throws as returning a Result, what should be the type of the following<br>numbers?<br></p><p>func toInt(x: String) throws -&gt; Int { ... } // -&gt; Result&lt;Int&gt;<br>let numbers: ??? = [&quot;one&quot;, &quot;2&quot;, &quot;3&quot;, &quot;four&quot;, &quot;5&quot;].map(toInt)<br></p><p>It can be regarded as both Result&lt;List&lt;Int&gt;&gt; and List&lt;Result&lt;Int&gt;&gt;. I think<br>it should be decided by the type of the numbers.<br></p><p>// Both workslet numbers: Result&lt;Array&lt;Int&gt;&gt; = [&quot;one&quot;, &quot;2&quot;, &quot;3&quot;,<br>&quot;four&quot;, &quot;5&quot;].map(toInt)let numbers: Array&lt;Result&lt;Int&gt;&gt; = [&quot;one&quot;, &quot;2&quot;,<br>&quot;3&quot;, &quot;four&quot;, &quot;5&quot;].map(toInt)<br></p><p>If the type of the numbers are omitted, what happens? We have some options.<br></p><p>   - Compilation error because of the ambiguous type<br>   - The default type like that the one for integer literals is Int<br>      - e.g. If map is marked as rethrows, returns Result&lt;Array&lt;Int&gt;&gt;, and<br>      Array&lt;Result&lt;Int&gt;&gt; for the others.<br></p><p><br>-- Yuta<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/f267fc40/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>March 14, 2016 at 12:00:00pm</p></header><div class="content"><p>I am for Automatic propagation/conversion.<br>if this line works:<br></p><p>let a : Result&lt;Foo&gt; = try makeFoo(42)<br></p><p>it would be great usage of Result. (there was discussion about it. I<br>think it was rejected).<br></p><p>Not really sure about:  &quot;let a: Result&lt;Foo&gt; = makeFoo(42)&quot;<br>I can see that this could become more needed/used when we are going<br>towards async coding in next Swift (4.0?).<br></p><p>Ondrej B.<br></p><p><br></p><p>On Mon, Mar 14, 2016 at 12:07 PM, Yuta Koshizawa via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I think it would be great if throws -&gt; Foo were a syntactic sugar of -&gt;<br>&gt; Result&lt;Foo&gt;. Without affecting existing codes, it makes it possible to go<br>&gt; back and forth between Manual Propagation and Automatic Propagation<br>&gt; seamlessly.<br>&gt;<br>&gt; // I wish if the first `makeFoo` were<br>&gt; // a syntactic sugar of the second one<br>&gt; func makeFoo(x: Int) throws -&gt; Foo {<br>&gt;   guard ... else {<br>&gt;     throw FooError()<br>&gt;   }<br>&gt;   return Foo(x)<br>&gt; }<br>&gt; // @warn_unused_result<br>&gt; // func makeFoo(x: Int) -&gt; Result&lt;Foo&gt; {<br>&gt; //   guard ... else {<br>&gt; //     return Result(error: FooError())<br>&gt; //   }<br>&gt; //   return Result(Foo(x))<br>&gt; // }<br>&gt;<br>&gt; // Manual propagation<br>&gt; let result: Result&lt;Foo&gt; = makeFoo(42) // without `try`<br>&gt; switch result {<br>&gt;   case let .Success(foo):<br>&gt;     ...<br>&gt;   case let .Failure(error):<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; // Automatic propagation<br>&gt; do {<br>&gt;   let foo: Foo = try makeFoo(42) // with `try`: a kind of unwrapping<br>&gt;   ...<br>&gt; } catch let error {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; For what?<br>&gt;<br>&gt; I want to unify throws and Result into one feature to keep the language<br>&gt; simple.<br>&gt;<br>&gt; As referred in &quot;Error Handling Rationale and Proposal&quot;, I think Swift should<br>&gt; provide something like Result. It means we would have similar two features:<br>&gt; throws and Result. We need a way to covert them to each other. For examples,<br>&gt; it can be done in the following way.<br>&gt;<br>&gt; // What I DON&#39;T want<br>&gt; func makeFoo(x: Int) throws -&gt; Foo { ... } // -&gt; Result&lt;Foo&gt;<br>&gt;<br>&gt; let a: Result&lt;Foo&gt; = try| makeFoo(42)<br>&gt;   // `try|` for `Result` like `try?` for `Optional`<br>&gt;<br>&gt; do {<br>&gt;   let b = try a.throwIfError()<br>&gt;   ...<br>&gt; } catch let error {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; If throws were a syntactic sugar of returning a Result, it would be simpler.<br>&gt;<br>&gt; // What I want<br>&gt; func makeFoo(x: Int) throws -&gt; Foo { ... } // -&gt; Result&lt;Foo&gt;<br>&gt;<br>&gt; let a: Result&lt;Foo&gt; = makeFoo(42)<br>&gt;<br>&gt; do {<br>&gt;   let b = try a<br>&gt;   ...<br>&gt; } catch let error {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; In Addition, it prevents that APIs of third-party libraries diverge. If we<br>&gt; had similar but different two features, throws and Result, some libraries<br>&gt; would use throws and others would use Result. Actually it has already<br>&gt; happened. Some popular libraries use antitypical/Result or their own Result<br>&gt; types. If throws were a syntactic sugar of returning a Result, using throws<br>&gt; or Result would affect only the appearance of codes, and we could use those<br>&gt; libraries in the same way.<br>&gt;<br>&gt;<br>&gt; -- Yuta<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9211cc51e7e6f1221cce0842f653735a?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Thomas Guthrie</string> &lt;tomguthrie at gmail.com&gt;<p>March 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 14 Mar 2016, at 11:36, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; it would be great usage of Result. (there was discussion about it. I<br>&gt; think it was rejected).<br>&gt; <br>&gt; Not really sure about:  &quot;let a: Result&lt;Foo&gt; = makeFoo(42)&quot;<br>&gt; I can see that this could become more needed/used when we are going<br>&gt; towards async coding in next Swift (4.0?).<br></p><p>Result is mentioned in https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors&gt; (the proposal/doc for swift’s current error handling) and John McCall had this to say about it:<br></p><p>&gt; We considered it, had some specifics worked out, and then decided to put it on hold.  Part of our reasoning was that it seemed more like an implementation detail of the async / CPS-conversion features we’d like to provide than an independently valuable feature, given that we don’t want to encourage people to write library interfaces using functional-style error handling instead of throws.<br>&gt; <br>&gt; It’s also a feature that’s directly affected by the design of typed throws, which in turn poses some usability challenges for it.  For example, without typed throws you really just want the type to be Result&lt;T&gt;.  With typed throws, can you still write that, or do you have to write Result&lt;T, ErrorType&gt;?  Also, if we want every function result signature to have a corresponding Result&lt;&gt; type, does that permanently prevent us to supporting multiple error types with “typed throws”?  Also, would it be too frustrating to work with typed Result values if we don’t allow implicit covariant conversions along one or both dimensions?<br></p><p>(From https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001433.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001433.html&gt;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/1ae79c82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>March 14, 2016 at 03:00:00pm</p></header><div class="content"><p>+1. The potential integration with auto-async-conversion here is brilliant<br>and will be incredibly useful if implemented.<br></p><p>On Mon, Mar 14, 2016 at 8:15 AM Thomas Guthrie via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 14 Mar 2016, at 11:36, Ondrej Barina via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; it would be great usage of Result. (there was discussion about it. I<br>&gt; think it was rejected).<br>&gt;<br>&gt; Not really sure about:  &quot;let a: Result&lt;Foo&gt; = makeFoo(42)&quot;<br>&gt; I can see that this could become more needed/used when we are going<br>&gt; towards async coding in next Swift (4.0?).<br>&gt;<br>&gt;<br>&gt; Result is mentioned in<br>&gt; https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors (the proposal/doc<br>&gt; for swift’s current error handling) and John McCall had this to say about<br>&gt; it:<br>&gt;<br>&gt; We considered it, had some specifics worked out, and then decided to put<br>&gt; it on hold.  Part of our reasoning was that it seemed more like an<br>&gt; implementation detail of the async / CPS-conversion features we’d like to<br>&gt; provide than an independently valuable feature, given that we don’t want to<br>&gt; encourage people to write library interfaces using functional-style error<br>&gt; handling instead of throws.<br>&gt;<br>&gt; It’s also a feature that’s directly affected by the design of typed<br>&gt; throws, which in turn poses some usability challenges for it.  For example,<br>&gt; without typed throws you really just want the type to be Result&lt;T&gt;.  With<br>&gt; typed throws, can you still write that, or do you have to write Result&lt;T,<br>&gt; ErrorType&gt;?  Also, if we want every function result signature to have a<br>&gt; corresponding Result&lt;&gt; type, does that permanently prevent us to supporting<br>&gt; multiple error types with “typed throws”?  Also, would it be too<br>&gt; frustrating to work with typed Result values if we don’t allow implicit<br>&gt; covariant conversions along one or both dimensions?<br>&gt;<br>&gt;<br>&gt; (From<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001433.html<br>&gt; )<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/f07e6adc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 5:15 AM, Thomas Guthrie via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Mar 2016, at 11:36, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; it would be great usage of Result. (there was discussion about it. I<br>&gt;&gt; think it was rejected).<br>&gt;&gt; <br>&gt;&gt; Not really sure about:  &quot;let a: Result&lt;Foo&gt; = makeFoo(42)&quot;<br>&gt;&gt; I can see that this could become more needed/used when we are going<br>&gt;&gt; towards async coding in next Swift (4.0?).<br>&gt; <br>&gt; Result is mentioned in https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors&gt; (the proposal/doc for swift’s current error handling) and John McCall had this to say about it:<br>&gt; <br>&gt;&gt; We considered it, had some specifics worked out, and then decided to put it on hold.  Part of our reasoning was that it seemed more like an implementation detail of the async / CPS-conversion features we’d like to provide than an independently valuable feature, given that we don’t want to encourage people to write library interfaces using functional-style error handling instead of throws.<br>&gt;&gt; <br>&gt;&gt; It’s also a feature that’s directly affected by the design of typed throws, which in turn poses some usability challenges for it.  For example, without typed throws you really just want the type to be Result&lt;T&gt;.  With typed throws, can you still write that, or do you have to write Result&lt;T, ErrorType&gt;?  Also, if we want every function result signature to have a corresponding Result&lt;&gt; type, does that permanently prevent us to supporting multiple error types with “typed throws”?  Also, would it be too frustrating to work with typed Result values if we don’t allow implicit covariant conversions along one or both dimensions?<br>&gt; <br>&gt; (From https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001433.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001433.html&gt;)<br></p><p>Yeah, we extensively discussed adding a Result type internally, but ultimately couldn&#39;t justify it. The only real use case we could see in the wild was for threading errors through CPS-inversion-style abstractions like async promises, something we hope to provide proper language support for. More generally, expressing effects as monadic values is a pretty awful abstraction; aside from polluting the Internet with an endless deluge of unhelpful tutorials, they also don&#39;t compose cleanly, they impose nesting where is desired—you have to pick between Result&lt;Async&lt;T&gt;&gt; and Async&lt;Result&lt;T&gt;&gt;, or build ResultT&lt;AsyncT&lt;Identity&gt;&gt;&lt;T&gt; out of monad transformers—and they don&#39;t do the natural thing when used with other higher-order abstractions—if you&#39;re mapping a `throws` function over a collection, you probably want to propagate that error like `rethrows` does, not end up with a collection of Result&lt;T&gt;. I&#39;d rather see us adopt an extensible algebraic effects system, something like http://www.eff-lang.org, which provides a framework for `throws`, `async` and other control flow effects to be cleanly composed and abstracted over. I see `throws` as the first seed of that.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/969b52f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>March 15, 2016 at 10:00:00pm</p></header><div class="content"><p>2016-03-15 2:23 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt;<br>&gt; Yeah, we extensively discussed adding a Result type internally, but<br>&gt; ultimately couldn&#39;t justify it. The only real use case we could see in the<br>&gt; wild was for threading errors through CPS-inversion-style abstractions like<br>&gt; async promises, something we hope to provide proper language support for.<br>&gt; More generally, expressing effects as monadic values is a pretty awful<br>&gt; abstraction; aside from polluting the Internet with an endless deluge of<br>&gt; unhelpful tutorials, they also don&#39;t compose cleanly, they impose nesting<br>&gt; where is desired—you have to pick between Result&lt;Async&lt;T&gt;&gt; and<br>&gt; Async&lt;Result&lt;T&gt;&gt;, or build ResultT&lt;AsyncT&lt;Identity&gt;&gt;&lt;T&gt; out of monad<br>&gt; transformers—and they don&#39;t do the natural thing when used with other<br>&gt; higher-order abstractions—if you&#39;re mapping a `throws` function over a<br>&gt; collection, you probably want to propagate that error like `rethrows` does,<br>&gt; not end up with a collection of Result&lt;T&gt;.<br></p><p>Yes, I know the pain of nested monads and I don&#39;t want to encourage<br>monadic error handling with awful nests.<br></p><p>To tell the truth, I ultimately desire to unify `Optional`s, `throws`<br>and `Result`s.<br></p><p>We have already had `Optional`s which can be used in a monadic way. To<br>prevent excessive monadic handling, I think we need Automatic<br>Propagation for `Optional`s.<br></p><p>```<br>// Automatic Propagation for `Optional`s<br>let a: Int? = ...<br>let b: Int? = ...<br></p><p>do {<br>  let sum: Int = (try a) + (try b)<br>  ...<br>} catch { // if `a` and/or `b` are `nil`<br>  ...<br>}<br>```<br></p><p>Although &quot;Error Handling Rational and Proposal&quot; says `Optional`s<br>should be used for simple domain errors and are suitable for Manual<br>Propagation, I think Automatic Propagation is also useful for<br>`Optional`s. We get `nil` not only as errors but also as empty values.<br>Our codes are full of `Optional`s. Handling them manually costs a lot.<br>So I think it is good to have Automatic Propagation for `Optional`s.<br></p><p>However it is confusing to mix `Optional`s and `throws` functions with<br>the same keyword `try`. So I think something like `typealias<br>Optional&lt;T&gt; = Result&lt;T, NilError&gt;`, which could be identical in a<br>binary form to current `Optional` with `struct NilError: ErrorType<br>{}`, and unified `throws` and `Result`s would be better. Then we would<br>have only `Result`s, but it could be used as `Optional`s and `throws`.<br></p><p>Although `Result`s might make it possible to abuse monadic error<br>handling, problems of abuses are also true for other language<br>features: e.g. `(Float, Float)` as `Vector2` instead of `struct<br>Vector2 { ... }` for tuples. Even if we keep `Optional`s and `throws`<br>separated, `Optional`s can be handled monadically and we need to<br>encourage people how and when to use them to prevent abuses. I think<br>language features cannot prevent abuses, and it is a role of coding<br>guidelines.<br></p><p>So I think it is good to unify `Optional`s, `throws` and `Result`s.<br>But because it seemed too radical, I proposed the part of it at first:<br>`throws -&gt; Foo` as a syntactic sugar of `-&gt; Result&lt;Foo&gt;`.<br></p><p><br>&gt; I&#39;d rather see us adopt an<br>&gt; extensible algebraic effects system, something like http://www.eff-lang.org,<br>&gt; which provides a framework for `throws`, `async` and other control flow<br>&gt; effects to be cleanly composed and abstracted over. I see `throws` as the<br>&gt; first seed of that.<br></p><p>Thank you for the information. Because I am not familiar with Eff, I<br>will check it. If it composes multiple abstractions well, it must be<br>great!<br></p><p>-- Yuta<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 6:39 AM, Yuta Koshizawa &lt;koher at koherent.org&gt; wrote:<br>&gt; <br>&gt; 2016-03-15 2:23 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; Yeah, we extensively discussed adding a Result type internally, but<br>&gt;&gt; ultimately couldn&#39;t justify it. The only real use case we could see in the<br>&gt;&gt; wild was for threading errors through CPS-inversion-style abstractions like<br>&gt;&gt; async promises, something we hope to provide proper language support for.<br>&gt;&gt; More generally, expressing effects as monadic values is a pretty awful<br>&gt;&gt; abstraction; aside from polluting the Internet with an endless deluge of<br>&gt;&gt; unhelpful tutorials, they also don&#39;t compose cleanly, they impose nesting<br>&gt;&gt; where is desired—you have to pick between Result&lt;Async&lt;T&gt;&gt; and<br>&gt;&gt; Async&lt;Result&lt;T&gt;&gt;, or build ResultT&lt;AsyncT&lt;Identity&gt;&gt;&lt;T&gt; out of monad<br>&gt;&gt; transformers—and they don&#39;t do the natural thing when used with other<br>&gt;&gt; higher-order abstractions—if you&#39;re mapping a `throws` function over a<br>&gt;&gt; collection, you probably want to propagate that error like `rethrows` does,<br>&gt;&gt; not end up with a collection of Result&lt;T&gt;.<br>&gt; <br>&gt; Yes, I know the pain of nested monads and I don&#39;t want to encourage<br>&gt; monadic error handling with awful nests.<br>&gt; <br>&gt; To tell the truth, I ultimately desire to unify `Optional`s, `throws`<br>&gt; and `Result`s.<br>&gt; <br>&gt; We have already had `Optional`s which can be used in a monadic way. To<br>&gt; prevent excessive monadic handling, I think we need Automatic<br>&gt; Propagation for `Optional`s.<br>&gt; <br>&gt; ```<br>&gt; // Automatic Propagation for `Optional`s<br>&gt; let a: Int? = ...<br>&gt; let b: Int? = ...<br>&gt; <br>&gt; do {<br>&gt;  let sum: Int = (try a) + (try b)<br>&gt;  ...<br>&gt; } catch { // if `a` and/or `b` are `nil`<br>&gt;  ...<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Although &quot;Error Handling Rational and Proposal&quot; says `Optional`s<br>&gt; should be used for simple domain errors and are suitable for Manual<br>&gt; Propagation, I think Automatic Propagation is also useful for<br>&gt; `Optional`s. We get `nil` not only as errors but also as empty values.<br>&gt; Our codes are full of `Optional`s. Handling them manually costs a lot.<br>&gt; So I think it is good to have Automatic Propagation for `Optional`s.<br>&gt; <br>&gt; However it is confusing to mix `Optional`s and `throws` functions with<br>&gt; the same keyword `try`. So I think something like `typealias<br>&gt; Optional&lt;T&gt; = Result&lt;T, NilError&gt;`, which could be identical in a<br>&gt; binary form to current `Optional` with `struct NilError: ErrorType<br>&gt; {}`, and unified `throws` and `Result`s would be better. Then we would<br>&gt; have only `Result`s, but it could be used as `Optional`s and `throws`.<br>&gt; <br>&gt; Although `Result`s might make it possible to abuse monadic error<br>&gt; handling, problems of abuses are also true for other language<br>&gt; features: e.g. `(Float, Float)` as `Vector2` instead of `struct<br>&gt; Vector2 { ... }` for tuples. Even if we keep `Optional`s and `throws`<br>&gt; separated, `Optional`s can be handled monadically and we need to<br>&gt; encourage people how and when to use them to prevent abuses. I think<br>&gt; language features cannot prevent abuses, and it is a role of coding<br>&gt; guidelines.<br>&gt; <br>&gt; So I think it is good to unify `Optional`s, `throws` and `Result`s.<br>&gt; But because it seemed too radical, I proposed the part of it at first:<br>&gt; `throws -&gt; Foo` as a syntactic sugar of `-&gt; Result&lt;Foo&gt;`.<br></p><p>I agree, it&#39;s nice to be able to open optionals and avoid direct monadic manipulations too. Optionals can be lifted and extracted from a `throws` body fairly easily already, much like a `Result`:<br></p><p>enum Nil: ErrorType { case Nil }<br>extension Optional {<br>  func getOrThrow() throws -&gt; Wrapped {<br>    if let x = self { return x }<br>    throw Nil.Nil <br>  }<br>}<br>func doOrNil&lt;T, U&gt;(f: (T) throws -&gt; U, x: T) -&gt; U? {<br>  do {<br>    return try f(x)<br>  } catch {<br>    return nil<br>  }<br>}<br></p><p>The latter is provided by the language as `try?` already. If we had typed `throws`, it would be nice to be able to express `throws Nil` more precisely, of course.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; I&#39;d rather see us adopt an<br>&gt;&gt; extensible algebraic effects system, something like http://www.eff-lang.org,<br>&gt;&gt; which provides a framework for `throws`, `async` and other control flow<br>&gt;&gt; effects to be cleanly composed and abstracted over. I see `throws` as the<br>&gt;&gt; first seed of that.<br>&gt; <br>&gt; Thank you for the information. Because I am not familiar with Eff, I<br>&gt; will check it. If it composes multiple abstractions well, it must be<br>&gt; great!<br>&gt; <br>&gt; -- Yuta<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/9c755671/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>throws as returning a Result</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>March 17, 2016 at 09:00:00am</p></header><div class="content"><p>2016-03-16 2:03 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt;<br>&gt; On Mar 15, 2016, at 6:39 AM, Yuta Koshizawa &lt;koher at koherent.org&gt; wrote:<br>&gt;<br>&gt; 2016-03-15 2:23 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt;<br>&gt;<br>&gt; Yeah, we extensively discussed adding a Result type internally, but<br>&gt; ultimately couldn&#39;t justify it. The only real use case we could see in the<br>&gt; wild was for threading errors through CPS-inversion-style abstractions like<br>&gt; async promises, something we hope to provide proper language support for.<br>&gt; More generally, expressing effects as monadic values is a pretty awful<br>&gt; abstraction; aside from polluting the Internet with an endless deluge of<br>&gt; unhelpful tutorials, they also don&#39;t compose cleanly, they impose nesting<br>&gt; where is desired—you have to pick between Result&lt;Async&lt;T&gt;&gt; and<br>&gt; Async&lt;Result&lt;T&gt;&gt;, or build ResultT&lt;AsyncT&lt;Identity&gt;&gt;&lt;T&gt; out of monad<br>&gt; transformers—and they don&#39;t do the natural thing when used with other<br>&gt; higher-order abstractions—if you&#39;re mapping a `throws` function over a<br>&gt; collection, you probably want to propagate that error like `rethrows` does,<br>&gt; not end up with a collection of Result&lt;T&gt;.<br>&gt;<br>&gt;<br>&gt; Yes, I know the pain of nested monads and I don&#39;t want to encourage<br>&gt; monadic error handling with awful nests.<br>&gt;<br>&gt; To tell the truth, I ultimately desire to unify `Optional`s, `throws`<br>&gt; and `Result`s.<br>&gt;<br>&gt; We have already had `Optional`s which can be used in a monadic way. To<br>&gt; prevent excessive monadic handling, I think we need Automatic<br>&gt; Propagation for `Optional`s.<br>&gt;<br>&gt; ```<br>&gt; // Automatic Propagation for `Optional`s<br>&gt; let a: Int? = ...<br>&gt; let b: Int? = ...<br>&gt;<br>&gt; do {<br>&gt;  let sum: Int = (try a) + (try b)<br>&gt;  ...<br>&gt; } catch { // if `a` and/or `b` are `nil`<br>&gt;  ...<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Although &quot;Error Handling Rational and Proposal&quot; says `Optional`s<br>&gt; should be used for simple domain errors and are suitable for Manual<br>&gt; Propagation, I think Automatic Propagation is also useful for<br>&gt; `Optional`s. We get `nil` not only as errors but also as empty values.<br>&gt; Our codes are full of `Optional`s. Handling them manually costs a lot.<br>&gt; So I think it is good to have Automatic Propagation for `Optional`s.<br>&gt;<br>&gt; However it is confusing to mix `Optional`s and `throws` functions with<br>&gt; the same keyword `try`. So I think something like `typealias<br>&gt; Optional&lt;T&gt; = Result&lt;T, NilError&gt;`, which could be identical in a<br>&gt; binary form to current `Optional` with `struct NilError: ErrorType<br>&gt; {}`, and unified `throws` and `Result`s would be better. Then we would<br>&gt; have only `Result`s, but it could be used as `Optional`s and `throws`.<br>&gt;<br>&gt; Although `Result`s might make it possible to abuse monadic error<br>&gt; handling, problems of abuses are also true for other language<br>&gt; features: e.g. `(Float, Float)` as `Vector2` instead of `struct<br>&gt; Vector2 { ... }` for tuples. Even if we keep `Optional`s and `throws`<br>&gt; separated, `Optional`s can be handled monadically and we need to<br>&gt; encourage people how and when to use them to prevent abuses. I think<br>&gt; language features cannot prevent abuses, and it is a role of coding<br>&gt; guidelines.<br>&gt;<br>&gt; So I think it is good to unify `Optional`s, `throws` and `Result`s.<br>&gt; But because it seemed too radical, I proposed the part of it at first:<br>&gt; `throws -&gt; Foo` as a syntactic sugar of `-&gt; Result&lt;Foo&gt;`.<br>&gt;<br>&gt;<br>&gt; I agree, it&#39;s nice to be able to open optionals and avoid direct monadic<br>&gt; manipulations too. Optionals can be lifted and extracted from a `throws`<br>&gt; body fairly easily already, much like a `Result`:<br>&gt;<br>&gt; enum Nil: ErrorType { case Nil }<br>&gt; extension Optional {<br>&gt;   func getOrThrow() throws -&gt; Wrapped {<br>&gt;     if let x = self { return x }<br>&gt;     throw Nil.Nil<br>&gt;   }<br>&gt; }<br>&gt; func doOrNil&lt;T, U&gt;(f: (T) throws -&gt; U, x: T) -&gt; U? {<br>&gt;   do {<br>&gt;     return try f(x)<br>&gt;   } catch {<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The latter is provided by the language as `try?` already. If we had typed<br>&gt; `throws`, it would be nice to be able to express `throws Nil` more<br>&gt; precisely, of course.<br></p><p>I would still want `try` to unwrap `Optional`s even if we had<br>`getOrThrow`. Although the difference is slight, I think it is<br>important. I choose an alternative way, e.g. an applicative style, if<br>we need some extra works to unwrap `Optional`s besides just writing<br>`try`.<br></p><p>But I think it is out of scope of this thread: `Result` and `throws. I<br>will start another thread for it. Thanks for the discussion.<br></p><p>-- Yuta<br></p><p>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; I&#39;d rather see us adopt an<br>&gt; extensible algebraic effects system, something like http://www.eff-lang.org,<br>&gt; which provides a framework for `throws`, `async` and other control flow<br>&gt; effects to be cleanly composed and abstracted over. I see `throws` as the<br>&gt; first seed of that.<br>&gt;<br>&gt;<br>&gt; Thank you for the information. Because I am not familiar with Eff, I<br>&gt; will check it. If it composes multiple abstractions well, it must be<br>&gt; great!<br>&gt;<br>&gt; -- Yuta<br>&gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
