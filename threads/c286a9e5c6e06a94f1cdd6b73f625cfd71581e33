<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  3, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>There are quite a few programming languages that provide support for<br>numeric types apart from the customary floating-point and fixed-width<br>integer types. Prominent examples of additional numeric types include<br>rational numbers, arbitrary-width integer types, and fixed-point numbers.<br>Many of these numeric types are applicable to a wide variety of problem<br>domains.<br></p><p>Swift seems like it would be a good fit for stdlib implementation of some<br>of these numeric types. Structs and value semantics, literal<br>initialization, and operator overloading would allow such types to be<br>treated as first-class citizens. Is the community amenable to such a<br>proposal, which would entail the data structures themselves, arithmetic<br>operations, and interoperation between different numeric types to form a<br>numerical tower of sorts?<br></p><p>Best regards,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/c2861e33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>On Dec 3, 2015, at 1:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; There are quite a few programming languages that provide support for numeric types apart from the customary floating-point and fixed-width integer types. Prominent examples of additional numeric types include rational numbers, arbitrary-width integer types, and fixed-point numbers. Many of these numeric types are applicable to a wide variety of problem domains.<br></p><p>Hi Austin, great to hear from you:<br></p><p>It would be great to consider this.  We?ve specifically recently discussed BigInt support, for example.  <br></p><p>One of the things that we?d like to see for Swift 3 is a revised set of numerics protocols, to make it possible to write generic numeric algorithms.  One concern I have with this is that abstracting over (e.g.) IEEE and rational numbers may overly complicate the protocols necessary to get simple things done.<br></p><p>That said, I?m not an expert on this area, so I?m cc?ing some people who are :-)<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Swift seems like it would be a good fit for stdlib implementation of some of these numeric types. Structs and value semantics, literal initialization, and operator overloading would allow such types to be treated as first-class citizens. Is the community amenable to such a proposal, which would entail the data structures themselves, arithmetic operations, and interoperation between different numeric types to form a numerical tower of sorts?<br>&gt; <br>&gt; Best regards,<br>&gt; Austin<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/1bc97b56/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>On Thu, Dec 3, 2015 at 1:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; There are quite a few programming languages that provide support for numeric types apart from the customary floating-point and fixed-width integer types. Prominent examples of additional numeric types include rational numbers, arbitrary-width integer types, and fixed-point numbers. Many of these numeric types are applicable to a wide variety of problem domains.<br></p><p>&gt;<br>&gt; Swift seems like it would be a good fit for stdlib implementation of some of these numeric types. Structs and value semantics, literal initialization, and operator overloading would allow such types to be treated as first-class citizens. Is the community amenable to such a proposal, which would entail the data structures themselves, arithmetic operations, and interoperation between different numeric types to form a numerical tower of sorts?<br></p><p>Hi Austin,<br></p><p>We are interested in improving our numerics support, and we are<br>definitely interested in hearing your ideas in this space.  You don&#39;t<br>have to write a full proposal though.  Just an extended email to<br>swift-evolution would be a good start.<br></p><p>You can find the current prototype for library support for integers<br>here: https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  3, 2015 at 06:00:00pm</p></header><div class="content"><p>Thanks, Chris and Dmitri! I will do some research and write something up<br>over the weekend.<br></p><p>Austin<br></p><p>On Thu, Dec 3, 2015 at 2:24 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Thu, Dec 3, 2015 at 1:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; There are quite a few programming languages that provide support for<br>&gt; numeric types apart from the customary floating-point and fixed-width<br>&gt; integer types. Prominent examples of additional numeric types include<br>&gt; rational numbers, arbitrary-width integer types, and fixed-point numbers.<br>&gt; Many of these numeric types are applicable to a wide variety of problem<br>&gt; domains.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Swift seems like it would be a good fit for stdlib implementation of<br>&gt; some of these numeric types. Structs and value semantics, literal<br>&gt; initialization, and operator overloading would allow such types to be<br>&gt; treated as first-class citizens. Is the community amenable to such a<br>&gt; proposal, which would entail the data structures themselves, arithmetic<br>&gt; operations, and interoperation between different numeric types to form a<br>&gt; numerical tower of sorts?<br>&gt;<br>&gt; Hi Austin,<br>&gt;<br>&gt; We are interested in improving our numerics support, and we are<br>&gt; definitely interested in hearing your ideas in this space.  You don&#39;t<br>&gt; have to write a full proposal though.  Just an extended email to<br>&gt; swift-evolution would be a good start.<br>&gt;<br>&gt; You can find the current prototype for library support for integers<br>&gt; here:<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/d1153422/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  3, 2015 at 09:00:00pm</p></header><div class="content"><p>Dear swift-evolution,<br></p><p>I less want to make concrete proposals than start a conversation about<br>expanded numerical support in Swift. In that spirit, here are some thoughts:<br></p><p>Arbitrary-precision integers (bigints) are a logical first step. Bigints<br>then enable practical support for rationals. (With bigints, rational<br>operations need not fail because of integer overflow.) Adding at least<br>these two numerical types would bring Swift far closer wrt numerical<br>support wrt languages like Clojure or Ruby.<br></p><p>Many languages make a distinction between fixed precision integers and<br>bigints (i.e. Haskell&#39;s Int vs Integer). I propose the definition of two<br>related types: ArbitraryPrecisionInteger and Integer.<br></p><p>ArbitraryPrecisionInteger is a struct wrapping a pointer to a byte buffer,<br>much like how Swift&#39;s Array, Set, and Dictionary collection types work<br>(c.f.<br>https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html).<br>It wraps an arbitrarily large integer within a container adhering to value<br>semantics. Perhaps this can be exposed as part of the stdlib, or a<br>&#39;private&#39; implementation detail.<br></p><p>Integer is intended to be used by application developers, and most of the<br>arithmetic/comparison functionality exposed by the stdlib deals with<br>arguments and return values of type Integer. Integers are enums:<br></p><p>enum Integer {<br>case Small(Int)<br>case Big(ArbitraryPrecisionInteger)<br>}<br></p><p>Like ArbitraryPrecisionInteger, Integer represents an arbitrary-precision<br>integer. It wraps either a fixed-size (64-bit) signed integer, or a bigint.<br>Integer&#39;s invariant is that integers within the range of an Int are always<br>stored as an Int. This is enforced by the mathematical operations defined<br>on arguments of type Integer. This allows for a slow path (consisting of<br>operations that are conducted on ArbitraryPrecisionIntegers), and a fast<br>path (consisting of checked operations on Ints, with automatic promotion to<br>ArbitraryPrecisionInteger as necessary). Fast path operations, in the best<br>case, need not allocate heap memory or invoke retain/release operations.<br></p><p>Integers can be unconditionally constructed (promoted) from Ints, and can<br>be conditionally demoted to Ints ( () -&gt; Int? ). (All Ints are Integers,<br>but not all Integers are Ints.)<br></p><p>A useful compiler support feature might be a &quot;BigIntegerLiteralConvertible&quot;<br>protocol, which allows literal integers out of the range of Ints to be<br>assigned to Integer values. Swift can already tell if an integer literal is<br>out of range (e.g. &quot;let x : Int8 = 123456&quot;), so there is some precedent.<br>This would be a more elegant solution than requiring bigints to be<br>initialized via strings (as some other arbitrary precision arithmetic<br>libraries do).<br></p><p>Rational numbers are represented by the Rational struct which encapsulates<br>two Integers, the numerator and denominator. Rationals can be conditionally<br>constructed explicitly from two Integers (as long as the denominator isn&#39;t<br>0), or from a single Integer (all Integers are Rationals, but the opposite<br>is not true). A good invariant for Rationals might be having them always<br>represented in the most simplified form - for example, Rational(2, 6)<br>should be represented internally as 1/3 when constructed.<br></p><p>Future topics to explore include complex numbers, arbitrary-precision<br>floating-point numbers, and fixed-precision and/or decimal number types.<br></p><p>Given that I&#39;m little more than a dabbler in these topics (most of my<br>expertise came from trying to reverse-assemble Clojure&#39;s numerical<br>support), feedback from someone with experience and/or expertise wrt<br>numerical/scientific computing, bignum libraries, numerical towers, etc.<br>would be hugely appreciated.<br></p><p>Best regards,<br>Austin<br></p><p><br>On Thu, Dec 3, 2015 at 6:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; Thanks, Chris and Dmitri! I will do some research and write something up<br>&gt; over the weekend.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Thu, Dec 3, 2015 at 2:24 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Thu, Dec 3, 2015 at 1:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi all,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There are quite a few programming languages that provide support for<br>&gt;&gt; numeric types apart from the customary floating-point and fixed-width<br>&gt;&gt; integer types. Prominent examples of additional numeric types include<br>&gt;&gt; rational numbers, arbitrary-width integer types, and fixed-point numbers.<br>&gt;&gt; Many of these numeric types are applicable to a wide variety of problem<br>&gt;&gt; domains.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift seems like it would be a good fit for stdlib implementation of<br>&gt;&gt; some of these numeric types. Structs and value semantics, literal<br>&gt;&gt; initialization, and operator overloading would allow such types to be<br>&gt;&gt; treated as first-class citizens. Is the community amenable to such a<br>&gt;&gt; proposal, which would entail the data structures themselves, arithmetic<br>&gt;&gt; operations, and interoperation between different numeric types to form a<br>&gt;&gt; numerical tower of sorts?<br>&gt;&gt;<br>&gt;&gt; Hi Austin,<br>&gt;&gt;<br>&gt;&gt; We are interested in improving our numerics support, and we are<br>&gt;&gt; definitely interested in hearing your ideas in this space.  You don&#39;t<br>&gt;&gt; have to write a full proposal though.  Just an extended email to<br>&gt;&gt; swift-evolution would be a good start.<br>&gt;&gt;<br>&gt;&gt; You can find the current prototype for library support for integers<br>&gt;&gt; here:<br>&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/c8c3026e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  3, 2015 at 09:00:00pm</p></header><div class="content"><p>On Thu, Dec 3, 2015 at 9:22 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; Integer is intended to be used by application developers, and most of the<br>&gt; arithmetic/comparison functionality exposed by the stdlib deals with<br>&gt; arguments and return values of type Integer.<br></p><p>So one would use Integer, which is capable of representing arbitrary<br>precision integers, most of the time?  We have considered this in the<br>past.  The concern is that the branches that this introduces<br>everywhere and the code bloat wouldn&#39;t allow Swift to achieve C-like<br>performance.<br></p><p>We are considering adding an arbitrary precision integer type, though.<br></p><p>&gt; A useful compiler support feature might be a &quot;BigIntegerLiteralConvertible&quot;<br>&gt; protocol, which allows literal integers out of the range of Ints to be<br>&gt; assigned to Integer values. Swift can already tell if an integer literal is<br>&gt; out of range (e.g. &quot;let x : Int8 = 123456&quot;), so there is some precedent.<br></p><p>Swift&#39;s integer literal convertible protocol supports integers up to<br>2048 bits.  This is sufficient for all practical purposes, I think.<br></p><p>&gt; Rational numbers are represented by the Rational struct which encapsulates<br>&gt; two Integers, the numerator and denominator. Rationals can be conditionally<br>&gt; constructed explicitly from two Integers (as long as the denominator isn&#39;t<br>&gt; 0), or from a single Integer (all Integers are Rationals, but the opposite<br>&gt; is not true).<br></p><p>Yep, this is pretty standard.  How do you propose to model &quot;Integers<br>are Rationals&quot; in Swift?<br></p><p>&gt; A good invariant for Rationals might be having them always<br>&gt; represented in the most simplified form - for example, Rational(2, 6) should<br>&gt; be represented internally as 1/3 when constructed.<br></p><p>This has performance tradeoffs.  What do other libraries and languages do?<br></p><p>&gt; Future topics to explore include complex numbers, arbitrary-precision<br>&gt; floating-point numbers, and fixed-precision and/or decimal number types.<br></p><p>What about protocols, operations and algorithms?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>On Dec 3, 2015, at 9:48 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; A good invariant for Rationals might be having them always<br>&gt;&gt; represented in the most simplified form - for example, Rational(2, 6) should<br>&gt;&gt; be represented internally as 1/3 when constructed.<br>&gt; <br>&gt; This has performance tradeoffs.  What do other libraries and languages do?<br></p><p>I know Haskell always reduces Rationals to their reduced form. This does have performance implications, but not doing so has surprising consequences for operations you perform on them. For example, it?s reasonable to expect that Rational(2,6) == Rational(1,3), but implementing that without reduced Rationals pretty much requires reducing them on the fly. The alternative, of saying they?re not equal, would probably surprise most people.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>Clojure also performs automatic reduction of rational numbers. However, the<br>source code seems to indicate that reduction is built into the definitions<br>of the methods that perform arithmetic on rational numbers, and the &quot;Ratio&quot;<br>class that implements rational number support does not do any reduction<br>itself.<br></p><p>(c.f.<br>https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Numbers.java,<br>ll. 350-364, 704-727, et al)<br></p><p>&gt;From a semantic standpoint, I would be very surprised if e.g. 2/6 and 1/3<br>were not considered equal, or for that matter if they weren&#39;t completely<br>interchangeable.<br></p><p>- Austin<br></p><p>On Thu, Dec 3, 2015 at 11:21 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; On Dec 3, 2015, at 9:48 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; A good invariant for Rationals might be having them always<br>&gt; &gt;&gt; represented in the most simplified form - for example, Rational(2, 6)<br>&gt; should<br>&gt; &gt;&gt; be represented internally as 1/3 when constructed.<br>&gt; &gt;<br>&gt; &gt; This has performance tradeoffs.  What do other libraries and languages<br>&gt; do?<br>&gt;<br>&gt; I know Haskell always reduces Rationals to their reduced form. This does<br>&gt; have performance implications, but not doing so has surprising consequences<br>&gt; for operations you perform on them. For example, it?s reasonable to expect<br>&gt; that Rational(2,6) == Rational(1,3), but implementing that without reduced<br>&gt; Rationals pretty much requires reducing them on the fly. The alternative,<br>&gt; of saying they?re not equal, would probably surprise most people.<br>&gt;<br>&gt; -Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/d4edb0e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>If Swift?s Ints may go up to 2048 bits, I?d agree that they probably cover most cases. That?s not to say a big int would be useless, just that I think it should be separate, meant to be used by those who actually need it rather than interfering with normal Int logic, which is likely to be used more often.<br></p><p>&gt; On Dec 4, 2015, at 2:45 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Clojure also performs automatic reduction of rational numbers. However, the source code seems to indicate that reduction is built into the definitions of the methods that perform arithmetic on rational numbers, and the &quot;Ratio&quot; class that implements rational number support does not do any reduction itself.<br>&gt; <br>&gt; (c.f. https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Numbers.java &lt;https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Numbers.java&gt;, ll. 350-364, 704-727, et al)<br>&gt; <br>&gt; From a semantic standpoint, I would be very surprised if e.g. 2/6 and 1/3 were not considered equal, or for that matter if they weren&#39;t completely interchangeable.<br>&gt; <br>&gt; - Austin<br>&gt; <br>&gt; On Thu, Dec 3, 2015 at 11:21 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt; On Dec 3, 2015, at 9:48 PM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; A good invariant for Rationals might be having them always<br>&gt; &gt;&gt; represented in the most simplified form - for example, Rational(2, 6) should<br>&gt; &gt;&gt; be represented internally as 1/3 when constructed.<br>&gt; &gt;<br>&gt; &gt; This has performance tradeoffs.  What do other libraries and languages do?<br>&gt; <br>&gt; I know Haskell always reduces Rationals to their reduced form. This does have performance implications, but not doing so has surprising consequences for operations you perform on them. For example, it?s reasonable to expect that Rational(2,6) == Rational(1,3), but implementing that without reduced Rationals pretty much requires reducing them on the fly. The alternative, of saying they?re not equal, would probably surprise most people.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b930887b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Expanded support for numeric types in stdlib?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  5, 2015 at 09:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 6:13 AM, Vinicius Vendramini<br>&lt;vinivendra at gmail.com&gt; wrote:<br>&gt;<br>&gt; If Swift’s Ints may go up to 2048 bits, I’d agree that they probably cover most cases. That’s not to say a big int would be useless, just that I think it should be separate, meant to be used by those who actually need it rather than interfering with normal Int logic, which is likely to be used more often.<br></p><p>Swift&#39;s &#39;Int&#39;s are pointer-sized.  Swift&#39;s integer literals can be up<br>to 2048 bits, which allows one to write types (e.g., BigInt) that can<br>be initialized from large literals.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
