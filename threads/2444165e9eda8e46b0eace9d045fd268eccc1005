<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jun 23 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As previously threatened mentioned, I&#39;ve written a draft proposal to<br>&gt; fix a number of naming issues with APIs operating on the beginning and<br>&gt; end of Sequences and Collections:<br>&gt;<br>&gt; • Inconsistent use of `prefix`/`suffix` vs. `first`/`last`<br>&gt; • Confusing naming of `drop` methods<br>&gt; • Ambiguous naming of `index(of:/where:)` and `drop(while:)`<br>&gt; • `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` shouldn&#39;t<br>&gt; be part of this family at all<br>&gt;<br>&gt; To fix this, I propose:<br>&gt;<br>&gt; • Renaming all methods which operate on more than one element at the<br>&gt; beginning/end to use &quot;prefix&quot; or &quot;suffix&quot;, not &quot;first&quot; or &quot;last&quot;<br>&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and<br>&gt; `first(where:)` to `earliest(where:)`<br></p><p>What&#39;s wrong with firstIndex(of:/where:) [and lastIndex(of:/where:)]?<br>That seems like a much less esoteric way to phrase it that meshes well<br>with the meanings of<br></p><p>     xs.first<br>     xs.indices.first<br></p><p>etc.<br></p><p>&gt; • Renaming the `drop` methods to use `removing`<br></p><p>Very clever!  I *like*.<br></p><p>&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)`<br>&gt; as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps<br>&gt; `people[nil..&lt;idx]`.<br></p><p>Yes please; I really want this.  This part is a slightly nontrivial<br>design problem, though.  Someone should build an implementation before<br>the actual design is proposed.  Probably the best way would be to<br>leave prefix and suffix alone for the moment and add/test the new<br>subscripts.<br></p><p>&gt; Since that last point requires significant redesign, including the<br>&gt; introduction of new types, I have also included an alternative design<br>&gt; which uses `people[to: idx]` instead.<br></p><p>I really don&#39;t like using labels for this, because stride(to:) and<br>stride(through:) have already spawned a naming bikeshed with no clear<br>resolution, suggesting that no name works.  Plus, the ..&lt; operator<br>already implies the name.<br></p><p>&gt; This proposal does not seek to add new functionality; it merely<br>&gt; renames or (in the case of the &quot;aggressive&quot; subscript option)<br>&gt; redesigns existing functionality. I do, however, discuss (without<br>&gt; making many judgements about their wisdom) how these changes might<br>&gt; affect the naming of functionality we might add in future versions of<br>&gt; Swift.<br></p><p>Good.<br></p><p>&gt; I would mainly like feedback on the two most open questions left in<br>&gt; this proposal:<br>&gt;<br>&gt; • The choice of `removing` to replace `drop`<br></p><p>It&#39;s 100% appropriate, provided that the APIs match some corresponding<br>mutating remove API.  Nonmutating operations are often implemented via<br>lazy adaptors... which a slice can be viewed to be.  So I think this is<br>a beautiful answer.<br></p><p>&gt; • The decision about whether to use `people[..&lt;idx]`,<br>&gt; `people[nil..&lt;idx]`, or `people[to: idx]`.<br></p><p>I prefer how the first one reads.<br></p><p>&gt; But I&#39;d also like comments on the rest of the proposal, and on whether<br>&gt; I should split the prefix(upTo:/through:)/suffix(from:) changes into a<br>&gt; separate proposal from the rest.<br></p><p>I very much appreciate that you&#39;re addressing all of these at once.<br></p><p>&gt; I suspect this will cause a firestorm of bikeshedding, so please try<br>&gt; to keep your suggestions grounded. Don&#39;t just suggest a name;<br>&gt; articulate why it&#39;s a better choice than what we already have or what<br>&gt; this proposal suggests. Only you can prevent our first<br>&gt; *three*-hundred-message bikeshedding thread.<br>&gt;<br>&gt; Thanks for your attention!<br>&gt;<br>&gt; (P.S. The proposal below includes several huge tables which may cause<br>&gt; some mail clients to become very pouty and refuse to eat their<br>&gt; supper. You may want to read the proposal at<br>&gt; &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430<br>&gt; &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430&gt;&gt;<br>&gt; instead.)<br>&gt;<br>&gt; The Sequence and Collection protocols offer a wide variety of APIs which<br>&gt; are defined to operate on, or from, one end of the sequence:<br>&gt; <br>&gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)  <br></p><p>I think you want “Operation” or “Semantics” rather than “Operand” (which<br>means an argument to an operation)<br></p><p>&gt; Fixed Size        <br>&gt; First 1 C.first - S.dropFirst() C.removeFirst() C.popFirst() -  <br>&gt; Last 1 C.last - S.dropLast() C.removeLast() C.popLast() -  <br>&gt; First (n: Int) S.prefix(_:) - S.dropFirst(_:) C.removeFirst(_:) - S.starts(with:)  <br>&gt; ...with closure S.prefix(while:) - S.drop(while:) - - S.starts  <br>&gt;       (with:isEquivalent:)  <br>&gt; Last (n: Int) S.suffix(_:) - S.dropLast(_:) C.removeLast(_:) - -  <br>&gt; ...with closure - - - - - -  <br>&gt; Searching From End        <br>&gt; First matching - C.index(of:) - - - -  <br>&gt; element        <br>&gt; ...with closure S.first(where:) C.index(where:) - - - -  <br>&gt; Last matching element - - - - - -  <br>&gt; ...with closure - - - - - -  <br>&gt; Based on Index        <br>&gt; startIndex ..&lt; (i: Index) C.prefix(upTo:) - - - - -  <br>&gt; startIndex ... (i: Index) C.prefix(through:) - - - - -  <br>&gt; (i: Index) ..&lt; endIndex C.suffix(from:) - - - - -  <br>&gt; <br>&gt;  I have included several blank rows for operands which fit the APIs&#39; patterns, even if they don&#39;t happen to have any operations currently.<br>&gt; <br>&gt;  Type abbreviations:<br>&gt; <br>&gt;  * S = Sequence<br>&gt;  * C = Collection (or a sub-protocol like BidirectionalCollection)<br>&gt; <br>&gt;  Notes:<br>&gt; <br>&gt;  1 remove and pop both mutate the array to delete the indicated element(s), but remove assumes as a precondition that the indicated elements exist, while pop<br>&gt;  checks whether or not they exist.<br>&gt; <br>&gt;  2 String and NSString have bespoke versions of first n and last n Equate operations, in the form of their hasPrefix and hasSuffix methods.<br>&gt; <br>&gt; Leaving aside the question of whether any gaps in these tables ought to be filled, I see a number of issues with existing terminology.<br>&gt; <br>&gt; SVG ImageInconsistent use of prefix and suffix<br>&gt; <br>&gt; Some APIs which operate on a variable number of elements anchored at one end or the other use the terms prefix or suffix:<br>&gt; <br>&gt; * Sequence.prefix(_:) and Sequence.suffix(_:)<br>&gt; * Sequence.prefix(while:)<br>&gt; * String.hasPrefix(_:) and String.hasSuffix(_:)<br>&gt; <br>&gt; Others, however, use first or last:<br>&gt; <br>&gt; * Sequence.dropFirst(_:) and Sequence.dropLast(_:)<br>&gt; * Sequence.removeFirst(_:) and Sequence.removeLast(_:)<br>&gt; <br>&gt; Still others use neither:<br>&gt; <br>&gt; * Sequence.starts(with:)<br>&gt; * Sequence.drop(while:)<br>&gt; <br>&gt; These methods are all closely related, but because of this inconsistent terminology, they fail to form predictable method families.<br>&gt; <br>&gt; SVG Imagefirst has multiple meanings<br>&gt; <br>&gt; The word first can mean three different things in these APIs:<br>&gt; <br>&gt; * Just the very first element of the sequence.<br>&gt; <br>&gt; * A subsequence of elements anchored at the beginning of the sequence,<br>&gt;   as mentioned in the last point.<br>&gt; <br>&gt; * The first element encountered in the sequence which matches a given<br>&gt;   criterion when walking from the beginning of the sequence towards the<br>&gt;   end.<br>&gt; <br>&gt; It would be nice to have more clarity here.<br></p><p>You seem to be suggesting that a word needs to mean exactly the same<br>thing regardless of context.  If so, I disagree.  If I say “the first<br>element” or “the first element greater than 5” there&#39;s absolutely no<br>lack of clarity AFAICT.  That accounts for the first and last bullets<br></p><p>The usage in the middle bullet is open to misinterpretation and I would<br>support fixing that.<br></p><p>     xs.removeFirst(42)<br></p><p>could read like, “remove the first element equal to 42.”<br></p><p>&gt; SVG Imagedrop is misleading and scary<br>&gt; <br>&gt; In a Swift context, I believe the drop methods are actively confusing:<br>&gt; <br>&gt; * drop does not have the -ing or -ed suffix normally used for a<br>&gt; nonmutating method.<br>&gt; <br>&gt; * drop has strong associations with destructive operations; it&#39;s the<br>&gt; term used, for instance, for deleting whole tables in SQL. Even<br>&gt; dropping would probably sound more like a mutating operation than<br>&gt; alternatives.<br>&gt; <br>&gt; * As previously mentioned, the use of dropFirst and dropLast for<br>&gt; single-drop operations and multiple-drop operations breaks up method<br>&gt; families.<br>&gt; <br>&gt; drop, dropFirst, and dropLast are terms of art, so we allow them a<br>&gt; certain amount of leeway. However, I believe the drop functions go<br>&gt; well beyond what we should<br>&gt; permit. They are relatively uncommon operations, associated primarily<br>&gt; with functional languages rather than mainstream object-oriented or<br>&gt; imperative languages, and<br>&gt; their violation of the normal Swift naming guidelines is especially<br>&gt; misleading.<br>&gt; <br>&gt; The term-of-art exception is not a suicide pact; <br></p><p>Tatoo that on your forehead, mister!<br></p><p>&gt; it is meant to aid understanding by importing common terminology, not<br>&gt; bind us to follow every decision made by any language that came before<br>&gt; us. In this case, I think we should ignore precedent and forge our own<br>&gt; path.<br>&gt; <br>&gt; SVG ImageUnstated direction of operation<br>&gt; <br>&gt; Several APIs could theoretically be implemented by working from either<br>&gt; end of the sequence, and would return different results depending on<br>&gt; the direction, but do not indicate the direction in their names:<br>&gt; <br>&gt; * Sequence.drop(while:)<br>&gt; * Collection.index(of:)<br>&gt; <br>&gt; Adding a direction to these APIs would make their behavior clearer and permit us to offer opposite-end equivalents in the future. (Unmerged swift-evolution pull<br>&gt; request 329 would add lastIndex methods.)<br>&gt; <br>&gt; SVG ImageThe index(...) base name has been polluted<br>&gt; <br>&gt; Swift 3&#39;s new collection model placed a number of low-level index<br>&gt; manipulating operations on the base method name index. These now share<br>&gt; that name with index(of:) and index(where:), which are much<br>&gt; higher-level operations. This may be confusing for users looking for<br>&gt; high-level operations; the only real relationship between the two sets<br>&gt; of operations is that they both return an index.<br></p><p>There&#39;s another relationship.  Once you call the high-level operation,<br>you&#39;re now in the domain of indexing, and are very likely to ask for the<br>index(after:) the one you found.<br></p><p>&gt; It would be nice to separate these two groups of methods into<br>&gt; different families.<br></p><p>I used to think that was important, but I no longer do given the above.<br></p><p>&gt; SVG ImageOperations taking an index are really slicing<br>&gt; <br>&gt; prefix(upTo:), prefix(through:), and suffix(from:) at first appear to<br>&gt; belong to the same family as the other prefix and suffix methods, but<br>&gt; deeper examination reveals otherwise. They are the only operations<br>&gt; which take indices, and they don&#39;t cleanly extend to the other<br>&gt; operations which belong to these families. (For instance, it would not<br>&gt; make sense to add a dropPrefix(upTo:) method; it would be equivalent<br>&gt; to suffix(from:).)<br>&gt; <br>&gt; Also, on Int-indexed collections like Array, prefix(_:) and<br>&gt; prefix(upTo:) are identical, but there is little relationship between<br>&gt; suffix(_:) and suffix(from:), which is confusing.<br>&gt; <br>&gt; suffix(from:) is a particularly severe source of confusion. The other<br>&gt; suffix APIs all have parameters relative to the endof the collection,<br>&gt; but suffix(from:)&#39;s index is still relative to the beginning of the<br>&gt; array. This is obvious if you think deeply about the meaning of an<br>&gt; index, but we don&#39;t really want to force our users to stare at a<br>&gt; strange API until they have an epiphany.<br>&gt; <br>&gt; I believe these operations have much more in common with slicing a<br>&gt; collection using a range, and that reimagining them as slicing APIs<br>&gt; will be more fruitful.<br></p><p>Yes please.<br></p><p>&gt; SVG ImageWhy does it matter?<br>&gt; <br>&gt; Many of these APIs are only occasionally necessary, so it&#39;s important<br>&gt; that they be easy to find when needed and easy to understand when<br>&gt; read. If you know that prefix (10) will get the first ten elements but<br>&gt; don&#39;t know what its inverse is, you will probably not guess that it&#39;s<br>&gt; dropFirst(10). The confusing, conflicting names in these APIs are a<br>&gt; barrier to users adopting them where appropriate.<br>&gt; <br>&gt; SVG ImageProposed solution<br>&gt; <br>&gt; We sever the index-taking APIs from the others, forming two separate<br>&gt; families, which I will call the &quot;Sequence-end operations&quot; and the<br>&gt; &quot;index-based operations&quot;. We then consider and redesign them along<br>&gt; separate lines.<br>&gt; <br>&gt; SVG ImageSequence-end operations<br>&gt; <br>&gt; Each of these APIs should be renamed to use a directional word based<br>&gt; on its row in the table:<br>&gt; <br>&gt; Operand Directional word  <br>&gt; Fixed Size   <br>&gt; First 1 first  <br>&gt; Last 1 last  <br>&gt; First (n: Int) prefix  <br>&gt; ...with closure prefix  <br>&gt; Last (n: Int) suffix  <br>&gt; ...with closure suffix  <br>&gt; Searching From End   <br>&gt; First matching element earliest  <br>&gt; ...with closure earliest  <br>&gt; Last matching element latest  <br>&gt; ...with closure latest  <br>&gt; <br>&gt; To accomplish this, starts(with:) should be renamed to hasPrefix(_:),<br></p><p>+1<br></p><p>&gt; <br>&gt; and other APIs should have directional words replaced or added as<br>&gt; appropriate.<br>&gt; <br>&gt; Additionally, the word drop in the &quot;Exclude&quot; APIs should be replaced<br>&gt; with removing. These operations omit the same elements which the<br>&gt; remove operations delete, so even though the types are not always the<br>&gt; same (removing returns SubSequence, not Self), I think they are<br>&gt; similar enough to deserve to be treated as nonmutating forms.<br>&gt; <br>&gt; These changes yield (altered names bold):<br>&gt; <br>&gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)  <br>&gt; Fixed Size        <br>&gt; First 1 C.first - S.removingFirst() C.removeFirst() C.popFirst() -  <br>&gt; Last 1 C.last - S.removingLast() C.removeLast() C.popLast() -  <br>&gt; First (n: Int) S.prefix(_:) - S.removingPrefix(_:) C.removePrefix(_:) - S.hasPrefix(_:)  <br>&gt; ...with closure S.prefix(while:) - S.removingPrefix - - S.hasPrefix  <br>&gt;    (while:)   (_:isEquivalent:)  <br></p><p>Call me overly fussy, but I don&#39;t love the use of “while” here because<br>it seems stateful.<br></p><p>   xs.prefix(while: isFull)<br></p><p>That reads like I&#39;m going to repeatedly take the prefix of xs while some<br>isFull property is true.  The most descriptive usage I can think of is<br></p><p>   for x in xs.longestPrefix(where: isFull)<br></p><p>What do you think?<br></p><p>[BTW, you might need to stop using a table because it&#39;s already too<br>wide, but your examples *really* ought to be showing use cases rather<br>than signatures, c.f. the table in<br>https://github.com/apple/swift/pull/2981.  Otherwise it&#39;s hard]<br></p><p>&gt; Last (n: Int) S.suffix(_:) - S.removingSuffix(_:) C.removeSuffix(_:) -<br>&gt; - ...with closure - - - - - - Searching From End First matching -<br>&gt; C.earliestIndex(of:) - - - - element ...with closure<br>&gt; S.earliest(where:) C.earliestIndex - - - - (where:) Last matching<br>&gt; element - - - - - - ...with closure - - - - - -<br>&gt; <br>&gt; SVG ImageAlternative to removing<br>&gt; <br>&gt; If the type differences are seen as disqualifying removing as a<br>&gt; replacement for drop, <br></p><p>They are not!<br></p><p>&gt; I suggest using skipping instead.<br>&gt; <br>&gt; There are, of course, many possible alternatives to skipping; this is<br>&gt; almost a perfect subject for bikeshedding. I&#39;ve chosen skipping<br>&gt; because:<br>&gt; <br>&gt; 1 It is not an uncommon word, unlike (say) omitting. This means<br>&gt; non-native English speakers and schoolchildren are more likely to<br>&gt; recognize it.<br>&gt; <br>&gt; 2 It is an -ing verb, unlike (say) without. This makes it fit common<br>&gt; Swift naming patterns more closely.<br>&gt; <br>&gt; 3 It does not imply danger, unlike (say) dropping, nor some sort of<br>&gt; ongoing process, unlike (say) ignoring. This makes its behavior more<br>&gt; obvious.<br>&gt; <br>&gt; If you want to suggest an alternative on swift-evolution, please do<br>&gt; not merely mention a synonym; rather, explain why it is an improvement<br>&gt; on either these axes or other ones. (I would be particularly<br>&gt; interested in names other than removing which draw an analogy to<br>&gt; something else in Swift.)<br>&gt; <br>&gt; SVG ImageIndex-based operations<br>&gt; <br>&gt; Because these APIs look up elements based on their indices, I believe these operations should be exposed as subscripts, and ideally should look like other slicing<br>&gt; operations.<br>&gt; <br>&gt; My primary design is rather ambitious, introducing two new types and either two operator overloads, or four unary forms of existing binary operators. I therefore<br>&gt; present a more conservative alternative as well.<br>&gt; <br>&gt; SVG ImagePreferred (ambitious) option<br>&gt; <br>&gt; let head = people[..&lt;i]<br>&gt; let tail = people[i..&lt;]<br></p><p>let equivalentTail = people[i...] // reads a bit better, no?<br>let headThroughI = people[...i]<br></p><p>&gt; let rearrangedPeople = tail + head<br>&gt; <br>&gt; Or this small variation:<br>&gt; <br>&gt; let head = people[nil ..&lt; i]<br>&gt; let tail = people[i ..&lt; nil]<br>&gt; let rearrangedPeople = tail + head<br>&gt; <br>&gt; The operators would construct instances of a new pair of types,<br>&gt; IncompleteRange (for ..&lt;) and IncompleteClosedRange (for ...), and<br>&gt; Collection would include new subscripts taking these types. These<br>&gt; would probably have default implementations which constructed an<br>&gt; equivalent Range or ClosedRange using startIndex and endIndex, then<br>&gt; passed the resulting range through to the existing subscripts.<br></p><p>W00t!<br></p><p>&gt; <br>&gt; I prefer this option because it offers an elegant syntax immediately<br>&gt; recognizable as a form of slicing, and provides a straightforward way<br>&gt; for a future version of Swift to extend other Range-handling<br>&gt; Collection operations, like replaceSubrange(_:with:) and<br>&gt; removeSubrange(_:), to handle subranges bound by the ends of the<br>&gt; Collection.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July  3, 2016 at 11:00:00am</p></header><div class="content"><p>The incomplete range concept is quite intriguing.<br></p><p>Have we considered spelling the operators with an asterisk at the<br>incomplete end?<br>prefix *..&lt;<br>prefix *...<br>postfix ...*<br>postfix ..&lt;*<br></p><p>That way the use-sites would look like:<br>someCollection[*..&lt;idx]<br>someCollection[*...idx]<br>someCollection[idx...*]<br>someCollection[idx..&lt;*]<br></p><p>&gt;From a “first-glance” perspective, the asterisk “looks like” a wildcard<br>placeholder, which should help readers and writers of code to understand<br>the meaning.<br></p><p>And from a future language development standpoint, we’ll keep the<br>triple-dot spelling available for whatever needs may arise (tuple<br>splatting, variadic generics, etc.)<br></p><p>Thoughts?<br></p><p>Nevin<br></p><p><br>On Fri, Jul 1, 2016 at 6:50 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Jun 23 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; As previously threatened mentioned, I&#39;ve written a draft proposal to<br>&gt; &gt; fix a number of naming issues with APIs operating on the beginning and<br>&gt; &gt; end of Sequences and Collections:<br>&gt; &gt;<br>&gt; &gt; • Inconsistent use of `prefix`/`suffix` vs. `first`/`last`<br>&gt; &gt; • Confusing naming of `drop` methods<br>&gt; &gt; • Ambiguous naming of `index(of:/where:)` and `drop(while:)`<br>&gt; &gt; • `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` shouldn&#39;t<br>&gt; &gt; be part of this family at all<br>&gt; &gt;<br>&gt; &gt; To fix this, I propose:<br>&gt; &gt;<br>&gt; &gt; • Renaming all methods which operate on more than one element at the<br>&gt; &gt; beginning/end to use &quot;prefix&quot; or &quot;suffix&quot;, not &quot;first&quot; or &quot;last&quot;<br>&gt; &gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and<br>&gt; &gt; `first(where:)` to `earliest(where:)`<br>&gt;<br>&gt; What&#39;s wrong with firstIndex(of:/where:) [and lastIndex(of:/where:)]?<br>&gt; That seems like a much less esoteric way to phrase it that meshes well<br>&gt; with the meanings of<br>&gt;<br>&gt;      xs.first<br>&gt;      xs.indices.first<br>&gt;<br>&gt; etc.<br>&gt;<br>&gt; &gt; • Renaming the `drop` methods to use `removing`<br>&gt;<br>&gt; Very clever!  I *like*.<br>&gt;<br>&gt; &gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)`<br>&gt; &gt; as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps<br>&gt; &gt; `people[nil..&lt;idx]`.<br>&gt;<br>&gt; Yes please; I really want this.  This part is a slightly nontrivial<br>&gt; design problem, though.  Someone should build an implementation before<br>&gt; the actual design is proposed.  Probably the best way would be to<br>&gt; leave prefix and suffix alone for the moment and add/test the new<br>&gt; subscripts.<br>&gt;<br>&gt; &gt; Since that last point requires significant redesign, including the<br>&gt; &gt; introduction of new types, I have also included an alternative design<br>&gt; &gt; which uses `people[to: idx]` instead.<br>&gt;<br>&gt; I really don&#39;t like using labels for this, because stride(to:) and<br>&gt; stride(through:) have already spawned a naming bikeshed with no clear<br>&gt; resolution, suggesting that no name works.  Plus, the ..&lt; operator<br>&gt; already implies the name.<br>&gt;<br>&gt; &gt; This proposal does not seek to add new functionality; it merely<br>&gt; &gt; renames or (in the case of the &quot;aggressive&quot; subscript option)<br>&gt; &gt; redesigns existing functionality. I do, however, discuss (without<br>&gt; &gt; making many judgements about their wisdom) how these changes might<br>&gt; &gt; affect the naming of functionality we might add in future versions of<br>&gt; &gt; Swift.<br>&gt;<br>&gt; Good.<br>&gt;<br>&gt; &gt; I would mainly like feedback on the two most open questions left in<br>&gt; &gt; this proposal:<br>&gt; &gt;<br>&gt; &gt; • The choice of `removing` to replace `drop`<br>&gt;<br>&gt; It&#39;s 100% appropriate, provided that the APIs match some corresponding<br>&gt; mutating remove API.  Nonmutating operations are often implemented via<br>&gt; lazy adaptors... which a slice can be viewed to be.  So I think this is<br>&gt; a beautiful answer.<br>&gt;<br>&gt; &gt; • The decision about whether to use `people[..&lt;idx]`,<br>&gt; &gt; `people[nil..&lt;idx]`, or `people[to: idx]`.<br>&gt;<br>&gt; I prefer how the first one reads.<br>&gt;<br>&gt; &gt; But I&#39;d also like comments on the rest of the proposal, and on whether<br>&gt; &gt; I should split the prefix(upTo:/through:)/suffix(from:) changes into a<br>&gt; &gt; separate proposal from the rest.<br>&gt;<br>&gt; I very much appreciate that you&#39;re addressing all of these at once.<br>&gt;<br>&gt; &gt; I suspect this will cause a firestorm of bikeshedding, so please try<br>&gt; &gt; to keep your suggestions grounded. Don&#39;t just suggest a name;<br>&gt; &gt; articulate why it&#39;s a better choice than what we already have or what<br>&gt; &gt; this proposal suggests. Only you can prevent our first<br>&gt; &gt; *three*-hundred-message bikeshedding thread.<br>&gt; &gt;<br>&gt; &gt; Thanks for your attention!<br>&gt; &gt;<br>&gt; &gt; (P.S. The proposal below includes several huge tables which may cause<br>&gt; &gt; some mail clients to become very pouty and refuse to eat their<br>&gt; &gt; supper. You may want to read the proposal at<br>&gt; &gt; &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430<br>&gt; &gt; &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430&gt;&gt;<br>&gt; &gt; instead.)<br>&gt; &gt;<br>&gt; &gt; The Sequence and Collection protocols offer a wide variety of APIs which<br>&gt; &gt; are defined to operate on, or from, one end of the sequence:<br>&gt; &gt;<br>&gt; &gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)<br>&gt;<br>&gt; I think you want “Operation” or “Semantics” rather than “Operand” (which<br>&gt; means an argument to an operation)<br>&gt;<br>&gt; &gt; Fixed Size<br>&gt; &gt; First 1 C.first - S.dropFirst() C.removeFirst() C.popFirst() -<br>&gt; &gt; Last 1 C.last - S.dropLast() C.removeLast() C.popLast() -<br>&gt; &gt; First (n: Int) S.prefix(_:) - S.dropFirst(_:) C.removeFirst(_:) -<br>&gt; S.starts(with:)<br>&gt; &gt; ...with closure S.prefix(while:) - S.drop(while:) - - S.starts<br>&gt; &gt;       (with:isEquivalent:)<br>&gt; &gt; Last (n: Int) S.suffix(_:) - S.dropLast(_:) C.removeLast(_:) - -<br>&gt; &gt; ...with closure - - - - - -<br>&gt; &gt; Searching From End<br>&gt; &gt; First matching - C.index(of:) - - - -<br>&gt; &gt; element<br>&gt; &gt; ...with closure S.first(where:) C.index(where:) - - - -<br>&gt; &gt; Last matching element - - - - - -<br>&gt; &gt; ...with closure - - - - - -<br>&gt; &gt; Based on Index<br>&gt; &gt; startIndex ..&lt; (i: Index) C.prefix(upTo:) - - - - -<br>&gt; &gt; startIndex ... (i: Index) C.prefix(through:) - - - - -<br>&gt; &gt; (i: Index) ..&lt; endIndex C.suffix(from:) - - - - -<br>&gt; &gt;<br>&gt; &gt;  I have included several blank rows for operands which fit the APIs&#39;<br>&gt; patterns, even if they don&#39;t happen to have any operations currently.<br>&gt; &gt;<br>&gt; &gt;  Type abbreviations:<br>&gt; &gt;<br>&gt; &gt;  * S = Sequence<br>&gt; &gt;  * C = Collection (or a sub-protocol like BidirectionalCollection)<br>&gt; &gt;<br>&gt; &gt;  Notes:<br>&gt; &gt;<br>&gt; &gt;  1 remove and pop both mutate the array to delete the indicated<br>&gt; element(s), but remove assumes as a precondition that the indicated<br>&gt; elements exist, while pop<br>&gt; &gt;  checks whether or not they exist.<br>&gt; &gt;<br>&gt; &gt;  2 String and NSString have bespoke versions of first n and last n<br>&gt; Equate operations, in the form of their hasPrefix and hasSuffix methods.<br>&gt; &gt;<br>&gt; &gt; Leaving aside the question of whether any gaps in these tables ought to<br>&gt; be filled, I see a number of issues with existing terminology.<br>&gt; &gt;<br>&gt; &gt; SVG ImageInconsistent use of prefix and suffix<br>&gt; &gt;<br>&gt; &gt; Some APIs which operate on a variable number of elements anchored at one<br>&gt; end or the other use the terms prefix or suffix:<br>&gt; &gt;<br>&gt; &gt; * Sequence.prefix(_:) and Sequence.suffix(_:)<br>&gt; &gt; * Sequence.prefix(while:)<br>&gt; &gt; * String.hasPrefix(_:) and String.hasSuffix(_:)<br>&gt; &gt;<br>&gt; &gt; Others, however, use first or last:<br>&gt; &gt;<br>&gt; &gt; * Sequence.dropFirst(_:) and Sequence.dropLast(_:)<br>&gt; &gt; * Sequence.removeFirst(_:) and Sequence.removeLast(_:)<br>&gt; &gt;<br>&gt; &gt; Still others use neither:<br>&gt; &gt;<br>&gt; &gt; * Sequence.starts(with:)<br>&gt; &gt; * Sequence.drop(while:)<br>&gt; &gt;<br>&gt; &gt; These methods are all closely related, but because of this inconsistent<br>&gt; terminology, they fail to form predictable method families.<br>&gt; &gt;<br>&gt; &gt; SVG Imagefirst has multiple meanings<br>&gt; &gt;<br>&gt; &gt; The word first can mean three different things in these APIs:<br>&gt; &gt;<br>&gt; &gt; * Just the very first element of the sequence.<br>&gt; &gt;<br>&gt; &gt; * A subsequence of elements anchored at the beginning of the sequence,<br>&gt; &gt;   as mentioned in the last point.<br>&gt; &gt;<br>&gt; &gt; * The first element encountered in the sequence which matches a given<br>&gt; &gt;   criterion when walking from the beginning of the sequence towards the<br>&gt; &gt;   end.<br>&gt; &gt;<br>&gt; &gt; It would be nice to have more clarity here.<br>&gt;<br>&gt; You seem to be suggesting that a word needs to mean exactly the same<br>&gt; thing regardless of context.  If so, I disagree.  If I say “the first<br>&gt; element” or “the first element greater than 5” there&#39;s absolutely no<br>&gt; lack of clarity AFAICT.  That accounts for the first and last bullets<br>&gt;<br>&gt; The usage in the middle bullet is open to misinterpretation and I would<br>&gt; support fixing that.<br>&gt;<br>&gt;      xs.removeFirst(42)<br>&gt;<br>&gt; could read like, “remove the first element equal to 42.”<br>&gt;<br>&gt; &gt; SVG Imagedrop is misleading and scary<br>&gt; &gt;<br>&gt; &gt; In a Swift context, I believe the drop methods are actively confusing:<br>&gt; &gt;<br>&gt; &gt; * drop does not have the -ing or -ed suffix normally used for a<br>&gt; &gt; nonmutating method.<br>&gt; &gt;<br>&gt; &gt; * drop has strong associations with destructive operations; it&#39;s the<br>&gt; &gt; term used, for instance, for deleting whole tables in SQL. Even<br>&gt; &gt; dropping would probably sound more like a mutating operation than<br>&gt; &gt; alternatives.<br>&gt; &gt;<br>&gt; &gt; * As previously mentioned, the use of dropFirst and dropLast for<br>&gt; &gt; single-drop operations and multiple-drop operations breaks up method<br>&gt; &gt; families.<br>&gt; &gt;<br>&gt; &gt; drop, dropFirst, and dropLast are terms of art, so we allow them a<br>&gt; &gt; certain amount of leeway. However, I believe the drop functions go<br>&gt; &gt; well beyond what we should<br>&gt; &gt; permit. They are relatively uncommon operations, associated primarily<br>&gt; &gt; with functional languages rather than mainstream object-oriented or<br>&gt; &gt; imperative languages, and<br>&gt; &gt; their violation of the normal Swift naming guidelines is especially<br>&gt; &gt; misleading.<br>&gt; &gt;<br>&gt; &gt; The term-of-art exception is not a suicide pact;<br>&gt;<br>&gt; Tatoo that on your forehead, mister!<br>&gt;<br>&gt; &gt; it is meant to aid understanding by importing common terminology, not<br>&gt; &gt; bind us to follow every decision made by any language that came before<br>&gt; &gt; us. In this case, I think we should ignore precedent and forge our own<br>&gt; &gt; path.<br>&gt; &gt;<br>&gt; &gt; SVG ImageUnstated direction of operation<br>&gt; &gt;<br>&gt; &gt; Several APIs could theoretically be implemented by working from either<br>&gt; &gt; end of the sequence, and would return different results depending on<br>&gt; &gt; the direction, but do not indicate the direction in their names:<br>&gt; &gt;<br>&gt; &gt; * Sequence.drop(while:)<br>&gt; &gt; * Collection.index(of:)<br>&gt; &gt;<br>&gt; &gt; Adding a direction to these APIs would make their behavior clearer and<br>&gt; permit us to offer opposite-end equivalents in the future. (Unmerged<br>&gt; swift-evolution pull<br>&gt; &gt; request 329 would add lastIndex methods.)<br>&gt; &gt;<br>&gt; &gt; SVG ImageThe index(...) base name has been polluted<br>&gt; &gt;<br>&gt; &gt; Swift 3&#39;s new collection model placed a number of low-level index<br>&gt; &gt; manipulating operations on the base method name index. These now share<br>&gt; &gt; that name with index(of:) and index(where:), which are much<br>&gt; &gt; higher-level operations. This may be confusing for users looking for<br>&gt; &gt; high-level operations; the only real relationship between the two sets<br>&gt; &gt; of operations is that they both return an index.<br>&gt;<br>&gt; There&#39;s another relationship.  Once you call the high-level operation,<br>&gt; you&#39;re now in the domain of indexing, and are very likely to ask for the<br>&gt; index(after:) the one you found.<br>&gt;<br>&gt; &gt; It would be nice to separate these two groups of methods into<br>&gt; &gt; different families.<br>&gt;<br>&gt; I used to think that was important, but I no longer do given the above.<br>&gt;<br>&gt; &gt; SVG ImageOperations taking an index are really slicing<br>&gt; &gt;<br>&gt; &gt; prefix(upTo:), prefix(through:), and suffix(from:) at first appear to<br>&gt; &gt; belong to the same family as the other prefix and suffix methods, but<br>&gt; &gt; deeper examination reveals otherwise. They are the only operations<br>&gt; &gt; which take indices, and they don&#39;t cleanly extend to the other<br>&gt; &gt; operations which belong to these families. (For instance, it would not<br>&gt; &gt; make sense to add a dropPrefix(upTo:) method; it would be equivalent<br>&gt; &gt; to suffix(from:).)<br>&gt; &gt;<br>&gt; &gt; Also, on Int-indexed collections like Array, prefix(_:) and<br>&gt; &gt; prefix(upTo:) are identical, but there is little relationship between<br>&gt; &gt; suffix(_:) and suffix(from:), which is confusing.<br>&gt; &gt;<br>&gt; &gt; suffix(from:) is a particularly severe source of confusion. The other<br>&gt; &gt; suffix APIs all have parameters relative to the endof the collection,<br>&gt; &gt; but suffix(from:)&#39;s index is still relative to the beginning of the<br>&gt; &gt; array. This is obvious if you think deeply about the meaning of an<br>&gt; &gt; index, but we don&#39;t really want to force our users to stare at a<br>&gt; &gt; strange API until they have an epiphany.<br>&gt; &gt;<br>&gt; &gt; I believe these operations have much more in common with slicing a<br>&gt; &gt; collection using a range, and that reimagining them as slicing APIs<br>&gt; &gt; will be more fruitful.<br>&gt;<br>&gt; Yes please.<br>&gt;<br>&gt; &gt; SVG ImageWhy does it matter?<br>&gt; &gt;<br>&gt; &gt; Many of these APIs are only occasionally necessary, so it&#39;s important<br>&gt; &gt; that they be easy to find when needed and easy to understand when<br>&gt; &gt; read. If you know that prefix (10) will get the first ten elements but<br>&gt; &gt; don&#39;t know what its inverse is, you will probably not guess that it&#39;s<br>&gt; &gt; dropFirst(10). The confusing, conflicting names in these APIs are a<br>&gt; &gt; barrier to users adopting them where appropriate.<br>&gt; &gt;<br>&gt; &gt; SVG ImageProposed solution<br>&gt; &gt;<br>&gt; &gt; We sever the index-taking APIs from the others, forming two separate<br>&gt; &gt; families, which I will call the &quot;Sequence-end operations&quot; and the<br>&gt; &gt; &quot;index-based operations&quot;. We then consider and redesign them along<br>&gt; &gt; separate lines.<br>&gt; &gt;<br>&gt; &gt; SVG ImageSequence-end operations<br>&gt; &gt;<br>&gt; &gt; Each of these APIs should be renamed to use a directional word based<br>&gt; &gt; on its row in the table:<br>&gt; &gt;<br>&gt; &gt; Operand Directional word<br>&gt; &gt; Fixed Size<br>&gt; &gt; First 1 first<br>&gt; &gt; Last 1 last<br>&gt; &gt; First (n: Int) prefix<br>&gt; &gt; ...with closure prefix<br>&gt; &gt; Last (n: Int) suffix<br>&gt; &gt; ...with closure suffix<br>&gt; &gt; Searching From End<br>&gt; &gt; First matching element earliest<br>&gt; &gt; ...with closure earliest<br>&gt; &gt; Last matching element latest<br>&gt; &gt; ...with closure latest<br>&gt; &gt;<br>&gt; &gt; To accomplish this, starts(with:) should be renamed to hasPrefix(_:),<br>&gt;<br>&gt; +1<br>&gt;<br>&gt; &gt;<br>&gt; &gt; and other APIs should have directional words replaced or added as<br>&gt; &gt; appropriate.<br>&gt; &gt;<br>&gt; &gt; Additionally, the word drop in the &quot;Exclude&quot; APIs should be replaced<br>&gt; &gt; with removing. These operations omit the same elements which the<br>&gt; &gt; remove operations delete, so even though the types are not always the<br>&gt; &gt; same (removing returns SubSequence, not Self), I think they are<br>&gt; &gt; similar enough to deserve to be treated as nonmutating forms.<br>&gt; &gt;<br>&gt; &gt; These changes yield (altered names bold):<br>&gt; &gt;<br>&gt; &gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)<br>&gt; &gt; Fixed Size<br>&gt; &gt; First 1 C.first - S.removingFirst() C.removeFirst() C.popFirst() -<br>&gt; &gt; Last 1 C.last - S.removingLast() C.removeLast() C.popLast() -<br>&gt; &gt; First (n: Int) S.prefix(_:) - S.removingPrefix(_:) C.removePrefix(_:) -<br>&gt; S.hasPrefix(_:)<br>&gt; &gt; ...with closure S.prefix(while:) - S.removingPrefix - - S.hasPrefix<br>&gt; &gt;    (while:)   (_:isEquivalent:)<br>&gt;<br>&gt; Call me overly fussy, but I don&#39;t love the use of “while” here because<br>&gt; it seems stateful.<br>&gt;<br>&gt;    xs.prefix(while: isFull)<br>&gt;<br>&gt; That reads like I&#39;m going to repeatedly take the prefix of xs while some<br>&gt; isFull property is true.  The most descriptive usage I can think of is<br>&gt;<br>&gt;    for x in xs.longestPrefix(where: isFull)<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; [BTW, you might need to stop using a table because it&#39;s already too<br>&gt; wide, but your examples *really* ought to be showing use cases rather<br>&gt; than signatures, c.f. the table in<br>&gt; https://github.com/apple/swift/pull/2981.  Otherwise it&#39;s hard]<br>&gt;<br>&gt; &gt; Last (n: Int) S.suffix(_:) - S.removingSuffix(_:) C.removeSuffix(_:) -<br>&gt; &gt; - ...with closure - - - - - - Searching From End First matching -<br>&gt; &gt; C.earliestIndex(of:) - - - - element ...with closure<br>&gt; &gt; S.earliest(where:) C.earliestIndex - - - - (where:) Last matching<br>&gt; &gt; element - - - - - - ...with closure - - - - - -<br>&gt; &gt;<br>&gt; &gt; SVG ImageAlternative to removing<br>&gt; &gt;<br>&gt; &gt; If the type differences are seen as disqualifying removing as a<br>&gt; &gt; replacement for drop,<br>&gt;<br>&gt; They are not!<br>&gt;<br>&gt; &gt; I suggest using skipping instead.<br>&gt; &gt;<br>&gt; &gt; There are, of course, many possible alternatives to skipping; this is<br>&gt; &gt; almost a perfect subject for bikeshedding. I&#39;ve chosen skipping<br>&gt; &gt; because:<br>&gt; &gt;<br>&gt; &gt; 1 It is not an uncommon word, unlike (say) omitting. This means<br>&gt; &gt; non-native English speakers and schoolchildren are more likely to<br>&gt; &gt; recognize it.<br>&gt; &gt;<br>&gt; &gt; 2 It is an -ing verb, unlike (say) without. This makes it fit common<br>&gt; &gt; Swift naming patterns more closely.<br>&gt; &gt;<br>&gt; &gt; 3 It does not imply danger, unlike (say) dropping, nor some sort of<br>&gt; &gt; ongoing process, unlike (say) ignoring. This makes its behavior more<br>&gt; &gt; obvious.<br>&gt; &gt;<br>&gt; &gt; If you want to suggest an alternative on swift-evolution, please do<br>&gt; &gt; not merely mention a synonym; rather, explain why it is an improvement<br>&gt; &gt; on either these axes or other ones. (I would be particularly<br>&gt; &gt; interested in names other than removing which draw an analogy to<br>&gt; &gt; something else in Swift.)<br>&gt; &gt;<br>&gt; &gt; SVG ImageIndex-based operations<br>&gt; &gt;<br>&gt; &gt; Because these APIs look up elements based on their indices, I believe<br>&gt; these operations should be exposed as subscripts, and ideally should look<br>&gt; like other slicing<br>&gt; &gt; operations.<br>&gt; &gt;<br>&gt; &gt; My primary design is rather ambitious, introducing two new types and<br>&gt; either two operator overloads, or four unary forms of existing binary<br>&gt; operators. I therefore<br>&gt; &gt; present a more conservative alternative as well.<br>&gt; &gt;<br>&gt; &gt; SVG ImagePreferred (ambitious) option<br>&gt; &gt;<br>&gt; &gt; let head = people[..&lt;i]<br>&gt; &gt; let tail = people[i..&lt;]<br>&gt;<br>&gt; let equivalentTail = people[i...] // reads a bit better, no?<br>&gt; let headThroughI = people[...i]<br>&gt;<br>&gt; &gt; let rearrangedPeople = tail + head<br>&gt; &gt;<br>&gt; &gt; Or this small variation:<br>&gt; &gt;<br>&gt; &gt; let head = people[nil ..&lt; i]<br>&gt; &gt; let tail = people[i ..&lt; nil]<br>&gt; &gt; let rearrangedPeople = tail + head<br>&gt; &gt;<br>&gt; &gt; The operators would construct instances of a new pair of types,<br>&gt; &gt; IncompleteRange (for ..&lt;) and IncompleteClosedRange (for ...), and<br>&gt; &gt; Collection would include new subscripts taking these types. These<br>&gt; &gt; would probably have default implementations which constructed an<br>&gt; &gt; equivalent Range or ClosedRange using startIndex and endIndex, then<br>&gt; &gt; passed the resulting range through to the existing subscripts.<br>&gt;<br>&gt; W00t!<br>&gt;<br>&gt; &gt;<br>&gt; &gt; I prefer this option because it offers an elegant syntax immediately<br>&gt; &gt; recognizable as a form of slicing, and provides a straightforward way<br>&gt; &gt; for a future version of Swift to extend other Range-handling<br>&gt; &gt; Collection operations, like replaceSubrange(_:with:) and<br>&gt; &gt; removeSubrange(_:), to handle subranges bound by the ends of the<br>&gt; &gt; Collection.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/a448d11c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 3:50 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)`<br>&gt;&gt; as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps<br>&gt;&gt; `people[nil..&lt;idx]`.<br>&gt; <br>&gt; Yes please; I really want this.  This part is a slightly nontrivial<br>&gt; design problem, though.  Someone should build an implementation before<br>&gt; the actual design is proposed.  Probably the best way would be to<br>&gt; leave prefix and suffix alone for the moment and add/test the new<br>&gt; subscripts.<br></p><p>I&#39;ll try to figure out how to wedge something into stdlib, but until I do, here&#39;s something I tried out in a playground: https://gist.github.com/brentdax/b36ef130873b752d4c6f7ee3c157d07d<br></p><p>(Already sent that to you, Dave; this is for everyone else.)<br></p><p>&gt;&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and<br>&gt;&gt; `first(where:)` to `earliest(where:)`<br>&gt; <br>&gt; What&#39;s wrong with firstIndex(of:/where:) [and lastIndex(of:/where:)]?<br>&gt; That seems like a much less esoteric way to phrase it that meshes well<br>&gt; with the meanings of<br>&gt; <br>&gt;     xs.first<br>&gt;     xs.indices.first<br>&gt; <br>&gt; etc.<br></p><p>[and]<br></p><p>&gt;&gt; first has multiple meanings<br>&gt;&gt; <br>&gt;&gt; The word first can mean three different things in these APIs:<br>&gt;&gt; <br>&gt;&gt; * Just the very first element of the sequence.<br>&gt;&gt; <br>&gt;&gt; * A subsequence of elements anchored at the beginning of the sequence,<br>&gt;&gt;  as mentioned in the last point.<br>&gt;&gt; <br>&gt;&gt; * The first element encountered in the sequence which matches a given<br>&gt;&gt;  criterion when walking from the beginning of the sequence towards the<br>&gt;&gt;  end.<br>&gt;&gt; <br>&gt;&gt; It would be nice to have more clarity here.<br>&gt; <br>&gt; You seem to be suggesting that a word needs to mean exactly the same<br>&gt; thing regardless of context.  If so, I disagree.  If I say “the first<br>&gt; element” or “the first element greater than 5” there&#39;s absolutely no<br>&gt; lack of clarity AFAICT.  That accounts for the first and last bullets<br></p><p>I was hoping to distinguish between the O(1), always-anchored first/last calls and the O(n), unanchored earliest/latest calls. Perhaps that isn&#39;t necessary, though; `xs.first(x)` *does* read well, and it&#39;d be difficult to imagine an implementation on most collections that didn&#39;t involve searching multiple elements.<br></p><p>&gt;&gt; The Sequence and Collection protocols offer a wide variety of APIs which<br>&gt;&gt; are defined to operate on, or from, one end of the sequence:<br>&gt;&gt; <br>&gt;&gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)  <br>&gt; <br>&gt; I think you want “Operation” or “Semantics” rather than “Operand” (which<br>&gt; means an argument to an operation)<br></p><p>&quot;Operand&quot; is meant to label the column below it, which lists things like &quot;First 1 Element&quot;. Maybe I should just leave that cell blank, though.<br></p><p>&gt;&gt; The term-of-art exception is not a suicide pact; <br>&gt; <br>&gt; Tatoo that on your forehead, mister!<br></p><p>Touché.<br></p><p>(I still believe map, reduce, and filter are much stronger terms of art and don&#39;t require much modification, but that&#39;s a discussion for another thread.)<br></p><p>&gt;&gt; The index(...) base name has been polluted<br>&gt;&gt; <br>&gt;&gt; Swift 3&#39;s new collection model placed a number of low-level index<br>&gt;&gt; manipulating operations on the base method name index. These now share<br>&gt;&gt; that name with index(of:) and index(where:), which are much<br>&gt;&gt; higher-level operations. This may be confusing for users looking for<br>&gt;&gt; high-level operations; the only real relationship between the two sets<br>&gt;&gt; of operations is that they both return an index.<br>&gt; <br>&gt; There&#39;s another relationship.  Once you call the high-level operation,<br>&gt; you&#39;re now in the domain of indexing, and are very likely to ask for the<br>&gt; index(after:) the one you found.<br></p><p>Maybe. I suspect most users simply use the index without manipulating it, but certainly you&#39;ll sometimes use both.<br></p><p>(But even without that, I still think the directional vagueness and the possibility of a `lastIndex` method in the future are good enough justifications to rename it on their own.)<br></p><p>&gt;&gt; These changes yield (altered names bold):<br>&gt;&gt; <br>&gt;&gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)  <br>&gt;&gt; Fixed Size        <br>&gt;&gt; First 1 C.first - S.removingFirst() C.removeFirst() C.popFirst() -  <br>&gt;&gt; Last 1 C.last - S.removingLast() C.removeLast() C.popLast() -  <br>&gt;&gt; First (n: Int) S.prefix(_:) - S.removingPrefix(_:) C.removePrefix(_:) - S.hasPrefix(_:)  <br>&gt;&gt; ...with closure S.prefix(while:) - S.removingPrefix - - S.hasPrefix  <br>&gt;&gt;   (while:)   (_:isEquivalent:)  <br>&gt; <br>&gt; Call me overly fussy, but I don&#39;t love the use of “while” here because<br>&gt; it seems stateful.<br>&gt; <br>&gt;   xs.prefix(while: isFull)<br>&gt; <br>&gt; That reads like I&#39;m going to repeatedly take the prefix of xs while some<br>&gt; isFull property is true.  The most descriptive usage I can think of is<br>&gt; <br>&gt;   for x in xs.longestPrefix(where: isFull)<br>&gt; <br>&gt; What do you think?<br></p><p>I don&#39;t like changing the base name—it breaks the connection between `prefix(_:)` and `prefix(while:)`—unless we change it for all of the relevant calls, but I&#39;m certainly open to changing the label. Maybe `prefix(whereEach: isFull)`?<br></p><p>On the other hand, does `xs.prefix(3)` read well? APIs that take counts seem to be challenging to name; I&#39;ve had some of the same problems with UnsafeRawPointer APIs.<br></p><p>&gt; [BTW, you might need to stop using a table because it&#39;s already too<br>&gt; wide, but your examples *really* ought to be showing use cases rather<br>&gt; than signatures, c.f. the table in<br>&gt; https://github.com/apple/swift/pull/2981.  Otherwise it&#39;s hard]<br></p><p>I&#39;ll try to find a way to fit examples in.<br></p><p>&gt;&gt; Preferred (ambitious) option<br>&gt;&gt; <br>&gt;&gt; let head = people[..&lt;i]<br>&gt;&gt; let tail = people[i..&lt;]<br>&gt; <br>&gt; let equivalentTail = people[i...] // reads a bit better, no?<br>&gt; let headThroughI = people[...i]<br></p><p>It looks nicer, but it breaks the mental model of these unary forms merely filling in `startIndex` or `endIndex` automatically. Like the `..&lt;` operator itself, I think we&#39;re better off with ugly clarity than pretty vagueness.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 11, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri Jul 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 3:50 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)`<br>&gt;&gt;&gt; as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps<br>&gt;&gt;&gt; `people[nil..&lt;idx]`.<br>&gt;&gt; <br>&gt;&gt; Yes please; I really want this.  This part is a slightly nontrivial<br>&gt;&gt; design problem, though.  Someone should build an implementation before<br>&gt;&gt; the actual design is proposed.  Probably the best way would be to<br>&gt;&gt; leave prefix and suffix alone for the moment and add/test the new<br>&gt;&gt; subscripts.<br>&gt;<br>&gt; I&#39;ll try to figure out how to wedge something into stdlib, but until I<br>&gt; do, here&#39;s something I tried out in a playground:<br>&gt; https://gist.github.com/brentdax/b36ef130873b752d4c6f7ee3c157d07d<br>&gt;<br>&gt; (Already sent that to you, Dave; this is for everyone else.)<br>&gt;<br>&gt;&gt;&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and<br>&gt;&gt;&gt; `first(where:)` to `earliest(where:)`<br>&gt;&gt; <br>&gt;&gt; What&#39;s wrong with firstIndex(of:/where:) [and lastIndex(of:/where:)]?<br>&gt;&gt; That seems like a much less esoteric way to phrase it that meshes well<br>&gt;&gt; with the meanings of<br>&gt;&gt; <br>&gt;&gt;     xs.first<br>&gt;&gt;     xs.indices.first<br>&gt;&gt; <br>&gt;&gt; etc.<br>&gt;<br>&gt; [and]<br>&gt;<br>&gt;&gt;&gt; first has multiple meanings<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The word first can mean three different things in these APIs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Just the very first element of the sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A subsequence of elements anchored at the beginning of the sequence,<br>&gt;&gt;&gt;  as mentioned in the last point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The first element encountered in the sequence which matches a given<br>&gt;&gt;&gt;  criterion when walking from the beginning of the sequence towards the<br>&gt;&gt;&gt;  end.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be nice to have more clarity here.<br>&gt;&gt; <br>&gt;&gt; You seem to be suggesting that a word needs to mean exactly the same<br>&gt;&gt; thing regardless of context.  If so, I disagree.  If I say “the first<br>&gt;&gt; element” or “the first element greater than 5” there&#39;s absolutely no<br>&gt;&gt; lack of clarity AFAICT.  That accounts for the first and last bullets<br>&gt;<br>&gt; I was hoping to distinguish between the O(1), always-anchored<br>&gt; first/last calls and the O(n), unanchored earliest/latest<br>&gt; calls. Perhaps that isn&#39;t necessary, though; `xs.first(x)` *does* read<br>&gt; well, and it&#39;d be difficult to imagine an implementation on most<br>&gt; collections that didn&#39;t involve searching multiple elements.<br></p><p>Well, it&#39;s a reasonable thing to want to distinguish, but I don&#39;t think<br>I want to burden every API that effectively does a linear search with<br>the awkwardness of “earliest” and “latest.”  To me it doesn&#39;t look like<br>a great trade-off.<br></p><p>We could rename “first” and “last” so they always mean O(N) but that<br>seems overly fussy too.<br></p><p>Just IMO, of course.<br></p><p>&gt;&gt;&gt; The Sequence and Collection protocols offer a wide variety of APIs which<br>&gt;&gt;&gt; are defined to operate on, or from, one end of the sequence:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)  <br>&gt;&gt; <br>&gt;&gt; I think you want “Operation” or “Semantics” rather than “Operand” (which<br>&gt;&gt; means an argument to an operation)<br>&gt;<br>&gt; &quot;Operand&quot; is meant to label the column below it, which lists things<br>&gt; like &quot;First 1 Element&quot;. <br></p><p>I know that, and that&#39;s exactly why “Operand” is the wrong word here.<br></p><p>&gt; Maybe I should just leave that cell blank, though.<br>&gt;<br>&gt;&gt;&gt; The term-of-art exception is not a suicide pact; <br>&gt;&gt; <br>&gt;&gt; Tatoo that on your forehead, mister!<br>&gt;<br>&gt; Touché.<br>&gt;<br>&gt; (I still believe map, reduce, and filter are much stronger terms of<br>&gt; art and don&#39;t require much modification, but that&#39;s a discussion for<br>&gt; another thread.)<br></p><p>Indeedy.<br></p><p>&gt;&gt;&gt; The index(...) base name has been polluted<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift 3&#39;s new collection model placed a number of low-level index<br>&gt;&gt;&gt; manipulating operations on the base method name index. These now share<br>&gt;&gt;&gt; that name with index(of:) and index(where:), which are much<br>&gt;&gt;&gt; higher-level operations. This may be confusing for users looking for<br>&gt;&gt;&gt; high-level operations; the only real relationship between the two sets<br>&gt;&gt;&gt; of operations is that they both return an index.<br>&gt;&gt; <br>&gt;&gt; There&#39;s another relationship.  Once you call the high-level operation,<br>&gt;&gt; you&#39;re now in the domain of indexing, and are very likely to ask for the<br>&gt;&gt; index(after:) the one you found.<br>&gt;<br>&gt; Maybe. I suspect most users simply use the index without manipulating<br>&gt; it, but certainly you&#39;ll sometimes use both.<br>&gt;<br>&gt; (But even without that, I still think the directional vagueness and<br>&gt; the possibility of a `lastIndex` method in the future are good enough<br>&gt; justifications to rename it on their own.)<br></p><p>+1<br></p><p>&gt;<br>&gt;<br>&gt;&gt;&gt; These changes yield (altered names bold):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Operand Get Index Exclude Remove (1) Pop (1) Equate (2)  <br>&gt;&gt;&gt; Fixed Size        <br>&gt;&gt;&gt; First 1 C.first - S.removingFirst() C.removeFirst() C.popFirst() -  <br>&gt;&gt;&gt; Last 1 C.last - S.removingLast() C.removeLast() C.popLast() -  <br>&gt;&gt;&gt; First (n: Int) S.prefix(_:) - S.removingPrefix(_:) C.removePrefix(_:) - S.hasPrefix(_:)  <br>&gt;&gt;&gt; ...with closure S.prefix(while:) - S.removingPrefix - - S.hasPrefix  <br>&gt;&gt;&gt;   (while:)   (_:isEquivalent:)  <br>&gt;&gt; <br>&gt;&gt; Call me overly fussy, but I don&#39;t love the use of “while” here because<br>&gt;&gt; it seems stateful.<br>&gt;&gt; <br>&gt;&gt;   xs.prefix(while: isFull)<br>&gt;&gt; <br>&gt;&gt; That reads like I&#39;m going to repeatedly take the prefix of xs while some<br>&gt;&gt; isFull property is true.  The most descriptive usage I can think of is<br>&gt;&gt; <br>&gt;&gt;   for x in xs.longestPrefix(where: isFull)<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;<br>&gt; I don&#39;t like changing the base name—it breaks the connection between<br>&gt; `prefix(_:)` and `prefix(while:)`—<br></p><p>Well, I&#39;m really hoping we won&#39;t hang on to the first one forever, and<br>that slicing syntax will eventually work here.<br></p><p>&gt; unless we change it for all of the relevant calls, but I&#39;m certainly<br>&gt; open to changing the label. Maybe `prefix(whereEach: isFull)`?<br></p><p>I think “while” is better than that one, since it implies “longest.”<br>However, I still think “longestPrefix...” will read much more clearly at<br>the call site.<br></p><p>&gt; On the other hand, does `xs.prefix(3)` read well? <br></p><p>One among many reasons I want to use slicing syntax here.<br></p><p>&gt; APIs that take counts seem to be challenging to name; I&#39;ve had some of<br>&gt; the same problems with UnsafeRawPointer APIs.<br></p><p>A separate proposal to clean up APIs taking counts might be a good idea,<br>then.  But let&#39;s not get too far afield in this thread.<br></p><p>&gt;&gt; [BTW, you might need to stop using a table because it&#39;s already too<br>&gt;&gt; wide, but your examples *really* ought to be showing use cases rather<br>&gt;&gt; than signatures, c.f. the table in<br>&gt;&gt; https://github.com/apple/swift/pull/2981.  Otherwise it&#39;s hard]<br>&gt;<br>&gt; I&#39;ll try to find a way to fit examples in.<br>&gt;<br>&gt;&gt;&gt; Preferred (ambitious) option<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let head = people[..&lt;i]<br>&gt;&gt;&gt; let tail = people[i..&lt;]<br>&gt;&gt; <br>&gt;&gt; let equivalentTail = people[i...] // reads a bit better, no?<br>&gt;&gt; let headThroughI = people[...i]<br>&gt;<br>&gt; It looks nicer, but it breaks the mental model of these unary forms<br>&gt; merely filling in `startIndex` or `endIndex` automatically. <br></p><p>Ah, you&#39;re right, that&#39;s a dimension of simplicity I hadn&#39;t considered<br>(could I have said that in a more complicated way?!)<br></p><p>&gt; Like the `..&lt;` operator itself, I think we&#39;re better off with ugly<br>&gt; clarity than pretty vagueness.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
