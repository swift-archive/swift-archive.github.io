<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Change infix operator attributes syntax to be more consistent with the rest of the language</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March  6, 2016 at 12:00:00pm</p></header><div class="content"><p>First of all, I suggest that we remove `assignment` from Swift 2.2 in any<br>case. It has been deprecated for long enough.<br></p><p>Operator declarations are always global.<br>Operator declarations of the same operator are always in conflict, even if<br>in different modules.<br>Therefore, I believe, operators would be best defined using directive<br>syntax:<br></p><p>#operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>#operator(!, fixity: postfix)<br></p><p>It&#39;s obvious from this declaration that it must be global and must not be<br>duplicated even in different modules (remember C macros?).<br>It would allow us to remove operator declaration grammar entirely, add a<br>directive instead. Simplification of grammar and consistency is one of<br>directions for Swift 2.2 and Swift 3.0.<br></p><p>Why not curly braces? Curly braces in Swift declarations are used to<br>declare multiple &quot;child&quot; entities. On the other hand, attributes and<br>directives are used with *preudo-arguments*.<br>I also want to remind the main difference between attributes and directives<br>in Swift. @-attributes always stand before something and modify it.<br>#-directives are stand-alone things on themselves.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/22f9f2f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Change infix operator attributes syntax to be more consistent with the rest of the language</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  6, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; First of all, I suggest that we remove `assignment` from Swift 2.2 in any case. It has been deprecated for long enough.<br>&gt; <br>&gt; Operator declarations are always global.<br>&gt; Operator declarations of the same operator are always in conflict, even if in different modules.<br>&gt; Therefore, I believe, operators would be best defined using directive syntax:<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>&gt; #operator(!, fixity: postfix)<br>&gt; <br>&gt; It&#39;s obvious from this declaration that it must be global and must not be duplicated even in different modules (remember C macros?).<br>&gt; It would allow us to remove operator declaration grammar entirely, add a directive instead. Simplification of grammar and consistency is one of directions for Swift 2.2 and Swift 3.0.<br>&gt; <br>&gt; Why not curly braces? Curly braces in Swift declarations are used to declare multiple &quot;child&quot; entities. On the other hand, attributes and directives are used with *preudo-arguments*.<br>&gt; I also want to remind the main difference between attributes and directives in Swift. @-attributes always stand before something and modify it. #-directives are stand-alone things on themselves.<br></p><p>Treating it as a compiler directive is an interesting idea. It certainly doesn&#39;t work anything like other declarations in Swift; a compiler directive might drive that point home.<br></p><p>I don&#39;t really like this specific design, though—it doesn&#39;t really match the look and feel of existing directives. Looking through the Swift book, I believe the only compiler directive that actually *changes* anything is `#setline` (The Directive Formerly Known As `#line`). Its parameters consist of an unmarked list of values with no separator or labeling. Trying to duplicate that style would give us something like this:<br></p><p>	#operator &lt;&gt; infix left 100<br></p><p>That&#39;s, um, pretty bad. There *is* precedent for function-like constructs, though, so perhaps we could do this:<br></p><p>	#operator &lt;&gt; infix(associativity: left, precedence: 100)<br>	#operator ! prefix<br></p><p>That&#39;s actually not too bad—it connects the attributes very strongly to the `infix` keyword while still putting those details at the end of the statement so they don&#39;t obscure the more important bits.<br></p><p>One other issue is that the compiler directives which are permitted in statement position (rather than expressions like `#line` or `#available(...)`) are &quot;verb-y&quot;—they read as commands, not nouns. It would probably be more consistent to use a verb of some kind:<br></p><p>	#addoperator &lt;&gt; infix(associativity: left, precedence: 100)<br>	#defoperator &lt;&gt; infix(associativity: left, precedence: 100)<br></p><p>A space would make that more readable (even if it would break consistency with `#setline`:<br></p><p>	#add operator &lt;&gt; infix(associativity: left, precedence: 100)<br>	#def operator &lt;&gt; infix(associativity: left, precedence: 100)<br></p><p>Or, more fancifully:<br></p><p>	#invent operator &lt;&gt; infix(associativity: left, precedence: 100)<br>	#adopt operator &lt;&gt; infix(associativity: left, precedence: 100)<br></p><p>In theory, this could become a mechanism to extend the grammar in other ways, like:<br></p><p>	// add `foo?.bar()` to grammar<br>	#invent dispatcher ?. infix<br></p><p>	// add `if cond { statements } else { statements }` to grammar<br>	#invent statement if controlflow(_: expression, _: block, else: block)<br></p><p>But that&#39;s a whole different kind of fanciful.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Change infix operator attributes syntax to be more consistent with the rest of the language</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I don&#39;t really like this specific design, though—it doesn&#39;t really match<br>the look and feel of existing directives.<br></p><p>I propose that all compiler directives (that have arguments) be formatted<br>in pseudo-function form:<br>#setline(1, file: &quot;main.swift&quot;)<br>I&#39;ll create a proposal for this, which will go hand-to-hand with my syntax<br>for operators.<br></p><p>Additionally, I&#39;ve come up with an idea for complete operators overhaul.<br>The main suggestions are as follows:<br></p><p>1.<br>All operators are available without any pre-definition:<br></p><p>postfix func ! &lt;T&gt;(left: T?) -&gt; T<br></p><p>func &lt;&gt;(left: Int, right: Int) -&gt; Bool  // assuming infix&lt;&gt;, no<br>associativity, no precedence<br></p><p>1 ||| 2  // error: function |||(Int, Int) is not defined<br></p><p>2.<br>If we want to globally set associativity or precedence for infix operators,<br>we write:<br></p><p>#operator(|||, associativity: left, precedence: 100)<br></p><p>These operator configuration directives must not be in conflict. We can<br>omit one or both of parameters:<br></p><p>#operator(|||, precedence: 100)<br>#operator(|||)  // just disallow other #operator directives<br></p><p>2016-03-06 14:44 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt; &gt; First of all, I suggest that we remove `assignment` from Swift 2.2 in<br>&gt; any case. It has been deprecated for long enough.<br>&gt; &gt;<br>&gt; &gt; Operator declarations are always global.<br>&gt; &gt; Operator declarations of the same operator are always in conflict, even<br>&gt; if in different modules.<br>&gt; &gt; Therefore, I believe, operators would be best defined using directive<br>&gt; syntax:<br>&gt; &gt;<br>&gt; &gt; #operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>&gt; &gt; #operator(!, fixity: postfix)<br>&gt; &gt;<br>&gt; &gt; It&#39;s obvious from this declaration that it must be global and must not<br>&gt; be duplicated even in different modules (remember C macros?).<br>&gt; &gt; It would allow us to remove operator declaration grammar entirely, add a<br>&gt; directive instead. Simplification of grammar and consistency is one of<br>&gt; directions for Swift 2.2 and Swift 3.0.<br>&gt; &gt;<br>&gt; &gt; Why not curly braces? Curly braces in Swift declarations are used to<br>&gt; declare multiple &quot;child&quot; entities. On the other hand, attributes and<br>&gt; directives are used with *preudo-arguments*.<br>&gt; &gt; I also want to remind the main difference between attributes and<br>&gt; directives in Swift. @-attributes always stand before something and modify<br>&gt; it. #-directives are stand-alone things on themselves.<br>&gt;<br>&gt; Treating it as a compiler directive is an interesting idea. It certainly<br>&gt; doesn&#39;t work anything like other declarations in Swift; a compiler<br>&gt; directive might drive that point home.<br>&gt;<br>&gt; I don&#39;t really like this specific design, though—it doesn&#39;t really match<br>&gt; the look and feel of existing directives. Looking through the Swift book, I<br>&gt; believe the only compiler directive that actually *changes* anything is<br>&gt; `#setline` (The Directive Formerly Known As `#line`). Its parameters<br>&gt; consist of an unmarked list of values with no separator or labeling. Trying<br>&gt; to duplicate that style would give us something like this:<br>&gt;<br>&gt;         #operator &lt;&gt; infix left 100<br>&gt;<br>&gt; That&#39;s, um, pretty bad. There *is* precedent for function-like constructs,<br>&gt; though, so perhaps we could do this:<br>&gt;<br>&gt;         #operator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;         #operator ! prefix<br>&gt;<br>&gt; That&#39;s actually not too bad—it connects the attributes very strongly to<br>&gt; the `infix` keyword while still putting those details at the end of the<br>&gt; statement so they don&#39;t obscure the more important bits.<br>&gt;<br>&gt; One other issue is that the compiler directives which are permitted in<br>&gt; statement position (rather than expressions like `#line` or<br>&gt; `#available(...)`) are &quot;verb-y&quot;—they read as commands, not nouns. It would<br>&gt; probably be more consistent to use a verb of some kind:<br>&gt;<br>&gt;         #addoperator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;         #defoperator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;<br>&gt; A space would make that more readable (even if it would break consistency<br>&gt; with `#setline`:<br>&gt;<br>&gt;         #add operator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;         #def operator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;<br>&gt; Or, more fancifully:<br>&gt;<br>&gt;         #invent operator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;         #adopt operator &lt;&gt; infix(associativity: left, precedence: 100)<br>&gt;<br>&gt; In theory, this could become a mechanism to extend the grammar in other<br>&gt; ways, like:<br>&gt;<br>&gt;         // add `foo?.bar()` to grammar<br>&gt;         #invent dispatcher ?. infix<br>&gt;<br>&gt;         // add `if cond { statements } else { statements }` to grammar<br>&gt;         #invent statement if controlflow(_: expression, _: block, else:<br>&gt; block)<br>&gt;<br>&gt; But that&#39;s a whole different kind of fanciful.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/20eb6c1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Proposal] Change infix operator attributes syntax to be more consistent with the rest of the language</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>March  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; &gt; I don&#39;t really like this specific design, though—it doesn&#39;t really<br>&gt; match the look and feel of existing directives.<br>&gt;<br>&gt; I propose that all compiler directives (that have arguments) be<br>&gt; formatted in pseudo-function form:<br>&gt; #setline(1, file: &quot;main.swift&quot;)<br>&gt; I&#39;ll create a proposal for this, which will go hand-to-hand with my<br>&gt; syntax for operators.<br>&gt;<br>&gt; Additionally, I&#39;ve come up with an idea for complete operators<br>&gt; overhaul. The main suggestions are as follows:<br>If you intend to draft a proposal for this that encompasses operators,<br>I&#39;ll happily hold off. My gut feeling though is that a proposal that<br>standardizes directives and also changes how operators are declared may<br>be better served if they were split into two distinct proposals.<br>&gt;<br>&gt; 1. <br>&gt; All operators are available without any pre-definition:<br>&gt;<br>&gt; postfix func ! &lt;T&gt;(left: T?) -&gt; T <br>&gt;<br>&gt; func &lt;&gt;(left: Int, right: Int) -&gt; Bool  // assuming infix&lt;&gt;, no<br>&gt; associativity, no precedence<br>&gt;<br>&gt; 1 ||| 2  // error: function |||(Int, Int) is not defined<br>&gt;<br>This is interesting, but I wonder if an infix operator function with<br>more esoteric operator characters would be easily identifiable as an<br>operator vs a normal function. Operator declarations don&#39;t need to be<br>near their function definitions though, and this is technically possible<br>to do today anyways, so maybe my concern with this change is unfounded.<br>One way to make this be 100% clear to the reader though would be to<br>require infix in front of func, just like prefix and postfix which I<br>kind of like.<br>&gt; 2.<br>&gt; If we want to globally set associativity or precedence for infix<br>&gt; operators, we write:<br>&gt;<br>&gt; #operator(|||, associativity: left, precedence: 100)<br>&gt;<br>&gt; These operator configuration directives must not be in conflict. We<br>&gt; can omit one or both of parameters:<br>&gt;<br>&gt; #operator(|||, precedence: 100)<br>&gt; #operator(|||)  // just disallow other #operator directives<br>I agree that the compiler directive look is interesting (though it&#39;s not<br>my most preferred method of declaring operators aesthetically). However,<br>omitting fixity here, as this example does, could constrain the design<br>of future changes that might add behavior control to prefix and postix<br>operators, and in my opinion it&#39;s a better idea to leave that avenue open.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/c7445c9c/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Change infix operator attributes syntax to be more consistent with the rest of the language</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>March  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Le 6 mars 2016 à 12:44, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; First of all, I suggest that we remove `assignment` from Swift 2.2 in any case. It has been deprecated for long enough.<br>&gt;&gt; <br>&gt;&gt; Operator declarations are always global.<br>&gt;&gt; Operator declarations of the same operator are always in conflict, even if in different modules.<br>&gt;&gt; Therefore, I believe, operators would be best defined using directive syntax:<br>&gt;&gt; <br>&gt;&gt; #operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>&gt;&gt; #operator(!, fixity: postfix)<br>&gt;&gt; <br>&gt;&gt; It&#39;s obvious from this declaration that it must be global and must not be duplicated even in different modules (remember C macros?).<br>&gt;&gt; It would allow us to remove operator declaration grammar entirely, add a directive instead. Simplification of grammar and consistency is one of directions for Swift 2.2 and Swift 3.0.<br>&gt;&gt; <br>&gt;&gt; Why not curly braces? Curly braces in Swift declarations are used to declare multiple &quot;child&quot; entities. On the other hand, attributes and directives are used with *preudo-arguments*.<br>&gt;&gt; I also want to remind the main difference between attributes and directives in Swift. @-attributes always stand before something and modify it. #-directives are stand-alone things on themselves.<br>&gt; <br>&gt; Treating it as a compiler directive is an interesting idea. It certainly doesn&#39;t work anything like other declarations in Swift; a compiler directive might drive that point home.<br>&gt; <br>&gt; I don&#39;t really like this specific design, though—it doesn&#39;t really match the look and feel of existing directives. Looking through the Swift book, I believe the only compiler directive that actually *changes* anything is `#setline` (The Directive Formerly Known As `#line`). Its parameters consist of an unmarked list of values with no separator or labeling. Trying to duplicate that style would give us something like this:<br></p><p>As describe in the #setline change proposition, #setline is a tool generated directive used only by the compiler. No time has been waste to try to design it to be ‘swift like’ or readable, or anything else, and so I don’t think we should use it as an example in any design discussion.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/c0293727/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
