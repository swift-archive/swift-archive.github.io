<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>August  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Garth<br></p><p>&gt; I’m not sure why you’re trying to avoid sequences - as far as the actual values you are iterating over, your needs seem to be pretty well covered by the existing stride() family.<br></p><p> I am not avoiding per se the use of Strides &amp; Sequence &amp; Co.<br> It is just because I simply don’t need them in my iterator functions.<br>&gt; <br>&gt; Given that you just want to flatten the call sites, perhaps something like this would suit your needs:<br>&gt; <br>&gt; let xrange = stride(from:  0.0, to: 30.0, by: 10.0)<br>&gt; let yrange = stride(from:  0.0, to: 20.0, by: 5.0)<br>&gt; let zrange = stride(from: 10.0, to:-10.0, by:-5.0)<br>&gt; <br>&gt; for (x, y, z) in cartesianProduct(xrange, yrange, zrange) {<br>&gt;    print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>&gt;    if z &lt; 0.0 {<br>&gt;        print ( &quot;** z value \(z) is below zero! **&quot; )<br>&gt;        break<br>&gt;    }<br>&gt; }<br>&gt; Using strides removes the need for any of the NumericType labels, and cartesianProduct() would be usable for any (reiterable) sequences, not just your designated types. <br></p><p>True. but what I have now works. all I need was new iterators for numeric type as soon as possible <br>because the for;; will be no longer available in 3.0.<br>As a sort of spin-off I also made it for 2 and 3 dimensions.<br>For my apps this is sufficient and even better to use than the nested for;;for;; <br></p><p>I am currently trying to write an iterator that should work<br>with a variable depth of levels. A recursive approach<br>Currently it is under construction not yet working as expected.<br>I cannot wrap my brain around the recursive part. (yet)<br>will drop it for a day or two. :o) <br>You can try / improve it in your xcode playground if you like. is 2.3 but should also work in 3.0.<br></p><p>struct IteratorParameters&lt;T:NumericType&gt;<br>{<br>    let start: T<br>    let step:  T<br>    let test: (T) -&gt; Bool<br>}<br></p><p>func iterateR&lt;T: NumericType&gt;( parameters: [IteratorParameters&lt;T&gt;], block: (Int,[T]) -&gt; Bool)<br>{<br>    var currents = [T]()<br>    for parm in parameters<br>    {<br>        currents.append(parm.start)   // initialize current values with start values.<br>    }<br>    <br>    let levels = parameters.count - 1<br>    var level  = 0<br></p><p>    //——under construction————obviously still not ok here---------------------------<br>    func iterateLevel()  // recursive nested function.<br>    {<br>        <br>        while parameters[level].test(currents[level]) &amp;&amp; block(level,currents)<br>        {<br>            currents[level] = currents[level] + parameters[level].step<br>            iterateLevel()  // recursive<br>        }<br>        level = level + 1<br>        print(&quot;\n&quot;)<br>    }<br>    //-------------------------------------------------------------------------------<br>    iterateLevel()<br>}<br></p><p><br>func testIteratorR()<br>{<br>    <br>    var itparms = [IteratorParameters&lt;Int&gt;]()<br>    <br>    itparms.append( IteratorParameters( start: 0, step :    1, test: {$0 &lt;  3} ) )<br>    itparms.append( IteratorParameters( start: 0, step :    1, test: {$0 &lt;  3} ) )<br>    itparms.append( IteratorParameters( start: 0, step :    1, test: {$0 &lt;  3} ) )<br>    itparms.append( IteratorParameters( start: 0, step :    1, test: {$0 &lt;  3} ) )<br>    <br>    iterateR(itparms,<br>             block: {lvl, values in<br>                         print(&quot;level=\(lvl) values = \(values)&quot;)<br>                       return true    } )<br>}<br></p><p><br>&gt; <br>&gt; If you want a language issue to obsess over, I suggest the inflexibility of tuples, which force you to have a separate wrapper for each number of dimensions. :-)<br> :o) I find very little use for tuples, except perhaps when tuples are used to pass byte arrays to lower-level functions, and even then.<br>I am more and more less “obsessed” with changing and disappearing  language features, because <br>in many cases, in Swift increasingly you can roll your own to replace them or even make something better, if really needed.<br>like in Smalltalk as well. <br>&gt; <br>&gt; I would have thought there’d be an off-the-shelf cartesian product somewhere that you could use, but it doesn’t seem to come up in the Google. It’d look something like this. (This is causing a compiler crash in Xcode 8b3 and so is not completely vetted, but it’s probably close…)<br></p><p>Will try your solution (looks clever)  although I don’t need the collection “by-product”  Perhaps more suited for<br>in progs that have a more functional programming inclination?<br>&gt; <br>&gt; func cartesianProduct&lt;U, V where U: Sequence, V == U.Iterator.Element&gt;(_ args: U...) -&gt;<br>&gt;    AnyIterator&lt;[V]&gt;<br>&gt; {<br>&gt;    var iterators = args.map { $0.makeIterator() }<br>&gt;    var values = [V?]()<br>&gt;    for i in 0 ... iterators.endIndex {<br>&gt;        values.append(iterators[i].next())<br>&gt;    }<br>&gt;    var done = values.contains { $0 == nil }<br>&gt; <br>&gt;    return AnyIterator() {<br>&gt;        if done {<br>&gt;            return nil<br>&gt;        }<br>&gt;        let thisValue = values.map { $0! }<br>&gt;        var i = args.endIndex<br>&gt;        repeat {<br>&gt;            values[i] = iterators[i].next()<br>&gt;            if values[i] != nil {<br>&gt;                return thisValue<br>&gt;            } else if i == 0 {<br>&gt;                done = true<br>&gt;                return thisValue<br>&gt;            } else {<br>&gt;                iterators[i] = args[i].makeIterator()<br>&gt;                values[i] = iterators[i].next()<br>&gt;                i -= 1<br>&gt;            }<br>&gt;        } while true<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; func cartesianProduct&lt;U, V where U: Sequence, V == U.Iterator.Element&gt;(_ a: U, _ b: U, _ c: U) -&gt;<br>&gt;    AnyIterator&lt;(V, V, V)&gt;<br>&gt; {<br>&gt;    var subIterator: AnyIterator&lt;[V]&gt; = cartesianProduct(a, b, c)<br>&gt;    return AnyIterator() {<br>&gt;        if let value = subIterator.next() {<br>&gt;            return (value[0], value[1], value[2])<br>&gt;        }<br>&gt;        return nil<br>&gt;    }<br>&gt; }<br></p><p>Kind Regards<br>Ted<br></p><p><br></p><p>&gt; Garth<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 30, 2016, at 1:48 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; thanks for the tip about Hirundo app!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A positive side-effect of removing the classical for;; loop<br>&gt;&gt;&gt;&gt; (yes, it’s me saying this :o)  is that it forces me to find<br>&gt;&gt;&gt;&gt; a good and generic equivalent for it, <br>&gt;&gt;&gt;&gt; making the conversion of my for;;s to 3.0 easier.<br>&gt;&gt;&gt;&gt; which is *not* based on collections or sequences and<br>&gt;&gt;&gt;&gt; does not rely on deeper calls to Sequence etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; so, I’ve made the functions [iterator, iterator2D, iterator3D]  (hereunder)<br>&gt;&gt;&gt;&gt; wich btw clearly demonstrate the power and flexibility of Swift. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Very straightforward, and efficient (i assume) just like the classical for;; loop.  <br>&gt;&gt;&gt;&gt; It works quite well in my sources.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a spin-off,  I’ve extended these to iterators for matrices 2D and cubes? 3D...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Question: <br>&gt;&gt;&gt;&gt; Perhaps implementing “multi dimensional iterator functions<br>&gt;&gt;&gt;&gt; in Swift might  be a good idea. so that is no longer necessary to nest/nest/nest iterators. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Met vriendelijke groeten, sorry for my “intensity” in discussing the classical for;; <br>&gt;&gt;&gt;&gt; I&#39;ll have to rethink this for;; again..  <br>&gt;&gt;&gt;&gt; Thanks, Ted.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any remarks ( all ), suggestions about the code hereunder:              ? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol NumericType<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;    func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;    func -(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;    func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;    func /(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;    func %(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Double : NumericType { }<br>&gt;&gt;&gt;&gt; extension Float  : NumericType { }<br>&gt;&gt;&gt;&gt; extension CGFloat: NumericType { }<br>&gt;&gt;&gt;&gt; extension Int    : NumericType { }<br>&gt;&gt;&gt;&gt; extension Int8   : NumericType { }<br>&gt;&gt;&gt;&gt; extension Int16  : NumericType { }<br>&gt;&gt;&gt;&gt; extension Int32  : NumericType { }<br>&gt;&gt;&gt;&gt; extension Int64  : NumericType { }<br>&gt;&gt;&gt;&gt; extension UInt   : NumericType { }<br>&gt;&gt;&gt;&gt; extension UInt8  : NumericType { }<br>&gt;&gt;&gt;&gt; extension UInt16 : NumericType { }<br>&gt;&gt;&gt;&gt; extension UInt32 : NumericType { }<br>&gt;&gt;&gt;&gt; extension UInt64 : NumericType { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Simple iterator with generic parameters, with just a few lines of code.<br>&gt;&gt;&gt;&gt; /// for most numeric types (see above)<br>&gt;&gt;&gt;&gt; /// Usage Example:<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; ///   iterate(xmax, { $0 &gt; xmin}, -xstep,<br>&gt;&gt;&gt;&gt; ///    {x in<br>&gt;&gt;&gt;&gt; ///        print(&quot;x = \(x)&quot;)<br>&gt;&gt;&gt;&gt; ///        return true  // returning false acts like a break<br>&gt;&gt;&gt;&gt; ///     } )<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; ///  -Parameter vstart: Initial value<br>&gt;&gt;&gt;&gt; ///  -Parameter step:    The iteration stepping value.<br>&gt;&gt;&gt;&gt; ///  -Parameter test:    A block with iteration test. e.g. {$0 &gt; 10}<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; ///  -Parameter block:   A block to be executed with each step.<br>&gt;&gt;&gt;&gt; ///       The block must include a return true (acts like &quot;continue&quot;)<br>&gt;&gt;&gt;&gt; ///                                   or false (acts like &quot;break&quot;)<br>&gt;&gt;&gt;&gt; ///  -Please Note: <br>&gt;&gt;&gt;&gt; ///  There is minor precision loss ca: 1/1000 ... 1/500 <br>&gt;&gt;&gt;&gt; ///  when iterating with floating point numbers.<br>&gt;&gt;&gt;&gt; ///  However, in most cases this can be safely ignored.<br>&gt;&gt;&gt;&gt; ///  made by ted van gaalen.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func iterate&lt;T:NumericType&gt; (<br>&gt;&gt;&gt;&gt;                    vstart:  T,<br>&gt;&gt;&gt;&gt;                   _ vstep:  T,<br>&gt;&gt;&gt;&gt;                   _  test: (T) -&gt; Bool,<br>&gt;&gt;&gt;&gt;                   _ block: (T) -&gt; Bool )<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;    var current = vstart<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    while test(current) &amp;&amp; block(current)<br>&gt;&gt;&gt;&gt;    {<br>&gt;&gt;&gt;&gt;        current = current + vstep<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// X,Y 2D matrix (table) iterator with generic parameters<br>&gt;&gt;&gt;&gt; func iterate2D&lt;T:NumericType&gt; (<br>&gt;&gt;&gt;&gt;     xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;&gt;&gt;&gt;   _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;&gt;&gt;&gt;   _ block: (T,T) -&gt; Bool )<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;    var xcurrent = xstart<br>&gt;&gt;&gt;&gt;    var ycurrent = ystart<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var dontStop = true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;&gt;    {<br>&gt;&gt;&gt;&gt;        ycurrent = ystart<br>&gt;&gt;&gt;&gt;        while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;&gt;        {<br>&gt;&gt;&gt;&gt;            dontStop = block(xcurrent, ycurrent)<br>&gt;&gt;&gt;&gt;            ycurrent = ycurrent + ystep<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;        xcurrent = xcurrent + xstep<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// X,Y,Z 3D (cubic) iterator with generic parameters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func iterate3D&lt;T:NumericType&gt; (<br>&gt;&gt;&gt;&gt;    xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;&gt;&gt;&gt;  _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;&gt;&gt;&gt;  _ zstart:  T,  _ zstep: T, _ ztest: (T) -&gt; Bool,<br>&gt;&gt;&gt;&gt;      _ block: (T,T,T) -&gt; Bool )<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;    var xcurrent = xstart<br>&gt;&gt;&gt;&gt;    var ycurrent = ystart<br>&gt;&gt;&gt;&gt;    var zcurrent = zstart<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var dontStop = true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;&gt;    {<br>&gt;&gt;&gt;&gt;        ycurrent = ystart<br>&gt;&gt;&gt;&gt;        while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;&gt;        {<br>&gt;&gt;&gt;&gt;            zcurrent = zstart<br>&gt;&gt;&gt;&gt;            while ztest(zcurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;&gt;            {<br>&gt;&gt;&gt;&gt;                dontStop = block(xcurrent, ycurrent, zcurrent)<br>&gt;&gt;&gt;&gt;                zcurrent = zcurrent + zstep<br>&gt;&gt;&gt;&gt;            }<br>&gt;&gt;&gt;&gt;            ycurrent = ycurrent + ystep<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;        xcurrent = xcurrent + xstep<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func testIterator()<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;    iterate(0.0, 0.5, {$0 &lt; 1000.00000} ,<br>&gt;&gt;&gt;&gt;            { value in<br>&gt;&gt;&gt;&gt;                print(&quot;Value = \(value) &quot;)<br>&gt;&gt;&gt;&gt;                return true<br>&gt;&gt;&gt;&gt;    } )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    let startv: CGFloat = -20.0<br>&gt;&gt;&gt;&gt;    let stepv: CGFloat =   0.5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    iterate(startv, stepv, {$0 &lt; 1000.00000} ,<br>&gt;&gt;&gt;&gt;            { val in<br>&gt;&gt;&gt;&gt;                print(&quot;R = \(val)&quot;)<br>&gt;&gt;&gt;&gt;                return true<br>&gt;&gt;&gt;&gt;    } )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    let tolerance = 0.01 // boundary tolerance for floating point type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    iterate2D( 0.0, 10.0, { $0 &lt; 100.0 + tolerance } ,<br>&gt;&gt;&gt;&gt;               0.0,  5.0, { $0 &lt;  50.0 + tolerance } ,<br>&gt;&gt;&gt;&gt;               {x,y in<br>&gt;&gt;&gt;&gt;                print(&quot;x = \(x) y = \(y)&quot;)<br>&gt;&gt;&gt;&gt;                return true  // false from block stops iterating ( like break)<br>&gt;&gt;&gt;&gt;                } )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    iterate3D( 0.0,  10.0, { $0 &lt;   30.0 } ,  // x<br>&gt;&gt;&gt;&gt;               0.0,   5.0, { $0 &lt;   20.0 } ,  // y<br>&gt;&gt;&gt;&gt;               10.0, -5.0, { $0 &gt;  -10.0 } ,  // z<br>&gt;&gt;&gt;&gt;               {x,y,z in<br>&gt;&gt;&gt;&gt;                    print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>&gt;&gt;&gt;&gt;                    if z &lt; 0.0<br>&gt;&gt;&gt;&gt;                    {<br>&gt;&gt;&gt;&gt;                        print ( &quot;** z value \(z) is below zero! **&quot; )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                        return false  // (acts as break in for;;)<br>&gt;&gt;&gt;&gt;                    }<br>&gt;&gt;&gt;&gt;                    return true  // return stmt is obligatory (continue)<br>&gt;&gt;&gt;&gt;               } )<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/1ad5ef59/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
