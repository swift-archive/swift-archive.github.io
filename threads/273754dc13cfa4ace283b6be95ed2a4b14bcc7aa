<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri Jan 22 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 22, 2016, at 1:57 PM, Jeff Kelley via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How do you handle naming non-mutating versions of these operations?<br>&gt;&gt;&gt; Conjugating other irregular verbs also imposes a barrier on<br>&gt;&gt;&gt; developers whose first language is not English.<br>&gt;&gt; <br>&gt;&gt; Swift could use “after” as a prefix, or something similar.<br>&gt;&gt; <br>&gt;&gt; array.sort()<br>&gt;&gt; array.afterSort()<br>&gt;&gt; <br>&gt;&gt; I was tempted to say “afterSorting()” but that has the same problems mentioned above.<br>&gt;<br>&gt; That&#39;s reminiscent of the way the classic Cocoa naming guidelines<br>&gt; cleverly avoided these issues by using the &#39;did-&#39; prefix consistently<br>&gt; instead of ever conjugating verbs into preterite tense. &#39;after&#39; is a<br>&gt; bit awkward, though, as are any other equivalent prefixes i can think<br>&gt; of that have the same effect on the past participle (havingSplit?<br>&gt; bySplitting?)<br></p><p>&quot;splitting&quot; works perfectly well on its own, IMO.  If there&#39;s an<br>argument to the method, you&#39;ll want some kind of preposition like &quot;At&quot;<br>or &quot;On&quot; afterwards.<br></p><p>I think the real problem cases for this guideline as written are the<br>ones where there&#39;s no underlying verb, like &quot;union&quot;, or where the verb<br>already has a strong non-mutating connotation, like &quot;exclusiveOr.&quot;<br>Those are the ones that really cry out for a different convention, like<br>&quot;InPlace.&quot;  <br></p><p>In developing the guidelines, we had some internal arguments about<br>whether it was worth adding complexity to accomodate those cases, or<br>whether we should simply not mention them and let them get sorted out on<br>a case-by-case basis when they come up in code review.  We didn&#39;t reach<br>consensus, so this would be a useful area in which to get community<br>input.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 23, 2016 at 11:00:00pm</p></header><div class="content"><p>This is a very real problem. It has come up a nontrivial number of times during my attempt to conform Surge &lt;https://github.com/mattt/Surge&gt; to the API Guideline. My work in progress version is here &lt;https://github.com/TheArtOfEngineering/Jolt&gt;.<br></p><p>Surge is in essence Swift a wrapper around the Accelerate framework. Originally the Surge API was constructed as a collection of global functions that mirrored the Accelerate framework exactly. I’m currently attempting to bring the API in line with the API Guideline and to extend CollectionType to have methods with these operations.<br></p><p>Thus I have three different types of API end points.<br></p><p>- Global functions<br>- Non-mutating methods<br>- Mutating methods<br></p><p>These distinctions could potentially be important given that these are all performance critical vector operations. Also given that this is extending the Accelerate framework many functions are named in mathematical terms, which makes them more difficult to name according to the current guidelines. Consider the following functions.<br></p><p>First let’s consider a function like `add` which operates on vectors and whose output is also a vector. This function is straightforward to conform to the API Guidelines, the result of which is quite satisfying. <br></p><p>The global function is called `add`, the mutating method is called `add`, and the non-mutating method is called `adding`.<br>	<br>	add(x, y) vs x.add(y) vs x.adding(y)<br></p><p>Excellent.<br></p><p>Next, however, consider the vector function `sum`. In this case the global function is named `sum`. There is no corresponding mutating method for `sum` since it does not output a vector. Should the non-mutating method therefore be called `sum` or `summed`? The Guideline is not so explicit about this. You could conceivably make an argument for either, although I think `sum` would win out because there is no non-mutating version. If there is no current mutating version for an API, but there could conceivably be one in the future, I assume that it should use the ‘ed/ing&#39; rule. <br></p><p>sum(myVec) vs myVec.sum() // &lt;- this is non-mutating<br></p><p>So far, acceptable.<br></p><p>What about the function `sin`? <br></p><p>Again, the global function is just `sin`. How, though, do you distinguish the mutating and non-mutating methods?<br></p><p>sin(x) vs x.sin() vs x.sined()?<br></p><p>Fortunately, the API Guideline does have a comment on this. In the case of `sin`, it is reasonable to only provide the global function in accordance with mathematical convention. The problem is that memory constricted environments may require that the calculation be done in place. What that should look like is not clear.<br></p><p>What about functions that are almost always abbreviated by convention like `ceil`?<br></p><p>ceil(x) vs x.ceil() vs x.ceiled()<br></p><p>In this case the InPlace prefix can save us. x.ceilInPlace() would work.<br></p><p>Another good one is `remainder`.<br></p><p>remainder(x) vs x.remainder() vs x.remaindered() ?<br></p><p>These are just a few examples, but there are many many others in this API alone that the Guidelines struggle to address. Most are problematic for the same reasons outlined above. If it weren’t necessarily critical to reduce memory use it would suffice to just include the global function for many of them.<br></p><p>e.g.<br>reciprocal<br>threshold<br>floor<br>abs -&gt; ???<br>exp -&gt; x.exponentiated()?<br>exp2 or expSquared<br>logb<br>mean<br>dot<br>cross<br></p><p>For some functions like `dot` we could conceivably rely on the fact that familiar users would know that the return type is not the same as the arguments. I would argue however, that, if we were going to rely on the type information of the returned value then perhaps that’s what should be relied on exclusively to determine whether a method is mutating or not. <br></p><p>All mutating methods should return Void and all non mutating methods should have @warn_unused_result. Thus the context would distinguish it’s mutability. Not a huge fan of this, but with the unused warning result it’s not too bad.<br></p><p>For example.<br></p><p>let y = [...]<br>let x = y.remainder()<br></p><p>vs<br></p><p>var y = […]<br>y.remainder()<br></p><p>I hope this helps to give a little bit of color on a real world example outside of the standard library.<br></p><p>Thanks,<br></p><p>Tyler<br></p><p><br>&gt; On Jan 23, 2016, at 11:00 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jan 22 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 1:57 PM, Jeff Kelley via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How do you handle naming non-mutating versions of these operations?<br>&gt;&gt;&gt;&gt; Conjugating other irregular verbs also imposes a barrier on<br>&gt;&gt;&gt;&gt; developers whose first language is not English.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift could use “after” as a prefix, or something similar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; array.sort()<br>&gt;&gt;&gt; array.afterSort()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was tempted to say “afterSorting()” but that has the same problems mentioned above.<br>&gt;&gt; <br>&gt;&gt; That&#39;s reminiscent of the way the classic Cocoa naming guidelines<br>&gt;&gt; cleverly avoided these issues by using the &#39;did-&#39; prefix consistently<br>&gt;&gt; instead of ever conjugating verbs into preterite tense. &#39;after&#39; is a<br>&gt;&gt; bit awkward, though, as are any other equivalent prefixes i can think<br>&gt;&gt; of that have the same effect on the past participle (havingSplit?<br>&gt;&gt; bySplitting?)<br>&gt; <br>&gt; &quot;splitting&quot; works perfectly well on its own, IMO.  If there&#39;s an<br>&gt; argument to the method, you&#39;ll want some kind of preposition like &quot;At&quot;<br>&gt; or &quot;On&quot; afterwards.<br>&gt; <br>&gt; I think the real problem cases for this guideline as written are the<br>&gt; ones where there&#39;s no underlying verb, like &quot;union&quot;, or where the verb<br>&gt; already has a strong non-mutating connotation, like &quot;exclusiveOr.&quot;<br>&gt; Those are the ones that really cry out for a different convention, like<br>&gt; &quot;InPlace.&quot;  <br>&gt; <br>&gt; In developing the guidelines, we had some internal arguments about<br>&gt; whether it was worth adding complexity to accomodate those cases, or<br>&gt; whether we should simply not mention them and let them get sorted out on<br>&gt; a case-by-case basis when they come up in code review.  We didn&#39;t reach<br>&gt; consensus, so this would be a useful area in which to get community<br>&gt; input.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/6c8e7dc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 24, 2016 at 12:00:00am</p></header><div class="content"><p>And by CollectionType, I mean Array. It fits the spirit of the API more closely and I wasn’t able to swing mutability with CollectionType.<br></p><p>And…. I should also mention that I just figured out that<br></p><p>&gt; let y = [...]<br>&gt; let x = y.remainder()<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; var y = […]<br>&gt; y.remainder()<br></p><p>is insufficient for the compiler to disambiguate. The source of my confusion was that the top example works fine, but the bottom one, not so much. I suppose because although in my example the functions marked mutating return Void, in general mutating functions *can* return a value.<br></p><p>So perhaps, as suggested, InPlace or some symbol could be used to disambiguate. <br></p><p>Tyler<br></p><p><br>&gt; On Jan 23, 2016, at 11:36 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a very real problem. It has come up a nontrivial number of times during my attempt to conform Surge &lt;https://github.com/mattt/Surge&gt; to the API Guideline. My work in progress version is here &lt;https://github.com/TheArtOfEngineering/Jolt&gt;.<br>&gt; <br>&gt; Surge is in essence Swift a wrapper around the Accelerate framework. Originally the Surge API was constructed as a collection of global functions that mirrored the Accelerate framework exactly. I’m currently attempting to bring the API in line with the API Guideline and to extend CollectionType to have methods with these operations.<br>&gt; <br>&gt; Thus I have three different types of API end points.<br>&gt; <br>&gt; - Global functions<br>&gt; - Non-mutating methods<br>&gt; - Mutating methods<br>&gt; <br>&gt; These distinctions could potentially be important given that these are all performance critical vector operations. Also given that this is extending the Accelerate framework many functions are named in mathematical terms, which makes them more difficult to name according to the current guidelines. Consider the following functions.<br>&gt; <br>&gt; First let’s consider a function like `add` which operates on vectors and whose output is also a vector. This function is straightforward to conform to the API Guidelines, the result of which is quite satisfying. <br>&gt; <br>&gt; The global function is called `add`, the mutating method is called `add`, and the non-mutating method is called `adding`.<br>&gt; 	<br>&gt; 	add(x, y) vs x.add(y) vs x.adding(y)<br>&gt; <br>&gt; Excellent.<br>&gt; <br>&gt; Next, however, consider the vector function `sum`. In this case the global function is named `sum`. There is no corresponding mutating method for `sum` since it does not output a vector. Should the non-mutating method therefore be called `sum` or `summed`? The Guideline is not so explicit about this. You could conceivably make an argument for either, although I think `sum` would win out because there is no non-mutating version. If there is no current mutating version for an API, but there could conceivably be one in the future, I assume that it should use the ‘ed/ing&#39; rule. <br>&gt; <br>&gt; sum(myVec) vs myVec.sum() // &lt;- this is non-mutating<br>&gt; <br>&gt; So far, acceptable.<br>&gt; <br>&gt; What about the function `sin`? <br>&gt; <br>&gt; Again, the global function is just `sin`. How, though, do you distinguish the mutating and non-mutating methods?<br>&gt; <br>&gt; sin(x) vs x.sin() vs x.sined()?<br>&gt; <br>&gt; Fortunately, the API Guideline does have a comment on this. In the case of `sin`, it is reasonable to only provide the global function in accordance with mathematical convention. The problem is that memory constricted environments may require that the calculation be done in place. What that should look like is not clear.<br>&gt; <br>&gt; What about functions that are almost always abbreviated by convention like `ceil`?<br>&gt; <br>&gt; ceil(x) vs x.ceil() vs x.ceiled()<br>&gt; <br>&gt; In this case the InPlace prefix can save us. x.ceilInPlace() would work.<br>&gt; <br>&gt; Another good one is `remainder`.<br>&gt; <br>&gt; remainder(x) vs x.remainder() vs x.remaindered() ?<br>&gt; <br>&gt; These are just a few examples, but there are many many others in this API alone that the Guidelines struggle to address. Most are problematic for the same reasons outlined above. If it weren’t necessarily critical to reduce memory use it would suffice to just include the global function for many of them.<br>&gt; <br>&gt; e.g.<br>&gt; reciprocal<br>&gt; threshold<br>&gt; floor<br>&gt; abs -&gt; ???<br>&gt; exp -&gt; x.exponentiated()?<br>&gt; exp2 or expSquared<br>&gt; logb<br>&gt; mean<br>&gt; dot<br>&gt; cross<br>&gt; <br>&gt; For some functions like `dot` we could conceivably rely on the fact that familiar users would know that the return type is not the same as the arguments. I would argue however, that, if we were going to rely on the type information of the returned value then perhaps that’s what should be relied on exclusively to determine whether a method is mutating or not. <br>&gt; <br>&gt; All mutating methods should return Void and all non mutating methods should have @warn_unused_result. Thus the context would distinguish it’s mutability. Not a huge fan of this, but with the unused warning result it’s not too bad.<br>&gt; <br>&gt; For example.<br>&gt; <br>&gt; let y = [...]<br>&gt; let x = y.remainder()<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; var y = […]<br>&gt; y.remainder()<br>&gt; <br>&gt; I hope this helps to give a little bit of color on a real world example outside of the standard library.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 11:00 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jan 22 2016, Joe Groff &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 22, 2016, at 1:57 PM, Jeff Kelley via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How do you handle naming non-mutating versions of these operations?<br>&gt;&gt;&gt;&gt;&gt; Conjugating other irregular verbs also imposes a barrier on<br>&gt;&gt;&gt;&gt;&gt; developers whose first language is not English.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift could use “after” as a prefix, or something similar.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; array.sort()<br>&gt;&gt;&gt;&gt; array.afterSort()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was tempted to say “afterSorting()” but that has the same problems mentioned above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s reminiscent of the way the classic Cocoa naming guidelines<br>&gt;&gt;&gt; cleverly avoided these issues by using the &#39;did-&#39; prefix consistently<br>&gt;&gt;&gt; instead of ever conjugating verbs into preterite tense. &#39;after&#39; is a<br>&gt;&gt;&gt; bit awkward, though, as are any other equivalent prefixes i can think<br>&gt;&gt;&gt; of that have the same effect on the past participle (havingSplit?<br>&gt;&gt;&gt; bySplitting?)<br>&gt;&gt; <br>&gt;&gt; &quot;splitting&quot; works perfectly well on its own, IMO.  If there&#39;s an<br>&gt;&gt; argument to the method, you&#39;ll want some kind of preposition like &quot;At&quot;<br>&gt;&gt; or &quot;On&quot; afterwards.<br>&gt;&gt; <br>&gt;&gt; I think the real problem cases for this guideline as written are the<br>&gt;&gt; ones where there&#39;s no underlying verb, like &quot;union&quot;, or where the verb<br>&gt;&gt; already has a strong non-mutating connotation, like &quot;exclusiveOr.&quot;<br>&gt;&gt; Those are the ones that really cry out for a different convention, like<br>&gt;&gt; &quot;InPlace.&quot;  <br>&gt;&gt; <br>&gt;&gt; In developing the guidelines, we had some internal arguments about<br>&gt;&gt; whether it was worth adding complexity to accomodate those cases, or<br>&gt;&gt; whether we should simply not mention them and let them get sorted out on<br>&gt;&gt; a case-by-case basis when they come up in code review.  We didn&#39;t reach<br>&gt;&gt; consensus, so this would be a useful area in which to get community<br>&gt;&gt; input.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/a1e81556/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 24, 2016 at 12:00:00am</p></header><div class="content"><p>Good/important examples.<br></p><p>The problem here seems to be that &quot;sin&quot;, &quot;mean&quot;, &quot;remainder&quot;, etc. read<br>nicely as noun phrases, but the guidelines would recommend -ed/-ing verb<br>forms in this case (methods with both mutating and nonmutating variants),<br>not noun phrases:<br></p><p>    &quot;*When a mutating method is described by a verb, name its nonmutating<br>counterpart according to the &#39;ed/ing&#39; rule*.&quot;<br></p><p>...but we don&#39;t have a verb to which to apply -ed or -ing. (&quot;sined&quot;?<br>&quot;meaned&quot;? &quot;remaindered&quot;?)<br></p><p>I agree that &quot;sinInPlace()&quot;, &quot;meanInPlace()&quot;, &quot;remainderInPlace()&quot; seem to<br>work pretty well, but I&#39;m aware that I&#39;m drawing on experience with the old<br>names of sortInPlace(), subtractInPlace(), etc., and in fact this case is<br>worse because the first words aren&#39;t really verbs (you can&#39;t sine something *in<br>place* any more than you can sine it). &quot;takeSine()&quot; doesn&#39;t sound great<br>either.<br></p><p>One option is to simply not offer mutating versions of these methods; then<br>users can write &quot;y=y.remainder()&quot; with only two extra characters (four with<br>spaces). IMO this is awkward; it also kinda necessitates an<br>isUniquelyReferenced check to avoid unnecessary copying.<br></p><p><br>Jacob &quot;no useful suggestions to see here&quot; Bandes-Storch<br></p><p>On Sat, Jan 23, 2016 at 11:36 PM, Tyler Fleming Cloutier via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is a very real problem. It has come up a nontrivial number of times<br>&gt; during my attempt to conform Surge &lt;https://github.com/mattt/Surge&gt; to<br>&gt; the API Guideline. My work in progress version is here<br>&gt; &lt;https://github.com/TheArtOfEngineering/Jolt&gt;.<br>&gt;<br>&gt; Surge is in essence Swift a wrapper around the Accelerate framework.<br>&gt; Originally the Surge API was constructed as a collection of global<br>&gt; functions that mirrored the Accelerate framework exactly. I’m currently<br>&gt; attempting to bring the API in line with the API Guideline and to extend<br>&gt; CollectionType to have methods with these operations.<br>&gt;<br>&gt; Thus I have three different types of API end points.<br>&gt;<br>&gt; - Global functions<br>&gt; - Non-mutating methods<br>&gt; - Mutating methods<br>&gt;<br>&gt; These distinctions could potentially be important given that these are all<br>&gt; performance critical vector operations. Also given that this is extending<br>&gt; the Accelerate framework many functions are named in mathematical terms,<br>&gt; which makes them more difficult to name according to the current<br>&gt; guidelines. Consider the following functions.<br>&gt;<br>&gt; First let’s consider a function like `add` which operates on vectors and<br>&gt; whose output is also a vector. This function is straightforward to conform<br>&gt; to the API Guidelines, the result of which is quite satisfying.<br>&gt;<br>&gt; The global function is called `add`, the mutating method is called `add`,<br>&gt; and the non-mutating method is called `adding`.<br>&gt; add(x, y) vs x.add(y) vs x.adding(y)<br>&gt;<br>&gt; Excellent.<br>&gt;<br>&gt; Next, however, consider the vector function `sum`. In this case the global<br>&gt; function is named `sum`. There is no corresponding mutating method for<br>&gt; `sum` since it does not output a vector. Should the non-mutating method<br>&gt; therefore be called `sum` or `summed`? The Guideline is not so explicit<br>&gt; about this. You could conceivably make an argument for either, although I<br>&gt; think `sum` would win out because there is no non-mutating version. If<br>&gt; there is no current mutating version for an API, but there could<br>&gt; conceivably be one in the future, I assume that it should use the ‘ed/ing&#39;<br>&gt; rule.<br>&gt;<br>&gt; sum(myVec) vs myVec.sum() // &lt;- this is non-mutating<br>&gt;<br>&gt; So far, acceptable.<br>&gt;<br>&gt; What about the function `sin`?<br>&gt;<br>&gt; Again, the global function is just `sin`. How, though, do you distinguish<br>&gt; the mutating and non-mutating methods?<br>&gt;<br>&gt; sin(x) vs x.sin() vs x.sined()?<br>&gt;<br>&gt; Fortunately, the API Guideline does have a comment on this. In the case of<br>&gt; `sin`, it is reasonable to only provide the global function in accordance<br>&gt; with mathematical convention. The problem is that memory constricted<br>&gt; environments may require that the calculation be done in place. What that<br>&gt; should look like is not clear.<br>&gt;<br>&gt; What about functions that are almost always abbreviated by convention like<br>&gt; `ceil`?<br>&gt;<br>&gt; ceil(x) vs x.ceil() vs x.ceiled()<br>&gt;<br>&gt; In this case the InPlace prefix can save us. x.ceilInPlace() would work.<br>&gt;<br>&gt; Another good one is `remainder`.<br>&gt;<br>&gt; remainder(x) vs x.remainder() vs x.remaindered() ?<br>&gt;<br>&gt; These are just a few examples, but there are many many others in this API<br>&gt; alone that the Guidelines struggle to address. Most are problematic for the<br>&gt; same reasons outlined above. If it weren’t necessarily critical to reduce<br>&gt; memory use it would suffice to just include the global function for many of<br>&gt; them.<br>&gt;<br>&gt; e.g.<br>&gt; reciprocal<br>&gt; threshold<br>&gt; floor<br>&gt; abs -&gt; ???<br>&gt; exp -&gt; x.exponentiated()?<br>&gt; exp2 or expSquared<br>&gt; logb<br>&gt; mean<br>&gt; dot<br>&gt; cross<br>&gt;<br>&gt; For some functions like `dot` we could conceivably rely on the fact that<br>&gt; familiar users would know that the return type is not the same as the<br>&gt; arguments. I would argue however, that, if we were going to rely on the<br>&gt; type information of the returned value then perhaps that’s what should be<br>&gt; relied on exclusively to determine whether a method is mutating or not.<br>&gt;<br>&gt; All mutating methods should return Void and all non mutating methods<br>&gt; should have @warn_unused_result. Thus the context would distinguish it’s<br>&gt; mutability. Not a huge fan of this, but with the unused warning result it’s<br>&gt; not too bad.<br>&gt;<br>&gt; For example.<br>&gt;<br>&gt; let y = [...]<br>&gt; let x = y.remainder()<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; var y = […]<br>&gt; y.remainder()<br>&gt;<br>&gt; I hope this helps to give a little bit of color on a real world example<br>&gt; outside of the standard library.<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt; On Jan 23, 2016, at 11:00 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jan 22 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jan 22, 2016, at 1:57 PM, Jeff Kelley via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jan 22, 2016, at 4:53 PM, Joe Groff via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt;<br>&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How do you handle naming non-mutating versions of these operations?<br>&gt; Conjugating other irregular verbs also imposes a barrier on<br>&gt; developers whose first language is not English.<br>&gt;<br>&gt;<br>&gt; Swift could use “after” as a prefix, or something similar.<br>&gt;<br>&gt; array.sort()<br>&gt; array.afterSort()<br>&gt;<br>&gt; I was tempted to say “afterSorting()” but that has the same problems<br>&gt; mentioned above.<br>&gt;<br>&gt;<br>&gt; That&#39;s reminiscent of the way the classic Cocoa naming guidelines<br>&gt; cleverly avoided these issues by using the &#39;did-&#39; prefix consistently<br>&gt; instead of ever conjugating verbs into preterite tense. &#39;after&#39; is a<br>&gt; bit awkward, though, as are any other equivalent prefixes i can think<br>&gt; of that have the same effect on the past participle (havingSplit?<br>&gt; bySplitting?)<br>&gt;<br>&gt;<br>&gt; &quot;splitting&quot; works perfectly well on its own, IMO.  If there&#39;s an<br>&gt; argument to the method, you&#39;ll want some kind of preposition like &quot;At&quot;<br>&gt; or &quot;On&quot; afterwards.<br>&gt;<br>&gt; I think the real problem cases for this guideline as written are the<br>&gt; ones where there&#39;s no underlying verb, like &quot;union&quot;, or where the verb<br>&gt; already has a strong non-mutating connotation, like &quot;exclusiveOr.&quot;<br>&gt; Those are the ones that really cry out for a different convention, like<br>&gt; &quot;InPlace.&quot;<br>&gt;<br>&gt; In developing the guidelines, we had some internal arguments about<br>&gt; whether it was worth adding complexity to accomodate those cases, or<br>&gt; whether we should simply not mention them and let them get sorted out on<br>&gt; a case-by-case basis when they come up in code review.  We didn&#39;t reach<br>&gt; consensus, so this would be a useful area in which to get community<br>&gt; input.<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/26047fe9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 12:34 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that &quot;sinInPlace()&quot;, &quot;meanInPlace()&quot;, &quot;remainderInPlace()&quot; seem to work pretty well, but I&#39;m aware that I&#39;m drawing on experience with the old names of sortInPlace(), subtractInPlace(), etc., and in fact this case is worse because the first words aren&#39;t really verbs (you can&#39;t sine something in place any more than you can sine it). &quot;takeSine()&quot; doesn&#39;t sound great either.<br></p><p>How about &quot;applyingSine()&quot; , &quot;applyingMean()&quot;, and &quot;applyingRemainder()&quot;? <br></p><p>Cheers, <br></p><p>Curt<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/8238b406/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 24, 2016 at 07:00:00pm</p></header><div class="content"><p>Just to clarify, are you suggesting that the mutating version would be<br>&quot;applySine()&quot;, and the nonmutating version would be &quot;applyingSine()&quot;?<br>On Sun, Jan 24, 2016 at 10:50 AM Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 24, 2016, at 12:34 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree that &quot;sinInPlace()&quot;, &quot;meanInPlace()&quot;, &quot;remainderInPlace()&quot; seem to<br>&gt; work pretty well, but I&#39;m aware that I&#39;m drawing on experience with the old<br>&gt; names of sortInPlace(), subtractInPlace(), etc., and in fact this case is<br>&gt; worse because the first words aren&#39;t really verbs (you can&#39;t sine something *in<br>&gt; place* any more than you can sine it). &quot;takeSine()&quot; doesn&#39;t sound great<br>&gt; either.<br>&gt;<br>&gt;<br>&gt; How about &quot;applyingSine()&quot; , &quot;applyingMean()&quot;, and &quot;applyingRemainder()&quot;?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Curt<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/366a1979/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/446db4307ac0d39e08cd818906ad7af8?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Curt Clifton</string> &lt;curt at curtclifton.net&gt;<p>January 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 11:06 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just to clarify, are you suggesting that the mutating version would be &quot;applySine()&quot;, and the nonmutating version would be &quot;applyingSine()”?<br></p><p>I was thinking `applyingSine()` for the mutating version and just plain old `sin()` for the non-mutating version, or maybe even a computed property, so just `sin`. I’m not really advocating for any of these, but hoping to spur discussion or provide a creative nudge.<br></p><p>Personally, I think I like the `fooInPlace()` convention. It’s unambiguous and sufficiently verbose to perhaps make people think twice about using it.<br></p><p>— Curt<br></p><p><br>&gt; On Sun, Jan 24, 2016 at 10:50 AM Curt Clifton &lt;curt at omnigroup.com &lt;mailto:curt at omnigroup.com&gt;&gt; wrote:<br>&gt; <br>&gt; On Jan 24, 2016, at 12:34 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I agree that &quot;sinInPlace()&quot;, &quot;meanInPlace()&quot;, &quot;remainderInPlace()&quot; seem to work pretty well, but I&#39;m aware that I&#39;m drawing on experience with the old names of sortInPlace(), subtractInPlace(), etc., and in fact this case is worse because the first words aren&#39;t really verbs (you can&#39;t sine something in place any more than you can sine it). &quot;takeSine()&quot; doesn&#39;t sound great either.<br>&gt; <br>&gt; How about &quot;applyingSine()&quot; , &quot;applyingMean()&quot;, and &quot;applyingRemainder()&quot;? <br>&gt; <br>&gt; Cheers, <br>&gt; <br>&gt; Curt<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/90ce3aec/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, Curt Clifton &lt;curt-AT-omnigroup.com&gt; wrote:<br></p><p>&gt;&gt; On Jan 24, 2016, at 12:34 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that &quot;sinInPlace()&quot;, &quot;meanInPlace()&quot;, &quot;remainderInPlace()&quot;<br>&gt;&gt; seem to work pretty well, but I&#39;m aware that I&#39;m drawing on<br>&gt;&gt; experience with the old names of sortInPlace(), subtractInPlace(),<br>&gt;&gt; etc., and in fact this case is worse because the first words aren&#39;t<br>&gt;&gt; really verbs (you can&#39;t sine something in place any more than you<br>&gt;&gt; can sine it). &quot;takeSine()&quot; doesn&#39;t sound great either.<br>&gt;<br>&gt; How about &quot;applyingSine()&quot; , &quot;applyingMean()&quot;, and &quot;applyingRemainder()&quot;? <br></p><p>&quot;x, applying sine()&quot; means &quot;x with sine applied,&quot; which is just &quot;sin(x)&quot;.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
