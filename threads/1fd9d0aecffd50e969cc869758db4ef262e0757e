<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>access control</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I hope that access control can be revisited. It is the number one<br>&gt; complaint about Swift that I hear from experienced developers. The<br>&gt; current solution came as a complete surprise to every ObjC developer<br>&gt; I&#39;ve talked to. The natural expectation was that a strong access<br>&gt; control system would be part of a strong type system. I already<br>&gt; submitted a pull request with a proposal for this after a lengthy<br>&gt; discussion here, but so far it was ignored. I hope that this can be<br>&gt; revisited. Even if most people who responded earlier in this list<br>&gt; decided that they were happy with the current state, it represents a<br>&gt; tiny fraction of people using the language, and at least all the<br>&gt; people I talked to strongly disagree but just aren’t on the list.<br>&gt;<br>&gt; Right now access control is file based and not API based. This is much<br>&gt; easier to implement but useless to express that certain elements of a<br>&gt; class are implementation details that are not meant to be used<br>&gt; anywhere else (someone can add more code to the same file and get<br>&gt; access to the implementation details without modifying the<br>&gt; class). <br></p><p>I agree that our current access control has real weaknesses, but I don&#39;t<br>agree you&#39;ve identified one above.  Anyone who can &quot;add more code to the<br>same file&quot; can just as easily modify/extend the class.  There&#39;s nothing<br>about extending a class that ought to raise a red flag in Swift, because<br>it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br></p><p>I&#39;m going to let others respond to the rest of this in more detail, but<br>I should also add that we didn&#39;t do file-level access control because it<br>was easier; we did it because we thought it was a better model for<br>Swift, where types are liberally open for extension.<br></p><p>&gt; It’s also impossible to hide APIs that are meant only for<br>&gt; customization points of subclasses.<br></p><p>&gt; Some of these problems could be solved with a convention like putting<br>&gt; _ in front of protected and __ in front of private methods, and Cocoa<br>&gt; uses a similar approach today. But this “solution” is in the same<br>&gt; category as using prefixes to determine types. If Swift aims to have a<br>&gt; strong type system, and it’s described as one of advantages of Swift<br>&gt; over ObjC, it should help enforce this at the language level.<br>&gt;<br>&gt; .NET has a good solution that respects the OOP terminology and deals<br>&gt; with accessibility in modules and at the API level:<br>&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br>&gt;<br>&gt; I think that a similar approach would work much better in Swift.<br>&gt;<br>&gt; —<br>&gt; Ilya Belenkiy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Cheers,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br></p><p>Yes, but with an API based access control, anyone modifying / extending the class can instantly see the author’s intent from the API declaration, and the compiler can prevent *accidental* misuse. Deliberate misuse cannot be stopped no matter what access control is in place (as long as the coder can modify the code in the module). But at least with an API based access control, a deliberate misuse is very easy to spot when debugging / reviewing the code. With a file based access control, the only way to tell if an API is really private or can be safely used anywhere in the same file is to read the comments / source code. And it’s much easier to miss in maintenance, debugging, or code reviews. The only way to make it obvious in the current model is to adopt a convention like _ in front of methods.<br></p><p>&gt; There&#39;s nothing about extending a class that ought to raise a red flag in Swift, because it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br></p><p><br>Unless the programmer extends a class in the same file. Then he can call anything marked private, and it’s impossible to tell without reading the code whether it violates the class invariants. There is no way to express this in Swift today. My proposal for local / scoped access control would solve this.<br></p><p>&gt;  we didn&#39;t do file-level access control because it was easier; we did it because we thought it was a better model for Swift, where types are liberally open for extension.<br></p><p>That’s what I assumed until I saw someone say it in this list when someone else raised a similar concern. Types in C++ and C# are also liberally open for extension, but they provide much better support for expressing the intent of an API and protect against accidental misuse.<br></p><p>&gt; On Jan 23, 2016, at 3:45 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I hope that access control can be revisited. It is the number one<br>&gt;&gt; complaint about Swift that I hear from experienced developers. The<br>&gt;&gt; current solution came as a complete surprise to every ObjC developer<br>&gt;&gt; I&#39;ve talked to. The natural expectation was that a strong access<br>&gt;&gt; control system would be part of a strong type system. I already<br>&gt;&gt; submitted a pull request with a proposal for this after a lengthy<br>&gt;&gt; discussion here, but so far it was ignored. I hope that this can be<br>&gt;&gt; revisited. Even if most people who responded earlier in this list<br>&gt;&gt; decided that they were happy with the current state, it represents a<br>&gt;&gt; tiny fraction of people using the language, and at least all the<br>&gt;&gt; people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt; <br>&gt;&gt; Right now access control is file based and not API based. This is much<br>&gt;&gt; easier to implement but useless to express that certain elements of a<br>&gt;&gt; class are implementation details that are not meant to be used<br>&gt;&gt; anywhere else (someone can add more code to the same file and get<br>&gt;&gt; access to the implementation details without modifying the<br>&gt;&gt; class). <br>&gt; <br>&gt; I agree that our current access control has real weaknesses, but I don&#39;t<br>&gt; agree you&#39;ve identified one above.  Anyone who can &quot;add more code to the<br>&gt; same file&quot; can just as easily modify/extend the class.  There&#39;s nothing<br>&gt; about extending a class that ought to raise a red flag in Swift, because<br>&gt; it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br>&gt; <br>&gt; I&#39;m going to let others respond to the rest of this in more detail, but<br>&gt; I should also add that we didn&#39;t do file-level access control because it<br>&gt; was easier; we did it because we thought it was a better model for<br>&gt; Swift, where types are liberally open for extension.<br>&gt; <br>&gt;&gt; It’s also impossible to hide APIs that are meant only for<br>&gt;&gt; customization points of subclasses.<br>&gt; <br>&gt;&gt; Some of these problems could be solved with a convention like putting<br>&gt;&gt; _ in front of protected and __ in front of private methods, and Cocoa<br>&gt;&gt; uses a similar approach today. But this “solution” is in the same<br>&gt;&gt; category as using prefixes to determine types. If Swift aims to have a<br>&gt;&gt; strong type system, and it’s described as one of advantages of Swift<br>&gt;&gt; over ObjC, it should help enforce this at the language level.<br>&gt;&gt; <br>&gt;&gt; .NET has a good solution that respects the OOP terminology and deals<br>&gt;&gt; with accessibility in modules and at the API level:<br>&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br>&gt;&gt; <br>&gt;&gt; I think that a similar approach would work much better in Swift.<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/9374d706/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>access control</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 2:14 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt; <br>&gt; Yes, but with an API based access control, anyone modifying / extending the class can instantly see the author’s intent from the API declaration, and the compiler can prevent *accidental* misuse. Deliberate misuse cannot be stopped no matter what access control is in place (as long as the coder can modify the code in the module). But at least with an API based access control, a deliberate misuse is very easy to spot when debugging / reviewing the code. With a file based access control, the only way to tell if an API is really private or can be safely used anywhere in the same file is to read the comments / source code. And it’s much easier to miss in maintenance, debugging, or code reviews. The only way to make it obvious in the current model is to adopt a convention like _ in front of methods.<br>&gt; <br>&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red flag in Swift, because it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br>&gt; <br>&gt; <br>&gt; Unless the programmer extends a class in the same file. Then he can call anything marked private, and it’s impossible to tell without reading the code whether it violates the class invariants. There is no way to express this in Swift today. My proposal for local / scoped access control would solve this.<br></p><p>This doesn&#39;t change if you constrain access to a class&#39;s members to the primary class declaration. Anyone extending the class within the &#39;class Foo { }&#39; braces also has to understand the class invariants.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt;  we didn&#39;t do file-level access control because it was easier; we did it because we thought it was a better model for Swift, where types are liberally open for extension.<br>&gt; <br>&gt; That’s what I assumed until I saw someone say it in this list when someone else raised a similar concern. Types in C++ and C# are also liberally open for extension, but they provide much better support for expressing the intent of an API and protect against accidental misuse.<br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 3:45 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I hope that access control can be revisited. It is the number one<br>&gt;&gt;&gt; complaint about Swift that I hear from experienced developers. The<br>&gt;&gt;&gt; current solution came as a complete surprise to every ObjC developer<br>&gt;&gt;&gt; I&#39;ve talked to. The natural expectation was that a strong access<br>&gt;&gt;&gt; control system would be part of a strong type system. I already<br>&gt;&gt;&gt; submitted a pull request with a proposal for this after a lengthy<br>&gt;&gt;&gt; discussion here, but so far it was ignored. I hope that this can be<br>&gt;&gt;&gt; revisited. Even if most people who responded earlier in this list<br>&gt;&gt;&gt; decided that they were happy with the current state, it represents a<br>&gt;&gt;&gt; tiny fraction of people using the language, and at least all the<br>&gt;&gt;&gt; people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now access control is file based and not API based. This is much<br>&gt;&gt;&gt; easier to implement but useless to express that certain elements of a<br>&gt;&gt;&gt; class are implementation details that are not meant to be used<br>&gt;&gt;&gt; anywhere else (someone can add more code to the same file and get<br>&gt;&gt;&gt; access to the implementation details without modifying the<br>&gt;&gt;&gt; class). <br>&gt;&gt; <br>&gt;&gt; I agree that our current access control has real weaknesses, but I don&#39;t<br>&gt;&gt; agree you&#39;ve identified one above.  Anyone who can &quot;add more code to the<br>&gt;&gt; same file&quot; can just as easily modify/extend the class.  There&#39;s nothing<br>&gt;&gt; about extending a class that ought to raise a red flag in Swift, because<br>&gt;&gt; it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to let others respond to the rest of this in more detail, but<br>&gt;&gt; I should also add that we didn&#39;t do file-level access control because it<br>&gt;&gt; was easier; we did it because we thought it was a better model for<br>&gt;&gt; Swift, where types are liberally open for extension.<br>&gt;&gt; <br>&gt;&gt;&gt; It’s also impossible to hide APIs that are meant only for<br>&gt;&gt;&gt; customization points of subclasses.<br>&gt;&gt; <br>&gt;&gt;&gt; Some of these problems could be solved with a convention like putting<br>&gt;&gt;&gt; _ in front of protected and __ in front of private methods, and Cocoa<br>&gt;&gt;&gt; uses a similar approach today. But this “solution” is in the same<br>&gt;&gt;&gt; category as using prefixes to determine types. If Swift aims to have a<br>&gt;&gt;&gt; strong type system, and it’s described as one of advantages of Swift<br>&gt;&gt;&gt; over ObjC, it should help enforce this at the language level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .NET has a good solution that respects the OOP terminology and deals<br>&gt;&gt;&gt; with accessibility in modules and at the API level:<br>&gt;&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx &lt;https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that a similar approach would work much better in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/c74d6f92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 23, 2016 at 10:00:00pm</p></header><div class="content"><p>Yes, but that understanding doesn&#39;t need to be as deep. Also, with The API<br>based approach, the compiler can enforce the class author&#39;s intent, and the<br>intent is very clearly spelled out.<br>On Sat, Jan 23, 2016 at 5:20 PM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; On Jan 23, 2016, at 2:14 PM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily<br>&gt; modify/extend the class.<br>&gt;<br>&gt;<br>&gt; Yes, but with an API based access control, anyone modifying / extending<br>&gt; the class can instantly see the author’s intent from the API declaration,<br>&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse cannot<br>&gt; be stopped no matter what access control is in place (as long as the coder<br>&gt; can modify the code in the module). But at least with an API based access<br>&gt; control, a deliberate misuse is very easy to spot when debugging /<br>&gt; reviewing the code. With a file based access control, the only way to tell<br>&gt; if an API is really private or can be safely used anywhere in the same file<br>&gt; is to read the comments / source code. And it’s much easier to miss in<br>&gt; maintenance, debugging, or code reviews. The only way to make it obvious in<br>&gt; the current model is to adopt a convention like _ in front of methods.<br>&gt;<br>&gt; There&#39;s nothing about extending a class that ought to raise a red flag in<br>&gt; Swift, because it&#39;s perfectly legit to do so and use only the class&#39;<br>&gt; public APIs.<br>&gt;<br>&gt;<br>&gt; Unless the programmer extends a class in the same file. Then he can call<br>&gt; anything marked private, and it’s impossible to tell without reading the<br>&gt; code whether it violates the class invariants. There is no way to express<br>&gt; this in Swift today. My proposal for local / scoped access control would<br>&gt; solve this.<br>&gt;<br>&gt;<br>&gt; This doesn&#39;t change if you constrain access to a class&#39;s members to the<br>&gt; primary class declaration. Anyone extending the class within the &#39;class Foo<br>&gt; { }&#39; braces also has to understand the class invariants.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt;  we didn&#39;t do file-level access control because it was easier; we did it<br>&gt; because we thought it was a better model for Swift, where types are<br>&gt; liberally open for extension.<br>&gt;<br>&gt;<br>&gt; That’s what I assumed until I saw someone say it in this list when someone<br>&gt; else raised a similar concern. Types in C++ and C# are also liberally open<br>&gt; for extension, but they provide much better support for expressing the<br>&gt; intent of an API and protect against accidental misuse.<br>&gt;<br>&gt; On Jan 23, 2016, at 3:45 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I hope that access control can be revisited. It is the number one<br>&gt; complaint about Swift that I hear from experienced developers. The<br>&gt; current solution came as a complete surprise to every ObjC developer<br>&gt; I&#39;ve talked to. The natural expectation was that a strong access<br>&gt; control system would be part of a strong type system. I already<br>&gt; submitted a pull request with a proposal for this after a lengthy<br>&gt; discussion here, but so far it was ignored. I hope that this can be<br>&gt; revisited. Even if most people who responded earlier in this list<br>&gt; decided that they were happy with the current state, it represents a<br>&gt; tiny fraction of people using the language, and at least all the<br>&gt; people I talked to strongly disagree but just aren’t on the list.<br>&gt;<br>&gt; Right now access control is file based and not API based. This is much<br>&gt; easier to implement but useless to express that certain elements of a<br>&gt; class are implementation details that are not meant to be used<br>&gt; anywhere else (someone can add more code to the same file and get<br>&gt; access to the implementation details without modifying the<br>&gt; class).<br>&gt;<br>&gt;<br>&gt; I agree that our current access control has real weaknesses, but I don&#39;t<br>&gt; agree you&#39;ve identified one above.  Anyone who can &quot;add more code to the<br>&gt; same file&quot; can just as easily modify/extend the class.  There&#39;s nothing<br>&gt; about extending a class that ought to raise a red flag in Swift, because<br>&gt; it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br>&gt;<br>&gt; I&#39;m going to let others respond to the rest of this in more detail, but<br>&gt; I should also add that we didn&#39;t do file-level access control because it<br>&gt; was easier; we did it because we thought it was a better model for<br>&gt; Swift, where types are liberally open for extension.<br>&gt;<br>&gt; It’s also impossible to hide APIs that are meant only for<br>&gt; customization points of subclasses.<br>&gt;<br>&gt;<br>&gt; Some of these problems could be solved with a convention like putting<br>&gt; _ in front of protected and __ in front of private methods, and Cocoa<br>&gt; uses a similar approach today. But this “solution” is in the same<br>&gt; category as using prefixes to determine types. If Swift aims to have a<br>&gt; strong type system, and it’s described as one of advantages of Swift<br>&gt; over ObjC, it should help enforce this at the language level.<br>&gt;<br>&gt; .NET has a good solution that respects the OOP terminology and deals<br>&gt; with accessibility in modules and at the API level:<br>&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br>&gt;<br>&gt; I think that a similar approach would work much better in Swift.<br>&gt;<br>&gt; —<br>&gt; Ilya Belenkiy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d68a2d4b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>access control</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br></p><p>&gt; Yes, but that understanding doesn&#39;t need to be as deep. <br></p><p>Can you explain that statement?  I don&#39;t see how it can possibly be<br>true.<br></p><p>&gt; Also, with The API based approach, the compiler can enforce the class<br>&gt; author&#39;s intent, and the intent is very clearly spelled out.<br></p><p>I don&#39;t see how that&#39;s a difference in Swift.  If you, as a class<br>author, don&#39;t have control over the contents of the file your class is<br>defined it, other people can break your class.  If you do, you can<br>prevent them from breaking it.<br></p><p>&gt; On Sat, Jan 23, 2016 at 5:20 PM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jan 23, 2016, at 2:14 PM, Ilya Belenkiy via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily<br>&gt;&gt; modify/extend the class.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, but with an API based access control, anyone modifying / extending<br>&gt;&gt; the class can instantly see the author’s intent from the API declaration,<br>&gt;&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse cannot<br>&gt;&gt; be stopped no matter what access control is in place (as long as the coder<br>&gt;&gt; can modify the code in the module). But at least with an API based access<br>&gt;&gt; control, a deliberate misuse is very easy to spot when debugging /<br>&gt;&gt; reviewing the code. With a file based access control, the only way to tell<br>&gt;&gt; if an API is really private or can be safely used anywhere in the same file<br>&gt;&gt; is to read the comments / source code. And it’s much easier to miss in<br>&gt;&gt; maintenance, debugging, or code reviews. The only way to make it obvious in<br>&gt;&gt; the current model is to adopt a convention like _ in front of methods.<br>&gt;&gt;<br>&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red flag in<br>&gt;&gt; Swift, because it&#39;s perfectly legit to do so and use only the class&#39;<br>&gt;&gt; public APIs.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Unless the programmer extends a class in the same file. Then he can call<br>&gt;&gt; anything marked private, and it’s impossible to tell without reading the<br>&gt;&gt; code whether it violates the class invariants. There is no way to express<br>&gt;&gt; this in Swift today. My proposal for local / scoped access control would<br>&gt;&gt; solve this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This doesn&#39;t change if you constrain access to a class&#39;s members to the<br>&gt;&gt; primary class declaration. Anyone extending the class within the &#39;class Foo<br>&gt;&gt; { }&#39; braces also has to understand the class invariants.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  we didn&#39;t do file-level access control because it was easier; we did it<br>&gt;&gt; because we thought it was a better model for Swift, where types are<br>&gt;&gt; liberally open for extension.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s what I assumed until I saw someone say it in this list when someone<br>&gt;&gt; else raised a similar concern. Types in C++ and C# are also liberally open<br>&gt;&gt; for extension, but they provide much better support for expressing the<br>&gt;&gt; intent of an API and protect against accidental misuse.<br>&gt;&gt;<br>&gt;&gt; On Jan 23, 2016, at 3:45 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I hope that access control can be revisited. It is the number one<br>&gt;&gt; complaint about Swift that I hear from experienced developers. The<br>&gt;&gt; current solution came as a complete surprise to every ObjC developer<br>&gt;&gt; I&#39;ve talked to. The natural expectation was that a strong access<br>&gt;&gt; control system would be part of a strong type system. I already<br>&gt;&gt; submitted a pull request with a proposal for this after a lengthy<br>&gt;&gt; discussion here, but so far it was ignored. I hope that this can be<br>&gt;&gt; revisited. Even if most people who responded earlier in this list<br>&gt;&gt; decided that they were happy with the current state, it represents a<br>&gt;&gt; tiny fraction of people using the language, and at least all the<br>&gt;&gt; people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt;<br>&gt;&gt; Right now access control is file based and not API based. This is much<br>&gt;&gt; easier to implement but useless to express that certain elements of a<br>&gt;&gt; class are implementation details that are not meant to be used<br>&gt;&gt; anywhere else (someone can add more code to the same file and get<br>&gt;&gt; access to the implementation details without modifying the<br>&gt;&gt; class).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree that our current access control has real weaknesses, but I don&#39;t<br>&gt;&gt; agree you&#39;ve identified one above.  Anyone who can &quot;add more code to the<br>&gt;&gt; same file&quot; can just as easily modify/extend the class.  There&#39;s nothing<br>&gt;&gt; about extending a class that ought to raise a red flag in Swift, because<br>&gt;&gt; it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to let others respond to the rest of this in more detail, but<br>&gt;&gt; I should also add that we didn&#39;t do file-level access control because it<br>&gt;&gt; was easier; we did it because we thought it was a better model for<br>&gt;&gt; Swift, where types are liberally open for extension.<br>&gt;&gt;<br>&gt;&gt; It’s also impossible to hide APIs that are meant only for<br>&gt;&gt; customization points of subclasses.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Some of these problems could be solved with a convention like putting<br>&gt;&gt; _ in front of protected and __ in front of private methods, and Cocoa<br>&gt;&gt; uses a similar approach today. But this “solution” is in the same<br>&gt;&gt; category as using prefixes to determine types. If Swift aims to have a<br>&gt;&gt; strong type system, and it’s described as one of advantages of Swift<br>&gt;&gt; over ObjC, it should help enforce this at the language level.<br>&gt;&gt;<br>&gt;&gt; .NET has a good solution that respects the OOP terminology and deals<br>&gt;&gt; with accessibility in modules and at the API level:<br>&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br>&gt;&gt;<br>&gt;&gt; I think that a similar approach would work much better in Swift.<br>&gt;&gt;<br>&gt;&gt; —<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>access control</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt;<br>&gt; Yes, but with an API based access control, <br></p><p>I don&#39;t know what that term means, sorry.<br></p><p>&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt; intent from the API declaration, <br></p><p>I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>APIs are the ones you don&#39;t want anyone to touch because they can break<br>your invariants.<br></p><p>&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse<br>&gt; cannot be stopped no matter what access control is in place (as long<br>&gt; as the coder can modify the code in the module). But at least with an<br>&gt; API based access control, a deliberate misuse is very easy to spot<br>&gt; when debugging / reviewing the code. With a file based access control,<br>&gt; the only way to tell if an API is really private or can be safely used<br>&gt; anywhere in the same file is to read the comments / source code. <br></p><p>Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>C++?  Why?<br></p><p>&gt; And it’s much easier to miss in maintenance, debugging, or code<br>&gt; reviews. The only way to make it obvious in the current model is to<br>&gt; adopt a convention like _ in front of methods.<br></p><p>The only reason we&#39;re doing that in the standard library is that we&#39;re<br>currently forced to make some implementation details formally public,<br>and we can&#39;t use “private” because &lt;reasons&gt;.  If it weren&#39;t for these<br>limitations, we&#39;d be very happy with “private.”  Defining one type per<br>file is usually a good practice anyway.<br></p><p>&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red<br>&gt;&gt; flag in Swift, because it&#39;s perfectly legit to do so and use only<br>&gt;&gt; the class&#39; public APIs.<br>&gt;<br>&gt; Unless the programmer extends a class in the same file. Then he can<br>&gt; call anything marked private, and it’s impossible to tell without<br>&gt; reading the code whether it violates the class invariants. <br></p><p>Without prohibiting class extensions from being made in the same file<br>where the class is defined—a capability we want to keep available to<br>class authors—that will always be the case.  Therefore, you have the<br>same scenario as in C++: anyone who modifies the file where a class is<br>defined might be violating its invariants.  It&#39;s just that in C++ the<br>violator has to write code between a particular set of braces.  When<br>reviewing diffs it&#39;s very common not to have enough context to see those<br>braces anyway.<br></p><p>&gt; There is no way to express this in Swift today. My proposal for local<br>&gt; / scoped access control would solve this.<br>&gt;<br>&gt;&gt;  we didn&#39;t do file-level access control because it was easier; we<br>&gt;&gt; did it because we thought it was a better model for Swift, where<br>&gt;&gt; types are liberally open for extension.<br>&gt;<br>&gt; That’s what I assumed until I saw someone say it in this list when<br>&gt; someone else raised a similar concern. Types in C++ and C# are also<br>&gt; liberally open for extension, <br></p><p>Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>outside the file where it&#39;s declared unless there&#39;s some really horrible<br>preprocessor stuff going on, and even then the class author would have<br>had to explicitly left that door open for you.<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; Yes, but with an API based access control, <br>&gt; <br>&gt; I don&#39;t know what that term means, sorry.<br></p><p>I had to come up with this term to distinguish it from a file based access control. In API based access control, visibility of anything is tied to the declaration instead of the file it is in. It’s the model that C++ and C# ( and I am sure many others) use. In file based access control, visibility of anything is tied to the file it is in and has little to do with the class API itself. It’s the model that Swift currently follows.<br></p><p>&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt; intent from the API declaration, <br>&gt; <br>&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt; your invariants.<br></p><p>In Swift, any additional code in the same source file can use the APIs declared private and break your invariants. The semantic meaning of private is not “use only inside the class” but “use only inside this file”. It is currently impossible to express “use only inside the class” semantics.<br></p><p>&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt; C++?  Why?<br></p><p>Because in Swift, private means “use only inside this file” and not “use only inside this class / scope”. In C++ private means “use only inside this class”. Moreover, C++ puts a special emphasis on this — variables are private inside the class unless the code specifically says otherwise.<br></p><p>&gt;  Defining one type per file is usually a good practice anyway.<br></p><p>This really depends on the context. There is value in keeping similar concepts / implementations in the same file. If one class and one extension per file become a requirement, then private will have the same semantics as in C++. It will also become very inconvenient to write code because even a small extension with 1 method that can fit on one line will require a separate file.<br></p><p>&gt; Without prohibiting class extensions from being made in the same file<br>&gt; where the class is defined—a capability we want to keep available to<br>&gt; class authors—that will always be the case.<br></p><p><br>It doesn’t have to be. My proposal (still a pull request) provides a way to explicitly declare a function or a property to be private to the scope where it is defined. So extensions and subclasses declared in the same file cannot access it and break the invariant. If it’s applied to both class definitions and extensions, it’s very consistent and provides an explicit declaration of intent that can (and should) be enforced by the compiler.<br></p><p>&gt; Therefore, you have the<br>&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt; violator has to write code between a particular set of braces.  When<br>&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt; braces anyway.<br></p><p>This is a crucial distinction. That particular set of braces defines a scope which acts as a black box and hides the implementation details. Anything outside the scope cannot damage the internal state, and the compiler *enforces* it. In Swift, the compiler only enforces that the API is not visible from another file because the language has no way to express “this should be visible only in the scope to hide implementation details”. The only exception to that are functions inside other functions and local variables — right now this is the only way to completely hide implementation details, but it’s very limited.<br></p><p>My main 2 points are that it’s impossible to express the intent of a truly local access level to hide implementation details, and because of that, the compiler cannot enforce this intent.<br></p><p>&gt; When<br>&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt; braces anyway.<br></p><p>This depends on how thoroughly the code is reviewed. But the main point there is that when you find out, you know that whoever worked around a private API did so knowing that he was introducing a hack. Because Swift has no way of expressing “this is private to the class, not just file it’s in”, someone may not know and make a mistake, and the compiler cannot catch it. My proposal makes the intent expressible in the language and enforceable by the compiler.<br></p><p>&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt; preprocessor stuff going on, and even then the class author would have<br>&gt; had to explicitly left that door open for you.<br></p><p>True, but my proposal deals with extensions the same way it does with class definitions — it provides a way to hide implementation details in a scope (whether it be a class definition or an extension scope) and make them invisible to everything else including extensions or other extensions or anything else in the same file. It provides a way to express the intent in the language and enforce it by the compiler.<br></p><p>&gt; On Jan 23, 2016, at 5:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt;&gt; <br>&gt;&gt; Yes, but with an API based access control, <br>&gt; <br>&gt; I don&#39;t know what that term means, sorry.<br>&gt; <br>&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt; intent from the API declaration, <br>&gt; <br>&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt; your invariants.<br>&gt; <br>&gt;&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse<br>&gt;&gt; cannot be stopped no matter what access control is in place (as long<br>&gt;&gt; as the coder can modify the code in the module). But at least with an<br>&gt;&gt; API based access control, a deliberate misuse is very easy to spot<br>&gt;&gt; when debugging / reviewing the code. With a file based access control,<br>&gt;&gt; the only way to tell if an API is really private or can be safely used<br>&gt;&gt; anywhere in the same file is to read the comments / source code. <br>&gt; <br>&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt; C++?  Why?<br>&gt; <br>&gt;&gt; And it’s much easier to miss in maintenance, debugging, or code<br>&gt;&gt; reviews. The only way to make it obvious in the current model is to<br>&gt;&gt; adopt a convention like _ in front of methods.<br>&gt; <br>&gt; The only reason we&#39;re doing that in the standard library is that we&#39;re<br>&gt; currently forced to make some implementation details formally public,<br>&gt; and we can&#39;t use “private” because &lt;reasons&gt;.  If it weren&#39;t for these<br>&gt; limitations, we&#39;d be very happy with “private.”  Defining one type per<br>&gt; file is usually a good practice anyway.<br>&gt; <br>&gt;&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red<br>&gt;&gt;&gt; flag in Swift, because it&#39;s perfectly legit to do so and use only<br>&gt;&gt;&gt; the class&#39; public APIs.<br>&gt;&gt; <br>&gt;&gt; Unless the programmer extends a class in the same file. Then he can<br>&gt;&gt; call anything marked private, and it’s impossible to tell without<br>&gt;&gt; reading the code whether it violates the class invariants. <br>&gt; <br>&gt; Without prohibiting class extensions from being made in the same file<br>&gt; where the class is defined—a capability we want to keep available to<br>&gt; class authors—that will always be the case.  Therefore, you have the<br>&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt; violator has to write code between a particular set of braces.  When<br>&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt; braces anyway.<br>&gt; <br>&gt;&gt; There is no way to express this in Swift today. My proposal for local<br>&gt;&gt; / scoped access control would solve this.<br>&gt;&gt; <br>&gt;&gt;&gt; we didn&#39;t do file-level access control because it was easier; we<br>&gt;&gt;&gt; did it because we thought it was a better model for Swift, where<br>&gt;&gt;&gt; types are liberally open for extension.<br>&gt;&gt; <br>&gt;&gt; That’s what I assumed until I saw someone say it in this list when<br>&gt;&gt; someone else raised a similar concern. Types in C++ and C# are also<br>&gt;&gt; liberally open for extension, <br>&gt; <br>&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt; preprocessor stuff going on, and even then the class author would have<br>&gt; had to explicitly left that door open for you.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>access control</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 23, 2016 at 06:00:00pm</p></header><div class="content"><p>It might aid the discussion if you provided a link to your proposal. I&#39;m assuming it includes examples of problems that your proposed changes solve. I&#39;d be interested in seeing those.<br></p><p>Cheers, <br></p><p>Curt<br>------------------------- <br>Curt Clifton, PhD <br>Software Developer <br>The Omni Group <br>www.curtclifton.net <br></p><p><br>On Jan 23, 2016, at 6:17 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt; <br>&gt; I had to come up with this term to distinguish it from a file based access control. In API based access control, visibility of anything is tied to the declaration instead of the file it is in. It’s the model that C++ and C# ( and I am sure many others) use. In file based access control, visibility of anything is tied to the file it is in and has little to do with the class API itself. It’s the model that Swift currently follows.<br>&gt; <br>&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt; your invariants.<br>&gt; <br>&gt; In Swift, any additional code in the same source file can use the APIs declared private and break your invariants. The semantic meaning of private is not “use only inside the class” but “use only inside this file”. It is currently impossible to express “use only inside the class” semantics.<br>&gt; <br>&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt; C++?  Why?<br>&gt; <br>&gt; Because in Swift, private means “use only inside this file” and not “use only inside this class / scope”. In C++ private means “use only inside this class”. Moreover, C++ puts a special emphasis on this — variables are private inside the class unless the code specifically says otherwise.<br>&gt; <br>&gt;&gt; Defining one type per file is usually a good practice anyway.<br>&gt; <br>&gt; This really depends on the context. There is value in keeping similar concepts / implementations in the same file. If one class and one extension per file become a requirement, then private will have the same semantics as in C++. It will also become very inconvenient to write code because even a small extension with 1 method that can fit on one line will require a separate file.<br>&gt; <br>&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt; class authors—that will always be the case.<br>&gt; <br>&gt; <br>&gt; It doesn’t have to be. My proposal (still a pull request) provides a way to explicitly declare a function or a property to be private to the scope where it is defined. So extensions and subclasses declared in the same file cannot access it and break the invariant. If it’s applied to both class definitions and extensions, it’s very consistent and provides an explicit declaration of intent that can (and should) be enforced by the compiler.<br>&gt; <br>&gt;&gt; Therefore, you have the<br>&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt; braces anyway.<br>&gt; <br>&gt; This is a crucial distinction. That particular set of braces defines a scope which acts as a black box and hides the implementation details. Anything outside the scope cannot damage the internal state, and the compiler *enforces* it. In Swift, the compiler only enforces that the API is not visible from another file because the language has no way to express “this should be visible only in the scope to hide implementation details”. The only exception to that are functions inside other functions and local variables — right now this is the only way to completely hide implementation details, but it’s very limited.<br>&gt; <br>&gt; My main 2 points are that it’s impossible to express the intent of a truly local access level to hide implementation details, and because of that, the compiler cannot enforce this intent.<br>&gt; <br>&gt;&gt; When<br>&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt; braces anyway.<br>&gt; <br>&gt; This depends on how thoroughly the code is reviewed. But the main point there is that when you find out, you know that whoever worked around a private API did so knowing that he was introducing a hack. Because Swift has no way of expressing “this is private to the class, not just file it’s in”, someone may not know and make a mistake, and the compiler cannot catch it. My proposal makes the intent expressible in the language and enforceable by the compiler.<br>&gt; <br>&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt; had to explicitly left that door open for you.<br>&gt; <br>&gt; True, but my proposal deals with extensions the same way it does with class definitions — it provides a way to hide implementation details in a scope (whether it be a class definition or an extension scope) and make them invisible to everything else including extensions or other extensions or anything else in the same file. It provides a way to express the intent in the language and enforce it by the compiler.<br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 5:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt; <br>&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt; your invariants.<br>&gt;&gt; <br>&gt;&gt;&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse<br>&gt;&gt;&gt; cannot be stopped no matter what access control is in place (as long<br>&gt;&gt;&gt; as the coder can modify the code in the module). But at least with an<br>&gt;&gt;&gt; API based access control, a deliberate misuse is very easy to spot<br>&gt;&gt;&gt; when debugging / reviewing the code. With a file based access control,<br>&gt;&gt;&gt; the only way to tell if an API is really private or can be safely used<br>&gt;&gt;&gt; anywhere in the same file is to read the comments / source code.<br>&gt;&gt; <br>&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt; C++?  Why?<br>&gt;&gt; <br>&gt;&gt;&gt; And it’s much easier to miss in maintenance, debugging, or code<br>&gt;&gt;&gt; reviews. The only way to make it obvious in the current model is to<br>&gt;&gt;&gt; adopt a convention like _ in front of methods.<br>&gt;&gt; <br>&gt;&gt; The only reason we&#39;re doing that in the standard library is that we&#39;re<br>&gt;&gt; currently forced to make some implementation details formally public,<br>&gt;&gt; and we can&#39;t use “private” because &lt;reasons&gt;.  If it weren&#39;t for these<br>&gt;&gt; limitations, we&#39;d be very happy with “private.”  Defining one type per<br>&gt;&gt; file is usually a good practice anyway.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red<br>&gt;&gt;&gt;&gt; flag in Swift, because it&#39;s perfectly legit to do so and use only<br>&gt;&gt;&gt;&gt; the class&#39; public APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless the programmer extends a class in the same file. Then he can<br>&gt;&gt;&gt; call anything marked private, and it’s impossible to tell without<br>&gt;&gt;&gt; reading the code whether it violates the class invariants.<br>&gt;&gt; <br>&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt; class authors—that will always be the case.  Therefore, you have the<br>&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt; braces anyway.<br>&gt;&gt; <br>&gt;&gt;&gt; There is no way to express this in Swift today. My proposal for local<br>&gt;&gt;&gt; / scoped access control would solve this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; we didn&#39;t do file-level access control because it was easier; we<br>&gt;&gt;&gt;&gt; did it because we thought it was a better model for Swift, where<br>&gt;&gt;&gt;&gt; types are liberally open for extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s what I assumed until I saw someone say it in this list when<br>&gt;&gt;&gt; someone else raised a similar concern. Types in C++ and C# are also<br>&gt;&gt;&gt; liberally open for extension,<br>&gt;&gt; <br>&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 23, 2016 at 09:00:00pm</p></header><div class="content"><p>Here is a link to the pull request:<br></p><p>https://github.com/apple/swift-evolution/pull/64<br></p><p><br>&gt; On Jan 23, 2016, at 9:23 PM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; It might aid the discussion if you provided a link to your proposal. I&#39;m assuming it includes examples of problems that your proposed changes solve. I&#39;d be interested in seeing those.<br>&gt; <br>&gt; Cheers, <br>&gt; <br>&gt; Curt<br>&gt; ------------------------- <br>&gt; Curt Clifton, PhD <br>&gt; Software Developer <br>&gt; The Omni Group <br>&gt; www.curtclifton.net <br>&gt; <br>&gt; <br>&gt; On Jan 23, 2016, at 6:17 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt; <br>&gt;&gt; I had to come up with this term to distinguish it from a file based access control. In API based access control, visibility of anything is tied to the declaration instead of the file it is in. It’s the model that C++ and C# ( and I am sure many others) use. In file based access control, visibility of anything is tied to the file it is in and has little to do with the class API itself. It’s the model that Swift currently follows.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt; your invariants.<br>&gt;&gt; <br>&gt;&gt; In Swift, any additional code in the same source file can use the APIs declared private and break your invariants. The semantic meaning of private is not “use only inside the class” but “use only inside this file”. It is currently impossible to express “use only inside the class” semantics.<br>&gt;&gt; <br>&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt; C++?  Why?<br>&gt;&gt; <br>&gt;&gt; Because in Swift, private means “use only inside this file” and not “use only inside this class / scope”. In C++ private means “use only inside this class”. Moreover, C++ puts a special emphasis on this — variables are private inside the class unless the code specifically says otherwise.<br>&gt;&gt; <br>&gt;&gt;&gt; Defining one type per file is usually a good practice anyway.<br>&gt;&gt; <br>&gt;&gt; This really depends on the context. There is value in keeping similar concepts / implementations in the same file. If one class and one extension per file become a requirement, then private will have the same semantics as in C++. It will also become very inconvenient to write code because even a small extension with 1 method that can fit on one line will require a separate file.<br>&gt;&gt; <br>&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt; class authors—that will always be the case.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It doesn’t have to be. My proposal (still a pull request) provides a way to explicitly declare a function or a property to be private to the scope where it is defined. So extensions and subclasses declared in the same file cannot access it and break the invariant. If it’s applied to both class definitions and extensions, it’s very consistent and provides an explicit declaration of intent that can (and should) be enforced by the compiler.<br>&gt;&gt; <br>&gt;&gt;&gt; Therefore, you have the<br>&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt; braces anyway.<br>&gt;&gt; <br>&gt;&gt; This is a crucial distinction. That particular set of braces defines a scope which acts as a black box and hides the implementation details. Anything outside the scope cannot damage the internal state, and the compiler *enforces* it. In Swift, the compiler only enforces that the API is not visible from another file because the language has no way to express “this should be visible only in the scope to hide implementation details”. The only exception to that are functions inside other functions and local variables — right now this is the only way to completely hide implementation details, but it’s very limited.<br>&gt;&gt; <br>&gt;&gt; My main 2 points are that it’s impossible to express the intent of a truly local access level to hide implementation details, and because of that, the compiler cannot enforce this intent.<br>&gt;&gt; <br>&gt;&gt;&gt; When<br>&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt; braces anyway.<br>&gt;&gt; <br>&gt;&gt; This depends on how thoroughly the code is reviewed. But the main point there is that when you find out, you know that whoever worked around a private API did so knowing that he was introducing a hack. Because Swift has no way of expressing “this is private to the class, not just file it’s in”, someone may not know and make a mistake, and the compiler cannot catch it. My proposal makes the intent expressible in the language and enforceable by the compiler.<br>&gt;&gt; <br>&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt; <br>&gt;&gt; True, but my proposal deals with extensions the same way it does with class definitions — it provides a way to hide implementation details in a scope (whether it be a class definition or an extension scope) and make them invisible to everything else including extensions or other extensions or anything else in the same file. It provides a way to express the intent in the language and enforce it by the compiler.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 5:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt; your invariants.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse<br>&gt;&gt;&gt;&gt; cannot be stopped no matter what access control is in place (as long<br>&gt;&gt;&gt;&gt; as the coder can modify the code in the module). But at least with an<br>&gt;&gt;&gt;&gt; API based access control, a deliberate misuse is very easy to spot<br>&gt;&gt;&gt;&gt; when debugging / reviewing the code. With a file based access control,<br>&gt;&gt;&gt;&gt; the only way to tell if an API is really private or can be safely used<br>&gt;&gt;&gt;&gt; anywhere in the same file is to read the comments / source code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt; C++?  Why?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And it’s much easier to miss in maintenance, debugging, or code<br>&gt;&gt;&gt;&gt; reviews. The only way to make it obvious in the current model is to<br>&gt;&gt;&gt;&gt; adopt a convention like _ in front of methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only reason we&#39;re doing that in the standard library is that we&#39;re<br>&gt;&gt;&gt; currently forced to make some implementation details formally public,<br>&gt;&gt;&gt; and we can&#39;t use “private” because &lt;reasons&gt;.  If it weren&#39;t for these<br>&gt;&gt;&gt; limitations, we&#39;d be very happy with “private.”  Defining one type per<br>&gt;&gt;&gt; file is usually a good practice anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red<br>&gt;&gt;&gt;&gt;&gt; flag in Swift, because it&#39;s perfectly legit to do so and use only<br>&gt;&gt;&gt;&gt;&gt; the class&#39; public APIs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless the programmer extends a class in the same file. Then he can<br>&gt;&gt;&gt;&gt; call anything marked private, and it’s impossible to tell without<br>&gt;&gt;&gt;&gt; reading the code whether it violates the class invariants.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt; class authors—that will always be the case.  Therefore, you have the<br>&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no way to express this in Swift today. My proposal for local<br>&gt;&gt;&gt;&gt; / scoped access control would solve this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; we didn&#39;t do file-level access control because it was easier; we<br>&gt;&gt;&gt;&gt;&gt; did it because we thought it was a better model for Swift, where<br>&gt;&gt;&gt;&gt;&gt; types are liberally open for extension.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s what I assumed until I saw someone say it in this list when<br>&gt;&gt;&gt;&gt; someone else raised a similar concern. Types in C++ and C# are also<br>&gt;&gt;&gt;&gt; liberally open for extension,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>access control</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 23, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks for sharing that.<br></p><p>It seems like the proposal would be stronger with some specific code examples of problems that can arise with `private` that are ameliorated with the introduction of `local`. I get the basic idea: with `private` I have to understand all the invariants in the file while with `local` I only need to understand the invariants within the lexical scope. However, I&#39;m having trouble understanding the situation where those are sufficiently different to justify increasing the complexity of the language. (If you were proposing replacing `private` with `local`, then the complexity would be the same. Of course, in that case, you&#39;d need to justify removing the level of access that allows extensions to access private members.) I may just be failing to understand. If so, a sufficiently detailed example would help, I think.<br></p><p>Secondly, in some languages, private members can only be accessed on self instances. Is your intention that local members can only be accessed thusly. That is, would the following be allowed:<br></p><p>struct Foo {<br>  local var bar: String<br>  // ...<br>  mutating func concatBar(otherFoo: Foo) {<br>    let othersBar = otherFoo.bar // legal?<br>    bar = bar + othersBar<br>  }<br>}<br></p><p>More generally, different languages have provided a wide variation in the specificity of their access control mechanisms. If `local` is only about static scope (i.e., the example above is legal), then do we need a mechanism for restricting to self-only access? Where is the appropriate floor on access restrictions? Why isn&#39;t a single file the appropriate floor?<br></p><p>Cheers,<br></p><p>Curt<br></p><p><br>&gt; On Jan 23, 2016, at 6:37 PM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here is a link to the pull request:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/64<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 9:23 PM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It might aid the discussion if you provided a link to your proposal. I&#39;m assuming it includes examples of problems that your proposed changes solve. I&#39;d be interested in seeing those.<br>&gt;&gt; <br>&gt;&gt; Cheers, <br>&gt;&gt; <br>&gt;&gt; Curt<br>&gt;&gt; ------------------------- <br>&gt;&gt; Curt Clifton, PhD <br>&gt;&gt; Software Developer <br>&gt;&gt; The Omni Group <br>&gt;&gt; www.curtclifton.net <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 23, 2016, at 6:17 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had to come up with this term to distinguish it from a file based access control. In API based access control, visibility of anything is tied to the declaration instead of the file it is in. It’s the model that C++ and C# ( and I am sure many others) use. In file based access control, visibility of anything is tied to the file it is in and has little to do with the class API itself. It’s the model that Swift currently follows.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt;&gt; your invariants.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift, any additional code in the same source file can use the APIs declared private and break your invariants. The semantic meaning of private is not “use only inside the class” but “use only inside this file”. It is currently impossible to express “use only inside the class” semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt;&gt; C++?  Why?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because in Swift, private means “use only inside this file” and not “use only inside this class / scope”. In C++ private means “use only inside this class”. Moreover, C++ puts a special emphasis on this — variables are private inside the class unless the code specifically says otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Defining one type per file is usually a good practice anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This really depends on the context. There is value in keeping similar concepts / implementations in the same file. If one class and one extension per file become a requirement, then private will have the same semantics as in C++. It will also become very inconvenient to write code because even a small extension with 1 method that can fit on one line will require a separate file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt;&gt; class authors—that will always be the case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn’t have to be. My proposal (still a pull request) provides a way to explicitly declare a function or a property to be private to the scope where it is defined. So extensions and subclasses declared in the same file cannot access it and break the invariant. If it’s applied to both class definitions and extensions, it’s very consistent and provides an explicit declaration of intent that can (and should) be enforced by the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, you have the<br>&gt;&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a crucial distinction. That particular set of braces defines a scope which acts as a black box and hides the implementation details. Anything outside the scope cannot damage the internal state, and the compiler *enforces* it. In Swift, the compiler only enforces that the API is not visible from another file because the language has no way to express “this should be visible only in the scope to hide implementation details”. The only exception to that are functions inside other functions and local variables — right now this is the only way to completely hide implementation details, but it’s very limited.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My main 2 points are that it’s impossible to express the intent of a truly local access level to hide implementation details, and because of that, the compiler cannot enforce this intent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When<br>&gt;&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This depends on how thoroughly the code is reviewed. But the main point there is that when you find out, you know that whoever worked around a private API did so knowing that he was introducing a hack. Because Swift has no way of expressing “this is private to the class, not just file it’s in”, someone may not know and make a mistake, and the compiler cannot catch it. My proposal makes the intent expressible in the language and enforceable by the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True, but my proposal deals with extensions the same way it does with class definitions — it provides a way to hide implementation details in a scope (whether it be a class definition or an extension scope) and make them invisible to everything else including extensions or other extensions or anything else in the same file. It provides a way to express the intent in the language and enforce it by the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 5:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt;&gt; your invariants.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse<br>&gt;&gt;&gt;&gt;&gt; cannot be stopped no matter what access control is in place (as long<br>&gt;&gt;&gt;&gt;&gt; as the coder can modify the code in the module). But at least with an<br>&gt;&gt;&gt;&gt;&gt; API based access control, a deliberate misuse is very easy to spot<br>&gt;&gt;&gt;&gt;&gt; when debugging / reviewing the code. With a file based access control,<br>&gt;&gt;&gt;&gt;&gt; the only way to tell if an API is really private or can be safely used<br>&gt;&gt;&gt;&gt;&gt; anywhere in the same file is to read the comments / source code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt;&gt; C++?  Why?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And it’s much easier to miss in maintenance, debugging, or code<br>&gt;&gt;&gt;&gt;&gt; reviews. The only way to make it obvious in the current model is to<br>&gt;&gt;&gt;&gt;&gt; adopt a convention like _ in front of methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only reason we&#39;re doing that in the standard library is that we&#39;re<br>&gt;&gt;&gt;&gt; currently forced to make some implementation details formally public,<br>&gt;&gt;&gt;&gt; and we can&#39;t use “private” because &lt;reasons&gt;.  If it weren&#39;t for these<br>&gt;&gt;&gt;&gt; limitations, we&#39;d be very happy with “private.”  Defining one type per<br>&gt;&gt;&gt;&gt; file is usually a good practice anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red<br>&gt;&gt;&gt;&gt;&gt;&gt; flag in Swift, because it&#39;s perfectly legit to do so and use only<br>&gt;&gt;&gt;&gt;&gt;&gt; the class&#39; public APIs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unless the programmer extends a class in the same file. Then he can<br>&gt;&gt;&gt;&gt;&gt; call anything marked private, and it’s impossible to tell without<br>&gt;&gt;&gt;&gt;&gt; reading the code whether it violates the class invariants.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt;&gt; class authors—that will always be the case.  Therefore, you have the<br>&gt;&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is no way to express this in Swift today. My proposal for local<br>&gt;&gt;&gt;&gt;&gt; / scoped access control would solve this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; we didn&#39;t do file-level access control because it was easier; we<br>&gt;&gt;&gt;&gt;&gt;&gt; did it because we thought it was a better model for Swift, where<br>&gt;&gt;&gt;&gt;&gt;&gt; types are liberally open for extension.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s what I assumed until I saw someone say it in this list when<br>&gt;&gt;&gt;&gt;&gt; someone else raised a similar concern. Types in C++ and C# are also<br>&gt;&gt;&gt;&gt;&gt; liberally open for extension,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 24, 2016 at 06:00:00am</p></header><div class="content"><p>The main idea is that “local” makes the author’s intent clear (the function or property should not be visible outside the scope) and it’s enforceable by the compiler and protects against accidental misuse. It also makes deliberate misuse easier to spot because it would require changes to the function or property declaration.<br></p><p>It is different from private in that you can add code to the same file and access anything marked as private and break things by calling something that was not supposed to be used directly. With local, you are forced to modify the function declaration, and you know that you are using the function or a property that was specifically hidden by the author. With private, you can never know if it can or cannot be called in the same file without the danger of breaking class invariant.<br></p><p>I think that lexical scope (type based) access would be enough. I wouldn’t want to require self (C++ and C# model) because it’s about the type, not the instance. But if this was the only way to get this accepted, I’d support that. It would be much better than nothing.<br></p><p>&gt; Where is the appropriate floor on access restrictions? Why isn&#39;t a single file the appropriate floor?<br></p><p>I think that it’s scope. It’s the smallest subdivision that can exit, and it provides a way to specify a public API for a class. Private as it is today does not express public / private API for a class. It only expresses access inside the same compilation unit, which is different.<br></p><p>&gt; On Jan 23, 2016, at 10:50 PM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; Thanks for sharing that.<br>&gt; <br>&gt; It seems like the proposal would be stronger with some specific code examples of problems that can arise with `private` that are ameliorated with the introduction of `local`. I get the basic idea: with `private` I have to understand all the invariants in the file while with `local` I only need to understand the invariants within the lexical scope. However, I&#39;m having trouble understanding the situation where those are sufficiently different to justify increasing the complexity of the language. (If you were proposing replacing `private` with `local`, then the complexity would be the same. Of course, in that case, you&#39;d need to justify removing the level of access that allows extensions to access private members.) I may just be failing to understand. If so, a sufficiently detailed example would help, I think.<br>&gt; <br>&gt; Secondly, in some languages, private members can only be accessed on self instances. Is your intention that local members can only be accessed thusly. That is, would the following be allowed:<br>&gt; <br>&gt; struct Foo {<br>&gt;  local var bar: String<br>&gt;  // ...<br>&gt;  mutating func concatBar(otherFoo: Foo) {<br>&gt;    let othersBar = otherFoo.bar // legal?<br>&gt;    bar = bar + othersBar<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; More generally, different languages have provided a wide variation in the specificity of their access control mechanisms. If `local` is only about static scope (i.e., the example above is legal), then do we need a mechanism for restricting to self-only access? Where is the appropriate floor on access restrictions? Why isn&#39;t a single file the appropriate floor?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Curt<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 6:37 PM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here is a link to the pull request:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/64<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 9:23 PM, Curt Clifton &lt;curt at omnigroup.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might aid the discussion if you provided a link to your proposal. I&#39;m assuming it includes examples of problems that your proposed changes solve. I&#39;d be interested in seeing those.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Curt<br>&gt;&gt;&gt; ------------------------- <br>&gt;&gt;&gt; Curt Clifton, PhD <br>&gt;&gt;&gt; Software Developer <br>&gt;&gt;&gt; The Omni Group <br>&gt;&gt;&gt; www.curtclifton.net <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 6:17 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I had to come up with this term to distinguish it from a file based access control. In API based access control, visibility of anything is tied to the declaration instead of the file it is in. It’s the model that C++ and C# ( and I am sure many others) use. In file based access control, visibility of anything is tied to the file it is in and has little to do with the class API itself. It’s the model that Swift currently follows.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt;&gt;&gt; your invariants.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Swift, any additional code in the same source file can use the APIs declared private and break your invariants. The semantic meaning of private is not “use only inside the class” but “use only inside this file”. It is currently impossible to express “use only inside the class” semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt;&gt;&gt; C++?  Why?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because in Swift, private means “use only inside this file” and not “use only inside this class / scope”. In C++ private means “use only inside this class”. Moreover, C++ puts a special emphasis on this — variables are private inside the class unless the code specifically says otherwise.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Defining one type per file is usually a good practice anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really depends on the context. There is value in keeping similar concepts / implementations in the same file. If one class and one extension per file become a requirement, then private will have the same semantics as in C++. It will also become very inconvenient to write code because even a small extension with 1 method that can fit on one line will require a separate file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt;&gt;&gt; class authors—that will always be the case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It doesn’t have to be. My proposal (still a pull request) provides a way to explicitly declare a function or a property to be private to the scope where it is defined. So extensions and subclasses declared in the same file cannot access it and break the invariant. If it’s applied to both class definitions and extensions, it’s very consistent and provides an explicit declaration of intent that can (and should) be enforced by the compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Therefore, you have the<br>&gt;&gt;&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a crucial distinction. That particular set of braces defines a scope which acts as a black box and hides the implementation details. Anything outside the scope cannot damage the internal state, and the compiler *enforces* it. In Swift, the compiler only enforces that the API is not visible from another file because the language has no way to express “this should be visible only in the scope to hide implementation details”. The only exception to that are functions inside other functions and local variables — right now this is the only way to completely hide implementation details, but it’s very limited.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My main 2 points are that it’s impossible to express the intent of a truly local access level to hide implementation details, and because of that, the compiler cannot enforce this intent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When<br>&gt;&gt;&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This depends on how thoroughly the code is reviewed. But the main point there is that when you find out, you know that whoever worked around a private API did so knowing that he was introducing a hack. Because Swift has no way of expressing “this is private to the class, not just file it’s in”, someone may not know and make a mistake, and the compiler cannot catch it. My proposal makes the intent expressible in the language and enforceable by the compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True, but my proposal deals with extensions the same way it does with class definitions — it provides a way to hide implementation details in a scope (whether it be a class definition or an extension scope) and make them invisible to everything else including extensions or other extensions or anything else in the same file. It provides a way to express the intent in the language and enforce it by the compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 23, 2016, at 5:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;ilya.belenkiy-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyone who can &quot;add more code to the same file&quot; can just as easily modify/extend the class.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but with an API based access control,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt;&gt;&gt; intent from the API declaration,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt;&gt;&gt; your invariants.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and the compiler can prevent *accidental* misuse. Deliberate misuse<br>&gt;&gt;&gt;&gt;&gt;&gt; cannot be stopped no matter what access control is in place (as long<br>&gt;&gt;&gt;&gt;&gt;&gt; as the coder can modify the code in the module). But at least with an<br>&gt;&gt;&gt;&gt;&gt;&gt; API based access control, a deliberate misuse is very easy to spot<br>&gt;&gt;&gt;&gt;&gt;&gt; when debugging / reviewing the code. With a file based access control,<br>&gt;&gt;&gt;&gt;&gt;&gt; the only way to tell if an API is really private or can be safely used<br>&gt;&gt;&gt;&gt;&gt;&gt; anywhere in the same file is to read the comments / source code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt;&gt;&gt; C++?  Why?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And it’s much easier to miss in maintenance, debugging, or code<br>&gt;&gt;&gt;&gt;&gt;&gt; reviews. The only way to make it obvious in the current model is to<br>&gt;&gt;&gt;&gt;&gt;&gt; adopt a convention like _ in front of methods.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The only reason we&#39;re doing that in the standard library is that we&#39;re<br>&gt;&gt;&gt;&gt;&gt; currently forced to make some implementation details formally public,<br>&gt;&gt;&gt;&gt;&gt; and we can&#39;t use “private” because &lt;reasons&gt;.  If it weren&#39;t for these<br>&gt;&gt;&gt;&gt;&gt; limitations, we&#39;d be very happy with “private.”  Defining one type per<br>&gt;&gt;&gt;&gt;&gt; file is usually a good practice anyway.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; flag in Swift, because it&#39;s perfectly legit to do so and use only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the class&#39; public APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unless the programmer extends a class in the same file. Then he can<br>&gt;&gt;&gt;&gt;&gt;&gt; call anything marked private, and it’s impossible to tell without<br>&gt;&gt;&gt;&gt;&gt;&gt; reading the code whether it violates the class invariants.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt;&gt;&gt; class authors—that will always be the case.  Therefore, you have the<br>&gt;&gt;&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt;&gt;&gt; braces anyway.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is no way to express this in Swift today. My proposal for local<br>&gt;&gt;&gt;&gt;&gt;&gt; / scoped access control would solve this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we didn&#39;t do file-level access control because it was easier; we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; did it because we thought it was a better model for Swift, where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types are liberally open for extension.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s what I assumed until I saw someone say it in this list when<br>&gt;&gt;&gt;&gt;&gt;&gt; someone else raised a similar concern. Types in C++ and C# are also<br>&gt;&gt;&gt;&gt;&gt;&gt; liberally open for extension,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>access control</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 3:14 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&lt;snip&gt;<br>&gt;&gt;  With a file based access control, the only way to tell if an API is really private or can be safely used anywhere in the same file is to read the comments / source code. And it’s much easier to miss in maintenance, debugging, or code reviews. The only way to make it obvious in the current model is to adopt a convention like _ in front of methods.<br></p><p>Within the same file, I would expect a member of my team writing code has the domain knowledge to do so correctly.<br></p><p>Is the primary use case meant for files which have grown too large/complex for the authors to be expected to comprehend the type state invariance of the code they are currently working on?<br></p><p>Or is the thought that developers may add code to the file to get access to private api (and implicit action), while they would not be willing to edit the access levels to do so otherwise (an explicit action)? This sounds like a process issue within a team, as access control flags will not necessarily restrict the process of modifying the code in certain ways for people who are already tasked with such without such external process/ramifications in place.<br></p><p>&gt; <br>&gt;&gt; There&#39;s nothing about extending a class that ought to raise a red flag in Swift, because it&#39;s perfectly legit to do so and use only the class&#39; public APIs.<br>&gt; <br>&gt; <br>&gt; Unless the programmer extends a class in the same file. Then he can call anything marked private, and it’s impossible to tell without reading the code whether it violates the class invariants. There is no way to express this in Swift today. My proposal for local / scoped access control would solve this.<br></p><p>There is nothing about someone editing that file to change a “local&quot; access modifier to “internal&quot; which will raise a red flag with Swift. Is this something that you plan to detect and block via a SCM commit hook/code review product?<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/98d642a9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
