<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Jacob, <br></p><p>This may be totally unrelated but how would proposed protocol handle enums with payloads?<br>I field a SR requesting a way to get the declared order cases of enums with payloads. <br>https://bugs.swift.org/browse/SR-887 &lt;https://bugs.swift.org/browse/SR-887&gt;<br></p><p>Do you think your proposal could be expanded to include Enums with payloads? <br></p><p>Thanks!<br></p><p>&gt; Hi folks,<br>&gt; <br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive<br>&gt; a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially<br>&gt; for refining the proposal before I submit a formal PR.<br>&gt; <br>&gt; The draft is here; full text below.<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt; <br>&gt; <br>&gt; Derived Collection of Enum Cases<br>&gt; <br>&gt; - Proposal: SE-NNNN<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt; - Author(s): Jacob Bandes-Storch&lt;https://github.com/jtbandes&gt;<br>&gt; - Status: *Awaiting review*<br>&gt; - Review manager: TBD<br>&gt; <br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt; Introduction<br>&gt; <br>&gt; It is a truth universally acknowledged, that a programmer in possession of<br>&gt; an enum with many cases, must eventually be in want of dynamic enumeration<br>&gt; over them.<br>&gt; <br>&gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt; far:<br>&gt; <br>&gt; - List of all Enum values (for simple enums)<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt;<br>&gt; (December<br>&gt; 8, 2015)<br>&gt; - Proposal: Enum &#39;count&#39; functionality<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt;<br>&gt; (December<br>&gt; 21, 2015)<br>&gt; - Draft Proposal: count property for enum types<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt;<br>&gt; (January<br>&gt; 17, 2016)<br>&gt; <br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt; <br>&gt; - How to enumerate an enum with String type?<br>&gt; &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt;<br>&gt; (June<br>&gt; 3, 2014; question score 131)<br>&gt; - How do I get the count of a Swift enum?<br>&gt; &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt;<br>&gt; (November<br>&gt; 23, 2014; question score 37)<br>&gt; <br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Simple enums are finite, and their values are statically known to the<br>&gt; compiler, yet working with them programmatically is challenging. It is<br>&gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt; the number of cases (or maximum valid rawValue).<br>&gt; <br>&gt; Currently, however, there is no built-in reflection or enumeration support.<br>&gt; Users must resort to manually listing out cases in order to iterate over<br>&gt; them:<br>&gt; <br>&gt; enum Attribute {<br>&gt; case Date, Name, Author<br>&gt; }func valueForAttribute(attr: Attribute) -&gt;String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0)<br>&gt; }.joinWithSeparator(&quot;\n&quot;)<br>&gt; <br>&gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt; known (or assumed) allowable raw values:<br>&gt; <br>&gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending<br>&gt; &quot;enum&quot;&lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt;(October<br>&gt; 2014):*<br>&gt; <br>&gt; enum Reindeer: Int {<br>&gt; case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner,<br>&gt; Blitzen, Rudolph<br>&gt; }extension Reindeer {<br>&gt; static var allCases: [Reindeer] {<br>&gt; var cur = 0<br>&gt; return Array(<br>&gt; GeneratorOf&lt;Reindeer&gt;{<br>&gt; return Reindeer(rawValue: cur++)<br>&gt; }<br>&gt; )<br>&gt; }<br>&gt; static var caseCount: Int {<br>&gt; var max: Int = 0<br>&gt; while let _ = self(rawValue: ++max) {}<br>&gt; return max<br>&gt; }<br>&gt; static func randomCase() -&gt;Reindeer {<br>&gt; // everybody do the Int/UInt32 shuffle!<br>&gt; let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt; return self(rawValue: randomValue)!<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; There are many problems with these existing techniques:<br>&gt; <br>&gt; - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt; and code.<br>&gt; - They are not standardized across codebases, nor provided automatically<br>&gt; by libraries such as Foundation and {App,UI}Kit.<br>&gt; - They are sometimes prone to bugs when enum cases are added, but the<br>&gt; user forgets to update a hard-coded static collection of cases.<br>&gt; <br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt; <br>&gt; -<br>&gt; <br>&gt; Rust does not seem to have a solution for this problem.<br>&gt; -<br>&gt; <br>&gt; C#&#39;s Enum has several methods<br>&gt; &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt;<br>&gt; available<br>&gt; for reflection, including GetValues() and GetNames().<br>&gt; -<br>&gt; <br>&gt; Java implicitly declares<br>&gt; &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;a<br>&gt; static values() function, returning an array of enum values, and<br>&gt; valueOf(String<br>&gt; name) which takes a String and returns the enum value with the<br>&gt; corresponding name (or throws an exception). More examples here<br>&gt; &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt; -<br>&gt; <br>&gt; The Template Haskell extension to Haskell provides a function reify which<br>&gt; extracts info about types<br>&gt; &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt; including their constructors.<br>&gt; <br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt; <br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; automagically derive a static var cases, whose type is a CollectionType of<br>&gt; all the enum&#39;s values.<br>&gt; <br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible<br>&gt; requirements; merely adding the conformance is enough to enable case<br>&gt; enumeration.<br>&gt; <br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; extension Ma: CaseEnumerable {}<br>&gt; <br>&gt; Ma.cases // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count // returns 7Array(Ma.cases) // returns [Ma.È©¨, .Âêó,<br>&gt; .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt; <br>&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt; <br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; Array(NSTextAlignment.cases) // returns [NSTextAlignment.Left,<br>&gt; .Right, .Center, .Justified, .Natural]<br>&gt; <br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt; <br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt; <br>&gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt; need to be stored, and the enum construction can happen dynamically.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt; compiler error.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for an enum with associated values will<br>&gt; result in a compiler error.<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt; variations<br>&gt; <br>&gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt; solution* or *Future directions* before the proposal is submitted for<br>&gt; review.<br>&gt; <br>&gt; -<br>&gt; <br>&gt; For enums with raw values, a static rawValues property (a collection of<br>&gt; RawValue rather than the enum type itself) could also be synthesized.<br>&gt; -<br>&gt; <br>&gt; CaseEnumerable could have a user-visible declaration requiring static<br>&gt; var cases, which would allow users to add conformances for custom non-<br>&gt; enum types.<br>&gt; - In this case, adding a conformance for a non-enum type would not be a<br>&gt; compiler error, it would just require an explicit implementation<br>&gt; of static<br>&gt; var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt; - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt; introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt; CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt; Self.<br>&gt; -<br>&gt; <br>&gt; It would be nice to have a way of supporting this for OptionSetType<br>&gt; structs. I would recommend that cases for an OptionSetType should<br>&gt; include only the already-declared static properties (not all possible<br>&gt; combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt; <br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt; <br>&gt; This proposal only adds functionality, so existing code will not be<br>&gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt; appearances in Google and GitHub searches.)<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; <br>&gt; The community has not raised any solutions that differ significantly from<br>&gt; this proposal, except for solutions which provide strictly *more*<br>&gt; functionality.<br>&gt; These are covered in the next section, *Future directions*.<br>&gt; <br>&gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt; discussed in the *Motivation* section above.<br>&gt; <br>&gt; The functionality could also be provided entirely through the<br>&gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt; confusing usage patterns.<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt; directions<br>&gt; <br>&gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt; the community can continue discussing the topic to flesh out more features.<br>&gt; <br>&gt; Here are some starting points, which are *not* part of this proposal:<br>&gt; <br>&gt; -<br>&gt; <br>&gt; Support for enum case *names*. It would be useful to get case names even<br>&gt; for enums which have integer rawValues. This could be part of the existing<br>&gt; reflection APIs, or it could take the form of derived implementations of<br>&gt; StringLiteralConvertible/CustomStringConvertible.<br>&gt; -<br>&gt; <br>&gt; Support for enums with associated values.<br>&gt; -<br>&gt; <br>&gt; When all associated values are themselves CaseEnumerable, this could<br>&gt; happen automatically:<br>&gt; <br>&gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs<br>&gt; }enum Rank: Int, CaseEnumerable {<br>&gt; case Ace = 1, Two, Three, Four, Five, Six<br>&gt; case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt; }enum Card {<br>&gt; case Joker<br>&gt; case Value(Rank, Suit)<br>&gt; }<br>&gt; // This now works, and generates all possible card types (Joker,<br>&gt; Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt; <br>&gt; -<br>&gt; <br>&gt; If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt; homogeneous, the cases collection could vend functions of<br>&gt; AssociatedValueType<br>&gt; -&gt;EnumType:<br>&gt; <br>&gt; enum LogMessage { case Error(String), Warning(String),<br>&gt; Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt; <br>&gt; LogMessage.cases // elements are (String) -&gt;LogMessage<br>&gt; <br>&gt; -<br>&gt; <br>&gt; If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt; vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt; <br>&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr),<br>&gt; Literal(Int) }extension Value: CaseEnumerable {}<br>&gt; // This example is pretty contrived, but illustrates the<br>&gt; functionality.let fortyTwos = Expr.cases.map {<br>&gt; // $0 is of type `Int -&gt;Expr | (Expr, Expr) -&gt;Expr`<br>&gt; switch $0 {<br>&gt; case let lit as Int -&gt;Expr: // handles .Literal<br>&gt; return lit(42)<br>&gt; case let bin as (Expr, Expr) -&gt;Expr: // handles .Apply and .Tuple<br>&gt; return bin(.Literal(42), .Literal(42))<br>&gt; // all cases are covered<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; -<br>&gt; <br>&gt; Support for generic enums.<br>&gt; -<br>&gt; <br>&gt; CaseEnumerable could be conditionally supported depending on the<br>&gt; generic argument(s). A great example would be Optional:<br>&gt; <br>&gt; enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable<br>&gt; where Wrapped: CaseEnumerable {}<br>&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/4421bf9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>March  8, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Jose,<br>Enums with payloads were discussed, but the proposal considers them out of<br>scope ‚Äî I was trying to keep it minimal so we could get a first version<br>into the language. (Still waiting for it to be merged though...!<br>https://github.com/apple/swift-evolution/pull/114 )<br></p><p>Jacob<br></p><p>On Tue, Mar 8, 2016 at 6:34 PM, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>wrote:<br></p><p>&gt; Hi Jacob,<br>&gt;<br>&gt; This may be totally unrelated but how would proposed protocol handle enums<br>&gt; with payloads?<br>&gt; I field a SR requesting a way to get the declared order cases of enums<br>&gt; with payloads.<br>&gt; https://bugs.swift.org/browse/SR-887<br>&gt;<br>&gt; Do you think your proposal could be expanded to include Enums with<br>&gt; payloads?<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; &gt; Hi folks,<br>&gt; &gt;<br>&gt; &gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will<br>&gt; derive<br>&gt; &gt; a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially<br>&gt; &gt; for refining the proposal before I submit a formal PR.<br>&gt; &gt;<br>&gt; &gt; The draft is here; full text below.<br>&gt; &gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Derived Collection of Enum Cases<br>&gt; &gt;<br>&gt; &gt; - Proposal: SE-NNNN<br>&gt; &gt; &lt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md<br>&gt; &gt;<br>&gt; &gt; - Author(s): Jacob Bandes-Storch&lt;https://github.com/jtbandes&gt;<br>&gt; &gt; - Status: *Awaiting review*<br>&gt; &gt; - Review manager: TBD<br>&gt; &gt;<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction<br>&gt; &gt;<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; It is a truth universally acknowledged, that a programmer in possession<br>&gt; of<br>&gt; &gt; an enum with many cases, must eventually be in want of dynamic<br>&gt; enumeration<br>&gt; &gt; over them.<br>&gt; &gt;<br>&gt; &gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt; &gt; far:<br>&gt; &gt;<br>&gt; &gt; - List of all Enum values (for simple enums)<br>&gt; &gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html<br>&gt; &gt;<br>&gt; &gt; (December<br>&gt; &gt; 8, 2015)<br>&gt; &gt; - Proposal: Enum &#39;count&#39; functionality<br>&gt; &gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html<br>&gt; &gt;<br>&gt; &gt; (December<br>&gt; &gt; 21, 2015)<br>&gt; &gt; - Draft Proposal: count property for enum types<br>&gt; &gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html<br>&gt; &gt;<br>&gt; &gt; (January<br>&gt; &gt; 17, 2016)<br>&gt; &gt;<br>&gt; &gt; Enumerating enumerations in Swift is also a popular topic on Stack<br>&gt; Overflow:<br>&gt; &gt;<br>&gt; &gt; - How to enumerate an enum with String type?<br>&gt; &gt; &lt;<br>&gt; http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type<br>&gt; &gt;<br>&gt; &gt; (June<br>&gt; &gt; 3, 2014; question score 131)<br>&gt; &gt; - How do I get the count of a Swift enum?<br>&gt; &gt; &lt;<br>&gt; http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum<br>&gt; &gt;<br>&gt; &gt; (November<br>&gt; &gt; 23, 2014; question score 37)<br>&gt; &gt;<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Simple enums are finite, and their values are statically known to the<br>&gt; &gt; compiler, yet working with them programmatically is challenging. It is<br>&gt; &gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt; &gt; the number of cases (or maximum valid rawValue).<br>&gt; &gt;<br>&gt; &gt; Currently, however, there is no built-in reflection or enumeration<br>&gt; support.<br>&gt; &gt; Users must resort to manually listing out cases in order to iterate over<br>&gt; &gt; them:<br>&gt; &gt;<br>&gt; &gt; enum Attribute {<br>&gt; &gt; case Date, Name, Author<br>&gt; &gt; }func valueForAttribute(attr: Attribute) -&gt;String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; &gt; // Cases must be listed explicitly:<br>&gt; &gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0)<br>&gt; &gt; }.joinWithSeparator(&quot;\n&quot;)<br>&gt; &gt;<br>&gt; &gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt; &gt; known (or assumed) allowable raw values:<br>&gt; &gt;<br>&gt; &gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for<br>&gt; Extending<br>&gt; &gt; &quot;enum&quot;&lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/<br>&gt; &gt;(October<br>&gt; &gt; 2014):*<br>&gt; &gt;<br>&gt; &gt; enum Reindeer: Int {<br>&gt; &gt; case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner,<br>&gt; &gt; Blitzen, Rudolph<br>&gt; &gt; }extension Reindeer {<br>&gt; &gt; static var allCases: [Reindeer] {<br>&gt; &gt; var cur = 0<br>&gt; &gt; return Array(<br>&gt; &gt; GeneratorOf&lt;Reindeer&gt;{<br>&gt; &gt; return Reindeer(rawValue: cur++)<br>&gt; &gt; }<br>&gt; &gt; )<br>&gt; &gt; }<br>&gt; &gt; static var caseCount: Int {<br>&gt; &gt; var max: Int = 0<br>&gt; &gt; while let _ = self(rawValue: ++max) {}<br>&gt; &gt; return max<br>&gt; &gt; }<br>&gt; &gt; static func randomCase() -&gt;Reindeer {<br>&gt; &gt; // everybody do the Int/UInt32 shuffle!<br>&gt; &gt; let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt; &gt; return self(rawValue: randomValue)!<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; There are many problems with these existing techniques:<br>&gt; &gt;<br>&gt; &gt; - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt; &gt; and code.<br>&gt; &gt; - They are not standardized across codebases, nor provided automatically<br>&gt; &gt; by libraries such as Foundation and {App,UI}Kit.<br>&gt; &gt; - They are sometimes prone to bugs when enum cases are added, but the<br>&gt; &gt; user forgets to update a hard-coded static collection of cases.<br>&gt; &gt;<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages<br>&gt; &gt;Precedent<br>&gt; &gt; in other languages<br>&gt; &gt;<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; Rust does not seem to have a solution for this problem.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; C#&#39;s Enum has several methods<br>&gt; &gt; &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt;<br>&gt; &gt; available<br>&gt; &gt; for reflection, including GetValues() and GetNames().<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; Java implicitly declares<br>&gt; &gt; &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;a<br>&gt; &gt; static values() function, returning an array of enum values, and<br>&gt; &gt; valueOf(String<br>&gt; &gt; name) which takes a String and returns the enum value with the<br>&gt; &gt; corresponding name (or throws an exception). More examples here<br>&gt; &gt; &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; The Template Haskell extension to Haskell provides a function reify which<br>&gt; &gt; extracts info about types<br>&gt; &gt; &lt;<br>&gt; http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info<br>&gt; &gt;,<br>&gt; &gt; including their constructors.<br>&gt; &gt;<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution<br>&gt; &gt;Proposed<br>&gt; &gt; solution<br>&gt; &gt;<br>&gt; &gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; &gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt; of<br>&gt; &gt; all the enum&#39;s values.<br>&gt; &gt;<br>&gt; &gt; Like ErrorType, the CaseEnumerable protocol will not have any<br>&gt; user-visible<br>&gt; &gt; requirements; merely adding the conformance is enough to enable case<br>&gt; &gt; enumeration.<br>&gt; &gt;<br>&gt; &gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; &gt; extension Ma: CaseEnumerable {}<br>&gt; &gt;<br>&gt; &gt; Ma.cases // returns some CollectionType whose Generator.Element is Ma<br>&gt; &gt; Ma.cases.count // returns 7Array(Ma.cases) // returns [Ma.È©¨, .Âêó,<br>&gt; &gt; .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt; &gt;<br>&gt; &gt; Conformances can even be added for enums which are defined in other<br>&gt; modules:<br>&gt; &gt;<br>&gt; &gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; &gt; Array(NSTextAlignment.cases) // returns [NSTextAlignment.Left,<br>&gt; &gt; .Right, .Center, .Justified, .Natural]<br>&gt; &gt;<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design<br>&gt; &gt;Detailed<br>&gt; &gt; design<br>&gt; &gt;<br>&gt; &gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt; &gt;<br>&gt; &gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt; &gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt; &gt; need to be stored, and the enum construction can happen dynamically.<br>&gt; &gt;<br>&gt; &gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt; &gt; compiler error.<br>&gt; &gt;<br>&gt; &gt; Attempting to derive CaseEnumerable for an enum with associated values<br>&gt; will<br>&gt; &gt; result in a compiler error.<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations<br>&gt; &gt;Possible<br>&gt; &gt; variations<br>&gt; &gt;<br>&gt; &gt; I&#39;d like us to discuss these, but they should be folded into either<br>&gt; *Proposed<br>&gt; &gt; solution* or *Future directions* before the proposal is submitted for<br>&gt; &gt; review.<br>&gt; &gt;<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; For enums with raw values, a static rawValues property (a collection of<br>&gt; &gt; RawValue rather than the enum type itself) could also be synthesized.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; CaseEnumerable could have a user-visible declaration requiring static<br>&gt; &gt; var cases, which would allow users to add conformances for custom non-<br>&gt; &gt; enum types.<br>&gt; &gt; - In this case, adding a conformance for a non-enum type would not be a<br>&gt; &gt; compiler error, it would just require an explicit implementation<br>&gt; &gt; of static<br>&gt; &gt; var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt; &gt; - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt; &gt; introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt; &gt; CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt; &gt; Self.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; It would be nice to have a way of supporting this for OptionSetType<br>&gt; &gt; structs. I would recommend that cases for an OptionSetType should<br>&gt; &gt; include only the already-declared static properties (not all possible<br>&gt; &gt; combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt; &gt;<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code<br>&gt; &gt;Impact<br>&gt; &gt; on existing code<br>&gt; &gt;<br>&gt; &gt; This proposal only adds functionality, so existing code will not be<br>&gt; &gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt; &gt; appearances in Google and GitHub searches.)<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered<br>&gt; &gt;Alternatives<br>&gt; &gt; considered<br>&gt; &gt;<br>&gt; &gt; The community has not raised any solutions that differ significantly from<br>&gt; &gt; this proposal, except for solutions which provide strictly *more*<br>&gt; &gt; functionality.<br>&gt; &gt; These are covered in the next section, *Future directions*.<br>&gt; &gt;<br>&gt; &gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt; &gt; discussed in the *Motivation* section above.<br>&gt; &gt;<br>&gt; &gt; The functionality could also be provided entirely through the<br>&gt; &gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt; &gt; confusing usage patterns.<br>&gt; &gt; &lt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions<br>&gt; &gt;Future<br>&gt; &gt; directions<br>&gt; &gt;<br>&gt; &gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt; &gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I<br>&gt; hope<br>&gt; &gt; the community can continue discussing the topic to flesh out more<br>&gt; features.<br>&gt; &gt;<br>&gt; &gt; Here are some starting points, which are *not* part of this proposal:<br>&gt; &gt;<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; Support for enum case *names*. It would be useful to get case names even<br>&gt; &gt; for enums which have integer rawValues. This could be part of the<br>&gt; existing<br>&gt; &gt; reflection APIs, or it could take the form of derived implementations of<br>&gt; &gt; StringLiteralConvertible/CustomStringConvertible.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; Support for enums with associated values.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; When all associated values are themselves CaseEnumerable, this could<br>&gt; &gt; happen automatically:<br>&gt; &gt;<br>&gt; &gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs<br>&gt; &gt; }enum Rank: Int, CaseEnumerable {<br>&gt; &gt; case Ace = 1, Two, Three, Four, Five, Six<br>&gt; &gt; case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt; &gt; }enum Card {<br>&gt; &gt; case Joker<br>&gt; &gt; case Value(Rank, Suit)<br>&gt; &gt; }<br>&gt; &gt; // This now works, and generates all possible card types (Joker,<br>&gt; &gt; Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt; &gt;<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt; &gt; homogeneous, the cases collection could vend functions of<br>&gt; &gt; AssociatedValueType<br>&gt; &gt; -&gt;EnumType:<br>&gt; &gt;<br>&gt; &gt; enum LogMessage { case Error(String), Warning(String),<br>&gt; &gt; Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt; &gt;<br>&gt; &gt; LogMessage.cases // elements are (String) -&gt;LogMessage<br>&gt; &gt;<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt; &gt; vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt; &gt;<br>&gt; &gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr),<br>&gt; &gt; Literal(Int) }extension Value: CaseEnumerable {}<br>&gt; &gt; // This example is pretty contrived, but illustrates the<br>&gt; &gt; functionality.let fortyTwos = Expr.cases.map {<br>&gt; &gt; // $0 is of type `Int -&gt;Expr | (Expr, Expr) -&gt;Expr`<br>&gt; &gt; switch $0 {<br>&gt; &gt; case let lit as Int -&gt;Expr: // handles .Literal<br>&gt; &gt; return lit(42)<br>&gt; &gt; case let bin as (Expr, Expr) -&gt;Expr: // handles .Apply and .Tuple<br>&gt; &gt; return bin(.Literal(42), .Literal(42))<br>&gt; &gt; // all cases are covered<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; Support for generic enums.<br>&gt; &gt; -<br>&gt; &gt;<br>&gt; &gt; CaseEnumerable could be conditionally supported depending on the<br>&gt; &gt; generic argument(s). A great example would be Optional:<br>&gt; &gt;<br>&gt; &gt; enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable<br>&gt; &gt; where Wrapped: CaseEnumerable {}<br>&gt; &gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/ab0586e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>March  9, 2016 at 08:00:00am</p></header><div class="content"><p>I would like to see in this proposal go into review.<br></p><p><br>&gt; On Mar 9, 2016, at 12:45 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Jose,<br>&gt; Enums with payloads were discussed, but the proposal considers them out of scope ‚Äî I was trying to keep it minimal so we could get a first version into the language. (Still waiting for it to be merged though...! https://github.com/apple/swift-evolution/pull/114 )<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt;&gt; On Tue, Mar 8, 2016 at 6:34 PM, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt;&gt; Hi Jacob, <br>&gt;&gt; <br>&gt;&gt; This may be totally unrelated but how would proposed protocol handle enums with payloads?<br>&gt;&gt; I field a SR requesting a way to get the declared order cases of enums with payloads. <br>&gt;&gt; https://bugs.swift.org/browse/SR-887<br>&gt;&gt; <br>&gt;&gt; Do you think your proposal could be expanded to include Enums with payloads? <br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; &gt; Hi folks,<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive<br>&gt;&gt; &gt; a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially<br>&gt;&gt; &gt; for refining the proposal before I submit a formal PR.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The draft is here; full text below.<br>&gt;&gt; &gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Derived Collection of Enum Cases<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; - Proposal: SE-NNNN<br>&gt;&gt; &gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;&gt; &gt; - Author(s): Jacob Bandes-Storch&lt;https://github.com/jtbandes&gt;<br>&gt;&gt; &gt; - Status: *Awaiting review*<br>&gt;&gt; &gt; - Review manager: TBD<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt;&gt; &gt; Introduction<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; It is a truth universally acknowledged, that a programmer in possession of<br>&gt;&gt; &gt; an enum with many cases, must eventually be in want of dynamic enumeration<br>&gt;&gt; &gt; over them.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt;&gt; &gt; far:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; - List of all Enum values (for simple enums)<br>&gt;&gt; &gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt;<br>&gt;&gt; &gt; (December<br>&gt;&gt; &gt; 8, 2015)<br>&gt;&gt; &gt; - Proposal: Enum &#39;count&#39; functionality<br>&gt;&gt; &gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt;<br>&gt;&gt; &gt; (December<br>&gt;&gt; &gt; 21, 2015)<br>&gt;&gt; &gt; - Draft Proposal: count property for enum types<br>&gt;&gt; &gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt;<br>&gt;&gt; &gt; (January<br>&gt;&gt; &gt; 17, 2016)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; - How to enumerate an enum with String type?<br>&gt;&gt; &gt; &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt;<br>&gt;&gt; &gt; (June<br>&gt;&gt; &gt; 3, 2014; question score 131)<br>&gt;&gt; &gt; - How do I get the count of a Swift enum?<br>&gt;&gt; &gt; &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt;<br>&gt;&gt; &gt; (November<br>&gt;&gt; &gt; 23, 2014; question score 37)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt;&gt; &gt; Motivation<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Simple enums are finite, and their values are statically known to the<br>&gt;&gt; &gt; compiler, yet working with them programmatically is challenging. It is<br>&gt;&gt; &gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt;&gt; &gt; the number of cases (or maximum valid rawValue).<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Currently, however, there is no built-in reflection or enumeration support.<br>&gt;&gt; &gt; Users must resort to manually listing out cases in order to iterate over<br>&gt;&gt; &gt; them:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum Attribute {<br>&gt;&gt; &gt; case Date, Name, Author<br>&gt;&gt; &gt; }func valueForAttribute(attr: Attribute) -&gt;String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt;&gt; &gt; // Cases must be listed explicitly:<br>&gt;&gt; &gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0)<br>&gt;&gt; &gt; }.joinWithSeparator(&quot;\n&quot;)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt;&gt; &gt; known (or assumed) allowable raw values:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending<br>&gt;&gt; &gt; &quot;enum&quot;&lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt;(October<br>&gt;&gt; &gt; 2014):*<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum Reindeer: Int {<br>&gt;&gt; &gt; case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner,<br>&gt;&gt; &gt; Blitzen, Rudolph<br>&gt;&gt; &gt; }extension Reindeer {<br>&gt;&gt; &gt; static var allCases: [Reindeer] {<br>&gt;&gt; &gt; var cur = 0<br>&gt;&gt; &gt; return Array(<br>&gt;&gt; &gt; GeneratorOf&lt;Reindeer&gt;{<br>&gt;&gt; &gt; return Reindeer(rawValue: cur++)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; )<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; static var caseCount: Int {<br>&gt;&gt; &gt; var max: Int = 0<br>&gt;&gt; &gt; while let _ = self(rawValue: ++max) {}<br>&gt;&gt; &gt; return max<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; static func randomCase() -&gt;Reindeer {<br>&gt;&gt; &gt; // everybody do the Int/UInt32 shuffle!<br>&gt;&gt; &gt; let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;&gt; &gt; return self(rawValue: randomValue)!<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; There are many problems with these existing techniques:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt;&gt; &gt; and code.<br>&gt;&gt; &gt; - They are not standardized across codebases, nor provided automatically<br>&gt;&gt; &gt; by libraries such as Foundation and {App,UI}Kit.<br>&gt;&gt; &gt; - They are sometimes prone to bugs when enum cases are added, but the<br>&gt;&gt; &gt; user forgets to update a hard-coded static collection of cases.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt;&gt; &gt; in other languages<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Rust does not seem to have a solution for this problem.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; C#&#39;s Enum has several methods<br>&gt;&gt; &gt; &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt;<br>&gt;&gt; &gt; available<br>&gt;&gt; &gt; for reflection, including GetValues() and GetNames().<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Java implicitly declares<br>&gt;&gt; &gt; &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;a<br>&gt;&gt; &gt; static values() function, returning an array of enum values, and<br>&gt;&gt; &gt; valueOf(String<br>&gt;&gt; &gt; name) which takes a String and returns the enum value with the<br>&gt;&gt; &gt; corresponding name (or throws an exception). More examples here<br>&gt;&gt; &gt; &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The Template Haskell extension to Haskell provides a function reify which<br>&gt;&gt; &gt; extracts info about types<br>&gt;&gt; &gt; &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt;&gt; &gt; including their constructors.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt;&gt; &gt; solution<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt;&gt; &gt; automagically derive a static var cases, whose type is a CollectionType of<br>&gt;&gt; &gt; all the enum&#39;s values.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible<br>&gt;&gt; &gt; requirements; merely adding the conformance is enough to enable case<br>&gt;&gt; &gt; enumeration.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt;&gt; &gt; extension Ma: CaseEnumerable {}<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Ma.cases // returns some CollectionType whose Generator.Element is Ma<br>&gt;&gt; &gt; Ma.cases.count // returns 7Array(Ma.cases) // returns [Ma.È©¨, .Âêó,<br>&gt;&gt; &gt; .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Conformances can even be added for enums which are defined in other modules:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt;&gt; &gt; Array(NSTextAlignment.cases) // returns [NSTextAlignment.Left,<br>&gt;&gt; &gt; .Right, .Center, .Justified, .Natural]<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt;&gt; &gt; design<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt;&gt; &gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt;&gt; &gt; need to be stored, and the enum construction can happen dynamically.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt;&gt; &gt; compiler error.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Attempting to derive CaseEnumerable for an enum with associated values will<br>&gt;&gt; &gt; result in a compiler error.<br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt;&gt; &gt; variations<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt;&gt; &gt; solution* or *Future directions* before the proposal is submitted for<br>&gt;&gt; &gt; review.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; For enums with raw values, a static rawValues property (a collection of<br>&gt;&gt; &gt; RawValue rather than the enum type itself) could also be synthesized.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; CaseEnumerable could have a user-visible declaration requiring static<br>&gt;&gt; &gt; var cases, which would allow users to add conformances for custom non-<br>&gt;&gt; &gt; enum types.<br>&gt;&gt; &gt; - In this case, adding a conformance for a non-enum type would not be a<br>&gt;&gt; &gt; compiler error, it would just require an explicit implementation<br>&gt;&gt; &gt; of static<br>&gt;&gt; &gt; var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;&gt; &gt; - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt;&gt; &gt; introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt;&gt; &gt; CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt;&gt; &gt; Self.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; It would be nice to have a way of supporting this for OptionSetType<br>&gt;&gt; &gt; structs. I would recommend that cases for an OptionSetType should<br>&gt;&gt; &gt; include only the already-declared static properties (not all possible<br>&gt;&gt; &gt; combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; &gt; on existing code<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; This proposal only adds functionality, so existing code will not be<br>&gt;&gt; &gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt;&gt; &gt; appearances in Google and GitHub searches.)<br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt;&gt; &gt; considered<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The community has not raised any solutions that differ significantly from<br>&gt;&gt; &gt; this proposal, except for solutions which provide strictly *more*<br>&gt;&gt; &gt; functionality.<br>&gt;&gt; &gt; These are covered in the next section, *Future directions*.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt;&gt; &gt; discussed in the *Motivation* section above.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The functionality could also be provided entirely through the<br>&gt;&gt; &gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt;&gt; &gt; confusing usage patterns.<br>&gt;&gt; &gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt;&gt; &gt; directions<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt;&gt; &gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt;&gt; &gt; the community can continue discussing the topic to flesh out more features.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Here are some starting points, which are *not* part of this proposal:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Support for enum case *names*. It would be useful to get case names even<br>&gt;&gt; &gt; for enums which have integer rawValues. This could be part of the existing<br>&gt;&gt; &gt; reflection APIs, or it could take the form of derived implementations of<br>&gt;&gt; &gt; StringLiteralConvertible/CustomStringConvertible.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Support for enums with associated values.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; When all associated values are themselves CaseEnumerable, this could<br>&gt;&gt; &gt; happen automatically:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs<br>&gt;&gt; &gt; }enum Rank: Int, CaseEnumerable {<br>&gt;&gt; &gt; case Ace = 1, Two, Three, Four, Five, Six<br>&gt;&gt; &gt; case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;&gt; &gt; }enum Card {<br>&gt;&gt; &gt; case Joker<br>&gt;&gt; &gt; case Value(Rank, Suit)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; // This now works, and generates all possible card types (Joker,<br>&gt;&gt; &gt; Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt;&gt; &gt; homogeneous, the cases collection could vend functions of<br>&gt;&gt; &gt; AssociatedValueType<br>&gt;&gt; &gt; -&gt;EnumType:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum LogMessage { case Error(String), Warning(String),<br>&gt;&gt; &gt; Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; LogMessage.cases // elements are (String) -&gt;LogMessage<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt;&gt; &gt; vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr),<br>&gt;&gt; &gt; Literal(Int) }extension Value: CaseEnumerable {}<br>&gt;&gt; &gt; // This example is pretty contrived, but illustrates the<br>&gt;&gt; &gt; functionality.let fortyTwos = Expr.cases.map {<br>&gt;&gt; &gt; // $0 is of type `Int -&gt;Expr | (Expr, Expr) -&gt;Expr`<br>&gt;&gt; &gt; switch $0 {<br>&gt;&gt; &gt; case let lit as Int -&gt;Expr: // handles .Literal<br>&gt;&gt; &gt; return lit(42)<br>&gt;&gt; &gt; case let bin as (Expr, Expr) -&gt;Expr: // handles .Apply and .Tuple<br>&gt;&gt; &gt; return bin(.Literal(42), .Literal(42))<br>&gt;&gt; &gt; // all cases are covered<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Support for generic enums.<br>&gt;&gt; &gt; -<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; CaseEnumerable could be conditionally supported depending on the<br>&gt;&gt; &gt; generic argument(s). A great example would be Optional:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable<br>&gt;&gt; &gt; where Wrapped: CaseEnumerable {}<br>&gt;&gt; &gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/0df5cb7e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
