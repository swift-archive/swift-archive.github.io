<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 13, 2016 at 09:00:00am</p></header><div class="content"><p>on Sat Feb 13 2016, Taras Zakharko &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On 12 Feb 2016, at 17:29, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Feb 12 2016, Taras Zakharko<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; IMO, using the converb/gerund/participle (whatever you call it) here<br>&gt;&gt;&gt; is a terrible idea (I say that as someone with a PhD in linguistics :)<br>&gt;&gt;&gt; ). It appears very counter-intuitive to me that ‘union’ should be the<br>&gt;&gt;&gt; in-place version, as it goes agains any convention I am aware of.  I’d<br>&gt;&gt;&gt; rather just keep InPlace here or, as Greg suggests, rely on compiler<br>&gt;&gt;&gt; optimisations.<br>&gt;&gt; <br>&gt;&gt; FWIW, I think it&#39;s almost impossible for compler optimizations to help<br>&gt;&gt; with arbitrarily complex LHS expressions such as a[b].c.d[e] =<br>&gt;&gt; a[b].c.d[e].union(f)<br>&gt;&gt; <br>&gt;&gt; ...and then you have the readability problem of repeated code.<br>&gt;<br>&gt; I don’t think that the problem is that complicated: if the compiler<br>&gt; detects that the invoked member has a in-place version, it just needs<br>&gt; to check that the expression ASTs on the left and right side are<br>&gt; identical (and that no getters have side effects). <br></p><p>The devil is in the parentheses, brother.<br></p><p>&gt; In the end, its just a special case of CSE, but its also true that<br>&gt; Swift does not seem to do anything like this right now.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Feb 2016, at 08:43, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could get behind that. At the call site there would be little<br>&gt;&gt;&gt;&gt; visible difference between this and the alternative where functions<br>&gt;&gt;&gt;&gt; beginning with &quot;=&quot; are allowed. One I can think of would be that the<br>&gt;&gt;&gt;&gt; `.=` operator would require some instances (of classes that have<br>&gt;&gt;&gt;&gt; properties that are reference types) declared with `let` to be<br>&gt;&gt;&gt;&gt; declared with `var`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Feb 12, 2016 at 1:26 AM, Greg Parker via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func ＝union(other: Self) { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt;&gt;&gt;&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt;&gt;&gt;&gt;&gt; fixed by tooling.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago<br>&gt;&gt;&gt;&gt;&gt; for a .= operator. Here&#39;s what I wrote then (with a handful of<br>&gt;&gt;&gt;&gt;&gt; syntax updates).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I suggest eliminating &quot;…InPlace&quot; as follows:<br>&gt;&gt;&gt;&gt;&gt; 1. Use the same method name for value-creating methods and in-place<br>&gt;&gt;&gt;&gt;&gt; mutation methods. No &quot;…InPlace&quot; suffix.<br>&gt;&gt;&gt;&gt;&gt; 2. Write all client code syntactically as if the in-place<br>&gt;&gt;&gt;&gt;&gt; implementations did not exist. Rely on the compiler to choose the<br>&gt;&gt;&gt;&gt;&gt; in-place implementation when possible.<br>&gt;&gt;&gt;&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the<br>&gt;&gt;&gt;&gt;&gt; &quot;expr = expr.method()&quot; case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Use the same method name for value-creating methods and in-place mutation methods<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct String {<br>&gt;&gt;&gt;&gt;&gt;  func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>&gt;&gt;&gt;&gt;&gt;  @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct String2 {<br>&gt;&gt;&gt;&gt;&gt;  @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The value-creating implementation is optional. If it is not<br>&gt;&gt;&gt;&gt;&gt; present, the compiler will generate a default value-creating<br>&gt;&gt;&gt;&gt;&gt; implementation that copies the object and calls the in-place<br>&gt;&gt;&gt;&gt;&gt; implementation. There is no default in-place implementation; if<br>&gt;&gt;&gt;&gt;&gt; there is no in-place implementation of a value-creating method then<br>&gt;&gt;&gt;&gt;&gt; the compiler simply fails to optimize to it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Write all client code syntactically as if the in-place implementations did not exist.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Instead of this<br>&gt;&gt;&gt;&gt;&gt;  s.upperInPlace()<br>&gt;&gt;&gt;&gt;&gt; write this<br>&gt;&gt;&gt;&gt;&gt;  s = s.upper()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The compiler optimizer can choose the in-place upper() implementation if it is present.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Instead of this<br>&gt;&gt;&gt;&gt;&gt;  t = s.upper().trim().truncate(toLength: 5) // oops, there&#39;s an<br>&gt;&gt;&gt;&gt;&gt; extra copy here<br>&gt;&gt;&gt;&gt;&gt;  t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>&gt;&gt;&gt;&gt;&gt; write this<br>&gt;&gt;&gt;&gt;&gt;  t = s.upper().trim().truncate(toLength: 5)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The developer can chain methods together and let the compiler<br>&gt;&gt;&gt;&gt;&gt; optimizer choose which in-place implementations to use. In this<br>&gt;&gt;&gt;&gt;&gt; case, if all in-place implementations are available, it should call<br>&gt;&gt;&gt;&gt;&gt; value-creating upper() followed by in-place trim() and in-place<br>&gt;&gt;&gt;&gt;&gt; truncate(toLength:).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. Add operator .= for in-place modification.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Operator .= is analogous to arithmetic operators like += . It is<br>&gt;&gt;&gt;&gt;&gt; shorthand for `expr = expr.stuff` for the case where `expr` is<br>&gt;&gt;&gt;&gt;&gt; inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if<br>&gt;&gt;&gt;&gt;&gt; Swift&#39;s optimization rules otherwise would allow it or require it<br>&gt;&gt;&gt;&gt;&gt; for the longhand case.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; s .= upper()<br>&gt;&gt;&gt;&gt;&gt; // like s = s.upper()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; p .= next<br>&gt;&gt;&gt;&gt;&gt; // like p = p.next<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt;&gt;&gt;&gt;&gt; // like some().long().expression =<br>&gt;&gt;&gt;&gt;&gt; some().long().expression.upper().trim().truncateToLength(5)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As seen in this last example, one advantage of this syntax is that<br>&gt;&gt;&gt;&gt;&gt; it allows chained mutations but cleanly separates the &quot;lookup&quot;<br>&gt;&gt;&gt;&gt;&gt; calls from the &quot;mutate&quot; calls. This is an improvement upon language<br>&gt;&gt;&gt;&gt;&gt; and API designs with mutating methods where the property being<br>&gt;&gt;&gt;&gt;&gt; changed is buried in the middle of the expression somewhere.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt;&gt;&gt;&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt;&gt;&gt;&gt;&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One consequence of these changes is that compiler optimizations to<br>&gt;&gt;&gt;&gt;&gt; take advantage of in-place implementation are much more important<br>&gt;&gt;&gt;&gt;&gt; for performance, because there isn&#39;t any syntax to call the<br>&gt;&gt;&gt;&gt;&gt; in-place implementation directly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
