<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through May 23. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 17, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; The review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through May 23. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br></p><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I&#39;m in favor, with one small concern:<br></p><p>&gt; Then, the protocol author is responsible for providing a generic global trampoline operator that is constrained by the protocol type and delegates to the static operator on that type:<br>&gt; <br>&gt; 	func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; 	  return T.==(lhs, rhs)<br>&gt; 	}<br></p><p>This trampoline operator, and all of the others in the proposal, appears to be 100% pure boilerplate. Could Swift generate them for us?<br></p><p>(Specifically, I&#39;m suggesting that if protocol P defines a `static func $!(args) -&gt; ret`, Swift should automatically generate a global `func #! &lt;T: P&gt; (args) -&gt; ret`, substituting `T` for any `Self`s among the parameters or return values.)<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Speeding up type inference is a Good Thing™.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>It *is* a little odd and hacky, particularly on the class side. I&#39;m not saying it&#39;s any worse than the status quo, but it doesn&#39;t feel like a full solution yet.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Short of Perl 6&#39;s solution, which is to introduce full multimethods into the language, I don&#39;t think I&#39;ve seen much that&#39;s better. (Other than the trampoline boilerplate, that is.)<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>May 18, 2016 at 12:00:00am</p></header><div class="content"><p>On 5/18/2016 12:03 AM, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; I&#39;m in favor, with one small concern:<br>&gt;<br>&gt;&gt; Then, the protocol author is responsible for providing a generic global trampoline operator that is constrained by the protocol type and delegates to the static operator on that type:<br>&gt;&gt;<br>&gt;&gt; 	func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt; 	  return T.==(lhs, rhs)<br>&gt;&gt; 	}<br>&gt; This trampoline operator, and all of the others in the proposal, appears to be 100% pure boilerplate. Could Swift generate them for us?<br>&gt;<br>&gt; (Specifically, I&#39;m suggesting that if protocol P defines a `static func $!(args) -&gt; ret`, Swift should automatically generate a global `func #! &lt;T: P&gt; (args) -&gt; ret`, substituting `T` for any `Self`s among the parameters or return values.)<br>&gt;<br>I was just about to respond to this proposal with the same feedback.<br>This code is purely mechanical and could be written wrong by a protocol<br>author.<br></p><p>Additionally, I am generally +1 for the same reasons as Brent, but I<br>have another caveat as well:<br></p><p>Defining prefix and postfix functions looks like this in the proposal:<br></p><p>  static prefix func ++(value: inout Self) -&gt; Self<br>  static postfix func ++(value: inout Self) -&gt; Self<br></p><p>yet the proposal suggests calling them this way from these boilerplate<br>methods:<br></p><p>prefix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>  return T.++(prefix: &amp;value)<br>  }<br>postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>    return T.++(postfix: &amp;value)<br>  }<br></p><p>Having this mismatch between argument labels at the declaration and call<br>site feels strange to me, and it is inconsistent with how function<br>argument labels work everywhere else in the language. What if the prefix<br>and postfix keywords also required the functions to be disambiguated<br>somehow in a way that the current method naming scheme allows?<br></p><p>  static prefix func ++(prefix value: inout Self) -&gt; Self<br>  static postfix func ++(postfix value: inout Self) -&gt; Self<br></p><p>This will give a clear signal for callers to know how they should call<br>the function by looking at the declaration, instead of relying on a<br>weird edge case for these kind of operator functions. `prefix` and<br>`postfix` don&#39;t necessarily need to be the actual names of the arguments<br>that are forced by the compiler, but they should be required to be<br>different in the same way that you can&#39;t re-declare the same identical<br>function signature any other time (aside from current global<br>prefix/postfix functions of course).<br></p><p>- Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 17, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Additionally, I am generally +1 for the same reasons as Brent, but I<br>&gt; have another caveat as well:<br>&gt; <br>&gt; Defining prefix and postfix functions looks like this in the proposal:<br>&gt; <br>&gt;  static prefix func ++(value: inout Self) -&gt; Self<br>&gt;  static postfix func ++(value: inout Self) -&gt; Self<br>&gt; <br>&gt; yet the proposal suggests calling them this way from these boilerplate<br>&gt; methods:<br>&gt; <br>&gt; prefix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt;  return T.++(prefix: &amp;value)<br>&gt;  }<br>&gt; postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt;    return T.++(postfix: &amp;value)<br>&gt;  }<br></p><p>I actually found this bizarre too, but forgot to mention it. My suggested solution runs in the other direction: We should require that *all* unary operator declarations and references use `prefix` or `postfix` as a parameter label. Thus, the trampoline operators themselves would be written as:<br></p><p>	func ++ &lt;T: SomeProtocol&gt;(prefix value: inout T) -&gt; T {<br>	    return T.++(prefix: &amp;value)<br>	}<br>	<br>	func ++ &lt;T: SomeProtocol&gt;(postfix value: inout T) -&gt; T {<br>	    return T.++(postfix: &amp;value)<br>	}<br></p><p>Not would be written as:<br></p><p>	func ! &lt;B: BooleanType&gt;(prefix value: B) -&gt; Bool<br></p><p>While force-unwrap (if we had inout return values) would be written:<br></p><p>	func ! &lt;T&gt;(postfix value: inout Optional&lt;T&gt;) -&gt; inout T<br></p><p>`prefix` and `postfix` would be eliminated from the language as declaration modifiers, except when declaring custom operators (which is already the Land Of Ad-Hoc Syntax).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 17, 2016 at 10:00:00pm</p></header><div class="content"><p>I too have a little trouble with the suggested trampoline syntax:<br></p><p>&gt;  static prefix func ++(value: inout Self) -&gt; Self<br>&gt;  static postfix func ++(value: inout Self) -&gt; Self<br></p><p>I agree with Brent that the most appropriate way to write the trampoline<br>itself would be something more like:<br></p><p>```<br>static func ++ (prefix value: inout Self) -&gt; Self<br>```<br></p><p>No particular need to eliminate declaration modifiers altogether quite yet<br>for the non-trampoline operators. The reasoning is this: a &quot;prefix func&quot; or<br>a &quot;postfix func&quot; would be used at the call site by actually prefixing or<br>postfixing the value. By contrast, the trampoline functions are called like<br>any other static member -- i.e. `T.++(prefix: foo)` -- and thus the<br>function itself is not really a &quot;prefix func&quot; or a &quot;postfix func&quot;, just a<br>func with a parameter label.<br></p><p><br>On Tue, May 17, 2016 at 9:57 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Additionally, I am generally +1 for the same reasons as Brent, but I<br>&gt; &gt; have another caveat as well:<br>&gt; &gt;<br>&gt; &gt; Defining prefix and postfix functions looks like this in the proposal:<br>&gt; &gt;<br>&gt; &gt;  static prefix func ++(value: inout Self) -&gt; Self<br>&gt; &gt;  static postfix func ++(value: inout Self) -&gt; Self<br>&gt; &gt;<br>&gt; &gt; yet the proposal suggests calling them this way from these boilerplate<br>&gt; &gt; methods:<br>&gt; &gt;<br>&gt; &gt; prefix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt; &gt;  return T.++(prefix: &amp;value)<br>&gt; &gt;  }<br>&gt; &gt; postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt; &gt;    return T.++(postfix: &amp;value)<br>&gt; &gt;  }<br>&gt;<br>&gt; I actually found this bizarre too, but forgot to mention it. My suggested<br>&gt; solution runs in the other direction: We should require that *all* unary<br>&gt; operator declarations and references use `prefix` or `postfix` as a<br>&gt; parameter label. Thus, the trampoline operators themselves would be written<br>&gt; as:<br>&gt;<br>&gt;         func ++ &lt;T: SomeProtocol&gt;(prefix value: inout T) -&gt; T {<br>&gt;             return T.++(prefix: &amp;value)<br>&gt;         }<br>&gt;<br>&gt;         func ++ &lt;T: SomeProtocol&gt;(postfix value: inout T) -&gt; T {<br>&gt;             return T.++(postfix: &amp;value)<br>&gt;         }<br>&gt;<br>&gt; Not would be written as:<br>&gt;<br>&gt;         func ! &lt;B: BooleanType&gt;(prefix value: B) -&gt; Bool<br>&gt;<br>&gt; While force-unwrap (if we had inout return values) would be written:<br>&gt;<br>&gt;         func ! &lt;T&gt;(postfix value: inout Optional&lt;T&gt;) -&gt; inout T<br>&gt;<br>&gt; `prefix` and `postfix` would be eliminated from the language as<br>&gt; declaration modifiers, except when declaring custom operators (which is<br>&gt; already the Land Of Ad-Hoc Syntax).<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/0c7de6d0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>May 18, 2016 at 01:00:00am</p></header><div class="content"><p>I do like this to a point, but it ascribes special compiler behavior to specific argument labels which feels odd. If someone defined another operator function with a completely different argument label, would it just be ignored? If a developer makes a typo, that could be a subtle bug that may be confusing. Or should the compiler only allow those two argument labels for unary operator functions? That feels strange since it&#39;s not a restriction present anywhere else, and it starts to feel like the labels have a dual purpose that also falls into the realm of keywords.<br></p><p>Either option doesn&#39;t quite sit right with me, even though the lack of duplication that this solution has does look better, admittedly. <br></p><p>--<br>Kevin Lundberg<br></p><p>On May 18, 2016, at 12:57 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Additionally, I am generally +1 for the same reasons as Brent, but I<br>&gt;&gt; have another caveat as well:<br>&gt;&gt; <br>&gt;&gt; Defining prefix and postfix functions looks like this in the proposal:<br>&gt;&gt; <br>&gt;&gt; static prefix func ++(value: inout Self) -&gt; Self<br>&gt;&gt; static postfix func ++(value: inout Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; yet the proposal suggests calling them this way from these boilerplate<br>&gt;&gt; methods:<br>&gt;&gt; <br>&gt;&gt; prefix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt;&gt; return T.++(prefix: &amp;value)<br>&gt;&gt; }<br>&gt;&gt; postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt;&gt;   return T.++(postfix: &amp;value)<br>&gt;&gt; }<br>&gt; <br>&gt; I actually found this bizarre too, but forgot to mention it. My suggested solution runs in the other direction: We should require that *all* unary operator declarations and references use `prefix` or `postfix` as a parameter label. Thus, the trampoline operators themselves would be written as:<br>&gt; <br>&gt;    func ++ &lt;T: SomeProtocol&gt;(prefix value: inout T) -&gt; T {<br>&gt;        return T.++(prefix: &amp;value)<br>&gt;    }<br>&gt;    <br>&gt;    func ++ &lt;T: SomeProtocol&gt;(postfix value: inout T) -&gt; T {<br>&gt;        return T.++(postfix: &amp;value)<br>&gt;    }<br>&gt; <br>&gt; Not would be written as:<br>&gt; <br>&gt;    func ! &lt;B: BooleanType&gt;(prefix value: B) -&gt; Bool<br>&gt; <br>&gt; While force-unwrap (if we had inout return values) would be written:<br>&gt; <br>&gt;    func ! &lt;T&gt;(postfix value: inout Optional&lt;T&gt;) -&gt; inout T<br>&gt; <br>&gt; `prefix` and `postfix` would be eliminated from the language as declaration modifiers, except when declaring custom operators (which is already the Land Of Ad-Hoc Syntax).<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 17, 2016 at 11:00:00pm</p></header><div class="content"><p>I think we don&#39;t need to invoke special compiler behavior. Namely, since<br>the trampoline is manually generated, do this:<br></p><p>Static:<br>```<br>static func ++(anyLabelYouWant value: inout Self) -&gt; Self<br>```<br></p><p>Later:<br>```<br>postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>  return T.++(anyLabelYouWant: &amp;value)<br>}<br>```<br></p><p>On Tue, May 17, 2016 at 10:57 PM, Kevin Lundberg via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I do like this to a point, but it ascribes special compiler behavior to<br>&gt; specific argument labels which feels odd. If someone defined another<br>&gt; operator function with a completely different argument label, would it just<br>&gt; be ignored? If a developer makes a typo, that could be a subtle bug that<br>&gt; may be confusing. Or should the compiler only allow those two argument<br>&gt; labels for unary operator functions? That feels strange since it&#39;s not a<br>&gt; restriction present anywhere else, and it starts to feel like the labels<br>&gt; have a dual purpose that also falls into the realm of keywords.<br>&gt;<br>&gt; Either option doesn&#39;t quite sit right with me, even though the lack of<br>&gt; duplication that this solution has does look better, admittedly.<br>&gt;<br>&gt; --<br>&gt; Kevin Lundberg<br>&gt;<br>&gt; On May 18, 2016, at 12:57 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; Additionally, I am generally +1 for the same reasons as Brent, but I<br>&gt; &gt;&gt; have another caveat as well:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Defining prefix and postfix functions looks like this in the proposal:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; static prefix func ++(value: inout Self) -&gt; Self<br>&gt; &gt;&gt; static postfix func ++(value: inout Self) -&gt; Self<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; yet the proposal suggests calling them this way from these boilerplate<br>&gt; &gt;&gt; methods:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; prefix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt; &gt;&gt; return T.++(prefix: &amp;value)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt; &gt;&gt;   return T.++(postfix: &amp;value)<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; I actually found this bizarre too, but forgot to mention it. My<br>&gt; suggested solution runs in the other direction: We should require that<br>&gt; *all* unary operator declarations and references use `prefix` or `postfix`<br>&gt; as a parameter label. Thus, the trampoline operators themselves would be<br>&gt; written as:<br>&gt; &gt;<br>&gt; &gt;    func ++ &lt;T: SomeProtocol&gt;(prefix value: inout T) -&gt; T {<br>&gt; &gt;        return T.++(prefix: &amp;value)<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    func ++ &lt;T: SomeProtocol&gt;(postfix value: inout T) -&gt; T {<br>&gt; &gt;        return T.++(postfix: &amp;value)<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; Not would be written as:<br>&gt; &gt;<br>&gt; &gt;    func ! &lt;B: BooleanType&gt;(prefix value: B) -&gt; Bool<br>&gt; &gt;<br>&gt; &gt; While force-unwrap (if we had inout return values) would be written:<br>&gt; &gt;<br>&gt; &gt;    func ! &lt;T&gt;(postfix value: inout Optional&lt;T&gt;) -&gt; inout T<br>&gt; &gt;<br>&gt; &gt; `prefix` and `postfix` would be eliminated from the language as<br>&gt; declaration modifiers, except when declaring custom operators (which is<br>&gt; already the Land Of Ad-Hoc Syntax).<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/d09f261a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 18, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Or should the compiler only allow those two argument labels for unary operator functions? That feels strange since it&#39;s not a restriction present anywhere else, and it starts to feel like the labels have a dual purpose that also falls into the realm of keywords.<br></p><p>A similar restriction exists on operators currently. Today, Swift does not allow keywords on operator parameters:<br></p><p> 23&gt; prefix func !&lt;T&gt;(prefix value: T) {}<br>repl.swift:23:18: error: operator cannot have keyword arguments<br>prefix func !&lt;T&gt;(prefix value: T) {}<br>                 ^~~~~~~<br></p><p>What I&#39;m suggesting is that, on unary operators, Swift require either the keyword &quot;prefix&quot; or &quot;postfix&quot; on the argument, and use that to differentiate between prefix and postfix operators. No other keyword would be used or permitted, and no keyword would be used or permitted on infix operators&#39; arguments.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 12:10 AM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Or should the compiler only allow those two argument labels for unary<br>&gt; operator functions? That feels strange since it&#39;s not a restriction present<br>&gt; anywhere else, and it starts to feel like the labels have a dual purpose<br>&gt; that also falls into the realm of keywords.<br>&gt;<br>&gt; A similar restriction exists on operators currently. Today, Swift does not<br>&gt; allow keywords on operator parameters:<br>&gt;<br>&gt;  23&gt; prefix func !&lt;T&gt;(prefix value: T) {}<br>&gt; repl.swift:23:18: error: operator cannot have keyword arguments<br>&gt; prefix func !&lt;T&gt;(prefix value: T) {}<br>&gt;                  ^~~~~~~<br>&gt;<br>&gt; What I&#39;m suggesting is that, on unary operators, Swift require either the<br>&gt; keyword &quot;prefix&quot; or &quot;postfix&quot; on the argument, and use that to<br>&gt; differentiate between prefix and postfix operators. No other keyword would<br>&gt; be used or permitted, and no keyword would be used or permitted on infix<br>&gt; operators&#39; arguments.<br>&gt;<br></p><p>I would be supportive of this. The syntax for static prefix/postfix<br>operators in that proposal was a matter of some earlier debate (in e-mail<br>threads, and a couple comments in the pull request &lt;<br>https://github.com/apple/swift-evolution/pull/283&gt;) and was one of the<br>parts of the proposal I thought felt less natural.<br></p><p>I think we should definitely have a solution that avoids duplication (so<br>not having a `prefix` as a leading keyword and as an argument label). Since<br>prefix/postfix operators are required to only have one argument, and those<br>arguments must already not have labels, introducing prefix/postfix as<br>labels instead of keywords to distinguish them seems natural.<br></p><p>The other major benefit (which I mention in a PR comment above) is that, if<br>you have a prefix and postfix operator with the same name, there is no way<br>currently to get function references to both of them (for passing to other<br>algorithms), because there are no labels used to distinguish them. For<br>example, if you use `++` as a function reference (ignoring the fact that<br>it&#39;s deprecated), the REPL takes the last one that was defined. (I didn&#39;t<br>test what the compiler does, but presumably it&#39;s arbitrary depending on the<br>ordering of the data structures used to store those operators.) Using<br>argument labels would solve this problem as well.<br></p><p><br></p><p><br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/38d469e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On 5/18/2016 10:21 AM, Tony Allevato wrote:<br>&gt; On Wed, May 18, 2016 at 12:10 AM Brent Royal-Gordon via<br>&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     ...<br>&gt;<br>&gt;     What I&#39;m suggesting is that, on unary operators, Swift require<br>&gt;     either the keyword &quot;prefix&quot; or &quot;postfix&quot; on the argument, and use<br>&gt;     that to differentiate between prefix and postfix operators. No<br>&gt;     other keyword would be used or permitted, and no keyword would be<br>&gt;     used or permitted on infix operators&#39; arguments.<br>&gt;<br>&gt;<br>&gt; I would be supportive of this. The syntax for static prefix/postfix<br>&gt; operators in that proposal was a matter of some earlier debate (in<br>&gt; e-mail threads, and a couple comments in the pull request<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/283&gt;) and was one of<br>&gt; the parts of the proposal I thought felt less natural.<br>&gt;<br>&gt; I think we should definitely have a solution that avoids duplication<br>&gt; (so not having a `prefix` as a leading keyword and as an argument<br>&gt; label). Since prefix/postfix operators are required to only have one<br>&gt; argument, and those arguments must already not have labels,<br>&gt; introducing prefix/postfix as labels instead of keywords to<br>&gt; distinguish them seems natural.<br>&gt;<br>&gt; The other major benefit (which I mention in a PR comment above) is<br>&gt; that, if you have a prefix and postfix operator with the same name,<br>&gt; there is no way currently to get function references to both of them<br>&gt; (for passing to other algorithms), because there are no labels used to<br>&gt; distinguish them. For example, if you use `++` as a function reference<br>&gt; (ignoring the fact that it&#39;s deprecated), the REPL takes the last one<br>&gt; that was defined. (I didn&#39;t test what the compiler does, but<br>&gt; presumably it&#39;s arbitrary depending on the ordering of the data<br>&gt; structures used to store those operators.) Using argument labels would<br>&gt; solve this problem as well.<br></p><p>These are good arguments. After thinking on it more and reading these<br>then I do support this change over my proposed change, especially given<br>that there is already precedent to control the form of operator function<br>definitions in this way that I was unaware of.<br></p><p>As far as binary operators go, would they need to have a mandatory _ in<br>front of each argument to satisfy what you propose, Brent? That is:<br></p><p>static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br></p><p>...since by default lhs and rhs would be externally visible argument<br>labels, or is it better to not impose any such restriction and keep<br>things the way they are? The compiler could also mandate that those<br>names be lhs and rhs to keep consistency with prefix and postfix, but<br>that seems like it might not be palatable, and would probably need to be<br>bikeshedded a bunch at the very least.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/6e5c3d78/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, May 17, 2016 at 9:03 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p><br>&gt; I&#39;m in favor, with one small concern:<br>&gt;<br>&gt; &gt; Then, the protocol author is responsible for providing a generic global<br>&gt; trampoline operator that is constrained by the protocol type and delegates<br>&gt; to the static operator on that type:<br>&gt; &gt;<br>&gt; &gt;       func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;         return T.==(lhs, rhs)<br>&gt; &gt;       }<br>&gt;<br>&gt; This trampoline operator, and all of the others in the proposal, appears<br>&gt; to be 100% pure boilerplate. Could Swift generate them for us?<br>&gt;<br>(Specifically, I&#39;m suggesting that if protocol P defines a `static func<br>&gt; $!(args) -&gt; ret`, Swift should automatically generate a global `func #! &lt;T:<br>&gt; P&gt; (args) -&gt; ret`, substituting `T` for any `Self`s among the parameters or<br>&gt; return values.)<br>&gt;<br></p><p>That was actually part of the original write-up :)  You can see the removed<br>content from the diff here:<br>https://github.com/apple/swift-evolution/pull/283/commits/841514fbd7d11ce1ab6dad8ee3c6473d6c550789<br></p><p>The core team felt that auto-generating the trampolines was too ambitious<br>for the Swift 3 timeline but that the rest of the improvements should not<br>be held up by it. I definitely intend to propose auto-trampolines as a<br>natural follow-up proposal to this (assuming it&#39;s accepted) for Swift 3.x/4.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/f2bc0299/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Mostly an enthusiastic +1.  This really cleans up one aspect of Swift that seemed un-Swifty.<br></p><p>Like others, I would prefer to see the trampoline automatically generated.  This is not just a boilerplate issue.  Consider the following from the proposal:<br></p><p>&gt; This would only search the global namespace and find * &lt;T: FooProtocol&gt; as a match. The name lookup will not search for operators defined as type members, so the concrete implementation of Foo.* would be ignored; the trampoline operator would explicitly call it. The only way to reference a type member operator is to fully-qualify it with its type&#39;s name, and it may only be called using function-call syntax.<br></p><p>&gt; This implies that a user could implement a more specific overload of global * for a concrete type (such as one that takes (Foo, Foo) as its arguments), which would bypass the trampoline operator. While we would not recommend that a user do this, it&#39;s not necessarily compelling to forbid it either.<br>&gt; <br>The consequences of this allow for confusing ambiguity.  I can implement a type that conforms to two or more unrelated protocols that both have the same operator requirement.  This means there will be an ambiguity issue when top-level lookup sees multiple trampoline definitions for which my type is an equally good match.  <br></p><p>The only way to resolve the ambiguity is to manually define a top-level operator definition for my concrete type.  This has great potential to be confusing to users.  It also means that by retroactively conforming a type to a new protocol I can introduce ambiguity into code that used to work as expected, which would be even more confusing and frustrating.  The most unfortunate aspect of this is that we all know the trampolines *should* all have the same implementation that just calls through to the static / class operator method defined on the type itself.<br></p><p>This potential for ambiguity does not currently exist in Swift precisely because each type is required to define its own top-level operator implementation which is always going to be the best match during overload resolution.<br></p><p>If the compiler manages trampolines it can take responsibility for 1) ensuring that they all simply call through to the static implementation as expected and 2) provide trampolines for concrete types to resolve ambiguity when necessary.<br></p><p>Maybe these ambiguity issues are acceptable for a short time if we just can’t get automatic trampolines into Swift 3, but we should consider them carefully before moving ahead.<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  The current mechanism feels out of place in Swift.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much so.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Most languages I know of the allow operator overloading do so in a similar way.  Some of them use an `adding` style naming convention for operator methods which I find very distasteful.  I’m really happy Swift is not going to take that path.  <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I followed the initial discussion and gave the specific details of the proposal a close look.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/1cc1ed12/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through May 23. The proposal is available here:<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br></p><p>Allow for consistent code when implementing operators. I&#39;d go a bit<br>further and say any operator functions should be declared like this<br>but this seems to be the case for another proposal.<br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes. In C# operator overloading is done exactly like this (but also<br>only like this).<br></p><p>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Mixed; there are very good ideas here but combined in IMHO some questionably-strict ways. I understand that starting small and extending later is preferable, and I understand the Swift 3 situation.<br></p><p>In favor of these: <br>- allowing static methods to have “operator names”<br>- deprecating operator requirements in protocols<br>- providing default operator definitions as trampolines to the static methods<br></p><p>It’s really not clear to me if this is anything more than just:<br></p><p>- adding the ability to give (static/class) methods operator names<br>- removing the ability for protocols to declare operators<br>- make all operator implementations “explicit&quot;…<br>- ...but providing “protocol operators” generically (e.g. via suitable “trampolines”)<br></p><p>…if that’s all there is to this, I’m ok with it for now, but have a suggestion:<br></p><p>I’d *prefer* there be an explicit annotation, e.g. to straw-man it a bit, something like one of these:<br></p><p>  @trampolined static func +(lhs: Self, rhs: Self) -&gt; Self<br>  @trampolined(operator) static func +(lhs: Self, rhs: Self) -&gt; Self<br></p><p>…which for now would just produce a compiler warning if no corresponding operator function is defined, but could someday be used to trigger trampoline synthesis.<br></p><p>The reason I request explicit syntax for this is b/c it seems *highly* likely that a subsequent enhancement will be to allow a similar mechanism to specify functions like `abs` and `sin` should be similarly trampolined (in their case into free functions); it’d be nice to have a common mechanism for them now, even if their implementation is to be deferred. <br></p><p>That said, it’d *concern me* if this proposal somehow planned to enforce that “operators” *always* call through to the operator-named function; it ought to be possible to e.g. define operators like so:<br></p><p>  protocol AngularCoordinateProtocol {<br></p><p>    associatedtype Rotation: RotationProtocol<br></p><p>    static func rotated(angle angle: Self, by rotation: Self.Rotation) -&gt; Self<br></p><p>  }<br></p><p>  func +&lt;A:AngularCoordinateProtocol&gt;(lhs: A, rhs: A.Rotation) -&gt; A { return A.rotated(angle: lhs, by: rhs) }<br>  func -&lt;A:AngularCoordinateProtocol&gt;(lhs: A, rhs: A.Rotation) -&gt; A { return A.rotated(angle: lhs, by: -rhs) }<br></p><p>…and it seems like this proposal wouldn’t preclude that, but I’m not 100% I understand it on that point. <br></p><p>Also, I can’t say I’m a fan of having the prefix/postfix handled by argument labels.<br></p><p>How hard would it be to e.g. simply allow something like this:<br></p><p>  func ==&lt;T:Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>    return lhs T.== rhs<br>  }<br></p><p>…instead of the `T.==(lhs,rhs)` syntax?<br></p><p>&gt; On May 17, 2016, at 10:33 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through May 23. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 18:07, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How hard would it be to e.g. simply allow something like this:<br>&gt; <br>&gt;  func ==&lt;T:Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;    return lhs T.== rhs<br>&gt;  }<br>&gt; <br>&gt; …instead of the `T.==(lhs,rhs)` syntax?<br></p><p>Yeah, I&#39;ve been meaning to suggest that. And &#39;T.++(x)&#39; and &#39;(x)T.++&#39; for prefix and postfix, respectfully.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016 at 9:20 PM David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 18, 2016, at 18:07, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; How hard would it be to e.g. simply allow something like this:<br>&gt; &gt;<br>&gt; &gt;  func ==&lt;T:Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;    return lhs T.== rhs<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; …instead of the `T.==(lhs,rhs)` syntax?<br>&gt;<br>&gt; Yeah, I&#39;ve been meaning to suggest that. And &#39;T.++(x)&#39; and &#39;(x)T.++&#39; for<br>&gt; prefix and postfix, respectfully.<br>&gt;<br></p><p>The &quot;fully-qualified operator&quot; syntax was one that was discussed in some of<br>the original e-mail threads. It was part an earlier draft of the proposal,<br>but I changed it to the function call syntax because<br></p><p>- visually, it&#39;s a bit tricky to parse with the eyes<br>- I wasn&#39;t sure whether it would pose similar problems for the compiler to<br>parse<br>- It doesn&#39;t solve the (admittedly edge case) issue of not being able to<br>refer distinctly to prefix/postfix operators that have the same name as a<br>first-class function without wrapping the invocation in a closure<br>- Chris Lattner recommended changing it to the function call syntax after a<br>core team discussion before the proposal PR was accepted, so it&#39;s possible<br>they have more insight into the parsing/implementation issues?<br></p><p><br></p><p>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/00aa9498/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 24, 2016, at 11:13 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, May 23, 2016 at 9:20 PM David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On May 18, 2016, at 18:07, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; How hard would it be to e.g. simply allow something like this:<br>&gt; &gt;<br>&gt; &gt;  func ==&lt;T:Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;    return lhs T.== rhs<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; …instead of the `T.==(lhs,rhs)` syntax?<br>&gt; <br>&gt; Yeah, I&#39;ve been meaning to suggest that. And &#39;T.++(x)&#39; and &#39;(x)T.++&#39; for prefix and postfix, respectfully.<br>&gt; <br>&gt; The &quot;fully-qualified operator&quot; syntax was one that was discussed in some of the original e-mail threads. It was part an earlier draft of the proposal, but I changed it to the function call syntax because<br>&gt; <br>&gt; - visually, it&#39;s a bit tricky to parse with the eyes<br></p><p>I agree, but IMHO I would anticipate that each time I needed to use a pre/post-fix method, I’d have to go to the reference and double-check whether:<br></p><p>  T.++(prefix: foo) <br></p><p>…means  “`foo` is prefixed-to `++`” or “the prefix `++` is prefixed-before `foo`”, and vice-versa for `postfix`; the point of confusion is that *usually* the argument label describe the argument, not the “function position” as it were. <br></p><p>Not likely to be a huge problem but likely to be confusing on the rare occasions it’s actually necessary to pick the right one.<br></p><p>Something like `prefixedTo:` and `postfixedTo:` would be more self-explanatory but seem clunky; perhaps a better formulation is possible here?<br></p><p>&gt; - I wasn&#39;t sure whether it would pose similar problems for the compiler to parse<br>&gt; - It doesn&#39;t solve the (admittedly edge case) issue of not being able to refer distinctly to prefix/postfix operators that have the same name as a first-class function without wrapping the invocation in a closure<br></p><p>It’s definitely an edge case but in some ways it just illustrates the tradeoff being made under this proposal. For this *specific* use case the following are IMHO increasingly self-explanatory:<br></p><p>- `foo.map(T.++)`<br>- `foo.map(T.++(prefix:))`<br>- `foo.map(T.incrementThenReturn(_:))`<br></p><p>…with the last approach being clearer in this one scenario, but still having all the other drawbacks that motivated to this proposal. <br></p><p>I can’t think of a natural scenario where this might come up; maybe something with `!` but even there I can’t think of one.<br></p><p>&gt; - Chris Lattner recommended changing it to the function call syntax after a core team discussion before the proposal PR was accepted, so it&#39;s possible they have more insight into the parsing/implementation issues?<br></p><p>That seems likely and reasonable.<br></p><p>After reflecting on it the main gripe I’d have is I don’t think the `prefix:/postfix:` labels do an ideal job of their roles in this proposal, but there’s probably a better approach to be found within the confines of “normal function” syntax.<br></p><p>&gt; <br>&gt;  <br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/a7530386/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;] <br></p><p>Hi, Tony. Thanks for working on this. I have to say I’m incredibly concerned with this direction, for two main reasons. I’ll try to break them down here. (Sorry for squeaking in at the end of the review period!)<br></p><p>Overrides<br></p><p>People up until now have been fairly unhappy with how operators are statically dispatched and can’t be overridden. We went all the way towards providing == that automatically calls isEqual(_:) on NSObject, but then you provide == for your subclass and it never gets called…no, wait, it does get called when you do a simple test, but not from the actual code that has NSObject as a static type.<br></p><p>This proposal stays in that space: the proposed “trampoline” operator will dispatch based on the static type of the objects, not the dynamic type. Why? Consider using == on an NSURL and an NSString, both statically typed as NSObject. Given the definition of the trampoline from the proposal<br></p><p>func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>  return T.==(lhs, rhs)<br>}<br></p><p>T can’t possibly be anything but NSObject. (Neither NSURL nor NSString matches the types of both ‘lhs’ and ‘rhs’.) This isn’t a regression from the current model, as you say, but it does make the current model even more surprising, since normally you’d expect methods to be dynamically dispatched.<br></p><p>Here’s an alternate formation of the trampoline that’s a little better about this…<br></p><p>func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>  return lhs.dynamicType.==(lhs, rhs)<br>}<br></p><p>…but I’m still not convinced. (People are especially likely to get this wrong without the trampolines being synthesized.)<br></p><p>One more note: at one point Joe Groff was investigating the idea that conformances wouldn’t be inherited onto subclasses, which would mean no more implicit ‘required’ initializers. Instead, the compiler would perform most operations by upcasting to the base class, and then converting to the protocol type or calling the generic function. In this world, T would always be NSObject, never a subclass, and we’d have to come up with something else. I think this model is still worth investigating and I wouldn’t want to close off our options just for the sake of “cleaning house”.<br></p><p>It’s possible that there’s not actually a reason to override operators in practice, which would make pretty much all of these concerns go away. (== is special; imagine we had an operation for checking equality within types and one across type hierarchies and ignore it for now.) I think it’d be worth investigating where operators are overridden today, and not just in Swift, to make sure we cover those use cases too.<br></p><p>(Please forgive all of the Foundation type examples that may soon be value types. They’re convenient.)<br></p><p><br>Assignment Operators<br></p><p>A mutating requirement and a static method with an inout parameter mean different things for a conforming class: the former can only access the class’s properties, while the latter can replace the caller’s reference as well.<br></p><p>class Player { … }<br></p><p>extension Player {<br>  static func roulette(_ player: inout Player) {<br>    if randomValue() &gt; 0.1 {<br>      player.roundsSurvived += 1<br>    } else {<br>      // Replace this player…but not any other references to them!<br>      player = Player()<br>    }<br>  }<br></p><p>  /*mutating*/ func solitaire() {<br>    self.roundsSurvived += 1<br>    // Cannot replace ‘self’<br>    //self = Player()<br>  }<br>}<br></p><p>I’m not sure if one of these is obviously better than the other (more capable ↔︎ more footgun). I agree with Nicola&#39;s point about mutating methods looking better than static methods taking an inout parameter, but that probably shouldn’t be the ultimate deciding factor.<br></p><p><br>I know we want to improve type-checker performance, and reducing the number of overloads seems like a way to do that, but I’m not convinced it actually will in a significant way (e.g. “you can now use ten operators in a chain instead of seven” is not enough of a win). It still seems like there ought to be a lot of low-hanging fruit in that area that we could easily clear away, like “an overload containing a struct type will never match any input but that struct type”.<br></p><p>I personally really want to move operators into types, but I want to do it by doing member lookup on the type, and fall back to global operators only if something can’t be found there. That approach<br></p><p>- also has potential to improve type-checker performance<br>- also removes operators from the global namespace<br>- also removes the need for “override points” (implementation methods like NSObject.isEqual(_:) and FloatingPoint.isLessThan(_:))<br></p><p>It does privilege the left-hand side of a binary operator, but I think that’s acceptable for the operators we’ve seen in practice. (Of course we would need real data to back that up.)<br></p><p><br>I think that about sums up my concerns and my interest in an alternate proposal. Again, I’m sorry for coming to this so late and for skimming the latest discussion on it; I’m sure “my” proposal has already come up, and I know it has its own flaws. I think I’m just not convinced that this is sufficiently better to be worth the churn and closing off of other potential avenues.<br></p><p>Best,<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/2764b1f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; It does privilege the left-hand side of a binary operator, but I think that’s acceptable for the operators we’ve seen in practice. (Of course we would need real data to back that up.)<br></p><p>I&#39;m not quite so convinced that privileging the left side isn&#39;t a big deal—think of all the mandatory type checks and other chicanery in an `-isEqual:` implementation—but I wonder if we can avoid privileging the left-hand side at all. For instance, suppose use of an infix operator &quot;looked&quot; like this:<br></p><p>	(lhs, rhs).==()<br></p><p>And method dispatch on a tuple was defined to use the dynamic types of all members of the tuple, with some kind of multimethod dispatch system. Then both operands participate equally in the dispatch, and a case with disparate subclasses will fall back to a superclass.<br></p><p>	// Note: This is, admittedly, an incredibly funky syntax.<br>	protocol Equatable {<br>		extension &lt;T: Equatable&gt;(T, T) {<br>			func ==() -&gt; Bool<br>		}<br>	}<br></p><p>	class Car: Equatable {<br>		let vin: String<br>	}<br>	extension (Car, Car) {<br>		func ==() -&gt; Bool {<br>			return self.0.vin == self.1.vin<br>		}<br>	}<br>	<br>	class Taxi: Car {<br>		var cabNumber: String<br>	}<br>	extension (Taxi, Taxi) {<br>		func ==() -&gt; Bool {<br>			return self.0.cabNumber == self.1.cabNumber<br>		}<br>	}<br>	<br>	class Uber: Car {<br>		var driverID: Int64<br>	}<br>	extension (Uber, Uber) {<br>		func ==() -&gt; Bool {<br>			return self.0.driverID == self.1.driverID<br>		}<br>	}<br></p><p>	// Note that I&#39;m erasing the subclasses here.<br>	let taxi: Automobile = Taxi()<br>	let uber: Automobile = Uber()<br></p><p>	taxi == taxi	// Compares by cabNumber<br>	uber == uber	// Compares by driverID<br>	taxi == uber	// Compares by vin<br></p><p>Multimethod dispatch at runtime is relatively slow, but it *would* give us the exact behavior we want.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016 at 9:58 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt; ]<br>&gt;<br>&gt; Hi, Tony. Thanks for working on this. I have to say I’m incredibly<br>&gt; concerned with this direction, for two main reasons. I’ll try to break them<br>&gt; down here. (Sorry for squeaking in at the end of the review period!)<br>&gt;<br></p><p>No worries, thanks for the detailed feedback! I&#39;ve tried to address your<br>concerns inline.<br></p><p><br>*Overrides*<br>&gt;<br>&gt; People up until now have been fairly unhappy with how operators are<br>&gt; statically dispatched and can’t be overridden. We went all the way towards<br>&gt; providing == that automatically calls isEqual(_:) on NSObject, but then you<br>&gt; provide == for your subclass and it never gets called…no, wait, it *does* get<br>&gt; called when you do a simple test, but not from the actual code that has<br>&gt; NSObject as a static type.<br>&gt;<br>&gt; This proposal stays in that space: the proposed “trampoline” operator will<br>&gt; dispatch based on the *static* type of the objects, not the dynamic type.<br>&gt; Why? Consider using == on an NSURL and an NSString, both statically typed<br>&gt; as NSObject. Given the definition of the trampoline from the proposal<br>&gt;<br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;<br>&gt;   return T.==(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; T can’t possibly be anything but NSObject. (Neither NSURL nor NSString<br>&gt; matches the types of both ‘lhs’ and ‘rhs’.) This isn’t a regression from<br>&gt; the current model, as you say, but it does make the current model *even<br>&gt; more surprising,* since normally you’d expect methods to be dynamically<br>&gt; dispatched.<br>&gt;<br></p><p>Setting Objective-C aside for a moment, is this example consistent with<br>Swift&#39;s design philosophies about type safety though? Swift doesn&#39;t even<br>let you compare types that seem reasonably compatible, like Float and<br>Double. Should we expect users to be able to compare completely distinct<br>types like NSURL and NSString without a little extra work?<br></p><p>If having `==` map to `NSObject.isEqual` is important for Objective-C<br>compatibility, then there&#39;s no reason the runtime can&#39;t provide the<br>following operator:<br></p><p>func ==(lhs: NSObject, rhs: NSObject) -&gt; Bool {<br>  return lhs.isEqual(rhs)<br>}<br></p><p>which should be more specific than the generic one and always get chosen in<br>the context you desire.<br></p><p>The situation is a little better when one of the types being compared has<br>the other type as a base, because then implementing the operators as class<br>methods instead of static methods does the right thing (with the only<br>caveat being you have to cast the arguments down to the correct type).<br></p><p><br>&gt; Here’s an alternate formation of the trampoline that’s a little better<br>&gt; about this…<br>&gt;<br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;<br>&gt;   return lhs.dynamicType.==(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; …but I’m still not convinced. (People are especially likely to get this<br>&gt; wrong without the trampolines being synthesized.)<br>&gt;<br>&gt; One more note: at one point Joe Groff was investigating the idea that<br>&gt; conformances wouldn’t be inherited onto subclasses, which would mean no<br>&gt; more implicit ‘required’ initializers. Instead, the compiler would perform<br>&gt; most operations by upcasting to the base class, and then converting to the<br>&gt; protocol type or calling the generic function. In this world, T would<br>&gt; *always* be NSObject, never a subclass, and we’d have to come up with<br>&gt; something else. I think this model is still worth investigating and I<br>&gt; wouldn’t want to close off our options just for the sake of “cleaning<br>&gt; house”.<br>&gt;<br>&gt; It’s possible that there’s not actually a reason to override operators in<br>&gt; practice, which would make pretty much all of these concerns go away. (==<br>&gt; is special; imagine we had an operation for checking equality within types<br>&gt; and one across type hierarchies and ignore it for now.) I think it’d be<br>&gt; worth investigating where operators are overridden today, and not just in<br>&gt; Swift, to make sure we cover those use cases too.<br>&gt;<br>&gt; (Please forgive all of the Foundation type examples that may soon be value<br>&gt; types. They’re convenient.)<br>&gt;<br>&gt;<br>&gt; *Assignment Operators*<br>&gt;<br>&gt; A mutating requirement and a static method with an inout parameter mean<br>&gt; different things for a conforming class: the former can only access the<br>&gt; class’s properties, while the latter can replace the caller’s *reference* as<br>&gt; well.<br>&gt;<br>&gt; class Player { … }<br>&gt;<br>&gt; extension Player {<br>&gt;   static func roulette(_ player: inout Player) {<br>&gt;     if randomValue() &gt; 0.1 {<br>&gt;       player.roundsSurvived += 1<br>&gt;     } else {<br>&gt;       // Replace this player…but not any other references to them!<br>&gt;       player = Player()<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt;   /*mutating*/ func solitaire() {<br>&gt;     self.roundsSurvived += 1<br>&gt;     // Cannot replace ‘self’<br>&gt;     //self = Player()<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I’m not sure if one of these is obviously better than the other (more<br>&gt; capable ↔︎ more footgun). I agree with Nicola&#39;s point about mutating<br>&gt; methods *looking* better than static methods taking an inout parameter,<br>&gt; but that probably shouldn’t be the ultimate deciding factor.<br>&gt;<br></p><p>You make a good point here. This is hitting on one of the fundamental<br>problems I&#39;ve had with mutating requirements in protocols in some of my own<br>projects, which is that even when a class type conforms to such a protocol<br>(or worse, even if the protocol itself is restricted to `class` types<br>only), if I want to use it in a generic context with that protocol as a<br>constraint, I still have to pass it unnecessarily as an inout argument.<br></p><p>On the one hand, fixing that underlying problem might help us here as well.<br>An obvious alternative would be to disallow `inout` on class conformances<br>to assignment operators, but that introduces inconsistency that I&#39;m trying<br>to avoid. I&#39;m not sure if it&#39;s any better, either.<br></p><p><br></p><p>&gt; I know we want to improve type-checker performance, and reducing the<br>&gt; number of overloads *seems* like a way to do that, but I’m not convinced<br>&gt; it actually will in a significant way (e.g. “you can now use ten operators<br>&gt; in a chain instead of seven” is not enough of a win). It still seems like<br>&gt; there ought to be a lot of low-hanging fruit in that area that we could<br>&gt; easily clear away, like “an overload containing a struct type will never<br>&gt; match any input but that struct type”.<br>&gt;<br>&gt; I personally really want to move operators into types, but I want to do it<br>&gt; by doing member lookup on the type, and fall back to global operators only<br>&gt; if something can’t be found there. That approach<br>&gt;<br>&gt; - also has potential to improve type-checker performance<br>&gt; - also removes operators from the global namespace<br>&gt; - also removes the need for “override points” (implementation methods like<br>&gt; NSObject.isEqual(_:) and FloatingPoint.isLessThan(_:))<br>&gt;<br>&gt; It does privilege the left-hand side of a binary operator, but I think<br>&gt; that’s acceptable for the operators we’ve seen in practice. (Of course we<br>&gt; would need real data to back that up.)<br>&gt;<br></p><p>As Brent pointed out in his reply, without multiple dispatch, you don&#39;t<br>really benefit from privileging the lhs argument, and in fact you can end<br>up in situations where the behavior is surprising if you don&#39;t implement<br>both orders. For example, in your (NSString, NSURL) example, each class<br>would have to be extended to explicitly support comparison with the other<br>in order to support commutativity if equality was an instance method. I&#39;m<br>not sure that&#39;s any better for those particular types than just having the<br>operators global in the first place.<br></p><p>My argument would be that there are still significant enough benefits to<br>move forward:<br></p><p>- for value types and for binary operators that have the same typed<br>arguments, static methods provide a clear benefit w.r.t. consistency (the<br>declaration of the global operator and the static operator look the same)<br>and obvious semantics<br>- for binary operators with differently typed arguments, static operators<br>support commutativity much better than instance methods because both<br>implementations live in the most natural type for that particular case (for<br>example, String + Character and Character + String)<br>- if later on we can auto-generate trampolines, the choice of instance vs.<br>static methods for value types becomes a wash because the compiler is<br>effectively doing the same dispatch under the hood anyway<br>- for class types, regardless of whether one is a base of the other or both<br>share a common third base type, neither static nor instance methods<br>completely solve the problem and won&#39;t until/unless Swift supports multiple<br>dispatch, and the proposed behavior is not a regression in those cases<br></p><p><br></p><p>&gt;<br>&gt; I think that about sums up my concerns and my interest in an alternate<br>&gt; proposal. Again, I’m sorry for coming to this so late and for skimming the<br>&gt; latest discussion on it; I’m sure “my” proposal has already come up, and I<br>&gt; know it has its own flaws. I think I’m just not convinced that this is<br>&gt; sufficiently *better* to be worth the churn and closing off of other<br>&gt; potential avenues.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/d6be5ea0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 09:07, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; On Mon, May 23, 2016 at 9:58 PM Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;] <br>&gt; <br>&gt; Hi, Tony. Thanks for working on this. I have to say I’m incredibly concerned with this direction, for two main reasons. I’ll try to break them down here. (Sorry for squeaking in at the end of the review period!)<br>&gt; <br>&gt; No worries, thanks for the detailed feedback! I&#39;ve tried to address your concerns inline.<br>&gt; <br>&gt; <br>&gt; Overrides<br>&gt; <br>&gt; People up until now have been fairly unhappy with how operators are statically dispatched and can’t be overridden. We went all the way towards providing == that automatically calls isEqual(_:) on NSObject, but then you provide == for your subclass and it never gets called…no, wait, it does get called when you do a simple test, but not from the actual code that has NSObject as a static type.<br>&gt; <br>&gt; This proposal stays in that space: the proposed “trampoline” operator will dispatch based on the static type of the objects, not the dynamic type. Why? Consider using == on an NSURL and an NSString, both statically typed as NSObject. Given the definition of the trampoline from the proposal<br>&gt; <br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return T.==(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; T can’t possibly be anything but NSObject. (Neither NSURL nor NSString matches the types of both ‘lhs’ and ‘rhs’.) This isn’t a regression from the current model, as you say, but it does make the current model even more surprising, since normally you’d expect methods to be dynamically dispatched.<br>&gt; <br>&gt; Setting Objective-C aside for a moment, is this example consistent with Swift&#39;s design philosophies about type safety though? Swift doesn&#39;t even let you compare types that seem reasonably compatible, like Float and Double. Should we expect users to be able to compare completely distinct types like NSURL and NSString without a little extra work?<br>&gt; <br>&gt; If having `==` map to `NSObject.isEqual` is important for Objective-C compatibility, then there&#39;s no reason the runtime can&#39;t provide the following operator:<br>&gt; <br>&gt; func ==(lhs: NSObject, rhs: NSObject) -&gt; Bool {<br>&gt;   return lhs.isEqual(rhs)<br>&gt; }<br>&gt; <br>&gt; which should be more specific than the generic one and always get chosen in the context you desire.<br>&gt; <br>&gt; The situation is a little better when one of the types being compared has the other type as a base, because then implementing the operators as class methods instead of static methods does the right thing (with the only caveat being you have to cast the arguments down to the correct type).<br>&gt; <br></p><p>&gt; <br>&gt; Here’s an alternate formation of the trampoline that’s a little better about this…<br>&gt; <br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return lhs.dynamicType.==(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; …but I’m still not convinced. (People are especially likely to get this wrong without the trampolines being synthesized.)<br>&gt; <br></p><p>Yeah, I don’t think arbitrary symmetric operators do work generally across object types. Equality is special since there’s a reasonable default, but that’s probably not the common case. That does make this a little better—if you never have to override an operator function, the static dispatch doesn’t matter.<br></p><p>I’m still concerned about asymmetric operators, however. That includes assignment operators, but also things like operators for chaining tasks, DSLs for constraint systems, etc. It’s not too hard to implement these to forward to something dynamically dispatched (as we’ve both shown), but the default behavior, which currently doesn’t do what you want, will continue not doing what you want.<br></p><p>&gt; Assignment Operators<br>&gt; <br>&gt; A mutating requirement and a static method with an inout parameter mean different things for a conforming class: the former can only access the class’s properties, while the latter can replace the caller’s reference as well.<br>&gt; <br>&gt; class Player { … }<br>&gt; <br>&gt; extension Player {<br>&gt;   static func roulette(_ player: inout Player) {<br>&gt;     if randomValue() &gt; 0.1 {<br>&gt;       player.roundsSurvived += 1<br>&gt;     } else {<br>&gt;       // Replace this player…but not any other references to them!<br>&gt;       player = Player()<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   /*mutating*/ func solitaire() {<br>&gt;     self.roundsSurvived += 1<br>&gt;     // Cannot replace ‘self’<br>&gt;     //self = Player()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I’m not sure if one of these is obviously better than the other (more capable ↔︎ more footgun). I agree with Nicola&#39;s point about mutating methods looking better than static methods taking an inout parameter, but that probably shouldn’t be the ultimate deciding factor.<br>&gt; <br>&gt; You make a good point here. This is hitting on one of the fundamental problems I&#39;ve had with mutating requirements in protocols in some of my own projects, which is that even when a class type conforms to such a protocol (or worse, even if the protocol itself is restricted to `class` types only), if I want to use it in a generic context with that protocol as a constraint, I still have to pass it unnecessarily as an inout argument.<br>&gt; <br>&gt; On the one hand, fixing that underlying problem might help us here as well. An obvious alternative would be to disallow `inout` on class conformances to assignment operators, but that introduces inconsistency that I&#39;m trying to avoid. I&#39;m not sure if it&#39;s any better, either.<br></p><p>Yeah, I’d definitely like to change the behavior we have now. We discussed it previously and decided this was the least bad thing to do, but I think that decision was wrong. That deserves a whole proposal of its own, though.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; I know we want to improve type-checker performance, and reducing the number of overloads seems like a way to do that, but I’m not convinced it actually will in a significant way (e.g. “you can now use ten operators in a chain instead of seven” is not enough of a win). It still seems like there ought to be a lot of low-hanging fruit in that area that we could easily clear away, like “an overload containing a struct type will never match any input but that struct type”.<br>&gt; <br>&gt; I personally really want to move operators into types, but I want to do it by doing member lookup on the type, and fall back to global operators only if something can’t be found there. That approach<br>&gt; <br>&gt; - also has potential to improve type-checker performance<br>&gt; - also removes operators from the global namespace<br>&gt; - also removes the need for “override points” (implementation methods like NSObject.isEqual(_:) and FloatingPoint.isLessThan(_:))<br>&gt; <br>&gt; It does privilege the left-hand side of a binary operator, but I think that’s acceptable for the operators we’ve seen in practice. (Of course we would need real data to back that up.)<br>&gt; <br>&gt; As Brent pointed out in his reply, without multiple dispatch, you don&#39;t really benefit from privileging the lhs argument, and in fact you can end up in situations where the behavior is surprising if you don&#39;t implement both orders. For example, in your (NSString, NSURL) example, each class would have to be extended to explicitly support comparison with the other in order to support commutativity if equality was an instance method. I&#39;m not sure that&#39;s any better for those particular types than just having the operators global in the first place.<br></p><p>I assume you’d still have to implement it with NSObject as the “other” type, like you do in Objective-C. You’d just return false in that case. But you’d get the correct answer for comparing two NSURLs that are statically typed as NSObject, which you wouldn’t using the vanilla trampoline.<br></p><p><br>&gt; <br>&gt; My argument would be that there are still significant enough benefits to move forward:<br>&gt; <br>&gt; - for value types and for binary operators that have the same typed arguments, static methods provide a clear benefit w.r.t. consistency (the declaration of the global operator and the static operator look the same) and obvious semantics<br></p><p>Agreed…for operators that go with protocols. Is that all of them? Most of them? I’m not sure.<br></p><p>&gt; - for binary operators with differently typed arguments, static operators support commutativity much better than instance methods because both implementations live in the most natural type for that particular case (for example, String + Character and Character + String)<br></p><p>Agreed, but I consider this only a mild plus because extensions are pretty easy in Swift. We put initializers and helper methods on related types all the time.<br></p><p>&gt; - if later on we can auto-generate trampolines, the choice of instance vs. static methods for value types becomes a wash because the compiler is effectively doing the same dispatch under the hood anyway<br></p><p>That’s true for value types whether or not we autogenerate, isn’t it?<br></p><p>(Also, for autogeneration, I like the idea of it being opt-out the same way default initializers are for a struct: if you provide a global operator implementation in the same module with the correct signature, the compiler doesn’t need to generate one.)<br></p><p>&gt; - for class types, regardless of whether one is a base of the other or both share a common third base type, neither static nor instance methods completely solve the problem and won&#39;t until/unless Swift supports multiple dispatch, and the proposed behavior is not a regression in those cases<br></p><p>I guess I’m not convinced of the chain of reasoning here. “Multi-method dispatch is the most correct way to solve the problem” is fine; “therefore, anything short of that isn’t worth doing” is where I get stuck. Instance methods partially solve the problem, and it’s possible (again, no data on hand) that they solve the problem in the majority of cases.<br></p><p>(It’s also possible that the prevalence of OO has made people prefer operators that can be dispatched based on the left-hand side, so I guess I’d want to go look at, e.g. Haskell and Perl to see what operators don’t fit in that bucket.)<br></p><p><br>I guess I’d summarize my stance as “this proposal enshrines our current problems with operator semantics in order to improve consistency in the syntax” (with “enshrines” meaning “makes harder to change later”), and that doesn’t seem like a good enough reason to change from what we have now.<br></p><p>(In particular, we don’t have any operator members now, besides in protocols. That means adding them in any form can probably be an additive change, or at least nearly so. Once we do, however, we’d have a hard time switching to a different model without breaking everyone’s code, and we should really stop breaking everyone’s code with new language changes at some point.)<br></p><p>Jordan<br></p><p>P.S. Thanks for taking my concerns seriously and taking the time to respond to them. :-)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/ef62ec2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;&gt; As Brent pointed out in his reply, without multiple dispatch, you don&#39;t really benefit from privileging the lhs argument, and in fact you can end up in situations where the behavior is surprising if you don&#39;t implement both orders. For example, in your (NSString, NSURL) example, each class would have to be extended to explicitly support comparison with the other in order to support commutativity if equality was an instance method. I&#39;m not sure that&#39;s any better for those particular types than just having the operators global in the first place.<br>&gt; <br>&gt; I assume you’d still have to implement it with NSObject as the “other” type, like you do in Objective-C. You’d just return false in that case.<br></p><p>It is rather unfortunate, though, that your `(Self, Self)` operator essentially becomes `(Self, NSObject)` once `NSObject` conforms. I mean, Swift will at least *tell* you this is happening and force you to write an `other as? Self` test, but the way the type of the right-hand side gets pinned down while the left-hand side stays unspecified is just strange.<br></p><p>(Incidentally, I think rather than returning `false` here, you probably ought to say:<br></p><p>	guard let other = other as? Self else {<br>		return super == other<br>	}<br></p><p>Would you be able to use `super` in that way? You probably ought to, if we&#39;re planning to use left-side dispatch.)<br></p><p>Meanwhile, a multi dispatch solution would send two otherwise unrelated types to `NSObject`&#39;s implementation, which would `===` the two instances, discover they were not identical, and return `nil`. More specific implementations would not even have to think about this case; the method dispatch would just do it for them. I don&#39;t know if that solution is feasible, but if it is, it seems clearly correct—it simply gives you the right behavior every single time with no hand-wringing about type mismatches.<br></p><p>(On the other hand, if we *do* use left-side dispatch, we might be able to solve the `isEqual` interop problems complained about upthread: if `==` is implicitly given an `@objc(isEqual:)` attribute, and `isEqual` definitions or calls are fix-it-ed to `==`, the problem essentially solves itself.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Brent, I think it&#39;s even slightly more complicated than that. Think e.g. how two subclass instances of NSArray should compare equal even if they&#39;ve got different types. (I really dislike class inheritance for these reasons, but below is my take on how we could better live with the issue in Swift.)<br></p><p>&gt; On 25 May 2016, at 11:15, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; As Brent pointed out in his reply, without multiple dispatch, you don&#39;t really benefit from privileging the lhs argument, and in fact you can end up in situations where the behavior is surprising if you don&#39;t implement both orders. For example, in your (NSString, NSURL) example, each class would have to be extended to explicitly support comparison with the other in order to support commutativity if equality was an instance method. I&#39;m not sure that&#39;s any better for those particular types than just having the operators global in the first place.<br>&gt;&gt; <br>&gt;&gt; I assume you’d still have to implement it with NSObject as the “other” type, like you do in Objective-C. You’d just return false in that case.<br>&gt; <br>&gt; It is rather unfortunate, though, that your `(Self, Self)` operator essentially becomes `(Self, NSObject)` once `NSObject` conforms. I mean, Swift will at least *tell* you this is happening and force you to write an `other as? Self` test, but the way the type of the right-hand side gets pinned down while the left-hand side stays unspecified is just strange.<br>&gt; <br>&gt; (Incidentally, I think rather than returning `false` here, you probably ought to say:<br>&gt; <br>&gt; 	guard let other = other as? Self else {<br>&gt; 		return super == other<br>&gt; 	}<br>&gt; <br>&gt; Would you be able to use `super` in that way? You probably ought to, if we&#39;re planning to use left-side dispatch.)<br>&gt; <br>&gt; Meanwhile, a multi dispatch solution would send two otherwise unrelated types to `NSObject`&#39;s implementation, which would `===` the two instances, discover they were not identical, and return `nil`. More specific implementations would not even have to think about this case; the method dispatch would just do it for them. I don&#39;t know if that solution is feasible, but if it is, it seems clearly correct—it simply gives you the right behavior every single time with no hand-wringing about type mismatches.<br>&gt; <br>&gt; (On the other hand, if we *do* use left-side dispatch, we might be able to solve the `isEqual` interop problems complained about upthread: if `==` is implicitly given an `@objc(isEqual:)` attribute, and `isEqual` definitions or calls are fix-it-ed to `==`, the problem essentially solves itself.)<br></p><p>For the very example of Equatable and Foundation classes, we would get the right behaviour for NSObject&#39;s `isEqual` by changing the definition of Equatable into:<br></p><p>    protocol Equatable {<br>        associatedtype EqualSelf = Self // the default is ok pretty much always<br>        func == (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>        func != (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>    }<br></p><p>This way, the compiler would always be looking for the `(Self, NSObject) -&gt; Bool` shape of operation, which actually picks up statically the correct overload for `lhs.isEqual(rhs)`.<br></p><p>When it comes to existentials, the usual case is like you said above; you want to check if you can cast the `rhs` to `Self`. But that usual case excludes the complication of class clusters where the instances of two different subclasses of a common superclass may compare equal.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/5bc77380/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; Brent, I think it&#39;s even slightly more complicated than that. Think e.g. how two subclass instances of NSArray should compare equal even if they&#39;ve got different types. (I really dislike class inheritance for these reasons, but below is my take on how we could better live with the issue in Swift.)<br></p><p>If you&#39;re referring to this:<br></p><p>&gt;&gt; 	guard let other = other as? Self else {<br>&gt;&gt; 		return super == other<br>&gt;&gt; 	}<br></p><p>I probably should have said `#Self`, meaning e.g. `NSArray` if you&#39;re implementing `NSArray.==`. What you really want to test for there is the *static* type of `self`, not the dynamic type.<br></p><p>If you&#39;re referring to the multiple dispatch thing, I actually think that will handle subclassing perfectly well. If you have a class hierarchy like this, with each class implementing its own `(Self, Self)` equality operation:<br></p><p>	NSObject<br>		NSArray<br>			MyArray<br>			MyOtherArray<br></p><p>Then using `==` on `MyArray` and `MyOtherArray` should use `(NSArray, NSArray).==()`, which presumably would compare the length and elements to test for equality.<br></p><p>&gt; For the very example of Equatable and Foundation classes, we would get the right behaviour for NSObject&#39;s `isEqual` by changing the definition of Equatable into:<br>&gt; <br>&gt;     protocol Equatable {<br>&gt;         associatedtype EqualSelf = Self // the default is ok pretty much always<br>&gt;         func == (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>&gt;         func != (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>&gt;     }<br>&gt; <br>&gt; This way, the compiler would always be looking for the `(Self, NSObject) -&gt; Bool` shape of operation, which actually picks up statically the correct overload for `lhs.isEqual(rhs)`.<br></p><p>But you would need to do this for all operators. A protocol that requires `&lt;` or `+` would need to de-privilege the right-hand side in exactly the same way.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 25 May 2016, at 12:21, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Brent, I think it&#39;s even slightly more complicated than that. Think e.g. how two subclass instances of NSArray should compare equal even if they&#39;ve got different types. (I really dislike class inheritance for these reasons, but below is my take on how we could better live with the issue in Swift.)<br>&gt; <br>&gt; If you&#39;re referring to this:<br>&gt; <br>&gt;&gt;&gt; 	guard let other = other as? Self else {<br>&gt;&gt;&gt; 		return super == other<br>&gt;&gt;&gt; 	}<br>&gt; <br>&gt; I probably should have said `#Self`, meaning e.g. `NSArray` if you&#39;re implementing `NSArray.==`. What you really want to test for there is the *static* type of `self`, not the dynamic type.<br>&gt; <br>&gt; If you&#39;re referring to the multiple dispatch thing, I actually think that will handle subclassing perfectly well. If you have a class hierarchy like this, with each class implementing its own `(Self, Self)` equality operation:<br>&gt; <br>&gt; 	NSObject<br>&gt; 		NSArray<br>&gt; 			MyArray<br>&gt; 			MyOtherArray<br>&gt; <br>&gt; Then using `==` on `MyArray` and `MyOtherArray` should use `(NSArray, NSArray).==()`, which presumably would compare the length and elements to test for equality.<br></p><p>It&#39;s kind of hard to explain without working code so here&#39;s a sample to play with: http://swiftlang.ng.bluemix.net/#/repl/c1ddd24113169ab82df118660c8e0de6ea24e48d32997c327638a88dc686e91f &lt;http://swiftlang.ng.bluemix.net/#/repl/c1ddd24113169ab82df118660c8e0de6ea24e48d32997c327638a88dc686e91f&gt;. Use the `#if true` line to toggle between the implementations. The core of the issue—which I think will also happen if we ever gain the ability to &quot;open&quot; existentials—is at the point where we cast the right-hand side to Self:<br></p><p>struct AnyEquatable : Equatable {<br>    let value: Any<br>    let isEqual: (AnyEquatable) -&gt; Bool<br>    init&lt;T : Equatable&gt;(_ value: T) {<br>        self.value = value<br>        self.isEqual = {r in<br>            guard let other = r.value as? T.EqualSelf else { return false }<br>            return value == other<br>        }<br>    }<br>}<br></p><p>func == (l: AnyEquatable, r: AnyEquatable) -&gt; Bool {<br>    return l.isEqual(r)<br>}<br></p><p>See the cast `r.value as? T.EqualSelf`, or `r.value as? T` like it would go for the stdlib Equatable. When `T` is MyArray or MyOtherArray and the erased type of `r.value` is not, the cast will fail.<br></p><p>&gt;&gt; For the very example of Equatable and Foundation classes, we would get the right behaviour for NSObject&#39;s `isEqual` by changing the definition of Equatable into:<br>&gt;&gt; <br>&gt;&gt;    protocol Equatable {<br>&gt;&gt;        associatedtype EqualSelf = Self // the default is ok pretty much always<br>&gt;&gt;        func == (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>&gt;&gt;        func != (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; This way, the compiler would always be looking for the `(Self, NSObject) -&gt; Bool` shape of operation, which actually picks up statically the correct overload for `lhs.isEqual(rhs)`.<br>&gt; <br>&gt; But you would need to do this for all operators. A protocol that requires `&lt;` or `+` would need to de-privilege the right-hand side in exactly the same way.<br></p><p><br>That&#39;s true. Maybe if we want to take this issue into account we should name `EqualSelf` more generally. Or then we can just shrug away the problem and document it. It&#39;s not something I tend to face in real work, partly because I try to avoid inheritance as much as possible, but I know it&#39;s there.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c83992cf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Proposal link:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;<br></p><p>Hi all,<br></p><p>&gt; On May 17, 2016, at 8:33 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; The review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through May 23. The proposal is available here:<br></p><p>My apologies for being very, very late with this review. As has been noted elsewhere, the core team has been rather DoS’d for the last few weeks, and even very important things are getting lost in the shuffle.<br></p><p>I support the goals of this proposal, but I’m strongly against the approach it takes because it is fundamentally based on forwarding functions in the global scope.<br></p><p>My Complaints with the Proposal<br>1) Adding an operator function to a type doesn’t “just work”, which is surprising. Let’s do something silly and add a ‘*’ operator to repeat strings:<br></p><p>extension String {<br>  static func *(lhs: String, rhs: Int) -&gt; String { … }<br>}<br></p><p>If I try to use this in the obvious way<br></p><p>print(“hello” * 3)<br></p><p>I will get a compiler error. I have two paths at this point, neither of which is obvious: either I need to find (or author!) a protocol to conform to that allows my particular brand of ‘*’ to match and has a global forwarding operator, or I need to implement the operator at the global scope:<br></p><p>  func *(lhs: String, rhs: Int) -&gt; String { ... }<br></p><p>2) Creating a new operator now requires more boilerplate:<br>	a) An operator definition, e.g.,<br></p><p>infix operator +++ { }<br></p><p>	b) A protocol that describes this new operator,<br></p><p>protocol Concatable {<br>  func operator+++(lhs: Self, rhs: Self) -&gt; Self<br>}<br></p><p>	c) A forwarding operator function based on that protocol<br></p><p>func operator+++&lt;T : Concatable&gt;(lhs: T, rhs: T) -&gt; T {<br>  return T.+++(lhs, rhs)<br>}<br></p><p>Yes, creating a new operator shouldn’t be the easiest thing in the world, but that is a ton of boilerplate. Moreover…<br></p><p>3) The protocols used to describe these operators aren’t really natural: they are bare-bones, purely-syntactic protocols that have no meaning other than to do forwarding. Just putting “+” into Arithmetic isn’t good enough: we’ll need another one for Strideable, and we’ll almost surely end up with a “HasBinaryPlus” protocol like this:<br></p><p>protocol HasBinaryPlus {<br>  func operator+(lhs: Self, rhs: Self) -&gt; Self<br>}<br></p><p>so that other non-arithmetic types that want to introduce a binary plus with this form can opt to the protocol rather than having to write the forwarding function I complained about in (1). Moreover, Arithmetic will inherit this HasBinaryPlus. Scale that out and you have Arithmetic being composed of a pile of meaningless syntactic protocols: HasBinaryPlus, HasBinaryMinus, HasBinaryStar, HasBinarySlash, HasPrefixPlus, HasPrefixMinus. It makes Arithmetic confusing because the requirements are scattered.<br></p><p>It’s not even that there is just one protocol per operator, either: even just with the standard library, + will have at least two protocols associated with it: HasBinaryPlus and Strideable to cover the various cases in the standard library. It’s probably not enough, and there will surely be more protocols created for binary + simply to provide the forwarding functions.<br></p><p>4) The rule prohibiting operator functions defined in a type that don’t conform to a protocol limits retroactive modeling. If you don’t have a protocol in hand, you have to use a global operator.<br></p><p>5) Forwarding functions aren’t good for tools. Under this proposal, if I write “1 + 2” and use a tool to look at which “+” it resolved to, what will we see? The generic forwarding operator. Even though I could look in the source and see this:<br></p><p>extension Int {<br>  static func +(lhs: Int, rhs: Int) -&gt; Int { … }<br>}<br></p><p>and even those that’s what will get called, my tools aren’t going to interpret the body of the global forwarding function for + to resolve it in the obvious way.<br></p><p><br>The Good Parts<br></p><p>With all that negative, one might get the impression that I don’t like operators in types. I think there are improvements here:<br></p><p>I) Writing an operator function in a type/extension of a type is far more natural that writing one at global scope for the common case. Even if you’re not planning on conforming to a protocol, it just feels right that (say) String + String should be defined in an extension of String. It’s better for tooling (which can more easily associate the operator + with the String type), code organization, works with the new meaning of the “private” access modifier, and simply feels like Swift.<br></p><p>II) The requirement to use “static” on the operator function requirement in the protocol makes perfect sense to me. It’s a lot clearer, and communicates the semantics better. I can’t recall why we didn’t do this in the first place.<br></p><p>III) The goal to reduce the total number of overloads is laudable. It can help type checker performance (fewer overloads == less exponential behavior) and improve diagnostics (fewer candidates to display on error). The key insight here is that we don’t want to consider both a generic operator based on some protocol (e.g., + for Arithmetic types) and the operator functions that are used to satisfy the corresponding requirement.<br></p><p>An Alternative Approach<br></p><p>Let’s accept (I) and (II). But, let’s make operator lookup always be global, so that it sees all operators defined at either module scope or within a type/extension of a type. This gives us the syntactic improvements of the SE-0091 “immediately”, and eliminates all five of my complaints above: the natural Swift thing of defining your functionality within the type or an extension thereof “just works”. It’s weird in the sense that operators will be the only place where we do such global lookup—finding entries at both global and type scope. However, SE-0091 is introducing a different weird name lookup rule, and it feels like there’s really no way to avoid it: we simply don’t want normal lexical name lookup for operators when they can be defined in types.<br></p><p>This approach does not (directly) give any of the type checker performance/QoI improvements of (III). However, we can achieve that by making the key insight of (III) part of the semantic model: when we find all operators, we also find the operators in the protocols themselves. The operators in the protocols are naturally generic, e.g., the Arithmetic + effectively has a generic function type like this:<br></p><p>	&lt;Self: Arithmetic&gt; (Self, Self) -&gt; Self<br></p><p>which is basically what the forwarding functions look like in SE-0091 at a type level. Then, we say that we do not consider an operator function if it implements a protocol requirement, because the requirement is a generalization of all of the operator functions that satisfy that requirement. With this rule, we’re effectively getting the same effects of SE-0091’s approach to (III)—but it’s more automatic.<br></p><p>Note that this approach could change semantics. When you type-check a generic function, you’re inferring the generic type arguments. That could end up type checking differently than considering a more specific function. For example, let’s say we were allowed to fulfill an operator function requirement with an operator function that was a subtype of the requirement (a commonly-requested feature), e.g.,<br></p><p>class Super { }<br></p><p>class Sub : Super, Equatable {<br>  static func ==(lhs: Super, rhs: Super) -&gt; Bool { … } // note: currently ill-formed, but requested often<br>}<br></p><p>func testMe(sup: Super) -&gt; Bool {<br>  return sup == sup  // error: Equatable.== fails because “Super” is not equatable,<br>                     // and Sub.== isn’t considered because it satisfies the Equatable.== requirement<br>}<br></p><p>I suspect this is acceptable. If we ever did start to allow one to satisfy a requirement with something that is a subtype, perhaps we just wouldn’t extend that rule to operator function requirements. Note that it’s possible that you can trigger this in the current type system as well—I haven’t tried.<br></p><p>One could experiment with this solution just with the standard library: take away all of the concrete +’s and map them to “Arithmetic.add” or “Strideable.add” to get down to the minimal set, and then put the forwarding functions in to see how well the type checker copes with it (e.g., performance, diagnostics, what unexpected breakage do we see). There’s a way to push the experiment further—by teaching the type checker to do this pruning rule, which doesn’t actually depend on introducing the ability to define an operator function within a type—but of course that requires more implementation effort.<br></p><p>	- Doug<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/91d996fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June 10, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks for your feedback, Doug! I&#39;ve addressed some of your concerns inline.<br></p><p>On Thu, Jun 9, 2016 at 10:16 PM Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; On May 17, 2016, at 8:33 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; The review of &quot;SE-0091: Improving operator requirements in protocols&quot;<br>&gt; begins now and runs through May 23. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; My apologies for being very, very late with this review. As has been noted<br>&gt; elsewhere, the core team has been rather DoS’d for the last few weeks, and<br>&gt; even very important things are getting lost in the shuffle.<br>&gt;<br>&gt; I support the goals of this proposal, but I’m strongly against the<br>&gt; approach it takes because it is fundamentally based on forwarding functions<br>&gt; in the global scope.<br>&gt;<br>&gt; *My Complaints with the Proposal*<br>&gt; 1) Adding an operator function to a type doesn’t “just work”, which is<br>&gt; surprising. Let’s do something silly and add a ‘*’ operator to repeat<br>&gt; strings:<br>&gt;<br>&gt; extension String {<br>&gt;   static func *(lhs: String, rhs: Int) -&gt; String { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If I try to use this in the obvious way<br>&gt;<br>&gt; print(“hello” * 3)<br>&gt;<br>&gt;<br>&gt; I will get a compiler error. I have two paths at this point, neither of<br>&gt; which is obvious: either I need to find (or author!) a protocol to conform<br>&gt; to that allows my particular brand of ‘*’ to match and has a global<br>&gt; forwarding operator, or I need to implement the operator at the global<br>&gt; scope:<br>&gt;<br>&gt;   func *(lhs: String, rhs: Int) -&gt; String { ... }<br>&gt;<br></p><p>The unambiguous answer here is that you need to define the answer at the<br>global scope; no protocols come into play here. This proposal only<br>discusses what happens *if* a protocol defines an operator as a<br>*requirement*; that does not apply to the case of extending an existing<br>type with a new operator, so it&#39;s unaffected by these proposed changes.<br></p><p>I&#39;ll concede that it has the possibility to introduce confusion as there<br>are now two places where operators can be defined, with different meanings.<br></p><p><br></p><p>&gt; 2) Creating a new operator now requires more boilerplate:<br>&gt; a) An operator definition, e.g.,<br>&gt;<br>&gt; infix operator +++ { }<br>&gt;<br>&gt;<br>&gt; b) A protocol that describes this new operator,<br>&gt;<br>&gt; protocol Concatable {<br>&gt;   func operator+++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt;<br>&gt;<br>&gt; c) A forwarding operator function based on that protocol<br>&gt;<br>&gt; func operator+++&lt;T : Concatable&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;   return T.+++(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Yes, creating a new operator shouldn’t be the easiest thing in the world,<br>&gt; but that is a ton of boilerplate. Moreover…<br>&gt;<br></p><p>This isn&#39;t the case—creating a new operator does not require defining a<br>protocol. Defining a new infix operator like `+++` would work just as it<br>did before; this proposal does not change that. I&#39;m *not* proposing that<br>all operators *must* be implemented through protocol conformance; I&#39;m<br>merely proposing changes to the way that they are implemented for<br>conformances. If a user defines `+++`, they can implement it with a global<br>function, without any protocol or trampoline introduced.<br></p><p>The additional burden is only on protocol authors (not authors of operators<br>in general) to provide the trampoline method. My initial way of addressing<br>that was to auto-generate the trampolines, eliminating the extra<br>boilerplate, but that was unfortunately deemed too ambitious for Swift 3.<br>However, I feel this still a step in the right direction and those issues<br>can be resolved later without breaking anything proposed here, while still<br>providing the other benefits described in the proposal.<br></p><p><br>&gt;<br>&gt; 3) The protocols used to describe these operators aren’t really natural:<br>&gt; they are bare-bones, purely-syntactic protocols that have no meaning other<br>&gt; than to do forwarding. Just putting “+” into Arithmetic isn’t good enough:<br>&gt; we’ll need another one for Strideable, and we’ll almost surely end up with<br>&gt; a “HasBinaryPlus” protocol like this:<br>&gt;<br>&gt; protocol HasBinaryPlus {<br>&gt;   func operator+(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; so that other non-arithmetic types that want to introduce a binary plus<br>&gt; with this form can opt to the protocol rather than having to write the<br>&gt; forwarding function I complained about in (1). Moreover, Arithmetic will<br>&gt; inherit this HasBinaryPlus. Scale that out and you have Arithmetic being<br>&gt; composed of a pile of meaningless syntactic protocols: HasBinaryPlus,<br>&gt; HasBinaryMinus, HasBinaryStar, HasBinarySlash, HasPrefixPlus,<br>&gt; HasPrefixMinus. It makes Arithmetic confusing because the requirements are<br>&gt; scattered.<br>&gt;<br>&gt; It’s not even that there is just one protocol per operator, either: even<br>&gt; just with the standard library, + will have at least two protocols<br>&gt; associated with it: HasBinaryPlus and Strideable to cover the various cases<br>&gt; in the standard library. It’s probably not enough, and there will surely be<br>&gt; more protocols created for binary + simply to provide the forwarding<br>&gt; functions.<br>&gt;<br></p><p>Again, this isn&#39;t the case. Operators are not required to be implemented<br>through protocols, but any protocol that requires an operator can include<br>it and there is no reason that they would have to be restricted to one<br>operator per protocol. Maybe this wasn&#39;t clear since I focused a lot on<br>`Equatable` in my proposal for simplicity, but the motivating example was<br>`FloatingPoint`, which would implement several:<br></p><p>    protocol FloatingPoint {<br>      static func +(lhs: Self, rhs: Self) -&gt; Self<br>      static func -(lhs: Self, rhs: Self) -&gt; Self<br>      static func *(lhs: Self, rhs: Self) -&gt; Self<br>      static func /(lhs: Self, rhs: Self) -&gt; Self<br>      // others...<br>}<br></p><p>As you can see, the protocol still has *semantic* meaning and is not just a<br>bag of syntax.<br></p><p><br></p><p>&gt;<br>&gt; 4) The rule prohibiting operator functions defined in a type that don’t<br>&gt; conform to a protocol limits retroactive modeling. If you don’t have a<br>&gt; protocol in hand, you have to use a global operator.<br>&gt;<br>&gt; 5) Forwarding functions aren’t good for tools. Under this proposal, if I<br>&gt; write “1 + 2” and use a tool to look at which “+” it resolved to, what will<br>&gt; we see? The generic forwarding operator. Even though I could look in the<br>&gt; source and see this:<br>&gt;<br>&gt; extension Int {<br>&gt;   static func +(lhs: Int, rhs: Int) -&gt; Int { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; and even those that’s what will get called, my tools aren’t going to<br>&gt; interpret the body of the global forwarding function for + to resolve it in<br>&gt; the obvious way.<br>&gt;<br>&gt;<br>&gt; *The Good Parts*<br>&gt;<br>&gt; With all that negative, one might get the impression that I don’t like<br>&gt; operators in types. I think there are improvements here:<br>&gt;<br>&gt; I) Writing an operator function in a type/extension of a type is far more<br>&gt; natural that writing one at global scope for the common case. Even if<br>&gt; you’re not planning on conforming to a protocol, it just feels right that<br>&gt; (say) String + String should be defined in an extension of String. It’s<br>&gt; better for tooling (which can more easily associate the operator + with the<br>&gt; String type), code organization, works with the new meaning of the<br>&gt; “private” access modifier, and simply feels like Swift.<br>&gt;<br>&gt; II) The requirement to use “static” on the operator function requirement<br>&gt; in the protocol makes perfect sense to me. It’s a lot clearer, and<br>&gt; communicates the semantics better. I can’t recall why we didn’t do this in<br>&gt; the first place.<br>&gt;<br>&gt; III) The goal to reduce the total number of overloads is laudable. It can<br>&gt; help type checker performance (fewer overloads == less exponential<br>&gt; behavior) and improve diagnostics (fewer candidates to display on error).<br>&gt; The key insight here is that we don’t want to consider both a generic<br>&gt; operator based on some protocol (e.g., + for Arithmetic types) *and* the<br>&gt; operator functions that are used to satisfy the corresponding requirement.<br>&gt;<br>&gt; *An Alternative Approach*<br>&gt;<br>&gt; Let’s accept (I) and (II). But, let’s make operator lookup always be<br>&gt; global, so that it sees all operators defined at either module scope or<br>&gt; within a type/extension of a type. This gives us the syntactic improvements<br>&gt; of the SE-0091 “immediately”, and eliminates all five of my complaints<br>&gt; above: the natural Swift thing of defining your functionality within the<br>&gt; type or an extension thereof “just works”. It’s weird in the sense that<br>&gt; operators will be the only place where we do such global lookup—finding<br>&gt; entries at both global and type scope. However, SE-0091 is introducing a<br>&gt; different weird name lookup rule, and it feels like there’s really no way<br>&gt; to avoid it: we simply don’t want normal lexical name lookup for operators<br>&gt; when they can be defined in types.<br>&gt;<br>&gt; This approach does not (directly) give any of the type checker<br>&gt; performance/QoI improvements of (III). However, we can achieve that by<br>&gt; making the key insight of (III) part of the semantic model: when we find<br>&gt; all operators, we also find the operators in the protocols themselves. The<br>&gt; operators in the protocols are naturally generic, e.g., the Arithmetic +<br>&gt; effectively has a generic function type like this:<br>&gt;<br>&gt; &lt;Self: Arithmetic&gt; (Self, Self) -&gt; Self<br>&gt;<br>&gt; which is basically what the forwarding functions look like in SE-0091 at a<br>&gt; type level. Then, we say that we do not consider an operator function if it<br>&gt; implements a protocol requirement, because the requirement is a<br>&gt; generalization of all of the operator functions that satisfy that<br>&gt; requirement. With this rule, we’re effectively getting the same effects of<br>&gt; SE-0091’s approach to (III)—but it’s more automatic.<br>&gt;<br></p><p>I like this suggestion very much, and I would support it—especially if it&#39;s<br>easier to implement than the trampoline generation that I proposed for the<br>same effect.<br></p><p>Thinking about it further, type checking that should be fairly<br>straightforward, right? If we ignore classes/subclassing for the time<br>being, an operator function can only have one or two arguments. Let&#39;s say<br>we have the following:<br></p><p>    let t1: T<br>    let t2: T<br>    let t = t1 + t2<br></p><p>If we eliminate global lookup for operators, this means that the + operator<br>*must* be implemented on T; so rather than searching the entire global<br>namespace for +(lhs: T, rhs: T), it just has to look in T for a matching +.<br></p><p>Likewise, heterogeneous argument lists can still be supported:<br></p><p>    let t: T<br>    let u: U<br>    let v = t + u<br></p><p>The operator must live as a static function in T or U, or it doesn&#39;t exist.<br>So lookup should again be fast. By looking up the operator in both T and U,<br>as opposed to just one or the other, this supports users being able to<br>define operators where they most logically make sense; for example,<br>hypothetically:<br></p><p>    protocol CustomStringProtcol {<br>        static func +(lhs: Self, rhs: Character) -&gt; Self<br>        static func +(lhs: Character, rhs: Self) -&gt; Self<br>    }<br>    struct CustomString: CustomStringProtocol { ... }<br></p><p>    let t: Character<br>    let u: String<br>    let v = t + u  // looks up + with compatible arguments in String and<br>Character, finds it in String<br></p><p>There&#39;s the potential for ambiguity if both types implement operators that<br>match, but that may not be cause for concern.<br></p><p><br></p><p>&gt;<br>&gt; Note that this approach could change semantics. When you type-check a<br>&gt; generic function, you’re inferring the generic type arguments. That could<br>&gt; end up type checking differently than considering a more specific function.<br>&gt; For example, let’s say we were allowed to fulfill an operator function<br>&gt; requirement with an operator function that was a subtype of the requirement<br>&gt; (a commonly-requested feature), e.g.,<br>&gt;<br>&gt; class Super { }<br>&gt;<br>&gt; class Sub : Super, Equatable {<br>&gt;   static func ==(lhs: Super, rhs: Super) -&gt; Bool { … } // note: currently<br>&gt; ill-formed, but requested often<br>&gt; }<br>&gt;<br>&gt; func testMe(sup: Super) -&gt; Bool {<br>&gt;   return sup == sup  // error: Equatable.== fails because “Super” is not<br>&gt; equatable,<br>&gt;                      // and Sub.== isn’t considered because it satisfies<br>&gt; the Equatable.== requirement<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I suspect this is acceptable. If we ever did start to allow one to satisfy<br>&gt; a requirement with something that is a subtype, perhaps we just wouldn’t<br>&gt; extend that rule to operator function requirements. Note that it’s possible<br>&gt; that you can trigger this in the current type system as well—I haven’t<br>&gt; tried.<br>&gt;<br>&gt; One could experiment with this solution just with the standard library:<br>&gt; take away all of the concrete +’s and map them to “Arithmetic.add” or<br>&gt; “Strideable.add” to get down to the minimal set, and then put the<br>&gt; forwarding functions in to see how well the type checker copes with it<br>&gt; (e.g., performance, diagnostics, what unexpected breakage do we see).<br>&gt; There’s a way to push the experiment further—by teaching the type checker<br>&gt; to do this pruning rule, which doesn’t actually depend on introducing the<br>&gt; ability to define an operator function within a type—but of course that<br>&gt; requires more implementation effort.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/523d0fb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 10, 2016, at 8:24 AM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; Thanks for your feedback, Doug! I&#39;ve addressed some of your concerns inline.<br>&gt; <br>&gt; On Thu, Jun 9, 2016 at 10:16 PM Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Proposal link:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt;&gt; On May 17, 2016, at 8:33 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; The review of &quot;SE-0091: Improving operator requirements in protocols&quot; begins now and runs through May 23. The proposal is available here:<br>&gt; <br>&gt; My apologies for being very, very late with this review. As has been noted elsewhere, the core team has been rather DoS’d for the last few weeks, and even very important things are getting lost in the shuffle.<br>&gt; <br>&gt; I support the goals of this proposal, but I’m strongly against the approach it takes because it is fundamentally based on forwarding functions in the global scope.<br>&gt; <br>&gt; My Complaints with the Proposal<br>&gt; 1) Adding an operator function to a type doesn’t “just work”, which is surprising. Let’s do something silly and add a ‘*’ operator to repeat strings:<br>&gt; <br>&gt; extension String {<br>&gt;   static func *(lhs: String, rhs: Int) -&gt; String { … }<br>&gt; }<br>&gt; <br>&gt; If I try to use this in the obvious way<br>&gt; <br>&gt; print(“hello” * 3)<br>&gt; <br>&gt; I will get a compiler error. I have two paths at this point, neither of which is obvious: either I need to find (or author!) a protocol to conform to that allows my particular brand of ‘*’ to match and has a global forwarding operator, or I need to implement the operator at the global scope:<br>&gt; <br>&gt;   func *(lhs: String, rhs: Int) -&gt; String { ... }<br>&gt; <br>&gt; The unambiguous answer here is that you need to define the answer at the global scope; no protocols come into play here. This proposal only discusses what happens *if* a protocol defines an operator as a *requirement*; that does not apply to the case of extending an existing type with a new operator, so it&#39;s unaffected by these proposed changes.<br>&gt; <br>&gt; I&#39;ll concede that it has the possibility to introduce confusion as there are now two places where operators can be defined, with different meanings.<br></p><p>My point (1) is about that confusion, and also that the most natural place to put an operator—inside a type or extension thereof—is not the correct place to put the operator.<br></p><p>&gt; <br>&gt; 2) Creating a new operator now requires more boilerplate:<br>&gt; 	a) An operator definition, e.g.,<br>&gt; <br>&gt; infix operator +++ { }<br>&gt; <br>&gt; 	b) A protocol that describes this new operator,<br>&gt; <br>&gt; protocol Concatable {<br>&gt;   func operator+++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; 	c) A forwarding operator function based on that protocol<br>&gt; <br>&gt; func operator+++&lt;T : Concatable&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;   return T.+++(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; Yes, creating a new operator shouldn’t be the easiest thing in the world, but that is a ton of boilerplate. Moreover…<br>&gt; <br>&gt; This isn&#39;t the case—creating a new operator does not require defining a protocol. Defining a new infix operator like `+++` would work just as it did before; this proposal does not change that. I&#39;m *not* proposing that all operators *must* be implemented through protocol conformance; I&#39;m merely proposing changes to the way that they are implemented for conformances. If a user defines `+++`, they can implement it with a global function, without any protocol or trampoline introduced.<br></p><p>You’re correct that I am not required to introduce a protocol for the new operator. If I don’t, however, then we don’t get any of the type-checker performance or QoI benefits from this proposal. Worse, if we introduce the protocol later—and don’t go refactor all of the global operator functions into members—we also don’t get the type-checker performance or QoI benefits. So, even if the proposal doesn’t specifically require what I’m complaining about in (2), it’s very likely to happy in the standard library and become “lore” for how to define operators.<br></p><p>&gt; <br>&gt; The additional burden is only on protocol authors (not authors of operators in general) to provide the trampoline method. My initial way of addressing that was to auto-generate the trampolines, eliminating the extra boilerplate, but that was unfortunately deemed too ambitious for Swift 3. However, I feel this still a step in the right direction and those issues can be resolved later without breaking anything proposed here, while still providing the other benefits described in the proposal.<br></p><p>Autogenerating trampolines eliminates one bit of the boilerplate, yes.<br></p><p>&gt; <br>&gt; 3) The protocols used to describe these operators aren’t really natural: they are bare-bones, purely-syntactic protocols that have no meaning other than to do forwarding. Just putting “+” into Arithmetic isn’t good enough: we’ll need another one for Strideable, and we’ll almost surely end up with a “HasBinaryPlus” protocol like this:<br>&gt; <br>&gt; protocol HasBinaryPlus {<br>&gt;   func operator+(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; so that other non-arithmetic types that want to introduce a binary plus with this form can opt to the protocol rather than having to write the forwarding function I complained about in (1). Moreover, Arithmetic will inherit this HasBinaryPlus. Scale that out and you have Arithmetic being composed of a pile of meaningless syntactic protocols: HasBinaryPlus, HasBinaryMinus, HasBinaryStar, HasBinarySlash, HasPrefixPlus, HasPrefixMinus. It makes Arithmetic confusing because the requirements are scattered.<br>&gt; <br>&gt; It’s not even that there is just one protocol per operator, either: even just with the standard library, + will have at least two protocols associated with it: HasBinaryPlus and Strideable to cover the various cases in the standard library. It’s probably not enough, and there will surely be more protocols created for binary + simply to provide the forwarding functions.<br>&gt; <br>&gt; Again, this isn&#39;t the case. Operators are not required to be implemented through protocols, but any protocol that requires an operator can include it and there is no reason that they would have to be restricted to one operator per protocol. Maybe this wasn&#39;t clear since I focused a lot on `Equatable` in my proposal for simplicity, but the motivating example was `FloatingPoint`, which would implement several:<br>&gt; <br>&gt;     protocol FloatingPoint {<br>&gt;       static func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;       static func -(lhs: Self, rhs: Self) -&gt; Self<br>&gt;       static func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;       static func /(lhs: Self, rhs: Self) -&gt; Self<br>&gt;       // others...<br>&gt; }<br>&gt; <br>&gt; As you can see, the protocol still has *semantic* meaning and is not just a bag of syntax.<br></p><p>If the trampoline functions don’t cover enough types, or we end up with lots of different trampoline functions (one for FloatingPoint, one for IntegerProtocol, another for Stridable, and so on), then we won’t actually end up with a significantly smaller overload set. So either we lose those benefits, or we end up slicing the protocols into smaller, reusable (but meaningless parts).<br></p><p>Let’s look at it this way: FloatingPoint will cover maybe 2-5 types (Float, Double, CGFloat (Darwin), Float80 (Intel), HalfFloat (maybe someday?)) . We’ll either need to abstract it further—into Arithmetic so we pick up the integral types, for example, or further so we can pick up String + String—or start adding more protocols that cover the same + syntax and have their own forwarding functions.<br></p><p>&gt; The Good Parts<br>&gt; <br>&gt; With all that negative, one might get the impression that I don’t like operators in types. I think there are improvements here:<br>&gt; <br>&gt; I) Writing an operator function in a type/extension of a type is far more natural that writing one at global scope for the common case. Even if you’re not planning on conforming to a protocol, it just feels right that (say) String + String should be defined in an extension of String. It’s better for tooling (which can more easily associate the operator + with the String type), code organization, works with the new meaning of the “private” access modifier, and simply feels like Swift.<br>&gt; <br>&gt; II) The requirement to use “static” on the operator function requirement in the protocol makes perfect sense to me. It’s a lot clearer, and communicates the semantics better. I can’t recall why we didn’t do this in the first place.<br>&gt; <br>&gt; III) The goal to reduce the total number of overloads is laudable. It can help type checker performance (fewer overloads == less exponential behavior) and improve diagnostics (fewer candidates to display on error). The key insight here is that we don’t want to consider both a generic operator based on some protocol (e.g., + for Arithmetic types) and the operator functions that are used to satisfy the corresponding requirement.<br>&gt; <br>&gt; An Alternative Approach<br>&gt; <br>&gt; Let’s accept (I) and (II). But, let’s make operator lookup always be global, so that it sees all operators defined at either module scope or within a type/extension of a type. This gives us the syntactic improvements of the SE-0091 “immediately”, and eliminates all five of my complaints above: the natural Swift thing of defining your functionality within the type or an extension thereof “just works”. It’s weird in the sense that operators will be the only place where we do such global lookup—finding entries at both global and type scope. However, SE-0091 is introducing a different weird name lookup rule, and it feels like there’s really no way to avoid it: we simply don’t want normal lexical name lookup for operators when they can be defined in types.<br>&gt; <br>&gt; This approach does not (directly) give any of the type checker performance/QoI improvements of (III). However, we can achieve that by making the key insight of (III) part of the semantic model: when we find all operators, we also find the operators in the protocols themselves. The operators in the protocols are naturally generic, e.g., the Arithmetic + effectively has a generic function type like this:<br>&gt; <br>&gt; 	&lt;Self: Arithmetic&gt; (Self, Self) -&gt; Self<br>&gt; <br>&gt; which is basically what the forwarding functions look like in SE-0091 at a type level. Then, we say that we do not consider an operator function if it implements a protocol requirement, because the requirement is a generalization of all of the operator functions that satisfy that requirement. With this rule, we’re effectively getting the same effects of SE-0091’s approach to (III)—but it’s more automatic.<br>&gt; <br>&gt; I like this suggestion very much, and I would support it—especially if it&#39;s easier to implement than the trampoline generation that I proposed for the same effect.<br>&gt; <br>&gt; Thinking about it further, type checking that should be fairly straightforward, right? If we ignore classes/subclassing for the time being, an operator function can only have one or two arguments. Let&#39;s say we have the following:<br>&gt; <br>&gt;     let t1: T<br>&gt;     let t2: T<br>&gt;     let t = t1 + t2<br>&gt; <br>&gt; If we eliminate global lookup for operators, this means that the + operator *must* be implemented on T; so rather than searching the entire global namespace for +(lhs: T, rhs: T), it just has to look in T for a matching +.<br>&gt; <br>&gt; Likewise, heterogeneous argument lists can still be supported:<br>&gt; <br>&gt;     let t: T<br>&gt;     let u: U<br>&gt;     let v = t + u<br>&gt; <br>&gt; The operator must live as a static function in T or U, or it doesn&#39;t exist. So lookup should again be fast. By looking up the operator in both T and U, as opposed to just one or the other, this supports users being able to define operators where they most logically make sense; for example, hypothetically:<br>&gt; <br>&gt;     protocol CustomStringProtcol {<br>&gt;         static func +(lhs: Self, rhs: Character) -&gt; Self<br>&gt;         static func +(lhs: Character, rhs: Self) -&gt; Self<br>&gt;     }<br>&gt;     struct CustomString: CustomStringProtocol { ... }<br>&gt; <br>&gt;     let t: Character<br>&gt;     let u: String<br>&gt;     let v = t + u  // looks up + with compatible arguments in String and Character, finds it in String<br></p><p>We’ve thought about this, and it doesn’t work in Swift’s type system. It’s similar to the rule that C++ uses for operator lookup—called Argument Dependent Lookup, or ADL—which looks in the types of the operands (and a whole pile of types and namespaces related to it). But that doesn’t work in a language with bidirectional type inference like Swift has, because you have to also consider the return type of the operator and there’s not necessarily any point at which you know all of the input types and the result type. Let’s do something fun:<br></p><p>extension String {<br>  func /(lhs: Character, rhs: Character) -&gt; String<br>}<br></p><p>let s: String = ‘a’ / ‘b’<br></p><p>We need to look in String to find this operator, which we can only do when we consider the return type. One doesn’t even need to involve the result type, because the way Swift handles literals makes it very hard to answer the question “what type is this expression going to have?”. Consider:<br></p><p>extension UInt {<br>  func +++(lhs: Int, rhs: UInt) -&gt; UInt	<br>}<br></p><p>let x = 1 +++ 2<br></p><p>There’s essentially no way to find that +++ based on the types, because literals don’t have types by themselves. However, if we did find the +++ based on some global lookup, the result will type-check. <br></p><p>&gt; There&#39;s the potential for ambiguity if both types implement operators that match, but that may not be cause for concern.<br></p><p>I think there’s always going to be a potential for ambiguity in this space. I’d only be particularly concerned about it if our rule caused people to have to duplicate operator functions in different types so that at least one of them would be found.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/ce167431/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
