<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[RFD] Non-Self Protocol Requirements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>The following situation has come up for me now and then: I want to work with groups of types that share a common behavior, but that behavior is not sourced in the implementation of the Self type but rather in a secondary type.  Specifically, could Swift be extended to introduce a protocol requirement that discusses how a type is used by a secondary type and not the kind of member provided directly by the type. For example:<br></p><p>// These are all numbers<br>let int32: Int32 = 1; let int8: Int8 = 1<br>let double: Double = 1.0; let cgfloat: CGFloat = 1.0; let float: Float = 1<br></p><p>// They can all be converted to Double using Double.init<br>Double(int32); Double(int8); Double(double); Double(cgfloat); Double(float)<br></p><p>// A heterogeneous collection cannot be unified into a single protocol<br>let foo: [Any] = [int32, int8, double, cgfloat, float]<br>foo.map{ Double($0) } // Can&#39;t work, Any doesn&#39;t make any sense here<br></p><p>The kind of thing I am looking for is something like this:<br></p><p>protocol DoubleSource {<br>    Double.init(Self)<br>}<br></p><p>In other words, the functionality constraint is not provided by the base type but by a second type to which the base type is a parameter.<br></p><p>My use case is for unrelated types (that is, there&#39;s no inheritance relationship like you&#39;d find in `UISwitch` and `UISlider`, for example -- both of which are `UIView` and `UIControl`), where there is a secondary type that implements behavior with the same signature for these separate types, such as the Double initializer. Where this pops up the most is in working with Sprite/SceneKit, GamePlayKit, QuartzCore, Accelerate, unifying my numeric values so I can mix and match calls and clean up the flow where some calls require CGPoint, others need float2, etc. Ideally I would be able to <br></p><p>extension DoubleSource {<br>    func bar() -&gt; T {<br>        let value = Double.init(self)<br>        // do something with value; return T of some type<br>    }<br>}<br></p><p>let foo: [DoubleSource] = [int32, int8, double, cgfloat, float]<br>foo.map{ bar($0) } // would work<br></p><p>Would something like this be a valuable direction to extend Swift? Is it something found in other languages? Does this kind of requirement have a name? Is it *pragmatically* possible to introduce it in Swift?<br></p><p>Thanks in advance for your thoughts and insights.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/83285287/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[RFD] Non-Self Protocol Requirements</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 17, 2016 at 01:00:00am</p></header><div class="content"><p>Yes, something like this would be handy! Even the ability to coerce from one type to another, if that destination type has a keyless initialiser for the source type.<br></p><p>Here’s some imaginary syntax for with Erica’s array example. I would prefer a way to not have a separate type for ‘DoubleSource’ if possible.<br></p><p>let foo: [Double] = Double[int32, int8, double, cgfloat, float] // As if you had written Double(…) around each item<br></p><p>or<br></p><p>let foo: [Double] = [int32, int8, double, cgfloat, float](Double.init) // // As if you had written Double(…) around each item<br></p><p><br>Here’s another use case I’ve had:<br></p><p>enum Deferred&lt;Result&gt; {<br>	typealias UseResult = () throws -&gt; Result<br>	<br>	case unit(UseResult)<br>	case future(((UseResult) -&gt; ()) -&gt; ())<br></p><p>	init(_ subroutine: UseResult) {<br>		self = .unit(subroutine)<br>	}<br>}<br></p><p>Instead of this:<br></p><p>struct Example {<br>	func next() -&gt; Deferred&lt;Int&gt; {<br>		return Deferred{ 42 }<br>	}<br>}<br></p><p>It would be nice to be able to do this:<br></p><p>struct Example {<br>	func next() -&gt; Deferred&lt;Int&gt; {<br>		return { 42 }<br>	}<br>}<br></p><p>I don’t know if that’s playing with fire, but it would be seemingly nice for Swift to automatically infer what I want.<br></p><p><br>&gt; On 17 May 2016, at 12:15 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following situation has come up for me now and then: I want to work with groups of types that share a common behavior, but that behavior is not sourced in the implementation of the Self type but rather in a secondary type.  Specifically, could Swift be extended to introduce a protocol requirement that discusses how a type is used by a secondary type and not the kind of member provided directly by the type. For example:<br>&gt; <br>&gt; // These are all numbers<br>&gt; let int32: Int32 = 1; let int8: Int8 = 1<br>&gt; let double: Double = 1.0; let cgfloat: CGFloat = 1.0; let float: Float = 1<br>&gt; <br>&gt; // They can all be converted to Double using Double.init<br>&gt; Double(int32); Double(int8); Double(double); Double(cgfloat); Double(float)<br>&gt; <br>&gt; // A heterogeneous collection cannot be unified into a single protocol<br>&gt; let foo: [Any] = [int32, int8, double, cgfloat, float]<br>&gt; foo.map{ Double($0) } // Can&#39;t work, Any doesn&#39;t make any sense here<br>&gt; <br>&gt; The kind of thing I am looking for is something like this:<br>&gt; <br>&gt; protocol DoubleSource {<br>&gt;     Double.init(Self)<br>&gt; }<br>&gt; <br>&gt; In other words, the functionality constraint is not provided by the base type but by a second type to which the base type is a parameter.<br>&gt; <br>&gt; My use case is for unrelated types (that is, there&#39;s no inheritance relationship like you&#39;d find in `UISwitch` and `UISlider`, for example -- both of which are `UIView` and `UIControl`), where there is a secondary type that implements behavior with the same signature for these separate types, such as the Double initializer. Where this pops up the most is in working with Sprite/SceneKit, GamePlayKit, QuartzCore, Accelerate, unifying my numeric values so I can mix and match calls and clean up the flow where some calls require CGPoint, others need float2, etc. Ideally I would be able to <br>&gt; <br>&gt; extension DoubleSource {<br>&gt;     func bar() -&gt; T {<br>&gt;         let value = Double.init(self)<br>&gt;         // do something with value; return T of some type<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let foo: [DoubleSource] = [int32, int8, double, cgfloat, float]<br>&gt; foo.map{ bar($0) } // would work<br>&gt; <br>&gt; Would something like this be a valuable direction to extend Swift? Is it something found in other languages? Does this kind of requirement have a name? Is it *pragmatically* possible to introduce it in Swift?<br>&gt; <br>&gt; Thanks in advance for your thoughts and insights.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/40e82531/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[RFD] Non-Self Protocol Requirements</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 16, 2016 at 07:00:00pm</p></header><div class="content"><p>On 16.05.2016 18:06, Patrick Smith via swift-evolution wrote:<br>&gt; let foo: [Double] = Double[int32, int8, double, cgfloat, float] // As if<br>&gt; you had written Double(…) around each item<br></p><p>I really like this suggestion. Actually IMO we don&#39;t need explicit type <br>declaration here:<br></p><p>// clearly it is an array of Double<br>let foo = Double[int32, int8, double, cgfloat, float]<br></p><p>We can use the same feature for other types like<br>let foo = String[1, 1.0, true]<br></p><p>Or even some complex type:<br>let foo = ComplexType[1, 1.0, true]<br></p><p>But I really don&#39;t like this:<br>//let foo: [Double] = [int32, int8, double, cgfloat, float](Double.init)<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
