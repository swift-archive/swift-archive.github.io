<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 13, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Apr 12 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yes, I totally agree that `Collection.subscript(_: Index)` should not<br>&gt; be Optional.<br>&gt;<br>&gt; But I think that index-manipulation methods like `successor(of:)` are<br>&gt; a different story. It is normal and expected that, when you alter an<br>&gt; index, you will occasionally hit the boundaries of the<br>&gt; collection. There certainly are cases where you know a particular<br>&gt; index manipulation is safe, but most index manipulations need to be<br>&gt; guarded by something like:<br>&gt;<br>&gt; 	while index &lt; collection.endIndex {<br>&gt; 		let nextIndex = collection.successor(of: index)<br>&gt; 		…<br>&gt; 		index = nextIndex<br>&gt; 	}<br></p><p>I disagree that this should be considered a “guard.”  You are testing<br>against another index—a basic feature of what makes something an index.<br>It&#39;s probably a bit more likely that this other index is at the end of<br>the collection, but it might not be.  For example, look at the algorithm<br>for reversing a collection in place:<br></p><p>  extension BidirectionalCollection where Self : MutableCollection {<br>    mutating func reverse() {<br>      if isEmpty { return } // early exit eliminates a branch in the loop<br>      var i = startIndex<br>      var j = predecessor(of: endIndex)<br>      while i &lt; j {<br>        swap(&amp;self[i], &amp;self[j])<br>        formSuccessor(&amp;i)<br>        formPredecessor(&amp;j)<br>      }<br>    }<br>  }<br></p><p>[Why isn&#39;t this in the stdlib?! Someone file a bug and write a proposal,<br>quick!]<br></p><p>&gt; In these cases, it would be better if the `successor(of:)` method was<br>&gt; designed in a way that acknowledged and encapsulated the bounds check<br>&gt; that is usually required when it is used:<br>&gt;<br>&gt; 	while let nextIndex = collection.successor(of: index) {<br>&gt; 		…<br>&gt; 		index = nextIndex<br>&gt; 	}<br></p><p>I disagree; it doesn&#39;t make sense that I should have to check for nil<br>when I&#39;m not really interested in the end of the collection as in my<br>example above.  Many other nontrivial algorithms will have the same<br>characteristic.  If all you need is to loop through indices to the end,<br>there are lots of ways to do it.  <br></p><p>Looking closer, what you&#39;ve got here is actually a *highly* unusual<br>case, where you want a pair of indices that you want to always point to<br>successive elements.  I do not know of any algorithm that would use this<br>except maybe bubblesort, and frankly I cannot see any reason to change<br>the standard library to support it.  Am I missing something?<br></p><p>&gt; Given the difficulties of statically detecting index invalidation, I<br>&gt; totally agree that (as you discussed in a section I&#39;ve snipped) we<br>&gt; can&#39;t statically prove indexes are safe. But we can, at the point<br>&gt; where we generate an index, easily check if that index is *currently*<br>&gt; valid. And it&#39;s something that most callers will have to do anyway if<br>&gt; we don&#39;t do it ourselves.<br></p><p>I really disagree with the assertion that most callers will need to do<br>this.  It certainly isn&#39;t a normal thing to do in any algorithm I know<br>of.  If you think I&#39;m wrong (not unheard of!), I suggest you code up the<br>method you&#39;ve requested and try to apply it in actual code that<br>manipulates indices, and show us how it improved the code.<br></p><p>&gt;&gt; We will change the index(_:stepsFrom:limitedBy:) overload to return<br>&gt;&gt; an optional, and we will see what other implications it has, and how<br>&gt;&gt; it fits into the rest of the system.<br>&gt;<br>&gt; I&#39;m glad to hear you&#39;ll evaluate this option, and I think it can give<br>&gt; us both what we want from this API.<br>&gt;<br>&gt; I think having the most high-level operations incorporate bounds<br>&gt; checks, while the lower-level ones don&#39;t, is a good compromise. <br></p><p>That may be the pattern you discern in Swift&#39;s bounds checks, but I just<br>want to be very clear that it&#39;s not a criterion we use to make the<br>determination.  I would love it if we had a more systematic way to make<br>the choice to insert bounds checks or not, but for now it remains<br>something of an art, trying to balance usability and performance<br>concerns.<br></p><p>&gt; If we encourage people to use `index(_:stepsFrom:limitedBy:)` unless<br>&gt; they know what they&#39;re doing, naïve clients will get an implicit<br>&gt; bounds check, while sophisticated, speed-sensitive clients can use<br>&gt; methods like `successor(of:)` which require them to check bounds<br>&gt; manually.<br></p><p>It&#39;s not a bounds check.  There are lots of ways to pass a limit that&#39;s<br>outside the bounds of the collection, and you can pass a limit that&#39;s in<br>the opposite direction from the offset.  If they happen to pass the<br>collection&#39;s endIndex and a positive offset, it degenerates to a bounds<br>check, but that&#39;s not what this method is for.<br></p><p>I will encourage people to use high-level algorithms where possible, so<br>they&#39;re not doing index manipulations directly.  Anyone doing low-level<br>index manipulations is probably implementing an algorithm, and I&#39;ll<br>encourage them to do whatever will be most efficient, and then test the<br>algorithm on some very strict models of Collection, that check<br>everything.  You can find some of these in the StdlibUnittest library in<br>the swift source tree.<br></p><p>&gt; (There might even be a case for offering bounds-checked<br>&gt; `successor(of:limitedBy:)` and `predecessor(of:limitedBy:)` methods to<br>&gt; give people bounds-checked alternatives to all three.)<br>&gt;<br>&gt;&gt; Thanks again, Brent.<br>&gt;<br>&gt; Thank you!<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 13, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 13, 2016, at 4:26 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Apr 12 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; In these cases, it would be better if the `successor(of:)` method was<br>&gt;&gt; designed in a way that acknowledged and encapsulated the bounds check<br>&gt;&gt; that is usually required when it is used:<br>&gt;&gt; <br>&gt;&gt; 	while let nextIndex = collection.successor(of: index) {<br>&gt;&gt; 		…<br>&gt;&gt; 		index = nextIndex<br>&gt;&gt; 	}<br>&gt; <br>&gt; I disagree; it doesn&#39;t make sense that I should have to check for nil<br>&gt; when I&#39;m not really interested in the end of the collection as in my<br>&gt; example above.  Many other nontrivial algorithms will have the same<br>&gt; characteristic.  If all you need is to loop through indices to the end,<br>&gt; there are lots of ways to do it.  <br>&gt; <br>&gt; Looking closer, what you&#39;ve got here is actually a *highly* unusual<br>&gt; case, where you want a pair of indices that you want to always point to<br>&gt; successive elements.  I do not know of any algorithm that would use this<br>&gt; except maybe bubblesort, and frankly I cannot see any reason to change<br>&gt; the standard library to support it.  Am I missing something?<br></p><p>Enumerating adjacent pairs from a sequence has its uses; when it’s a collection you can make the &quot;adjacent pairs” thing itself a collection, and a pair of adjacent indices from the source collection makes a natural choice for the non-end-index indices.<br></p><p>In this case I agree the language doesn’t need to change; just write the generic “adjacent pairs” thingy and then use it like so:<br></p><p>  // if you *really* wanted values:<br>  for (left,right) in collection.adjacentPairs() { …<br></p><p>  // if you *did* actually want indices;<br>  for (leftIndex,rightIndex) in collection.indices.adjacentPairs() {<br></p><p>…but all the uses I make of it for higher-level things than e.g. “algorithms” in the STL sense.<br></p><p>&gt; <br>&gt;&gt; Given the difficulties of statically detecting index invalidation, I<br>&gt;&gt; totally agree that (as you discussed in a section I&#39;ve snipped) we<br>&gt;&gt; can&#39;t statically prove indexes are safe. But we can, at the point<br>&gt;&gt; where we generate an index, easily check if that index is *currently*<br>&gt;&gt; valid. And it&#39;s something that most callers will have to do anyway if<br>&gt;&gt; we don&#39;t do it ourselves.<br>&gt; <br>&gt; I really disagree with the assertion that most callers will need to do<br>&gt; this.  It certainly isn&#39;t a normal thing to do in any algorithm I know<br>&gt; of.  If you think I&#39;m wrong (not unheard of!), I suggest you code up the<br>&gt; method you&#39;ve requested and try to apply it in actual code that<br>&gt; manipulates indices, and show us how it improved the code.<br>&gt; <br>&gt;&gt;&gt; We will change the index(_:stepsFrom:limitedBy:) overload to return<br>&gt;&gt;&gt; an optional, and we will see what other implications it has, and how<br>&gt;&gt;&gt; it fits into the rest of the system.<br>&gt;&gt; <br>&gt;&gt; I&#39;m glad to hear you&#39;ll evaluate this option, and I think it can give<br>&gt;&gt; us both what we want from this API.<br>&gt;&gt; <br>&gt;&gt; I think having the most high-level operations incorporate bounds<br>&gt;&gt; checks, while the lower-level ones don&#39;t, is a good compromise. <br>&gt; <br>&gt; That may be the pattern you discern in Swift&#39;s bounds checks, but I just<br>&gt; want to be very clear that it&#39;s not a criterion we use to make the<br>&gt; determination.  I would love it if we had a more systematic way to make<br>&gt; the choice to insert bounds checks or not, but for now it remains<br>&gt; something of an art, trying to balance usability and performance<br>&gt; concerns.<br>&gt; <br>&gt;&gt; If we encourage people to use `index(_:stepsFrom:limitedBy:)` unless<br>&gt;&gt; they know what they&#39;re doing, naïve clients will get an implicit<br>&gt;&gt; bounds check, while sophisticated, speed-sensitive clients can use<br>&gt;&gt; methods like `successor(of:)` which require them to check bounds<br>&gt;&gt; manually.<br>&gt; <br>&gt; It&#39;s not a bounds check.  There are lots of ways to pass a limit that&#39;s<br>&gt; outside the bounds of the collection, and you can pass a limit that&#39;s in<br>&gt; the opposite direction from the offset.  If they happen to pass the<br>&gt; collection&#39;s endIndex and a positive offset, it degenerates to a bounds<br>&gt; check, but that&#39;s not what this method is for.<br>&gt; <br>&gt; I will encourage people to use high-level algorithms where possible, so<br>&gt; they&#39;re not doing index manipulations directly.  Anyone doing low-level<br>&gt; index manipulations is probably implementing an algorithm, and I&#39;ll<br>&gt; encourage them to do whatever will be most efficient, and then test the<br>&gt; algorithm on some very strict models of Collection, that check<br>&gt; everything.  You can find some of these in the StdlibUnittest library in<br>&gt; the swift source tree.<br>&gt; <br>&gt;&gt; (There might even be a case for offering bounds-checked<br>&gt;&gt; `successor(of:limitedBy:)` and `predecessor(of:limitedBy:)` methods to<br>&gt;&gt; give people bounds-checked alternatives to all three.)<br>&gt;&gt; <br>&gt;&gt;&gt; Thanks again, Brent.<br>&gt;&gt; <br>&gt;&gt; Thank you!<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
