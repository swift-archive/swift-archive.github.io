<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  8, 2016 at 12:00:00pm</p></header><div class="content"><p>Draft here: https://gist.github.com/erica/a51a981ee0352235204692affa959307 &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307&gt;  Feedback solicited, both positive and negative. <br>We&#39;ve also got a related proposal about expanding ranges, which you can look at here (https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9 &lt;https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9&gt;)<br> but we want to float this one first.<br></p><p>Thanks, -- E<br></p><p><br></p><p>Proposal: SE-XXXX &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307/edit&gt;<br>Author(s): Xiaodi Wu &lt;https://github.com/xwu&gt;, Pyry Jahkola &lt;http://github.com/pyrtsa&gt;, Nate Cook &lt;http://github.com/natecook1000&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#introduction&gt;Introduction<br></p><p>We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br></p><p>This proposal was discussed on the Swift Evolution list in the Feature proposal: Range operator with step &lt;http://search.gmane.org/search.php?group=gmane.comp.lang.swift.evolution&amp;query=Feature+proposal%3A+Range+operator+with+step&gt; thread. (Direct link &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12801/focus=13051&gt; to original thread)<br></p><p> &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#motivation&gt;Motivation<br></p><p>Updating Range for Swift 3 offers a window of opportunity to simultaneously improve strides.<br></p><p>Under current Swift 3 plans, n.stride(to:/through:, by:) will be replaced with a standalone stride(from:, to:/through:, by:) function. We propose to replace this change with a method on ranges. Using a method reduces overall API surface area compared to free functions.<br></p><p>In its current incarnation, the standalone stride function uses confusing semantics. The current to implementation returns values in [start, end) and will never reach or get to end. The current through implementation returns values in [start, end]. It may never reach end and certainly never goes through that value. Our proposed method introduces simple, expected semantics that can be extended to both countable and continuous ranges, and to open and closed intervals (both half-open and fully-open).<br></p><p> &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#detail-design&gt;Detail Design<br></p><p>The striding(by:) method is called on ranges. When used with a positive step size, the count starts from the lower bound. With a negative step size, the count starts from the upper bound. These bounds apply regardless of whether they are inclusive or exclusive. <br></p><p>The following examples should cover all corner cases and include possible cases should Swift 3 introduce a full complement of open and closed ranges. The syntax for non-canonical range types is not fixed and can be discussed under separate cover.<br></p><p>(0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>(0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>(0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>(0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br></p><p>(0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>(0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>(0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>(0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br></p><p>(0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>(0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>(0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>(0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br></p><p>(0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>(0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>(0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>(0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>To reverse a stride, call reverse() on the results:<br></p><p>(0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>We note that striding by 0 should be always be a precondition failure.<br></p><p> &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#alternatives-considered&gt;Alternatives Considered<br></p><p>During the on-list discussion, we considered various scenarios that took closed/inclusive bounds into account or excluded open bounds for starting values. For example, we might have prohibited scenarios where multiple interpretations of an intended behavior might exist: is (0 ..&lt; 9).striding(by: -2) a precondition failure? We settled on the simplest, most straight-forward implementation involving the fewest compiler warnings and the lowest likelihood of precondition failures. We subscribe to the &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios more likely indicates bad language design than bad user comprehension.<br></p><p> &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#future-directions&gt;Future Directions<br></p><p>We intend to follow up with an expanded operator vocabulary that includes fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in the Detail Design section.<br></p><p>Upon adoption, the Swift community may consider expanding this approach to collection indices, for example:<br></p><p>let a = [8, 6, 7, 5, 3, 0, 9]<br>for e in a.striding(by: 3) {<br>    print(e) // 8, then 5, then 9<br>}<br>Striding offers a fundamental operation over collections. The consistent approach introduced in this proposal &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13936&gt; helps support the extension of stride semantics to collections.<br></p><p> &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#acknowlegements&gt;Acknowlegements<br></p><p>Thanks, Dave Abrahams, Matthew Judge<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/46fc5707/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April  9, 2016 at 01:00:00am</p></header><div class="content"><p>I am agnostic on a .striding() method, but I am strongly agains any suggestions of removing/replacing the global stride() function. The stride function does not pollute the global namespace as it is a universally useful construct (among others, for implementing classical iterating for loops), has its history in contemporary programming (comparable functions in languages like Python, R), and is IMO more readable and clear than a range with a striding method method. Furthermore, a stride is not a range — its a special sequence, while for ranges other rules apply. All in all, I don’t see why stride() and .striding() can’t coexist. <br></p><p>— Taras <br></p><p>P.S. As a side note, I would prefer if the stride() function be renamed sequence() or seq(), but thats just cosmetic personal preference. <br></p><p><br>&gt; On 08 Apr 2016, at 20:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Draft here: https://gist.github.com/erica/a51a981ee0352235204692affa959307 &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307&gt;  Feedback solicited, both positive and negative. <br>&gt; We&#39;ve also got a related proposal about expanding ranges, which you can look at here (https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9 &lt;https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9&gt;)<br>&gt;  but we want to float this one first.<br>&gt; <br>&gt; Thanks, -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307/edit&gt;<br>&gt; Author(s): Xiaodi Wu &lt;https://github.com/xwu&gt;, Pyry Jahkola &lt;http://github.com/pyrtsa&gt;, Nate Cook &lt;http://github.com/natecook1000&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#introduction&gt;Introduction<br>&gt; <br>&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the Feature proposal: Range operator with step &lt;http://search.gmane.org/search.php?group=gmane.comp.lang.swift.evolution&amp;query=Feature+proposal%3A+Range+operator+with+step&gt; thread. (Direct link &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12801/focus=13051&gt; to original thread)<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#motivation&gt;Motivation<br>&gt; <br>&gt; Updating Range for Swift 3 offers a window of opportunity to simultaneously improve strides.<br>&gt; <br>&gt; Under current Swift 3 plans, n.stride(to:/through:, by:) will be replaced with a standalone stride(from:, to:/through:, by:) function. We propose to replace this change with a method on ranges. Using a method reduces overall API surface area compared to free functions.<br>&gt; <br>&gt; In its current incarnation, the standalone stride function uses confusing semantics. The current to implementation returns values in [start, end) and will never reach or get to end. The current through implementation returns values in [start, end]. It may never reach end and certainly never goes through that value. Our proposed method introduces simple, expected semantics that can be extended to both countable and continuous ranges, and to open and closed intervals (both half-open and fully-open).<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#detail-design&gt;Detail Design<br>&gt; <br>&gt; The striding(by:) method is called on ranges. When used with a positive step size, the count starts from the lower bound. With a negative step size, the count starts from the upper bound. These bounds apply regardless of whether they are inclusive or exclusive. <br>&gt; <br>&gt; The following examples should cover all corner cases and include possible cases should Swift 3 introduce a full complement of open and closed ranges. The syntax for non-canonical range types is not fixed and can be discussed under separate cover.<br>&gt; <br>&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; <br>&gt; (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt; (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt; (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt; (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt; <br>&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt; (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt; (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt; (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt; <br>&gt; (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt; (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt; (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt; (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt; To reverse a stride, call reverse() on the results:<br>&gt; <br>&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt; We note that striding by 0 should be always be a precondition failure.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; During the on-list discussion, we considered various scenarios that took closed/inclusive bounds into account or excluded open bounds for starting values. For example, we might have prohibited scenarios where multiple interpretations of an intended behavior might exist: is (0 ..&lt; 9).striding(by: -2) a precondition failure? We settled on the simplest, most straight-forward implementation involving the fewest compiler warnings and the lowest likelihood of precondition failures. We subscribe to the &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios more likely indicates bad language design than bad user comprehension.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#future-directions&gt;Future Directions<br>&gt; <br>&gt; We intend to follow up with an expanded operator vocabulary that includes fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in the Detail Design section.<br>&gt; <br>&gt; Upon adoption, the Swift community may consider expanding this approach to collection indices, for example:<br>&gt; <br>&gt; let a = [8, 6, 7, 5, 3, 0, 9]<br>&gt; for e in a.striding(by: 3) {<br>&gt;     print(e) // 8, then 5, then 9<br>&gt; }<br>&gt; Striding offers a fundamental operation over collections. The consistent approach introduced in this proposal &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13936&gt; helps support the extension of stride semantics to collections.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#acknowlegements&gt;Acknowlegements<br>&gt; <br>&gt; Thanks, Dave Abrahams, Matthew Judge<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/5e054b81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 03:00:00pm</p></header><div class="content"><p>I agree with Taras that stride() and .striding() should coexist. <br></p><p>-Thorsten <br></p><p>&gt; Am 09.04.2016 um 01:01 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I am agnostic on a .striding() method, but I am strongly agains any suggestions of removing/replacing the global stride() function. The stride function does not pollute the global namespace as it is a universally useful construct (among others, for implementing classical iterating for loops), has its history in contemporary programming (comparable functions in languages like Python, R), and is IMO more readable and clear than a range with a striding method method. Furthermore, a stride is not a range — its a special sequence, while for ranges other rules apply. All in all, I don’t see why stride() and .striding() can’t coexist. <br>&gt; <br>&gt; — Taras <br>&gt; <br>&gt; P.S. As a side note, I would prefer if the stride() function be renamed sequence() or seq(), but thats just cosmetic personal preference. <br>&gt; <br>&gt; <br>&gt;&gt; On 08 Apr 2016, at 20:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Draft here: https://gist.github.com/erica/a51a981ee0352235204692affa959307  Feedback solicited, both positive and negative. <br>&gt;&gt; We&#39;ve also got a related proposal about expanding ranges, which you can look at here (https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9)<br>&gt;&gt;  but we want to float this one first.<br>&gt;&gt; <br>&gt;&gt; Thanks, -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author(s): Xiaodi Wu, Pyry Jahkola, Nate Cook, Erica Sadun<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the Feature proposal: Range operator with step thread. (Direct link to original thread)<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Updating Range for Swift 3 offers a window of opportunity to simultaneously improve strides.<br>&gt;&gt; <br>&gt;&gt; Under current Swift 3 plans, n.stride(to:/through:, by:) will be replaced with a standalone stride(from:, to:/through:, by:) function. We propose to replace this change with a method on ranges. Using a method reduces overall API surface area compared to free functions.<br>&gt;&gt; <br>&gt;&gt; In its current incarnation, the standalone stride function uses confusing semantics. The current to implementation returns values in [start, end) and will never reach or get to end. The current through implementation returns values in [start, end]. It may never reach end and certainly never goes through that value. Our proposed method introduces simple, expected semantics that can be extended to both countable and continuous ranges, and to open and closed intervals (both half-open and fully-open).<br>&gt;&gt; <br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; The striding(by:) method is called on ranges. When used with a positive step size, the count starts from the lower bound. With a negative step size, the count starts from the upper bound. These bounds apply regardless of whether they are inclusive or exclusive. <br>&gt;&gt; <br>&gt;&gt; The following examples should cover all corner cases and include possible cases should Swift 3 introduce a full complement of open and closed ranges. The syntax for non-canonical range types is not fixed and can be discussed under separate cover.<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt; (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;&gt; (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;&gt; (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt;&gt; (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt;&gt; To reverse a stride, call reverse() on the results:<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;&gt; We note that striding by 0 should be always be a precondition failure.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; During the on-list discussion, we considered various scenarios that took closed/inclusive bounds into account or excluded open bounds for starting values. For example, we might have prohibited scenarios where multiple interpretations of an intended behavior might exist: is (0 ..&lt; 9).striding(by: -2) a precondition failure? We settled on the simplest, most straight-forward implementation involving the fewest compiler warnings and the lowest likelihood of precondition failures. We subscribe to the &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios more likely indicates bad language design than bad user comprehension.<br>&gt;&gt; <br>&gt;&gt; Future Directions<br>&gt;&gt; <br>&gt;&gt; We intend to follow up with an expanded operator vocabulary that includes fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in the Detail Design section.<br>&gt;&gt; <br>&gt;&gt; Upon adoption, the Swift community may consider expanding this approach to collection indices, for example:<br>&gt;&gt; <br>&gt;&gt; let a = [8, 6, 7, 5, 3, 0, 9]<br>&gt;&gt; for e in a.striding(by: 3) {<br>&gt;&gt;     print(e) // 8, then 5, then 9<br>&gt;&gt; }<br>&gt;&gt; Striding offers a fundamental operation over collections. The consistent approach introduced in this proposal helps support the extension of stride semantics to collections.<br>&gt;&gt; <br>&gt;&gt; Acknowlegements<br>&gt;&gt; <br>&gt;&gt; Thanks, Dave Abrahams, Matthew Judge<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/a005d4cc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br></p><p>I take it that we&#39;re taking an incremental approach here, and further steps like:<br></p><p>* Adding new range operators<br>* Making all collections Strideable<br>* Unifying Range and IntervalType so we can stride over non-integers again<br>* Correctly striding over floats<br></p><p>Are out of scope for this particular proposal.<br></p><p>&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br></p><p>I favor `stride(over: 0...9, by: 2)`—or perhaps even `Stride(over: 0...9, by: 2)`, where `Stride` is a replacement for `StrideTo` and `StrideThrough`—over a `striding(by:)` method.  The precedence of the range-construction operators makes calling methods on a Range unusually difficult and ugly. (And I don&#39;t think adjusting the precedence is a realistic option; that would break things like `0..&lt;array.count`.) Passing the Range as a parameter instead evades this issue.<br></p><p>&gt; To reverse a stride, call reverse() on the results:<br>&gt; <br>&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br></p><p>Does this have different behavior from `(0...9).striding(by: -2)`? (I know it probably has a different implementation.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 09:00:00am</p></header><div class="content"><p>On Sat, Apr 9, 2016 at 1:00 AM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br>&gt;<br>&gt; I take it that we&#39;re taking an incremental approach here,<br></p><p>Yes, other proposals are on their way to complement this one.<br></p><p>&gt; and further steps like:<br>&gt;<br>&gt; * Adding new range operators<br></p><p>There&#39;s a draft proposal being worked on here:<br>https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9<br>We&#39;re still working on text to give more details on how to implement,<br>stronger use cases, etc.<br></p><p>&gt; * Making all collections Strideable<br></p><p>This merits additional discussion as to what it means to stride.<br></p><p>&gt; * Unifying Range and IntervalType so we can stride over non-integers again<br></p><p>This would be Dave A&#39;s work, which is nearing completion but hasn&#39;t<br>yet been reviewed. You can inspect the ongoing work in the<br>swift-3-indexing-model branch.<br></p><p>&gt; * Correctly striding over floats<br></p><p>Conflicting opinions exist as to whether to roll that into this<br>proposal or to write a separate one on that topic.<br></p><p>&gt; Are out of scope for this particular proposal.<br>&gt;<br>&gt;&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;<br>&gt; I favor `stride(over: 0...9, by: 2)`—or perhaps even `Stride(over: 0...9, by: 2)`, where `Stride` is a replacement for `StrideTo` and `StrideThrough`—over a `striding(by:)` method.  The precedence of the range-construction operators makes calling methods on a Range unusually difficult and ugly. (And I don&#39;t think adjusting the precedence is a realistic option; that would break things like `0..&lt;array.count`.) Passing the Range as a parameter instead evades this issue.<br></p><p>This is an interesting suggestion. One argument for abandoning the<br>stride(from:to:by:) notation was that what &quot;to&quot; or &quot;through&quot; meant<br>could be misconstrued. This neatly solves that issue. There is still a<br>preference for methods over free functions, though.<br></p><p>&gt;&gt; To reverse a stride, call reverse() on the results:<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;<br>&gt; Does this have different behavior from `(0...9).striding(by: -2)`? (I know it probably has a different implementation.)<br></p><p>It does. We propose `(0...9).striding(by: -2) == [9, 7, 5, 3, 1]`.<br></p><p>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>April  8, 2016 at 09:00:00pm</p></header><div class="content"><p>Le 8 avr. 2016 à 14:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br></p><p>The above reads wrong to me. The expression has to be read differently depending on the tinny detail that is the sign of the step that comes last:<br></p><p>* positive step: from 0 to 9 striding by 2<br>* negative step: to 0 from 9 striding by -2<br></p><p>Am I the only one thinking it&#39;s a bit too clever to swap the start and stop parts like this?<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>April  9, 2016 at 04:00:00am</p></header><div class="content"><p>Just as note, i think the sintax should be:<br></p><p>0...9<br>0..&lt;9<br>0&gt;..9<br>0&gt;.&lt;9<br></p><p>Because the intention is produce a number bigger than 0 (start). So greater<br>than zero less than nine.<br></p><p><br></p><p>Em sex, 8 de abr de 2016 22:50, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Le 8 avr. 2016 à 14:37, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;<br>&gt; The above reads wrong to me. The expression has to be read differently<br>&gt; depending on the tinny detail that is the sign of the step that comes last:<br>&gt;<br>&gt; * positive step: from 0 to 9 striding by 2<br>&gt; * negative step: to 0 from 9 striding by -2<br>&gt;<br>&gt; Am I the only one thinking it&#39;s a bit too clever to swap the start and<br>&gt; stop parts like this?<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/f7288838/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 09:00:00am</p></header><div class="content"><p>On Sat, Apr 9, 2016 at 5:44 AM, Wallacy via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Just as note, i think the sintax should be:<br>&gt;<br>&gt; 0...9<br>&gt; 0..&lt;9<br>&gt; 0&gt;..9<br>&gt; 0&gt;.&lt;9<br>&gt;<br>&gt; Because the intention is produce a number bigger than 0 (start). So greater<br>&gt; than zero less than nine.<br></p><p>That&#39;s not typically how it&#39;s written in math. When x is between two<br>values a and b, it&#39;s written a &lt; x &lt; b. The pointy end of the symbol<br>faces the smaller value. Here, 0 is the smaller value, so the pointy<br>end must face it, as in `0 &lt;.. 9` and `0 &lt;.&lt; 9`.<br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Em sex, 8 de abr de 2016 22:50, Michel Fortin via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt;<br>&gt;&gt; Le 8 avr. 2016 à 14:37, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt;<br>&gt;&gt; The above reads wrong to me. The expression has to be read differently<br>&gt;&gt; depending on the tinny detail that is the sign of the step that comes last:<br>&gt;&gt;<br>&gt;&gt; * positive step: from 0 to 9 striding by 2<br>&gt;&gt; * negative step: to 0 from 9 striding by -2<br>&gt;&gt;<br>&gt;&gt; Am I the only one thinking it&#39;s a bit too clever to swap the start and<br>&gt;&gt; stop parts like this?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Michel Fortin<br>&gt;&gt; https://michelf.ca<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 9, 2016, at 3:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Sat, Apr 9, 2016 at 5:44 AM, Wallacy via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Just as note, i think the sintax should be:<br>&gt;&gt; <br>&gt;&gt; 0...9<br>&gt;&gt; 0..&lt;9<br>&gt;&gt; 0&gt;..9<br>&gt;&gt; 0&gt;.&lt;9<br>&gt;&gt; <br>&gt;&gt; Because the intention is produce a number bigger than 0 (start). So greater<br>&gt;&gt; than zero less than nine.<br>&gt; <br>&gt; That&#39;s not typically how it&#39;s written in math. When x is between two<br>&gt; values a and b, it&#39;s written a &lt; x &lt; b. The pointy end of the symbol<br>&gt; faces the smaller value. Here, 0 is the smaller value, so the pointy<br>&gt; end must face it, as in `0 &lt;.. 9` and `0 &lt;.&lt; 9`.<br></p><p>Exactly. Up until just a few days ago, I would’ve agreed with Wallacy. I thought the range operators, “a … b” and “a ..&lt; b”, were supposed to represent “[a b]” and “[a b)”. Once the topic came up here, I realized that they were intended to approximate the notation “a ≤ x ≤ b” and “a ≤ x &lt; b”, which visually speaking makes a lot more sense to me. With that in mind, “a &lt;.. b” and “a &lt;.&lt; b” are the correct ways to extend the notation. IMHO, anyway.<br></p><p>- Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>April 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 9, 2016, at 1:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Apr 9, 2016 at 5:44 AM, Wallacy via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Just as note, i think the sintax should be:<br>&gt;&gt; <br>&gt;&gt; 0...9<br>&gt;&gt; 0..&lt;9<br>&gt;&gt; 0&gt;..9<br>&gt;&gt; 0&gt;.&lt;9<br></p><p>I agree with this. <br>&gt;&gt; <br>&gt;&gt; Because the intention is produce a number bigger than 0 (start). So greater<br>&gt;&gt; than zero less than nine.<br>&gt; <br>&gt; That&#39;s not typically how it&#39;s written in math. When x is between two<br>&gt; values a and b, it&#39;s written a &lt; x &lt; b. The pointy end of the symbol<br>&gt; faces the smaller value. Here, 0 is the smaller value, so the pointy<br>&gt; end must face it, as in `0 &lt;.. 9` and `0 &lt;.&lt; 9`.<br></p><p>I don&#39;t agree with this and I bet this is why Perl uses ^ for that purpose. <br></p><p>Including these not yet proposed operators will be distracting to the review of the proposal. These discussions would be better served as their own proposed proposal.  <br>I recommend removing any mention of them from this proposal.<br></p><p><br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Em sex, 8 de abr de 2016 22:50, Michel Fortin via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 8 avr. 2016 à 14:37, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The above reads wrong to me. The expression has to be read differently<br>&gt;&gt;&gt; depending on the tinny detail that is the sign of the step that comes last:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * positive step: from 0 to 9 striding by 2<br>&gt;&gt;&gt; * negative step: to 0 from 9 striding by -2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am I the only one thinking it&#39;s a bit too clever to swap the start and<br>&gt;&gt;&gt; stop parts like this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Michel Fortin<br>&gt;&gt;&gt; https://michelf.ca<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 09:00:00am</p></header><div class="content"><p>On Sat, Apr 9, 2016 at 2:49 AM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; Le 8 avr. 2016 à 14:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;<br>&gt; The above reads wrong to me. The expression has to be read differently depending on the tinny detail that is the sign of the step that comes last:<br>&gt;<br>&gt; * positive step: from 0 to 9 striding by 2<br>&gt; * negative step: to 0 from 9 striding by -2<br>&gt;<br>&gt; Am I the only one thinking it&#39;s a bit too clever to swap the start and stop parts like this?<br></p><p>The issue here is that ranges both do and don&#39;t have a direction.<br>0...9 is supposed to represent all numbers between and including 0 and<br>9 (agnostic of direction). However, when you have `for i in 0...9 {<br>code }`, the sequence very much goes from 0 through 9 and not the<br>other way round.<br></p><p>Note that it&#39;s not possible to write 9...0. Once that is clear, it&#39;s<br>fairly intuitive (IMO) to look to the stride size for indicating the<br>direction in which we stride, since that is the only other value there<br>is. Thus, we propose using a negative stride size means stride<br>backwards through the range.<br></p><p>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>April  9, 2016 at 11:00:00am</p></header><div class="content"><p>Le 9 avr. 2016 à 4:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt; Note that it&#39;s not possible to write 9...0. Once that is clear, it&#39;s<br>&gt; fairly intuitive (IMO) to look to the stride size for indicating the<br>&gt; direction in which we stride, since that is the only other value there<br>&gt; is.<br></p><p>I know it&#39;s not possible to write 9...0. But I disagree that it&#39;s intuitive that a negative step value would reverse the start and stop values. I think to be consistent it should trap, like with a step of zero, because you can&#39;t go from 0 to 9 with a negative step.<br></p><p>It&#39;s especially important to realize that if the step value is a variable you will not be able to know which is the start value and which is the stop criterion by quickly inspecting the code because the sign of the step is hidden away in the value of that variable.<br></p><p>In other words, whether the loop begins at the start or the end of the range becomes a runtime decision. There is a branch in the generator that swaps the start and end values depending on that sign. If the step value is not a literal constant, inlining might not be able to elide that branch. Add another branch to make it trap when given a step of zero. And if it traps when the range is invalid (such as in 9...0) then that&#39;s another branch to check this when you form the range. That&#39;s 3 branches needed before even starting the loop.<br></p><p>Perhaps I&#39;m just complaining about loosing the good performance characteristics of a C-style for loop. In the debate about this it was stated many times that `stride` could be used and would have the same performance. Is that promise about to be broken now?<br></p><p>On a final note: it&#39;s common, for me at least, to enter a loop with the start position already higher than the stop criterion, essentially doing something like `stride(from: 10, to 5, by 1)` which results in the loop being skipped. Translated into this new syntax, it&#39;d become something like `(10...5).striding(by: 1)` which of course will trap because of the invalid range, thus necessitating an extra `if` to check for this. That clutters the code and adds even more branches. Perhaps the solution to this is to not trap on ranges with a negative length, although that&#39;s probably going to cause other headaches elsewhere.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 05:00:00pm</p></header><div class="content"><p>The sign of the stride size is already (in the current version of Swift)<br>evaluated in the stride generator/iterator; as written, it is evaluated<br>every time next() is called, but of course that is optimized away when<br>possible. What we are proposing adds no additional logic to the loop. I<br>can&#39;t see a reason why inserting a line to trap on a negative stride size<br>would show any measurable improvement in performance compared to inserting<br>a line to use upperBound for start and lowerBound for end instead of vice<br>versa when initializing an instance of StrideTo/StrideThrough. This would<br>not be a branch in StrideToIterator.next(), nor even in<br>StrideToIterator.init(), but rather in StrideTo.init() or even<br>striding(by:). Rest assured that degrading performance for the most common<br>use case would be unacceptable (at least to me).<br></p><p>It is already the case that your code needs to account for the sign of the<br>stride size. Currently, not doing so runs the risk of unintentionally<br>creating an empty sequence. In our proposal, the result of using a stride<br>size of unintended sign would differ but the fact that you need to account<br>for it is unchanged. We are not proposing trapping on negative stride sizes<br>nor allowing ranges such as 9...0.<br>On Sat, Apr 9, 2016 at 4:53 PM Michel Fortin &lt;michel.fortin at michelf.ca&gt;<br>wrote:<br></p><p>&gt; Le 9 avr. 2016 à 4:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt; &gt; Note that it&#39;s not possible to write 9...0. Once that is clear, it&#39;s<br>&gt; &gt; fairly intuitive (IMO) to look to the stride size for indicating the<br>&gt; &gt; direction in which we stride, since that is the only other value there<br>&gt; &gt; is.<br>&gt;<br>&gt; I know it&#39;s not possible to write 9...0. But I disagree that it&#39;s<br>&gt; intuitive that a negative step value would reverse the start and stop<br>&gt; values. I think to be consistent it should trap, like with a step of zero,<br>&gt; because you can&#39;t go from 0 to 9 with a negative step.<br>&gt;<br>&gt; It&#39;s especially important to realize that if the step value is a variable<br>&gt; you will not be able to know which is the start value and which is the stop<br>&gt; criterion by quickly inspecting the code because the sign of the step is<br>&gt; hidden away in the value of that variable.<br>&gt;<br>&gt; In other words, whether the loop begins at the start or the end of the<br>&gt; range becomes a runtime decision. There is a branch in the generator that<br>&gt; swaps the start and end values depending on that sign. If the step value is<br>&gt; not a literal constant, inlining might not be able to elide that branch.<br>&gt; Add another branch to make it trap when given a step of zero. And if it<br>&gt; traps when the range is invalid (such as in 9...0) then that&#39;s another<br>&gt; branch to check this when you form the range. That&#39;s 3 branches needed<br>&gt; before even starting the loop.<br>&gt;<br>&gt; Perhaps I&#39;m just complaining about loosing the good performance<br>&gt; characteristics of a C-style for loop. In the debate about this it was<br>&gt; stated many times that `stride` could be used and would have the same<br>&gt; performance. Is that promise about to be broken now?<br>&gt;<br>&gt; On a final note: it&#39;s common, for me at least, to enter a loop with the<br>&gt; start position already higher than the stop criterion, essentially doing<br>&gt; something like `stride(from: 10, to 5, by 1)` which results in the loop<br>&gt; being skipped. Translated into this new syntax, it&#39;d become something like<br>&gt; `(10...5).striding(by: 1)` which of course will trap because of the invalid<br>&gt; range, thus necessitating an extra `if` to check for this. That clutters<br>&gt; the code and adds even more branches. Perhaps the solution to this is to<br>&gt; not trap on ranges with a negative length, although that&#39;s probably going<br>&gt; to cause other headaches elsewhere.<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/f9e8eeac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>April  9, 2016 at 05:00:00pm</p></header><div class="content"><p>Le 9 avr. 2016 à 13:23, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br></p><p>&gt; The sign of the stride size is already (in the current version of Swift) evaluated in the stride generator/iterator; as written, it is evaluated every time next() is called, but of course that is optimized away when possible.<br></p><p>You&#39;re right. I had to check the code before I could believe it. How terrible. There&#39;s two branches per loop iteration:<br>https://github.com/apple/swift/blob/swift-2.2-branch/stdlib/public/core/Stride.swift#L136<br></p><p>I know the optimizer is probably going to be good enough to elide the first branch in most circumstances... but still, relying on the optimizer doing its magic does not seem very wise. It&#39;s not like you&#39;ll get a warning when that branch is not elided.<br></p><p>&gt; What we are proposing adds no additional logic to the loop. I can&#39;t see a reason why inserting a line to trap on a negative stride size would show any measurable improvement in performance compared to inserting a line to use upperBound for start and lowerBound for end instead of vice versa when initializing an instance of StrideTo/StrideThrough.<br></p><p>That suggestion was based on consistency more than performance. The first part of my last email was *not* about performance. I was saying that semantically it would make more sense to me if it did the same thing as zero. &quot;I think to be consistent it should trap, like with a step of zero, because you can&#39;t go from 0 to 9 with a negative step.&quot; I guess we can agree to disagree on this.<br></p><p>Performance-wise, it would actually be one less branch at the start of the loop since you can fold it with the zero case using `predcondition(stride &gt; 0)`. And I now realize that it&#39;d make it possible to eliminate that dubious extra branch in `next()`, so that&#39;s one giant reason to do it.<br></p><p>I guess my main issue with `stride` as it is today is that it tries to be clever in the edge cases instead of just giving you an infinite sequence. Reversing the start and stop boundaries when the step is negative is just a way of making it even more clever. So perhaps it fits with the current direction, but it does not suit me.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  9, 2016 at 10:00:00am</p></header><div class="content"><p>While I’m in favour of the basic idea I think the operator selection is too complex, and I’m not sure about the need for negative strides. Really all I want are the following:<br></p><p>	(0 ... 6).striding(by: 2)	// [0, 2, 4, 6]		x from 0 to 6<br>	(0 ..&lt; 6).striding(by: 2)	// [0, 2, 4]		x from 0 while &lt;6<br>	(6 ... 0).striding(by: 2)	// [6, 4, 2, 0]		x from 6 to 0<br>	(6 ..&gt; 0).striding(by: 2)	// [6, 4, 2]		x from 6 while &gt;0<br></p><p>Everything else should be coverable either by flipping the order, or using .reverse(). The main advantage is that there’s only one new operator to clarify the 6 ..&gt; 0 case, though you could always just reuse the existing operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br></p><p>I dunno, I just don’t think that introducing tons of new operators is going to simplify things, and could lead to way more mistakes in practice; the only mistake above would be putting the indices in the wrong order and accidentally reversing the result.<br></p><p>Also, I’m against negative strides; while they could be useful for convenience (avoid the need for .reverse or flipping values) I’m just not sure that it makes sense. To me a stride is a distance, thus absolute, what matters is the direction of the range. Naturally we’d need ranges with a direction, but with collections requiring it to be in a particular order (or ignoring it and flipping where necessary).<br></p><p>&gt; On 8 Apr 2016, at 19:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Draft here: https://gist.github.com/erica/a51a981ee0352235204692affa959307 &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307&gt;  Feedback solicited, both positive and negative. <br>&gt; We&#39;ve also got a related proposal about expanding ranges, which you can look at here (https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9 &lt;https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9&gt;)<br>&gt;  but we want to float this one first.<br>&gt; <br>&gt; Thanks, -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307/edit&gt;<br>&gt; Author(s): Xiaodi Wu &lt;https://github.com/xwu&gt;, Pyry Jahkola &lt;http://github.com/pyrtsa&gt;, Nate Cook &lt;http://github.com/natecook1000&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#introduction&gt;Introduction<br>&gt; <br>&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the Feature proposal: Range operator with step &lt;http://search.gmane.org/search.php?group=gmane.comp.lang.swift.evolution&amp;query=Feature+proposal%3A+Range+operator+with+step&gt; thread. (Direct link &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12801/focus=13051&gt; to original thread)<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#motivation&gt;Motivation<br>&gt; <br>&gt; Updating Range for Swift 3 offers a window of opportunity to simultaneously improve strides.<br>&gt; <br>&gt; Under current Swift 3 plans, n.stride(to:/through:, by:) will be replaced with a standalone stride(from:, to:/through:, by:) function. We propose to replace this change with a method on ranges. Using a method reduces overall API surface area compared to free functions.<br>&gt; <br>&gt; In its current incarnation, the standalone stride function uses confusing semantics. The current to implementation returns values in [start, end) and will never reach or get to end. The current through implementation returns values in [start, end]. It may never reach end and certainly never goes through that value. Our proposed method introduces simple, expected semantics that can be extended to both countable and continuous ranges, and to open and closed intervals (both half-open and fully-open).<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#detail-design&gt;Detail Design<br>&gt; <br>&gt; The striding(by:) method is called on ranges. When used with a positive step size, the count starts from the lower bound. With a negative step size, the count starts from the upper bound. These bounds apply regardless of whether they are inclusive or exclusive. <br>&gt; <br>&gt; The following examples should cover all corner cases and include possible cases should Swift 3 introduce a full complement of open and closed ranges. The syntax for non-canonical range types is not fixed and can be discussed under separate cover.<br>&gt; <br>&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; <br>&gt; (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt; (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt; (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt; (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt; <br>&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt; (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt; (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt; (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt; <br>&gt; (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt; (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt; (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt; (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt; To reverse a stride, call reverse() on the results:<br>&gt; <br>&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt; We note that striding by 0 should be always be a precondition failure.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; During the on-list discussion, we considered various scenarios that took closed/inclusive bounds into account or excluded open bounds for starting values. For example, we might have prohibited scenarios where multiple interpretations of an intended behavior might exist: is (0 ..&lt; 9).striding(by: -2) a precondition failure? We settled on the simplest, most straight-forward implementation involving the fewest compiler warnings and the lowest likelihood of precondition failures. We subscribe to the &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios more likely indicates bad language design than bad user comprehension.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#future-directions&gt;Future Directions<br>&gt; <br>&gt; We intend to follow up with an expanded operator vocabulary that includes fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in the Detail Design section.<br>&gt; <br>&gt; Upon adoption, the Swift community may consider expanding this approach to collection indices, for example:<br>&gt; <br>&gt; let a = [8, 6, 7, 5, 3, 0, 9]<br>&gt; for e in a.striding(by: 3) {<br>&gt;     print(e) // 8, then 5, then 9<br>&gt; }<br>&gt; Striding offers a fundamental operation over collections. The consistent approach introduced in this proposal &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13936&gt; helps support the extension of stride semantics to collections.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#acknowlegements&gt;Acknowlegements<br>&gt; <br>&gt; Thanks, Dave Abrahams, Matthew Judge<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/5bb933cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 09:00:00am</p></header><div class="content"><p>I agree with 90% of your comment.<br></p><p>But, ranges are useful for more than just stride, and so I would say it<br>doesn&#39;t make sense to have an intrinsic direction for Range, which<br>pointedly has lowerBound and upperBound but not start and end. For sample,<br>there shouldn&#39;t be (0...9).contains(1) and (9...0).contains(1).<br></p><p>It&#39;s the *traversal* of the range by a stride that has a direction, and<br>thus the direction should be specified for a particular stride.<br></p><p>Similarly, the rationale for completing the range operators is for the uses<br>of range that include but are not limited to just stride. If it were just<br>for stride, then four range operators is three too many.<br>On Sat, Apr 9, 2016 at 10:33 AM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt; While I’m in favour of the basic idea I think the operator selection is<br>&gt; too complex, and I’m not sure about the need for negative strides. Really<br>&gt; all I want are the following:<br>&gt;<br>&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt; (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt; (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;<br>&gt; Everything else should be coverable either by flipping the order, or using<br>&gt; .reverse(). The main advantage is that there’s only one new operator to<br>&gt; clarify the 6 ..&gt; 0 case, though you could always just reuse the existing<br>&gt; operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt;<br>&gt; I dunno, I just don’t think that introducing tons of new operators is<br>&gt; going to simplify things, and could lead to way more mistakes in practice;<br>&gt; the only mistake above would be putting the indices in the wrong order and<br>&gt; accidentally reversing the result.<br>&gt;<br>&gt; Also, I’m against negative strides; while they could be useful for<br>&gt; convenience (avoid the need for .reverse or flipping values) I’m just not<br>&gt; sure that it makes sense. To me a stride is a distance, thus absolute, what<br>&gt; matters is the direction of the range. Naturally we’d need ranges with a<br>&gt; direction, but with collections requiring it to be in a particular order<br>&gt; (or ignoring it and flipping where necessary).<br>&gt;<br>&gt; On 8 Apr 2016, at 19:37, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Draft here: https://gist.github.com/erica/a51a981ee0352235204692affa959307  Feedback<br>&gt; solicited, both positive and negative.<br>&gt; We&#39;ve also got a related proposal about expanding ranges, which you can<br>&gt; look at here (<br>&gt; https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9)<br>&gt;  but we want to float this one first.<br>&gt;<br>&gt; Thanks, -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307/edit&gt;<br>&gt;    - Author(s): Xiaodi Wu &lt;https://github.com/xwu&gt;, Pyry Jahkola<br>&gt;    &lt;http://github.com/pyrtsa&gt;, Nate Cook &lt;http://github.com/natecook1000&gt;<br>&gt;    , Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range<br>&gt;  type.<br>&gt;<br>&gt; This proposal was discussed on the Swift Evolution list in the Feature<br>&gt; proposal: Range operator with step<br>&gt; &lt;http://search.gmane.org/search.php?group=gmane.comp.lang.swift.evolution&amp;query=Feature+proposal%3A+Range+operator+with+step&gt; thread.<br>&gt; (Direct link<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12801/focus=13051&gt; to<br>&gt; original thread)<br>&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Updating Range for Swift 3 offers a window of opportunity to<br>&gt; simultaneously improve strides.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Under current Swift 3 plans, n.stride(to:/through:, by:) will be<br>&gt;    replaced with a standalone stride(from:, to:/through:, by:) function.<br>&gt;    We propose to replace this change with a method on ranges. Using a method<br>&gt;    reduces overall API surface area compared to free functions.<br>&gt;    -<br>&gt;<br>&gt;    In its current incarnation, the standalone stride function uses<br>&gt;    confusing semantics. The current to implementation returns values in<br>&gt;    *[start, end)* and will never reach or get *to* end. The current<br>&gt;    through implementation returns values in *[start, end]*. It may never<br>&gt;    reach end and certainly never goes *through* that value. Our proposed<br>&gt;    method introduces simple, expected semantics that can be extended to both<br>&gt;    countable and continuous ranges, and to open and closed intervals (both<br>&gt;    half-open and fully-open).<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#detail-design&gt;Detail<br>&gt; Design<br>&gt;<br>&gt; The striding(by:) method is called on ranges. When used with a positive<br>&gt; step size, the count starts from the lower bound. With a negative step<br>&gt; size, the count starts from the upper bound. These bounds apply regardless<br>&gt; of whether they are inclusive or exclusive.<br>&gt;<br>&gt; The following examples should cover all corner cases and include possible<br>&gt; cases should Swift 3 introduce a full complement of open and closed ranges.<br>&gt; The syntax for non-canonical range types is not fixed and can be discussed<br>&gt; under separate cover.<br>&gt;<br>&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;<br>&gt; (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt; (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt; (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt; (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt;<br>&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt; (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt; (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt; (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;<br>&gt; (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt; (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt; (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt; (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt;<br>&gt; To reverse a stride, call reverse() on the results:<br>&gt;<br>&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;<br>&gt; We note that striding by 0 should be always be a precondition failure.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt; During the on-list discussion, we considered various scenarios that took<br>&gt; closed/inclusive bounds into account or excluded open bounds for starting<br>&gt; values. For example, we might have prohibited scenarios where multiple<br>&gt; interpretations of an intended behavior might exist: is (0 ..&lt;<br>&gt; 9).striding(by: -2) a precondition failure? We settled on the simplest,<br>&gt; most straight-forward implementation involving the fewest compiler warnings<br>&gt; and the lowest likelihood of precondition failures. We subscribe to the<br>&gt; &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios<br>&gt; more likely indicates bad language design than bad user comprehension.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#future-directions&gt;Future<br>&gt; Directions<br>&gt;<br>&gt; We intend to follow up with an expanded operator vocabulary that includes<br>&gt; fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open<br>&gt; ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in the<br>&gt; Detail Design section.<br>&gt;<br>&gt; Upon adoption, the Swift community may consider expanding this approach to<br>&gt; collection indices, for example:<br>&gt;<br>&gt; let a = [8, 6, 7, 5, 3, 0, 9]<br>&gt; for e in a.striding(by: 3) {<br>&gt;     print(e) // 8, then 5, then 9<br>&gt; }<br>&gt;<br>&gt; Striding offers a fundamental operation over collections. The consistent<br>&gt; approach introduced in this proposal<br>&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13936&gt; helps<br>&gt; support the extension of stride semantics to collections.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#acknowlegements&gt;<br>&gt; Acknowlegements<br>&gt; Thanks, Dave Abrahams, Matthew Judge<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/07340179/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  9, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 9 Apr 2016, at 10:50, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; But, ranges are useful for more than just stride, and so I would say it doesn&#39;t make sense to have an intrinsic direction for Range, which pointedly has lowerBound and upperBound but not start and end. For sample, there shouldn&#39;t be (0...9).contains(1) and (9...0).contains(1).<br></p><p>While I can appreciate that, I wonder if it’s really that important that 0…9 and 9…0 are identical? As long as we can be clear on which direction of range we want to generate (so probably still need two new operators), can tell what the direction is, and can convert between them if we need to for some reason (reverse should be fine for that?), then I think we’re okay.<br></p><p>i.e- 9 … 0 would still cause an error at compile or run-time, we’d have some other operator for doing that, not sure what, plus 9 ..&gt; 0, with both explicitly creating ranges in the reverse direction to avoid mistakes with the order or for computed indices. When it comes down to it the current Range has an implicitly forward direction, so I don’t see the problem with having the same in reverse personally.<br></p><p><br>I dunno, at the very least we might want to consider overloading the striding method as .striding(forwardBy:) and .striding(backwardBy:) or something similar, each taking a positive value of some kind to help avoid mistakes in cases where the stride size is computed rather than constant, this would make it more explicit at least.<br></p><p>&gt; On Sat, Apr 9, 2016 at 10:33 AM Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt; While I’m in favour of the basic idea I think the operator selection is too complex, and I’m not sure about the need for negative strides. Really all I want are the following:<br>&gt; <br>&gt; 	(0 ... 6).striding(by: 2)	// [0, 2, 4, 6]		x from 0 to 6<br>&gt; 	(0 ..&lt; 6).striding(by: 2)	// [0, 2, 4]		x from 0 while &lt;6<br>&gt; 	(6 ... 0).striding(by: 2)	// [6, 4, 2, 0]		x from 6 to 0<br>&gt; 	(6 ..&gt; 0).striding(by: 2)	// [6, 4, 2]		x from 6 while &gt;0<br>&gt; <br>&gt; Everything else should be coverable either by flipping the order, or using .reverse(). The main advantage is that there’s only one new operator to clarify the 6 ..&gt; 0 case, though you could always just reuse the existing operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt; <br>&gt; I dunno, I just don’t think that introducing tons of new operators is going to simplify things, and could lead to way more mistakes in practice; the only mistake above would be putting the indices in the wrong order and accidentally reversing the result.<br>&gt; <br>&gt; Also, I’m against negative strides; while they could be useful for convenience (avoid the need for .reverse or flipping values) I’m just not sure that it makes sense. To me a stride is a distance, thus absolute, what matters is the direction of the range. Naturally we’d need ranges with a direction, but with collections requiring it to be in a particular order (or ignoring it and flipping where necessary).<br>&gt; <br>&gt; <br>&gt;&gt; On 8 Apr 2016, at 19:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; Draft here: https://gist.github.com/erica/a51a981ee0352235204692affa959307 &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307&gt;  Feedback solicited, both positive and negative. <br>&gt;&gt; We&#39;ve also got a related proposal about expanding ranges, which you can look at here (https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9 &lt;https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9&gt;)<br>&gt;&gt;  but we want to float this one first.<br>&gt;&gt; <br>&gt;&gt; Thanks, -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Proposal: SE-XXXX &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307/edit&gt;<br>&gt;&gt; Author(s): Xiaodi Wu &lt;https://github.com/xwu&gt;, Pyry Jahkola &lt;http://github.com/pyrtsa&gt;, Nate Cook &lt;http://github.com/natecook1000&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range type.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the Feature proposal: Range operator with step &lt;http://search.gmane.org/search.php?group=gmane.comp.lang.swift.evolution&amp;query=Feature+proposal%3A+Range+operator+with+step&gt; thread. (Direct link &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12801/focus=13051&gt; to original thread)<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Updating Range for Swift 3 offers a window of opportunity to simultaneously improve strides.<br>&gt;&gt; <br>&gt;&gt; Under current Swift 3 plans, n.stride(to:/through:, by:) will be replaced with a standalone stride(from:, to:/through:, by:) function. We propose to replace this change with a method on ranges. Using a method reduces overall API surface area compared to free functions.<br>&gt;&gt; <br>&gt;&gt; In its current incarnation, the standalone stride function uses confusing semantics. The current to implementation returns values in [start, end) and will never reach or get to end. The current through implementation returns values in [start, end]. It may never reach end and certainly never goes through that value. Our proposed method introduces simple, expected semantics that can be extended to both countable and continuous ranges, and to open and closed intervals (both half-open and fully-open).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#detail-design&gt;Detail Design<br>&gt;&gt; <br>&gt;&gt; The striding(by:) method is called on ranges. When used with a positive step size, the count starts from the lower bound. With a negative step size, the count starts from the upper bound. These bounds apply regardless of whether they are inclusive or exclusive. <br>&gt;&gt; <br>&gt;&gt; The following examples should cover all corner cases and include possible cases should Swift 3 introduce a full complement of open and closed ranges. The syntax for non-canonical range types is not fixed and can be discussed under separate cover.<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt; (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;&gt; (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;&gt; (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt;&gt; (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt;&gt; To reverse a stride, call reverse() on the results:<br>&gt;&gt; <br>&gt;&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;&gt; We note that striding by 0 should be always be a precondition failure.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; During the on-list discussion, we considered various scenarios that took closed/inclusive bounds into account or excluded open bounds for starting values. For example, we might have prohibited scenarios where multiple interpretations of an intended behavior might exist: is (0 ..&lt; 9).striding(by: -2) a precondition failure? We settled on the simplest, most straight-forward implementation involving the fewest compiler warnings and the lowest likelihood of precondition failures. We subscribe to the &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios more likely indicates bad language design than bad user comprehension.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#future-directions&gt;Future Directions<br>&gt;&gt; <br>&gt;&gt; We intend to follow up with an expanded operator vocabulary that includes fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in the Detail Design section.<br>&gt;&gt; <br>&gt;&gt; Upon adoption, the Swift community may consider expanding this approach to collection indices, for example:<br>&gt;&gt; <br>&gt;&gt; let a = [8, 6, 7, 5, 3, 0, 9]<br>&gt;&gt; for e in a.striding(by: 3) {<br>&gt;&gt;     print(e) // 8, then 5, then 9<br>&gt;&gt; }<br>&gt;&gt; Striding offers a fundamental operation over collections. The consistent approach introduced in this proposal &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13936&gt; helps support the extension of stride semantics to collections.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#acknowlegements&gt;Acknowlegements<br>&gt;&gt; <br>&gt;&gt; Thanks, Dave Abrahams, Matthew Judge<br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/bacd2cb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 11:00:00pm</p></header><div class="content"><p>IMO, 9...0 is a non-starter. Especially with Range taking on the role of<br>Interval, it&#39;s critical that they have no direction. Suppose you have two<br>ranges, 0...9 and 9...0. Is 0...9 == 9...0? IMO, two countable ranges r0<br>and r1 are equal if, for value in r0, r1.contains(value) == true, and vice<br>versa. (Sorry for the pseudocode; I&#39;m typing on a phone.) However, if Range<br>has intrinsic direction, either equality ignores direction (ludicrous) or<br>0...9 != 9...0 (unacceptable).<br></p><p>Since we have `reverse()`, all ambiguity could be resolved by prohibiting<br>negative stride sizes altogether, I suppose. So, (0...9).striding(by:<br>2).reverse() could be the one Swifty way to stride backwards. Is that<br>objectionable to people?<br></p><p>On Sat, Apr 9, 2016 at 11:58 PM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt; On 9 Apr 2016, at 10:50, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; But, ranges are useful for more than just stride, and so I would say it<br>&gt; doesn&#39;t make sense to have an intrinsic direction for Range, which<br>&gt; pointedly has lowerBound and upperBound but not start and end. For sample,<br>&gt; there shouldn&#39;t be (0...9).contains(1) and (9...0).contains(1).<br>&gt;<br>&gt;<br>&gt; While I can appreciate that, I wonder if it’s really that important that<br>&gt; 0…9 and 9…0 are identical? As long as we can be clear on which direction of<br>&gt; range we want to generate (so probably still need two new operators), can<br>&gt; tell what the direction is, and can convert between them if we need to for<br>&gt; some reason (reverse should be fine for that?), then I think we’re okay.<br>&gt;<br>&gt; i.e- 9 … 0 would still cause an error at compile or run-time, we’d have<br>&gt; some other operator for doing that, not sure what, plus 9 ..&gt; 0, with both<br>&gt; explicitly creating ranges in the reverse direction to avoid mistakes with<br>&gt; the order or for computed indices. When it comes down to it the current<br>&gt; Range has an implicitly forward direction, so I don’t see the problem with<br>&gt; having the same in reverse personally.<br>&gt;<br>&gt;<br>&gt; I dunno, at the very least we might want to consider overloading the<br>&gt; striding method as .striding(forwardBy:) and .striding(backwardBy:) or<br>&gt; something similar, each taking a positive value of some kind to help avoid<br>&gt; mistakes in cases where the stride size is computed rather than constant,<br>&gt; this would make it more explicit at least.<br>&gt;<br>&gt; On Sat, Apr 9, 2016 at 10:33 AM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; While I’m in favour of the basic idea I think the operator selection is<br>&gt;&gt; too complex, and I’m not sure about the need for negative strides. Really<br>&gt;&gt; all I want are the following:<br>&gt;&gt;<br>&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt;&gt; (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt;&gt; (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;&gt;<br>&gt;&gt; Everything else should be coverable either by flipping the order, or<br>&gt;&gt; using .reverse(). The main advantage is that there’s only one new operator<br>&gt;&gt; to clarify the 6 ..&gt; 0 case, though you could always just reuse the<br>&gt;&gt; existing operator if you just interpret it as “x from 6 to, but not<br>&gt;&gt; including, 0&quot;<br>&gt;&gt;<br>&gt;&gt; I dunno, I just don’t think that introducing tons of new operators is<br>&gt;&gt; going to simplify things, and could lead to way more mistakes in practice;<br>&gt;&gt; the only mistake above would be putting the indices in the wrong order and<br>&gt;&gt; accidentally reversing the result.<br>&gt;&gt;<br>&gt;&gt; Also, I’m against negative strides; while they could be useful for<br>&gt;&gt; convenience (avoid the need for .reverse or flipping values) I’m just not<br>&gt;&gt; sure that it makes sense. To me a stride is a distance, thus absolute, what<br>&gt;&gt; matters is the direction of the range. Naturally we’d need ranges with a<br>&gt;&gt; direction, but with collections requiring it to be in a particular order<br>&gt;&gt; (or ignoring it and flipping where necessary).<br>&gt;&gt;<br>&gt;&gt; On 8 Apr 2016, at 19:37, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Draft here:<br>&gt;&gt; https://gist.github.com/erica/a51a981ee0352235204692affa959307  Feedback<br>&gt;&gt; solicited, both positive and negative.<br>&gt;&gt; We&#39;ve also got a related proposal about expanding ranges, which you can<br>&gt;&gt; look at here (<br>&gt;&gt; https://gist.github.com/erica/af92c541a0fb69fce1b7aaf8374a5aa9)<br>&gt;&gt;  but we want to float this one first.<br>&gt;&gt;<br>&gt;&gt; Thanks, -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;    &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307/edit&gt;<br>&gt;&gt;    - Author(s): Xiaodi Wu &lt;https://github.com/xwu&gt;, Pyry Jahkola<br>&gt;&gt;    &lt;http://github.com/pyrtsa&gt;, Nate Cook &lt;http://github.com/natecook1000&gt;<br>&gt;&gt;    , Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;    - Status: TBD<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; We propose to introduce a striding(by:) method on the revised 3.0 Range<br>&gt;&gt;  type.<br>&gt;&gt;<br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the Feature<br>&gt;&gt; proposal: Range operator with step<br>&gt;&gt; &lt;http://search.gmane.org/search.php?group=gmane.comp.lang.swift.evolution&amp;query=Feature+proposal%3A+Range+operator+with+step&gt; thread.<br>&gt;&gt; (Direct link<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12801/focus=13051&gt; to<br>&gt;&gt; original thread)<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Updating Range for Swift 3 offers a window of opportunity to<br>&gt;&gt; simultaneously improve strides.<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Under current Swift 3 plans, n.stride(to:/through:, by:) will be<br>&gt;&gt;    replaced with a standalone stride(from:, to:/through:, by:) function.<br>&gt;&gt;    We propose to replace this change with a method on ranges. Using a method<br>&gt;&gt;    reduces overall API surface area compared to free functions.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    In its current incarnation, the standalone stride function uses<br>&gt;&gt;    confusing semantics. The current to implementation returns values in<br>&gt;&gt;    *[start, end)* and will never reach or get *to* end. The current<br>&gt;&gt;    through implementation returns values in *[start, end]*. It may never<br>&gt;&gt;    reach end and certainly never goes *through* that value. Our proposed<br>&gt;&gt;    method introduces simple, expected semantics that can be extended to both<br>&gt;&gt;    countable and continuous ranges, and to open and closed intervals (both<br>&gt;&gt;    half-open and fully-open).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#detail-design&gt;Detail<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; The striding(by:) method is called on ranges. When used with a positive<br>&gt;&gt; step size, the count starts from the lower bound. With a negative step<br>&gt;&gt; size, the count starts from the upper bound. These bounds apply regardless<br>&gt;&gt; of whether they are inclusive or exclusive.<br>&gt;&gt;<br>&gt;&gt; The following examples should cover all corner cases and include possible<br>&gt;&gt; cases should Swift 3 introduce a full complement of open and closed ranges.<br>&gt;&gt; The syntax for non-canonical range types is not fixed and can be discussed<br>&gt;&gt; under separate cover.<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;&gt; (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;&gt; (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt; (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;&gt; (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;&gt; (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt;&gt; (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;&gt; (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt;&gt;<br>&gt;&gt; To reverse a stride, call reverse() on the results:<br>&gt;&gt;<br>&gt;&gt; (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;&gt;<br>&gt;&gt; We note that striding by 0 should be always be a precondition failure.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#alternatives-considered&gt;Alternatives<br>&gt;&gt; Considered<br>&gt;&gt;<br>&gt;&gt; During the on-list discussion, we considered various scenarios that took<br>&gt;&gt; closed/inclusive bounds into account or excluded open bounds for starting<br>&gt;&gt; values. For example, we might have prohibited scenarios where multiple<br>&gt;&gt; interpretations of an intended behavior might exist: is (0 ..&lt;<br>&gt;&gt; 9).striding(by: -2) a precondition failure? We settled on the simplest,<br>&gt;&gt; most straight-forward implementation involving the fewest compiler warnings<br>&gt;&gt; and the lowest likelihood of precondition failures. We subscribe to the<br>&gt;&gt; &quot;Dave Abrahams Philosophy&quot;: excessive special casing and warning scenarios<br>&gt;&gt; more likely indicates bad language design than bad user comprehension.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#future-directions&gt;Future<br>&gt;&gt; Directions<br>&gt;&gt;<br>&gt;&gt; We intend to follow up with an expanded operator vocabulary that includes<br>&gt;&gt; fully open ranges (&lt;.&lt;), fully closed ranges (...) and both half open<br>&gt;&gt; ranges (&lt;.., ..&lt;). These will support the full vocabulary laid out in<br>&gt;&gt; the Detail Design section.<br>&gt;&gt;<br>&gt;&gt; Upon adoption, the Swift community may consider expanding this approach<br>&gt;&gt; to collection indices, for example:<br>&gt;&gt;<br>&gt;&gt; let a = [8, 6, 7, 5, 3, 0, 9]<br>&gt;&gt; for e in a.striding(by: 3) {<br>&gt;&gt;     print(e) // 8, then 5, then 9<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Striding offers a fundamental operation over collections. The consistent<br>&gt;&gt; approach introduced in this proposal<br>&gt;&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13936&gt; helps<br>&gt;&gt; support the extension of stride semantics to collections.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/a51a981ee0352235204692affa959307#acknowlegements&gt;<br>&gt;&gt; Acknowlegements<br>&gt;&gt; Thanks, Dave Abrahams, Matthew Judge<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/d2ad9a95/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 9, 2016, at 5:58 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 9 Apr 2016, at 10:50, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But, ranges are useful for more than just stride, and so I would say it doesn&#39;t make sense to have an intrinsic direction for Range, which pointedly has lowerBound and upperBound but not start and end. For sample, there shouldn&#39;t be (0...9).contains(1) and (9...0).contains(1).<br>&gt; <br>&gt; While I can appreciate that, I wonder if it’s really that important that 0…9 and 9…0 are identical? As long as we can be clear on which direction of range we want to generate (so probably still need two new operators), can tell what the direction is, and can convert between them if we need to for some reason (reverse should be fine for that?), then I think we’re okay.<br>&gt; <br>&gt; i.e- 9 … 0 would still cause an error at compile or run-time, we’d have some other operator for doing that, not sure what, plus 9 ..&gt; 0, with both explicitly creating ranges in the reverse direction to avoid mistakes with the order or for computed indices. When it comes down to it the current Range has an implicitly forward direction, so I don’t see the problem with having the same in reverse personally.<br>&gt; <br>&gt; <br>&gt; I dunno, at the very least we might want to consider overloading the striding method as .striding(forwardBy:) and .striding(backwardBy:) or something similar, each taking a positive value of some kind to help avoid mistakes in cases where the stride size is computed rather than constant, this would make it more explicit at least.<br></p><p>I can’t imagine any scenario in which getting the step&#39;s sign wrong wouldn’t just be a typo. Why not just assign it the correct sign during the init function?<br>(0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>(6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br></p><p>(OTOH, I don’t understand why 6…0 is currently a crash, rather than the, IMHO, obviously intended sequence of “6,5,4,3,2,1,0”, so maybe I’m not the best person to ask)<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/11661a10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 10, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; I can’t imagine any scenario in which getting the step&#39;s sign wrong wouldn’t just be a typo.<br></p><p>Well, it could be an error if you derive the stride by subtracting two numbers, and the second number is unexpectedly larger than the first. Of course, that makes it a *bug*, not a typo.<br></p><p>&gt; Why not just assign it the correct sign during the init function?<br>&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br></p><p>One reason not to do it this way is that, if we extend `striding(by:)` to other collections, they will not be as easy to walk backwards through as this. You will have to do something like `collection.reversed().striding(by:)` which will be a hassle.<br></p><p>And the same may apply to Range, for that matter, because…<br></p><p>&gt; (OTOH, I don’t understand why 6…0 is currently a crash, rather than the, IMHO, obviously intended sequence of “6,5,4,3,2,1,0”, so maybe I’m not the best person to ask)<br></p><p>Well, suppose you say `6...0`. There are three ways that could be represented:<br></p><p>1.	Range(start: 0, end: 6)<br>2.	Range(start: 6, end: 0)<br>3.	Range(start: 0, end: 6, reversed: true)<br></p><p>Option 1 throws away the fact that the range was ever reversed, so it doesn&#39;t actually help with this case.<br></p><p>Option 2 complicates testing. Where before you might have written this:<br></p><p>	let inBounds = start &lt;= x &lt; end<br></p><p>Now you must write:<br></p><p>	let inBounds: Bool<br>	if start &lt; end {<br>		inBounds = start &lt;= x &amp;&amp; x &lt; end<br>	}<br>	else {<br>		inBounds = start &gt;= x &amp;&amp; x &gt; end<br>	}<br></p><p>Remember, conditional branches are relatively slow, and we want to avoid them where we can. If this is, for instance, the test of a loop, the extra branch is not a good thing.<br></p><p>Option 3 avoids this issue, but it requires more space. It also requires branches in other places which care about order.<br></p><p>And both 2 and 3 complicate slicing. If you say `array[6...0] = newValues`, the operation should probably be performed such that `array[6] == newValues[0]`. That seems difficult to implement—and all too easy to forget to handle. And I can imagine that it might prevent certain optimizations if the compiler couldn&#39;t prove they were forward ranges.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 10, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 10 Apr 2016, at 11:17, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Why not just assign it the correct sign during the init function?<br>&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br>&gt; <br>&gt; One reason not to do it this way is that, if we extend `striding(by:)` to other collections, they will not be as easy to walk backwards through as this. You will have to do something like `collection.reversed().striding(by:)` which will be a hassle.<br></p><p>Any thoughts on the alternative I mentioned a little earlier to define overloads instead of positive/negative? i.e- you would have two methods, .striding(forwardBy:) and .striding(backwardBy:). In addition to eliminating the use of a negative stride to indicate direction, this has the advantage that .striding(backwardBy:) can be defined only for types with a ReverseIndex or only for collections (as you can stride through a sequence, but only by going forward).<br></p><p>This should also make documentation a bit clearer, otherwise you’ve got the caveat that to go backwards requires a negative value, but only if the type supports that, which a developer would then need to check. Instead it either has the backwardBy variant or not.<br></p><p>I know that advance(by:) supports negative values, but this is actually something I wouldn’t mind seeing changed as well, as it has the same issues (passing a negative value in looks fine until you realise the type is a ForwardIndex only). It would also allow us to define Distance types that don’t support a direction, since this would be given by the choice of method called instead.<br></p><p><br>Of course I’d still like to be able to define 6 … 0 or whatever, but this would at least eliminate what I dislike about using negatives for direction.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/d6f30f33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 10, 2016 at 01:00:00pm</p></header><div class="content"><p>What types do you have in mind that would only support positive distances?<br>All numeric types (yes, even UInt, etc.) have signed distances, which<br>reflects the basic mathematical abstraction of a number line.<br></p><p>A consistent behavior with signed distances is so important that we are<br>currently struggling with an interesting issue with floating point types,<br>which is that due to rounding error 10.0 + a - a != 10.0 for some values of<br>a.<br></p><p>On Sun, Apr 10, 2016 at 12:53 PM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 10 Apr 2016, at 11:17, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Why not just assign it the correct sign during the init function?<br>&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br>&gt;<br>&gt;<br>&gt; One reason not to do it this way is that, if we extend `striding(by:)` to<br>&gt; other collections, they will not be as easy to walk backwards through as<br>&gt; this. You will have to do something like<br>&gt; `collection.reversed().striding(by:)` which will be a hassle.<br>&gt;<br>&gt;<br>&gt; Any thoughts on the alternative I mentioned a little earlier to define<br>&gt; overloads instead of positive/negative? i.e- you would have two methods,<br>&gt; .striding(forwardBy:) and .striding(backwardBy:). In addition to<br>&gt; eliminating the use of a negative stride to indicate direction, this has<br>&gt; the advantage that .striding(backwardBy:) can be defined only for types<br>&gt; with a ReverseIndex or only for collections (as you can stride through a<br>&gt; sequence, but only by going forward).<br>&gt;<br>&gt; This should also make documentation a bit clearer, otherwise you’ve got<br>&gt; the caveat that to go backwards requires a negative value, but only if the<br>&gt; type supports that, which a developer would then need to check. Instead it<br>&gt; either has the backwardBy variant or not.<br>&gt;<br>&gt; I know that advance(by:) supports negative values, but this is actually<br>&gt; something I wouldn’t mind seeing changed as well, as it has the same issues<br>&gt; (passing a negative value in looks fine until you realise the type is a<br>&gt; ForwardIndex only). It would also allow us to define Distance types that<br>&gt; don’t support a direction, since this would be given by the choice of<br>&gt; method called instead.<br>&gt;<br>&gt;<br>&gt; Of course I’d still like to be able to define 6 … 0 or whatever, but this<br>&gt; would at least eliminate what I dislike about using negatives for direction.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/41849eee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 10 Apr 2016, at 14:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; What types do you have in mind that would only support positive distances? All numeric types (yes, even UInt, etc.) have signed distances, which reflects the basic mathematical abstraction of a number line.<br></p><p>Say you wanted to stride through a singly-linked list, it would actually be beneficial to support only forward strides, the same is true of sequences, as you either may not know what the endpoint is, or would have to step through the whole sequence to find it (plus buffer every value in order to do-so safely).<br></p><p>&gt; A consistent behavior with signed distances is so important that we are currently struggling with an interesting issue with floating point types, which is that due to rounding error 10.0 + a - a != 10.0 for some values of a.<br></p><p>While that’s interesting I’m not sure why the sign is important; to me a stride is a width so it being negative makes no sense. For example, say I laid an array of Ints, organised into groups of five (and also that I’m lunatic who won’t use a tuple for this), the stride of this array is 5 whether I’m stepping through it forwards or backwards. Imagine I defined this like so (more realistically it’d be a struct or a class):<br></p><p>	typealias StridedIntegerArray:(stride:Int, array:[Int])<br></p><p>If the stride is set to 5, it’s always 5, the only thing that changes is whether I want to stride from the start or end of the array, plus I could things like:<br></p><p>	myStridedIntegerArray.prefix(from: 2).striding(forwardBy: myStridedIntegerArray.stride)	// Returns element at index 2, 7, 12, etc.<br></p><p><br>It just occurred to me that perhaps you intended this method only for ranges specifically and that perhaps I’m confusing things, but it seems to me like it should be a method for all sequences (with reverse stride available on collections with a reverse index type) returning a generator that only returns (or computes) every Nth element, for generic sequences/collections this would take the start or end index and use advanced(by:), though again, I kind of feel like that should be two separate methods as well, but that’s for another issue I think.<br></p><p>&gt; On Sun, Apr 10, 2016 at 12:53 PM Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 10 Apr 2016, at 11:17, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Why not just assign it the correct sign during the init function?<br>&gt;&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt;&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br>&gt;&gt; <br>&gt;&gt; One reason not to do it this way is that, if we extend `striding(by:)` to other collections, they will not be as easy to walk backwards through as this. You will have to do something like `collection.reversed().striding(by:)` which will be a hassle.<br>&gt; <br>&gt; Any thoughts on the alternative I mentioned a little earlier to define overloads instead of positive/negative? i.e- you would have two methods, .striding(forwardBy:) and .striding(backwardBy:). In addition to eliminating the use of a negative stride to indicate direction, this has the advantage that .striding(backwardBy:) can be defined only for types with a ReverseIndex or only for collections (as you can stride through a sequence, but only by going forward).<br>&gt; <br>&gt; This should also make documentation a bit clearer, otherwise you’ve got the caveat that to go backwards requires a negative value, but only if the type supports that, which a developer would then need to check. Instead it either has the backwardBy variant or not.<br>&gt; <br>&gt; I know that advance(by:) supports negative values, but this is actually something I wouldn’t mind seeing changed as well, as it has the same issues (passing a negative value in looks fine until you realise the type is a ForwardIndex only). It would also allow us to define Distance types that don’t support a direction, since this would be given by the choice of method called instead.<br>&gt; <br>&gt; <br>&gt; Of course I’d still like to be able to define 6 … 0 or whatever, but this would at least eliminate what I dislike about using negatives for direction.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/8c47e983/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 10, 2016 at 09:00:00pm</p></header><div class="content"><p>On Sun, Apr 10, 2016 at 3:58 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt; On 10 Apr 2016, at 14:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; What types do you have in mind that would only support positive distances?<br>&gt; All numeric types (yes, even UInt, etc.) have signed distances, which<br>&gt; reflects the basic mathematical abstraction of a number line.<br>&gt;<br>&gt;<br>&gt; Say you wanted to stride through a singly-linked list, it would actually be<br>&gt; beneficial to support only forward strides, the same is true of sequences,<br>&gt; as you either may not know what the endpoint is, or would have to step<br>&gt; through the whole sequence to find it (plus buffer every value in order to<br>&gt; do-so safely).<br>&gt;<br>&gt; A consistent behavior with signed distances is so important that we are<br>&gt; currently struggling with an interesting issue with floating point types,<br>&gt; which is that due to rounding error 10.0 + a - a != 10.0 for some values of<br>&gt; a.<br>&gt;<br>&gt;<br>&gt; While that’s interesting I’m not sure why the sign is important; to me a<br>&gt; stride is a width so it being negative makes no sense. For example, say I<br>&gt; laid an array of Ints, organised into groups of five (and also that I’m<br>&gt; lunatic who won’t use a tuple for this), the stride of this array is 5<br>&gt; whether I’m stepping through it forwards or backwards. Imagine I defined<br>&gt; this like so (more realistically it’d be a struct or a class):<br>&gt;<br>&gt; typealias StridedIntegerArray:(stride:Int, array:[Int])<br>&gt;<br>&gt; If the stride is set to 5, it’s always 5, the only thing that changes is<br>&gt; whether I want to stride from the start or end of the array, plus I could<br>&gt; things like:<br>&gt;<br>&gt; myStridedIntegerArray.prefix(from: 2).striding(forwardBy:<br>&gt; myStridedIntegerArray.stride) // Returns element at index 2, 7, 12, etc.<br></p><p>When you have a sequence returning elements at index 12, 7, 2, etc.,<br>wouldn&#39;t you call the stride size -5? I would, because 12 + (-5) = 7.<br></p><p>&gt;<br>&gt;<br>&gt; It just occurred to me that perhaps you intended this method only for ranges<br>&gt; specifically and that perhaps I’m confusing things, but it seems to me like<br>&gt; it should be a method for all sequences (with reverse stride available on<br>&gt; collections with a reverse index type) returning a generator that only<br>&gt; returns (or computes) every Nth element, for generic sequences/collections<br>&gt; this would take the start or end index and use advanced(by:), though again,<br>&gt; I kind of feel like that should be two separate methods as well, but that’s<br>&gt; for another issue I think.<br></p><p>I don&#39;t think it should be for ranges only, but ranges are the extent<br>of this proposal.<br></p><p>That said, my own opinion is that striding should not be available on<br>sequences but on collections only. In their most commonly used form,<br>integer strides take a start and end, and there is a finite number of<br>things to stride over; thus, in my reasoning, strides can be extended<br>to cover anything else that has a known start and end and has a finite<br>number of things, which is guaranteed by conformance to Collection but<br>not to Sequence. (At the moment, StrideTo/Through conforms to Sequence<br>and not to Collection, but that is considered something to be fixed<br>and we will see if we can address that as part of this set of stride<br>overhauls.)<br></p><p>As I see it, we agree on the problem: the current algorithm cannot<br>accommodate singly linked lists and sequences because those things do<br>not have a known endpoint if you begin an attempt to stride. However,<br>my conclusion is the opposite of yours: namely, that they should not<br>have stride. Maybe they should have something similar, but it<br>shouldn&#39;t be stride.<br></p><p>&gt;<br>&gt; On Sun, Apr 10, 2016 at 12:53 PM Haravikk via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 10 Apr 2016, at 11:17, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Why not just assign it the correct sign during the init function?<br>&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One reason not to do it this way is that, if we extend `striding(by:)` to<br>&gt;&gt; other collections, they will not be as easy to walk backwards through as<br>&gt;&gt; this. You will have to do something like<br>&gt;&gt; `collection.reversed().striding(by:)` which will be a hassle.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Any thoughts on the alternative I mentioned a little earlier to define<br>&gt;&gt; overloads instead of positive/negative? i.e- you would have two methods,<br>&gt;&gt; .striding(forwardBy:) and .striding(backwardBy:). In addition to eliminating<br>&gt;&gt; the use of a negative stride to indicate direction, this has the advantage<br>&gt;&gt; that .striding(backwardBy:) can be defined only for types with a<br>&gt;&gt; ReverseIndex or only for collections (as you can stride through a sequence,<br>&gt;&gt; but only by going forward).<br>&gt;&gt;<br>&gt;&gt; This should also make documentation a bit clearer, otherwise you’ve got<br>&gt;&gt; the caveat that to go backwards requires a negative value, but only if the<br>&gt;&gt; type supports that, which a developer would then need to check. Instead it<br>&gt;&gt; either has the backwardBy variant or not.<br>&gt;&gt;<br>&gt;&gt; I know that advance(by:) supports negative values, but this is actually<br>&gt;&gt; something I wouldn’t mind seeing changed as well, as it has the same issues<br>&gt;&gt; (passing a negative value in looks fine until you realise the type is a<br>&gt;&gt; ForwardIndex only). It would also allow us to define Distance types that<br>&gt;&gt; don’t support a direction, since this would be given by the choice of method<br>&gt;&gt; called instead.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Of course I’d still like to be able to define 6 … 0 or whatever, but this<br>&gt;&gt; would at least eliminate what I dislike about using negatives for direction.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 11, 2016 at 11:00:00am</p></header><div class="content"><p>on Sun Apr 10 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Sun, Apr 10, 2016 at 3:58 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 10 Apr 2016, at 14:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What types do you have in mind that would only support positive distances?<br>&gt;&gt; All numeric types (yes, even UInt, etc.) have signed distances, which<br>&gt;<br>&gt;&gt; reflects the basic mathematical abstraction of a number line.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Say you wanted to stride through a singly-linked list, it would actually be<br>&gt;&gt; beneficial to support only forward strides, the same is true of sequences,<br>&gt;&gt; as you either may not know what the endpoint is, or would have to step<br>&gt;&gt; through the whole sequence to find it (plus buffer every value in order to<br>&gt;&gt; do-so safely).<br>&gt;&gt;<br>&gt;&gt; A consistent behavior with signed distances is so important that we are<br>&gt;&gt; currently struggling with an interesting issue with floating point types,<br>&gt;&gt; which is that due to rounding error 10.0 + a - a != 10.0 for some values of<br>&gt;&gt; a.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; While that’s interesting I’m not sure why the sign is important; to me a<br>&gt;&gt; stride is a width so it being negative makes no sense. For example, say I<br>&gt;&gt; laid an array of Ints, organised into groups of five (and also that I’m<br>&gt;&gt; lunatic who won’t use a tuple for this), the stride of this array is 5<br>&gt;&gt; whether I’m stepping through it forwards or backwards. Imagine I defined<br>&gt;&gt; this like so (more realistically it’d be a struct or a class):<br>&gt;&gt;<br>&gt;&gt; typealias StridedIntegerArray:(stride:Int, array:[Int])<br>&gt;&gt;<br>&gt;&gt; If the stride is set to 5, it’s always 5, the only thing that changes is<br>&gt;&gt; whether I want to stride from the start or end of the array, plus I could<br>&gt;&gt; things like:<br>&gt;&gt;<br>&gt;&gt; myStridedIntegerArray.prefix(from: 2).striding(forwardBy:<br>&gt;&gt; myStridedIntegerArray.stride) // Returns element at index 2, 7, 12, etc.<br>&gt;<br>&gt; When you have a sequence returning elements at index 12, 7, 2, etc.,<br>&gt; wouldn&#39;t you call the stride size -5? I would, because 12 + (-5) = 7.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It just occurred to me that perhaps you intended this method only for ranges<br>&gt;&gt; specifically and that perhaps I’m confusing things, but it seems to me like<br>&gt;&gt; it should be a method for all sequences (with reverse stride available on<br>&gt;&gt; collections with a reverse index type) returning a generator that only<br>&gt;&gt; returns (or computes) every Nth element, for generic sequences/collections<br>&gt;&gt; this would take the start or end index and use advanced(by:), though again,<br>&gt;&gt; I kind of feel like that should be two separate methods as well, but that’s<br>&gt;&gt; for another issue I think.<br>&gt;<br>&gt; I don&#39;t think it should be for ranges only, but ranges are the extent<br>&gt; of this proposal.<br>&gt;<br>&gt; That said, my own opinion is that striding should not be available on<br>&gt; sequences but on collections only. In their most commonly used form,<br>&gt; integer strides take a start and end, and there is a finite number of<br>&gt; things to stride over; thus, in my reasoning, strides can be extended<br>&gt; to cover anything else that has a known start and end and has a finite<br>&gt; number of things, which is guaranteed by conformance to Collection but<br>&gt; not to Sequence. <br></p><p>I dunno; it seems to me that if someone gives me a Sequence I should be<br>able to traverse it, skipping every other element.  I don&#39;t see why<br>“stride” should be inapplicable here.<br></p><p>&gt; (At the moment, StrideTo/Through conforms to Sequence and not to<br>&gt; Collection, but that is considered something to be fixed and we will<br>&gt; see if we can address that as part of this set of stride overhauls.)<br>&gt;<br>&gt; As I see it, we agree on the problem: the current algorithm cannot<br>&gt; accommodate singly linked lists and sequences because those things do<br>&gt; not have a known endpoint if you begin an attempt to stride. However,<br>&gt; my conclusion is the opposite of yours: namely, that they should not<br>&gt; have stride. Maybe they should have something similar, but it<br>&gt; shouldn&#39;t be stride.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Apr 10, 2016 at 12:53 PM Haravikk via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 10 Apr 2016, at 11:17, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why not just assign it the correct sign during the init function?<br>&gt;&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt;&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One reason not to do it this way is that, if we extend `striding(by:)` to<br>&gt;&gt;&gt; other collections, they will not be as easy to walk backwards through as<br>&gt;&gt;&gt; this. You will have to do something like<br>&gt;&gt;&gt; `collection.reversed().striding(by:)` which will be a hassle.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any thoughts on the alternative I mentioned a little earlier to define<br>&gt;&gt;&gt; overloads instead of positive/negative? i.e- you would have two methods,<br>&gt;&gt;&gt; .striding(forwardBy:) and .striding(backwardBy:). In addition to eliminating<br>&gt;&gt;&gt; the use of a negative stride to indicate direction, this has the advantage<br>&gt;&gt;&gt; that .striding(backwardBy:) can be defined only for types with a<br>&gt;&gt;&gt; ReverseIndex or only for collections (as you can stride through a sequence,<br>&gt;&gt;&gt; but only by going forward).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This should also make documentation a bit clearer, otherwise you’ve got<br>&gt;&gt;&gt; the caveat that to go backwards requires a negative value, but only if the<br>&gt;&gt;&gt; type supports that, which a developer would then need to check. Instead it<br>&gt;&gt;&gt; either has the backwardBy variant or not.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I know that advance(by:) supports negative values, but this is actually<br>&gt;&gt;&gt; something I wouldn’t mind seeing changed as well, as it has the same issues<br>&gt;&gt;&gt; (passing a negative value in looks fine until you realise the type is a<br>&gt;&gt;&gt; ForwardIndex only). It would also allow us to define Distance types that<br>&gt;&gt;&gt; don’t support a direction, since this would be given by the choice of method<br>&gt;&gt;&gt; called instead.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course I’d still like to be able to define 6 … 0 or whatever, but this<br>&gt;&gt;&gt; would at least eliminate what I dislike about using negatives for direction.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 11, 2016 at 08:00:00pm</p></header><div class="content"><p>I realize what follows is actually an argument for restricting stride to<br>collections with randomly accessible elements, and maybe we should:<br></p><p>We&#39;ve touched a little bit on performance, and I think my feeling with<br>stride is that just the name itself suggests a certain logic--namely, that<br>we actually skip over, rather than visit and discard, the elements that<br>aren&#39;t in the sequence.<br></p><p>I form this intuition from the ordinary sense of the word &quot;stride&quot;--if my<br>walking gait has a stride size of two feet and there&#39;s a puddle less than<br>one foot wide right in front of me, striding by two feet means that my feet<br>stay dry. It doesn&#39;t mean I drag one shoe through the puddle and ignore it.<br>Likewise, when I stride from 2 to 10 by 2, I&#39;m adding two at every step,<br>not adding one twice.<br></p><p>Since an ordinary user of stride doesn&#39;t and shouldn&#39;t have to inspect the<br>code in the stride iterator, I think it would violate some users&#39;<br>expectations if sequences that are not collections have each element<br>visited regardless of stride size. A user can trivially write a for loop<br>iterating over the sequence itself and discard every not-nth element. We<br>shouldn&#39;t offer a stride function that looks more performant but actually<br>isn&#39;t.<br></p><p>On Mon, Apr 11, 2016 at 7:38 PM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Sun Apr 10 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Sun, Apr 10, 2016 at 3:58 PM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On 10 Apr 2016, at 14:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What types do you have in mind that would only support positive<br>&gt; distances?<br>&gt; &gt;&gt; All numeric types (yes, even UInt, etc.) have signed distances, which<br>&gt; &gt;<br>&gt; &gt;&gt; reflects the basic mathematical abstraction of a number line.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Say you wanted to stride through a singly-linked list, it would<br>&gt; actually be<br>&gt; &gt;&gt; beneficial to support only forward strides, the same is true of<br>&gt; sequences,<br>&gt; &gt;&gt; as you either may not know what the endpoint is, or would have to step<br>&gt; &gt;&gt; through the whole sequence to find it (plus buffer every value in order<br>&gt; to<br>&gt; &gt;&gt; do-so safely).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A consistent behavior with signed distances is so important that we are<br>&gt; &gt;&gt; currently struggling with an interesting issue with floating point<br>&gt; types,<br>&gt; &gt;&gt; which is that due to rounding error 10.0 + a - a != 10.0 for some<br>&gt; values of<br>&gt; &gt;&gt; a.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; While that’s interesting I’m not sure why the sign is important; to me a<br>&gt; &gt;&gt; stride is a width so it being negative makes no sense. For example, say<br>&gt; I<br>&gt; &gt;&gt; laid an array of Ints, organised into groups of five (and also that I’m<br>&gt; &gt;&gt; lunatic who won’t use a tuple for this), the stride of this array is 5<br>&gt; &gt;&gt; whether I’m stepping through it forwards or backwards. Imagine I defined<br>&gt; &gt;&gt; this like so (more realistically it’d be a struct or a class):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; typealias StridedIntegerArray:(stride:Int, array:[Int])<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If the stride is set to 5, it’s always 5, the only thing that changes is<br>&gt; &gt;&gt; whether I want to stride from the start or end of the array, plus I<br>&gt; could<br>&gt; &gt;&gt; things like:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; myStridedIntegerArray.prefix(from: 2).striding(forwardBy:<br>&gt; &gt;&gt; myStridedIntegerArray.stride) // Returns element at index 2, 7, 12, etc.<br>&gt; &gt;<br>&gt; &gt; When you have a sequence returning elements at index 12, 7, 2, etc.,<br>&gt; &gt; wouldn&#39;t you call the stride size -5? I would, because 12 + (-5) = 7.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It just occurred to me that perhaps you intended this method only for<br>&gt; ranges<br>&gt; &gt;&gt; specifically and that perhaps I’m confusing things, but it seems to me<br>&gt; like<br>&gt; &gt;&gt; it should be a method for all sequences (with reverse stride available<br>&gt; on<br>&gt; &gt;&gt; collections with a reverse index type) returning a generator that only<br>&gt; &gt;&gt; returns (or computes) every Nth element, for generic<br>&gt; sequences/collections<br>&gt; &gt;&gt; this would take the start or end index and use advanced(by:), though<br>&gt; again,<br>&gt; &gt;&gt; I kind of feel like that should be two separate methods as well, but<br>&gt; that’s<br>&gt; &gt;&gt; for another issue I think.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t think it should be for ranges only, but ranges are the extent<br>&gt; &gt; of this proposal.<br>&gt; &gt;<br>&gt; &gt; That said, my own opinion is that striding should not be available on<br>&gt; &gt; sequences but on collections only. In their most commonly used form,<br>&gt; &gt; integer strides take a start and end, and there is a finite number of<br>&gt; &gt; things to stride over; thus, in my reasoning, strides can be extended<br>&gt; &gt; to cover anything else that has a known start and end and has a finite<br>&gt; &gt; number of things, which is guaranteed by conformance to Collection but<br>&gt; &gt; not to Sequence.<br>&gt;<br>&gt; I dunno; it seems to me that if someone gives me a Sequence I should be<br>&gt; able to traverse it, skipping every other element.  I don&#39;t see why<br>&gt; “stride” should be inapplicable here.<br>&gt;<br>&gt; &gt; (At the moment, StrideTo/Through conforms to Sequence and not to<br>&gt; &gt; Collection, but that is considered something to be fixed and we will<br>&gt; &gt; see if we can address that as part of this set of stride overhauls.)<br>&gt; &gt;<br>&gt; &gt; As I see it, we agree on the problem: the current algorithm cannot<br>&gt; &gt; accommodate singly linked lists and sequences because those things do<br>&gt; &gt; not have a known endpoint if you begin an attempt to stride. However,<br>&gt; &gt; my conclusion is the opposite of yours: namely, that they should not<br>&gt; &gt; have stride. Maybe they should have something similar, but it<br>&gt; &gt; shouldn&#39;t be stride.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Sun, Apr 10, 2016 at 12:53 PM Haravikk via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On 10 Apr 2016, at 11:17, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Why not just assign it the correct sign during the init function?<br>&gt; &gt;&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt; &gt;&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; One reason not to do it this way is that, if we extend `striding(by:)`<br>&gt; to<br>&gt; &gt;&gt;&gt; other collections, they will not be as easy to walk backwards through<br>&gt; as<br>&gt; &gt;&gt;&gt; this. You will have to do something like<br>&gt; &gt;&gt;&gt; `collection.reversed().striding(by:)` which will be a hassle.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Any thoughts on the alternative I mentioned a little earlier to define<br>&gt; &gt;&gt;&gt; overloads instead of positive/negative? i.e- you would have two<br>&gt; methods,<br>&gt; &gt;&gt;&gt; .striding(forwardBy:) and .striding(backwardBy:). In addition to<br>&gt; eliminating<br>&gt; &gt;&gt;&gt; the use of a negative stride to indicate direction, this has the<br>&gt; advantage<br>&gt; &gt;&gt;&gt; that .striding(backwardBy:) can be defined only for types with a<br>&gt; &gt;&gt;&gt; ReverseIndex or only for collections (as you can stride through a<br>&gt; sequence,<br>&gt; &gt;&gt;&gt; but only by going forward).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This should also make documentation a bit clearer, otherwise you’ve got<br>&gt; &gt;&gt;&gt; the caveat that to go backwards requires a negative value, but only if<br>&gt; the<br>&gt; &gt;&gt;&gt; type supports that, which a developer would then need to check.<br>&gt; Instead it<br>&gt; &gt;&gt;&gt; either has the backwardBy variant or not.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I know that advance(by:) supports negative values, but this is actually<br>&gt; &gt;&gt;&gt; something I wouldn’t mind seeing changed as well, as it has the same<br>&gt; issues<br>&gt; &gt;&gt;&gt; (passing a negative value in looks fine until you realise the type is a<br>&gt; &gt;&gt;&gt; ForwardIndex only). It would also allow us to define Distance types<br>&gt; that<br>&gt; &gt;&gt;&gt; don’t support a direction, since this would be given by the choice of<br>&gt; method<br>&gt; &gt;&gt;&gt; called instead.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Of course I’d still like to be able to define 6 … 0 or whatever, but<br>&gt; this<br>&gt; &gt;&gt;&gt; would at least eliminate what I dislike about using negatives for<br>&gt; direction.<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/412f7a63/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>April 10, 2016 at 08:00:00am</p></header><div class="content"><p>Le 10 avr. 2016 à 6:17, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; Remember, conditional branches are relatively slow, and we want to avoid them where we can. If this is, for instance, the test of a loop, the extra branch is not a good thing.<br></p><p>Perhaps it&#39;s a bit extreme, but my idea for stride is that it should only have one branch in the loop condition and absolutely no other branch. The primitive stride could be defined like this:<br></p><p>	stride(from: 0, compare: &lt;, to: 10, by: 2)<br></p><p>and on top you could add some convenience functions for the &lt;, &gt;, &lt;=, and &gt;= cases:<br></p><p>	stride(from: 0, to: 10, by: 2) // stride(from: 0, compare: &lt;, to: 10, by: 2)<br>	stride(from: 10, downTo: 0, by: -2) // stride(from: 10, compare: &gt;, to: 0, by -2)<br></p><p>	stride(from: 0, through: 10, by: 2) // stride(from: 10, compare: &lt;=, to: 10, by 2)<br>	stride(from: 10, downThrough: 0, by: -2) // stride(from: 10, compare: &gt;=, to: 0, by -2)<br></p><p>None of these should try to prevent you from making an infinite sequence, so no trap for `by: 0` or one that moves the value in the wrong direction. And certainly no extra loop branch based on the sign of the stride (that&#39;s the most important part).<br></p><p>Based on that, you could add some convenience for ranges:<br></p><p>	(0 ..&lt; 10).striding(by: 2) // shortcut for: stride(from: 0, to: 10, by 2)<br>	(0 ..&lt; 10).stridingDown(by: -2) // shortcut for: stride(from: 10, to: 0, by -2)<br></p><p>I guess in this case it&#39;d be fine to add a precondition to check that `by` is not in the reverse direction so we can preserve the semantics of iterating over a collection. But because of this precondition and the other one in Range, I would actually prefer the non-range forms if I was using a `stride` in a nested loop.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 10, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; I can’t imagine any scenario in which getting the step&#39;s sign wrong wouldn’t just be a typo.<br></p><p>Well, it could be an error if you derive the stride by subtracting two numbers, and the second number is unexpectedly larger than the first. Of course, that makes it a *bug*, not a typo.<br></p><p>&gt; Why not just assign it the correct sign during the init function?<br>&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6], end &gt; start, so stride = by<br>&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0], start &gt; end, so stride = -by<br></p><p>One reason not to do it this way is that, if we extend `striding(by:)` to other collections, they will not be as easy to walk backwards through as this. You will have to do something like `collection.reversed().striding(by:)` which will be a hassle.<br></p><p>And the same may apply to Range, for that matter, because…<br></p><p>&gt; (OTOH, I don’t understand why 6…0 is currently a crash, rather than the, IMHO, obviously intended sequence of “6,5,4,3,2,1,0”, so maybe I’m not the best person to ask)<br></p><p>Well, suppose you say `6...0`. There are three ways that could be represented:<br></p><p>1.	Range(start: 0, end: 6)<br>2.	Range(start: 6, end: 0)<br>3.	Range(start: 0, end: 6, reversed: true)<br></p><p>Option 1 throws away the fact that the range was ever reversed, so it doesn&#39;t actually help with this case.<br></p><p>Option 2 complicates testing. Where before you might have written this:<br></p><p>	let inBounds = start &lt;= x &lt; end<br></p><p>Now you must write:<br></p><p>	let inBounds: Bool<br>	if start &lt; end {<br>		inBounds = start &lt;= x &amp;&amp; x &lt; end<br>	}<br>	else {<br>		inBounds = start &gt;= x &amp;&amp; x &gt; end<br>	}<br></p><p>Remember, conditional branches are relatively slow, and we want to avoid them where we can. If this is, for instance, the test of a loop, the extra branch is not a good thing.<br></p><p>Option 3 avoids this issue, but it requires more space. It also requires branches in other places which care about order.<br></p><p>And both 2 and 3 complicate slicing. If you say `array[6...0] = newValues`, the operation should probably be performed such that `array[6] == newValues[0]`. That seems difficult to implement—and all too easy to forget to handle. And I can imagine that it might prevent certain optimizations if the compiler couldn&#39;t prove they were forward ranges.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While I’m in favour of the basic idea I think the operator selection is too complex, and I’m not sure about the need for negative strides. Really all I want are the following:<br>&gt; <br>&gt; 	(0 ... 6).striding(by: 2)	// [0, 2, 4, 6]		x from 0 to 6<br>&gt; 	(0 ..&lt; 6).striding(by: 2)	// [0, 2, 4]		x from 0 while &lt;6<br>&gt; 	(6 ... 0).striding(by: 2)	// [6, 4, 2, 0]		x from 6 to 0<br>&gt; 	(6 ..&gt; 0).striding(by: 2)	// [6, 4, 2]		x from 6 while &gt;0<br>&gt; <br>&gt; Everything else should be coverable either by flipping the order, or using .reverse(). The main advantage is that there’s only one new operator to clarify the 6 ..&gt; 0 case, though you could always just reuse the existing operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br></p><p>`.reverse()` returns an array, though, not a StrideTo&lt;&gt;, which means it’ll get in an infinite loop on infinite sequences. This works fine:<br>for i in stride(from: 0.0, to: Double.infinity, by: M_PI) {<br>    if someTestInvolving(i) { break }<br>    ...<br>}<br></p><p>But this never even starts executing the loop because of the infinite loop inside `.reverse()`:<br>for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>    if someTestInvolving(i) { break }<br>    ...<br>}<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/335e226a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  9, 2016 at 11:00:00pm</p></header><div class="content"><p>Yikes. Not too concerned about the infinite loop issue, as floating point<br>strides when fixed to avoid error accumulation will necessarily enforce a<br>finite number of steps. However, you&#39;re talking a regular, not-at-all-lazy<br>Array being returned? That would be not good at all...<br></p><p>On Sun, Apr 10, 2016 at 12:29 AM Dave via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; While I’m in favour of the basic idea I think the operator selection is<br>&gt; too complex, and I’m not sure about the need for negative strides. Really<br>&gt; all I want are the following:<br>&gt;<br>&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt; (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt; (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;<br>&gt; Everything else should be coverable either by flipping the order, or using<br>&gt; .reverse(). The main advantage is that there’s only one new operator to<br>&gt; clarify the 6 ..&gt; 0 case, though you could always just reuse the existing<br>&gt; operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt;<br>&gt;<br>&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, which means it’ll<br>&gt; get in an infinite loop on infinite sequences. This works fine:<br>&gt; for i in stride(from: 0.0, to: Double.infinity, by: M_PI) {<br>&gt;     if someTestInvolving(i) { break }<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; But this never even starts executing the loop because of the infinite loop<br>&gt; inside `.reverse()`:<br>&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt;     if someTestInvolving(i) { break }<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/1127452f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  9, 2016 at 10:00:00pm</p></header><div class="content"><p>It’s not a matter of floating point error accumulation… At least on my machine, once a Double hits +/-∞, there’s no way that I know of to get back to normal floating point numbers. That is to say, for *all* normal, finite values of x, &quot;-Double.infinity + x&quot; will just return “-inf&quot;. If x is to equal Double.infinity, Double.NaN, or Double.quietNaN, then it’ll return “nan” (which, incidentally, will fail the regular equality test… Double.NaN isn’t even equal to itself; I think checking the floating point class is the way to do it).<br></p><p>I could easily be missing something, but AFAICT the only way to always get the correct sequence (without splitting the floating point types off into their own thing) is either have a negative stride swap start and end *before* the StrideTo starts generating values (that is, *not* by just calling `.reverse()` on something with a positive stride), or to allow “0 ..&lt; -Double.infinity” to be a valid range (with the negative stride being implied).<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 9, 2016, at 6:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yikes. Not too concerned about the infinite loop issue, as floating point strides when fixed to avoid error accumulation will necessarily enforce a finite number of steps. However, you&#39;re talking a regular, not-at-all-lazy Array being returned? That would be not good at all...<br>&gt; <br>&gt; On Sun, Apr 10, 2016 at 12:29 AM Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While I’m in favour of the basic idea I think the operator selection is too complex, and I’m not sure about the need for negative strides. Really all I want are the following:<br>&gt;&gt; <br>&gt;&gt; 	(0 ... 6).striding(by: 2)	// [0, 2, 4, 6]		x from 0 to 6<br>&gt;&gt; 	(0 ..&lt; 6).striding(by: 2)	// [0, 2, 4]		x from 0 while &lt;6<br>&gt;&gt; 	(6 ... 0).striding(by: 2)	// [6, 4, 2, 0]		x from 6 to 0<br>&gt;&gt; 	(6 ..&gt; 0).striding(by: 2)	// [6, 4, 2]		x from 6 while &gt;0<br>&gt;&gt; <br>&gt;&gt; Everything else should be coverable either by flipping the order, or using .reverse(). The main advantage is that there’s only one new operator to clarify the 6 ..&gt; 0 case, though you could always just reuse the existing operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt; <br>&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, which means it’ll get in an infinite loop on infinite sequences. This works fine:<br>&gt; for i in stride(from: 0.0, to: Double.infinity, by: M_PI) {<br>&gt;     if someTestInvolving(i) { break }<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; But this never even starts executing the loop because of the infinite loop inside `.reverse()`:<br>&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt;     if someTestInvolving(i) { break }<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/13dad278/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 10, 2016 at 05:00:00am</p></header><div class="content"><p>We will be proposing exactly that which you&#39;ve put in parentheses, i.e.<br>floating point types will get their own strides, and it will be a<br>precondition failure to try to stride from or to infinity or nan :)<br></p><p>On Sun, Apr 10, 2016 at 4:47 AM &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; It’s not a matter of floating point error accumulation… At least on my<br>&gt; machine, once a Double hits +/-∞, there’s no way that I know of to get back<br>&gt; to normal floating point numbers. That is to say, for *all* normal, finite<br>&gt; values of x, &quot;-Double.infinity + x&quot; will just return “-inf&quot;. If x is to<br>&gt; equal Double.infinity, Double.NaN, or Double.quietNaN, then it’ll return<br>&gt; “nan” (which, incidentally, will fail the regular equality test… Double.NaN<br>&gt; isn’t even equal to itself; I think checking the floating point class is<br>&gt; the way to do it).<br>&gt;<br>&gt; I could easily be missing something, but AFAICT the only way to always get<br>&gt; the correct sequence (without splitting the floating point types off into<br>&gt; their own thing) is either have a negative stride swap start and end<br>&gt; *before* the StrideTo starts generating values (that is, *not* by just<br>&gt; calling `.reverse()` on something with a positive stride), or to allow “0<br>&gt; ..&lt; -Double.infinity” to be a valid range (with the negative stride being<br>&gt; implied).<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Apr 9, 2016, at 6:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Yikes. Not too concerned about the infinite loop issue, as floating point<br>&gt; strides when fixed to avoid error accumulation will necessarily enforce a<br>&gt; finite number of steps. However, you&#39;re talking a regular, not-at-all-lazy<br>&gt; Array being returned? That would be not good at all...<br>&gt;<br>&gt; On Sun, Apr 10, 2016 at 12:29 AM Dave via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; While I’m in favour of the basic idea I think the operator selection is<br>&gt;&gt; too complex, and I’m not sure about the need for negative strides. Really<br>&gt;&gt; all I want are the following:<br>&gt;&gt;<br>&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt;&gt; (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt;&gt; (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;&gt;<br>&gt;&gt; Everything else should be coverable either by flipping the order, or<br>&gt;&gt; using .reverse(). The main advantage is that there’s only one new operator<br>&gt;&gt; to clarify the 6 ..&gt; 0 case, though you could always just reuse the<br>&gt;&gt; existing operator if you just interpret it as “x from 6 to, but not<br>&gt;&gt; including, 0&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, which means<br>&gt;&gt; it’ll get in an infinite loop on infinite sequences. This works fine:<br>&gt;&gt; for i in stride(from: 0.0, to: Double.infinity, by: M_PI) {<br>&gt;&gt;     if someTestInvolving(i) { break }<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But this never even starts executing the loop because of the infinite<br>&gt;&gt; loop inside `.reverse()`:<br>&gt;&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt;&gt;     if someTestInvolving(i) { break }<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/26bb4e3c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 10, 2016 at 01:00:00am</p></header><div class="content"><p>I understand (and agree with) 3/4 of that… Why do we want to prevent striding *to* an infinity? I mean, yeah it’ll take a long time to get there, but with the new floating point stride code, a floating point value will *eventually* “overflow” into infinity (or `iteration += 1` will overflow and crash), it’s just that at that point there isn’t a straight-forward way to go the other direction anymore.<br></p><p>Actually, striding from an infinity should be ok, too, as long as it’s not the actual starting point:<br>let x = -Double.infinity ... 0.0 // Big Problems in, um, Non-Little Loops… or something… (and apologies to Kurt Russell)<br>let x = -Double.infinity &lt;.. 0.0 // starts at `nextafter(start, end)` (-1.797693134862316e+308, in this case)<br></p><p>If the infinities are definitely out even as exclusive endpoints, can the floating point types get min/max properties like the integer types have?<br>let x = Double.min ... Double.max // same as -1.797693134862316e+308 ... 1.797693134862316e+308, but way easier to write<br>let x = Float.min ... Float.max // same as -3.402823e+38 ... 3.402823e+38<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 10, 2016, at 12:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; We will be proposing exactly that which you&#39;ve put in parentheses, i.e. floating point types will get their own strides, and it will be a precondition failure to try to stride from or to infinity or nan :)<br>&gt; <br>&gt; On Sun, Apr 10, 2016 at 4:47 AM &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; It’s not a matter of floating point error accumulation… At least on my machine, once a Double hits +/-∞, there’s no way that I know of to get back to normal floating point numbers. That is to say, for *all* normal, finite values of x, &quot;-Double.infinity + x&quot; will just return “-inf&quot;. If x is to equal Double.infinity, Double.NaN, or Double.quietNaN, then it’ll return “nan” (which, incidentally, will fail the regular equality test… Double.NaN isn’t even equal to itself; I think checking the floating point class is the way to do it).<br>&gt; <br>&gt; I could easily be missing something, but AFAICT the only way to always get the correct sequence (without splitting the floating point types off into their own thing) is either have a negative stride swap start and end *before* the StrideTo starts generating values (that is, *not* by just calling `.reverse()` on something with a positive stride), or to allow “0 ..&lt; -Double.infinity” to be a valid range (with the negative stride being implied).<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Apr 9, 2016, at 6:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yikes. Not too concerned about the infinite loop issue, as floating point strides when fixed to avoid error accumulation will necessarily enforce a finite number of steps. However, you&#39;re talking a regular, not-at-all-lazy Array being returned? That would be not good at all...<br>&gt;&gt; <br>&gt;&gt; On Sun, Apr 10, 2016 at 12:29 AM Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I’m in favour of the basic idea I think the operator selection is too complex, and I’m not sure about the need for negative strides. Really all I want are the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	(0 ... 6).striding(by: 2)	// [0, 2, 4, 6]		x from 0 to 6<br>&gt;&gt;&gt; 	(0 ..&lt; 6).striding(by: 2)	// [0, 2, 4]		x from 0 while &lt;6<br>&gt;&gt;&gt; 	(6 ... 0).striding(by: 2)	// [6, 4, 2, 0]		x from 6 to 0<br>&gt;&gt;&gt; 	(6 ..&gt; 0).striding(by: 2)	// [6, 4, 2]		x from 6 while &gt;0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything else should be coverable either by flipping the order, or using .reverse(). The main advantage is that there’s only one new operator to clarify the 6 ..&gt; 0 case, though you could always just reuse the existing operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt;&gt; <br>&gt;&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, which means it’ll get in an infinite loop on infinite sequences. This works fine:<br>&gt;&gt; for i in stride(from: 0.0, to: Double.infinity, by: M_PI) {<br>&gt;&gt;     if someTestInvolving(i) { break }<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; But this never even starts executing the loop because of the infinite loop inside `.reverse()`:<br>&gt;&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt;&gt;     if someTestInvolving(i) { break }<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/a9690bcc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 10, 2016 at 07:00:00am</p></header><div class="content"><p>The iteration counter will be floating point and the iterator will break<br>down after incrementing by one is no longer exactly representable. It has<br>been made clear on this list that there is a strong preference that no<br>floating point stride should degenerate into an infinite loop due to this<br>issue. Thus, there will be a limit at the time a floating point stride is<br>created of 2^53 steps (in the case of a Double--some thought is necessary<br>for a Float). As currently mocked up the logic is whether start + 2^53 *<br>stride gets you to/through the end. If not, precondition failure.<br>On Sun, Apr 10, 2016 at 7:41 AM &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; I understand (and agree with) 3/4 of that… Why do we want to prevent<br>&gt; striding *to* an infinity? I mean, yeah it’ll take a long time to get<br>&gt; there, but with the new floating point stride code, a floating point value<br>&gt; will *eventually* “overflow” into infinity (or `iteration += 1` will<br>&gt; overflow and crash), it’s just that at that point there isn’t a<br>&gt; straight-forward way to go the other direction anymore.<br>&gt;<br>&gt; Actually, striding from an infinity should be ok, too, as long as it’s not<br>&gt; the actual starting point:<br>&gt; let x = -Double.infinity ... 0.0 // Big Problems in, um, Non-Little<br>&gt; Loops… or something… (and apologies to Kurt Russell)<br>&gt; let x = -Double.infinity &lt;.. 0.0 // starts at `nextafter(start, end)`<br>&gt; (-1.797693134862316e+308, in this case)<br>&gt;<br>&gt; If the infinities are definitely out even as exclusive endpoints, can the<br>&gt; floating point types get min/max properties like the integer types have?<br>&gt; let x = Double.min ... Double.max // same as -1.797693134862316e+308 ... 1.797693134862316e+308,<br>&gt; but way easier to write<br>&gt; let x = Float.min ... Float.max // same as -3.402823e+38 ... 3.402823e+38<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Apr 10, 2016, at 12:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; We will be proposing exactly that which you&#39;ve put in parentheses, i.e.<br>&gt; floating point types will get their own strides, and it will be a<br>&gt; precondition failure to try to stride from or to infinity or nan :)<br>&gt;<br>&gt; On Sun, Apr 10, 2016 at 4:47 AM &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;&gt; It’s not a matter of floating point error accumulation… At least on my<br>&gt;&gt; machine, once a Double hits +/-∞, there’s no way that I know of to get back<br>&gt;&gt; to normal floating point numbers. That is to say, for *all* normal, finite<br>&gt;&gt; values of x, &quot;-Double.infinity + x&quot; will just return “-inf&quot;. If x is to<br>&gt;&gt; equal Double.infinity, Double.NaN, or Double.quietNaN, then it’ll return<br>&gt;&gt; “nan” (which, incidentally, will fail the regular equality test… Double.NaN<br>&gt;&gt; isn’t even equal to itself; I think checking the floating point class is<br>&gt;&gt; the way to do it).<br>&gt;&gt;<br>&gt;&gt; I could easily be missing something, but AFAICT the only way to always<br>&gt;&gt; get the correct sequence (without splitting the floating point types off<br>&gt;&gt; into their own thing) is either have a negative stride swap start and end<br>&gt;&gt; *before* the StrideTo starts generating values (that is, *not* by just<br>&gt;&gt; calling `.reverse()` on something with a positive stride), or to allow “0<br>&gt;&gt; ..&lt; -Double.infinity” to be a valid range (with the negative stride being<br>&gt;&gt; implied).<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; On Apr 9, 2016, at 6:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yikes. Not too concerned about the infinite loop issue, as floating point<br>&gt;&gt; strides when fixed to avoid error accumulation will necessarily enforce a<br>&gt;&gt; finite number of steps. However, you&#39;re talking a regular, not-at-all-lazy<br>&gt;&gt; Array being returned? That would be not good at all...<br>&gt;&gt;<br>&gt;&gt; On Sun, Apr 10, 2016 at 12:29 AM Dave via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I’m in favour of the basic idea I think the operator selection is<br>&gt;&gt;&gt; too complex, and I’m not sure about the need for negative strides. Really<br>&gt;&gt;&gt; all I want are the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt;&gt;&gt; (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt;&gt;&gt; (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt;&gt;&gt; (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Everything else should be coverable either by flipping the order, or<br>&gt;&gt;&gt; using .reverse(). The main advantage is that there’s only one new operator<br>&gt;&gt;&gt; to clarify the 6 ..&gt; 0 case, though you could always just reuse the<br>&gt;&gt;&gt; existing operator if you just interpret it as “x from 6 to, but not<br>&gt;&gt;&gt; including, 0&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, which means<br>&gt;&gt;&gt; it’ll get in an infinite loop on infinite sequences. This works fine:<br>&gt;&gt;&gt; for i in stride(from: 0.0, to: Double.infinity, by: M_PI) {<br>&gt;&gt;&gt;     if someTestInvolving(i) { break }<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But this never even starts executing the loop because of the infinite<br>&gt;&gt;&gt; loop inside `.reverse()`:<br>&gt;&gt;&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt;&gt;&gt;     if someTestInvolving(i) { break }<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/bf974bf8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  9, 2016 at 06:00:00pm</p></header><div class="content"><p>on Sat Apr 09 2016, davesweeris-AT-mac.com wrote:<br></p><p>&gt;     On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     While I’m in favour of the basic idea I think the operator selection is too<br>&gt;     complex, and I’m not sure about the need for negative strides. Really all I<br>&gt;     want are the following:<br>&gt;<br>&gt;     (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt;     (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt;     (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt;     (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;<br>&gt;     Everything else should be coverable either by flipping the order, or using .<br>&gt;     reverse(). The main advantage is that there’s only one new operator to<br>&gt;     clarify the 6 ..&gt; 0 case, though you could always just reuse the existing<br>&gt;     operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt;<br>&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, <br></p><p>.reversed() returns a ReversedCollection when the underlying collection<br>is bidirectional:<br></p><p>https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Reverse.swift#L250<br></p><p>That&#39;s lazy and cheap.<br></p><p>&gt; which means it’ll get in an infinite loop on infinite sequences. <br>&gt; This works fine: for i in stride(from: 0.0, to: Double.infinity, by:<br>&gt; M_PI) { if someTestInvolving(i) { break } ...  }<br>&gt;<br>&gt; But this never even starts executing the loop because of the infinite loop<br>&gt; inside `.reverse()`:<br>&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt; if someTestInvolving(i) { break }<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Oh, right, we’re talking about Swift 3.0… I really need to get that up and running on my computer.<br></p><p><br>&gt; On Apr 9, 2016, at 8:58 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Apr 09 2016, davesweeris-AT-mac.com wrote:<br>&gt; <br>&gt;&gt;    On Apr 9, 2016, at 4:33 AM, Haravikk via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    While I’m in favour of the basic idea I think the operator selection is too<br>&gt;&gt;    complex, and I’m not sure about the need for negative strides. Really all I<br>&gt;&gt;    want are the following:<br>&gt;&gt; <br>&gt;&gt;    (0 ... 6).striding(by: 2) // [0, 2, 4, 6] x from 0 to 6<br>&gt;&gt;    (0 ..&lt; 6).striding(by: 2) // [0, 2, 4] x from 0 while &lt;6<br>&gt;&gt;    (6 ... 0).striding(by: 2) // [6, 4, 2, 0] x from 6 to 0<br>&gt;&gt;    (6 ..&gt; 0).striding(by: 2) // [6, 4, 2] x from 6 while &gt;0<br>&gt;&gt; <br>&gt;&gt;    Everything else should be coverable either by flipping the order, or using .<br>&gt;&gt;    reverse(). The main advantage is that there’s only one new operator to<br>&gt;&gt;    clarify the 6 ..&gt; 0 case, though you could always just reuse the existing<br>&gt;&gt;    operator if you just interpret it as “x from 6 to, but not including, 0&quot;<br>&gt;&gt; <br>&gt;&gt; `.reverse()` returns an array, though, not a StrideTo&lt;&gt;, <br>&gt; <br>&gt; .reversed() returns a ReversedCollection when the underlying collection<br>&gt; is bidirectional:<br>&gt; <br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Reverse.swift#L250<br>&gt; <br>&gt; That&#39;s lazy and cheap.<br>&gt; <br>&gt;&gt; which means it’ll get in an infinite loop on infinite sequences. <br>&gt;&gt; This works fine: for i in stride(from: 0.0, to: Double.infinity, by:<br>&gt;&gt; M_PI) { if someTestInvolving(i) { break } ...  }<br>&gt;&gt; <br>&gt;&gt; But this never even starts executing the loop because of the infinite loop<br>&gt;&gt; inside `.reverse()`:<br>&gt;&gt; for i in stride(from: -Double.infinity, to: 0.0, by: M_PI).reverse() {<br>&gt;&gt; if someTestInvolving(i) { break }<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
