<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br></p><p>@interface MyClass : NSObject<br></p><p>@property (nonatomic) ForeignClass* foreignObject;<br>@property (nonatomic) int64_t foreignKey;<br></p><p>@end<br></p><p>@implementation MyClass<br></p><p>- (void)setForeignKey:(int64_t)foreignKey {<br>   _foreignKey = foreignKey;<br>   _foreignObject = nil;<br>}<br></p><p>- (ForeignClass*)foreignObject {<br>   if (!_foreignObject) {<br>       _foreignObject = [Database expensiveSelect:_foreignKey];<br>   }<br>   return _foreignObject;<br>}<br></p><p>@end<br></p><p>Unfortunately, the lazy keyword in Swift, which was supposed to make the lazy initialization pattern more concsive does not work in this case:<br></p><p>class MyClass {<br>   var foreignKey: Int64 {<br>       didSet {<br>           self.foreignObject = nil<br>       }<br>   }<br>   <br>   lazy var foreignObject: ForeignClass? = {<br>       return Database.expensiveSelect(self.foreignKey)<br>   }()<br>}<br></p><p>I&#39;m forced to rewrite it this way:<br></p><p>class MyClass {<br>   var foreignKey: Int64 {<br>       didSet {<br>           self.foreignObject = nil<br>       }<br>   }<br>   <br>   private var _foreignObject: ForeignClass? = nil<br>   var foreignObject: ForeignClass? {<br>       if _foreignObject == nil {<br>           _foreignObject = Database.expensiveSelect(self.foreignKey)<br>       }<br>       return _foreignObject<br>   }<br>}<br></p><p>When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>I want your opinion on three alternatives:<br></p><p>1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>3- Add a cache modifier that re-calcualtes when nil.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December  4, 2015 at 01:00:00pm</p></header><div class="content"><p>To me this actually feels more like something that might fit better as an additional type of optional, rather than a language feature.<br></p><p>Setting this optional to nil could work normally, and any attempt to access the value when nil would cause the reload to occur. The initialization semantics might be a tad ugly though.<br></p><p>var myLazyOpt = ReloadingOptional&lt;ForeignClass&gt;({<br>return Database.expensiveSelect(self.foreignKey)<br>})<br></p><p>You could probably implement something like this yourself, though I&#39;m not sure how elegant that would be without full language support.<br></p><p>Thanks for your time,<br>Cole Kurkowski<br>&gt; On Dec 4, 2015, at 07:40, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt; <br>&gt; @interface MyClass : NSObject<br>&gt; <br>&gt; @property (nonatomic) ForeignClass* foreignObject;<br>&gt; @property (nonatomic) int64_t foreignKey;<br>&gt; <br>&gt; @end<br>&gt; <br>&gt; @implementation MyClass<br>&gt; <br>&gt; - (void)setForeignKey:(int64_t)foreignKey {<br>&gt;   _foreignKey = foreignKey;<br>&gt;   _foreignObject = nil;<br>&gt; }<br>&gt; <br>&gt; - (ForeignClass*)foreignObject {<br>&gt;   if (!_foreignObject) {<br>&gt;       _foreignObject = [Database expensiveSelect:_foreignKey];<br>&gt;   }<br>&gt;   return _foreignObject;<br>&gt; }<br>&gt; <br>&gt; @end<br>&gt; <br>&gt; Unfortunately, the lazy keyword in Swift, which was supposed to make the lazy initialization pattern more concsive does not work in this case:<br>&gt; <br>&gt; class MyClass {<br>&gt;   var foreignKey: Int64 {<br>&gt;       didSet {<br>&gt;           self.foreignObject = nil<br>&gt;       }<br>&gt;   }<br>&gt; <br>&gt;   lazy var foreignObject: ForeignClass? = {<br>&gt;       return Database.expensiveSelect(self.foreignKey)<br>&gt;   }()<br>&gt; }<br>&gt; <br>&gt; I&#39;m forced to rewrite it this way:<br>&gt; <br>&gt; class MyClass {<br>&gt;   var foreignKey: Int64 {<br>&gt;       didSet {<br>&gt;           self.foreignObject = nil<br>&gt;       }<br>&gt;   }<br>&gt; <br>&gt;   private var _foreignObject: ForeignClass? = nil<br>&gt;   var foreignObject: ForeignClass? {<br>&gt;       if _foreignObject == nil {<br>&gt;           _foreignObject = Database.expensiveSelect(self.foreignKey)<br>&gt;       }<br>&gt;       return _foreignObject<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt; I want your opinion on three alternatives:<br>&gt; <br>&gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt; 3- Add a cache modifier that re-calcualtes when nil.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 5:40 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt; <br>&gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt; I want your opinion on three alternatives:<br>&gt; <br>&gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt; 3- Add a cache modifier that re-calcualtes when nil.<br></p><p>Hi David,<br></p><p>My preference is:<br>4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.<br></p><p>The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).<br></p><p>In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.<br></p><p>The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)<br></p><p>A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).<br></p><p>We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  6, 2015 at 11:00:00am</p></header><div class="content"><p>This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D<br></p><p>This has just become my #1 feature proposal!<br></p><p>Super excited David!<br></p><p>&gt; On 06 Dec 2015, at 08:27, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 5:40 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt;&gt; <br>&gt;&gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt;&gt; I want your opinion on three alternatives:<br>&gt;&gt; <br>&gt;&gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt;&gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt;&gt; 3- Add a cache modifier that re-calcualtes when nil.<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; My preference is:<br>&gt; 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.<br>&gt; <br>&gt; The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).<br>&gt; <br>&gt; In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.<br>&gt; <br>&gt; The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)<br>&gt; <br>&gt; A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).<br>&gt; <br>&gt; We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d933552ea7fda10a4488a74223c00988?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Thorsten Seitz</string> &lt;thorsten.seitz at web.de&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):<br></p><p>var x : T by Delayed()<br></p><p>with<br></p><p>class Delayed&lt;T&gt; {<br>	var value : T!<br>	func getValue(this: Any?, property: Property&lt;T&gt;) -&gt; T { return value }<br>	func setValue(this: Any?, property: Property&lt;T&gt;, value: T) {<br>		guard x == nil else { abort(„Property \(property) of \(this) has already been initialized when trying to initialize with value \(value)“) }<br>		self.value = value<br>	}<br>}<br></p><p>Some remarks<br>* I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error<br>* Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.<br>* Is the compiler able to optimize away the overhead of going through getValue on each access?<br>* I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow <br></p><p>-Thorsten<br></p><p>&gt; Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D<br>&gt; <br>&gt; This has just become my #1 feature proposal!<br>&gt; <br>&gt; Super excited David!<br>&gt; <br>&gt;&gt; On 06 Dec 2015, at 08:27, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 5:40 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt;&gt;&gt; I want your opinion on three alternatives:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt;&gt;&gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt;&gt;&gt; 3- Add a cache modifier that re-calcualtes when nil.<br>&gt;&gt; <br>&gt;&gt; Hi David,<br>&gt;&gt; <br>&gt;&gt; My preference is:<br>&gt;&gt; 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.<br>&gt;&gt; <br>&gt;&gt; The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).<br>&gt;&gt; <br>&gt;&gt; In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.<br>&gt;&gt; <br>&gt;&gt; The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)<br>&gt;&gt; <br>&gt;&gt; A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).<br>&gt;&gt; <br>&gt;&gt; We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  6, 2015 at 08:00:00am</p></header><div class="content"><p>Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.<br></p><p>I would really like to see something like `delayed let x : T` to handle the second phase of initialization problem, although I would add the requirement that it *must* be initialized in the second phase and it *cannot* be read until it is set (as far as the compiler can detect this through control flow analysis).  This would behave quite similarly to a simple `let x : T` member but with the caveat that it is possible to blow up if you attempt to read before setting it in the second phase and the compiler cannot detect the read attempt when performing control flow analysis.  <br></p><p>If Swift’s property delegates were able to both support let members and require initialization during the second phase (so the instance is guaranteed to be fully initialized and work correctly after initialization completes) then they would be a great solution.  I just can’t imagine how they could enforce this semantic.  I’m looking forward to reading Joe’s proposal and will be delighted if his design is able to support the desired semantics.<br></p><p>Chris, do you agree that this semantic is desirable to support one way or another?  <br></p><p>Thorsten’s attempt to implement something like this using a property delegate looks really dangerous to me.  A var member that blows up when somebody attempts to set it a second time seems extremely fragile.  It’s like an IUO but rather than blowing up when read it also blows up when set more than once.<br></p><p>Matthew<br></p><p><br>&gt; On Dec 6, 2015, at 6:32 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):<br>&gt; <br>&gt; var x : T by Delayed()<br>&gt; <br>&gt; with<br>&gt; <br>&gt; class Delayed&lt;T&gt; {<br>&gt; 	var value : T!<br>&gt; 	func getValue(this: Any?, property: Property&lt;T&gt;) -&gt; T { return value }<br>&gt; 	func setValue(this: Any?, property: Property&lt;T&gt;, value: T) {<br>&gt; 		guard x == nil else { abort(„Property \(property) of \(this) has already been initialized when trying to initialize with value \(value)“) }<br>&gt; 		self.value = value<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Some remarks<br>&gt; * I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error<br>&gt; * Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.<br>&gt; * Is the compiler able to optimize away the overhead of going through getValue on each access?<br>&gt; * I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;&gt; Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D<br>&gt;&gt; <br>&gt;&gt; This has just become my #1 feature proposal!<br>&gt;&gt; <br>&gt;&gt; Super excited David!<br>&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 08:27, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 5:40 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt;&gt;&gt;&gt; I want your opinion on three alternatives:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt;&gt;&gt;&gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt;&gt;&gt;&gt; 3- Add a cache modifier that re-calcualtes when nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi David,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My preference is:<br>&gt;&gt;&gt; 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d933552ea7fda10a4488a74223c00988?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Thorsten Seitz</string> &lt;thorsten.seitz at web.de&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>Absolutely correct. I’d prefer a statically checked solution, too :-)<br></p><p>-Thorsten<br></p><p><br>&gt; Am 06.12.2015 um 15:36 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.<br>&gt; <br>&gt; I would really like to see something like `delayed let x : T` to handle the second phase of initialization problem, although I would add the requirement that it *must* be initialized in the second phase and it *cannot* be read until it is set (as far as the compiler can detect this through control flow analysis).  This would behave quite similarly to a simple `let x : T` member but with the caveat that it is possible to blow up if you attempt to read before setting it in the second phase and the compiler cannot detect the read attempt when performing control flow analysis.  <br>&gt; <br>&gt; If Swift’s property delegates were able to both support let members and require initialization during the second phase (so the instance is guaranteed to be fully initialized and work correctly after initialization completes) then they would be a great solution.  I just can’t imagine how they could enforce this semantic.  I’m looking forward to reading Joe’s proposal and will be delighted if his design is able to support the desired semantics.<br>&gt; <br>&gt; Chris, do you agree that this semantic is desirable to support one way or another?  <br>&gt; <br>&gt; Thorsten’s attempt to implement something like this using a property delegate looks really dangerous to me.  A var member that blows up when somebody attempts to set it a second time seems extremely fragile.  It’s like an IUO but rather than blowing up when read it also blows up when set more than once.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 6:32 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):<br>&gt;&gt; <br>&gt;&gt; var x : T by Delayed()<br>&gt;&gt; <br>&gt;&gt; with<br>&gt;&gt; <br>&gt;&gt; class Delayed&lt;T&gt; {<br>&gt;&gt; 	var value : T!<br>&gt;&gt; 	func getValue(this: Any?, property: Property&lt;T&gt;) -&gt; T { return value }<br>&gt;&gt; 	func setValue(this: Any?, property: Property&lt;T&gt;, value: T) {<br>&gt;&gt; 		guard x == nil else { abort(„Property \(property) of \(this) has already been initialized when trying to initialize with value \(value)“) }<br>&gt;&gt; 		self.value = value<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Some remarks<br>&gt;&gt; * I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error<br>&gt;&gt; * Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.<br>&gt;&gt; * Is the compiler able to optimize away the overhead of going through getValue on each access?<br>&gt;&gt; * I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;&gt; Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has just become my #1 feature proposal!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Super excited David!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 08:27, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 5:40 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.<br>&gt;&gt;&gt;&gt;&gt; I want your opinion on three alternatives:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1- Do nothing, and use the slightly uglier Swift example when using a cache.<br>&gt;&gt;&gt;&gt;&gt; 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).<br>&gt;&gt;&gt;&gt;&gt; 3- Add a cache modifier that re-calcualtes when nil.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi David,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My preference is:<br>&gt;&gt;&gt;&gt; 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>lazy keyword vs lazy initialization pattern</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 6:36 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.<br></p><p>Lets wait to see Joe’s proposal before discussing in detail.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
