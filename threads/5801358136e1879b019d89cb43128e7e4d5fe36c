<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Introduction<br></p><p>A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br></p><p>Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br></p><p>SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br></p><p>let i = 17<br>let plist = [&quot;seventeen&quot;: i]<br>// OK<br>try! NSJSONSerialization.data(withJSONObject: plist)<br></p><p>let j: UInt8 = 38<br>let brokenPlist = [&quot;thirty-eight&quot;: j]<br>// Will throw because `j` didn&#39;t bridge to a JSON type<br>try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br></p><p>There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br></p><p>anim.toValue = CGPoint.zero<br>However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br></p><p> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br></p><p>All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br></p><p>Int8<br>Int16<br>Int32<br>Int64<br>UInt8<br>UInt16<br>UInt32<br>UInt64<br>Float<br>Double<br>Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br></p><p>NSRange<br>CGPoint<br>CGVector<br>CGSize<br>CGRect<br>CGAffineTransform<br>UIEdgeInsets<br>UIOffset<br>CATransform3D<br>CMTime<br>CMTimeRange<br>CMTimeMapping<br>MKCoordinate<br>MKCoordinateSpan<br>SCNVector3<br>SCNVector4<br>SCNMatrix4<br> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br></p><p>Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br></p><p>NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br></p><p> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br></p><p> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br></p><p>We can of course do nothing and leave the behavior as-is.<br></p><p>NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br></p><p>	- Doug<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/5801e36c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>August 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Early feedback is +1, you folks sure know how to write proposals on<br>Foundation. ;-)<br></p><p>I filed radar &lt;rdar://problem/20807093&gt; related to this a while ago. Is<br>there any chance the struct conformances could be applied using the<br>objc_boxable attribute added to Clang last year? Apple&#39;s definition of<br>what they consider to be simple, fixed structs should ideally live in<br>one place (apinotes would do as well).<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p><p><br>On Tue, Aug 23, 2016, at 03:36 PM, Douglas Gregor via swift-evolution wrote:<br>&gt; Introduction<br>&gt; A handful of Swift numeric types are bridged to NSNumber when passed<br>&gt; into Objective-C object contexts. We should extend this bridging<br>&gt; behavior to all Swift numeric types. We should also bridge common<br>&gt; Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt; Swift-evolution thread: TBD[1]<br>&gt; Motivation<br>&gt; SE-0116[2] changed how Objective-C&#39;s id and untyped collections import<br>&gt; into Swift to use the Any type. This makes it much more natural to<br>&gt; pass in Swift value types such as String and Array, but introduces the<br>&gt; hazard of passing in types that don&#39;t bridge well to Objective-C<br>&gt; objects. Particularly problematic are number types; whereas Int, UInt,<br>&gt; and Double will automatically bridge as NSNumber, other-sized numeric<br>&gt; types fall back to opaque boxing:<br>&gt; let i = 17 let plist = [&quot;seventeen&quot;: i] // OK try!<br>&gt; NSJSONSerialization.data(withJSONObject: plist)<br></p><p>&gt; let j: UInt8 = 38 let brokenPlist = [&quot;thirty-eight&quot;: j] // Will throw<br>&gt; because `j` didn&#39;t bridge to a JSON type try!<br>&gt; NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt; We had shied away from enabling this bridging for all numeric types in<br>&gt; the Swift 1.x days, among other reasons because we allowed implicit<br>&gt; bridging conversions in both directions from Swift value types to NS<br>&gt; objects and back, which meant that you could slowly and brokenly<br>&gt; convert between any two numeric types transitively via NSNumber if we<br>&gt; allowed this. We killed the implicit conversions completely with SE-<br>&gt; 0072[3] so that is no longer a concern, so expanding the bridging<br>&gt; behavior should no longer be a major problem, since it must now always<br>&gt; be explicitly asked for.<br>&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary<br>&gt; objects with members that are NSValue-boxed structs. Matt Neuberg<br>&gt; highlights Core Automation as an example in this bug report[4]. With<br>&gt; id-as-Any, it&#39;s natural to expect this to work:<br>&gt; anim.toValue = CGPoint.zero<br>&gt; However, the CGPoint value does not box as a meaningful Objective-C<br>&gt; object, so this currently breaks Core Animation at runtime despite<br>&gt; compiling successfully. It would be more idiomatic to bridge these<br>&gt; types to NSValue.<br>&gt; Proposed solution<br>&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when<br>&gt; used as objects in Objective-C:<br></p><p><br>&gt;  * Int8<br>&gt;  * Int16<br>&gt;  * Int32<br>&gt;  * Int64<br>&gt;  * UInt8<br>&gt;  * UInt16<br>&gt;  * UInt32<br>&gt;  * UInt64<br>&gt;  * Float<br>&gt;  * Double<br>&gt; Cocoa structs with existing NSValue factory and property support<br>&gt; should be made to bridge to NSValue when used as objects:<br></p><p><br>&gt;  * NSRange<br>&gt;  * CGPoint<br>&gt;  * CGVector<br>&gt;  * CGSize<br>&gt;  * CGRect<br>&gt;  * CGAffineTransform<br>&gt;  * UIEdgeInsets<br>&gt;  * UIOffset<br>&gt;  * CATransform3D<br>&gt;  * CMTime<br>&gt;  * CMTimeRange<br>&gt;  * CMTimeMapping<br>&gt;  * MKCoordinate<br>&gt;  * MKCoordinateSpan<br>&gt;  * SCNVector3<br>&gt;  * SCNVector4<br>&gt;  * SCNMatrix4<br>&gt; Detailed design<br>&gt; Bridged NSNumber and NSValue objects must be castable back to their<br>&gt; original Swift value types. NSValue normally preserves the type<br>&gt; information of its included struct in its objCType property. We can<br>&gt; check the objCType of an NSValue instance when attempting to cast back<br>&gt; to a specific bridged struct type.<br>&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not<br>&gt; generally guarantee to remember the exact number type an instance was<br>&gt; constructed from. We can instead say that casting an NSNumber to a<br>&gt; Swift number type succeeds if the value of the NSNumber is exactly<br>&gt; representable as the target type. This is imperfect, since it means<br>&gt; that an NSNumbercan potentially be cast to a different type from the<br>&gt; original value, but it at least ensures that Swift values round-trip<br>&gt; through the bridge without depending on NSNumber implementation<br>&gt; details.<br>&gt; Impact on existing code<br>&gt; This change has no static source impact, but changes the dynamic<br>&gt; behavior of the Objective-C bridge. From Objective-C&#39;s perspective,<br>&gt; values that used to bridge as opaque objects will now come in as<br>&gt; semantically meaningful Objective-C objects. This should be a safe<br>&gt; change, since existing code should not be relying on the behavior of<br>&gt; opaque bridged objects. From Swift&#39;s perspective, values should still<br>&gt; be able to round-trip from concrete number and struct types to Anyto<br>&gt; id to Any and back by dynamic casting. The ability to reliably<br>&gt; distinguish the exact number type that an NSNumberwas constructed from<br>&gt; would be lost.<br>&gt; Alternatives considered<br>&gt; We can of course do nothing and leave the behavior as-is.<br>&gt; NSValue also carries factories for valueWithPointer: and<br>&gt; valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and<br>&gt; Unmanaged this way, but we probably shouldn’t.<br>&gt;<br>&gt; - Doug<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>Links:<br></p><p>  1. https://lists.swift.org/pipermail/swift-evolution/<br>  2. https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md<br>  3. https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md<br>  4. https://bugs.swift.org/browse/SR-2414<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/eac58943/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 3:44 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Early feedback is +1, you folks sure know how to write proposals on Foundation. ;-)<br>&gt; <br>&gt; I filed radar &lt;rdar://problem/20807093&gt; related to this a while ago. Is there any chance the struct conformances could be applied using the objc_boxable attribute added to Clang last year? Apple&#39;s definition of what they consider to be simple, fixed structs should ideally live in one place (apinotes would do as well).<br></p><p>I’d forgotten about objc_boxable. It might be possible to synthesize an _ObjectiveCBridgeable conformance for objc_boxable types, using the @encode string to match whether a particular NSValue can be bridged to that type.<br></p><p>	- Doug<br></p><p>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt; <br>&gt; <br>&gt; On Tue, Aug 23, 2016, at 03:36 PM, Douglas Gregor via swift-evolution wrote:<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt;&gt; <br>&gt;&gt; let i = 17<br>&gt;&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt;&gt; // OK<br>&gt;&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt;&gt; <br>&gt;&gt; let j: UInt8 = 38<br>&gt;&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt;&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt;&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt;&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt;&gt; <br>&gt;&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt;&gt; <br>&gt;&gt; anim.toValue = CGPoint.zero<br>&gt;&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt;&gt; <br>&gt;&gt; Int8<br>&gt;&gt; Int16<br>&gt;&gt; Int32<br>&gt;&gt; Int64<br>&gt;&gt; UInt8<br>&gt;&gt; UInt16<br>&gt;&gt; UInt32<br>&gt;&gt; UInt64<br>&gt;&gt; Float<br>&gt;&gt; Double<br>&gt;&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt;&gt; <br>&gt;&gt; NSRange<br>&gt;&gt; CGPoint<br>&gt;&gt; CGVector<br>&gt;&gt; CGSize<br>&gt;&gt; CGRect<br>&gt;&gt; CGAffineTransform<br>&gt;&gt; UIEdgeInsets<br>&gt;&gt; UIOffset<br>&gt;&gt; CATransform3D<br>&gt;&gt; CMTime<br>&gt;&gt; CMTimeRange<br>&gt;&gt; CMTimeMapping<br>&gt;&gt; MKCoordinate<br>&gt;&gt; MKCoordinateSpan<br>&gt;&gt; SCNVector3<br>&gt;&gt; SCNVector4<br>&gt;&gt; SCNMatrix4<br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt;&gt; <br>&gt;&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; We can of course do nothing and leave the behavior as-is.<br>&gt;&gt; <br>&gt;&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/6a039623/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 23, 2016 at 05:00:00pm</p></header><div class="content"><p>+1.  This is fantastic.<br></p><p>&gt; On Aug 23, 2016, at 5:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt; <br>&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt; <br>&gt; let i = 17<br>&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt; // OK<br>&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt; <br>&gt; let j: UInt8 = 38<br>&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt; <br>&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt; <br>&gt; anim.toValue = CGPoint.zero<br>&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt; <br>&gt; Int8<br>&gt; Int16<br>&gt; Int32<br>&gt; Int64<br>&gt; UInt8<br>&gt; UInt16<br>&gt; UInt32<br>&gt; UInt64<br>&gt; Float<br>&gt; Double<br>&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt; <br>&gt; NSRange<br>&gt; CGPoint<br>&gt; CGVector<br>&gt; CGSize<br>&gt; CGRect<br>&gt; CGAffineTransform<br>&gt; UIEdgeInsets<br>&gt; UIOffset<br>&gt; CATransform3D<br>&gt; CMTime<br>&gt; CMTimeRange<br>&gt; CMTimeMapping<br>&gt; MKCoordinate<br>&gt; MKCoordinateSpan<br>&gt; SCNVector3<br>&gt; SCNVector4<br>&gt; SCNMatrix4<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt; <br>&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; We can of course do nothing and leave the behavior as-is.<br>&gt; <br>&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt; <br>&gt; 	- Doug<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/b9d465cb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>August 23, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Doug,<br></p><p>&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt; <br>&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt; <br>&gt; let i = 17<br>&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt; // OK<br>&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt; <br>&gt; let j: UInt8 = 38<br>&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt; <br>&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt; <br>&gt; anim.toValue = CGPoint.zero<br>&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt; <br>&gt; Int8<br>&gt; Int16<br>&gt; Int32<br>&gt; Int64<br>&gt; UInt8<br>&gt; UInt16<br>&gt; UInt32<br>&gt; UInt64<br>&gt; Float<br>&gt; Double<br>&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt; <br>&gt; NSRange<br>&gt; CGPoint<br>&gt; CGVector<br>&gt; CGSize<br>&gt; CGRect<br>&gt; CGAffineTransform<br>&gt; UIEdgeInsets<br>&gt; UIOffset<br>&gt; CATransform3D<br>&gt; CMTime<br>&gt; CMTimeRange<br>&gt; CMTimeMapping<br>&gt; MKCoordinate<br>&gt; MKCoordinateSpan<br>&gt; SCNVector3<br>&gt; SCNVector4<br>&gt; SCNMatrix4<br></p><p>How do new types get added to this list? It’s certainly not the case that NSValue knows about them specifically; usually some kind of category is added after the fact.<br></p><p>Also, how does this bridging work for swift-corelibs-foundation on Linux, where bridging is disabled?<br></p><p>- Tony<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt; <br>&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; We can of course do nothing and leave the behavior as-is.<br>&gt; <br>&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt; <br>&gt; 	- Doug<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/1be651d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 4:00 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt;&gt; <br>&gt;&gt; let i = 17<br>&gt;&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt;&gt; // OK<br>&gt;&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt;&gt; <br>&gt;&gt; let j: UInt8 = 38<br>&gt;&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt;&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt;&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt;&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt;&gt; <br>&gt;&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt;&gt; <br>&gt;&gt; anim.toValue = CGPoint.zero<br>&gt;&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt;&gt; <br>&gt;&gt; Int8<br>&gt;&gt; Int16<br>&gt;&gt; Int32<br>&gt;&gt; Int64<br>&gt;&gt; UInt8<br>&gt;&gt; UInt16<br>&gt;&gt; UInt32<br>&gt;&gt; UInt64<br>&gt;&gt; Float<br>&gt;&gt; Double<br>&gt;&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt;&gt; <br>&gt;&gt; NSRange<br>&gt;&gt; CGPoint<br>&gt;&gt; CGVector<br>&gt;&gt; CGSize<br>&gt;&gt; CGRect<br>&gt;&gt; CGAffineTransform<br>&gt;&gt; UIEdgeInsets<br>&gt;&gt; UIOffset<br>&gt;&gt; CATransform3D<br>&gt;&gt; CMTime<br>&gt;&gt; CMTimeRange<br>&gt;&gt; CMTimeMapping<br>&gt;&gt; MKCoordinate<br>&gt;&gt; MKCoordinateSpan<br>&gt;&gt; SCNVector3<br>&gt;&gt; SCNVector4<br>&gt;&gt; SCNMatrix4<br>&gt; <br>&gt; How do new types get added to this list? It’s certainly not the case that NSValue knows about them specifically; usually some kind of category is added after the fact.<br></p><p>I think the list was gathered from the documentation at:<br></p><p>	https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValue_Class/ &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValue_Class/&gt;<br></p><p>New types would get added when the owner of a particular framework determines that one of their value types can be mapped to a more-specific Objective-C class than Swift’s box type, at which point an _ObjectiveCBridgeable conformance can be added to do it. This proposal is taking the presence of those NSValue categories as an indication that NSValue is the best Objective-C class to which these types should be mapped.<br></p><p>&gt; Also, how does this bridging work for swift-corelibs-foundation on Linux, where bridging is disabled?<br></p><p>It doesn’t. This only affects how value types are boxed when we are providing interoperability with Objective-C.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; - Tony<br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt;&gt; <br>&gt;&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; We can of course do nothing and leave the behavior as-is.<br>&gt;&gt; <br>&gt;&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/b6646371/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 11:09 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 23, 2016, at 4:00 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Doug,<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let i = 17<br>&gt;&gt;&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt;&gt;&gt; // OK<br>&gt;&gt;&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let j: UInt8 = 38<br>&gt;&gt;&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt;&gt;&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt;&gt;&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt;&gt;&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anim.toValue = CGPoint.zero<br>&gt;&gt;&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Int8<br>&gt;&gt;&gt; Int16<br>&gt;&gt;&gt; Int32<br>&gt;&gt;&gt; Int64<br>&gt;&gt;&gt; UInt8<br>&gt;&gt;&gt; UInt16<br>&gt;&gt;&gt; UInt32<br>&gt;&gt;&gt; UInt64<br>&gt;&gt;&gt; Float<br>&gt;&gt;&gt; Double<br>&gt;&gt;&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSRange<br>&gt;&gt;&gt; CGPoint<br>&gt;&gt;&gt; CGVector<br>&gt;&gt;&gt; CGSize<br>&gt;&gt;&gt; CGRect<br>&gt;&gt;&gt; CGAffineTransform<br>&gt;&gt;&gt; UIEdgeInsets<br>&gt;&gt;&gt; UIOffset<br>&gt;&gt;&gt; CATransform3D<br>&gt;&gt;&gt; CMTime<br>&gt;&gt;&gt; CMTimeRange<br>&gt;&gt;&gt; CMTimeMapping<br>&gt;&gt;&gt; MKCoordinate<br>&gt;&gt;&gt; MKCoordinateSpan<br>&gt;&gt;&gt; SCNVector3<br>&gt;&gt;&gt; SCNVector4<br>&gt;&gt;&gt; SCNMatrix4<br>&gt;&gt; <br>&gt;&gt; How do new types get added to this list? It’s certainly not the case that NSValue knows about them specifically; usually some kind of category is added after the fact.<br>&gt; <br>&gt; I think the list was gathered from the documentation at:<br>&gt; <br>&gt; 	https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValue_Class/ &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValue_Class/&gt;<br>&gt; <br>&gt; New types would get added when the owner of a particular framework determines that one of their value types can be mapped to a more-specific Objective-C class than Swift’s box type, at which point an _ObjectiveCBridgeable conformance can be added to do it. This proposal is taking the presence of those NSValue categories as an indication that NSValue is the best Objective-C class to which these types should be mapped.<br>&gt; <br>&gt;&gt; Also, how does this bridging work for swift-corelibs-foundation on Linux, where bridging is disabled?<br>&gt; <br>&gt; It doesn’t. This only affects how value types are boxed when we are providing interoperability with Objective-C.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>Then it seems we are introducing an incompatibility, since really this is about interop with Foundation API and not really about Objective-C.<br></p><p>We would need a plan for how Foundation implementation (JSONSerialization is one example, but there are others) is supposed to handle this when the compiler does not provide any help by automatically boxing things like UInt8 into an NSNumber.<br></p><p>NSNumber makes some sense to me, but it’s still not clear to me why it’s important to automatically box something like MKCoordinateSpan into an NSValue when passed into Objective-C, instead of just leaving it in the general purpose SwiftValue box. If any Objective-C API wanted an NSValue it should ask for it, and then people can simply construct it themselves instead of us inserting magic into bridging.<br></p><p>- Tony<br></p><p>&gt;&gt; <br>&gt;&gt; - Tony<br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can of course do nothing and leave the behavior as-is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/a33739a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 11:29 AM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 24, 2016, at 11:09 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 23, 2016, at 4:00 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Doug,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let i = 17<br>&gt;&gt;&gt;&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt;&gt;&gt;&gt; // OK<br>&gt;&gt;&gt;&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let j: UInt8 = 38<br>&gt;&gt;&gt;&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt;&gt;&gt;&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt;&gt;&gt;&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt;&gt;&gt;&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; anim.toValue = CGPoint.zero<br>&gt;&gt;&gt;&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Int8<br>&gt;&gt;&gt;&gt; Int16<br>&gt;&gt;&gt;&gt; Int32<br>&gt;&gt;&gt;&gt; Int64<br>&gt;&gt;&gt;&gt; UInt8<br>&gt;&gt;&gt;&gt; UInt16<br>&gt;&gt;&gt;&gt; UInt32<br>&gt;&gt;&gt;&gt; UInt64<br>&gt;&gt;&gt;&gt; Float<br>&gt;&gt;&gt;&gt; Double<br>&gt;&gt;&gt;&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NSRange<br>&gt;&gt;&gt;&gt; CGPoint<br>&gt;&gt;&gt;&gt; CGVector<br>&gt;&gt;&gt;&gt; CGSize<br>&gt;&gt;&gt;&gt; CGRect<br>&gt;&gt;&gt;&gt; CGAffineTransform<br>&gt;&gt;&gt;&gt; UIEdgeInsets<br>&gt;&gt;&gt;&gt; UIOffset<br>&gt;&gt;&gt;&gt; CATransform3D<br>&gt;&gt;&gt;&gt; CMTime<br>&gt;&gt;&gt;&gt; CMTimeRange<br>&gt;&gt;&gt;&gt; CMTimeMapping<br>&gt;&gt;&gt;&gt; MKCoordinate<br>&gt;&gt;&gt;&gt; MKCoordinateSpan<br>&gt;&gt;&gt;&gt; SCNVector3<br>&gt;&gt;&gt;&gt; SCNVector4<br>&gt;&gt;&gt;&gt; SCNMatrix4<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How do new types get added to this list? It’s certainly not the case that NSValue knows about them specifically; usually some kind of category is added after the fact.<br>&gt;&gt; <br>&gt;&gt; I think the list was gathered from the documentation at:<br>&gt;&gt; <br>&gt;&gt; 	https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValue_Class/ &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValue_Class/&gt;<br>&gt;&gt; <br>&gt;&gt; New types would get added when the owner of a particular framework determines that one of their value types can be mapped to a more-specific Objective-C class than Swift’s box type, at which point an _ObjectiveCBridgeable conformance can be added to do it. This proposal is taking the presence of those NSValue categories as an indication that NSValue is the best Objective-C class to which these types should be mapped.<br>&gt;&gt; <br>&gt;&gt;&gt; Also, how does this bridging work for swift-corelibs-foundation on Linux, where bridging is disabled?<br>&gt;&gt; <br>&gt;&gt; It doesn’t. This only affects how value types are boxed when we are providing interoperability with Objective-C.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt; <br>&gt; Then it seems we are introducing an incompatibility, since really this is about interop with Foundation API and not really about Objective-C.<br></p><p>It’s tightening up the “boxed” representation exposed to Objective-C. I don’t see that it introduces a new incompatibility; at worst, it expends an existing incompatibility that exists for Int/UInt/Float/Double to more types.<br></p><p>&gt; <br>&gt; We would need a plan for how Foundation implementation (JSONSerialization is one example, but there are others) is supposed to handle this when the compiler does not provide any help by automatically boxing things like UInt8 into an NSNumber.<br></p><p>The corelibs JSONSerialization will need to deal with these types somehow—probably by having them conform to some protocol that allows them to work with JSONSerialization. If we have to do that by boxing them in (NS|CF)Number/(NS|CF)Value to share implementation at the CF level, we can do that via a protocol or specific type checks.<br></p><p>&gt; NSNumber makes some sense to me, but it’s still not clear to me why it’s important to automatically box something like MKCoordinateSpan into an NSValue when passed into Objective-C, instead of just leaving it in the general purpose SwiftValue box. If any Objective-C API wanted an NSValue it should ask for it, and then people can simply construct it themselves instead of us inserting magic into bridging.<br></p><p>MKCoordinateSpan will get boxed regardless; this boxes it the same way an Objective-C programmer would so it’ll be seen appropriately in Objective-C.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can of course do nothing and leave the behavior as-is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/311ba389/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 4:00 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; SE-0116 changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt;&gt; <br>&gt;&gt; let i = 17<br>&gt;&gt; let plist = [&quot;seventeen&quot;<br>&gt;&gt; : i]<br>&gt;&gt; <br>&gt;&gt; // OK<br>&gt;&gt; try! NSJSONSerialization.<br>&gt;&gt; data(withJSONObject: plist)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let j: UInt8 = 38<br>&gt;&gt; let brokenPlist = [&quot;thirty-eight&quot;<br>&gt;&gt; : j]<br>&gt;&gt; <br>&gt;&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt;&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt;&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt;&gt; <br>&gt;&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt;&gt; <br>&gt;&gt; anim.toValue = CGPoint.zero<br>&gt;&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt;&gt; <br>&gt;&gt; 	• Int8<br>&gt;&gt; 	• Int16<br>&gt;&gt; 	• Int32<br>&gt;&gt; 	• Int64<br>&gt;&gt; 	• UInt8<br>&gt;&gt; 	• UInt16<br>&gt;&gt; 	• UInt32<br>&gt;&gt; 	• UInt64<br>&gt;&gt; 	• Float<br>&gt;&gt; 	• Double<br>&gt;&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt;&gt; <br>&gt;&gt; 	• NSRange<br>&gt;&gt; 	• CGPoint<br>&gt;&gt; 	• CGVector<br>&gt;&gt; 	• CGSize<br>&gt;&gt; 	• CGRect<br>&gt;&gt; 	• CGAffineTransform<br>&gt;&gt; 	• UIEdgeInsets<br>&gt;&gt; 	• UIOffset<br>&gt;&gt; 	• CATransform3D<br>&gt;&gt; 	• CMTime<br>&gt;&gt; 	• CMTimeRange<br>&gt;&gt; 	• CMTimeMapping<br>&gt;&gt; 	• MKCoordinate<br>&gt;&gt; 	• MKCoordinateSpan<br>&gt;&gt; 	• SCNVector3<br>&gt;&gt; 	• SCNVector4<br>&gt;&gt; 	• SCNMatrix4<br>&gt; <br>&gt; How do new types get added to this list? It’s certainly not the case that NSValue knows about them specifically; usually some kind of category is added after the fact.<br></p><p>I pulled this list from the API docs. Zach mentioned the existence of the `objc_boxable` attribute in Objective-C. Would it make more sense to make this an importer feature, introducing the bridging to NSValue based on that attribute rather than hard-coding the conformances in the overlay?<br></p><p>&gt; Also, how does this bridging work for swift-corelibs-foundation on Linux, where bridging is disabled?<br></p><p>How much corelibs code works directly with NSNumber or NSValue? In native Swift code, you ought to be able to pass around Anys containing value types and dynamically cast out their values with Swift&#39;s native casting features.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Proposal draft] Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Strong +1 to this proposal. Lack of implicit bridging for Int8/Int16/Int32/Int64 types has caused crashes in production code I&#39;ve worked with, so this is a real problem. Now that `id` is imported as `Any`, it&#39;s even easy to run into these crashes since there&#39;s no compile-time error when you pass an `Int8` into Objective-C as `Any` and try to use it as if it were an `NSNumber`.<br></p><p>&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; A handful of Swift numeric types are bridged to NSNumber when passed into Objective-C object contexts. We should extend this bridging behavior to all Swift numeric types. We should also bridge common Cocoa structs such as NSRangeby boxing them into NSValue objects.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#motivation&gt;Motivation<br>&gt; <br>&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the hazard of passing in types that don&#39;t bridge well to Objective-C objects. Particularly problematic are number types; whereas Int, UInt, and Double will automatically bridge as NSNumber, other-sized numeric types fall back to opaque boxing:<br>&gt; <br>&gt; let i = 17<br>&gt; let plist = [&quot;seventeen&quot;: i]<br>&gt; // OK<br>&gt; try! NSJSONSerialization.data(withJSONObject: plist)<br>&gt; <br>&gt; let j: UInt8 = 38<br>&gt; let brokenPlist = [&quot;thirty-eight&quot;: j]<br>&gt; // Will throw because `j` didn&#39;t bridge to a JSON type<br>&gt; try! NSJSONSerialization.data(withJSONObject: brokenPlist)<br>&gt; We had shied away from enabling this bridging for all numeric types in the Swift 1.x days, among other reasons because we allowed implicit bridging conversions in both directions from Swift value types to NS objects and back, which meant that you could slowly and brokenly convert between any two numeric types transitively via NSNumber if we allowed this. We killed the implicit conversions completely with SE-0072 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md&gt; so that is no longer a concern, so expanding the bridging behavior should no longer be a major problem, since it must now always be explicitly asked for.<br>&gt; <br>&gt; There are also many Cocoa APIs that accept NSArray and NSDictionary objects with members that are NSValue-boxed structs. Matt Neuberg highlights Core Automation as an example in this bug report &lt;https://bugs.swift.org/browse/SR-2414&gt;. With id-as-Any, it&#39;s natural to expect this to work:<br>&gt; <br>&gt; anim.toValue = CGPoint.zero<br>&gt; However, the CGPoint value does not box as a meaningful Objective-C object, so this currently breaks Core Animation at runtime despite compiling successfully. It would be more idiomatic to bridge these types to NSValue.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; All of Swift&#39;s number types should be made to bridge to NSNumber when used as objects in Objective-C:<br>&gt; <br>&gt; Int8<br>&gt; Int16<br>&gt; Int32<br>&gt; Int64<br>&gt; UInt8<br>&gt; UInt16<br>&gt; UInt32<br>&gt; UInt64<br>&gt; Float<br>&gt; Double<br>&gt; Cocoa structs with existing NSValue factory and property support should be made to bridge to NSValue when used as objects:<br>&gt; <br>&gt; NSRange<br>&gt; CGPoint<br>&gt; CGVector<br>&gt; CGSize<br>&gt; CGRect<br>&gt; CGAffineTransform<br>&gt; UIEdgeInsets<br>&gt; UIOffset<br>&gt; CATransform3D<br>&gt; CMTime<br>&gt; CMTimeRange<br>&gt; CMTimeMapping<br>&gt; MKCoordinate<br>&gt; MKCoordinateSpan<br>&gt; SCNVector3<br>&gt; SCNVector4<br>&gt; SCNMatrix4<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Bridged NSNumber and NSValue objects must be castable back to their original Swift value types. NSValue normally preserves the type information of its included struct in its objCType property. We can check the objCType of an NSValue instance when attempting to cast back to a specific bridged struct type.<br>&gt; <br>&gt; NSNumber is a bit trickier, since Cocoa&#39;s implementation does not generally guarantee to remember the exact number type an instance was constructed from. We can instead say that casting an NSNumber to a Swift number type succeeds if the value of the NSNumber is exactly representable as the target type. This is imperfect, since it means that an NSNumbercan potentially be cast to a different type from the original value, but it at least ensures that Swift values round-trip through the bridge without depending on NSNumber implementation details.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, values that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from concrete number and struct types to Anyto id to Any and back by dynamic casting. The ability to reliably distinguish the exact number type that an NSNumberwas constructed from would be lost.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-nsnumber-and-nsvalue.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; We can of course do nothing and leave the behavior as-is.<br>&gt; <br>&gt; NSValue also carries factories for valueWithPointer: and valueWithNonretainedObject:. Maybe we could bridgeUnsafePointer and Unmanaged this way, but we probably shouldn’t.<br>&gt; <br>&gt; 	- Doug<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/4a1e55ba/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
