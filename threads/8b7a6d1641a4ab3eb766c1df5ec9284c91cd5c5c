<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/708ba2ac0f2fda7836eff3c4960e9c8a?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Jerome Paschoud</string> &lt;jerome_paschoud at mac.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>I would like to see the String type to support regular expression per default. I think that a language that advertise itself as being a good scripting language should provide in its default implementation an easy way (=~ for example in Perl) to use regular expressions. I know that one can use the NSRegularExpression, but who really what to first create an NSRegularExpression object(whit all the nice escaping operation that come with every \), then get a NSTextCheckingResult, then get a range (and what I mean is a NSRange and not a NSRange&lt;String.Index&gt;) and finally perform slicing of your original string. <br></p><p>I realize that it could be considered as purely syntactic sugar, but what a nice one.<br></p><p>Jérôme<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  8, 2015 at 01:00:00pm</p></header><div class="content"><p>It sounds like you are asking for two things:<br></p><p>=~ operator support for regular expressions<br>regular expression literals<br></p><p>I would love to see regular expressions be more usable in swift, but my opinion is that =~ is a bad idea, and regex literals have tradeoffs important to consider.<br></p><p>For =~ :<br>1. The semantics of the =~ operator in other languages maps to a return value of Int? - matching position or nil with no match. This means you would likely need to write if str =~ foo != nil { … }<br>2. The above is considerably longer and harder to read than (say) if foo.matches(str) {<br>2. The semantics of the =~ operator produce state around matched groups, which is usually exposed to the language as either thread-local or block-local data.<br>3. The =~ operator only makes sense when applied to strings (or some other random access text source) and regex<br></p><p>For regex literals, my only concern is that it makes regex a language feature over an extended or standard library feature. If there is ever a desire to have Swift usable on embedded systems, you would likely want to be able to drop regular expression support.<br></p><p>On the flip side, regex may require code generation/compilation to work. A statement like:<br></p><p>while Regex(“foo”).matches(currentLine) { ... }<br></p><p>has a performance hit in generating the regex parser on each invocation of the loop.<br></p><p>Not only does having a literal syntax allow the compiler to optimize this to generation of a single processor, but the compiler could even generate IL to do said processing.<br></p><p>-DW<br>  <br>&gt; On Dec 8, 2015, at 1:14 PM, Jerome Paschoud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like to see the String type to support regular expression per default. I think that a language that advertise itself as being a good scripting language should provide in its default implementation an easy way (=~ for example in Perl) to use regular expressions. I know that one can use the NSRegularExpression, but who really what to first create an NSRegularExpression object(whit all the nice escaping operation that come with every \), then get a NSTextCheckingResult, then get a range (and what I mean is a NSRange and not a NSRange&lt;String.Index&gt;) and finally perform slicing of your original string. <br>&gt; <br>&gt; I realize that it could be considered as purely syntactic sugar, but what a nice one.<br>&gt; <br>&gt; Jérôme<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; 1. The semantics of the =~ operator in other languages maps to a return value of Int? - matching position or nil with no match. This means you would likely need to write if str =~ foo != nil { … }<br></p><p>Actually, I suspect the return value would be more like Range&lt;String.Character.Index&gt;?, or maybe even Regex.Match?. <br></p><p>&gt; 2. The semantics of the =~ operator produce state around matched groups, which is usually exposed to the language as either thread-local or block-local data.<br></p><p>This is hugely dependent on the language and I think it’s pretty obvious that Swift would take a return-value-based approach:<br></p><p>	if let match = string =~ /”([^\\”]*(\\[\\”][^\\”]*)*)”/ {<br>		let quotedString = match.substrings[1]<br>		…<br>	}<br></p><p>&gt; For regex literals, my only concern is that it makes regex a language feature over an extended or standard library feature.<br></p><p>Not necessarily. The only thing that *has* to be in the language is support for parsing regex literals, and the only thing that has to be in the standard library is RegexLiteralConvertible. Even if there is a Regex type in the standard library, just that type could be dropped there without requiring huge compiler changes.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December  9, 2015 at 12:00:00am</p></header><div class="content"><p>I think we can extend this to something more general: VerbatimLiteralConvertible. A VerbatimLiteral would maybe start with a \&quot; and end with &quot;\ (Might not work with these delimiters). It would enable one to not have to escape special chars like &quot; and \, so that they can be used just like that:<br></p><p>let verb = \&quot;And he said: &quot;\o/&quot;&quot;\<br>let file = \&quot;<br>First line<br>&quot;Still in verbatim!<br>&quot;\<br></p><p>We could then use this for the Reges type like:<br></p><p>struct Regex : VerbatimLiteralConvertible {<br>    init(verbatimLiteral value: String) {<br>        ...<br>    }<br>}<br></p><p>extension String {<br>    func match(regex: Regex) -&gt; Range&lt;String.Index&gt;? {<br>        ...<br>    }<br>}<br></p><p>let matches = string.match(\&quot;[a-z]&quot;test&quot;\)<br></p><p>Such a VerbatimLiteral also has the advantage of being able to copy-paste potentially big regex expressions in your code without the need to manually add all those &quot;\&quot; for escaping. Also it can be used to directly copy-past some text with correct line breaks and indentation.<br></p><p>I&#39;d really love to see this, I&#39;m just unsure of how the parser could delimit such a VerbatimLiteral.<br></p><p>Kame<br></p><p>&gt; On 08 Dec 2015, at 23:41, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 1. The semantics of the =~ operator in other languages maps to a return value of Int? - matching position or nil with no match. This means you would likely need to write if str =~ foo != nil { … }<br>&gt; <br>&gt; Actually, I suspect the return value would be more like Range&lt;String.Character.Index&gt;?, or maybe even Regex.Match?. <br>&gt; <br>&gt;&gt; 2. The semantics of the =~ operator produce state around matched groups, which is usually exposed to the language as either thread-local or block-local data.<br>&gt; <br>&gt; This is hugely dependent on the language and I think it’s pretty obvious that Swift would take a return-value-based approach:<br>&gt; <br>&gt;    if let match = string =~ /”([^\\”]*(\\[\\”][^\\”]*)*)”/ {<br>&gt;        let quotedString = match.substrings[1]<br>&gt;        …<br>&gt;    }<br>&gt; <br>&gt;&gt; For regex literals, my only concern is that it makes regex a language feature over an extended or standard library feature.<br>&gt; <br>&gt; Not necessarily. The only thing that *has* to be in the language is support for parsing regex literals, and the only thing that has to be in the standard library is RegexLiteralConvertible. Even if there is a Regex type in the standard library, just that type could be dropped there without requiring huge compiler changes.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>It&#39;d be trickier, but you could imagine allowing the user to declare a<br>custom delimiter for their &quot;verbatim literals&quot;, so a Regex type would use a<br>&quot;/&quot;.<br></p><p>Ruby, for example, has string literal constructs which allow a wide range<br>of delimiters: https://simpleror.wordpress.com/2009/03/15/q-q-w-w-x-r-s/<br> (and Perl as well, I believe)<br></p><p>Jacob<br></p><p>On Tue, Dec 8, 2015 at 3:19 PM, Kametrixom Tikara via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think we can extend this to something more general:<br>&gt; VerbatimLiteralConvertible. A VerbatimLiteral would maybe start with a \&quot;<br>&gt; and end with &quot;\ (Might not work with these delimiters). It would enable one<br>&gt; to not have to escape special chars like &quot; and \, so that they can be used<br>&gt; just like that:<br>&gt;<br>&gt; let verb = \&quot;And he said: &quot;\o/&quot;&quot;\<br>&gt; let file = \&quot;<br>&gt; First line<br>&gt; &quot;Still in verbatim!<br>&gt; &quot;\<br>&gt;<br>&gt; We could then use this for the Reges type like:<br>&gt;<br>&gt; struct Regex : VerbatimLiteralConvertible {<br>&gt;     init(verbatimLiteral value: String) {<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension String {<br>&gt;     func match(regex: Regex) -&gt; Range&lt;String.Index&gt;? {<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let matches = string.match(\&quot;[a-z]&quot;test&quot;\)<br>&gt;<br>&gt; Such a VerbatimLiteral also has the advantage of being able to copy-paste<br>&gt; potentially big regex expressions in your code without the need to manually<br>&gt; add all those &quot;\&quot; for escaping. Also it can be used to directly copy-past<br>&gt; some text with correct line breaks and indentation.<br>&gt;<br>&gt; I&#39;d really love to see this, I&#39;m just unsure of how the parser could<br>&gt; delimit such a VerbatimLiteral.<br>&gt;<br>&gt; Kame<br>&gt;<br>&gt; &gt; On 08 Dec 2015, at 23:41, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; 1. The semantics of the =~ operator in other languages maps to a return<br>&gt; value of Int? - matching position or nil with no match. This means you<br>&gt; would likely need to write if str =~ foo != nil { … }<br>&gt; &gt;<br>&gt; &gt; Actually, I suspect the return value would be more like<br>&gt; Range&lt;String.Character.Index&gt;?, or maybe even Regex.Match?.<br>&gt; &gt;<br>&gt; &gt;&gt; 2. The semantics of the =~ operator produce state around matched<br>&gt; groups, which is usually exposed to the language as either thread-local or<br>&gt; block-local data.<br>&gt; &gt;<br>&gt; &gt; This is hugely dependent on the language and I think it’s pretty obvious<br>&gt; that Swift would take a return-value-based approach:<br>&gt; &gt;<br>&gt; &gt;    if let match = string =~ /”([^\\”]*(\\[\\”][^\\”]*)*)”/ {<br>&gt; &gt;        let quotedString = match.substrings[1]<br>&gt; &gt;        …<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;&gt; For regex literals, my only concern is that it makes regex a language<br>&gt; feature over an extended or standard library feature.<br>&gt; &gt;<br>&gt; &gt; Not necessarily. The only thing that *has* to be in the language is<br>&gt; support for parsing regex literals, and the only thing that has to be in<br>&gt; the standard library is RegexLiteralConvertible. Even if there is a Regex<br>&gt; type in the standard library, just that type could be dropped there without<br>&gt; requiring huge compiler changes.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/48d8b4d7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Empower String type with regular expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 12:14 PM, Jerome Paschoud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like to see the String type to support regular expression per default. I think that a language that advertise itself as being a good scripting language should provide in its default implementation an easy way (=~ for example in Perl) to use regular expressions. I know that one can use the NSRegularExpression, but who really what to first create an NSRegularExpression object(whit all the nice escaping operation that come with every \), then get a NSTextCheckingResult, then get a range (and what I mean is a NSRange and not a NSRange&lt;String.Index&gt;) and finally perform slicing of your original string. <br></p><p>Just MHO, but I’d really really like to see proper regex support in Swift someday.<br></p><p>I think it could fit naturally into the pattern matching syntax we already have - the obvious syntax for this pattern would use // delimiters. <br></p><p>It is also probably worth burning first-class language support for regexes.  This would allow specifying variable captures inline in the pattern, would allow flexible syntax for defining regexes, support powerful extensions to the base regex model (e.g. Perl 6 style), and would provide better compile-time checking and error recovery for mistakes.<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
