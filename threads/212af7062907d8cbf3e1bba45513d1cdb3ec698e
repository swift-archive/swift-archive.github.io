<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri Jan 22 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt; <br>&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt;&gt; fundamental type such Int or String, type information and context at<br>&gt;&gt; the point of use may not fully convey intent. In this example, the<br>&gt;&gt; declaration may be clear, but the use site is vague:<br>&gt;&gt; <br>&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt; grid.add(self, for: graphics) // vague<br>&gt;&gt; <br>&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt; <br>&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;<br>&gt; I don’t understand why to compensate for weak type information we put<br>&gt; some of that compensation in the name of the function and other parts<br>&gt; of it in the [external] name of the parameter.<br></p><p>IIUC, some people feel strongly that it would be really strange and<br>nonuniform to have a substantial fraction of methods with an argument<br>label on the first argument unless that percentage was nearly 100.<br></p><p>[I don&#39;t know whether there&#39;s an &quot;official terminology&quot; for these names,<br>but we&#39;ve been calling them &quot;argument labels&quot; in the naming discussions.<br>Note that the (&quot;internal&quot;) parameter names aren&#39;t strictly internal as<br>they get used in documentation comments, and should be chosen<br>accordingly.  So, I&#39;m using the terms &quot;argument label&quot; and &quot;parameter<br>name&quot;.]<br></p><p>&gt; If we were going to reference functions like this:<br>&gt; addObserver:forKeyPath, then I can understand it. But that’s not the<br>&gt; plan of record, it’s to do this: addObserver(_:forKeyPath).<br></p><p>That&#39;s an interesting argument.<br></p><p>&gt; Regardless of the default naming scheme, it seems like the rule should<br>&gt; be to use external names to clarify that parameters role.<br>&gt;<br>&gt; func add(observer observer: NSObject, forKeyPath path: String)<br>&gt; grid.add(observer: self, forKeyPath: graphics)<br>&gt;<br>&gt; This promotes a very clear and consistent rule: weak type information<br>&gt; should be clarified by the parameter’s external name. There are no<br>&gt; exceptions for the first parameter. <br></p><p>That seems very clean to me.<br></p><p>&gt; Otherwise, it seems like there is super fine line between this rule<br>&gt; and the next one below.<br>&gt;<br>&gt; Additionally, this also alleviates my concerns with the default<br>&gt; parameter have _ as the external name by default because this<br>&gt; addresses the case when it would be desirable to have that<br>&gt; name. <br></p><p>Sorry, I don&#39;t understand what you&#39;re getting at here.<br></p><p>&gt; Further, the case below handles the case when it’s not.<br>&gt;<br>&gt;&gt; Omit Needless Words. Every word in a name should convey salient information at the use site.<br>&gt;&gt; <br>&gt;&gt; More words may be needed to clarify intent or disambiguate meaning,<br>&gt;&gt; but those that are redundant with information the reader already<br>&gt;&gt; possesses should be omitted. In particular, omit words that merely<br>&gt;&gt; repeat type information:<br>&gt;&gt; <br>&gt;&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt;&gt; allViews.removeElement(cancelButton)<br>&gt;&gt; <br>&gt;&gt; In this case, the word Element adds nothing salient at the call site. This API would be better:<br>&gt;&gt; <br>&gt;&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt;&gt; allViews.remove(cancelButton) // clearer<br>&gt;&gt; <br>&gt;&gt; Occasionally, repeating type information is necessary to avoid<br>&gt;&gt; ambiguity, but in general it is better to use a word that describes<br>&gt;&gt; a parameter’s role rather than its type. See the next item for<br>&gt;&gt; details.<br>&gt;<br>&gt; The description here seems to overlap with the “Compensate for Weak<br>&gt; Type Information” rule, especially with the clause: “repeating type<br>&gt; information”. It may be better to re-work the example to be<br>&gt; `removeItem(member: Element)` to make this distinction more clear that<br>&gt; it’s not type information being removed.<br></p><p>Oh, great point!<br></p><p>&gt; Also, by clarifying that statement, the above rule change I suggested<br>&gt; would be consistent. Type information clarification goes into the<br>&gt; external parameter name, functionality clarification goes into the<br>&gt; function name. Those are hard-n-fast rules that are straight-forward.<br></p><p>I like &#39;em, FWIW.<br></p><p>&gt;&gt; Be Grammatical<br>&gt;&gt; <br>&gt;&gt; When a mutating method is described by a verb, name its non-mutating<br>&gt;&gt; counterpart according to the “ed/ing” rule, e.g. the non-mutating<br>&gt;&gt; versions of x.sort() and x.append(y) are x.sorted() and<br>&gt;&gt; x.appending(y).<br>&gt;<br>&gt; Is this guideline suggesting that we should design our APIs to<br>&gt; generally have both mutating and non-mutaging counterparts?<br></p><p>Definitely not.<br></p><p>&gt; As other have pointed out, this is also very hard to do all the<br>&gt; time. I think the alternatives are worse. <br></p><p>The alternatives to always creating mutating/nonmutating pairs?  What<br>alternatives have you considered, and what do you see the consequences<br>to be?<br></p><p>&gt; It would be nice if there were a way to annotate all member functions<br>&gt; as mutating/non-mutating to really by-pass this ambiguity.<br></p><p>I don&#39;t know what you mean by that.  Can you explain?<br></p><p>FWIW, there are potential language-level approaches to this problem<br>(e.g. https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst),<br>but in the absence of language features, it&#39;s something we need a<br>convention for.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>The inPlace proposal is excellent. As suggested something like x.=f() would<br>be perfect to distinguish mutating methods .Something I don&#39;t like from the<br>API design guidelines is that non mutating methods like enumerate would be<br>become enumerated. In my mind enumerate is a word of art and I don&#39;t ever<br>think of it as muting so having to always use enumerated in the future<br>seems weird. Also having to ed/ing non mutating methods seems to make<br>mutating methods more important.<br></p><p>//non mutating suggestion<br>x.sort()<br>x.split()<br></p><p>//other ideas for mutating methods names<br>x.sort*()<br>x.sort&amp;() // I like &amp; the most<br>x.split&amp;()<br>x.sort@()<br></p><p>By marking a method with a special character at the end, the reader would<br>know that the method mutates.<br></p><p>On Saturday, January 23, 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jan 22 2016, David Owens II &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s<br>&gt; role.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt; &gt;&gt; fundamental type such Int or String, type information and context at<br>&gt; &gt;&gt; the point of use may not fully convey intent. In this example, the<br>&gt; &gt;&gt; declaration may be clear, but the use site is vague:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt; &gt;&gt; grid.add(self, for: graphics) // vague<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun<br>&gt; describing its role:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt; &gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt; &gt;<br>&gt; &gt; I don’t understand why to compensate for weak type information we put<br>&gt; &gt; some of that compensation in the name of the function and other parts<br>&gt; &gt; of it in the [external] name of the parameter.<br>&gt;<br>&gt; IIUC, some people feel strongly that it would be really strange and<br>&gt; nonuniform to have a substantial fraction of methods with an argument<br>&gt; label on the first argument unless that percentage was nearly 100.<br>&gt;<br>&gt; [I don&#39;t know whether there&#39;s an &quot;official terminology&quot; for these names,<br>&gt; but we&#39;ve been calling them &quot;argument labels&quot; in the naming discussions.<br>&gt; Note that the (&quot;internal&quot;) parameter names aren&#39;t strictly internal as<br>&gt; they get used in documentation comments, and should be chosen<br>&gt; accordingly.  So, I&#39;m using the terms &quot;argument label&quot; and &quot;parameter<br>&gt; name&quot;.]<br>&gt;<br>&gt; &gt; If we were going to reference functions like this:<br>&gt; &gt; addObserver:forKeyPath, then I can understand it. But that’s not the<br>&gt; &gt; plan of record, it’s to do this: addObserver(_:forKeyPath).<br>&gt;<br>&gt; That&#39;s an interesting argument.<br>&gt;<br>&gt; &gt; Regardless of the default naming scheme, it seems like the rule should<br>&gt; &gt; be to use external names to clarify that parameters role.<br>&gt; &gt;<br>&gt; &gt; func add(observer observer: NSObject, forKeyPath path: String)<br>&gt; &gt; grid.add(observer: self, forKeyPath: graphics)<br>&gt; &gt;<br>&gt; &gt; This promotes a very clear and consistent rule: weak type information<br>&gt; &gt; should be clarified by the parameter’s external name. There are no<br>&gt; &gt; exceptions for the first parameter.<br>&gt;<br>&gt; That seems very clean to me.<br>&gt;<br>&gt; &gt; Otherwise, it seems like there is super fine line between this rule<br>&gt; &gt; and the next one below.<br>&gt; &gt;<br>&gt; &gt; Additionally, this also alleviates my concerns with the default<br>&gt; &gt; parameter have _ as the external name by default because this<br>&gt; &gt; addresses the case when it would be desirable to have that<br>&gt; &gt; name.<br>&gt;<br>&gt; Sorry, I don&#39;t understand what you&#39;re getting at here.<br>&gt;<br>&gt; &gt; Further, the case below handles the case when it’s not.<br>&gt; &gt;<br>&gt; &gt;&gt; Omit Needless Words. Every word in a name should convey salient<br>&gt; information at the use site.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; More words may be needed to clarify intent or disambiguate meaning,<br>&gt; &gt;&gt; but those that are redundant with information the reader already<br>&gt; &gt;&gt; possesses should be omitted. In particular, omit words that merely<br>&gt; &gt;&gt; repeat type information:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public mutating func removeElement(member: Element) -&gt; Element?<br>&gt; &gt;&gt; allViews.removeElement(cancelButton)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In this case, the word Element adds nothing salient at the call site.<br>&gt; This API would be better:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public mutating func remove(member: Element) -&gt; Element?<br>&gt; &gt;&gt; allViews.remove(cancelButton) // clearer<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Occasionally, repeating type information is necessary to avoid<br>&gt; &gt;&gt; ambiguity, but in general it is better to use a word that describes<br>&gt; &gt;&gt; a parameter’s role rather than its type. See the next item for<br>&gt; &gt;&gt; details.<br>&gt; &gt;<br>&gt; &gt; The description here seems to overlap with the “Compensate for Weak<br>&gt; &gt; Type Information” rule, especially with the clause: “repeating type<br>&gt; &gt; information”. It may be better to re-work the example to be<br>&gt; &gt; `removeItem(member: Element)` to make this distinction more clear that<br>&gt; &gt; it’s not type information being removed.<br>&gt;<br>&gt; Oh, great point!<br>&gt;<br>&gt; &gt; Also, by clarifying that statement, the above rule change I suggested<br>&gt; &gt; would be consistent. Type information clarification goes into the<br>&gt; &gt; external parameter name, functionality clarification goes into the<br>&gt; &gt; function name. Those are hard-n-fast rules that are straight-forward.<br>&gt;<br>&gt; I like &#39;em, FWIW.<br>&gt;<br>&gt; &gt;&gt; Be Grammatical<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When a mutating method is described by a verb, name its non-mutating<br>&gt; &gt;&gt; counterpart according to the “ed/ing” rule, e.g. the non-mutating<br>&gt; &gt;&gt; versions of x.sort() and x.append(y) are x.sorted() and<br>&gt; &gt;&gt; x.appending(y).<br>&gt; &gt;<br>&gt; &gt; Is this guideline suggesting that we should design our APIs to<br>&gt; &gt; generally have both mutating and non-mutaging counterparts?<br>&gt;<br>&gt; Definitely not.<br>&gt;<br>&gt; &gt; As other have pointed out, this is also very hard to do all the<br>&gt; &gt; time. I think the alternatives are worse.<br>&gt;<br>&gt; The alternatives to always creating mutating/nonmutating pairs?  What<br>&gt; alternatives have you considered, and what do you see the consequences<br>&gt; to be?<br>&gt;<br>&gt; &gt; It would be nice if there were a way to annotate all member functions<br>&gt; &gt; as mutating/non-mutating to really by-pass this ambiguity.<br>&gt;<br>&gt; I don&#39;t know what you mean by that.  Can you explain?<br>&gt;<br>&gt; FWIW, there are potential language-level approaches to this problem<br>&gt; (e.g.<br>&gt; https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst),<br>&gt; but in the absence of language features, it&#39;s something we need a<br>&gt; convention for.<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/bd18520c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>On Sat, Jan 23, 2016 at 12:44 PM, J. Cheyo Jimenez via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The inPlace proposal is excellent. As suggested something like<br>&gt; x.=f() would be perfect to distinguish mutating methods .Something I don&#39;t<br>&gt; like from the API design guidelines is that non mutating methods like<br>&gt; enumerate would be become enumerated. In my mind enumerate is a word of art<br>&gt; and I don&#39;t ever think of it as muting so having to always use enumerated<br>&gt; in the future seems weird. Also having to ed/ing non mutating methods seems<br>&gt; to make mutating methods more important.<br>&gt;<br>&gt; //non mutating suggestion<br>&gt; x.sort()<br>&gt; x.split()<br>&gt;<br>&gt; //other ideas for mutating methods names<br>&gt; x.sort*()<br>&gt; x.sort&amp;() // I like &amp; the most<br>&gt; x.split&amp;()<br>&gt; x.sort@()<br>&gt;<br>&gt; By marking a method with a special character at the end, the reader would<br>&gt; know that the method mutates.<br>&gt;<br></p><p>Ruby uses ! for this, by convention:<br>http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/e710c48f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br></p><p>In Swift: foo.contains(...)<br>In Ruby: foo.include?(...)<br></p><p>In Swift: foo.isEmpty<br>In Ruby: foo.empty?<br></p><p>Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br></p><p><br>Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br></p><p>Non-mutating:<br></p><p>Swift — foo.reverse()<br>Ruby — foo.reverse<br></p><p>Mutating:<br></p><p>Swift — foo.reverseInPlace()<br>Ruby — foo.reverse!<br></p><p><br>Non-mutating:<br></p><p>Swift — foo.sort()  or  foo.sort({…})<br>Ruby — foo.sort  or  foo.sort {…}<br></p><p>Mutating:<br></p><p>Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>Ruby — foo.sort!  or  foo.sort! {…} <br></p><p><br>I think it’s a simple and nice way of addressing the naming issue of mutating vs. non-mutating or pure vs. impure functions/methods. However, this conflicts with the syntax sugar of Optionals and, therefore, following this path would have a clear impact in the language.<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jan 23, 2016, at 3:46 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Jan 23, 2016 at 12:44 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The inPlace proposal is excellent. As suggested something like x.=f() would be perfect to distinguish mutating methods .Something I don&#39;t like from the API design guidelines is that non mutating methods like enumerate would be become enumerated. In my mind enumerate is a word of art and I don&#39;t ever think of it as muting so having to always use enumerated in the future seems weird. Also having to ed/ing non mutating methods seems to make mutating methods more important. <br>&gt; <br>&gt; //non mutating suggestion<br>&gt; x.sort()<br>&gt; x.split()<br>&gt; <br>&gt; //other ideas for mutating methods names<br>&gt; x.sort*()<br>&gt; x.sort&amp;() // I like &amp; the most<br>&gt; x.split&amp;()<br>&gt; x.sort@()<br>&gt; <br>&gt; By marking a method with a special character at the end, the reader would know that the method mutates. <br>&gt; <br>&gt; Ruby uses ! for this, by convention: http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods &lt;http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/cb59b387/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Syntax extensions for indicating mutation (was: [Review] SE-0023 API Design Guidelines)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>on Fri Jan 29 2016, Adriano Ferreira &lt;adriano.ferreira-AT-me.com&gt; wrote:<br></p><p>&gt; Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br>&gt;<br>&gt; In Swift: foo.contains(...)<br>&gt; In Ruby: foo.include?(...)<br>&gt;<br>&gt; In Swift: foo.isEmpty<br>&gt; In Ruby: foo.empty?<br>&gt;<br>&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br>&gt;<br>&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br>&gt;<br>&gt; Non-mutating:<br>&gt;<br>&gt; Swift — foo.reverse()<br>&gt; Ruby — foo.reverse<br>&gt;<br>&gt; Mutating:<br>&gt;<br>&gt; Swift — foo.reverseInPlace()<br>&gt; Ruby — foo.reverse!<br>&gt;<br>&gt; Non-mutating:<br>&gt;<br>&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt;<br>&gt; Mutating:<br>&gt;<br>&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt;<br>&gt; I think it’s a simple and nice way of addressing the naming issue of<br>&gt; mutating vs. non-mutating or pure vs. impure<br>&gt; functions/methods. However, this conflicts with the syntax sugar of<br>&gt; Optionals and, therefore, following this path would have a clear<br>&gt; impact in the language.<br></p><p>Please keep discussion of new language features in a separate thread;<br>thanks.<br></p><p>-D<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Syntax extensions for indicating mutation (was: [Review] SE-0023 API Design Guidelines)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 29 Jan 2016, at 20:23, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; on Fri Jan 29 2016, Adriano Ferreira &lt;adriano.ferreira-AT-me.com&gt; wrote:<br>&gt; <br>&gt;&gt; Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br>&gt;&gt; <br>&gt;&gt; In Swift: foo.contains(...)<br>&gt;&gt; In Ruby: foo.include?(...)<br>&gt;&gt; <br>&gt;&gt; In Swift: foo.isEmpty<br>&gt;&gt; In Ruby: foo.empty?<br>&gt;&gt; <br>&gt;&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br>&gt;&gt; <br>&gt;&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br>&gt;&gt; <br>&gt;&gt; Non-mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.reverse()<br>&gt;&gt; Ruby — foo.reverse<br>&gt;&gt; <br>&gt;&gt; Mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.reverseInPlace()<br>&gt;&gt; Ruby — foo.reverse!<br>&gt;&gt; <br>&gt;&gt; Non-mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt;&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt;&gt; <br>&gt;&gt; Mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt;&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt;&gt; <br>&gt;&gt; I think it’s a simple and nice way of addressing the naming issue of<br>&gt;&gt; mutating vs. non-mutating or pure vs. impure<br>&gt;&gt; functions/methods. However, this conflicts with the syntax sugar of<br>&gt;&gt; Optionals and, therefore, following this path would have a clear<br>&gt;&gt; impact in the language.<br>&gt; <br>&gt; Please keep discussion of new language features in a separate thread;<br>&gt; thanks.<br></p><p>I thought the point was mostly just to highlight how another language has dealt with the same problem? Of course Ruby’s syntax wouldn’t be feasible in Swift, and at the same time I think it’s actually unnecessary to add it so long as a good naming convention is very clear about what something is or does, i.e- <br></p><p>	foo.sort() // Sorts the original<br>	foo.sorted() // Returns a sorted form of the original, leaving the original unchanged<br></p><p>You could do reverseInPlace() instead, but personally I dislike that, though the main problem with the above is how easy it is to make a typo, whereas the operators for mutability would throw errors if used incorrectly. However, if properly declared the mutating vs non-mutating methods shouldn’t actually be easy to misuse either, i.e-<br></p><p>	mutating func sort() -&gt; Void { /* Do some sorting in here */ }<br>	@warn_unused_result func sorted() -&gt; SomeType { /* Make and return a sorted copy in here */ }<br></p><p>The first declaration can’t be misused because with its return type being void trying to assign it would cause an error, plus the mutating keyword ensures that it won’t be intentionally called on a read-only value.<br>The second declaration’s @warn_unused_result ensures that it won’t be misused because it isn’t possible to simply call it, it must be assigned or produce a warning. So this actually reinforces that overly verbose method names like reverseInPlace() are not needed when attempting to convey mutating vs non-mutating behaviour, as the compiler will quickly indicate a misuse.<br></p><p>The main problem is when a mutating function also needs to be able to return some optional result in addition to mutating itself for example:<br></p><p>	mutating func sort() -&gt; Int { /* Sort self, and return the number of elements that had to be relocated in order to do-so */ }<br></p><p>However I think the easiest fix in this case would be declare it like:<br></p><p>	@warn_unused_result mutating func sortAndCountElementsMoved() -&gt; Int { /* Sort and return number of elements moved */ }<br>	mutating func sort() { let _ = self.sortAndCountElementsMoved(); } // Call the above, but explicitly ignore its result<br></p><p>So eh… in conclusion, I don’t think we need Ruby’s operators as Swift can solve the same problems, though maybe not as succinctly.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/35901bc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (was: Syntax extensions for indicating mutation)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>on Fri Jan 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br></p><p>&gt;&gt; On 29 Jan 2016, at 20:23, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; on Fri Jan 29 2016, Adriano Ferreira &lt;adriano.ferreira-AT-me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Indeed, Ruby has an interesting convention where a question mark<br>&gt;<br>&gt;&gt;&gt; (?) is used for boolean functions/methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift: foo.contains(...)<br>&gt;&gt;&gt; In Ruby: foo.include?(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift: foo.isEmpty<br>&gt;&gt;&gt; In Ruby: foo.empty?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is<br>&gt;&gt;&gt; a method, but the idea is similar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, an exclamation mark (!) is generally used to indicate that a<br>&gt;&gt;&gt; function/method mutates `self`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.reverse()<br>&gt;&gt;&gt; Ruby — foo.reverse<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.reverseInPlace()<br>&gt;&gt;&gt; Ruby — foo.reverse!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt;&gt;&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt;&gt;&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s a simple and nice way of addressing the naming issue of<br>&gt;&gt;&gt; mutating vs. non-mutating or pure vs. impure<br>&gt;&gt;&gt; functions/methods. However, this conflicts with the syntax sugar of<br>&gt;&gt;&gt; Optionals and, therefore, following this path would have a clear<br>&gt;&gt;&gt; impact in the language.<br>&gt;&gt; <br>&gt;&gt; Please keep discussion of new language features in a separate thread;<br>&gt;&gt; thanks.<br>&gt;<br>&gt; I thought the point was mostly just to highlight how another language<br>&gt; has dealt with the same problem? <br></p><p>Presumably the person posting about this knew what the point was? ;-)<br></p><p>&gt; Of course Ruby’s syntax wouldn’t be feasible in Swift, and at the same<br>&gt; time I think it’s actually unnecessary to add it so long as a good<br>&gt; naming convention is very clear about what something is or does, <br></p><p>Now we&#39;re back on topic.<br></p><p>&gt; i.e-<br>&gt;<br>&gt; 	foo.sort() // Sorts the original<br>&gt; 	foo.sorted() // Returns a sorted form of the original, leaving<br>&gt; the original unchanged<br>&gt;<br>&gt; You could do reverseInPlace() instead, but personally I dislike that,<br>&gt; though the main problem with the above is how easy it is to make a<br>&gt; typo, whereas the operators for mutability would throw errors if used<br>&gt; incorrectly. However, if properly declared the mutating vs<br>&gt; non-mutating methods shouldn’t actually be easy to misuse either, i.e-<br>&gt;<br>&gt; 	mutating func sort() -&gt; Void { /* Do some sorting in here */ }<br>&gt; 	@warn_unused_result func sorted() -&gt; SomeType { /* Make and<br>&gt; return a sorted copy in here */ }<br>&gt;<br>&gt; The first declaration can’t be misused because with its return type<br>&gt; being void trying to assign it would cause an error, plus the mutating<br>&gt; keyword ensures that it won’t be intentionally called on a read-only<br>&gt; value.<br>&gt; The second declaration’s @warn_unused_result ensures that it won’t be<br>&gt; misused because it isn’t possible to simply call it, it must be<br>&gt; assigned or produce a warning. So this actually reinforces that overly<br>&gt; verbose method names like reverseInPlace() are not needed when<br>&gt; attempting to convey mutating vs non-mutating behaviour, as the<br>&gt; compiler will quickly indicate a misuse.<br>&gt;<br>&gt; The main problem is when a mutating function also needs to be able to<br>&gt; return some optional result in addition to mutating itself for<br>&gt; example:<br>&gt;<br>&gt; 	mutating func sort() -&gt; Int { /* Sort self, and return the number of elements that had to be relocated in order to do-so */ }<br></p><p>I don&#39;t see a problem here.  We have precedent in, e.g.,<br>RangeReplaceableCollectionType:<br></p><p>  /// Remove the element at index `i`.<br>  ///<br>  /// Invalidates all indices with respect to `self`.<br>  ///<br>  /// - Complexity: O(`self.count`).<br>  mutating func removeAtIndex(i: Index) -&gt; Generator.Element<br></p><p>&gt; However I think the easiest fix in this case would be declare it like:<br>&gt;<br>&gt; 	@warn_unused_result mutating func sortAndCountElementsMoved() -&gt; Int { /* Sort and return number of elements moved */ }<br>&gt; 	mutating func sort() { let _ =<br>&gt; self.sortAndCountElementsMoved(); } // Call the above, but explicitly<br>&gt; ignore its result<br>&gt;<br>&gt; So eh… in conclusion, I don’t think we need Ruby’s operators as Swift<br>&gt; can solve the same problems, though maybe not as succinctly.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>In Ruby ‘?’ indicates conditional usage while in Swift ‘?’ indicates optionality or an optional (fall-back) execution path (this operation returned return nil as a fallback for not holding a value, method being called on a nil value, method call throwing an error, etc)<br></p><p>This is why in Ruby 2.3, the “?.” operator that they wanted to use eventually evolved into an “&amp;.” operator.<br></p><p>‘!’ in Ruby means either this operation is destructive or that this operation will raise an exception on error, in Swift it means as a general rule ‘failures are precondition failures which will crash your application’<br></p><p>-DW<br></p><p>&gt; On Jan 29, 2016, at 11:10 AM, Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br>&gt; <br>&gt; In Swift: foo.contains(...)<br>&gt; In Ruby: foo.include?(...)<br>&gt; <br>&gt; In Swift: foo.isEmpty<br>&gt; In Ruby: foo.empty?<br>&gt; <br>&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br>&gt; <br>&gt; <br>&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br>&gt; <br>&gt; Non-mutating:<br>&gt; <br>&gt; Swift — foo.reverse()<br>&gt; Ruby — foo.reverse<br>&gt; <br>&gt; Mutating:<br>&gt; <br>&gt; Swift — foo.reverseInPlace()<br>&gt; Ruby — foo.reverse!<br>&gt; <br>&gt; <br>&gt; Non-mutating:<br>&gt; <br>&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt; <br>&gt; Mutating:<br>&gt; <br>&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt; <br>&gt; <br>&gt; I think it’s a simple and nice way of addressing the naming issue of mutating vs. non-mutating or pure vs. impure functions/methods. However, this conflicts with the syntax sugar of Optionals and, therefore, following this path would have a clear impact in the language.<br>&gt; <br>&gt; Best,<br>&gt; <br>&gt; — A<br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 3:46 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sat, Jan 23, 2016 at 12:44 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The inPlace proposal is excellent. As suggested something like x.=f() would be perfect to distinguish mutating methods .Something I don&#39;t like from the API design guidelines is that non mutating methods like enumerate would be become enumerated. In my mind enumerate is a word of art and I don&#39;t ever think of it as muting so having to always use enumerated in the future seems weird. Also having to ed/ing non mutating methods seems to make mutating methods more important. <br>&gt;&gt; <br>&gt;&gt; //non mutating suggestion<br>&gt;&gt; x.sort()<br>&gt;&gt; x.split()<br>&gt;&gt; <br>&gt;&gt; //other ideas for mutating methods names<br>&gt;&gt; x.sort*()<br>&gt;&gt; x.sort&amp;() // I like &amp; the most<br>&gt;&gt; x.split&amp;()<br>&gt;&gt; x.sort@()<br>&gt;&gt; <br>&gt;&gt; By marking a method with a special character at the end, the reader would know that the method mutates. <br>&gt;&gt; <br>&gt;&gt; Ruby uses ! for this, by convention: http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods &lt;http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/9a0056b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb5a6986048ff63d65b0f34fd1ecd1a9?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Paul Cantrell</string> &lt;paul at innig.net&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>I took Adriano’s comments not as a specific syntax proposal — clearly Ruby’s use of the ? and ! symbols is both different from and fundamentally incompatible with Swift’s — but rather as a way of pointing out that another language has solved this problem by reserving a special notation for “mutating” instead of trying to pack it in to grammar-based or otherwise natural-langue-based conventions, and that worked out all right.<br></p><p>Turning back to the guidelines review at hand, I do worry that these proposed guidelines pack too much significance into the vagaries of English grammar, which (as we’ve found out on this thread) is an inconsistent and fickle friend. I’m personally in favor of charging ahead with that quixotic venture nonetheless, but I do worry a bit that the guidelines as stated are too narrowly stated in all the places where grammar is involved.<br></p><p>Cheers, P<br></p><p>&gt; On Jan 29, 2016, at 2:55 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Ruby ‘?’ indicates conditional usage while in Swift ‘?’ indicates optionality or an optional (fall-back) execution path (this operation returned return nil as a fallback for not holding a value, method being called on a nil value, method call throwing an error, etc)<br>&gt; <br>&gt; This is why in Ruby 2.3, the “?.” operator that they wanted to use eventually evolved into an “&amp;.” operator.<br>&gt; <br>&gt; ‘!’ in Ruby means either this operation is destructive or that this operation will raise an exception on error, in Swift it means as a general rule ‘failures are precondition failures which will crash your application’<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 11:10 AM, Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br>&gt;&gt; <br>&gt;&gt; In Swift: foo.contains(...)<br>&gt;&gt; In Ruby: foo.include?(...)<br>&gt;&gt; <br>&gt;&gt; In Swift: foo.isEmpty<br>&gt;&gt; In Ruby: foo.empty?<br>&gt;&gt; <br>&gt;&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br>&gt;&gt; <br>&gt;&gt; Non-mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.reverse()<br>&gt;&gt; Ruby — foo.reverse<br>&gt;&gt; <br>&gt;&gt; Mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.reverseInPlace()<br>&gt;&gt; Ruby — foo.reverse!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Non-mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt;&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt;&gt; <br>&gt;&gt; Mutating:<br>&gt;&gt; <br>&gt;&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt;&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think it’s a simple and nice way of addressing the naming issue of mutating vs. non-mutating or pure vs. impure functions/methods. However, this conflicts with the syntax sugar of Optionals and, therefore, following this path would have a clear impact in the language.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; <br>&gt;&gt; — A<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 3:46 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Jan 23, 2016 at 12:44 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; The inPlace proposal is excellent. As suggested something like x.=f() would be perfect to distinguish mutating methods .Something I don&#39;t like from the API design guidelines is that non mutating methods like enumerate would be become enumerated. In my mind enumerate is a word of art and I don&#39;t ever think of it as muting so having to always use enumerated in the future seems weird. Also having to ed/ing non mutating methods seems to make mutating methods more important. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //non mutating suggestion<br>&gt;&gt;&gt; x.sort()<br>&gt;&gt;&gt; x.split()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //other ideas for mutating methods names<br>&gt;&gt;&gt; x.sort*()<br>&gt;&gt;&gt; x.sort&amp;() // I like &amp; the most<br>&gt;&gt;&gt; x.split&amp;()<br>&gt;&gt;&gt; x.sort@()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By marking a method with a special character at the end, the reader would know that the method mutates. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ruby uses ! for this, by convention: http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods &lt;http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/6aa10c01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Should static/class methods be capitalized, or lower-cased?  I have my own convention of capitalizing them, but I don’t know if that’s how most people do it.<br></p><p>Matt<br></p><p>&gt; On Jan 29, 2016, at 13:14, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I took Adriano’s comments not as a specific syntax proposal — clearly Ruby’s use of the ? and ! symbols is both different from and fundamentally incompatible with Swift’s — but rather as a way of pointing out that another language has solved this problem by reserving a special notation for “mutating” instead of trying to pack it in to grammar-based or otherwise natural-langue-based conventions, and that worked out all right.<br>&gt; <br>&gt; Turning back to the guidelines review at hand, I do worry that these proposed guidelines pack too much significance into the vagaries of English grammar, which (as we’ve found out on this thread) is an inconsistent and fickle friend. I’m personally in favor of charging ahead with that quixotic venture nonetheless, but I do worry a bit that the guidelines as stated are too narrowly stated in all the places where grammar is involved.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 2:55 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Ruby ‘?’ indicates conditional usage while in Swift ‘?’ indicates optionality or an optional (fall-back) execution path (this operation returned return nil as a fallback for not holding a value, method being called on a nil value, method call throwing an error, etc)<br>&gt;&gt; <br>&gt;&gt; This is why in Ruby 2.3, the “?.” operator that they wanted to use eventually evolved into an “&amp;.” operator.<br>&gt;&gt; <br>&gt;&gt; ‘!’ in Ruby means either this operation is destructive or that this operation will raise an exception on error, in Swift it means as a general rule ‘failures are precondition failures which will crash your application’<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 11:10 AM, Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift: foo.contains(...)<br>&gt;&gt;&gt; In Ruby: foo.include?(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift: foo.isEmpty<br>&gt;&gt;&gt; In Ruby: foo.empty?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.reverse()<br>&gt;&gt;&gt; Ruby — foo.reverse<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.reverseInPlace()<br>&gt;&gt;&gt; Ruby — foo.reverse!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt;&gt;&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt;&gt;&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s a simple and nice way of addressing the naming issue of mutating vs. non-mutating or pure vs. impure functions/methods. However, this conflicts with the syntax sugar of Optionals and, therefore, following this path would have a clear impact in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 3:46 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Jan 23, 2016 at 12:44 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The inPlace proposal is excellent. As suggested something like x.=f() would be perfect to distinguish mutating methods .Something I don&#39;t like from the API design guidelines is that non mutating methods like enumerate would be become enumerated. In my mind enumerate is a word of art and I don&#39;t ever think of it as muting so having to always use enumerated in the future seems weird. Also having to ed/ing non mutating methods seems to make mutating methods more important. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //non mutating suggestion<br>&gt;&gt;&gt;&gt; x.sort()<br>&gt;&gt;&gt;&gt; x.split()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //other ideas for mutating methods names<br>&gt;&gt;&gt;&gt; x.sort*()<br>&gt;&gt;&gt;&gt; x.sort&amp;() // I like &amp; the most<br>&gt;&gt;&gt;&gt; x.split&amp;()<br>&gt;&gt;&gt;&gt; x.sort@()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By marking a method with a special character at the end, the reader would know that the method mutates. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ruby uses ! for this, by convention: http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods &lt;http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/ba6925ee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 29, 2016 at 05:00:00pm</p></header><div class="content"><p>That was exactly my point Paul, and thanks for making it clearer.<br></p><p>Best,<br></p><p>—A<br></p><p>&gt; On Jan 29, 2016, at 4:14 PM, Paul Cantrell &lt;paul at innig.net&gt; wrote:<br>&gt; <br>&gt; I took Adriano’s comments not as a specific syntax proposal — clearly Ruby’s use of the ? and ! symbols is both different from and fundamentally incompatible with Swift’s — but rather as a way of pointing out that another language has solved this problem by reserving a special notation for “mutating” instead of trying to pack it in to grammar-based or otherwise natural-langue-based conventions, and that worked out all right.<br>&gt; <br>&gt; Turning back to the guidelines review at hand, I do worry that these proposed guidelines pack too much significance into the vagaries of English grammar, which (as we’ve found out on this thread) is an inconsistent and fickle friend. I’m personally in favor of charging ahead with that quixotic venture nonetheless, but I do worry a bit that the guidelines as stated are too narrowly stated in all the places where grammar is involved.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 2:55 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Ruby ‘?’ indicates conditional usage while in Swift ‘?’ indicates optionality or an optional (fall-back) execution path (this operation returned return nil as a fallback for not holding a value, method being called on a nil value, method call throwing an error, etc)<br>&gt;&gt; <br>&gt;&gt; This is why in Ruby 2.3, the “?.” operator that they wanted to use eventually evolved into an “&amp;.” operator.<br>&gt;&gt; <br>&gt;&gt; ‘!’ in Ruby means either this operation is destructive or that this operation will raise an exception on error, in Swift it means as a general rule ‘failures are precondition failures which will crash your application’<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 11:10 AM, Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed, Ruby has an interesting convention where a question mark (?) is used for boolean functions/methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift: foo.contains(...)<br>&gt;&gt;&gt; In Ruby: foo.include?(...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift: foo.isEmpty<br>&gt;&gt;&gt; In Ruby: foo.empty?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, in the last case `isEmpty` is a property whereas `empty?` is a method, but the idea is similar.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.reverse()<br>&gt;&gt;&gt; Ruby — foo.reverse<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.reverseInPlace()<br>&gt;&gt;&gt; Ruby — foo.reverse!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.sort()  or  foo.sort({…})<br>&gt;&gt;&gt; Ruby — foo.sort  or  foo.sort {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutating:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift — foo.sortInPlace()  or  foo.sortInPlace({…})<br>&gt;&gt;&gt; Ruby — foo.sort!  or  foo.sort! {…} <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s a simple and nice way of addressing the naming issue of mutating vs. non-mutating or pure vs. impure functions/methods. However, this conflicts with the syntax sugar of Optionals and, therefore, following this path would have a clear impact in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 3:46 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Jan 23, 2016 at 12:44 PM, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The inPlace proposal is excellent. As suggested something like x.=f() would be perfect to distinguish mutating methods .Something I don&#39;t like from the API design guidelines is that non mutating methods like enumerate would be become enumerated. In my mind enumerate is a word of art and I don&#39;t ever think of it as muting so having to always use enumerated in the future seems weird. Also having to ed/ing non mutating methods seems to make mutating methods more important. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //non mutating suggestion<br>&gt;&gt;&gt;&gt; x.sort()<br>&gt;&gt;&gt;&gt; x.split()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //other ideas for mutating methods names<br>&gt;&gt;&gt;&gt; x.sort*()<br>&gt;&gt;&gt;&gt; x.sort&amp;() // I like &amp; the most<br>&gt;&gt;&gt;&gt; x.split&amp;()<br>&gt;&gt;&gt;&gt; x.sort@()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By marking a method with a special character at the end, the reader would know that the method mutates. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ruby uses ! for this, by convention: http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods &lt;http://stackoverflow.com/questions/612189/why-are-exclamation-marks-used-in-ruby-methods&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/33824bba/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Also, an exclamation mark (!) is generally used to indicate that a function/method mutates `self`:<br></p><p>It&#39;s a common misconception that `!` means &quot;mutates&quot; in Ruby. It actually means something like &quot;more dangerous variant&quot;. The danger being indicated is *often* that it mutates, but sometimes it&#39;s that it throws an exception (rather than returning `false` or `nil`) or bypasses validations. There is also a rule in Ruby that you should never use `!` unless there&#39;s a non-`!` variant.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 11:53 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jan 22 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Be Grammatical<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a mutating method is described by a verb, name its non-mutating<br>&gt;&gt;&gt; counterpart according to the “ed/ing” rule, e.g. the non-mutating<br>&gt;&gt;&gt; versions of x.sort() and x.append(y) are x.sorted() and<br>&gt;&gt;&gt; x.appending(y).<br>&gt;&gt; <br>&gt;&gt; Is this guideline suggesting that we should design our APIs to<br>&gt;&gt; generally have both mutating and non-mutaging counterparts?<br>&gt; <br>&gt; Definitely not.<br>&gt; <br>&gt;&gt; As other have pointed out, this is also very hard to do all the<br>&gt;&gt; time. I think the alternatives are worse. <br>&gt; <br>&gt; The alternatives to always creating mutating/nonmutating pairs?  What<br>&gt; alternatives have you considered, and what do you see the consequences<br>&gt; to be?<br>&gt; <br>&gt;&gt; It would be nice if there were a way to annotate all member functions<br>&gt;&gt; as mutating/non-mutating to really by-pass this ambiguity.<br>&gt; <br>&gt; I don&#39;t know what you mean by that.  Can you explain?<br>&gt; <br>&gt; FWIW, there are potential language-level approaches to this problem<br>&gt; (e.g. https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst),<br>&gt; but in the absence of language features, it&#39;s something we need a<br>&gt; convention for.<br></p><p>Exactly. It seems like this convention is a work-around for a language design deficiency. In the case of value types, there are indeed other solutions that could even allow the same name for functions to be used for both mutating and non-mutating. The key thing of importance is bringing that clarity to the call site.<br></p><p>I think there are some interesting proposals in the link provided. Another potential:<br></p><p>var items = [...]<br>mut items.sort()            // sorts the items in-place<br>let copy = items.sort()     // sorts a copy of the items and returns that copy<br></p><p>let items = [...]<br>mut items.sort()            // error: unable to mutate a constant value<br></p><p>The other potential thing to look it is what it means for class-types to allow mutation. I simply cannot trust a class-type that has a function named with the correct guidelines or an &quot;InPlace&quot; suffix to actually return a real copy of the class type.<br></p><p>I guess my point is this: codifying a convention seems pre-mature as that convention doesn&#39;t bring the safety goals of the language into a place that&#39;s verifiable. All of the other guidelines are simply about clarity of use, this convention has a far reaching impact.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/3a0179f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fdb7d28949d81cc824f5842c17b18512?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>charles@charlesism.com</string> &lt;charlesism.com at gmail.com&gt;<p>January 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Exactly. It seems like this convention is a work-around for a language design deficiency. In the case of value types, there are indeed other solutions that could even allow the same name for functions to be used for both mutating and non-mutating. The key thing of importance is bringing that clarity to the call site.<br></p><p>This makes a lot of sense. I&#39;m glad we&#39;re considering design. There&#39;s rules to remember either way, but I&#39;d prefer to use the same method name for both mutating and copying. Messing around with English grammar is a &quot;naming problem&quot; and costs a programmer more mental effort. Look no further than online debates over the best conjugation of this or that Protocol name.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 07:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, &quot;charles-AT-charlesism.com&quot; &lt;charlesism.com-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; Exactly. It seems like this convention is a work-around for a<br>&gt; language design deficiency. In the case of value types, there are<br>&gt; indeed other solutions that could even allow the same name for<br>&gt; functions to be used for both mutating and non-mutating. The key thing<br>&gt; of importance is bringing that clarity to the call site.<br>&gt;<br>&gt; This makes a lot of sense. I&#39;m glad we&#39;re considering design. There&#39;s<br>&gt; rules to remember either way, but I&#39;d prefer to use the same method<br>&gt; name for both mutating and copying. Messing around with English<br>&gt; grammar is a &quot;naming problem&quot; and costs a programmer more mental<br>&gt; effort. Look no further than online debates over the best conjugation<br>&gt; of this or that Protocol name.<br></p><p>OK, but please, take that discussion to a different thread, or even<br>consider delaying it.  As much as I wish it were otherwise (I originally<br>wrote that proposal before Swift 1 was released) something like the<br>InPlace proposal is so unlikely to be in scope for Swift 3 as to be<br>effectively irrelevant to the API Design Guidelines, which we are trying<br>to roll out immediately, and which can&#39;t be based on speculative feature<br>ideas.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
