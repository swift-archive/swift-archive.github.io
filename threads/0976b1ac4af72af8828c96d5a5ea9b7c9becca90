<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Separating the finite-vs-infinite distinction from single-vs-multi-pass</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>This post describes the standard library team&#39;s analysis of the<br>finite/infinite sequence issue raised by Matthew Johnson and others in<br>http://news.gmane.org/find-root.php?message_id=1976B8AE%2dFDD1%2d4257%2dA24F%2d2AFF84115445%40anandabits.com.<br></p><p>[Dmitri is going to write a separate post detailing our proposed<br>direction with respect to the original topic raised by David Waite in<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/21295, the<br>confusion resulting from the refinement relationship between Sequence<br>and Collection that introduces non-destructive consumption.  As you<br>will see below, the resolution of this post&#39;s issue will depend<br>somewhat on that].<br></p><p>It seems to us that there are four possible approaches here:<br></p><p>1. Do nothing.  Infinite loops are not usually security problems and<br>   might not be worth complicating APIs for.<br></p><p>2. Formally lift the constraint on Collection that forces it to be<br>   finite.  That would allow us to model multi-pass traversal over<br>   (portions of) infinite sequences.<br></p><p>3. #2, plus add to Collection an `isKnownToBeInfinite` property,<br>   defaulting to `false`, that can be used to trigger a trap when a call<br>   would otherwise loop infinitely.<br></p><p>4. Go all the way to separate protocols for finite and infinite<br>   Collections as detailed in<br>   http://article.gmane.org/gmane.comp.lang.swift.evolution/22471<br></p><p>As far as we can tell, the only real point in distinguishing finiteness<br>is to prevent infinite loops.  Since inifinite loops are equally<br>(non-)problematic for both single- and multi-pass sequences, we can find<br>little justification for treating single-pass and multi-pass sequences<br>differently where finiteness is concerned.  Therefore, whatever we end<br>up with for Collection should apply to single-pass sequences as well.<br></p><p>Lastly, it looks like nobody on the standard library team is going to<br>have the time to drive this forward for Swift 3.  While the standard<br>library team can provide some guidance, if it is to happen, someone else<br>needs to take the reins.  That&#39;s not supposed to be discouraging:<br>several smart and capable people have expressed their interest in this<br>topic.  That said, if you care about it, you&#39;ll need to do as much work<br>as possible independently.  That includes putting the proposal through<br>evolution and creating a pull request containing the implementation.<br></p><p>Thanks, everybody!<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Separating the finite-vs-infinite distinction from single-vs-multi-pass</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  6, 2016 at 03:00:00pm</p></header><div class="content"><p>1. Do nothing with finiteness, because huge sequences are mostly like<br>infinite ones, plus because infinite loops are useful<br>2. Allow collections to be infinite<br>3. Do not add new fields to collections, because infinite loops are useful<br>4, Do not separate protocols<br>Current model of IteratorProtocol + Sequence is a very simple and clean way<br>to define one&#39;s own iterables. Let&#39;s not break it.<br></p><p>Now to single-pass-ness.<br>I would suggest the following model:<br>1. Iterable protocol is base of everything that can be used in for loop.<br>Contains all single-pass-able operations.<br>2. IteratorProtocol is what Iterable returns. IteratorProtocol conforms to<br>Iterable, returns itself. Single-pass sequences should conform to<br>IteratorProtocol.<br>3. Sequence protocol conforms to Iterable. Sequences are multi-pass.<br></p><p>Also, we should leave both Sequence and Collection trees, because correctly<br>conforming to Collection is a hard work, and correctly conforming to<br>Sequence must be easy as pie.<br></p><p>2016-07-06 4:56 GMT+03:00 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt;<br>&gt; This post describes the standard library team&#39;s analysis of the<br>&gt; finite/infinite sequence issue raised by Matthew Johnson and others in<br>&gt;<br>&gt; http://news.gmane.org/find-root.php?message_id=1976B8AE%2dFDD1%2d4257%2dA24F%2d2AFF84115445%40anandabits.com<br>&gt; .<br>&gt;<br>&gt; [Dmitri is going to write a separate post detailing our proposed<br>&gt; direction with respect to the original topic raised by David Waite in<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/21295, the<br>&gt; confusion resulting from the refinement relationship between Sequence<br>&gt; and Collection that introduces non-destructive consumption.  As you<br>&gt; will see below, the resolution of this post&#39;s issue will depend<br>&gt; somewhat on that].<br>&gt;<br>&gt; It seems to us that there are four possible approaches here:<br>&gt;<br>&gt; 1. Do nothing.  Infinite loops are not usually security problems and<br>&gt;    might not be worth complicating APIs for.<br>&gt;<br>&gt; 2. Formally lift the constraint on Collection that forces it to be<br>&gt;    finite.  That would allow us to model multi-pass traversal over<br>&gt;    (portions of) infinite sequences.<br>&gt;<br>&gt; 3. #2, plus add to Collection an `isKnownToBeInfinite` property,<br>&gt;    defaulting to `false`, that can be used to trigger a trap when a call<br>&gt;    would otherwise loop infinitely.<br>&gt;<br>&gt; 4. Go all the way to separate protocols for finite and infinite<br>&gt;    Collections as detailed in<br>&gt;    http://article.gmane.org/gmane.comp.lang.swift.evolution/22471<br>&gt;<br>&gt; As far as we can tell, the only real point in distinguishing finiteness<br>&gt; is to prevent infinite loops.  Since inifinite loops are equally<br>&gt; (non-)problematic for both single- and multi-pass sequences, we can find<br>&gt; little justification for treating single-pass and multi-pass sequences<br>&gt; differently where finiteness is concerned.  Therefore, whatever we end<br>&gt; up with for Collection should apply to single-pass sequences as well.<br>&gt;<br>&gt; Lastly, it looks like nobody on the standard library team is going to<br>&gt; have the time to drive this forward for Swift 3.  While the standard<br>&gt; library team can provide some guidance, if it is to happen, someone else<br>&gt; needs to take the reins.  That&#39;s not supposed to be discouraging:<br>&gt; several smart and capable people have expressed their interest in this<br>&gt; topic.  That said, if you care about it, you&#39;ll need to do as much work<br>&gt; as possible independently.  That includes putting the proposal through<br>&gt; evolution and creating a pull request containing the implementation.<br>&gt;<br>&gt; Thanks, everybody!<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/0f156088/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Separating the finite-vs-infinite distinction from single-vs-multi-pass</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jul 06 2016, Anton Zhilin &lt;antonyzhilin-AT-gmail.com&gt; wrote:<br></p><p>&gt; 1. Do nothing with finiteness, because huge sequences are mostly like<br>&gt; infinite ones, plus because infinite loops are useful<br>&gt; 2. Allow collections to be infinite<br>&gt; 3. Do not add new fields to collections, because infinite loops are<br>&gt; useful<br></p><p>No argument so far, but...<br></p><p>&gt; 4, Do not separate protocols<br>&gt; Current model of IteratorProtocol + Sequence is a very simple and clean way<br>&gt; to define one&#39;s own iterables. Let&#39;s not break it.<br></p><p>It&#39;s already broken.  When you call non-mutating methods such as map,<br>filter, or reduce on a Sequence, the sequence can be modified.  That<br>provblem was outlined very nicely by David Waite in<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/focus=21872:<br></p><p>  My main motivation for proposing this is the potential for developer<br>  confusion. As stated during one of the previous threads on the naming<br>  of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>  naming requirement not typical of the rest of the Swift standard<br>  library in that many methods on Sequence may or may not be<br>  destructive. As such, naming methods for any extensions on Sequence is<br>  challenging as the names need to not imply immutability.<br></p><p>&gt; Now to single-pass-ness.<br>&gt; I would suggest the following model:<br>&gt; 1. Iterable protocol is base of everything that can be used in for loop.<br>&gt; Contains all single-pass-able operations.<br>&gt; 2. IteratorProtocol is what Iterable returns. IteratorProtocol conforms to<br>&gt; Iterable, returns itself. Single-pass sequences should conform to<br>&gt; IteratorProtocol.<br>&gt; 3. Sequence protocol conforms to Iterable. Sequences are multi-pass.<br></p><p>That solves no problems AFAICT and introduces a new protocol.  What&#39;s<br>the point?<br></p><p>&gt; Also, we should leave both Sequence and Collection trees, because<br>&gt; correctly conforming to Collection is a hard work, and correctly<br>&gt; conforming to Sequence must be easy as pie.<br></p><p>That goal should not take precedence over logical coherence and<br>simplicity of the standard library.<br></p><p>Also, conforming to collection isn&#39;t really hard.<br></p><p>Finally, as mentioned earlier we could easily supply a protocol that<br>makes it no harder than conforming to IteratorProtocol is.  You don&#39;t<br>even need to make your iteration state equatable because we can compare<br>counters stored in the indices.  I&#39;ll post a gist illustrating this<br>today.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
