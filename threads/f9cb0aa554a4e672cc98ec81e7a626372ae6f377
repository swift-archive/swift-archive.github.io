<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May  7, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift users,<br></p><p>I wanted to run something past you folks and get some opinions/feedback.<br></p><p>About a month ago on Hacker News I saw someone commenting about how Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged. Unfortunately, I didn&#39;t have time to dig into it until this morning. The code in its entirety can be found here: https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683 &lt;https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683&gt;<br></p><p>At line 26 we have the following code:<br></p><p>result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br></p><p>&#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a [String]. When I profiled the code in Instruments, I noticed that it was spending significant time within the reflection machinery.<br></p><p>It turns out that the initializer to make a String out of a utf16 view looks like this, and I believe this is the initializer the author intended to call:<br></p><p>init?(_: String.UTF16View) &lt;&gt;<br></p><p>However, the actual initializer being called was this String initializer in the Mirror code:<br></p><p>public init&lt;Subject&gt;(_ instance: Subject)<br></p><p>This seems like a tricky gotcha for developers who aren&#39;t extremely familiar with both the String and reflection APIs. His code looked reasonable at a first glance and I didn&#39;t suspect anything was wrong until I profiled it. Even so, I only made the connection because I recognized the name of the standard library function from poking around inside the source files.<br></p><p>What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br></p><p>Best,<br>Austin<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160507/f9cbf377/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May  8, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Austin,<br></p><p>I further “swiftyfied” the code to this (swift-DEVELOPMENT-SNAPSHOT-2016-05-03-a):<br></p><p>import Foundation<br></p><p>let N = 1_000_000<br></p><p>func generateTestData() -&gt; [String] {<br>  return (0..&lt;N).map { _ in &quot;,,abc, 123  ,x, , more more more,\u{A0}and yet more, &quot; }<br>}<br></p><p>func splitAndTrim(s: String, sep: Character) -&gt; [String] {<br>  return s.characters.split(separator: sep, omittingEmptySubsequences: false)<br>                     .map(String.init)<br>                     .map { $0.trimmingCharacters(in: .whitespacesAndNewlines()) }<br>}<br></p><p>func doSplits(data: [String]) -&gt; Int {<br>  return data.reduce(0) { $0 + splitAndTrim(s: $1, sep: Character(&quot;,&quot;)).count }<br>}<br></p><p>let data = generateTestData()<br>let start = NSDate()<br>let sum = doSplits(data: data)<br>print(&quot;elapsed: \(NSDate().timeIntervalSince(start))&quot;)<br>print(&quot;sum: \(sum)&quot;)<br></p><p>I didn’t expect it to run as fast as the original (or even faster) but the code above takes 13 seconds to run… But that’s just an aside :)<br></p><p>To actually come back to the problem you mentioned:<br></p><p>You can disambiguate the initializer to call in the following ways (probably there are other ways):<br></p><p>Add an ! after the init call since the one which should be used is failable (the one that uses reflection does not), so the compiler chooses the “right” one.<br></p><p>result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()])!) <br></p><p>Or you can reference the initializer and use it afterwards (more future-proof):<br></p><p>let utf16View = cs[begin..&lt;end.successor()]<br>let initializer = String.init as (String.UTF16View -&gt; String?)<br>result.append(begin == eos ? &quot;&quot; : initializer(utf16View)!)<br></p><p>This reduces the time to 2.2 seconds on my machine (from ~2.9), but that’s still far from 0.8.<br></p><p>&gt; What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br></p><p><br>It might be very surprising behavior and we could think about adding an external label to all those initializers that cause trouble. The performance is of course a little worrying for a zero-cost abstractions language, but I think there are currently more important goals (getting the design right, etc.). We are still at the early stages with a lot of stuff changing and I think when the syntax, ABI, etc. are settled, performance / optimization will get more attention :)<br></p><p>- Dennis<br></p><p>&gt; On May 7, 2016, at 7:39 PM, Austin Zheng via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift users,<br>&gt; <br>&gt; I wanted to run something past you folks and get some opinions/feedback.<br>&gt; <br>&gt; About a month ago on Hacker News I saw someone commenting about how Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged. Unfortunately, I didn&#39;t have time to dig into it until this morning. The code in its entirety can be found here: https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683 &lt;https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683&gt;<br>&gt; <br>&gt; At line 26 we have the following code:<br>&gt; <br>&gt; result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br>&gt; <br>&gt; &#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a [String]. When I profiled the code in Instruments, I noticed that it was spending significant time within the reflection machinery.<br>&gt; <br>&gt; It turns out that the initializer to make a String out of a utf16 view looks like this, and I believe this is the initializer the author intended to call:<br>&gt; <br>&gt; init?(_: String.UTF16View) &lt;&gt;<br>&gt; <br>&gt; However, the actual initializer being called was this String initializer in the Mirror code:<br>&gt; <br>&gt; public init&lt;Subject&gt;(_ instance: Subject)<br>&gt; <br>&gt; This seems like a tricky gotcha for developers who aren&#39;t extremely familiar with both the String and reflection APIs. His code looked reasonable at a first glance and I didn&#39;t suspect anything was wrong until I profiled it. Even so, I only made the connection because I recognized the name of the standard library function from poking around inside the source files.<br>&gt; <br>&gt; What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160508/33402b29/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 7, 2016, at 10:39 AM, Austin Zheng via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift users,<br>&gt; <br>&gt; I wanted to run something past you folks and get some opinions/feedback.<br>&gt; <br>&gt; About a month ago on Hacker News I saw someone commenting about how Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged. Unfortunately, I didn&#39;t have time to dig into it until this morning. The code in its entirety can be found here: https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683<br>&gt; <br>&gt; At line 26 we have the following code:<br>&gt; <br>&gt; result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br>&gt; <br>&gt; &#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a [String]. When I profiled the code in Instruments, I noticed that it was spending significant time within the reflection machinery.<br>&gt; <br>&gt; It turns out that the initializer to make a String out of a utf16 view looks like this, and I believe this is the initializer the author intended to call:<br>&gt; <br>&gt; init?(_: String.UTF16View)<br>&gt; <br>&gt; However, the actual initializer being called was this String initializer in the Mirror code:<br>&gt; <br>&gt; public init&lt;Subject&gt;(_ instance: Subject)<br>&gt; <br>&gt; This seems like a tricky gotcha for developers who aren&#39;t extremely familiar with both the String and reflection APIs. His code looked reasonable at a first glance and I didn&#39;t suspect anything was wrong until I profiled it. Even so, I only made the connection because I recognized the name of the standard library function from poking around inside the source files.<br>&gt; <br>&gt; What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br></p><p>This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is very easy to call by accident if you&#39;re trying to hit another unlabeled initializer. It also strikes me as not particularly &quot;value-preserving&quot;, since stringifying many types loses information. Perhaps we should propose giving it a label, String(printing:) maybe?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mon, May 9, 2016, at 01:25 PM, Joe Groff via swift-users wrote:<br>&gt; This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is<br>&gt; very easy to call by accident if you&#39;re trying to hit another unlabeled<br>&gt; initializer. It also strikes me as not particularly &quot;value-preserving&quot;,<br>&gt; since stringifying many types loses information. Perhaps we should<br>&gt; propose giving it a label, String(printing:) maybe?<br></p><p>I&#39;ve been wondering about this since String(reflecting:) came about, as<br>plain print() is capable of doing about the same amount of reflection as<br>debugPrint(). I don&#39;t want to get into the bikeshedding of it, but I&#39;d<br>really like to see printing String initializer get a verb label. It&#39;s<br>pretty strongly against the API guidelines for initializers.<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>On Mon, May 9, 2016 at 10:25 AM, Joe Groff via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 7, 2016, at 10:39 AM, Austin Zheng via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift users,<br>&gt; &gt;<br>&gt; &gt; I wanted to run something past you folks and get some opinions/feedback.<br>&gt; &gt;<br>&gt; &gt; About a month ago on Hacker News I saw someone commenting about how<br>&gt; Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code<br>&gt; sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged.<br>&gt; Unfortunately, I didn&#39;t have time to dig into it until this morning. The<br>&gt; code in its entirety can be found here:<br>&gt; https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683<br>&gt; &gt;<br>&gt; &gt; At line 26 we have the following code:<br>&gt; &gt;<br>&gt; &gt; result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br>&gt; &gt;<br>&gt; &gt; &#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a [String].<br>&gt; When I profiled the code in Instruments, I noticed that it was spending<br>&gt; significant time within the reflection machinery.<br>&gt; &gt;<br>&gt; &gt; It turns out that the initializer to make a String out of a utf16 view<br>&gt; looks like this, and I believe this is the initializer the author intended<br>&gt; to call:<br>&gt; &gt;<br>&gt; &gt; init?(_: String.UTF16View)<br>&gt; &gt;<br>&gt; &gt; However, the actual initializer being called was this String initializer<br>&gt; in the Mirror code:<br>&gt; &gt;<br>&gt; &gt; public init&lt;Subject&gt;(_ instance: Subject)<br>&gt; &gt;<br>&gt; &gt; This seems like a tricky gotcha for developers who aren&#39;t extremely<br>&gt; familiar with both the String and reflection APIs. His code looked<br>&gt; reasonable at a first glance and I didn&#39;t suspect anything was wrong until<br>&gt; I profiled it. Even so, I only made the connection because I recognized the<br>&gt; name of the standard library function from poking around inside the source<br>&gt; files.<br>&gt; &gt;<br>&gt; &gt; What do other people think? Is this something worth worrying about, or<br>&gt; is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how<br>&gt; that code sample might be improved would be appreciated - my naive first<br>&gt; attempt wasn&#39;t any better.<br>&gt;<br>&gt; This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is<br>&gt; very easy to call by accident if you&#39;re trying to hit another unlabeled<br>&gt; initializer. It also strikes me as not particularly &quot;value-preserving&quot;,<br>&gt; since stringifying many types loses information. Perhaps we should propose<br>&gt; giving it a label, String(printing:) maybe?<br>&gt;<br></p><p>+1<br></p><p><br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160509/8ea7848d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 9, 2016, at 10:28 AM, Jacob Bandes-Storch via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, May 9, 2016 at 10:25 AM, Joe Groff via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On May 7, 2016, at 10:39 AM, Austin Zheng via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift users,<br>&gt; &gt;<br>&gt; &gt; I wanted to run something past you folks and get some opinions/feedback.<br>&gt; &gt;<br>&gt; &gt; About a month ago on Hacker News I saw someone commenting about how Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged. Unfortunately, I didn&#39;t have time to dig into it until this morning. The code in its entirety can be found here: https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683 &lt;https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683&gt;<br>&gt; &gt;<br>&gt; &gt; At line 26 we have the following code:<br>&gt; &gt;<br>&gt; &gt; result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br>&gt; &gt;<br>&gt; &gt; &#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a [String]. When I profiled the code in Instruments, I noticed that it was spending significant time within the reflection machinery.<br>&gt; &gt;<br>&gt; &gt; It turns out that the initializer to make a String out of a utf16 view looks like this, and I believe this is the initializer the author intended to call:<br>&gt; &gt;<br>&gt; &gt; init?(_: String.UTF16View)<br>&gt; &gt;<br>&gt; &gt; However, the actual initializer being called was this String initializer in the Mirror code:<br>&gt; &gt;<br>&gt; &gt; public init&lt;Subject&gt;(_ instance: Subject)<br>&gt; &gt;<br>&gt; &gt; This seems like a tricky gotcha for developers who aren&#39;t extremely familiar with both the String and reflection APIs. His code looked reasonable at a first glance and I didn&#39;t suspect anything was wrong until I profiled it. Even so, I only made the connection because I recognized the name of the standard library function from poking around inside the source files.<br>&gt; &gt;<br>&gt; &gt; What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br>&gt; <br>&gt; This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is very easy to call by accident if you&#39;re trying to hit another unlabeled initializer. It also strikes me as not particularly &quot;value-preserving&quot;, since stringifying many types loses information. Perhaps we should propose giving it a label, String(printing:) maybe?<br>&gt; <br>&gt; +1<br></p><p>+1<br></p><p> - Daniel<br></p><p>&gt;  <br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160509/3422fa90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May  9, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks to all who commented. I&#39;ll put together a proposal to rename that<br>initializer tonight, unless someone else wants to do it. This seems like a<br>pretty straightforward clarity gain, and it might even help a bit with<br>compilation times.<br></p><p>Austin<br></p><p>On Mon, May 9, 2016 at 10:54 AM, Daniel Dunbar via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On May 9, 2016, at 10:28 AM, Jacob Bandes-Storch via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mon, May 9, 2016 at 10:25 AM, Joe Groff via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On May 7, 2016, at 10:39 AM, Austin Zheng via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift users,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I wanted to run something past you folks and get some opinions/feedback.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; About a month ago on Hacker News I saw someone commenting about how<br>&gt;&gt; Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code<br>&gt;&gt; sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged.<br>&gt;&gt; Unfortunately, I didn&#39;t have time to dig into it until this morning. The<br>&gt;&gt; code in its entirety can be found here:<br>&gt;&gt; https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; At line 26 we have the following code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a<br>&gt;&gt; [String]. When I profiled the code in Instruments, I noticed that it was<br>&gt;&gt; spending significant time within the reflection machinery.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It turns out that the initializer to make a String out of a utf16 view<br>&gt;&gt; looks like this, and I believe this is the initializer the author intended<br>&gt;&gt; to call:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; init?(_: String.UTF16View)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; However, the actual initializer being called was this String<br>&gt;&gt; initializer in the Mirror code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public init&lt;Subject&gt;(_ instance: Subject)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This seems like a tricky gotcha for developers who aren&#39;t extremely<br>&gt;&gt; familiar with both the String and reflection APIs. His code looked<br>&gt;&gt; reasonable at a first glance and I didn&#39;t suspect anything was wrong until<br>&gt;&gt; I profiled it. Even so, I only made the connection because I recognized the<br>&gt;&gt; name of the standard library function from poking around inside the source<br>&gt;&gt; files.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What do other people think? Is this something worth worrying about, or<br>&gt;&gt; is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how<br>&gt;&gt; that code sample might be improved would be appreciated - my naive first<br>&gt;&gt; attempt wasn&#39;t any better.<br>&gt;&gt;<br>&gt;&gt; This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is<br>&gt;&gt; very easy to call by accident if you&#39;re trying to hit another unlabeled<br>&gt;&gt; initializer. It also strikes me as not particularly &quot;value-preserving&quot;,<br>&gt;&gt; since stringifying many types loses information. Perhaps we should propose<br>&gt;&gt; giving it a label, String(printing:) maybe?<br>&gt;&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160509/d3a03a82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>Now that I see it, I realise I’ve run in to that a fair few times myself; I didn’t even know the string-view initialisers were failable.<br></p><p>I’m not sure I understand why reflection is exposed as an initialiser on String in the first place - it might make more sense as a global function.<br></p><p>Karl<br>&gt; On 9 May 2016, at 20:43, Austin Zheng via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks to all who commented. I&#39;ll put together a proposal to rename that initializer tonight, unless someone else wants to do it. This seems like a pretty straightforward clarity gain, and it might even help a bit with compilation times.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Mon, May 9, 2016 at 10:54 AM, Daniel Dunbar via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 9, 2016, at 10:28 AM, Jacob Bandes-Storch via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, May 9, 2016 at 10:25 AM, Joe Groff via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On May 7, 2016, at 10:39 AM, Austin Zheng via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift users,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I wanted to run something past you folks and get some opinions/feedback.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; About a month ago on Hacker News I saw someone commenting about how Swift&#39;s string-handling code was unbearably slow (3 seconds to run a code sample, vs. 0.8 in Java). I asked him to provide the code, and he obliged. Unfortunately, I didn&#39;t have time to dig into it until this morning. The code in its entirety can be found here: https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683 &lt;https://gist.github.com/austinzheng/d6c674780a58cb63832c4df3f809e683&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; At line 26 we have the following code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; result.append(begin == eos ? &quot;&quot; : String(cs[begin..&lt;end.successor()]))<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &#39;cs&#39; is a UTF16 view into an input string, while &#39;result&#39; is a [String]. When I profiled the code in Instruments, I noticed that it was spending significant time within the reflection machinery.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It turns out that the initializer to make a String out of a utf16 view looks like this, and I believe this is the initializer the author intended to call:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; init?(_: String.UTF16View)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; However, the actual initializer being called was this String initializer in the Mirror code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public init&lt;Subject&gt;(_ instance: Subject)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This seems like a tricky gotcha for developers who aren&#39;t extremely familiar with both the String and reflection APIs. His code looked reasonable at a first glance and I didn&#39;t suspect anything was wrong until I profiled it. Even so, I only made the connection because I recognized the name of the standard library function from poking around inside the source files.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br>&gt;&gt; <br>&gt;&gt; This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is very easy to call by accident if you&#39;re trying to hit another unlabeled initializer. It also strikes me as not particularly &quot;value-preserving&quot;, since stringifying many types loses information. Perhaps we should propose giving it a label, String(printing:) maybe?<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt; <br>&gt; +1<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160510/37191c26/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>String initializers and developer ergonomics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  9, 2016 at 08:00:00pm</p></header><div class="content"><p>On May 9, 2016, at 10:25 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; This seems like a tricky gotcha for developers who aren&#39;t extremely familiar with both the String and reflection APIs. His code looked reasonable at a first glance and I didn&#39;t suspect anything was wrong until I profiled it. Even so, I only made the connection because I recognized the name of the standard library function from poking around inside the source files.<br>&gt;&gt; <br>&gt;&gt; What do other people think? Is this something worth worrying about, or is it so rare that it shouldn&#39;t matter? Also, any suggestions as to how that code sample might be improved would be appreciated - my naive first attempt wasn&#39;t any better.<br>&gt; <br>&gt; This definitely strikes me as a problem. The String&lt;T&gt;(_:) constructor is very easy to call by accident if you&#39;re trying to hit another unlabeled initializer. It also strikes me as not particularly &quot;value-preserving&quot;, since stringifying many types loses information. Perhaps we should propose giving it a label, String(printing:) maybe?<br></p><p>I agree, +1.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
