<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On 2016-07-18 16:15:10 +0000, Leonardo Pessoa via swift-evolution said:<br></p><p>&gt; I believe sealed by default applied to functions makes the behaviour<br>&gt; consistent with classes and allows for the same behaviour we wanted<br>&gt; with this proposal. It would allows us to create subclassable classes<br>&gt; in which we would be able to internally override a method but not<br>&gt; outside the library and selectively allow other methods to be<br>&gt; overriden. Final won&#39;t do it so if this is not the default behaviour,<br>&gt; it will be necessary to introduce the sealed keyword so we can achieve<br>&gt; this.<br></p><p>Can you give an example where you&#39;d need such a sealed method, but the <br>obvious pattern I described wouldn&#39;t work?<br></p><p>&gt; It&#39;s inconsistent to have to explicitly open a class and<br>&gt; explicitly seal its methods and vice-versa. It was my assumption that<br>&gt; when we chose sealed by default with the proposal we were talking<br>&gt; about everything and not just classes (I at least was talking<br>&gt; everything).<br></p><p>This was my assumption as well, but then I thought things through. I <br>suspect this might be what our friendly review manager was getting at <br>when he gently lamented the lack of sufficient discussion on <br>&quot;overridable&quot;.<br></p><p>&gt; Introducing &quot;dynamic&quot; or some other keyword to mark explicitly methods<br>&gt; that should be overriden is just the same &quot;open&quot; with sealed methods<br>&gt; by default would mean for public methods so it makes no difference to<br>&gt; me.<br></p><p>&quot;dynamic&quot; is already in the language. It changes method dispatch to use <br>Objective-C style message passing, enabling advanced techniques based <br>on the dynamic runtime, such as method swizzling or KVO. Since it <br>already exists, I&#39;m not arguing for its introduction; I merely want it <br>integrated into the proposal, in order to keep the language coherent.<br></p><p>&gt; Also having no default will not change that some library<br>&gt; developers will have everything sealed and selectively open.<br>&gt; No default shall also make developers prone to open to think more about<br>&gt; the keyword they&#39;ll choose to use,<br></p><p>Exactly! For this particular corner of the language, it fulfills the <br>&quot;unwavering goal of requiring additional thought when publishing a <br>class as public API&quot;. Forcing people to make an explicit choice is by <br>far the most straightforward way to achieve this. It also has the nice <br>property of being harder to interpret as a value judgement on <br>overridability, which is clearly a topic that gets people&#39;s monocles <br>popping. ಠ_ರೃ<br></p><p>&gt; but I&#39;m not fond of no default.<br></p><p>If adding an extra qualifier turns out to be an onerous requirement, we <br>can choose a default at any time later, without breaking existing code. <br>It&#39;ll probably be easier to do so once we have a little experience in <br>actually using the new language.<br></p><p>&gt; As for the inheritance of openness, I firmly believe it shouldn&#39;t. If<br>&gt; a class inherited from an open class is open by default, there will be<br>&gt; no libraries making use of other libraries or we should also introduce<br>&gt; the sealed keyword in order to make the class (or method) sealed<br>&gt; again. This behaviour seems inconsistent to me too.<br></p><p>Agreed.<br></p><p>&gt; <br>&gt; L<br>&gt; <br>&gt; <br>&gt; On 18 July 2016 at 09:07, Károly Lőrentey &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On 2016-07-18 09:17:43 +0000, David Hart via swift-evolution said:<br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Jul 2016, at 11:11, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there a summary somewhere of the motivation for allowing methods to<br>&gt;&gt;&gt;&gt;&gt; be declared non-overridable within open classes?<br>&gt;&gt;&gt; [...]<br>&gt;&gt;&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The<br>&gt;&gt;&gt; mere fact that a class allows subclassing doesn&#39;t necessarily mean that<br>&gt;&gt;&gt; every member in it is designed to be subclassed. Consider<br>&gt;&gt;&gt; `UIViewController`: It&#39;s obviously designed to be subclassed, and some<br>&gt;&gt;&gt; methods in it (such as `loadView`) are intended to be overridden, but others<br>&gt;&gt;&gt; (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And [if UIViewController were to be written in Swift] there&#39;d be a good<br>&gt;&gt;&gt; reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know UIKit internals, but I could imagine loadViewIfNeeded be<br>&gt;&gt;&gt; overridden internally, if one knows the precise internal workings of<br>&gt;&gt;&gt; UIViewController. That would require open, to allow overriding internally<br>&gt;&gt;&gt; but not externally.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I thought about this aspect a little more. I think it&#39;s fair to say that<br>&gt;&gt; we&#39;re breaking new ground for language design here. Classes limiting<br>&gt;&gt; inheritance to a certain set of subclasses are nothing new (I&#39;ve written &amp;<br>&gt;&gt; used classes doing this in C++, Java and C#), but no language that I know of<br>&gt;&gt; allows limiting overrides of a specific public member in such a way. I think<br>&gt;&gt; we need a convincing rationale for making this esoteric middle ground<br>&gt;&gt; between final and open members the new default.<br>&gt;&gt; <br>&gt;&gt; The UIKit example above isn&#39;t convincing at all. It is already quite easy to<br>&gt;&gt; allow package-internal subclasses to configure the behavior of<br>&gt;&gt; loadViewIfNeeded without such a novel language feature. E.g., the UIKit team<br>&gt;&gt; can simply make loadViewIfNeeded call into a non-final but internal method:<br>&gt;&gt; <br>&gt;&gt; public open class UIViewController {<br>&gt;&gt; private var _view: UIView? = nil<br>&gt;&gt; <br>&gt;&gt; public final func loadViewIfNeeded() {<br>&gt;&gt; internalLoadViewIfNeeded()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func internalLoadViewIfNeeded() { // overridable internally<br>&gt;&gt; if let view = _view { return }<br>&gt;&gt; loadView()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public open func loadView() {<br>&gt;&gt; // Load it from a nib or whatevs<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I see no drawback to this pattern; it is quite clear and simple. Therefore,<br>&gt;&gt; in the interest of keeping the language free of needless complexity, I<br>&gt;&gt; suggest we change the proposal to remove the implicit &quot;sealed&quot; level of<br>&gt;&gt; public member overridability, and support only &quot;open&quot; or &quot;final&quot; class<br>&gt;&gt; members.<br>&gt;&gt; <br>&gt;&gt; For members, &quot;open&quot; should mean the opposite of &quot;final&quot;, with no levels in<br>&gt;&gt; between. Member-level openness should be entirely independent of visibility;<br>&gt;&gt; so it should be possible to say &quot;internal open&quot; to mean an internally<br>&gt;&gt; overridable member that&#39;s not at all visible outside the module -- the same<br>&gt;&gt; as today&#39;s default.<br>&gt;&gt; <br>&gt;&gt; (Note that (on platforms with an Objective-C runtime) &quot;dynamic&quot; provides a<br>&gt;&gt; third level of flexibility for class members; I argue that it should imply<br>&gt;&gt; &quot;open&quot;. So in order of increasing flexibility, we&#39;d have &quot;final&quot;, &quot;open&quot; and<br>&gt;&gt; &quot;dynamic&quot; members. This seems easy enough to describe and understand.)<br>&gt;&gt; <br>&gt;&gt; I also suggest that for now, we should make neither &quot;final&quot; nor &quot;open&quot; nor<br>&gt;&gt; &quot;dynamic&quot; the default for public members of open classes: we should rather<br>&gt;&gt; require class authors to explicity add one of these qualifiers to all public<br>&gt;&gt; member declarations. This way, we can defer the argument for choosing a<br>&gt;&gt; default to a later (additive) proposal, once we have some experience with<br>&gt;&gt; this setup. Non-public members can safely keep defaulting to &quot;internal<br>&gt;&gt; open&quot;, like they do today.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Károly<br>&gt;&gt; @lorentey<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-- <br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>On 18 July 2016 at 16:06, Károly Lőrentey &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On 2016-07-18 16:15:10 +0000, Leonardo Pessoa via swift-evolution said:<br>&gt;<br>&gt;&gt; I believe sealed by default applied to functions makes the behaviour<br>&gt;&gt; consistent with classes and allows for the same behaviour we wanted<br>&gt;&gt; with this proposal. It would allows us to create subclassable classes<br>&gt;&gt; in which we would be able to internally override a method but not<br>&gt;&gt; outside the library and selectively allow other methods to be<br>&gt;&gt; overriden. Final won&#39;t do it so if this is not the default behaviour,<br>&gt;&gt; it will be necessary to introduce the sealed keyword so we can achieve<br>&gt;&gt; this.<br>&gt;<br>&gt;<br>&gt; Can you give an example where you&#39;d need such a sealed method, but the<br>&gt; obvious pattern I described wouldn&#39;t work?<br></p><p>I&#39;m not saying your pattern doesn&#39;t work; I&#39;m saying it requires more code.<br></p><p>&gt;&gt; It&#39;s inconsistent to have to explicitly open a class and<br>&gt;&gt; explicitly seal its methods and vice-versa. It was my assumption that<br>&gt;&gt; when we chose sealed by default with the proposal we were talking<br>&gt;&gt; about everything and not just classes (I at least was talking<br>&gt;&gt; everything).<br>&gt;<br>&gt;<br>&gt; This was my assumption as well, but then I thought things through. I suspect<br>&gt; this might be what our friendly review manager was getting at when he gently<br>&gt; lamented the lack of sufficient discussion on &quot;overridable&quot;.<br>&gt;<br>&gt;&gt; Introducing &quot;dynamic&quot; or some other keyword to mark explicitly methods<br>&gt;&gt; that should be overriden is just the same &quot;open&quot; with sealed methods<br>&gt;&gt; by default would mean for public methods so it makes no difference to<br>&gt;&gt; me.<br>&gt;<br>&gt;<br>&gt; &quot;dynamic&quot; is already in the language. It changes method dispatch to use<br>&gt; Objective-C style message passing, enabling advanced techniques based on the<br>&gt; dynamic runtime, such as method swizzling or KVO. Since it already exists,<br>&gt; I&#39;m not arguing for its introduction; I merely want it integrated into the<br>&gt; proposal, in order to keep the language coherent.<br></p><p>When I was talking &quot;dynamic&quot; here, I was meaning as in .NET (dynamic<br>is required to say a method can be overriden). Perhaps I was misguided<br>here.<br></p><p>&gt;&gt; Also having no default will not change that some library<br>&gt;&gt; developers will have everything sealed and selectively open.<br>&gt;&gt; No default shall also make developers prone to open to think more about<br>&gt;&gt; the keyword they&#39;ll choose to use,<br>&gt;<br>&gt;<br>&gt; Exactly! For this particular corner of the language, it fulfills the<br>&gt; &quot;unwavering goal of requiring additional thought when publishing a class as<br>&gt; public API&quot;. Forcing people to make an explicit choice is by far the most<br>&gt; straightforward way to achieve this. It also has the nice property of being<br>&gt; harder to interpret as a value judgement on overridability, which is clearly<br>&gt; a topic that gets people&#39;s monocles popping. ಠ_ರೃ<br>&gt;<br>&gt;&gt; but I&#39;m not fond of no default.<br>&gt;<br>&gt;<br>&gt; If adding an extra qualifier turns out to be an onerous requirement, we can<br>&gt; choose a default at any time later, without breaking existing code. It&#39;ll<br>&gt; probably be easier to do so once we have a little experience in actually<br>&gt; using the new language.<br></p><p>So should we drop internal by default too?<br></p><p>&gt;&gt; As for the inheritance of openness, I firmly believe it shouldn&#39;t. If<br>&gt;&gt; a class inherited from an open class is open by default, there will be<br>&gt;&gt; no libraries making use of other libraries or we should also introduce<br>&gt;&gt; the sealed keyword in order to make the class (or method) sealed<br>&gt;&gt; again. This behaviour seems inconsistent to me too.<br>&gt;<br>&gt;<br>&gt; Agreed.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; L<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18 July 2016 at 09:07, Károly Lőrentey &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2016-07-18 09:17:43 +0000, David Hart via swift-evolution said:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 18 Jul 2016, at 11:11, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Jul 18, 2016 at 3:27 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Is there a summary somewhere of the motivation for allowing methods to<br>&gt;&gt;&gt;&gt;&gt;&gt; be declared non-overridable within open classes?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; [...]<br>&gt;&gt;&gt;&gt; Garth: I think it&#39;s implicit in the reasons to prevent subclassing. The<br>&gt;&gt;&gt;&gt; mere fact that a class allows subclassing doesn&#39;t necessarily mean that<br>&gt;&gt;&gt;&gt; every member in it is designed to be subclassed. Consider<br>&gt;&gt;&gt;&gt; `UIViewController`: It&#39;s obviously designed to be subclassed, and some<br>&gt;&gt;&gt;&gt; methods in it (such as `loadView`) are intended to be overridden, but<br>&gt;&gt;&gt;&gt; others<br>&gt;&gt;&gt;&gt; (such as `loadViewIfNeeded`) are *not* intended to be overridden.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And [if UIViewController were to be written in Swift] there&#39;d be a good<br>&gt;&gt;&gt;&gt; reason why `loadViewIfNeeded` and others of its ilk couldn&#39;t be final?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t know UIKit internals, but I could imagine loadViewIfNeeded be<br>&gt;&gt;&gt;&gt; overridden internally, if one knows the precise internal workings of<br>&gt;&gt;&gt;&gt; UIViewController. That would require open, to allow overriding<br>&gt;&gt;&gt;&gt; internally<br>&gt;&gt;&gt;&gt; but not externally.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I thought about this aspect a little more. I think it&#39;s fair to say that<br>&gt;&gt;&gt; we&#39;re breaking new ground for language design here. Classes limiting<br>&gt;&gt;&gt; inheritance to a certain set of subclasses are nothing new (I&#39;ve written<br>&gt;&gt;&gt; &amp;<br>&gt;&gt;&gt; used classes doing this in C++, Java and C#), but no language that I know<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; allows limiting overrides of a specific public member in such a way. I<br>&gt;&gt;&gt; think<br>&gt;&gt;&gt; we need a convincing rationale for making this esoteric middle ground<br>&gt;&gt;&gt; between final and open members the new default.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The UIKit example above isn&#39;t convincing at all. It is already quite easy<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt; allow package-internal subclasses to configure the behavior of<br>&gt;&gt;&gt; loadViewIfNeeded without such a novel language feature. E.g., the UIKit<br>&gt;&gt;&gt; team<br>&gt;&gt;&gt; can simply make loadViewIfNeeded call into a non-final but internal<br>&gt;&gt;&gt; method:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public open class UIViewController {<br>&gt;&gt;&gt; private var _view: UIView? = nil<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public final func loadViewIfNeeded() {<br>&gt;&gt;&gt; internalLoadViewIfNeeded()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; internal func internalLoadViewIfNeeded() { // overridable internally<br>&gt;&gt;&gt; if let view = _view { return }<br>&gt;&gt;&gt; loadView()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public open func loadView() {<br>&gt;&gt;&gt; // Load it from a nib or whatevs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see no drawback to this pattern; it is quite clear and simple.<br>&gt;&gt;&gt; Therefore,<br>&gt;&gt;&gt; in the interest of keeping the language free of needless complexity, I<br>&gt;&gt;&gt; suggest we change the proposal to remove the implicit &quot;sealed&quot; level of<br>&gt;&gt;&gt; public member overridability, and support only &quot;open&quot; or &quot;final&quot; class<br>&gt;&gt;&gt; members.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For members, &quot;open&quot; should mean the opposite of &quot;final&quot;, with no levels<br>&gt;&gt;&gt; in<br>&gt;&gt;&gt; between. Member-level openness should be entirely independent of<br>&gt;&gt;&gt; visibility;<br>&gt;&gt;&gt; so it should be possible to say &quot;internal open&quot; to mean an internally<br>&gt;&gt;&gt; overridable member that&#39;s not at all visible outside the module -- the<br>&gt;&gt;&gt; same<br>&gt;&gt;&gt; as today&#39;s default.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Note that (on platforms with an Objective-C runtime) &quot;dynamic&quot; provides<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt; third level of flexibility for class members; I argue that it should<br>&gt;&gt;&gt; imply<br>&gt;&gt;&gt; &quot;open&quot;. So in order of increasing flexibility, we&#39;d have &quot;final&quot;, &quot;open&quot;<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; &quot;dynamic&quot; members. This seems easy enough to describe and understand.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also suggest that for now, we should make neither &quot;final&quot; nor &quot;open&quot;<br>&gt;&gt;&gt; nor<br>&gt;&gt;&gt; &quot;dynamic&quot; the default for public members of open classes: we should<br>&gt;&gt;&gt; rather<br>&gt;&gt;&gt; require class authors to explicity add one of these qualifiers to all<br>&gt;&gt;&gt; public<br>&gt;&gt;&gt; member declarations. This way, we can defer the argument for choosing a<br>&gt;&gt;&gt; default to a later (additive) proposal, once we have some experience with<br>&gt;&gt;&gt; this setup. Non-public members can safely keep defaulting to &quot;internal<br>&gt;&gt;&gt; open&quot;, like they do today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Károly<br>&gt;&gt;&gt; @lorentey<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Károly<br>&gt; @lorentey<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 18, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 18, 2016, at 12:06 PM, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Introducing &quot;dynamic&quot; or some other keyword to mark explicitly methods<br>&gt;&gt; that should be overriden is just the same &quot;open&quot; with sealed methods<br>&gt;&gt; by default would mean for public methods so it makes no difference to<br>&gt;&gt; me.<br>&gt; <br>&gt; &quot;dynamic&quot; is already in the language. It changes method dispatch to use Objective-C style message passing, enabling advanced techniques based on the dynamic runtime, such as method swizzling or KVO. Since it already exists, I&#39;m not arguing for its introduction; I merely want it integrated into the proposal, in order to keep the language coherent.<br></p><p>I would prefer not to ascribe overridability semantics to `dynamic`. I see `dynamic` as a hint to the compiler that something *outside of normal, safe Swift code* may cause this entity&#39;s implementation to change. A `dynamic final` member is a perfectly coherent concept: Formally, nothing is allowed to override this member, but in practice, something may change it behind the compiler&#39;s back.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>The revised proposal is much nicer. I&#39;m still onboard on having classes<br>sealed by default, but not as much on class members. Initially I felt<br>that members should follow the same semantics as the class to avoid<br>confusion, but I&#39;ve read all the other emails I think I changed my mind.<br> <br>As demonstrated by Károly, it is pretty simple to create a internally<br>opened method by having a public final method that calls the internal<br>one. To me having open only applied to class provides a nice balance to<br>the language.<br> <br>---<br> <br>On Mon, Jul 18, 2016, at 03:48, L. Mihalkovic via swift-evolution wrote:<br>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt; On Jul 18, 2016, at 10:27 AM, Brent Royal-Gordon<br>&gt; &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; On Jul 17, 2016, at 8:57 PM, L. Mihalkovic via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jul 17, 2016, at 9:14 PM, Garth Snyder via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Is there a summary somewhere of the motivation for allowing methods<br>&gt;&gt;&gt;&gt; to be declared non-overridable within open classes?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because 1) someone woke up one morning and thought it would be great<br>&gt;&gt;&gt; 2) it goes into the direction of making swift a language for non<br>&gt;&gt;&gt; programmers 3) the core team wants it<br>&gt;&gt;<br>&gt;&gt; Laurent: This is not a fair characterization of the actual position<br>&gt;&gt; of the proposal&#39;s supporters. If you can&#39;t be civil about this topic,<br>&gt;&gt; perhaps you shouldn&#39;t be discussing it at all.<br>&gt;<br>&gt; 3) the core team was very clear that it is the<br>&gt; direction they want for the language.<br> <br>I have edit the original message to focus only on point number 3.<br>Garth asked specifically about class members, not class themselves.<br>The core team &quot;believes with conviction&quot; that classes should not be<br>open by default but they asked more discussion on the &quot;overridability&quot;<br>of members.<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/aed4aad8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
