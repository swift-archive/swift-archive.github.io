<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  9, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I think I have found a couple of bugs in lazy collections; just checking<br>before filling. The following code is a filter map version of the Sieve of<br>Eratosthenes:<br></p><p>func lazyFilterMapForEachLoop(limit: Int = 9) -&gt; [Int] {<br></p><p>    var possibles = Array(count: limit + 1, repeatedValue: true)<br></p><p>    return (2 ... limit).lazy.filter { i in // Has to be lazy and<br>sequential so that `possibles` is updated before it is used<br></p><p>        print(&quot;i BF: \(i)&quot;)<br></p><p>        return possibles[i]<br></p><p>    }.map { i in<br></p><p>        print(&quot;i AF: \(i)&quot;)<br></p><p>        (i * i).stride(through: limit, by: i).forEach { j in<br></p><p>            possibles[j] = false<br></p><p>        }<br></p><p>        return i<br></p><p>    }<br></p><p>}<br></p><p><br>It produces for a limit of 9:<br></p><p>*i BF: 2*<br></p><p>*i BF: 3*<br></p><p>*i BF: 4*<br></p><p>*i BF: 5*<br></p><p>*i BF: 6*<br></p><p>*i BF: 7*<br></p><p>*i BF: 8*<br></p><p>*i BF: 9*<br></p><p>*i BF: 2*<br></p><p>*i AF: 2*<br></p><p>*i BF: 3*<br></p><p>*i AF: 3*<br></p><p>*i BF: 4*<br></p><p>*i BF: 5*<br></p><p>*i AF: 5*<br></p><p>*i BF: 6*<br></p><p>*i BF: 7*<br></p><p>*i AF: 7*<br></p><p>*i BF: 8*<br></p><p>*i BF: 9*<br></p><p>*fatal error: Index out of range*<br></p><p><br>There are a couple of odd things about this:<br></p><p>   1. The filter closure is called twice per trial integer! First without<br>   preceding to the map stage at all, i.e. all values are filtered out! Second<br>   time through the numbers it does proceed to the map stage as you would<br>   expect.<br>   2. It produces an &quot;Index out of range&quot; error despite the fact that<br>   maximum number processed is 9 which is an allowable index of `possibles`.<br></p><p>Is this a couple of bugs or have I misunderstood something?<br></p><p>Thanks in advance,<br></p><p>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160209/d1ce34de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February  8, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Feb 8, 2016 at 8:56 PM, Howard Lovatt via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; Hi,<br>&gt;<br>&gt; I think I have found a couple of bugs in lazy collections; just checking<br>&gt; before filling. The following code is a filter map version of the Sieve of<br>&gt; Eratosthenes:<br>&gt;<br>&gt; func lazyFilterMapForEachLoop(limit: Int = 9) -&gt; [Int] {<br>&gt;<br>&gt;     var possibles = Array(count: limit + 1, repeatedValue: true)<br>&gt;<br>&gt;     return (2 ... limit).lazy.filter { i in // Has to be lazy and sequential<br>&gt; so that `possibles` is updated before it is used<br></p><p>Before looking at your questions below, I want to note that this is<br>not a supported way of using the lazy subsystem.  The issue is that<br>you seem to be relying on the evaluation order.  It is not guaranteed,<br>even if you can reliably reproduce a certain evaluation order in the<br>current version of the library.<br></p><p>&gt; The filter closure is called twice per trial integer! First without<br>&gt; preceding to the map stage at all, i.e. all values are filtered out! Second<br>&gt; time through the numbers it does proceed to the map stage as you would<br>&gt; expect.<br></p><p>Again, remember that you are using the *lazy* subsystem.  The<br>evaluation order of the closures you are passing to the operations is<br>not guaranteed.  Closures can be evaluated once, more than once, or<br>not at all, and in the order that the library choses.  Closures are<br>required to be pure, so you are not allowed to observe how many times<br>and in which order they were actually evaluated.<br></p><p>The reason why the closure is evaluated twice is because you end up<br>calling an eager map(), which tries to reserve the array capacity<br>suitable for the result.  To do that, map() calls &#39;count&#39; on the lazy<br>filter collection, which triggers the computation the first time.<br></p><p>It is an open question though, whether calling the closure twice is<br>profitable here, and what can we do about it.  The idea though is that<br>those reallocations can sometimes be quite expensive when the closure<br>is cheap to execute.  OTOH, when the closure is expensive to evaluate,<br>calling it twice is a loss.<br></p><p>&gt; It produces an &quot;Index out of range&quot; error despite the fact that maximum<br>&gt; number processed is 9 which is an allowable index of `possibles`.<br></p><p>Are you sure you didn&#39;t mean to use ..&lt; instead of ...?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Thanks for the reply Dmitri - comments inline below:<br></p><p>  -- Howard.<br></p><p>On 9 February 2016 at 16:17, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Mon, Feb 8, 2016 at 8:56 PM, Howard Lovatt via swift-users<br>&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I think I have found a couple of bugs in lazy collections; just checking<br>&gt; &gt; before filling. The following code is a filter map version of the Sieve<br>&gt; of<br>&gt; &gt; Eratosthenes:<br>&gt; &gt;<br>&gt; &gt; func lazyFilterMapForEachLoop(limit: Int = 9) -&gt; [Int] {<br>&gt; &gt;<br>&gt; &gt;     var possibles = Array(count: limit + 1, repeatedValue: true)<br>&gt; &gt;<br>&gt; &gt;     return (2 ... limit).lazy.filter { i in // Has to be lazy and<br>&gt; sequential<br>&gt; &gt; so that `possibles` is updated before it is used<br>&gt;<br>&gt; Before looking at your questions below, I want to note that this is<br>&gt; not a supported way of using the lazy subsystem.  The issue is that<br>&gt; you seem to be relying on the evaluation order.  It is not guaranteed,<br>&gt; even if you can reliably reproduce a certain evaluation order in the<br>&gt; current version of the library.<br>&gt;<br></p><p>Not sure where it says that it won&#39;t be sequential - do you have a<br>reference?<br></p><p>&gt;<br>&gt; &gt; The filter closure is called twice per trial integer! First without<br>&gt; &gt; preceding to the map stage at all, i.e. all values are filtered out!<br>&gt; Second<br>&gt; &gt; time through the numbers it does proceed to the map stage as you would<br>&gt; &gt; expect.<br>&gt;<br>&gt; Again, remember that you are using the *lazy* subsystem.  The<br>&gt; evaluation order of the closures you are passing to the operations is<br>&gt; not guaranteed.  Closures can be evaluated once, more than once, or<br>&gt; not at all, and in the order that the library choses.  Closures are<br>&gt; required to be pure, so you are not allowed to observe how many times<br>&gt; and in which order they were actually evaluated.<br>&gt;<br>&gt; Not sure where it says it can be called more than one - the filter might<br>be a very expensive operation like a database lookup!<br></p><p><br>&gt; The reason why the closure is evaluated twice is because you end up<br>&gt; calling an eager map(), which tries to reserve the array capacity<br>&gt; suitable for the result.  To do that, map() calls &#39;count&#39; on the lazy<br>&gt; filter collection, which triggers the computation the first time.<br>&gt;<br>&gt; map on a lazy collection results in another lazy collection, so I don&#39;t<br>see this.<br></p><p><br>&gt; It is an open question though, whether calling the closure twice is<br>&gt; profitable here, and what can we do about it.  The idea though is that<br>&gt; those reallocations can sometimes be quite expensive when the closure<br>&gt; is cheap to execute.  OTOH, when the closure is expensive to evaluate,<br>&gt; calling it twice is a loss.<br>&gt;<br>&gt; &gt; It produces an &quot;Index out of range&quot; error despite the fact that maximum<br>&gt; &gt; number processed is 9 which is an allowable index of `possibles`.<br>&gt;<br>&gt; Are you sure you didn&#39;t mean to use ..&lt; instead of ...?<br>&gt;<br></p><p>No I meant 2 ... limit, the array is of size limit + 1.<br></p><p>PS The equivalent code in Java works as expected.<br></p><p>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160209/63dbef56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>February  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 9:28 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Not sure where it says that it won&#39;t be sequential - do you have a reference? <br>…<br>&gt; Not sure where it says it can be called more than one - the filter might be a very expensive operation like a database lookup!<br></p><p>I think it’s more that the documentation doesn’t specify sequential ordering, and that it doesn’t say the closure is only called once … so you can’t assume that those conditions are true. You’re just inferring that they are, based on your intuition about the implementation.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160208/8670e97e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  9, 2016 at 05:00:00pm</p></header><div class="content"><p>But it does say it is in-order. It says for SequenceType:<br></p><p>&quot;A type that can be iterated with a for...in loop&quot;<br></p><p>which means it must be in-order (for loops are allowed side effects). Also<br>why would you call something SequenceType if it wasn&#39;t sequential? It also<br>categorically says that you can&#39;t iterate multiple times reliably:<br></p><p> &quot;As a consequence, it is not possible to run multiple for loops on a<br>sequence to &quot;resume&quot; iteration&quot;.<br></p><p><br>So why am I seeing two passes?<br></p><p>And an index out of bounds?<br></p><p>  -- Howard.<br></p><p>On 9 February 2016 at 17:26, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 8, 2016, at 9:28 PM, Howard Lovatt via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Not sure where it says that it won&#39;t be sequential - do you have a<br>&gt; reference?<br>&gt;<br>&gt; …<br>&gt;<br>&gt; Not sure where it says it can be called more than one - the filter might<br>&gt; be a very expensive operation like a database lookup!<br>&gt;<br>&gt;<br>&gt; I think it’s more that the documentation *doesn’t* specify sequential<br>&gt; ordering, and that it *doesn’t* say the closure is only called once … so<br>&gt; you can’t assume that those conditions are true. You’re just inferring that<br>&gt; they are, based on your intuition about the implementation.<br>&gt;<br>&gt; —Jens<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160209/89cc77c9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February  8, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Feb 8, 2016 at 9:28 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; Thanks for the reply Dmitri - comments inline below:<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 9 February 2016 at 16:17, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 8, 2016 at 8:56 PM, Howard Lovatt via swift-users<br>&gt;&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think I have found a couple of bugs in lazy collections; just checking<br>&gt;&gt; &gt; before filling. The following code is a filter map version of the Sieve<br>&gt;&gt; &gt; of<br>&gt;&gt; &gt; Eratosthenes:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func lazyFilterMapForEachLoop(limit: Int = 9) -&gt; [Int] {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     var possibles = Array(count: limit + 1, repeatedValue: true)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     return (2 ... limit).lazy.filter { i in // Has to be lazy and<br>&gt;&gt; &gt; sequential<br>&gt;&gt; &gt; so that `possibles` is updated before it is used<br>&gt;&gt;<br>&gt;&gt; Before looking at your questions below, I want to note that this is<br>&gt;&gt; not a supported way of using the lazy subsystem.  The issue is that<br>&gt;&gt; you seem to be relying on the evaluation order.  It is not guaranteed,<br>&gt;&gt; even if you can reliably reproduce a certain evaluation order in the<br>&gt;&gt; current version of the library.<br>&gt;<br>&gt;<br>&gt; Not sure where it says that it won&#39;t be sequential - do you have a<br>&gt; reference?<br></p><p>I&#39;m sorry, it is hard to provide a reference to internal discussions<br>that we had when we were designing these things, so please take my<br>word for it :)<br></p><p>If the documentation isn&#39;t saying anything about this, then it should<br>be improved to be more explicit.<br></p><p>The same is actually true even for the non-lazy map() and filter() --<br>you shouldn&#39;t be assuming the evaluation order for eager functions<br>either.  It is just that in practice it is only efficient to build the<br>result array in exactly one pass, from start to the end, so the<br>implementation is unlikely to change.  We also realize that many<br>people are likely to be accidentally relying on the evaluation order<br>there, so it would be hard to change it.  But still, it is not a<br>guarantee.<br></p><p>&gt;&gt; &gt; The filter closure is called twice per trial integer! First without<br>&gt;&gt; &gt; preceding to the map stage at all, i.e. all values are filtered out!<br>&gt;&gt; &gt; Second<br>&gt;&gt; &gt; time through the numbers it does proceed to the map stage as you would<br>&gt;&gt; &gt; expect.<br>&gt;&gt;<br>&gt;&gt; Again, remember that you are using the *lazy* subsystem.  The<br>&gt;&gt; evaluation order of the closures you are passing to the operations is<br>&gt;&gt; not guaranteed.  Closures can be evaluated once, more than once, or<br>&gt;&gt; not at all, and in the order that the library choses.  Closures are<br>&gt;&gt; required to be pure, so you are not allowed to observe how many times<br>&gt;&gt; and in which order they were actually evaluated.<br>&gt;&gt;<br>&gt; Not sure where it says it can be called more than one - the filter might be<br>&gt; a very expensive operation like a database lookup!<br>&gt;<br>&gt;&gt;<br>&gt;&gt; The reason why the closure is evaluated twice is because you end up<br>&gt;&gt; calling an eager map(), which tries to reserve the array capacity<br>&gt;&gt; suitable for the result.  To do that, map() calls &#39;count&#39; on the lazy<br>&gt;&gt; filter collection, which triggers the computation the first time.<br>&gt;&gt;<br>&gt; map on a lazy collection results in another lazy collection, so I don&#39;t see<br>&gt; this.<br></p><p>There are two overloads -- one from CollectionType protocol, that<br>returns an Array, and another one from lazy, that returns a lazy<br>collection.  Both are visible, the second is preferred.  Since you<br>used the map() function in a position that requires the Array return<br>type to match with the function&#39;s return type (via the return<br>statement), the lazy overload can&#39;t match, so the type checker<br>selected the first one.<br></p><p>&gt;&gt; It is an open question though, whether calling the closure twice is<br>&gt;&gt; profitable here, and what can we do about it.  The idea though is that<br>&gt;&gt; those reallocations can sometimes be quite expensive when the closure<br>&gt;&gt; is cheap to execute.  OTOH, when the closure is expensive to evaluate,<br>&gt;&gt; calling it twice is a loss.<br>&gt;&gt;<br>&gt;&gt; &gt; It produces an &quot;Index out of range&quot; error despite the fact that maximum<br>&gt;&gt; &gt; number processed is 9 which is an allowable index of `possibles`.<br>&gt;&gt;<br>&gt;&gt; Are you sure you didn&#39;t mean to use ..&lt; instead of ...?<br>&gt;<br>&gt;<br>&gt; No I meant 2 ... limit, the array is of size limit + 1.<br></p><p>Oh, right, now I see the issue.  The issue again caused by the<br>non-purity of the closure passed to filter().  The first time the<br>closure always says true, which promises a large filtered collection.<br>But then, during the second pass, it starts rejecting elements it<br>previously accepted, and delivers a collection smaller than promised.<br></p><p>&gt; PS The equivalent code in Java works as expected.<br></p><p>It is hard to say what the equivalent Java code would be, since Java<br>does not have a Swift lazy subsystem.  Java has streams, but it would<br>be wrong to assume that the two operate according to the same exact<br>rules.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>2 x lazy collection bugs</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>February  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 11:54 PM, Dmitri Gribenko via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Oh, right, now I see the issue.  The issue again caused by the<br>&gt; non-purity of the closure passed to filter(). <br></p><p>It makes sense that the closures passed to functional operations like filter() and map() should be pure, but I don’t see that documented. It would probably be a good idea to call this out explicitly, for the benefit of those not used to functional programming.<br></p><p>(I think someone earlier in this thread said that “all closures should be pure”, but of course that’s not true in Swift in general. This exposes the tension between functional and non-functional uses of Swift.)<br></p><p>[I’m by no means an expert at functional programming, but I develop a database engine that uses map/reduce for indexing, and I’m very used to having to remind users that their map functions need to be pure :) ]<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160209/303debf8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
