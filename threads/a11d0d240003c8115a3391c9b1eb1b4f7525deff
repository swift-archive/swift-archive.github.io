<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “Constraining AnySequence.init” begins now and runs through Monday, December 21st, 2015. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>	Cheers,<br>	Doug Gregor<br>	Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20151218/a11ddeff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>The URL is right (https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md), but the link points to a different proposal (https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md). Copy-paste it to access the review.<br></p><p>&gt; Le 18 déc. 2015 à 12:51:57, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Constraining AnySequence.init” begins now and runs through Monday, December 21st, 2015. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; 	Cheers,<br>&gt; 	Doug Gregor<br>&gt; 	Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/065bc65d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>Yikes, thank you! I have no idea how I managed that. Will re-send...<br></p><p>	- Doug<br></p><p>&gt; On Dec 18, 2015, at 9:58 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; The URL is right (https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md&gt;), but the link points to a different proposal (https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;). Copy-paste it to access the review.<br>&gt; <br>&gt;&gt; Le 18 déc. 2015 à 12:51:57, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of “Constraining AnySequence.init” begins now and runs through Monday, December 21st, 2015. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; 	Cheers,<br>&gt;&gt; 	Doug Gregor<br>&gt;&gt; 	Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/71010351/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>*# What is your evaluation of the proposal?*<br></p><p>Overall it looks good. I haven&#39;t looked at the implementation of<br>AnySequence before, but it sound fairly reasonable.<br></p><p>A couple of minor nits:<br></p><p>1. The proposal motivation says<br></p><p>&gt; At the moment AnyCollection does not delegate calls to SequenceType<br>&gt; protocol methods to the underlying base sequence<br></p><p>Presumably that should say AnySequence instead of AnyCollection, since<br>the rest of the proposal talks about AnySequence?<br></p><p>2. One of the added constraints looks like<br></p><p>S.SubSequence.SubSequence == S.SubSequence<br></p><p>with a comment saying that ideally the set of constraints would apply to<br>the SequenceType protocol but that&#39;s not currently possible. This makes<br>sense for the other constraints (that SubSequence conforms to<br>SequenceType and has the same element), but this particular constraint,<br>that the subsequence type must have itself as its own subsequence,<br>surprises me a little. I can see why it&#39;s needed here (because that&#39;s<br>the only way you can guarantee that recursing through SubSequences<br>always finds SequenceTypes with the right element), but ideally we<br>wouldn&#39;t actually require it to be the _same_ sequence, just that it is<br>some sequence with the same element type. If we ever change Swift such<br>that these constraints can be expressed on the SequenceType definition<br>itself, then presumably we&#39;ll be able to drop this == constraint<br>entirely as the SequenceType protocol itself will ensure that its<br>subsequence is a sequence of the same element type (which will satisfy<br>the need to have it be true after arbitrary levels of recursion).<br></p><p>Given that, I&#39;m inclined to say that we should of course go ahead and<br>have this == constraint here because that&#39;s the only way to satisfy the<br>requirement today, but just to note that if SequenceType can learn to<br>express this requirement directly the == constraint will go away as it&#39;s<br>perfectly fine then for subsequences of subsequences to be different<br>sequence types.<br></p><p>*# Is the problem being addressed significant enough to warrant a change<br>to Swift?*<br></p><p>Yeah. It&#39;s a fairly minor change in the scheme of things (should affect<br>very little code, if any), and it fixes a surprising hole in<br>AnySequence.<br></p><p>*# Does this proposal fit well with the feel and direction of Swift?*<br></p><p>Yes.<br></p><p>*# If you have you used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?*<br></p><p>Not applicable.<br></p><p>*# How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?*<br></p><p>A reasonably brief reading.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 18, 2015, at 09:59 AM, Douglas Gregor via swift-evolution wrote:<br>&gt; Yikes, thank you! I have no idea how I managed that. Will re-send...<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;&gt; On Dec 18, 2015, at 9:58 AM, Félix Cloutier<br>&gt;&gt; &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The URL is right<br>&gt;&gt; (https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md)<br>&gt;&gt; , but the link points to a different proposal<br>&gt;&gt; (https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md)<br>&gt;&gt; . Copy-paste it to access the review.<br>&gt;&gt;<br>&gt;&gt;&gt; Le 18 déc. 2015 à 12:51:57, Douglas Gregor via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The review of “Constraining AnySequence.init” begins now and runs<br>&gt;&gt;&gt; through Monday, December 21st, 2015. The proposal is available here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0014-constrained-AnySequence.md[1]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt;&gt; review through constructive criticism and, eventually, determine the<br>&gt;&gt;&gt; direction of Swift. When writing your review, here are some<br>&gt;&gt;&gt; questions you might want to answer in your review:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * What is your evaluation of the proposal? * Is the problem being<br>&gt;&gt;&gt; addressed significant enough to warrant a change to Swift? * Does<br>&gt;&gt;&gt; this proposal fit well with the feel and direction of Swift? * If<br>&gt;&gt;&gt; you have you used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those? * How<br>&gt;&gt;&gt; much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers, Doug Gregor Review Manager<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/d6bdc8b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>Thanks for a review Kevin!<br></p><p>&gt; At the moment AnyCollection does not delegate calls to SequenceType protocol methods to the underlying base sequence<br>&gt;  <br>&gt; Presumably that should say AnySequence instead of AnyCollection, since the rest of the proposal talks about AnySequence?<br>Good catch. Although applicable to AnyCollection as well, this should mention AnySequence in this case. 👍<br></p><p>&gt;  <br>&gt; 2. One of the added constraints looks like<br>&gt;  <br>&gt; S.SubSequence.SubSequence == S.SubSequence<br>&gt;  <br>&gt; with a comment saying that ideally the set of constraints would apply to the SequenceType protocol but that&#39;s not currently possible. This makes sense for the other constraints (that SubSequence conforms to SequenceType and has the same element), but this particular constraint, that the subsequence type must have itself as its own subsequence, surprises me a little. I can see why it&#39;s needed here (because that&#39;s the only way you can guarantee that recursing through SubSequences always finds SequenceTypes with the right element), but ideally we wouldn&#39;t actually require it to be the _same_ sequence, just that it is some sequence with the same element type. If we ever change Swift such that these constraints can be expressed on the SequenceType definition itself, then presumably we&#39;ll be able to drop this == constraint entirely as the SequenceType protocol itself will ensure that its subsequence is a sequence of the same element type (which will satisfy the need to have it be true after arbitrary levels of recursion).<br></p><p>You’re totally right again. I will make these changes to the proposal.<br></p><p>max<br></p><p>[a bunch of text removed]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/26a20386/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 18, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi Kevin,<br></p><p>Thank you for your feedback!<br></p><p>On Fri, Dec 18, 2015 at 3:13 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; 2. One of the added constraints looks like<br>&gt;<br>&gt;<br>&gt; S.SubSequence.SubSequence == S.SubSequence<br>&gt;<br>&gt;<br>&gt; with a comment saying that ideally the set of constraints would apply to<br>&gt; the SequenceType protocol but that&#39;s not currently possible. This makes<br>&gt; sense for the other constraints (that SubSequence conforms to SequenceType<br>&gt; and has the same element), but this particular constraint, that the<br>&gt; subsequence type must have itself as its own subsequence, surprises me a<br>&gt; little. I can see why it&#39;s needed here (because that&#39;s the only way you can<br>&gt; guarantee that recursing through SubSequences always finds SequenceTypes<br>&gt; with the right element), but ideally we wouldn&#39;t actually require it to be<br>&gt; the _same_ sequence, just that it is some sequence with the same element<br>&gt; type. If we ever change Swift such that these constraints can be expressed<br>&gt; on the SequenceType definition itself, then presumably we&#39;ll be able to<br>&gt; drop this == constraint entirely as the SequenceType protocol itself will<br>&gt; ensure that its subsequence is a sequence of the same element type (which<br>&gt; will satisfy the need to have it be true after arbitrary levels of<br>&gt; recursion).<br>&gt;<br></p><p>The idea behind putting this constraint into the protocol was to make it<br>possible to write code that repeatedly slices a collection without getting<br>a ton of different types along the way:<br></p><p>var myCollectionSlice = myCollection[myCollection.indices]<br>myCollectionSlice = myCollectionSlice.dropFirst()<br></p><p>Also, we couldn&#39;t come up with an example of a sequence or a collection<br>that needs to have different SubSequence types on different depth levels<br>for efficiency or type safety reasons.  Given that we think we aren&#39;t<br>limiting expressivity with this constraint, having a simpler model (the<br>operation of slicing slices is closed in the set of types) is better.<br></p><p>I&#39;d be happy to hear if you know some sequence or collection types that<br>would benefit from not having this constraint.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/e9835a37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 10:00:00pm</p></header><div class="content"><p>Fair enough. I was thinking that it&#39;s better to err on the side of<br>allowing flexibility, but there is something to be said for having<br>slices of slices still be slices. My vague thought was that there might<br>be some desire to have a slice be a type that wraps the thing being<br>sliced, but I admit that I can&#39;t think offhand of any reason why a<br>FooSlice&lt;FooSlice&lt;FooSlice&lt;Foo&gt;&gt;&gt; would be useful.<br></p><p>-Kevin<br></p><p>On Fri, Dec 18, 2015, at 08:51 PM, Dmitri Gribenko wrote:<br>&gt; Hi Kevin,<br>&gt;<br>&gt; Thank you for your feedback!<br>&gt;<br>&gt; On Fri, Dec 18, 2015 at 3:13 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; 2. One of the added constraints looks like<br>&gt;&gt;<br>&gt;&gt; S.SubSequence.SubSequence == S.SubSequence<br>&gt;&gt;<br>&gt;&gt; with a comment saying that ideally the set of constraints would apply<br>&gt;&gt; to the SequenceType protocol but that&#39;s not currently possible. This<br>&gt;&gt; makes sense for the other constraints (that SubSequence conforms to<br>&gt;&gt; SequenceType and has the same element), but this particular<br>&gt;&gt; constraint, that the subsequence type must have itself as its own<br>&gt;&gt; subsequence, surprises me a little. I can see why it&#39;s needed here<br>&gt;&gt; (because that&#39;s the only way you can guarantee that recursing through<br>&gt;&gt; SubSequences always finds SequenceTypes with the right element), but<br>&gt;&gt; ideally we wouldn&#39;t actually require it to be the _same_ sequence,<br>&gt;&gt; just that it is some sequence with the same element type. If we ever<br>&gt;&gt; change Swift such that these constraints can be expressed on the<br>&gt;&gt; SequenceType definition itself, then presumably we&#39;ll be able to drop<br>&gt;&gt; this == constraint entirely as the SequenceType protocol itself will<br>&gt;&gt; ensure that its subsequence is a sequence of the same element type<br>&gt;&gt; (which will satisfy the need to have it be true after arbitrary<br>&gt;&gt; levels of recursion).<br>&gt;<br>&gt; The idea behind putting this constraint into the protocol was to make<br>&gt; it possible to write code that repeatedly slices a collection without<br>&gt; getting a ton of different types along the way:<br>&gt;<br>&gt; var myCollectionSlice = myCollection[myCollection.indices]<br>&gt; myCollectionSlice = myCollectionSlice.dropFirst()<br>&gt;<br>&gt; Also, we couldn&#39;t come up with an example of a sequence or a<br>&gt; collection that needs to have different SubSequence types on different<br>&gt; depth levels for efficiency or type safety reasons.  Given that we<br>&gt; think we aren&#39;t limiting expressivity with this constraint, having a<br>&gt; simpler model (the operation of slicing slices is closed in the set of<br>&gt; types) is better.<br>&gt;<br>&gt; I&#39;d be happy to hear if you know some sequence or collection types<br>&gt; that would benefit from not having this constraint.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/0d5df098/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 10:00:00pm</p></header><div class="content"><p>Well actually...<br></p><p>LazyCollection right now has just this very behavior. The SubSequence of<br>a LazyCollection&lt;T&gt; is a LazyCollection&lt;Slice&lt;T&gt;&gt;. If you say<br>`[1,2,3].lazy.prefixUpTo(3).prefixUpTo(3)` you end up with a<br>LazyCollection&lt;Slice&lt;Slice&lt;[Int]&gt;&gt;&gt;. So the only way we can constrain<br>SubSequence this way is by also making it possible for LazyCollection to<br>&quot;flatten&quot; the slices.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 18, 2015, at 10:03 PM, Kevin Ballard wrote:<br>&gt; Fair enough. I was thinking that it&#39;s better to err on the side of<br>&gt; allowing flexibility, but there is something to be said for having<br>&gt; slices of slices still be slices. My vague thought was that there<br>&gt; might be some desire to have a slice be a type that wraps the thing<br>&gt; being sliced, but I admit that I can&#39;t think offhand of any reason why<br>&gt; a FooSlice&lt;FooSlice&lt;FooSlice&lt;Foo&gt;&gt;&gt; would be useful.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Fri, Dec 18, 2015, at 08:51 PM, Dmitri Gribenko wrote:<br>&gt;&gt; Hi Kevin,<br>&gt;&gt;<br>&gt;&gt; Thank you for your feedback!<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 18, 2015 at 3:13 PM, Kevin Ballard via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; 2. One of the added constraints looks like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; S.SubSequence.SubSequence == S.SubSequence<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with a comment saying that ideally the set of constraints would<br>&gt;&gt;&gt; apply to the SequenceType protocol but that&#39;s not currently<br>&gt;&gt;&gt; possible. This makes sense for the other constraints (that<br>&gt;&gt;&gt; SubSequence conforms to SequenceType and has the same element), but<br>&gt;&gt;&gt; this particular constraint, that the subsequence type must have<br>&gt;&gt;&gt; itself as its own subsequence, surprises me a little. I can see why<br>&gt;&gt;&gt; it&#39;s needed here (because that&#39;s the only way you can guarantee that<br>&gt;&gt;&gt; recursing through SubSequences always finds SequenceTypes with the<br>&gt;&gt;&gt; right element), but ideally we wouldn&#39;t actually require it to be<br>&gt;&gt;&gt; the _same_ sequence, just that it is some sequence with the same<br>&gt;&gt;&gt; element type. If we ever change Swift such that these constraints<br>&gt;&gt;&gt; can be expressed on the SequenceType definition itself, then<br>&gt;&gt;&gt; presumably we&#39;ll be able to drop this == constraint entirely as the<br>&gt;&gt;&gt; SequenceType protocol itself will ensure that its subsequence is a<br>&gt;&gt;&gt; sequence of the same element type (which will satisfy the need to<br>&gt;&gt;&gt; have it be true after arbitrary levels of recursion).<br>&gt;&gt;<br>&gt;&gt; The idea behind putting this constraint into the protocol was to make<br>&gt;&gt; it possible to write code that repeatedly slices a collection without<br>&gt;&gt; getting a ton of different types along the way:<br>&gt;&gt;<br>&gt;&gt; var myCollectionSlice = myCollection[myCollection.indices]<br>&gt;&gt; myCollectionSlice = myCollectionSlice.dropFirst()<br>&gt;&gt;<br>&gt;&gt; Also, we couldn&#39;t come up with an example of a sequence or a<br>&gt;&gt; collection that needs to have different SubSequence types on<br>&gt;&gt; different depth levels for efficiency or type safety reasons.  Given<br>&gt;&gt; that we think we aren&#39;t limiting expressivity with this constraint,<br>&gt;&gt; having a simpler model (the operation of slicing slices is closed in<br>&gt;&gt; the set of types) is better.<br>&gt;&gt;<br>&gt;&gt; I&#39;d be happy to hear if you know some sequence or collection types<br>&gt;&gt; that would benefit from not having this constraint.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/ecdd80b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] Constraining AnySequence.init</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 18, 2015 at 10:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015 at 10:08 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; Well actually...<br>&gt;<br>&gt; LazyCollection right now has just this very behavior. The SubSequence of a<br>&gt; LazyCollection&lt;T&gt; is a LazyCollection&lt;Slice&lt;T&gt;&gt;. If you say<br>&gt; `[1,2,3].lazy.prefixUpTo(3).prefixUpTo(3)` you end up with a<br>&gt; LazyCollection&lt;Slice&lt;Slice&lt;[Int]&gt;&gt;&gt;. So the only way we can constrain<br>&gt; SubSequence this way is by also making it possible for LazyCollection to<br>&gt; &quot;flatten&quot; the slices.<br></p><p>Indeed, thanks for noticing this!  Multiple levels of Slice&lt;T&gt;<br>wrapping is bad not just because of the type, but because each Slice<br>has its own index bounds stored, and every access through a Slice<br>needs to perform a range check.  So having multiple levels of wrapping<br>would affect performance in this case.<br></p><p>If we tested LazyCollection with `addForwardCollectionTests()` from<br>StdlibUnittest, we would have noticed.<br></p><p>The fix might be here:<br></p><p>// stdlib/public/core/LazyCollection.swift<br>public subscript(bounds: Range&lt;Index&gt;) -&gt; LazyCollection&lt;Slice&lt;Base&gt;&gt;<br>&gt;&gt;&gt;<br>public subscript(bounds: Range&lt;Index&gt;) -&gt; LazyCollection&lt;Base.SubSequence&gt;<br></p><p>(Haven&#39;t compiled it.)<br></p><p>I opened https://bugs.swift.org/browse/SR-318 for this issue.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
