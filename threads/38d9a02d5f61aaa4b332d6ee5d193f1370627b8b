<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello!<br></p><p>I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on<br>the swift-evolution repo, but we never had any discussion about it on-list,<br>besides a long time ago<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;.<br>Here&#39;s the first draft of the proposal:<br></p><p><br>Sealed classes by default<br>&lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;<br>Introduction<br></p><p>Introduce a new sealed class modifier that makes classes and methods<br>final outside<br>of the module they&#39;re declared in, but non-final within the module.<br>&lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;<br>Motivation<br></p><p>   - It is not uncommon to have a need for a reference type without needing<br>   inheritance. Classes must be intentionally designed to be subclassable,<br>   carefully deciding which methods are the override entry-points such that<br>   the the behavior remains correct and subclasses respect the Liskov<br>   substitution principle<br>   &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>   - Defaulting to non-final allows the author of a class to accidentally<br>   leave the visible methods open for overrides, even if they didn&#39;t carefully<br>   consider this possibility.<br>   - Requiring that the author of a class mark a class as open is akin to<br>   requiring symbols to be explicitly public: it ensures that a conscious<br>   decision is made regarding whether the ability to subclass a class is<br>   part of the API.<br></p><p>&lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed<br>solution<br></p><p>   - New sealed (*actual name pending bike-shedding*) class modifier for<br>   classes and methods which marks them as only overridable within the module<br>   they&#39;re declared in.<br>   - sealed becomes the default for classes and methods.<br>   - New open (*actual name pending bike-shedding*) class modifier to<br>   explicitly mark a class or a method as overridable.<br></p><p>&lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed<br>design<br></p><p>Code Examples:<br></p><p>/// ModuleA:<br>/// This class is `sealed` by default./// This is equivalent to<br>`sealed class SealedParentClass`class SealedParentClass {<br>    /// This method is `sealed` by default`.<br>    func foo()<br></p><p>    /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>    /// level higher than that of its class.<br>    open func bar()<br></p><p>    /// The behavior of `final` methods remains unchanged.<br>    final func baz()<br>}<br></p><p>open class OpenParentClass {<br>    /// This method is `sealed` by default`.<br>    func foo()<br></p><p>    /// Overridable methods in an `open` class must be explicitly<br>marked as `open`.<br>    open func bar()<br></p><p>    /// The behavior of a `final` method remains unchanged.<br>    final func baz()<br>}<br>/// The behavior of `final` classes remains unchanged.final class FinalClass { }<br></p><p>/// ModuleB:<br>import ModuleA<br>/// This raises a compilation error: ParentClass is effectively<br>`final` from/// this module&#39;s point of view.class SubclassA :<br>SealedParentClass { }<br>/// This is allowed since `OpenParentClass` has been marked explicitly<br>`open`class SubclassB : OpenParentClass {<br>    /// This raises a compilation error: `OpenParentClass.foo` is<br>    /// effectively `final` outside of `ModuleA`.<br>    override func foo() { }<br></p><p>    /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>    override func bar() { }<br>}<br></p><p>&lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>   - This would be a backwards-breaking change for all classes and methods<br>   that are public and non-final, which code outside of their module has<br>   overriden. Those classes/methods would fail to compile. Their superclass<br>   would need to be changed to open.<br></p><p>&lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives<br>considered<br></p><p>   - Defaulting to final instead: This would be comparable to Swift<br>   defaulting to private, as opposed to internal. Just like internal is a<br>   better trade-off, sealed by default also makes sure that getting started<br>   with Swift, writing code within a module, doesn&#39;t require a lot of<br>   boilerplate, and fighting against the compiler.<br></p><p>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/38d97b8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Could you elaborate on how we should treat classes imported from Objective-C or CF-style C? That is, do we always annotate them as being “open” because those paradigms permit subclassing anywhere, or do you propose some kind of recommended “sealed” audit, or what?<br></p><p>&gt; On Jun 27, 2016, at 3:40 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello!<br>&gt; <br>&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;. Here&#39;s the first draft of the proposal:<br>&gt; <br>&gt; <br>&gt; Sealed classes by default<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;Introduction<br>&gt; <br>&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;Motivation<br>&gt; <br>&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt; sealed becomes the default for classes and methods.<br>&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Code Examples:<br>&gt; <br>&gt; /// ModuleA:<br>&gt; <br>&gt; /// This class is `sealed` by default.<br>&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt; class SealedParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;     /// level higher than that of its class.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; open class OpenParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; /// The behavior of `final` classes remains unchanged.<br>&gt; final class FinalClass { }<br>&gt; /// ModuleB:<br>&gt; <br>&gt; import ModuleA<br>&gt; <br>&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt; /// this module&#39;s point of view.<br>&gt; class SubclassA : SealedParentClass { }<br>&gt; <br>&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt; class SubclassB : OpenParentClass {<br>&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;     override func foo() { }<br>&gt; <br>&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;     override func bar() { }<br>&gt; }<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt; -- <br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/ce49bd10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>June 28, 2016 at 12:00:00am</p></header><div class="content"><p>That is a very good point, it should be explicitly mentioned in the<br>proposal. My thought would be that since in the Obj-C runtime it&#39;s not<br>possible to guarantee a class won&#39;t have subclasses, or that a method is<br>not overriden, Obj-C classes would be imported as open.<br></p><p>On the Swift side, I think today it&#39;s possible to declare a &quot;public final<br>@objc class&quot;, but you can still inherit from it from Obj-C, right? My hunch<br>would be that that should be disallowed, but perhaps there&#39;s a reason why<br>it&#39;s allowed today.<br>On Mon, Jun 27, 2016 at 4:25 PM Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br></p><p>&gt; Could you elaborate on how we should treat classes imported from<br>&gt; Objective-C or CF-style C? That is, do we always annotate them as being<br>&gt; “open” because those paradigms permit subclassing anywhere, or do you<br>&gt; propose some kind of recommended “sealed” audit, or what?<br>&gt;<br>&gt; On Jun 27, 2016, at 3:40 PM, Javier Soto via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello!<br>&gt;<br>&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt;<br>&gt; on the swift-evolution repo, but we never had any discussion about it<br>&gt; on-list, besides a long time ago<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;.<br>&gt; Here&#39;s the first draft of the proposal:<br>&gt;<br>&gt;<br>&gt; Sealed classes by default<br>&gt; &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Introduce a new sealed class modifier that makes classes and methods final<br>&gt;  outside of the module they&#39;re declared in, but non-final within the<br>&gt; module.<br>&gt;<br>&gt; &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt;    - It is not uncommon to have a need for a reference type without<br>&gt;    needing inheritance. Classes must be intentionally designed to be<br>&gt;    subclassable, carefully deciding which methods are the override<br>&gt;    entry-points such that the the behavior remains correct and subclasses<br>&gt;    respect the Liskov substitution principle<br>&gt;    &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt;    - Defaulting to non-final allows the author of a class to accidentally<br>&gt;    leave the visible methods open for overrides, even if they didn&#39;t carefully<br>&gt;    consider this possibility.<br>&gt;    - Requiring that the author of a class mark a class as open is akin to<br>&gt;    requiring symbols to be explicitly public: it ensures that a conscious<br>&gt;    decision is made regarding whether the ability to subclass a class is<br>&gt;    part of the API.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt;    - New sealed (*actual name pending bike-shedding*) class modifier for<br>&gt;    classes and methods which marks them as only overridable within the module<br>&gt;    they&#39;re declared in.<br>&gt;    - sealed becomes the default for classes and methods.<br>&gt;    - New open (*actual name pending bike-shedding*) class modifier to<br>&gt;    explicitly mark a class or a method as overridable.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Code Examples:<br>&gt;<br>&gt; /// ModuleA:<br>&gt; /// This class is `sealed` by default./// This is equivalent to `sealed class SealedParentClass`class SealedParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt;<br>&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;     /// level higher than that of its class.<br>&gt;     open func bar()<br>&gt;<br>&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt;<br>&gt; open class OpenParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt;<br>&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;     open func bar()<br>&gt;<br>&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; /// The behavior of `final` classes remains unchanged.final class FinalClass { }<br>&gt;<br>&gt; /// ModuleB:<br>&gt; import ModuleA<br>&gt; /// This raises a compilation error: ParentClass is effectively `final` from/// this module&#39;s point of view.class SubclassA : SealedParentClass { }<br>&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`class SubclassB : OpenParentClass {<br>&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;     override func foo() { }<br>&gt;<br>&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;     override func bar() { }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt;    - This would be a backwards-breaking change for all classes and<br>&gt;    methods that are public and non-final, which code outside of their module<br>&gt;    has overriden. Those classes/methods would fail to compile. Their<br>&gt;    superclass would need to be changed to open.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    - Defaulting to final instead: This would be comparable to Swift<br>&gt;    defaulting to private, as opposed to internal. Just like internal is a<br>&gt;    better trade-off, sealed by default also makes sure that getting<br>&gt;    started with Swift, writing code within a module, doesn&#39;t require a lot of<br>&gt;    boilerplate, and fighting against the compiler.<br>&gt;<br>&gt; --<br>&gt; Javier Soto<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/fcdc9e2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>June 27, 2016 at 05:00:00pm</p></header><div class="content"><p>I was also referring to how we present Objective-C classes in Swift. That is, if a Swift user tries to subclass an Objective-C-imported class, then we’d take into account sealed-ness in order to issue an error/warning, etc. If you are also proposing a Clang attribute for this, e.g. ‘swift_sealed’, to import as sealed (meaning issue an error if Swift users try to subclass it), then that should be spelled out as well. I don’t have an opinion on whether this is a good idea yet, just pointing out some more directions to explore. In general it feels like your proposal could use more fleshing out.<br></p><p><br>&gt; On Jun 27, 2016, at 5:08 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is a very good point, it should be explicitly mentioned in the proposal. My thought would be that since in the Obj-C runtime it&#39;s not possible to guarantee a class won&#39;t have subclasses, or that a method is not overriden, Obj-C classes would be imported as open. <br>&gt; <br>&gt; On the Swift side, I think today it&#39;s possible to declare a &quot;public final @objc class&quot;, but you can still inherit from it from Obj-C, right? My hunch would be that that should be disallowed, but perhaps there&#39;s a reason why it&#39;s allowed today. <br>&gt; On Mon, Jun 27, 2016 at 4:25 PM Michael Ilseman &lt;milseman at apple.com &lt;mailto:milseman at apple.com&gt;&gt; wrote:<br>&gt; Could you elaborate on how we should treat classes imported from Objective-C or CF-style C? That is, do we always annotate them as being “open” because those paradigms permit subclassing anywhere, or do you propose some kind of recommended “sealed” audit, or what?<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 3:40 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; Hello!<br>&gt;&gt; <br>&gt;&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;. Here&#39;s the first draft of the proposal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sealed classes by default<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt;&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt;&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt;&gt; sealed becomes the default for classes and methods.<br>&gt;&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Code Examples:<br>&gt;&gt; <br>&gt;&gt; /// ModuleA:<br>&gt;&gt; <br>&gt;&gt; /// This class is `sealed` by default.<br>&gt;&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt;&gt; class SealedParentClass {<br>&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;     func foo()<br>&gt;&gt; <br>&gt;&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;&gt;     /// level higher than that of its class.<br>&gt;&gt;     open func bar()<br>&gt;&gt; <br>&gt;&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;&gt;     final func baz()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; open class OpenParentClass {<br>&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;     func foo()<br>&gt;&gt; <br>&gt;&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;&gt;     open func bar()<br>&gt;&gt; <br>&gt;&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;&gt;     final func baz()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// The behavior of `final` classes remains unchanged.<br>&gt;&gt; final class FinalClass { }<br>&gt;&gt; /// ModuleB:<br>&gt;&gt; <br>&gt;&gt; import ModuleA<br>&gt;&gt; <br>&gt;&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt;&gt; /// this module&#39;s point of view.<br>&gt;&gt; class SubclassA : SealedParentClass { }<br>&gt;&gt; <br>&gt;&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt;&gt; class SubclassB : OpenParentClass {<br>&gt;&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;&gt;     override func foo() { }<br>&gt;&gt; <br>&gt;&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;&gt;     override func bar() { }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt;&gt; -- <br>&gt;&gt; Javier Soto<br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Javier Soto<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/7aa6d63a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 06:00:00am</p></header><div class="content"><p>-1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility. A couple months ago I even ran into difficulties when trying to extend AlamoFire because some things had not been designed as cleanly as they could have been to make extending it easy. So if the default is now that everything becomes non-extensible but default, it is going to complicate (and partially defeat the purpose of) reusing libraries.<br>Regards<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 2:11 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was also referring to how we present Objective-C classes in Swift. That is, if a Swift user tries to subclass an Objective-C-imported class, then we’d take into account sealed-ness in order to issue an error/warning, etc. If you are also proposing a Clang attribute for this, e.g. ‘swift_sealed’, to import as sealed (meaning issue an error if Swift users try to subclass it), then that should be spelled out as well. I don’t have an opinion on whether this is a good idea yet, just pointing out some more directions to explore. In general it feels like your proposal could use more fleshing out.<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 5:08 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That is a very good point, it should be explicitly mentioned in the proposal. My thought would be that since in the Obj-C runtime it&#39;s not possible to guarantee a class won&#39;t have subclasses, or that a method is not overriden, Obj-C classes would be imported as open. <br>&gt;&gt; <br>&gt;&gt; On the Swift side, I think today it&#39;s possible to declare a &quot;public final @objc class&quot;, but you can still inherit from it from Obj-C, right? My hunch would be that that should be disallowed, but perhaps there&#39;s a reason why it&#39;s allowed today. <br>&gt;&gt; On Mon, Jun 27, 2016 at 4:25 PM Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt;&gt;&gt; Could you elaborate on how we should treat classes imported from Objective-C or CF-style C? That is, do we always annotate them as being “open” because those paradigms permit subclassing anywhere, or do you propose some kind of recommended “sealed” audit, or what?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 3:40 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I sent this as a PR on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago. Here&#39;s the first draft of the proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sealed classes by default<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle.<br>&gt;&gt;&gt;&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt;&gt;&gt;&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt;&gt;&gt;&gt; sealed becomes the default for classes and methods.<br>&gt;&gt;&gt;&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Code Examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// ModuleA:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// This class is `sealed` by default.<br>&gt;&gt;&gt;&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt;&gt;&gt;&gt; class SealedParentClass {<br>&gt;&gt;&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;&gt;&gt;&gt;     /// level higher than that of its class.<br>&gt;&gt;&gt;&gt;     open func bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;&gt;&gt;&gt;     final func baz()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; open class OpenParentClass {<br>&gt;&gt;&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;&gt;&gt;&gt;     open func bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;&gt;&gt;&gt;     final func baz()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// The behavior of `final` classes remains unchanged.<br>&gt;&gt;&gt;&gt; final class FinalClass { }<br>&gt;&gt;&gt;&gt; /// ModuleB:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import ModuleA<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt;&gt;&gt;&gt; /// this module&#39;s point of view.<br>&gt;&gt;&gt;&gt; class SubclassA : SealedParentClass { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt;&gt;&gt;&gt; class SubclassB : OpenParentClass {<br>&gt;&gt;&gt;&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;&gt;&gt;&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;&gt;&gt;&gt;     override func foo() { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;&gt;&gt;&gt;     override func bar() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Javier Soto<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Javier Soto<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/4d81716a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br></p><p>This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br></p><p>Mark<br></p><p>&gt; A couple months ago I even ran into difficulties when trying to extend AlamoFire because some things had not been designed as cleanly as they could have been to make extending it easy. So if the default is now that everything becomes non-extensible but default, it is going to complicate (and partially defeat the purpose of) reusing libraries.<br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 28, 2016, at 2:11 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I was also referring to how we present Objective-C classes in Swift. That is, if a Swift user tries to subclass an Objective-C-imported class, then we’d take into account sealed-ness in order to issue an error/warning, etc. If you are also proposing a Clang attribute for this, e.g. ‘swift_sealed’, to import as sealed (meaning issue an error if Swift users try to subclass it), then that should be spelled out as well. I don’t have an opinion on whether this is a good idea yet, just pointing out some more directions to explore. In general it feels like your proposal could use more fleshing out.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 5:08 PM, Javier Soto &lt;javier.api at gmail.com &lt;mailto:javier.api at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a very good point, it should be explicitly mentioned in the proposal. My thought would be that since in the Obj-C runtime it&#39;s not possible to guarantee a class won&#39;t have subclasses, or that a method is not overriden, Obj-C classes would be imported as open. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the Swift side, I think today it&#39;s possible to declare a &quot;public final @objc class&quot;, but you can still inherit from it from Obj-C, right? My hunch would be that that should be disallowed, but perhaps there&#39;s a reason why it&#39;s allowed today. <br>&gt;&gt;&gt; On Mon, Jun 27, 2016 at 4:25 PM Michael Ilseman &lt;milseman at apple.com &lt;mailto:milseman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Could you elaborate on how we should treat classes imported from Objective-C or CF-style C? That is, do we always annotate them as being “open” because those paradigms permit subclassing anywhere, or do you propose some kind of recommended “sealed” audit, or what?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 3:40 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;. Here&#39;s the first draft of the proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sealed classes by default<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt;&gt;&gt;&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt;&gt;&gt;&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt;&gt;&gt;&gt; sealed becomes the default for classes and methods.<br>&gt;&gt;&gt;&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Code Examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// ModuleA:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// This class is `sealed` by default.<br>&gt;&gt;&gt;&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt;&gt;&gt;&gt; class SealedParentClass {<br>&gt;&gt;&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;&gt;&gt;&gt;     /// level higher than that of its class.<br>&gt;&gt;&gt;&gt;     open func bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;&gt;&gt;&gt;     final func baz()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; open class OpenParentClass {<br>&gt;&gt;&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;&gt;&gt;&gt;     open func bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;&gt;&gt;&gt;     final func baz()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// The behavior of `final` classes remains unchanged.<br>&gt;&gt;&gt;&gt; final class FinalClass { }<br>&gt;&gt;&gt;&gt; /// ModuleB:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import ModuleA<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt;&gt;&gt;&gt; /// this module&#39;s point of view.<br>&gt;&gt;&gt;&gt; class SubclassA : SealedParentClass { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt;&gt;&gt;&gt; class SubclassB : OpenParentClass {<br>&gt;&gt;&gt;&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;&gt;&gt;&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;&gt;&gt;&gt;     override func foo() { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;&gt;&gt;&gt;     override func bar() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Javier Soto<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Javier Soto<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/855eb479/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt; <br>&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br></p><p>But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 4:55 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt;&gt; <br>&gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt; <br>&gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br></p><p>Typically you modify something open source - 99% of which is on GitHub. IMHO the best way is to either fork it and perhaps submit a pull request with the fix.<br></p><p>But I understand that this is not always possible...<br></p><p><br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>IMO the issue with the argument that we wouldn&#39;t be able to &quot;monkey patch&quot;<br>things on sealed classes is that that is already the nature of Swift. The<br>designer of an API can choose to use structs instead of classes, and then<br>there&#39;s already no way to &quot;subclass&quot;. Moreover, &quot;final&quot; already exists, and<br>whether sealed is introduced or not, and whether it becomes the default or<br>not, API designers are already free to use final in all classes they do not<br>intend to be subclassed, so I think that would be an argument against final<br>existing in the first place, and that ship has already sailed.<br></p><p>As for whether sealed would allow for optimizations: my hunch is that it<br>would. However, as I write this I noticed a flaw with my proposal: I said<br>that sealed classes would be exported as final. This is only half-true.<br>They would in that they can&#39;t be subclassed outside the module, but there<br>could be subclasses in the same module! That means if the parent were to be<br>treated as final, code outside the module would incorrectly devirtualize<br>non-final methods.<br>On Tue, Jun 28, 2016 at 7:59 AM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 28, 2016, at 4:55 PM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do<br>&gt; it in a clear structured fashion that is well designed for extensibility.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This sounds more like an argument for having sealed classes than not.<br>&gt; As the proposal points out in the motivation, if the base class is not<br>&gt; designed with subclassing in mind then overriding methods can result in<br>&gt; unintended behavior (e.g. crashing, or other bugs).<br>&gt; &gt;<br>&gt; &gt; But I think the counter argument is, what if you need to fix or<br>&gt; workaround unintended behavior of the class you’re trying to use?<br>&gt;<br>&gt; Typically you modify something open source - 99% of which is on GitHub.<br>&gt; IMHO the best way is to either fork it and perhaps submit a pull request<br>&gt; with the fix.<br>&gt;<br>&gt; But I understand that this is not always possible...<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/e8ea08eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 8:09 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; IMO the issue with the argument that we wouldn&#39;t be able to &quot;monkey patch&quot; things on sealed classes is that that is already the nature of Swift. The designer of an API can choose to use structs instead of classes, and then there&#39;s already no way to &quot;subclass&quot;. Moreover, &quot;final&quot; already exists, and whether sealed is introduced or not, and whether it becomes the default or not, API designers are already free to use final in all classes they do not intend to be subclassed, so I think that would be an argument against final existing in the first place, and that ship has already sailed. <br>&gt; <br>&gt; As for whether sealed would allow for optimizations: my hunch is that it would. However, as I write this I noticed a flaw with my proposal: I said that sealed classes would be exported as final. This is only half-true. They would in that they can&#39;t be subclassed outside the module, but there could be subclasses in the same module! That means if the parent were to be treated as final, code outside the module would incorrectly devirtualize non-final methods. <br></p><p>Also, note that:<br>  - we&#39;re clearly going to have to import ObjC classes as subclassable by default, and in fact there&#39;s currently no way to explicitly declare an ObjC class to be final;<br>  - many classes in ObjC are actually intended to be subclassed (although not every method is intended to be overridden), and those tend to be the classes that users most want to patch;<br>  - methods in ObjC can just be directly monkey-patched without subclassing, even if we&#39;re not necessarily happy about you doing it; and<br>  - even if we re-implemented a bunch of frameworks in Swift, we&#39;d still have to maintain compatibility with some amount of this stuff.<br></p><p>So I don&#39;t think that sealed-by-default would have any significant impact on the ability to patch Apple code as a third party.<br></p><p>For code that isn&#39;t deployed in an OS that won&#39;t be updated, the obviously better solution is to fix the library, either yourself or, if it&#39;s closed-source, through your normal vendor support process.<br></p><p>John.<br></p><p>&gt; On Tue, Jun 28, 2016 at 7:59 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jun 28, 2016, at 4:55 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt; &gt;<br>&gt; &gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br>&gt; <br>&gt; Typically you modify something open source - 99% of which is on GitHub. IMHO the best way is to either fork it and perhaps submit a pull request with the fix.<br>&gt; <br>&gt; But I understand that this is not always possible...<br>&gt; <br>&gt; <br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/2dac071d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:59 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 4:55 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt;&gt; <br>&gt;&gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br>&gt; <br>&gt; Typically you modify something open source - 99% of which is on GitHub. IMHO the best way is to either fork it and perhaps submit a pull request with the fix.<br>&gt; <br>&gt; But I understand that this is not always possible…<br></p><p>I agree that this is the best approach for open source dependencies.  If the authors of the library disagree with you about what the public API should be then perhaps it isn’t the right dependency for your project and you should either create your own fork or find another library to use.<br></p><p>That said, in the &quot;final by default” thread a lot of the discussion was about working around bugs in Apple’s closed source frameworks.  This line of argument isn’t really valid because changing the default in Swift won’t affect frameworks written in Objective-C and also because the default is unlikely to have a significant impact on Apple’s exposed API.  Apple will be free to use `sealed` even if they need to apply it manually and is very likely to do so as soon as they start writing frameworks in Swift and `sealed` is an option.<br></p><p>IMO the argument for introducing `sealed` and making it the default is roughly analogous to the argument for having an `internal` access level and making that the default: the author of a library should have tools to control what is and is not exposed as public API.  The ability to subclass is an API contract every bit as much as anything else.  The safe default is to require library authors to opt-in to all public API, thus avoiding &quot;accidentally public” API.  <br></p><p>As was noted in previous threads, making the contract more explicit and enforcing it is viewed by many as a good thing.  It prevents hackish workarounds which both facilitates framework evolution and also increases pressure on framework authors to fix their bugs in a timely manner.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/29bfcf72/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 4:59 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 4:55 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt;&gt; <br>&gt;&gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br>&gt; <br>&gt; Typically you modify something open source - 99% of which is on GitHub. IMHO the best way is to either fork it and perhaps submit a pull request with the fix.<br>&gt; <br>&gt; But I understand that this is not always possible...<br></p><p>I am a professional dev, and i rarely have the time (or even the legal right) to push back the changes i make to public code... the objc world is IMVHO very far from the professional open source culture that exists around other languages... so far the swift world is very embryonic. Sealing by default looks to me like a miss judgement of the maturity of the ecosystem.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>June 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 7:55 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt;&gt; <br>&gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt; <br>&gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br></p><p>Sure, I understand that, and I don’t mean to trivialize that concern. I’m just pointing out that “code…that is [not] well designed for extensibility”, might not  work very well if you start using extension points that weren’t well thought through.<br></p><p>If you are designing for extensibility you’ll be carefully thinking about what should and should not be final both within and outside of your module. Not doing so can result in bugs. This proposal introduces the ability to allow extension within the module but restrict it outside the module, and defaults to not allowing extension beyond the module.<br></p><p>You can argue both ways which default would be better, and I suspect people who mostly write libraries might opt for sealed-by-default, and people who mostly consume libraries might opt for open-by-default. My point is that open-by-default isn’t “better” because it allows you to potentially work around a problem in a base class, because by working around that problem by overriding a method that wasn’t designed to be overridden you don’t know how many other new problems you might be introducing (now or in the future if the implementation of the base class changes).<br></p><p>Mark<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 10:17 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 7:55 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt;&gt; <br>&gt;&gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br>&gt; <br>&gt; Sure, I understand that, and I don’t mean to trivialize that concern. I’m just pointing out that “code…that is [not] well designed for extensibility”, might not  work very well if you start using extension points that weren’t well thought through.<br>&gt; <br>&gt; If you are designing for extensibility you’ll be carefully thinking about what should and should not be final both within and outside of your module. Not doing so can result in bugs. This proposal introduces the ability to allow extension within the module but restrict it outside the module, and defaults to not allowing extension beyond the module.<br>&gt; <br>&gt; You can argue both ways which default would be better, and I suspect people who mostly write libraries might opt for sealed-by-default, and people who mostly consume libraries might opt for open-by-default. My point is that open-by-default isn’t “better” because it allows you to potentially work around a problem in a base class, because by working around that problem by overriding a method that wasn’t designed to be overridden you don’t know how many other new problems you might be introducing (now or in the future if the implementation of the base class changes).<br></p><p>I think a good argument for sealed by default is that if we introduce `sealed` responsible library authors will already be marking all classes not intended for external subclassing as either `sealed` or `final` anyway.   The intended (and hopefully actual) public  API will be identical regardless of the default.  Making it the default avoids a lot of boilerplate keywords and makes ensure the API contract is stated more explicitly.<br></p><p>The only case where the default should make a difference is when a library is written without consideration of subclasses.  As you point out, in that case it is a really bad idea to attempt to work around a bug with a subclass.<br></p><p>&gt; <br>&gt; Mark<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 5:24 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 10:17 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 7:55 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 28, 2016, at 9:52 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I think the counter argument is, what if you need to fix or workaround unintended behavior of the class you’re trying to use?<br>&gt;&gt; <br>&gt;&gt; Sure, I understand that, and I don’t mean to trivialize that concern. I’m just pointing out that “code…that is [not] well designed for extensibility”, might not  work very well if you start using extension points that weren’t well thought through.<br>&gt;&gt; <br>&gt;&gt; If you are designing for extensibility you’ll be carefully thinking about what should and should not be final both within and outside of your module.<br></p><p>We all think carefully about what we do... it just does not mean the same in regards to the outcome. It seems it is only in the software industry that we all think of ourselves as michelangelos or rubens.. unfortunately it takes a lot of errors to become humble about it.<br></p><p>&gt;&gt; Not doing so can result in bugs. This proposal introduces the ability to allow extension within the module but restrict it outside the module, and defaults to not allowing extension beyond the module.<br>&gt;&gt; <br>&gt;&gt; You can argue both ways which default would be better, and I suspect people who mostly write libraries might opt for sealed-by-default, and people who mostly consume libraries might opt for open-by-default. My point is that open-by-default isn’t “better” because it allows you to potentially work around a problem in a base class, because by working around that problem by overriding a method that wasn’t designed to be overridden you don’t know how many other new problems you might be introducing (now or in the future if the implementation of the base class changes).<br>&gt; <br>&gt; I think a good argument for sealed by default is that if we introduce `sealed` responsible library authors will already be marking all classes not intended for external subclassing as either `sealed` or `final` anyway.   The intended (and hopefully actual) public  API will be identical regardless of the default.  Making it the default avoids a lot of boilerplate keywords and makes ensure the API contract is stated more explicitly.<br>&gt; <br>&gt; The only case where the default should make a difference is when a library is written without consideration of subclasses.  As you point out, in that case it is a really bad idea to attempt to work around a bug with a subclass.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 28, 2016, at 4:52 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:10 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 for the fact that if all devs can write working code, fewer can do it in a clear structured fashion that is well designed for extensibility.<br>&gt; <br>&gt; This sounds more like an argument for having sealed classes than not. As the proposal points out in the motivation, if the base class is not designed with subclassing in mind then overriding methods can result in unintended behavior (e.g. crashing, or other bugs).<br>&gt; <br></p><p>The pb i am referencing is devs who think their code is designed for extension but ends up being awkward or incompletely so. In my exp this is true of lots of (most) libs, including prominent projects. I got this sense over the years that a lot if newb designers want to play gods by showing how well they can juggle the different levels of privacy/locking in a language to create great extensible codebases.. and after getting burned a few times by their inability to think holistically about all possible codepaths, they become more humble and write more straightforward code that in the end becomes more extensible.<br></p><p>Crashing because of me deciding to extend something not ready for should remain my responsibility, because in the end this is no different than my own code crashing because of my bugs. I think it should be everyone&#39;s responsibility to make sure we pay attention when drinking hot coffee, not the responsibility of mcDonald to write in caps on their cups that hot liquids tend to cause burns. <br></p><p>&gt; Mark<br>&gt; <br>&gt;&gt; A couple months ago I even ran into difficulties when trying to extend AlamoFire because some things had not been designed as cleanly as they could have been to make extending it easy. So if the default is now that everything becomes non-extensible but default, it is going to complicate (and partially defeat the purpose of) reusing libraries.<br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 2:11 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was also referring to how we present Objective-C classes in Swift. That is, if a Swift user tries to subclass an Objective-C-imported class, then we’d take into account sealed-ness in order to issue an error/warning, etc. If you are also proposing a Clang attribute for this, e.g. ‘swift_sealed’, to import as sealed (meaning issue an error if Swift users try to subclass it), then that should be spelled out as well. I don’t have an opinion on whether this is a good idea yet, just pointing out some more directions to explore. In general it feels like your proposal could use more fleshing out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 5:08 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is a very good point, it should be explicitly mentioned in the proposal. My thought would be that since in the Obj-C runtime it&#39;s not possible to guarantee a class won&#39;t have subclasses, or that a method is not overriden, Obj-C classes would be imported as open. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the Swift side, I think today it&#39;s possible to declare a &quot;public final @objc class&quot;, but you can still inherit from it from Obj-C, right? My hunch would be that that should be disallowed, but perhaps there&#39;s a reason why it&#39;s allowed today. <br>&gt;&gt;&gt;&gt; On Mon, Jun 27, 2016 at 4:25 PM Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Could you elaborate on how we should treat classes imported from Objective-C or CF-style C? That is, do we always annotate them as being “open” because those paradigms permit subclassing anywhere, or do you propose some kind of recommended “sealed” audit, or what?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 3:40 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I sent this as a PR on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago. Here&#39;s the first draft of the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sealed classes by default<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle.<br>&gt;&gt;&gt;&gt;&gt;&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt;&gt;&gt;&gt;&gt;&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt;&gt;&gt;&gt;&gt;&gt; sealed becomes the default for classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Code Examples:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// ModuleA:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// This class is `sealed` by default.<br>&gt;&gt;&gt;&gt;&gt;&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt;&gt;&gt;&gt;&gt;&gt; class SealedParentClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     /// level higher than that of its class.<br>&gt;&gt;&gt;&gt;&gt;&gt;     open func bar()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;&gt;&gt;&gt;&gt;&gt;     final func baz()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; open class OpenParentClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;     /// This method is `sealed` by default`.<br>&gt;&gt;&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;&gt;&gt;&gt;&gt;&gt;     open func bar()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;&gt;&gt;&gt;&gt;&gt;     final func baz()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// The behavior of `final` classes remains unchanged.<br>&gt;&gt;&gt;&gt;&gt;&gt; final class FinalClass { }<br>&gt;&gt;&gt;&gt;&gt;&gt; /// ModuleB:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt;&gt;&gt;&gt;&gt;&gt; /// this module&#39;s point of view.<br>&gt;&gt;&gt;&gt;&gt;&gt; class SubclassA : SealedParentClass { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt;&gt;&gt;&gt;&gt;&gt; class SubclassB : OpenParentClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;&gt;&gt;&gt;&gt;&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;&gt;&gt;&gt;&gt;&gt;     override func foo() { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;&gt;&gt;&gt;&gt;&gt;     override func bar() { }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Javier Soto<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Javier Soto<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/bc781795/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m a tentative +1, but I think we might consider a degree of &quot;sealing&quot;, e.g- make extending the type a warning rather than an error, or require an attribute in order to force the extension. In other words, we make it perfectly clear that extending anyway is a bad idea, but still allow it to be done in cases where code wasn&#39;t properly defined with this in mind. Perhaps we could consider something like sealed(warning) and sealed(error), with the former being the default?<br></p><p>&gt; On 27 Jun 2016, at 23:40, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello!<br>&gt; <br>&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;. Here&#39;s the first draft of the proposal:<br>&gt; <br>&gt; <br>&gt; Sealed classes by default<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;Introduction<br>&gt; <br>&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;Motivation<br>&gt; <br>&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt; sealed becomes the default for classes and methods.<br>&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Code Examples:<br>&gt; <br>&gt; /// ModuleA:<br>&gt; <br>&gt; /// This class is `sealed` by default.<br>&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt; class SealedParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;     /// level higher than that of its class.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; open class OpenParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; /// The behavior of `final` classes remains unchanged.<br>&gt; final class FinalClass { }<br>&gt; /// ModuleB:<br>&gt; <br>&gt; import ModuleA<br>&gt; <br>&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt; /// this module&#39;s point of view.<br>&gt; class SubclassA : SealedParentClass { }<br>&gt; <br>&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt; class SubclassB : OpenParentClass {<br>&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;     override func foo() { }<br>&gt; <br>&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;     override func bar() { }<br>&gt; }<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt; -- <br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/d359ee7c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>All bike-shedding aside, I see two parts of this proposal and I come down on different sides for the two.<br></p><p>1. Introducing a new class modifier that acts as final outside the defining module<br>2. Changing the default to this new modifier (and thus also introducing a third explicit class modifier that represents the current default (non-final) behavior.<br></p><p>I think that the behavior of the new proposed modifier is useful. I imagine that it would allow for the same type of optimizations as a final class (assuming whole module optimizations) while remaining flexible within the module itself. We’re currently using a public protocol with one or more internal non-final classes to achieve similar results in the specific scenario where we want a unified external type. <br></p><p>On the topic of changing the default, I’m against for the same reasons that was brought up in the discussion of making final the default. Since those reasons were mostly about usage outside of the same module, I find them equally valid in this case.<br></p><p>- David<br></p><p><br>&gt; On 28 Jun 2016, at 00:40, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello!<br>&gt; <br>&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;. Here&#39;s the first draft of the proposal:<br>&gt; <br>&gt; <br>&gt; Sealed classes by default<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;Introduction<br>&gt; <br>&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;Motivation<br>&gt; <br>&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt; sealed becomes the default for classes and methods.<br>&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Code Examples:<br>&gt; <br>&gt; /// ModuleA:<br>&gt; <br>&gt; /// This class is `sealed` by default.<br>&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt; class SealedParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;     /// level higher than that of its class.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; open class OpenParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; /// The behavior of `final` classes remains unchanged.<br>&gt; final class FinalClass { }<br>&gt; /// ModuleB:<br>&gt; <br>&gt; import ModuleA<br>&gt; <br>&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt; /// this module&#39;s point of view.<br>&gt; class SubclassA : SealedParentClass { }<br>&gt; <br>&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt; class SubclassB : OpenParentClass {<br>&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;     override func foo() { }<br>&gt; <br>&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;     override func bar() { }<br>&gt; }<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt; -- <br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/27ca169f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>+1 for the concept of a &quot;sealed” class.<br>-1 for making it default.<br></p><p>Would there be a benefit to having “sealed&quot; protocols, as well?<br></p><p>- Dave Sweeris<br></p><p>On Jun 27, 2016, at 17:40, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; Hello!<br>&gt; <br>&gt; I sent this as a PR &lt;https://github.com/apple/swift-evolution/pull/376&gt; on the swift-evolution repo, but we never had any discussion about it on-list, besides a long time ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/9702/focus=9708&gt;. Here&#39;s the first draft of the proposal:<br>&gt; <br>&gt; <br>&gt; Sealed classes by default<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#introduction&gt;Introduction<br>&gt; <br>&gt; Introduce a new sealed class modifier that makes classes and methods final outside of the module they&#39;re declared in, but non-final within the module.<br>&gt; <br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#motivation&gt;Motivation<br>&gt; <br>&gt; It is not uncommon to have a need for a reference type without needing inheritance. Classes must be intentionally designed to be subclassable, carefully deciding which methods are the override entry-points such that the the behavior remains correct and subclasses respect the Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt;.<br>&gt; Defaulting to non-final allows the author of a class to accidentally leave the visible methods open for overrides, even if they didn&#39;t carefully consider this possibility.<br>&gt; Requiring that the author of a class mark a class as open is akin to requiring symbols to be explicitly public: it ensures that a conscious decision is made regarding whether the ability to subclass a class is part of the API.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; New sealed (actual name pending bike-shedding) class modifier for classes and methods which marks them as only overridable within the module they&#39;re declared in.<br>&gt; sealed becomes the default for classes and methods.<br>&gt; New open (actual name pending bike-shedding) class modifier to explicitly mark a class or a method as overridable.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Code Examples:<br>&gt; <br>&gt; /// ModuleA:<br>&gt; <br>&gt; /// This class is `sealed` by default.<br>&gt; /// This is equivalent to `sealed class SealedParentClass`<br>&gt; class SealedParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// This raises a compilation error: a method can&#39;t have a &quot;subclassability&quot;<br>&gt;     /// level higher than that of its class.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of `final` methods remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; open class OpenParentClass {<br>&gt;     /// This method is `sealed` by default`.<br>&gt;     func foo()<br>&gt; <br>&gt;     /// Overridable methods in an `open` class must be explicitly marked as `open`.<br>&gt;     open func bar()<br>&gt; <br>&gt;     /// The behavior of a `final` method remains unchanged.<br>&gt;     final func baz()<br>&gt; }<br>&gt; <br>&gt; /// The behavior of `final` classes remains unchanged.<br>&gt; final class FinalClass { }<br>&gt; /// ModuleB:<br>&gt; <br>&gt; import ModuleA<br>&gt; <br>&gt; /// This raises a compilation error: ParentClass is effectively `final` from<br>&gt; /// this module&#39;s point of view.<br>&gt; class SubclassA : SealedParentClass { }<br>&gt; <br>&gt; /// This is allowed since `OpenParentClass` has been marked explicitly `open`<br>&gt; class SubclassB : OpenParentClass {<br>&gt;     /// This raises a compilation error: `OpenParentClass.foo` is<br>&gt;     /// effectively `final` outside of `ModuleA`.<br>&gt;     override func foo() { }<br>&gt; <br>&gt;     /// This is allowed since `OpenParentClass.bar` is explicitly `open`.<br>&gt;     override func bar() { }<br>&gt; }<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This would be a backwards-breaking change for all classes and methods that are public and non-final, which code outside of their module has overriden. Those classes/methods would fail to compile. Their superclass would need to be changed to open.<br>&gt;  &lt;https://github.com/JaviSoto/swift-evolution/blob/a46877afb0302d2b03fa493255f5ced04ccb7f34/proposals/0000-sealed-by-default.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Defaulting to final instead: This would be comparable to Swift defaulting to private, as opposed to internal. Just like internal is a better trade-off, sealed by default also makes sure that getting started with Swift, writing code within a module, doesn&#39;t require a lot of boilerplate, and fighting against the compiler.<br>&gt; -- <br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/d8735538/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; +1 for the concept of a &quot;sealed” class.<br>&gt; -1 for making it default.<br></p><p>Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>So there is nothing left to do :)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt; -1 for making it default.<br>&gt; <br>&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt; So there is nothing left to do :)<br></p><p>Sealed and final are very different.  Sealed allows subclasses *within the declaring module* but final does not allow any subclasses at all.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt; -1 for making it default.<br>&gt; <br>&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt; So there is nothing left to do :)<br></p><p>No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Do we really need a new keyword? Since we already have syntax like<br>`internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br></p><p>On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;<br>&gt; michael.peternell at gmx.at&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt; &gt;&gt; -1 for making it default.<br>&gt; &gt;<br>&gt; &gt; Aren&#39;t sealed classes already implemented? I think the keyword is<br>&gt; `final`..<br>&gt; &gt; So there is nothing left to do :)<br>&gt;<br>&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for<br>&gt; subclassing within your module (where you can presumably write more<br>&gt; efficient code based on knowledge of each subclass).<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/5d4e5181/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 11:11 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br></p><p>The spelling is definitely up for debate.  I remember that Chris in particular wasn&#39;t happy with &quot;sealed&quot;.<br></p><p>(Of course the entire proposal is still up for debate; I&#39;m just saying that so far we&#39;ve been talking about the proposal at a high level with very little attention to specifics.)<br></p><p>John.<br></p><p><br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at &lt;mailto:michael.peternell at gmx.at&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt; &gt;&gt; -1 for making it default.<br>&gt; &gt;<br>&gt; &gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt; &gt; So there is nothing left to do :)<br>&gt; <br>&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/9c54f2e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>I like `closed` better because it would pair up nicely with `opened`<br></p><p>`opened` would be a good keyword imo (applying the ing/ed rule). <br></p><p>In the future if we ever support open enums, we could use the same keyword. :) <br></p><p><br></p><p>&gt; On Jun 29, 2016, at 11:16 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 11:11 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt; <br>&gt; The spelling is definitely up for debate.  I remember that Chris in particular wasn&#39;t happy with &quot;sealed&quot;.<br>&gt; <br>&gt; (Of course the entire proposal is still up for debate; I&#39;m just saying that so far we&#39;ve been talking about the proposal at a high level with very little attention to specifics.)<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at &lt;mailto:michael.peternell at gmx.at&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt; &gt;&gt; -1 for making it default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt; &gt; So there is nothing left to do :)<br>&gt;&gt; <br>&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/53427a91/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br></p><p>-Michael<br></p><p>&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt; &gt;&gt; -1 for making it default.<br>&gt; &gt;<br>&gt; &gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt; &gt; So there is nothing left to do :)<br>&gt; <br>&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br></p><p>Right.<br></p><p>If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br></p><p>To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br></p><p>&quot;communal&quot;? :)<br></p><p>&quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br></p><p>John.<br></p><p><br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt; <br>&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 29, 2016 at 09:00:00pm</p></header><div class="content"><p>How about `public(extensible)` ?<br></p><p>On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;<br>&gt; Right.<br>&gt;<br>&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;<br>&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;<br>&gt; &quot;communal&quot;? :)<br>&gt;<br>&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -Michael<br>&gt;&gt;<br>&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br></p><p>`sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br></p><p>And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br></p><p>-Michael<br></p><p>&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; How about `public(extensible)` ?<br>&gt; <br>&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt; <br>&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt; <br>&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt; <br>&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 29, 2016 at 10:00:00pm</p></header><div class="content"><p>On 29.06.2016 22:05, Michael Peternell wrote:<br>&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really<br>&gt; looks like premature optimization to me. Instead there should be some<br>&gt; `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone<br>&gt; will understand!<br></p><p>I understand your point of view. But I also think about the proposal as <br>forcing the developer of public(! i.e. usually which exported from some <br>framework) to carefully think if he/she really wants to allow exported <br>types will be extensible. Not just about performance.<br></p><p>And as was mentioned, &#39;sealed&#39; is not &#39;final&#39; : you can extend the sealed <br>type in internal scope, but it will be final for public scope. (If I don&#39;t <br>miss something)<br></p><p>But, yes, I&#39;m also not sure if we should seal by default and not introduce <br>`public(final)` or `public(sealed)` access modifier for those who <br>explicitly don&#39;t want to allow extension of exported class.<br></p><p>&gt;<br>&gt; `sealed` classes should be a special optimization used by optimizing<br>&gt; developers who ask for it. Don&#39;t make it an unwanted and un-asked-for<br>&gt; default optimization. The people who care for optimization much will<br>&gt; learn about `sealed` and be able to apply the concept in both cases. The<br>&gt; people who don&#39;t care about performance will just be disappointed by the<br>&gt; &quot;implicitly sealed&quot; behavior. And with this proposal, when I read<br>&gt; `unsealed` I can never know: &quot;did this developer intend me to be able to<br>&gt; subclass this class? or did he just not want to restrict me<br>&gt; unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;<br>&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch<br>&gt; lies in final classes or final methods. Sealing everything by default<br>&gt; just marks many classes and methods as implicitly final (because it can<br>&gt; be proven that they are not subclassed). I just don&#39;t think that all<br>&gt; these theoretical performance improvements are really worth the trouble<br>&gt; in practice.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;<br>&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via<br>&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote: Do you mean<br>&gt;&gt;&gt;&gt; `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really<br>&gt;&gt;&gt;&gt; make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods —<br>&gt;&gt;&gt; and I don&#39;t think the modifier is worth adding unless it&#39;s the<br>&gt;&gt;&gt; default — then we need a way of &quot;unsealing&quot; classes and methods<br>&gt;&gt;&gt; that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good<br>&gt;&gt;&gt; enough for that.  And we should try to make the positive form (&quot;can<br>&gt;&gt;&gt; be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;),<br>&gt;&gt;&gt; because the latter will not usually be written.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If<br>&gt;&gt;&gt; it does have to be stacked with &quot;public&quot;, then I think it ought to<br>&gt;&gt;&gt; be pretty short.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to<br>&gt;&gt;&gt; be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax<br>&gt;&gt;&gt;&gt;&gt; like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via<br>&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class. -1 for making it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword<br>&gt;&gt;&gt;&gt;&gt;&gt; is `final`.. So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed`<br>&gt;&gt;&gt;&gt;&gt; allows for subclassing within your module (where you can<br>&gt;&gt;&gt;&gt;&gt; presumably write more efficient code based on knowledge of each<br>&gt;&gt;&gt;&gt;&gt; subclass).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 12:05 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt; <br>&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt; <br>&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br></p><p>I&#39;m confused about why you think this is so much of a problem.  Do you really anticipate writing so many Swift libraries with public classes?<br></p><p>John.<br></p><p>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt; <br>&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 30, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>On Jun 29, 2016, at 9:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 12:05 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt; <br>&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt; <br>&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt; <br>&gt; I&#39;m confused about why you think this is so much of a problem.  Do you really anticipate writing so many Swift libraries with public classes?<br>&gt; <br></p><p>Look at some of the public libs on github for server side swift.. one recently claimed 50 modules and counting... I think swift is missing a level of containment below modules, and people are starting to make up for it by creating a flury of (1class+1protocol) modules, especially now that package manager makes it so trivial to create them. I think this is only the begining... and nodejs is there to show how insane it could become:  remember the recent &quot;trimleft&quot; nightmare (1 module with 15 LOC including brackets used pervasively that suddenly disapears).<br></p><p><br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:27 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Jun 29, 2016, at 9:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 12:05 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt;&gt; <br>&gt;&gt; I&#39;m confused about why you think this is so much of a problem.  Do you really anticipate writing so many Swift libraries with public classes?<br>&gt;&gt; <br>&gt; <br>&gt; Look at some of the public libs on github for server side swift.. one recently claimed 50 modules and counting... I think swift is missing a level of containment below modules, and people are starting to make up for it by creating a flury of (1class+1protocol) modules, especially now that package manager makes it so trivial to create them. I think this is only the begining... and nodejs is there to show how insane it could become:  remember the recent &quot;trimleft&quot; nightmare (1 module with 15 LOC including brackets used pervasively that suddenly disapears).<br></p><p>I&#39;m not arguing that there aren&#39;t going to be a lot of libraries.  We&#39;re all excited about the number of libraries.  Libraries are great.  I&#39;m trying to understand whether the objections here — which only matter on library boundaries — are motivated by any concrete experience writing such libraries in Swift.<br></p><p>Michael&#39;s argument was that sealed-by-default will be a major problem for those libraries and their users.  Let&#39;s suppose that there&#39;s a library with a public class, and it&#39;s sealed by default.  We can conclude that the author has never once tried to subclass this class outside of their library, because if they had, they would have gotten a compiler error.  Therefore, at best, if I hack the library to allow subclasses, I&#39;m going to be doing something that has never once been tested and certainly was not considered when the class was written.  It&#39;s pretty clear that this is not the developer&#39;s intent.<br></p><p>Likewise, it&#39;s not true that &quot;the documenting aspect of `unsealed` is so small&quot;.  Under sealed-by-default, the developer has to make a conscious, deliberate step to allow subclasses outside of their library.  They clearly do intend for you to be able to subclass this class.  It&#39;s actually the reverse situation where the user doesn&#39;t know how to interpret the code, because under unsealed-by-default, they can&#39;t know whether the class is really intended to be subclassed or whether they just forgot to add the restriction.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  2, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>On Jun 30, 2016, at 9:12 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 10:27 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 9:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:05 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m confused about why you think this is so much of a problem.  Do you really anticipate writing so many Swift libraries with public classes?<br>&gt;&gt; <br>&gt;&gt; Look at some of the public libs on github for server side swift.. one recently claimed 50 modules and counting... I think swift is missing a level of containment below modules, and people are starting to make up for it by creating a flury of (1class+1protocol) modules, especially now that package manager makes it so trivial to create them. I think this is only the begining... and nodejs is there to show how insane it could become:  remember the recent &quot;trimleft&quot; nightmare (1 module with 15 LOC including brackets used pervasively that suddenly disapears).<br>&gt; <br>&gt; I&#39;m not arguing that there aren&#39;t going to be a lot of libraries.  We&#39;re all excited about the number of libraries.  Libraries are great.  <br></p><p>The issue is that according to this year&#39;s very interesting talk on perf is that an app&#39;s startup time can get thrown over the limit by having to perform too much relocation during dylib loading. I doubt too many will actually pay attention (i just started a nodejs app a couple days ago and before it did anything, bringing in angular and a few other dependencies downloaded 168M in over 60 modules)<br></p><p>&gt; I&#39;m trying to understand whether the objections here — which only matter on library boundaries — are motivated by any concrete experience writing such libraries in Swift.<br>&gt; <br>&gt; Michael&#39;s argument was that sealed-by-default will be a major problem for those libraries and their users.  Let&#39;s suppose that there&#39;s a library with a public class, and it&#39;s sealed by default.  We can conclude that the author has never once tried to subclass this class outside of their library, because if they had, they would have gotten a compiler error.  Therefore, at best, if I hack the library to allow subclasses, I&#39;m going to be doing something that has never once been tested and certainly was not considered when the class was written.  It&#39;s pretty clear that this is not the developer&#39;s intent.<br></p><p>I think that you r considering an already sophisticated developer to whom you attribute the thought of &#39;whats it gonna be to use my code&#39;. compared to the real life i know. That said I spent some time thinking about your arguments and I guess i can live with sealed (<br></p><p>&gt; Likewise, it&#39;s not true that &quot;the documenting aspect of `unsealed` is so small&quot;.  Under sealed-by-default, the developer has to make a conscious, deliberate step to allow subclasses outside of their library.  They clearly do intend for you to be able to subclass this class.  It&#39;s actually the reverse situation where the user doesn&#39;t know how to interpret the code,<br></p><p>I believe most devs are not able to accurately predict what their code does and will allow to do be done. Over the last 20 years i have usually seen the most creative solutions being found despite what the original library writers did, but it is just my personal exp. i would prefer a world without forking dependencies, but... <br></p><p>But i think you best argument is that idiomatic swift should not rely on classes as much as other languages. So in the end, the applicability will become more limited as we learn to write better swift over time. I think you are right. :)<br></p><p>&gt; because under unsealed-by-default, they can&#39;t know whether the class is really intended to be subclassed or whether they just forgot to add the restriction.<br>&gt; <br>&gt; John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 10:58 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 30, 2016, at 9:12 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 10:27 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 9:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:05 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m confused about why you think this is so much of a problem.  Do you really anticipate writing so many Swift libraries with public classes?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Look at some of the public libs on github for server side swift.. one recently claimed 50 modules and counting... I think swift is missing a level of containment below modules, and people are starting to make up for it by creating a flury of (1class+1protocol) modules, especially now that package manager makes it so trivial to create them. I think this is only the begining... and nodejs is there to show how insane it could become:  remember the recent &quot;trimleft&quot; nightmare (1 module with 15 LOC including brackets used pervasively that suddenly disapears).<br>&gt;&gt; <br>&gt;&gt; I&#39;m not arguing that there aren&#39;t going to be a lot of libraries.  We&#39;re all excited about the number of libraries.  Libraries are great.  <br>&gt; <br>&gt; The issue is that according to this year&#39;s very interesting talk on perf is that an app&#39;s startup time can get thrown over the limit by having to perform too much relocation during dylib loading. I doubt too many will actually pay attention (i just started a nodejs app a couple days ago and before it did anything, bringing in angular and a few other dependencies downloaded 168M in over 60 modules)<br></p><p>I&#39;m referring to libraries as a tool for code organization.  Right now, some of the build tooling around Swift assumes that libraries have to be built as a separate dynamic library, and I agree that that&#39;s really unfortunate.<br></p><p>&gt;&gt; I&#39;m trying to understand whether the objections here — which only matter on library boundaries — are motivated by any concrete experience writing such libraries in Swift.<br>&gt;&gt; <br>&gt;&gt; Michael&#39;s argument was that sealed-by-default will be a major problem for those libraries and their users.  Let&#39;s suppose that there&#39;s a library with a public class, and it&#39;s sealed by default.  We can conclude that the author has never once tried to subclass this class outside of their library, because if they had, they would have gotten a compiler error.  Therefore, at best, if I hack the library to allow subclasses, I&#39;m going to be doing something that has never once been tested and certainly was not considered when the class was written.  It&#39;s pretty clear that this is not the developer&#39;s intent.<br>&gt; <br>&gt; I think that you r considering an already sophisticated developer to whom you attribute the thought of &#39;whats it gonna be to use my code&#39;. compared to the real life i know. That said I spent some time thinking about your arguments and I guess i can live with sealed (<br></p><p>Okay.  I think this has been a really productive conversation, and it&#39;s definitely made the proposal better, thank you.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; Likewise, it&#39;s not true that &quot;the documenting aspect of `unsealed` is so small&quot;.  Under sealed-by-default, the developer has to make a conscious, deliberate step to allow subclasses outside of their library.  They clearly do intend for you to be able to subclass this class.  It&#39;s actually the reverse situation where the user doesn&#39;t know how to interpret the code,<br>&gt; <br>&gt; I believe most devs are not able to accurately predict what their code does and will allow to do be done. Over the last 20 years i have usually seen the most creative solutions being found despite what the original library writers did, but it is just my personal exp. i would prefer a world without forking dependencies, but... <br>&gt; <br>&gt; But i think you best argument is that idiomatic swift should not rely on classes as much as other languages. So in the end, the applicability will become more limited as we learn to write better swift over time. I think you are right. :)<br>&gt; <br>&gt;&gt; because under unsealed-by-default, they can&#39;t know whether the class is really intended to be subclassed or whether they just forgot to add the restriction.<br>&gt;&gt; <br>&gt;&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/fa85db7e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>June 30, 2016 at 08:00:00am</p></header><div class="content"><p>From my understanding, &quot;Sealed&quot; or whatever we will call it technically provides no actual optimisations. We cannot assume the class is final because something inside the module may have vended a subclass.<br></p><p>The issue that &quot;sealed&quot; as a concept fills is that you stop people from subclassing types that were never specifically designed for subclassing, but allows the module to do some subclassing for its own needs because the developer understands how the class works.<br></p><p>It also means a developer of the framework can retroactively apply &quot;Final&quot; to the class if they&#39;ve worked out it actually should be final and will never be subclass. If the concept of Sealed did not exist, then a framework could never finalise a class down the track - users of the framework may have subclassed the type, and now the framework is hamstrung by its previous &quot;openness&quot;.<br></p><p>Should this be the default? In my opinion, yes.  Allowing subclassing to other clients should be explicit. It will tie you down and limit you from developing into the future. Allowing subclasses from other clients is a promise for the life of your product, and cannot be reneged. On classes that are not designed for subclassing, this is ill advised, and on classes you wish to optimise, it&#39;s a permanent limitation.<br></p><p>While I fear the abuse framework vendors will exercise, by allowing clever private hacks, and disallowing obj-c style workarounds, I think the safety and longevity of this approach is far more important.<br></p><p>+1 to the concept. I agree &quot;sealed&quot; is not foot wording and can be improved.<br></p><p>- Rod Brown<br></p><p>&gt; On 30 Jun. 2016, at 5:05 am, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt; <br>&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt; <br>&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt; <br>&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 3:45 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From my understanding, &quot;Sealed&quot; or whatever we will call it technically provides no actual optimisations. We cannot assume the class is final because something inside the module may have vended a subclass.<br></p><p>It can enable optimization when compiling with -whole-module-optimization since we know all the subclasses defined within the module. For any call site where the static type and all subclasses are sealed, we can limit the set of potential callees to only the functions defined in those types. Further, if the static type at the callsite has no subclasses, we can treat it like final and devirtualize the call.<br></p><p>Mark<br></p><p>&gt; <br>&gt; The issue that &quot;sealed&quot; as a concept fills is that you stop people from subclassing types that were never specifically designed for subclassing, but allows the module to do some subclassing for its own needs because the developer understands how the class works.<br>&gt; <br>&gt; It also means a developer of the framework can retroactively apply &quot;Final&quot; to the class if they&#39;ve worked out it actually should be final and will never be subclass. If the concept of Sealed did not exist, then a framework could never finalise a class down the track - users of the framework may have subclassed the type, and now the framework is hamstrung by its previous &quot;openness&quot;.<br>&gt; <br>&gt; Should this be the default? In my opinion, yes.  Allowing subclassing to other clients should be explicit. It will tie you down and limit you from developing into the future. Allowing subclasses from other clients is a promise for the life of your product, and cannot be reneged. On classes that are not designed for subclassing, this is ill advised, and on classes you wish to optimise, it&#39;s a permanent limitation.<br>&gt; <br>&gt; While I fear the abuse framework vendors will exercise, by allowing clever private hacks, and disallowing obj-c style workarounds, I think the safety and longevity of this approach is far more important.<br>&gt; <br>&gt; +1 to the concept. I agree &quot;sealed&quot; is not foot wording and can be improved.<br>&gt; <br>&gt; - Rod Brown<br>&gt; <br>&gt;&gt; On 30 Jun. 2016, at 5:05 am, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt; <br>&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt; <br>&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:56 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 3:45 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From my understanding, &quot;Sealed&quot; or whatever we will call it technically provides no actual optimisations. We cannot assume the class is final because something inside the module may have vended a subclass.<br>&gt; <br>&gt; It can enable optimization when compiling with -whole-module-optimization since we know all the subclasses defined within the module. For any call site where the static type and all subclasses are sealed, we can limit the set of potential callees to only the functions defined in those types. Further, if the static type at the callsite has no subclasses, we can treat it like final and devirtualize the call.<br></p><p>There are other interesting things that you can do when you know a class isn’t public inheritable.  For example, I am planning a proposal (after Swift 3) for exhaustive pattern matching on classes that are not publicly inheritable.  <br></p><p>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The issue that &quot;sealed&quot; as a concept fills is that you stop people from subclassing types that were never specifically designed for subclassing, but allows the module to do some subclassing for its own needs because the developer understands how the class works.<br>&gt;&gt; <br>&gt;&gt; It also means a developer of the framework can retroactively apply &quot;Final&quot; to the class if they&#39;ve worked out it actually should be final and will never be subclass. If the concept of Sealed did not exist, then a framework could never finalise a class down the track - users of the framework may have subclassed the type, and now the framework is hamstrung by its previous &quot;openness&quot;.<br>&gt;&gt; <br>&gt;&gt; Should this be the default? In my opinion, yes.  Allowing subclassing to other clients should be explicit. It will tie you down and limit you from developing into the future. Allowing subclasses from other clients is a promise for the life of your product, and cannot be reneged. On classes that are not designed for subclassing, this is ill advised, and on classes you wish to optimise, it&#39;s a permanent limitation.<br>&gt;&gt; <br>&gt;&gt; While I fear the abuse framework vendors will exercise, by allowing clever private hacks, and disallowing obj-c style workarounds, I think the safety and longevity of this approach is far more important.<br>&gt;&gt; <br>&gt;&gt; +1 to the concept. I agree &quot;sealed&quot; is not foot wording and can be improved.<br>&gt;&gt; <br>&gt;&gt; - Rod Brown<br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun. 2016, at 5:05 am, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/e3401623/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:05 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 29, 2016, at 5:56 PM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 3:45 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From my understanding, &quot;Sealed&quot; or whatever we will call it technically provides no actual optimisations. We cannot assume the class is final because something inside the module may have vended a subclass.<br>&gt;&gt; <br>&gt;&gt; It can enable optimization when compiling with -whole-module-optimization since we know all the subclasses defined within the module. For any call site where the static type and all subclasses are sealed, we can limit the set of potential callees to only the functions defined in those types. Further, if the static type at the callsite has no subclasses, we can treat it like final and devirtualize the call.<br>&gt; <br>&gt; There are other interesting things that you can do when you know a class isn’t public inheritable.  For example, I am planning a proposal (after Swift 3) for exhaustive pattern matching on classes that are not publicly inheritable.  <br></p><p>Yes, there are a number of things in this category.  For example, there&#39;s a fair amount of pedantry around class initializers that we could significantly weaken if we&#39;re certain we know about all the subclasses.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The issue that &quot;sealed&quot; as a concept fills is that you stop people from subclassing types that were never specifically designed for subclassing, but allows the module to do some subclassing for its own needs because the developer understands how the class works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It also means a developer of the framework can retroactively apply &quot;Final&quot; to the class if they&#39;ve worked out it actually should be final and will never be subclass. If the concept of Sealed did not exist, then a framework could never finalise a class down the track - users of the framework may have subclassed the type, and now the framework is hamstrung by its previous &quot;openness&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should this be the default? In my opinion, yes.  Allowing subclassing to other clients should be explicit. It will tie you down and limit you from developing into the future. Allowing subclasses from other clients is a promise for the life of your product, and cannot be reneged. On classes that are not designed for subclassing, this is ill advised, and on classes you wish to optimise, it&#39;s a permanent limitation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I fear the abuse framework vendors will exercise, by allowing clever private hacks, and disallowing obj-c style workarounds, I think the safety and longevity of this approach is far more important.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to the concept. I agree &quot;sealed&quot; is not foot wording and can be improved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rod Brown<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Jun. 2016, at 5:05 am, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m still unhappy about this &quot;sealed by default&quot; proposal. That really looks like premature optimization to me. Instead there should be some `sealed` keyword. Maybe it should be called `applepublic` :-p Everyone will understand!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `sealed` classes should be a special optimization used by optimizing developers who ask for it. Don&#39;t make it an unwanted and un-asked-for default optimization. The people who care for optimization much will learn about `sealed` and be able to apply the concept in both cases. The people who don&#39;t care about performance will just be disappointed by the &quot;implicitly sealed&quot; behavior. And with this proposal, when I read `unsealed` I can never know: &quot;did this developer intend me to be able to subclass this class? or did he just not want to restrict me unnecessarily?&quot; The documenting aspect of `unsealed` is so small.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And `sealed` is just an optimization; IMHO the magic of static dispatch lies in final classes or final methods. Sealing everything by default just marks many classes and methods as implicitly final (because it can be proven that they are not subclassed). I just don&#39;t think that all these theoretical performance improvements are really worth the trouble in practice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:39 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at &lt;mailto:michael.peternell at gmx.at&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/7462f6bf/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 29, 2016, at 17:45, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From my understanding, &quot;Sealed&quot; or whatever we will call it technically provides no actual optimisations. We cannot assume the class is final because something inside the module may have vended a subclass.<br></p><p>Sure we can. Because the class is sealed, the compiler can know that no further subclassing is possible, which can allowing it to use static dispatch, inlining, etc wherever possible.<br></p><p>I think...<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 6:05 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 17:45, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From my understanding, &quot;Sealed&quot; or whatever we will call it technically provides no actual optimisations. We cannot assume the class is final because something inside the module may have vended a subclass.<br>&gt; <br>&gt; Sure we can. Because the class is sealed, the compiler can know that no further subclassing is possible, which can allowing it to use static dispatch, inlining, etc wherever possible.<br></p><p>The compiler knows that subclasses cannot happen outside the module, but if subclasses exist within the module there will be many cases where the compiler won’t be able to devirtualize.<br></p><p>&gt; <br>&gt; I think...<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; How about `public(extensible)` ?<br></p><p>Hmm.  I started to work out an example with these as separate modifiers, and I think I understand the need to combine them in some way.<br></p><p>I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s used in API descriptions.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 29, 2016, at 2:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; How about `public(extensible)` ?<br>&gt; <br>&gt; Hmm.  I started to work out an example with these as separate modifiers, and I think I understand the need to combine them in some way.<br>&gt; <br>&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s used in API descriptions.<br></p><p>&#39;extensible&#39; is a broad term.  That has both advantages and disadvantages.  <br></p><p>An advantage is that it can be used to mean both &#39;subclassable&#39; / &#39;inheritable&#39; as well as &#39;overridable&#39;.  This would allow us to use a single keyword, while sealing methods by default in &#39;extensible&#39; classes.  <br></p><p>A disadvantage is that is isn&#39;t immediately clear what kind of extensibility is provided - you just have to know what the keyword means in a specific context.<br></p><p>Perhaps a larger disadvantage is that &#39;extensible&#39; shares a root with &#39;extension&#39; and all public classes are open to extension in Swift.  <br></p><p>-Matthew<br></p><p>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 2:54 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt; How about `public(extensible)` ?<br>&gt;<br>&gt; Hmm.  I started to work out an example with these as separate modifiers,<br>&gt; and I think I understand the need to combine them in some way.<br>&gt;<br>&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s<br>&gt; used in API descriptions.<br>&gt;<br></p><p>This particular word is unfortunate because it has nothing to do with an<br>extension, which shares the same etymological root.<br></p><p><br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/62d5b163/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 1:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Wed, Jun 29, 2016 at 2:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; &gt; How about `public(extensible)` ?<br>&gt; <br>&gt; Hmm.  I started to work out an example with these as separate modifiers, and I think I understand the need to combine them in some way.<br>&gt; <br>&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s used in API descriptions.<br>&gt; <br>&gt; This particular word is unfortunate because it has nothing to do with an extension, which shares the same etymological root.<br></p><p>I agree, but I&#39;m not sure that it&#39;s particularly confusing in practice.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/e599fc3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 3:36 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Jun 29, 2016, at 1:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Wed, Jun 29, 2016 at 2:54 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; &gt; How about `public(extensible)` ?<br>&gt;&gt;<br>&gt;&gt; Hmm.  I started to work out an example with these as separate modifiers,<br>&gt;&gt; and I think I understand the need to combine them in some way.<br>&gt;&gt;<br>&gt;&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s<br>&gt;&gt; used in API descriptions.<br>&gt;&gt;<br>&gt;<br>&gt; This particular word is unfortunate because it has nothing to do with an<br>&gt; extension, which shares the same etymological root.<br>&gt;<br>&gt;<br>&gt; I agree, but I&#39;m not sure that it&#39;s particularly confusing in practice.<br>&gt;<br></p><p>Why not just &quot;inheritable&quot;? That is, after all, what we mean, no?<br></p><p>John.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/412e2cd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 1:44 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Jun 30, 2016 at 3:36 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 29, 2016, at 1:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On Wed, Jun 29, 2016 at 2:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt; How about `public(extensible)` ?<br>&gt;&gt; <br>&gt;&gt; Hmm.  I started to work out an example with these as separate modifiers, and I think I understand the need to combine them in some way.<br>&gt;&gt; <br>&gt;&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s used in API descriptions.<br>&gt;&gt; <br>&gt;&gt; This particular word is unfortunate because it has nothing to do with an extension, which shares the same etymological root.<br>&gt; <br>&gt; I agree, but I&#39;m not sure that it&#39;s particularly confusing in practice.<br>&gt;  <br>&gt; Why not just &quot;inheritable&quot;? That is, after all, what we mean, no?<br></p><p>All class methods are intrinsically inheritable.  A non-inheritable method would *require* an override.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/9f35c47e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 3:47 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Jun 30, 2016, at 1:44 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Jun 30, 2016 at 3:36 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 29, 2016, at 1:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; On Wed, Jun 29, 2016 at 2:54 PM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt; How about `public(extensible)` ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hmm.  I started to work out an example with these as separate modifiers,<br>&gt;&gt;&gt; and I think I understand the need to combine them in some way.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s<br>&gt;&gt;&gt; used in API descriptions.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This particular word is unfortunate because it has nothing to do with an<br>&gt;&gt; extension, which shares the same etymological root.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree, but I&#39;m not sure that it&#39;s particularly confusing in practice.<br>&gt;&gt;<br>&gt;<br>&gt; Why not just &quot;inheritable&quot;? That is, after all, what we mean, no?<br>&gt;<br>&gt;<br>&gt; All class methods are intrinsically inheritable.  A non-inheritable method<br>&gt; would *require* an override.<br>&gt;<br></p><p>Sorry, I was more suggesting that word in the context of<br>`public(inheritable)`, provided the default is sealed.<br></p><p><br>&gt; John.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/b1a2e7e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 1:50 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Jun 30, 2016 at 3:47 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 30, 2016, at 1:44 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On Thu, Jun 30, 2016 at 3:36 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 29, 2016, at 1:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 2:54 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 11:39 AM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; How about `public(extensible)` ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm.  I started to work out an example with these as separate modifiers, and I think I understand the need to combine them in some way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if just &quot;extensible&quot; would be good enough.  It is a term that&#39;s used in API descriptions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This particular word is unfortunate because it has nothing to do with an extension, which shares the same etymological root.<br>&gt;&gt; <br>&gt;&gt; I agree, but I&#39;m not sure that it&#39;s particularly confusing in practice.<br>&gt;&gt;  <br>&gt;&gt; Why not just &quot;inheritable&quot;? That is, after all, what we mean, no?<br>&gt; <br>&gt; All class methods are intrinsically inheritable.  A non-inheritable method would *require* an override.<br>&gt; <br>&gt; Sorry, I was more suggesting that word in the context of `public(inheritable)`, provided the default is sealed.<br></p><p>The same argument applies: both sealed and unsealed methods are capable of being inherited.  And you don&#39;t inherit classes, you inherit *from* them.<br></p><p>If we&#39;re going to go along those lines, we should just use public(subclassable) and public(overridable).  We can fall back on those if necessary; I would just like to continue looking for better alternatives.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/bfa1c217/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 30, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; If we&#39;re going to go along those lines, we should just use public(subclassable) and public(overridable).  We can fall back on those if necessary; I would just like to continue looking for better alternatives.<br></p><p>I would prefer to have a *single* keyword which meant both public and overridable. That would minimize the impact of this feature—instead of writing:<br></p><p>	public class MyViewController: UIViewController {<br>		public func displayMe(_ me: person) { … }<br>	}<br></p><p>You&#39;d write (strawman keyword):<br></p><p>	openseason class MyViewController: UIViewController {<br>		openseason func displayMe(_ me: person) { … }<br>	}<br></p><p>And then `MyViewController` could be subclassed, and `displayMe` overridden.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  1, 2016 at 07:00:00am</p></header><div class="content"><p>That starts to look an awful lot like a fifth access level just for classes<br>(I know you&#39;re not proposing one, but it could start to look that way to a<br>user). I think there&#39;s much to be said for having the word public in front<br>of things that are public. Unless, of course, your strawman keyword is a<br>much maligned compound word that begins with &quot;public&quot;, like<br>&quot;publicoverridable&quot;.<br>On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; If we&#39;re going to go along those lines, we should just use<br>&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;<br>&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt; writing:<br>&gt;<br>&gt;         public class MyViewController: UIViewController {<br>&gt;                 public func displayMe(_ me: person) { … }<br>&gt;         }<br>&gt;<br>&gt; You&#39;d write (strawman keyword):<br>&gt;<br>&gt;         openseason class MyViewController: UIViewController {<br>&gt;                 openseason func displayMe(_ me: person) { … }<br>&gt;         }<br>&gt;<br>&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt; overridden.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/d5141b49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  1, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; That starts to look an awful lot like a fifth access level just for classes (I know you&#39;re not proposing one, but it could start to look that way to a user).<br></p><p>You know, it *could* be.<br></p><p>Suppose that, in `internal` scope, you can do all of these things:<br></p><p>* Subclass a class.<br>* Add a case to an enum in an extension.[1]<br>* Add a stored property to a struct in an extension.<br>* Conform to a protocol (as opposed to just using and constraining with the existing conformances).<br>* Override an individual initializer, property, subscript, or method in an extension or subclass.[2]<br></p><p>But `public` does not permit them. You can *use* something that is public, but you can&#39;t extend it. `open`, on the other hand, *does* allow you to extend them. It means that outside code has (about) as much freedom to extend the `open` item as code inside your module does.<br></p><p>This approach would allow us to make the &quot;sealing&quot; very tight—if you changed a class from `public` to `open`, all of its `public` members would still be sealed—without actually making that a heavy burden on programmers who want things unsealed.<br></p><p>This also suggests that perhaps `final` is best thought of as foreclosing the things that `open` permits, either within a module or in future versions:<br></p><p>* A `final` class can never be subclassed.<br>* A `final` enum can never have cases added.<br>* A `final` struct can never have stored properties added.<br>* A `final` protocol...well, okay, that one&#39;s pretty useless. Maybe there just aren&#39;t `final` protocols.[3]<br>* A `final` property, subscript, or method can never be overridden.<br></p><p>A `final` thing would be fast both inside and outside the module, because it would have guarantees about its size/dynamic type/implementation; an `open` thing would be slow both inside and outside, because it would have no such guarantees; and a non-`final`, non-`open` thing would be slow externally but fast internally.<br></p><p><br></p><p>[1] There&#39;s another thread floating around where I&#39;ve seen people suggest that enums could never be open because you couldn&#39;t unique integer raw values to each case. I think that&#39;s a rather narrow view of what an enum is for; many, perhaps most, enums don&#39;t need raw values, and even those that do could support string raw values with little danger.<br></p><p>[2] You can&#39;t currently override a member in an extension, but I think that would be essential for initializing extension stored properties and especially for adding cases to enums (you&#39;d want to override members to handle your cases). <br></p><p>[3] Or maybe a `final` protocol can&#39;t be conformed to directly, but only through a sub-protocol (which could only be defined within the module). That would allow arrangements like &quot;Sequence is the parent protocol of both IteratorProtocol and Collection, but all Sequences must conform to one of those sub-protocols&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 2:08 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; That starts to look an awful lot like a fifth access level just for classes (I know you&#39;re not proposing one, but it could start to look that way to a user).<br>&gt; <br>&gt; You know, it *could* be.<br>&gt; <br>&gt; Suppose that, in `internal` scope, you can do all of these things:<br>&gt; <br>&gt; * Subclass a class.<br>&gt; * Add a case to an enum in an extension.[1]<br>&gt; * Add a stored property to a struct in an extension.<br>&gt; * Conform to a protocol (as opposed to just using and constraining with the existing conformances).<br>&gt; * Override an individual initializer, property, subscript, or method in an extension or subclass.[2]<br>&gt; <br>&gt; But `public` does not permit them. You can *use* something that is public, but you can&#39;t extend it. `open`, on the other hand, *does* allow you to extend them. It means that outside code has (about) as much freedom to extend the `open` item as code inside your module does.<br>&gt; <br>&gt; This approach would allow us to make the &quot;sealing&quot; very tight—if you changed a class from `public` to `open`, all of its `public` members would still be sealed—without actually making that a heavy burden on programmers who want things unsealed.<br></p><p>Yes, this is the way I&#39;ve been thinking about it.<br></p><p>&gt; This also suggests that perhaps `final` is best thought of as foreclosing the things that `open` permits, either within a module or in future versions:<br>&gt; <br>&gt; * A `final` class can never be subclassed.<br>&gt; * A `final` enum can never have cases added.<br>&gt; * A `final` struct can never have stored properties added.<br>&gt; * A `final` protocol...well, okay, that one&#39;s pretty useless. Maybe there just aren&#39;t `final` protocols.[3]<br>&gt; * A `final` property, subscript, or method can never be overridden.<br>&gt; <br>&gt; A `final` thing would be fast both inside and outside the module, because it would have guarantees about its size/dynamic type/implementation; an `open` thing would be slow both inside and outside, because it would have no such guarantees; and a non-`final`, non-`open` thing would be slow externally but fast internally.<br></p><p>This is an interesting thought.  Its application to &#39;struct&#39;, though, seems a bit strange, since &#39;final&#39; on classes doesn&#39;t remove the ability for the module to change the stored properties (and clearly we wouldn&#39;t want it to do so).<br></p><p>&gt; [1] There&#39;s another thread floating around where I&#39;ve seen people suggest that enums could never be open because you couldn&#39;t unique integer raw values to each case. I think that&#39;s a rather narrow view of what an enum is for; many, perhaps most, enums don&#39;t need raw values, and even those that do could support string raw values with little danger.<br></p><p>If we know that an enum needs to be extensible, we can leave room in its implementation for cases with arbitrary associated values.  This isn&#39;t a problem.<br></p><p>Raw values are perhaps different.<br></p><p>&gt; [2] You can&#39;t currently override a member in an extension, but I think that would be essential for initializing extension stored properties and especially for adding cases to enums (you&#39;d want to override members to handle your cases).<br></p><p>Yes, I think allowing extensions to override members is an eventual goal.  It needs runtime support, though, and some careful language design.<br></p><p>&gt; [3] Or maybe a `final` protocol can&#39;t be conformed to directly, but only through a sub-protocol (which could only be defined within the module). That would allow arrangements like &quot;Sequence is the parent protocol of both IteratorProtocol and Collection, but all Sequences must conform to one of those sub-protocols&quot;.<br></p><p>It&#39;s okay for a modifier to not have meaning for absolutely everything. :)<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  2, 2016 at 09:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>On Jul 1, 2016, at 6:43 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; On Jul 1, 2016, at 2:08 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; That starts to look an awful lot like a fifth access level just for classes (I know you&#39;re not proposing one, but it could start to look that way to a user).<br>&gt;&gt; <br>&gt;&gt; You know, it *could* be.<br>&gt;&gt; <br>&gt;&gt; Suppose that, in `internal` scope, you can do all of these things:<br>&gt;&gt; <br>&gt;&gt; * Subclass a class.<br>&gt;&gt; * Add a case to an enum in an extension.[1]<br>&gt;&gt; * Add a stored property to a struct in an extension.<br>&gt;&gt; * Conform to a protocol (as opposed to just using and constraining with the existing conformances).<br>&gt;&gt; * Override an individual initializer, property, subscript, or method in an extension or subclass.[2]<br>&gt;&gt; <br>&gt;&gt; But `public` does not permit them. You can *use* something that is public, but you can&#39;t extend it. `open`, on the other hand, *does* allow you to extend them. It means that outside code has (about) as much freedom to extend the `open` item as code inside your module does.<br>&gt;&gt; <br>&gt;&gt; This approach would allow us to make the &quot;sealing&quot; very tight—if you changed a class from `public` to `open`, all of its `public` members would still be sealed—without actually making that a heavy burden on programmers who want things unsealed.<br>&gt; <br>&gt; Yes, this is the way I&#39;ve been thinking about it.<br>&gt; <br>&gt;&gt; This also suggests that perhaps `final` is best thought of as foreclosing the things that `open` permits, either within a module or in future versions:<br>&gt;&gt; <br>&gt;&gt; * A `final` class can never be subclassed.<br>&gt;&gt; * A `final` enum can never have cases added.<br>&gt;&gt; * A `final` struct can never have stored properties added.<br>&gt;&gt; * A `final` protocol...well, okay, that one&#39;s pretty useless. Maybe there just aren&#39;t `final` protocols.[3]<br>&gt;&gt; * A `final` property, subscript, or method can never be overridden.<br>&gt;&gt; <br>&gt;&gt; A `final` thing would be fast both inside and outside the module, because it would have guarantees about its size/dynamic type/implementation; an `open` thing would be slow both inside and outside, because it would have no such guarantees; and a non-`final`, non-`open` thing would be slow externally but fast internally.<br>&gt; <br>&gt; This is an interesting thought.  Its application to &#39;struct&#39;, though, seems a bit strange, since &#39;final&#39; on classes doesn&#39;t remove the ability for the module to change the stored properties (and clearly we wouldn&#39;t want it to do so).<br>&gt; <br>&gt;&gt; [1] There&#39;s another thread floating around where I&#39;ve seen people suggest that enums could never be open because you couldn&#39;t unique integer raw values to each case. I think that&#39;s a rather narrow view of what an enum is for; many, perhaps most, enums don&#39;t need raw values, and even those that do could support string raw values with little danger.<br>&gt; <br>&gt; If we know that an enum needs to be extensible, we can leave room in its implementation for cases with arbitrary associated values.  This isn&#39;t a problem.<br>&gt; <br>&gt; Raw values are perhaps different.<br></p><p>This is a situation I often run into in jave where I would use an enum to create a finite set of constants to be passed (say action identifers). But then this makes it very difficult for external modules to extend the core set of actions locally. So i generally windup with an enum and an interface (the enum implements the interface).<br>Then local extensions are free to define their own local enums to cover only their local extensions to the original core set of actions. Then the public api definition constrains the action parameter to be enum&amp;TheRequiredInterface. In the end this is a pattern I&#39;ve come to like because tracing usage of the interface I can find all subsequent entensions to the core set of actions. Each subsequent set of extensions is just that: its own closed enum showing that they all form a coherent namespace for that extension (being a different enum than my original set, they do not prevent me extending the core set without risking name collisions with their extensions). The only cost is the heavier api declation site signature that is wearing the double enum &amp; interface constraint.<br>The point is that you can extend enums without have to open them, and the resulting pattern may be even better than if you open the enum. The only hickup..... Swift does not let you express<br></p><p>protocol Command{}<br>func myCommand Handler&lt;C: enum &amp; Command&gt;{}<br></p><p><br>&gt;&gt; [2] You can&#39;t currently override a member in an extension, but I think that would be essential for initializing extension stored properties and especially for adding cases to enums (you&#39;d want to override members to handle your cases).<br>&gt; <br>&gt; Yes, I think allowing extensions to override members is an eventual goal.  It needs runtime support, though, and some careful language design.<br>&gt; <br>&gt;&gt; [3] Or maybe a `final` protocol can&#39;t be conformed to directly, but only through a sub-protocol (which could only be defined within the module). That would allow arrangements like &quot;Sequence is the parent protocol of both IteratorProtocol and Collection, but all Sequences must conform to one of those sub-protocols&quot;.<br>&gt; <br>&gt; It&#39;s okay for a modifier to not have meaning for absolutely everything. :)<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 12:42 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is a situation I often run into in jave where I would use an enum to create a finite set of constants to be passed (say action identifers). But then this makes it very difficult for external modules to extend the core set of actions locally. So i generally windup with an enum and an interface (the enum implements the interface).<br></p><p>Sure. I would argue that that&#39;s the exact right approach to take for this kind of thing. For instance, for storyboard segue identifiers, I would write something like this:<br></p><p>	open protocol SegueIdentifierProtocol: RawRepresentable where RawValue == String {}<br></p><p>	open protocol SeguePerformable {<br>		associatedtype SegueIdentifier: SegueIdentifierProtocol<br>		<br>		// Hooks<br>		func shouldPerformSegue(with identifier: SegueIdentifier, sender: AnyObject?) -&gt; Bool<br>		func prepare(for segue: UIStoryboardSegue, with identifier: SegueIdentifier, sender: AnyObject?)<br>	}<br></p><p>	public extension SeguePerformable where Self: UIViewController {<br>		// Machinery to bridge to normal UIViewController API<br>		<br>		func performSegue(with identifier: SegueIdentifier, sender: AnyObject?) {...}<br>		override func shouldPerformSegue(withIdentifier identifier: String, sender: AnyObject?) -&gt; Bool {...}<br>		override func prepare(for segue: UIStoryboardSegue, sender: AnyObject?) {...}<br>	}<br></p><p>Rather than attempting some sort of universal enum of all identifiers:<br></p><p>	extension UIViewController {<br>		open enum SegueIdentifier: String {<br>			// Extensible for users<br>		}<br>		<br>		// Hooks<br>		open func shouldPerformSegue(with identifier: SegueIdentifier, sender: AnyObject?) -&gt; Bool {...}<br>		open func prepare(for segue: UIStoryboardSegue, with identifier: SegueIdentifier, sender: AnyObject?) {...}<br>		<br>		// Machinery to bridge to normal UIViewController API<br>		public func performSegue(with identifier: SegueIdentifier, sender: AnyObject?) {...}<br>		override public func shouldPerformSegue(withIdentifier identifier: String, sender: AnyObject?) -&gt; Bool {...}<br>		override public func prepare(for segue: UIStoryboardSegue, sender: AnyObject?) {...}<br>	}<br></p><p>&gt; Then local extensions are free to define their own local enums to cover only their local extensions to the original core set of actions. Then the public api definition constrains the action parameter to be enum&amp;TheRequiredInterface.<br></p><p>Okay, but why constrain it to `enum`? Do you actually care that it&#39;s an `enum`, or do you just care that there&#39;s a type which can give you the identifier you need? If somebody wrote a highly dynamic client of your code that needed to generate identifiers on the fly, why should your code reject that?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  2, 2016 at 02:00:00pm</p></header><div class="content"><p>Inline<br>Regards<br>(From mobile)<br></p><p>On Jul 2, 2016, at 10:51 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 2, 2016, at 12:42 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a situation I often run into in jave where I would use an enum to create a finite set of constants to be passed (say action identifers). But then this makes it very difficult for external modules to extend the core set of actions locally. So i generally windup with an enum and an interface (the enum implements the interface).<br>&gt; <br>&gt; Sure. I would argue that that&#39;s the exact right approach to take for this kind of thing. For instance, for storyboard segue identifiers, I would write something like this:<br>&gt; <br>&gt;    open protocol SegueIdentifierProtocol: RawRepresentable where RawValue == String {}<br>&gt; <br>&gt;    open protocol SeguePerformable {<br>&gt;        associatedtype SegueIdentifier: SegueIdentifierProtocol<br>&gt;        <br>&gt;        // Hooks<br>&gt;        func shouldPerformSegue(with identifier: SegueIdentifier, sender: AnyObject?) -&gt; Bool<br>&gt;        func prepare(for segue: UIStoryboardSegue, with identifier: SegueIdentifier, sender: AnyObject?)<br>&gt;    }<br>&gt; <br>&gt;    public extension SeguePerformable where Self: UIViewController {<br>&gt;        // Machinery to bridge to normal UIViewController API<br>&gt;        <br>&gt;        func performSegue(with identifier: SegueIdentifier, sender: AnyObject?) {...}<br>&gt;        override func shouldPerformSegue(withIdentifier identifier: String, sender: AnyObject?) -&gt; Bool {...}<br>&gt;        override func prepare(for segue: UIStoryboardSegue, sender: AnyObject?) {...}<br>&gt;    }<br>&gt; <br>&gt; Rather than attempting some sort of universal enum of all identifiers:<br>&gt; <br>&gt;    extension UIViewController {<br>&gt;        open enum SegueIdentifier: String {<br>&gt;            // Extensible for users<br>&gt;        }<br>&gt;        <br>&gt;        // Hooks<br>&gt;        open func shouldPerformSegue(with identifier: SegueIdentifier, sender: AnyObject?) -&gt; Bool {...}<br>&gt;        open func prepare(for segue: UIStoryboardSegue, with identifier: SegueIdentifier, sender: AnyObject?) {...}<br>&gt;        <br>&gt;        // Machinery to bridge to normal UIViewController API<br>&gt;        public func performSegue(with identifier: SegueIdentifier, sender: AnyObject?) {...}<br>&gt;        override public func shouldPerformSegue(withIdentifier identifier: String, sender: AnyObject?) -&gt; Bool {...}<br>&gt;        override public func prepare(for segue: UIStoryboardSegue, sender: AnyObject?) {...}<br>&gt;    }<br>&gt; <br>&gt;&gt; Then local extensions are free to define their own local enums to cover only their local extensions to the original core set of actions. Then the public api definition constrains the action parameter to be enum&amp;TheRequiredInterface.<br>&gt; <br>&gt; Okay, but why constrain it to `enum`? Do you actually care that it&#39;s an `enum`, or do you just care that there&#39;s a type which can give you the identifier you need? If somebody wrote a highly dynamic client of your code that needed to generate identifiers on the fly, why should your code reject that?<br></p><p>In the case of a segway id (i did watch the wwdc presentation last year too) the protocol representation is IMHO more a pedentic exercise in &#39;look how pretty i can make my code&#39; than an actual technical necessity (considering people have been writing the same apps in objc for years, their argument of &#39;avoiding mismatch&#39; did not hold much water when considering the scale we are talking about).<br></p><p>I was refering to real life systems (think state machine-like libraries for eg) where having access to the complete set carries a real value. For some, dealing with multiple disjointed sets is a minor hickup, for others a real feature. The point is i am describing carefully designed real life (many trading) systems for which i truly care about every piece of what i described for various reasons (be it size/modularity 400KLOC+ systems, bytecode level efficiency of enums as Hash keys, .... ). At this point none of these systems could be done in swift yet due to small gaps here and there (of course they could technically be rewritten in cobol if need be, but at a tremendous loss):<br>* can&#39;t constrain on enum (what&#39;s worse is Dave is not even convinced there is any case for it)<br>* can&#39;t easily discover all cases<br>* can&#39;t annotate enum case with meta information making runtime adaptation possible<br>...<br></p><p>Maybe the gap will never close and java/scala/kotlin/ceylon will remain the languages of choice for the real life servers of this world. An interesting question might be: what to do when a phonegap app written in typescript is much more expressive than its swift counterpart? Today i use swift because it is new and fun, but i find c# much more powerful for even iOS only apps. But i have high hopes.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July  2, 2016 at 10:00:00am</p></header><div class="content"><p>+1 to sealed<br>+1 to sealed-as-default.<br></p><p>I prefer the need to explicitly share details that I would like to share.<br>Separately, I do think that we need to improve the tools for auditing and<br>organizing APIs.<br></p><p>On Sat, Jul 2, 2016 at 8:35 AM, L. Mihalkovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Inline<br>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt; On Jul 2, 2016, at 10:51 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Jul 2, 2016, at 12:42 AM, L. Mihalkovic &lt;<br>&gt; laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is a situation I often run into in jave where I would use an enum<br>&gt; to create a finite set of constants to be passed (say action identifers).<br>&gt; But then this makes it very difficult for external modules to extend the<br>&gt; core set of actions locally. So i generally windup with an enum and an<br>&gt; interface (the enum implements the interface).<br>&gt; &gt;<br>&gt; &gt; Sure. I would argue that that&#39;s the exact right approach to take for<br>&gt; this kind of thing. For instance, for storyboard segue identifiers, I would<br>&gt; write something like this:<br>&gt; &gt;<br>&gt; &gt;    open protocol SegueIdentifierProtocol: RawRepresentable where<br>&gt; RawValue == String {}<br>&gt; &gt;<br>&gt; &gt;    open protocol SeguePerformable {<br>&gt; &gt;        associatedtype SegueIdentifier: SegueIdentifierProtocol<br>&gt; &gt;<br>&gt; &gt;        // Hooks<br>&gt; &gt;        func shouldPerformSegue(with identifier: SegueIdentifier, sender:<br>&gt; AnyObject?) -&gt; Bool<br>&gt; &gt;        func prepare(for segue: UIStoryboardSegue, with identifier:<br>&gt; SegueIdentifier, sender: AnyObject?)<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    public extension SeguePerformable where Self: UIViewController {<br>&gt; &gt;        // Machinery to bridge to normal UIViewController API<br>&gt; &gt;<br>&gt; &gt;        func performSegue(with identifier: SegueIdentifier, sender:<br>&gt; AnyObject?) {...}<br>&gt; &gt;        override func shouldPerformSegue(withIdentifier identifier:<br>&gt; String, sender: AnyObject?) -&gt; Bool {...}<br>&gt; &gt;        override func prepare(for segue: UIStoryboardSegue, sender:<br>&gt; AnyObject?) {...}<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; Rather than attempting some sort of universal enum of all identifiers:<br>&gt; &gt;<br>&gt; &gt;    extension UIViewController {<br>&gt; &gt;        open enum SegueIdentifier: String {<br>&gt; &gt;            // Extensible for users<br>&gt; &gt;        }<br>&gt; &gt;<br>&gt; &gt;        // Hooks<br>&gt; &gt;        open func shouldPerformSegue(with identifier: SegueIdentifier,<br>&gt; sender: AnyObject?) -&gt; Bool {...}<br>&gt; &gt;        open func prepare(for segue: UIStoryboardSegue, with identifier:<br>&gt; SegueIdentifier, sender: AnyObject?) {...}<br>&gt; &gt;<br>&gt; &gt;        // Machinery to bridge to normal UIViewController API<br>&gt; &gt;        public func performSegue(with identifier: SegueIdentifier,<br>&gt; sender: AnyObject?) {...}<br>&gt; &gt;        override public func shouldPerformSegue(withIdentifier<br>&gt; identifier: String, sender: AnyObject?) -&gt; Bool {...}<br>&gt; &gt;        override public func prepare(for segue: UIStoryboardSegue,<br>&gt; sender: AnyObject?) {...}<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;&gt; Then local extensions are free to define their own local enums to cover<br>&gt; only their local extensions to the original core set of actions. Then the<br>&gt; public api definition constrains the action parameter to be<br>&gt; enum&amp;TheRequiredInterface.<br>&gt; &gt;<br>&gt; &gt; Okay, but why constrain it to `enum`? Do you actually care that it&#39;s an<br>&gt; `enum`, or do you just care that there&#39;s a type which can give you the<br>&gt; identifier you need? If somebody wrote a highly dynamic client of your code<br>&gt; that needed to generate identifiers on the fly, why should your code reject<br>&gt; that?<br>&gt;<br>&gt; In the case of a segway id (i did watch the wwdc presentation last year<br>&gt; too) the protocol representation is IMHO more a pedentic exercise in &#39;look<br>&gt; how pretty i can make my code&#39; than an actual technical necessity<br>&gt; (considering people have been writing the same apps in objc for years,<br>&gt; their argument of &#39;avoiding mismatch&#39; did not hold much water when<br>&gt; considering the scale we are talking about).<br>&gt;<br>&gt; I was refering to real life systems (think state machine-like libraries<br>&gt; for eg) where having access to the complete set carries a real value. For<br>&gt; some, dealing with multiple disjointed sets is a minor hickup, for others a<br>&gt; real feature. The point is i am describing carefully designed real life<br>&gt; (many trading) systems for which i truly care about every piece of what i<br>&gt; described for various reasons (be it size/modularity 400KLOC+ systems,<br>&gt; bytecode level efficiency of enums as Hash keys, .... ). At this point none<br>&gt; of these systems could be done in swift yet due to small gaps here and<br>&gt; there (of course they could technically be rewritten in cobol if need be,<br>&gt; but at a tremendous loss):<br>&gt; * can&#39;t constrain on enum (what&#39;s worse is Dave is not even convinced<br>&gt; there is any case for it)<br>&gt; * can&#39;t easily discover all cases<br>&gt; * can&#39;t annotate enum case with meta information making runtime adaptation<br>&gt; possible<br>&gt; ...<br>&gt;<br>&gt; Maybe the gap will never close and java/scala/kotlin/ceylon will remain<br>&gt; the languages of choice for the real life servers of this world. An<br>&gt; interesting question might be: what to do when a phonegap app written in<br>&gt; typescript is much more expressive than its swift counterpart? Today i use<br>&gt; swift because it is new and fun, but i find c# much more powerful for even<br>&gt; iOS only apps. But i have high hopes.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/bd3f2e9e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; That starts to look an awful lot like a fifth access level just for classes (I know you&#39;re not proposing one, but it could start to look that way to a user). I think there&#39;s much to be said for having the word public in front of things that are public. Unless, of course, your strawman keyword is a much maligned compound word that begins with &quot;public&quot;, like &quot;publicoverridable&quot;.<br></p><p>I would also prefer a single keyword if the word implies something about accessibility.  &quot;open&quot; does that, although using it here would conflict with its potential use on enums unless we required all cases within the defining module to be present in the enum declaration rather than extensions.<br></p><p>I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d just separate them and say that the second half can only be present on a public declaration, or do this parenthesized syntax.<br></p><p>John.<br></p><p><br>&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt; If we&#39;re going to go along those lines, we should just use public(subclassable) and public(overridable).  We can fall back on those if necessary; I would just like to continue looking for better alternatives.<br>&gt; <br>&gt; I would prefer to have a *single* keyword which meant both public and overridable. That would minimize the impact of this feature—instead of writing:<br>&gt; <br>&gt;         public class MyViewController: UIViewController {<br>&gt;                 public func displayMe(_ me: person) { … }<br>&gt;         }<br>&gt; <br>&gt; You&#39;d write (strawman keyword):<br>&gt; <br>&gt;         openseason class MyViewController: UIViewController {<br>&gt;                 openseason func displayMe(_ me: person) { … }<br>&gt;         }<br>&gt; <br>&gt; And then `MyViewController` could be subclassed, and `displayMe` overridden.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/bba85d85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  1, 2016 at 02:00:00pm</p></header><div class="content"><p>The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>may not be common to use &quot;opened&quot; as an adjective but from the<br>dictionaries I consulted it is possible to.<br></p><p>opened class MyViewController: UIViewController {<br>       opened func displayMe(_ me: person) { … }<br>}<br></p><p>On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt; &quot;publicoverridable&quot;.<br>&gt;<br>&gt;<br>&gt; I would also prefer a single keyword if the word implies something about<br>&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt; its potential use on enums unless we required all cases within the defining<br>&gt; module to be present in the enum declaration rather than extensions.<br>&gt;<br>&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt; just separate them and say that the second half can only be present on a<br>&gt; public declaration, or do this parenthesized syntax.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt; &gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt; &gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;<br>&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt; writing:<br>&gt;&gt;<br>&gt;&gt;         public class MyViewController: UIViewController {<br>&gt;&gt;                 public func displayMe(_ me: person) { … }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;<br>&gt;&gt;         openseason class MyViewController: UIViewController {<br>&gt;&gt;                 openseason func displayMe(_ me: person) { … }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt; overridden.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>If “opened”, who or what did the opening? If “open” is like “extensible”, then I would interpret “opened” to be like “extended”.<br></p><p>&gt; On Jul 1, 2016, at 10:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>&gt; may not be common to use &quot;opened&quot; as an adjective but from the<br>&gt; dictionaries I consulted it is possible to.<br>&gt; <br>&gt; opened class MyViewController: UIViewController {<br>&gt;       opened func displayMe(_ me: person) { … }<br>&gt; }<br>&gt; <br>&gt; On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt;&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt;&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt;&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt;&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt;&gt; &quot;publicoverridable&quot;.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would also prefer a single keyword if the word implies something about<br>&gt;&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt;&gt; its potential use on enums unless we required all cases within the defining<br>&gt;&gt; module to be present in the enum declaration rather than extensions.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt;&gt; just separate them and say that the second half can only be present on a<br>&gt;&gt; public declaration, or do this parenthesized syntax.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt;&gt;&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt;&gt;&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt;&gt; writing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        public class MyViewController: UIViewController {<br>&gt;&gt;&gt;                public func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        openseason class MyViewController: UIViewController {<br>&gt;&gt;&gt;                openseason func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt;&gt; overridden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 10:51 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt; If “opened”, who or what did the opening? If “open” is like “extensible”, then I would interpret “opened” to be like “extended”.<br></p><p>Yeah, I would prefer &quot;open&quot; to &quot;opened&quot;.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; On Jul 1, 2016, at 10:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>&gt;&gt; may not be common to use &quot;opened&quot; as an adjective but from the<br>&gt;&gt; dictionaries I consulted it is possible to.<br>&gt;&gt; <br>&gt;&gt; opened class MyViewController: UIViewController {<br>&gt;&gt;      opened func displayMe(_ me: person) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt;&gt;&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt;&gt;&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt;&gt;&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt;&gt;&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt;&gt;&gt; &quot;publicoverridable&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would also prefer a single keyword if the word implies something about<br>&gt;&gt;&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt;&gt;&gt; its potential use on enums unless we required all cases within the defining<br>&gt;&gt;&gt; module to be present in the enum declaration rather than extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt;&gt;&gt; just separate them and say that the second half can only be present on a<br>&gt;&gt;&gt; public declaration, or do this parenthesized syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt;&gt;&gt;&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt;&gt;&gt;&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt;&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt;&gt;&gt; writing:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       public class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;               public func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       openseason class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;               openseason func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt;&gt;&gt; overridden.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Coming in late on this, but here’s my take guided by the principal of least surprise (according to me):<br></p><p>- everything is sealed within its module by default, no keyword<br>- use “public” to mean “exported out of the module, subclass/overridable”<br>- use “public(final)” to mean “exported out of the module, no subclassing or overriding externally, but overriding and subclasses allowed internally”<br>- meaning of “final” does not change<br>- using “public final” then means the same as both public(final) and also “final” internal to the module<br>- using “public(final) final” could be presented as an error with fixit since it’s redundant<br></p><p>Did I miss anything?<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Jul 1, 2016, at 12:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 10:51 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt;&gt; If “opened”, who or what did the opening? If “open” is like “extensible”, then I would interpret “opened” to be like “extended”.<br>&gt; <br>&gt; Yeah, I would prefer &quot;open&quot; to &quot;opened&quot;.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 10:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>&gt;&gt;&gt; may not be common to use &quot;opened&quot; as an adjective but from the<br>&gt;&gt;&gt; dictionaries I consulted it is possible to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; opened class MyViewController: UIViewController {<br>&gt;&gt;&gt;     opened func displayMe(_ me: person) { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt;&gt;&gt;&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt;&gt;&gt;&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt;&gt;&gt;&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt;&gt;&gt;&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt;&gt;&gt;&gt; &quot;publicoverridable&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would also prefer a single keyword if the word implies something about<br>&gt;&gt;&gt;&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt;&gt;&gt;&gt; its potential use on enums unless we required all cases within the defining<br>&gt;&gt;&gt;&gt; module to be present in the enum declaration rather than extensions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt;&gt;&gt;&gt; just separate them and say that the second half can only be present on a<br>&gt;&gt;&gt;&gt; public declaration, or do this parenthesized syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt;&gt;&gt;&gt;&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt;&gt;&gt;&gt;&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt;&gt;&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt;&gt;&gt;&gt; writing:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;      public class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;              public func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;      openseason class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;              openseason func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt;&gt;&gt;&gt; overridden.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Ok, I suppose that this design *basically* undoes the sealed by default thing, doesn’t it? :P  lol. One of those days, I guess..<br></p><p>Sigh.<br></p><p>Crawling away…<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jul 1, 2016, at 1:16 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Coming in late on this, but here’s my take guided by the principal of least surprise (according to me):<br>&gt; <br>&gt; - everything is sealed within its module by default, no keyword<br>&gt; - use “public” to mean “exported out of the module, subclass/overridable”<br>&gt; - use “public(final)” to mean “exported out of the module, no subclassing or overriding externally, but overriding and subclasses allowed internally”<br>&gt; - meaning of “final” does not change<br>&gt; - using “public final” then means the same as both public(final) and also “final” internal to the module<br>&gt; - using “public(final) final” could be presented as an error with fixit since it’s redundant<br>&gt; <br>&gt; Did I miss anything?<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 12:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 10:51 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt;&gt;&gt; If “opened”, who or what did the opening? If “open” is like “extensible”, then I would interpret “opened” to be like “extended”.<br>&gt;&gt; <br>&gt;&gt; Yeah, I would prefer &quot;open&quot; to &quot;opened&quot;.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 1, 2016, at 10:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>&gt;&gt;&gt;&gt; may not be common to use &quot;opened&quot; as an adjective but from the<br>&gt;&gt;&gt;&gt; dictionaries I consulted it is possible to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; opened class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;    opened func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt;&gt;&gt;&gt;&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt;&gt;&gt;&gt;&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt;&gt;&gt;&gt;&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt;&gt;&gt;&gt;&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt;&gt;&gt;&gt;&gt; &quot;publicoverridable&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would also prefer a single keyword if the word implies something about<br>&gt;&gt;&gt;&gt;&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt;&gt;&gt;&gt;&gt; its potential use on enums unless we required all cases within the defining<br>&gt;&gt;&gt;&gt;&gt; module to be present in the enum declaration rather than extensions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt;&gt;&gt;&gt;&gt; just separate them and say that the second half can only be present on a<br>&gt;&gt;&gt;&gt;&gt; public declaration, or do this parenthesized syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt;&gt;&gt;&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; writing:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     public class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;             public func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     openseason class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;             openseason func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt;&gt;&gt;&gt;&gt; overridden.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Imma try again.. :P<br></p><p><br>- everything is sealed within its module by default, no keyword<br></p><p>- use “export” (formerly “public”) to mean “visible outside of the module, no subclassing or overriding externally, but overriding and subclasses allowed internally unless otherwise restricted”<br></p><p>- use “export(public)” to mean “visible outside of the module, subclass/overridable externally”<br></p><p>- using “export final” then makes sense with the “final” being applied internally to the module as well<br></p><p>- using “export(public) final” *probably* doesn’t make sense, but would mean overriding and subclasses allowed externally, but not internally <br></p><p><br>My argument for “export” here is that it is in the inverse of “import” which is how you get another module’s stuff into your module in the first place.<br></p><p><br>Bonus side tracking:<br></p><p>I would then possibly argue that “internal” should be renamed to “public”.<br></p><p>After which I might be inclined to argue that “fileprivate” be renamed to “internal” :P<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Jul 1, 2016, at 1:20 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Ok, I suppose that this design *basically* undoes the sealed by default thing, doesn’t it? :P  lol. One of those days, I guess..<br>&gt; <br>&gt; Sigh.<br>&gt; <br>&gt; Crawling away…<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 1:16 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coming in late on this, but here’s my take guided by the principal of least surprise (according to me):<br>&gt;&gt; <br>&gt;&gt; - everything is sealed within its module by default, no keyword<br>&gt;&gt; - use “public” to mean “exported out of the module, subclass/overridable”<br>&gt;&gt; - use “public(final)” to mean “exported out of the module, no subclassing or overriding externally, but overriding and subclasses allowed internally”<br>&gt;&gt; - meaning of “final” does not change<br>&gt;&gt; - using “public final” then means the same as both public(final) and also “final” internal to the module<br>&gt;&gt; - using “public(final) final” could be presented as an error with fixit since it’s redundant<br>&gt;&gt; <br>&gt;&gt; Did I miss anything?<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 12:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 1, 2016, at 10:51 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; If “opened”, who or what did the opening? If “open” is like “extensible”, then I would interpret “opened” to be like “extended”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, I would prefer &quot;open&quot; to &quot;opened&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 10:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>&gt;&gt;&gt;&gt;&gt; may not be common to use &quot;opened&quot; as an adjective but from the<br>&gt;&gt;&gt;&gt;&gt; dictionaries I consulted it is possible to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; opened class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;   opened func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt;&gt;&gt;&gt;&gt;&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt;&gt;&gt;&gt;&gt;&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt;&gt;&gt;&gt;&gt;&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt;&gt;&gt;&gt;&gt;&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;publicoverridable&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would also prefer a single keyword if the word implies something about<br>&gt;&gt;&gt;&gt;&gt;&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt;&gt;&gt;&gt;&gt;&gt; its potential use on enums unless we required all cases within the defining<br>&gt;&gt;&gt;&gt;&gt;&gt; module to be present in the enum declaration rather than extensions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; just separate them and say that the second half can only be present on a<br>&gt;&gt;&gt;&gt;&gt;&gt; public declaration, or do this parenthesized syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; writing:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    public class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            public func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    openseason class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            openseason func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; overridden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>I almost sent out an email with what you wrote. <br></p><p>how about `public( nonfinal )`<br></p><p>&gt; - use “public(nonfinal)” to mean “exported out of the module, subclass/overridable”<br></p><p>I think just `open` would be a little bit better. `public( open )`<br></p><p><br></p><p>&gt; On Jul 1, 2016, at 11:20 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, I suppose that this design *basically* undoes the sealed by default thing, doesn’t it? :P  lol. One of those days, I guess..<br>&gt; <br>&gt; Sigh.<br>&gt; <br>&gt; Crawling away…<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 1:16 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coming in late on this, but here’s my take guided by the principal of least surprise (according to me):<br>&gt;&gt; <br>&gt;&gt; - everything is sealed within its module by default, no keyword<br>&gt;&gt; - use “public” to mean “exported out of the module, subclass/overridable”<br>&gt;&gt; - use “public(final)” to mean “exported out of the module, no subclassing or overriding externally, but overriding and subclasses allowed internally”<br>&gt;&gt; - meaning of “final” does not change<br>&gt;&gt; - using “public final” then means the same as both public(final) and also “final” internal to the module<br>&gt;&gt; - using “public(final) final” could be presented as an error with fixit since it’s redundant<br>&gt;&gt; <br>&gt;&gt; Did I miss anything?<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 12:53 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 1, 2016, at 10:51 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; If “opened”, who or what did the opening? If “open” is like “extensible”, then I would interpret “opened” to be like “extended”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, I would prefer &quot;open&quot; to &quot;opened&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 10:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal was to use &quot;sealed&quot; so why not &quot;opened&quot;? I understand it<br>&gt;&gt;&gt;&gt;&gt; may not be common to use &quot;opened&quot; as an adjective but from the<br>&gt;&gt;&gt;&gt;&gt; dictionaries I consulted it is possible to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; opened class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;   opened func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 1 July 2016 at 13:47, John McCall via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; That starts to look an awful lot like a fifth access level just for classes<br>&gt;&gt;&gt;&gt;&gt;&gt; (I know you&#39;re not proposing one, but it could start to look that way to a<br>&gt;&gt;&gt;&gt;&gt;&gt; user). I think there&#39;s much to be said for having the word public in front<br>&gt;&gt;&gt;&gt;&gt;&gt; of things that are public. Unless, of course, your strawman keyword is a<br>&gt;&gt;&gt;&gt;&gt;&gt; much maligned compound word that begins with &quot;public&quot;, like<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;publicoverridable&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would also prefer a single keyword if the word implies something about<br>&gt;&gt;&gt;&gt;&gt;&gt; accessibility.  &quot;open&quot; does that, although using it here would conflict with<br>&gt;&gt;&gt;&gt;&gt;&gt; its potential use on enums unless we required all cases within the defining<br>&gt;&gt;&gt;&gt;&gt;&gt; module to be present in the enum declaration rather than extensions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; we&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; just separate them and say that the second half can only be present on a<br>&gt;&gt;&gt;&gt;&gt;&gt; public declaration, or do this parenthesized syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jul 1, 2016 at 01:54 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we&#39;re going to go along those lines, we should just use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public(subclassable) and public(overridable).  We can fall back on those if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; necessary; I would just like to continue looking for better alternatives.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would prefer to have a *single* keyword which meant both public and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; overridable. That would minimize the impact of this feature—instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; writing:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    public class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            public func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You&#39;d write (strawman keyword):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    openseason class MyViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;            openseason func displayMe(_ me: person) { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then `MyViewController` could be subclassed, and `displayMe`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; overridden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/f3f36a84/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 1 Jul 2016, at 17:47, John McCall wrote:<br>&gt; <br>&gt; I don&#39;t think we&#39;d ever use a compound keyword that starts with public; <br>&gt; we&#39;d just separate them and say that the second half can only be present <br>&gt; on a public declaration, or do this parenthesized syntax.<br></p><p>The `super` keyword could be reused:<br></p><p>	public super class ParentClass {<br>	    public       func foo() { }<br>	    public super func bar() { }<br>	    public final func baz() { }<br>	}<br></p><p>-- Ben<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 30, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 8:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about `public(extensible)` ?<br>&gt; <br>&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default<br></p><p>What a jump... I am very curious about this rational that seems so obvious to you?<br></p><p>&gt;&gt; — then we need a way of &quot;unsealing&quot; classes and methods that&#39;s fairly pithy.  I don&#39;t think a parenthesized spelling is good enough for that.  And we should try to make the positive form (&quot;can be overridden&quot;) shorter than the negative (&quot;cannot be overridden&quot;), because the latter will not usually be written.<br>&gt;&gt; <br>&gt;&gt; To me, the ideal spelling would be usable in place of &quot;public&quot;.  If it does have to be stacked with &quot;public&quot;, then I think it ought to be pretty short.<br>&gt;&gt; <br>&gt;&gt; &quot;communal&quot;? :)<br>&gt;&gt; <br>&gt;&gt; &quot;open&quot; doesn&#39;t carry quite the right meaning, and it would need to be paired with &quot;public&quot;, I think.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:17 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; On Jun 29, 2016, at 8:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt; <br>&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default<br>&gt; <br>&gt; What a jump... I am very curious about this rational that seems so obvious to you?<br></p><p>There are a thousand different ways to add minor variations on language features.  In almost every single thread of any length on this list, you can find someone who got attached to a slightly different feature from the one that eventually got picked, and often you can find them asking why we didn&#39;t just add that, too, maybe under a different name or using different syntax.  If we added every single one of those, the language would not be better, it would just be absurdly, dauntingly complex.  We have to look at these kinds of additive features with a very critical eye and decide how much code will really benefit from it.<br></p><p>In our experience, idiomatic Swift libraries don&#39;t center that much around classes, and especially not around class inheritance.  Value types are usually a better and more efficient data representation than juggling shared mutable state, and protocols are a cleaner and much more robust tool for polymorphism than overriding methods.  Classes are useful for modeling values with &quot;identity&quot;, but even then, the class itself can often be final: when its operations need to be polymorphic, it&#39;s usually better to just pass in a closure or an existential, because piling up overrides turns code into spaghetti very quickly.<br></p><p>That doesn&#39;t mean we don&#39;t want to add good tools for classes, of course, but inheritance and overriding have a lot of subtle interactions, both at a low level with other language features and at a high level with any attempt to establish basic object invariants.  Programmers want an endless variety of language tools for ensuring that overrides satisfy the contract correctly — &quot;require the super method to be called&quot;, &quot;require the super method to be called in exactly this way&quot;, &quot;require the super method to be called unless the method exits early&quot;, &quot;only allow calls to these specific other methods&quot;, &quot;require this method to be called before doing anything else&quot;, ad infinitum.  The only way we could possibly support all that is by first adding some massive new contracts feature and then embellishing it with a ton of inheritance-specific logic; in other words, everything with classes quickly balloons into a a huge research project, because (in my opinion) overriding is just an inherently clumsy tool.<br></p><p>So when you look at something like &#39;sealed&#39; as an opt-in modifier, you have to think carefully about who is actually going to use it.  It&#39;s an explicit modifier that limits inheritance, but we already have &#39;final&#39;, so it&#39;s only useful when the library wants to provide its own private subclasses, but doesn&#39;t want to commit to full public inheritability.  How often does that happen, really?  Are we adding this feature for a handful of developers in the entire world, most of whom could probably find another solution to their problem?  And that&#39;s for &#39;sealed&#39; on a class — are we really supposed to expect that someone will unseal a class, but individually protect all the methods and properties they don&#39;t want overridden?<br></p><p>In contrast, &#39;sealed&#39; as a default is a conservative protection against forgetting to add &#39;final&#39; (which will quickly get caught if the class is truly meant to be subclassed), and applied method-by-method it encourages the developer to think carefully about where they want the extension points to be on their class.  Moreover, it enables a number of interesting language enhancements which can only be done safely with complete knowledge of the inheritance tree, and it significantly improves performance without adding any invasive annotations.  And because it&#39;s already there as the default behavior, that handful of developers who actually need it specifically can get it for free.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 1:21 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:17 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 29, 2016, at 8:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default<br>&gt;&gt; <br>&gt;&gt; What a jump... I am very curious about this rational that seems so obvious to you?<br>&gt; <br>&gt; There are a thousand different ways to add minor variations on language features.  In almost every single thread of any length on this list, you can find someone who got attached to a slightly different feature from the one that eventually got picked, and often you can find them asking why we didn&#39;t just add that, too, maybe under a different name or using different syntax.  If we added every single one of those, the language would not be better, it would just be absurdly, dauntingly complex.  We have to look at these kinds of additive features with a very critical eye and decide how much code will really benefit from it.<br>&gt; <br>&gt; In our experience, idiomatic Swift libraries don&#39;t center that much around classes, and especially not around class inheritance.  Value types are usually a better and more efficient data representation than juggling shared mutable state, and protocols are a cleaner and much more robust tool for polymorphism than overriding methods.  Classes are useful for modeling values with &quot;identity&quot;, but even then, the class itself can often be final: when its operations need to be polymorphic, it&#39;s usually better to just pass in a closure or an existential, because piling up overrides turns code into spaghetti very quickly.<br>&gt; <br>&gt; That doesn&#39;t mean we don&#39;t want to add good tools for classes, of course, but inheritance and overriding have a lot of subtle interactions, both at a low level with other language features and at a high level with any attempt to establish basic object invariants.  Programmers want an endless variety of language tools for ensuring that overrides satisfy the contract correctly — &quot;require the super method to be called&quot;, &quot;require the super method to be called in exactly this way&quot;, &quot;require the super method to be called unless the method exits early&quot;, &quot;only allow calls to these specific other methods&quot;, &quot;require this method to be called before doing anything else&quot;, ad infinitum.  The only way we could possibly support all that is by first adding some massive new contracts feature and then embellishing it with a ton of inheritance-specific logic; in other words, everything with classes quickly balloons into a a huge research project, because (in my opinion) overriding is just an inherently clumsy tool.<br>&gt; <br>&gt; So when you look at something like &#39;sealed&#39; as an opt-in modifier, you have to think carefully about who is actually going to use it.  It&#39;s an explicit modifier that limits inheritance, but we already have &#39;final&#39;, so it&#39;s only useful when the library wants to provide its own private subclasses, but doesn&#39;t want to commit to full public inheritability.  How often does that happen, really?  Are we adding this feature for a handful of developers in the entire world, most of whom could probably find another solution to their problem?  And that&#39;s for &#39;sealed&#39; on a class — are we really supposed to expect that someone will unseal a class, but individually protect all the methods and properties they don&#39;t want overridden?<br>&gt; <br>&gt; In contrast, &#39;sealed&#39; as a default is a conservative protection against forgetting to add &#39;final&#39; (which will quickly get caught if the class is truly meant to be subclassed), and applied method-by-method it encourages the developer to think carefully about where they want the extension points to be on their class.  Moreover, it enables a number of interesting language enhancements which can only be done safely with complete knowledge of the inheritance tree, and it significantly improves performance without adding any invasive annotations.  And because it&#39;s already there as the default behavior, that handful of developers who actually need it specifically can get it for free.<br>&gt; <br>&gt; John.<br></p><p>100% agree. Sealed-by-default is the only thing that makes sense to me at module boundaries and would obsolete the use of final-like keywords as magical performance tools. I was dismayed to see “final” added out of performance necessity and would love to see it return to a pure role as an API constraint.<br></p><p>To me, module is about what parts of the system can be compiled independently and support binary distribution. That’s being conflated with source distribution, but it should be possible to separate those concerns.<br></p><p>Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 11:07 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; On Jun 30, 2016, at 1:21 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 10:17 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 8:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What a jump... I am very curious about this rational that seems so obvious to you?<br>&gt;&gt; <br>&gt;&gt; There are a thousand different ways to add minor variations on language features.  In almost every single thread of any length on this list, you can find someone who got attached to a slightly different feature from the one that eventually got picked, and often you can find them asking why we didn&#39;t just add that, too, maybe under a different name or using different syntax.  If we added every single one of those, the language would not be better, it would just be absurdly, dauntingly complex.  We have to look at these kinds of additive features with a very critical eye and decide how much code will really benefit from it.<br>&gt;&gt; <br>&gt;&gt; In our experience, idiomatic Swift libraries don&#39;t center that much around classes, and especially not around class inheritance.  Value types are usually a better and more efficient data representation than juggling shared mutable state, and protocols are a cleaner and much more robust tool for polymorphism than overriding methods.  Classes are useful for modeling values with &quot;identity&quot;, but even then, the class itself can often be final: when its operations need to be polymorphic, it&#39;s usually better to just pass in a closure or an existential, because piling up overrides turns code into spaghetti very quickly.<br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t mean we don&#39;t want to add good tools for classes, of course, but inheritance and overriding have a lot of subtle interactions, both at a low level with other language features and at a high level with any attempt to establish basic object invariants.  Programmers want an endless variety of language tools for ensuring that overrides satisfy the contract correctly — &quot;require the super method to be called&quot;, &quot;require the super method to be called in exactly this way&quot;, &quot;require the super method to be called unless the method exits early&quot;, &quot;only allow calls to these specific other methods&quot;, &quot;require this method to be called before doing anything else&quot;, ad infinitum.  The only way we could possibly support all that is by first adding some massive new contracts feature and then embellishing it with a ton of inheritance-specific logic; in other words, everything with classes quickly balloons into a a huge research project, because (in my opinion) overriding is just an inherently clumsy tool.<br>&gt;&gt; <br>&gt;&gt; So when you look at something like &#39;sealed&#39; as an opt-in modifier, you have to think carefully about who is actually going to use it.  It&#39;s an explicit modifier that limits inheritance, but we already have &#39;final&#39;, so it&#39;s only useful when the library wants to provide its own private subclasses, but doesn&#39;t want to commit to full public inheritability.  How often does that happen, really?  Are we adding this feature for a handful of developers in the entire world, most of whom could probably find another solution to their problem?  And that&#39;s for &#39;sealed&#39; on a class — are we really supposed to expect that someone will unseal a class, but individually protect all the methods and properties they don&#39;t want overridden?<br>&gt;&gt; <br>&gt;&gt; In contrast, &#39;sealed&#39; as a default is a conservative protection against forgetting to add &#39;final&#39; (which will quickly get caught if the class is truly meant to be subclassed), and applied method-by-method it encourages the developer to think carefully about where they want the extension points to be on their class.  Moreover, it enables a number of interesting language enhancements which can only be done safely with complete knowledge of the inheritance tree, and it significantly improves performance without adding any invasive annotations.  And because it&#39;s already there as the default behavior, that handful of developers who actually need it specifically can get it for free.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; 100% agree. Sealed-by-default is the only thing that makes sense to me at module boundaries and would obsolete the use of final-like keywords as magical performance tools. I was dismayed to see “final” added out of performance necessity and would love to see it return to a pure role as an API constraint.<br>&gt; <br>&gt; To me, module is about what parts of the system can be compiled independently and support binary distribution. That’s being conflated with source distribution, but it should be possible to separate those concerns.<br></p><p>Agreed.  Where we do have source distributions of modules, we should of course take advantage of the fact that we&#39;re compiling things together, but ultimately we want binary modules to be as efficient as possible.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 30, 2016, at 1:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; On Jun 30, 2016, at 11:07 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 30, 2016, at 1:21 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:17 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 8:39 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about `public(extensible)` ?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 29.06.2016 21:32, John McCall via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 11:16 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If &quot;sealed&quot; is the default behavior for public classes and methods — and I don&#39;t think the modifier is worth adding unless it&#39;s the default<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What a jump... I am very curious about this rational that seems so obvious to you?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a thousand different ways to add minor variations on language features.  In almost every single thread of any length on this list, you can find someone who got attached to a slightly different feature from the one that eventually got picked, and often you can find them asking why we didn&#39;t just add that, too, maybe under a different name or using different syntax.  If we added every single one of those, the language would not be better, it would just be absurdly, dauntingly complex.  We have to look at these kinds of additive features with a very critical eye and decide how much code will really benefit from it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In our experience, idiomatic Swift libraries don&#39;t center that much around classes, and especially not around class inheritance.  Value types are usually a better and more efficient data representation than juggling shared mutable state, and protocols are a cleaner and much more robust tool for polymorphism than overriding methods.  Classes are useful for modeling values with &quot;identity&quot;, but even then, the class itself can often be final: when its operations need to be polymorphic, it&#39;s usually better to just pass in a closure or an existential, because piling up overrides turns code into spaghetti very quickly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn&#39;t mean we don&#39;t want to add good tools for classes, of course, but inheritance and overriding have a lot of subtle interactions, both at a low level with other language features and at a high level with any attempt to establish basic object invariants.  Programmers want an endless variety of language tools for ensuring that overrides satisfy the contract correctly — &quot;require the super method to be called&quot;, &quot;require the super method to be called in exactly this way&quot;, &quot;require the super method to be called unless the method exits early&quot;, &quot;only allow calls to these specific other methods&quot;, &quot;require this method to be called before doing anything else&quot;, ad infinitum.  The only way we could possibly support all that is by first adding some massive new contracts feature and then embellishing it with a ton of inheritance-specific logic; in other words, everything with classes quickly balloons into a a huge research project, because (in my opinion) overriding is just an inherently clumsy tool.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So when you look at something like &#39;sealed&#39; as an opt-in modifier, you have to think carefully about who is actually going to use it.  It&#39;s an explicit modifier that limits inheritance, but we already have &#39;final&#39;, so it&#39;s only useful when the library wants to provide its own private subclasses, but doesn&#39;t want to commit to full public inheritability.  How often does that happen, really?  Are we adding this feature for a handful of developers in the entire world, most of whom could probably find another solution to their problem?  And that&#39;s for &#39;sealed&#39; on a class — are we really supposed to expect that someone will unseal a class, but individually protect all the methods and properties they don&#39;t want overridden?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In contrast, &#39;sealed&#39; as a default is a conservative protection against forgetting to add &#39;final&#39; (which will quickly get caught if the class is truly meant to be subclassed), and applied method-by-method it encourages the developer to think carefully about where they want the extension points to be on their class.  Moreover, it enables a number of interesting language enhancements which can only be done safely with complete knowledge of the inheritance tree, and it significantly improves performance without adding any invasive annotations.  And because it&#39;s already there as the default behavior, that handful of developers who actually need it specifically can get it for free.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; 100% agree. Sealed-by-default is the only thing that makes sense to me at module boundaries and would obsolete the use of final-like keywords as magical performance tools. I was dismayed to see “final” added out of performance necessity and would love to see it return to a pure role as an API constraint.<br>&gt;&gt; <br>&gt;&gt; To me, module is about what parts of the system can be compiled independently and support binary distribution. That’s being conflated with source distribution, but it should be possible to separate those concerns.<br>&gt; <br>&gt; Agreed.  Where we do have source distributions of modules, we should of course take advantage of the fact that we&#39;re compiling things together<br></p><p>I&#39;m really looking forward to that! (along with Xcode support for the package manager)<br></p><p>&gt; , but ultimately we want binary modules to be as efficient as possible.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I actually thought about something like &#39;public(final)&#39; as it may make<br>it clearer the intention to the class (and no new keywords were<br>introduced).<br></p><p>Also I think we should draw a guideline for such naming because there<br>are always so many suggestions. Having a guideline would reduce our<br>efforts in choosing names.<br></p><p>L<br></p><p>On 29 June 2016 at 15:16, Michael Peternell via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt; &gt;&gt; -1 for making it default.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt; &gt; So there is nothing left to do :)<br>&gt;&gt;<br>&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>June 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 29 juin 2016 à 21:41, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I actually thought about something like &#39;public(final)&#39; as it may make<br>&gt; it clearer the intention to the class (and no new keywords were<br>&gt; introduced).<br></p><p>I also though about public(final), but it may be confused with &quot;public final&quot; which can be used to defined a class final even in the module scope.<br></p><p>&gt; Also I think we should draw a guideline for such naming because there<br>&gt; are always so many suggestions. Having a guideline would reduce our<br>&gt; efforts in choosing names.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; On 29 June 2016 at 15:16, Michael Peternell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Do you mean `public(unsealed)`? Because `internal(unsealed)` doesn&#39;t really make sense. `internal` declarations are always sealed.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.06.2016 um 20:11 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we really need a new keyword? Since we already have syntax like `internal(set)` couldn&#39;t we do `internal(unsealed)`, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 12:21 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 12:15 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 29.06.2016 um 15:54 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 for the concept of a &quot;sealed” class.<br>&gt;&gt;&gt;&gt;&gt; -1 for making it default.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Aren&#39;t sealed classes already implemented? I think the keyword is `final`..<br>&gt;&gt;&gt;&gt; So there is nothing left to do :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, `final` doesn’t allow for any subclassing, but `sealed` allows for subclassing within your module (where you can presumably write more efficient code based on knowledge of each subclass).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
