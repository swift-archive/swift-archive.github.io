<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: failable numeric conversion initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>Problem:<br>Swift numeric types all currently have a family of conversion initializers.  In many use cases they leave a lot to be desired.  Initializing an integer type with a floating point value will truncate any fractional portion of the number.  Initializing with an out-of-range value traps.  <br></p><p>Solution:<br></p><p>Sometimes it would be more desirable to convert the runtime value if it can be done without losing information (or possibly with only minimal loss of precision when initializing a floating point type).  This could be easily accomplished if the standard library had a family of failable initializers for all numeric types, either returning an Optional or throwing when the initialization was not successful.  <br></p><p>I prefer the throwing version because failure can be automatically propagated up the call stack and the error could capture value that was provided and the type that failed to initialize which may be useful when debugging.  Also, `try?` allows callers to throw away the error if the detail isn‚Äôt necessary.  However, the Optional version would provide the basic functionality that is desired and would be sufficient if the community likes it better.<br></p><p>//  Conversions from all integer types.<br>init?(_ value: Int8)<br>init?(_ value: Int16)<br>init?(_ value: Int32)<br>init?(_ value: Int64)<br>init?(_ value: Int)<br>init?(_ value: UInt8)<br>init?(_ value: UInt16)<br>init?(_ value: UInt32)<br>init?(_ value: UInt64)<br>init?(_ value: UInt)<br></p><p>//  Conversions from all floating-point types.<br>init?(_ value: Float)<br>init?(_ value: Double)<br>#if arch(i386) || arch(x86_64)<br>init?(_ value: Float80)<br>#endif<br></p><p>OR<br></p><p>//  Conversions from all integer types.<br>init(_ value: Int8) throws<br>init(_ value: Int16) throws<br>init(_ value: Int32) throws<br>init(_ value: Int64) throws<br>init(_ value: Int) throws<br>init(_ value: UInt8) throws<br>init(_ value: UInt16) throws<br>init(_ value: UInt32) throws<br>init(_ value: UInt64) throws<br>init(_ value: UInt) throws<br></p><p>//  Conversions from all floating-point types.<br>init(_ value: Float) throws<br>init(_ value: Double) throws<br>#if arch(i386) || arch(x86_64)<br>init(_ value: Float80) throws<br>#endif<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: failable numeric conversion initializers</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  6, 2015 at 03:00:00pm</p></header><div class="content"><p>On Sun, Dec 6, 2015 at 11:28 AM, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Problem:<br>&gt; Swift numeric types all currently have a family of conversion initializers.  In many use cases they leave a lot to be desired.  Initializing an integer type with a floating point value will truncate any fractional portion of the number.  Initializing with an out-of-range value traps.<br>&gt;<br>&gt; Solution:<br>&gt;<br>&gt; Sometimes it would be more desirable to convert the runtime value if it can be done without losing information (or possibly with only minimal loss of precision when initializing a floating point type).  This could be easily accomplished if the standard library had a family of failable initializers for all numeric types, either returning an Optional or throwing when the initialization was not successful.<br>&gt;<br>&gt; I prefer the throwing version because failure can be automatically propagated up the call stack and the error could capture value that was provided and the type that failed to initialize which may be useful when debugging.  Also, `try?` allows callers to throw away the error if the detail isn‚Äôt necessary.  However, the Optional version would provide the basic functionality that is desired and would be sufficient if the community likes it better.<br>&gt;<br>&gt; //  Conversions from all integer types.<br>&gt; init?(_ value: Int8)<br>&gt; init?(_ value: Int16)<br>&gt; init?(_ value: Int32)<br>&gt; init?(_ value: Int64)<br>&gt; init?(_ value: Int)<br>&gt; init?(_ value: UInt8)<br>&gt; init?(_ value: UInt16)<br>&gt; init?(_ value: UInt32)<br>&gt; init?(_ value: UInt64)<br>&gt; init?(_ value: UInt)<br></p><p>One issue is that these initializers already exist with the signature<br>&#39;init(_ value: IntXYZ)&#39;.  Adding these failable initializers would<br>make code like the following ambiguous:<br></p><p>var u8 = getUInt8()<br>var myInt = Int(u8)<br></p><p>We need a label to distinguish these.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Proposal: failable numeric conversion initializers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>The throwing ones might use &quot;strict&quot;, or something similar, i.e.<br></p><p>init(strict value: Int64) throws<br></p><p>-Thorsten<br></p><p>&gt; Am 07.12.2015 um 00:55 schrieb Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Sun, Dec 6, 2015 at 11:28 AM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Problem:<br>&gt;&gt; Swift numeric types all currently have a family of conversion initializers.  In many use cases they leave a lot to be desired.  Initializing an integer type with a floating point value will truncate any fractional portion of the number.  Initializing with an out-of-range value traps.<br>&gt;&gt; <br>&gt;&gt; Solution:<br>&gt;&gt; <br>&gt;&gt; Sometimes it would be more desirable to convert the runtime value if it can be done without losing information (or possibly with only minimal loss of precision when initializing a floating point type).  This could be easily accomplished if the standard library had a family of failable initializers for all numeric types, either returning an Optional or throwing when the initialization was not successful.<br>&gt;&gt; <br>&gt;&gt; I prefer the throwing version because failure can be automatically propagated up the call stack and the error could capture value that was provided and the type that failed to initialize which may be useful when debugging.  Also, `try?` allows callers to throw away the error if the detail isn‚Äôt necessary.  However, the Optional version would provide the basic functionality that is desired and would be sufficient if the community likes it better.<br>&gt;&gt; <br>&gt;&gt; //  Conversions from all integer types.<br>&gt;&gt; init?(_ value: Int8)<br>&gt;&gt; init?(_ value: Int16)<br>&gt;&gt; init?(_ value: Int32)<br>&gt;&gt; init?(_ value: Int64)<br>&gt;&gt; init?(_ value: Int)<br>&gt;&gt; init?(_ value: UInt8)<br>&gt;&gt; init?(_ value: UInt16)<br>&gt;&gt; init?(_ value: UInt32)<br>&gt;&gt; init?(_ value: UInt64)<br>&gt;&gt; init?(_ value: UInt)<br>&gt; <br>&gt; One issue is that these initializers already exist with the signature<br>&gt; &#39;init(_ value: IntXYZ)&#39;.  Adding these failable initializers would<br>&gt; make code like the following ambiguous:<br>&gt; <br>&gt; var u8 = getUInt8()<br>&gt; var myInt = Int(u8)<br>&gt; <br>&gt; We need a label to distinguish these.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/e439482c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: failable numeric conversion initializers</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 7:49 AM, thorsten at portableinnovations.de<br>&lt;thorsten at portableinnovations.de&gt; wrote:<br>&gt; The throwing ones might use &quot;strict&quot;, or something similar, i.e.<br>&gt;<br>&gt; init(strict value: Int64) throws<br></p><p>Well, choosing that word is very important :)  &quot;strict&quot; does not imply<br>&quot;throwing&quot; to me, FWIW, it is more like &quot;lossless&quot; than &quot;throwing&quot;.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: failable numeric conversion initializers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>If we‚Äôre going to bikeshed (üòÄ), I have a strong preference for ‚Äúexact‚Äù for this usage.  There would need to be a good reason to diverge from the widely-used IEEE 754 terminology.<br></p><p>&gt; On Dec 7, 2015, at 12:50 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 7, 2015 at 7:49 AM, thorsten at portableinnovations.de<br>&gt; &lt;thorsten at portableinnovations.de&gt; wrote:<br>&gt;&gt; The throwing ones might use &quot;strict&quot;, or something similar, i.e.<br>&gt;&gt; <br>&gt;&gt; init(strict value: Int64) throws<br>&gt; <br>&gt; Well, choosing that word is very important :)  &quot;strict&quot; does not imply<br>&gt; &quot;throwing&quot; to me, FWIW, it is more like &quot;lossless&quot; than &quot;throwing&quot;.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: failable numeric conversion initializers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>I personally don&#39;t care what the argument label is (or even if this functionality is achieved through other means as Chris indicated a preference for).  I just want the language to support failable numeric conversions in some way or another.  <br></p><p>That said, if we do add such initializers and IEEE has a terminology for this it seems like a no-brainier to use it.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 7, 2015, at 12:21 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If we‚Äôre going to bikeshed (üòÄ), I have a strong preference for ‚Äúexact‚Äù for this usage.  There would need to be a good reason to diverge from the widely-used IEEE 754 terminology.<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:50 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 7:49 AM, thorsten at portableinnovations.de<br>&gt;&gt; &lt;thorsten at portableinnovations.de&gt; wrote:<br>&gt;&gt;&gt; The throwing ones might use &quot;strict&quot;, or something similar, i.e.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(strict value: Int64) throws<br>&gt;&gt; <br>&gt;&gt; Well, choosing that word is very important :)  &quot;strict&quot; does not imply<br>&gt;&gt; &quot;throwing&quot; to me, FWIW, it is more like &quot;lossless&quot; than &quot;throwing&quot;.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
