<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Is there an underlying reason why optional protocol requirements need @objc? (from -dev)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  5, 2016 at 08:00:00am</p></header><div class="content"><p>on Fri Mar 04 2016, Shawn Erickson &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; (Sorry I hate top posting but fighting with Google inbox to avoid it)<br>&gt;<br>&gt; In delegation patterns it can be very helpful in terms of optimization<br>&gt; (performance and memory) if the delegator can interrogate a delegate to<br>&gt; know if certain delegation points are needed or not. I have code that has<br>&gt; done this interrogation at delegate registration allowing potentially<br>&gt; complex code paths and/or state maintenance to be avoided. <br></p><p>There&#39;s always a way to do this kind of thing without making the<br>requirement itself optional.  For example, you can wrap the return type<br>in an Optional and have the default implementation always return nil, or<br>you can have the method accept a closure passed by the caller that<br>represents the extra work one would have to do in case the “optional<br>requirement” were supplied, and make sure it&#39;s called in any non-default<br>implementation, etc.<br></p><p>&gt; It also could do impl caching to improve dispatch (did not support<br>&gt; after registration &quot;reconfiguring&quot; delegates in this model purposely).<br>&gt;<br>&gt; Under objective-c leveraging optional protocol methods and runtime checks<br>&gt; for responds to those was one built-in way for that. It also could add<br>&gt; boilerplate code to check before dispatch that was potentially error prone<br>&gt; and cumbersome. ...hence why I often did the check and configuration at<br>&gt; registration in my code often avoiding peppering code with dispatch checks.<br></p><p>Not sure what you have in mind in any of the text above; I think I&#39;d<br>need to see examples.<br></p><p>&gt; Anyway not attempting to state anything for against this question about<br>&gt; optional requirements in swift protocols. ...a handful of reasonable<br>&gt; patterns exist in swift that allows one to achieve the same thing in safer<br>&gt; and likely more performant ways.<br></p><p>IMO “optional requirements” only express things that can already be<br>expressed in other ways, add complexity to the language, weaken the<br>concept of what a protocol is, and worst of all, encourage the creation<br>of weak abstractions.  I don&#39;t doubt they&#39;ve been useful to people in<br>the past but that doesn&#39;t mean they should be in the language.<br></p><p>It sounds on the surface like maybe you don&#39;t disagree with me here, in<br>which case there&#39;s not much more to say about it(?)<br></p><p>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Fri, Mar 4, 2016 at 9:38 AM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Mar 04 2016, Shawn Erickson &lt;shawnce-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Well one missed aspect is that the delegator can test if the delegate<br>&gt;&gt; &gt; responds to the method and modify its logic to adjust to the reality<br>&gt;&gt; (which<br>&gt;&gt; &gt; could have reasonable optimization hanging off it). If you depend on<br>&gt;&gt; &gt; default no-op you don&#39;t get that ability (at least as &quot;easily&quot;). ...it of<br>&gt;&gt; &gt; course is intertwined with the runtime capabilities of objective-c.<br>&gt;&gt;<br>&gt;&gt; All that testing puts too much burden on the client, IMO.  It&#39;s much<br>&gt;&gt; better to provide customization points with default behaviors that work<br>&gt;&gt; sensibly when not overridden.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Fri, Mar 4, 2016 at 9:16 AM Erica Sadun via swift-dev &lt;<br>&gt;&gt; &gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; On Mar 4, 2016, at 9:25 AM, Dave Abrahams via swift-dev &lt;<br>&gt;&gt; &gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; on Fri Mar 04 2016, Simon Pilkington &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; This seems like a strange/unrelated restriction on what is quite a<br>&gt;&gt; &gt;&gt; useful feature.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; ...or an abomination.  What sense does “optional requirement” make,<br>&gt;&gt; &gt;&gt; &gt; after all?!<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; However oxymoronic,  I kind of get the point. If you want default no-op<br>&gt;&gt; &gt;&gt; behaviors, with<br>&gt;&gt; &gt;&gt; the option to override, which is what optional Objective-C requirements<br>&gt;&gt; &gt;&gt; really are, just<br>&gt;&gt; &gt;&gt; create protocol extensions.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; extension MyProtocol {<br>&gt;&gt; &gt;&gt;    func optionalMember() {} // nothing to do<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This guarantees that the member exists, can be called by all consumers,<br>&gt;&gt; &gt;&gt; but that there&#39;s a<br>&gt;&gt; &gt;&gt; default in place that frees the conforming type from actually having to<br>&gt;&gt; &gt;&gt; implement anything<br>&gt;&gt; &gt;&gt; unless it really wants to.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -- E<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; &gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
