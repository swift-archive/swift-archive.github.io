<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>Automatic protocol forwarding<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-automatic-protocol-forwarding.md&gt;<br>Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>Status: Review<br>Review manager: TBD<br>Introduction<br></p><p>Automatic protocol forwarding introduces the ability to use delegation without the need write forwarding member implementations manually. <br></p><p>A preliminary mailing list thread on this topic had the subject protocol based invocation forwarding &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000931.html&gt;<br>Motivation<br></p><p>Delegation is a robust, composition oriented design technique that keeps interface and implementation inheritance separate. The primary drawback to this technique is that it requires a lot of manual boilerplate to forward implemenation to the implementing member. This proposal eliminates the need to write such boilerplate manually, thus making delegation-based designs much more convenient and attractive.<br></p><p>This proposal may also serve as the foundation for a future enhancement allowing a very concise “newtype” declaration.<br></p><p>Proposed solution<br></p><p>I propose introducing a forward declaration be allowed within a type declaration or type extension. The forward declaration will cause the compiler to synthesize implementations of the members required by the forwarded protocols. The synthesized implementations will simply forward the method call to the specified member.<br></p><p>The basic declaration looks like this:<br></p><p>forward Protocol, OtherProtocol to memberIdentifier<br>The first clause contains a list of protocols to forward. <br></p><p>The second clause specifies the identifier of the property to which the protocol members will be forwarded. Any visible property that implements the members required by the protocol is eligible for forwarding. It does not matter whether it is stored, computed, lazy, etc.<br></p><p>It is also possible to include an access control declaration modifier to specify the visibility of the synthesized members.<br></p><p>Self parameters<br></p><p>When a protocol member includes a Self parameter forwarding implementations must accept the forwarding type but supply an argument of the forwardee type when making the forwarding call. The most straightforward way to do this is to simply use the same property getter that is used when forwarding. This is the proposed solution.<br></p><p>Self return types<br></p><p>When a protocol member includes a Self return type forwarding implementations must return the forwarding type. However, the forwardee implmentation will return a value of the forwardee type. This result must be used to produce a value of the forwarding type in some way.<br></p><p>The solution in this proposal is based on an ad-hoc overloading convention. A protocol-based solution would probably be desirable if it were possible, however it is not. This proposal supports forwarding to more than one member, possibly with different types. A protocol-based solution would require the forwarding type to conform to the “Self return value conversion” protocol once for each forwardee type.<br></p><p>Static members<br></p><p>When a forwardee value is returned from a static member an initializer will be used to produce a final return value. The initializer must be visible at the source location of the forward declaration and must look like this:<br></p><p>struct Forwarder {<br>    let forwardee: Forwardee<br>    forward P to forwardee<br>    init(_ forwardeeReturnValue: Forwardee) { //... }<br>}<br>Instance members<br></p><p>When a forwardee value is returned from an instance member an instance method will be used to transform the return value into a value of the correct type. An instance method is necessary in order to allow the forwarding type to access the state of the instance upon which the method was called when performing the transformation.<br></p><p>If the instance method is not implemented the initializer used for static members will be used instead.<br></p><p>The transformation has the form:<br></p><p>struct Forwarder {<br>    let forwardee: Forwardee<br>    forward P to forwardee<br>    func transformedForwardingReturnValue(forwardeeReturnValue: Forwardee) -&gt; Forwarder { //... }<br>}<br>NOTE: This method should have a better name. Suggestions are appreciated!<br></p><p>Examples<br></p><p>Basic example<br></p><p>NOTE: Forwardee does not actually conform to P itself. Conformance is not required to synthesize the forwarding member implementations. It is only required that members necessary for forwarding exist. This is particularly important to the second example.<br></p><p>public protocol P {<br>    typealias TA<br>    var i: Int<br>    func foo() -&gt; Bool<br>}<br></p><p>private struct Forwardee {<br>    typealias TA = String<br>    var i: Int = 42<br>    func foo() -&gt; Bool { return true }<br>}<br></p><p>public struct Forwarder {<br>    private let forwardee: Forwardee<br>}<br></p><p>extension Forwarder: P {	<br>    // user declares<br>    public forward P to forwardee<br>    <br>    // compiler synthesizes<br>    // TA must be synthesized as it cannot be inferred for this protocol<br>    public typealias TA = String <br>    public var i: Int {<br>        get { return forwardee.i }<br>        set { forwardee.i = newValue }<br>    }<br>    public func foo() -&gt; Bool { <br>        return forwardee.foo() <br>    }<br>}<br>Existential forwardee<br></p><p>NOTE: Existentials of type P do not actually conform to P itself. Conformance is not required to synthesize the forwarding member implementations. It is only required that members necessary for forwarding exist.<br></p><p>public protocol P {<br>    func foo() -&gt; Bool<br>}<br></p><p>struct S: P {<br>    private let p: P<br>    <br>    // user declares:<br>    forward P to p<br>    <br>    // compiler synthesizes:<br>    func foo() -&gt; Bool {<br>        return p.foo()<br>    }<br>}<br>Self parameters<br></p><p>public protocol P {<br>    func foo(value: Self) -&gt; Bool<br>}<br></p><p>extension Int: P {<br>    func foo(value: Int) -&gt; Bool {<br>        return value != self<br>    }<br>}<br></p><p>struct S: P {<br>    private let i: Int<br>    <br>    // user declares:<br>    forward P to i<br>    <br>    // compiler synthesizes:<br>    func foo(value: S) -&gt; Bool {<br>        return i.foo(value.i)<br>    }<br>}<br>Self return types<br></p><p>Using the instance method:<br></p><p>public protocol P {<br>    func foo() -&gt; Self<br>}<br></p><p>extension Int: P {<br>    func foo() -&gt; Int {<br>        return self + 1<br>    }<br>}<br></p><p>struct S: P {<br>    private let i: Int<br>    func transformedForwardingReturnValue(forwardeeReturnValue: Int) -&gt; S {<br>        return S(i: forwardeeReturnValue)<br>    }<br>    <br>    // user declares:<br>    forward P to i<br>    <br>    // compiler synthesizes:<br>    func foo() -&gt; S {<br>        return self.transformedForwardingReturnValue(i.foo())<br>    }<br>}<br>Using the initializer:<br></p><p>public protocol P {<br>    func foo() -&gt; Self<br>}<br></p><p>extension Int: P {<br>    func foo() -&gt; Int {<br>        return self + 1<br>    }<br>}<br></p><p>struct S: P {<br>    private let i: Int<br>    init(_ value: Int) {<br>        i = value<br>    }<br>    <br>    // user declares:<br>    forward P to i<br>    <br>    // compiler synthesizes:<br>    func foo() -&gt; S {<br>        return S(i.foo())<br>    }<br>}<br>Forwarding multiple protocols<br></p><p>public protocol P {<br>    func foo() -&gt; Bool<br>}<br>public protocol Q {<br>    func bar() -&gt; Bool<br>}<br></p><p>extension Int: P, Q {<br>    func foo() -&gt; Bool {<br>        return true<br>    }<br>    func bar() -&gt; Bool {<br>        return false<br>    }<br>}<br></p><p>struct S: P, Q {<br>    private let i: Int<br>    <br>    // user declares:<br>    forward P, Q to i<br>    <br>    // compiler synthesizes:<br>    func foo() -&gt; Bool {<br>        return i.foo()<br>    }<br>    func bar() -&gt; Bool {<br>        return i.bar()<br>    }<br>}<br>Forwarding to multiple members<br></p><p>public protocol P {<br>    func foo() -&gt; Bool<br>}<br>public protocol Q {<br>    func bar() -&gt; Bool<br>}<br></p><p>extension Int: P {<br>    func foo() -&gt; Bool {<br>        return true<br>    }<br>}<br>extension Double: Q {<br>    func bar() -&gt; Bool {<br>        return false<br>    }<br>}<br></p><p>struct S: P, Q {<br>    private let i: Int<br>    private let d: Double<br>    <br>    // user declares:<br>    forward P to i<br>    forward Q to d<br>    <br>    // compiler synthesizes:<br>    func foo() -&gt; Bool {<br>        return i.foo()<br>    }<br>    func bar() -&gt; Bool {<br>        return d.bar()<br>    }<br>}<br>Non-final class<br></p><p>NOTE: C cannot declare conformance to the protocol due to the Self return value requirement. However, the compiler still synthesizes the forwarding methods and allows them to be used directly by users of C.<br></p><p>public protocol P {<br>    func foo() -&gt; Self<br>}<br></p><p>extension Int: P {<br>    func foo() -&gt; Int {<br>        return self + 1<br>    }<br>}<br></p><p>// C does not and cannot declare conformance to P<br>class C {<br>    private let i: Int<br>    init(_ value: Int) {<br>        i = value<br>    }<br>    <br>    // user declares:<br>    forward P to i<br>    <br>    // compiler synthesizes:<br>    func foo() -&gt; C {<br>        return C(i.foo())<br>    }<br>}<br>Detailed design<br></p><p>TODO: grammar modification to add the forward declaration<br></p><p>Automatic forwarding only synthesizes member implementations. It does not automatically conform the forwarding type to the protocol(s) that are forwarded. If actual conformance is desired (as it usually will be) it must be explicitly stated.<br>The forwardee type need not actually conform to the protocol forwarded to it. It only needs to implement the members the forwarder must access in the synthesized forwarding methods. This is particularly important as long as protocol existentials do not conform to the protocol itself.<br>While it will not be possible to conform non-final classes to protocols containing a Self return type forwarding should still be allowed. The synthesized methods will have a return type of the non-final class which in which the forwarding declaration occured. The synthesized methods may still be useful in cases where actual protocol conformance is not necessary.<br>All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br>TODO: How should other annotations on the forwardee implementations of forwarded members (such as @warn_unused_result) be handled? <br>It is possible that the member implementations synthesized by forwarding will conflict with existing members or with each other (when forwarding more than one protocol). All such conflicts, with one exception, should produce a compiler error at the site of the forwarding declaration which resulted in conflicting members.<br>One specific case that should not be considered a conflict is when forwarding more than one protocol with identical member declarations to the same member of the forwarding type. In this case the synthesized implementation required to forward all of the protocols is identical. The compiler should not synthesize multiple copies of the implementation and then report a redeclaration error.<br>It is likely that any attempt to forward different protocols with Self return types to more than one member of the same type will result in sensible behavior. This should probable be a compiler error. For example:<br>protocol P {<br>    func foo() -&gt; Self<br>}<br>protocol Q {<br>    func bar() -&gt; Self<br>}<br></p><p>struct Forwarder: P, Q {<br>    let d1: Double<br>    let d2: Double<br>    <br>    forward P to d1<br>    forward Q to d2<br></p><p>    func transformedForwardingReturnValue(_ forwardeeReturnValue: Double) -&gt; Forwarder { <br>        // What do we do here?  <br>        // We don&#39;t know if the return value resulted from forwarding foo to d1 or bar to d2.<br>        // It is unlikely that the same behavior is correct in both cases.<br>    }<br>}<br>Impact on existing code<br></p><p>This is a strictly additive change. It has no impact on existing code.<br></p><p>Future enhancements<br></p><p>In the spirit of incremental change, this proposal focuses on core functionality. Several enhancements to the core functionality are possible and are likely to be explored in the future.<br></p><p>Partial forwarding synthesis<br></p><p>The current proposal makes automatic forwarding an “all or nothing” feature. In cases where you want to forward most of the implementation of a set of members but would need to “override” one or more specific members the current proposal will not help. You will still be required to forward the entire protocol manually. Attempting to implement some specific members manually will result in a redeclaration error.<br></p><p>This proposal does not allow partial forwarding synthesis in order to focus on the basic forwarding mechanism and allow us to gain some experience with that first, before considering the best way to make partial forwarding possible without introducing unintended potential for error. One example of a consideration that may apply is whether or not forwardee types should be able to mark members as “final for forwarding” in some way that prevents them from being “overriden” by a forwarder.<br></p><p>Newtype<br></p><p>While the current proposal provides the basic behavior desired for newtype, it is not as concise as it could be. Adding syntactic sugar to make this common case more concise would be straightforward:<br></p><p>// user declares<br>newtype Weight = Double forwarding P, Q<br></p><p>// compiler synthesizes<br>struct Weight: P, Q {<br>    var value: Double<br>    forward P, Q to value<br>    init(_ value: Double) { self.value = value }<br>}<br>However, there are additional nuances related to associated types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004735.html&gt; that should be considered and addressed by a newtype proposal.<br></p><p>Forwarding declaration in protocol extensions<br></p><p>It may be possible to allow the forward declaration in protocol extensions by forwarding to a required property of the protocol. This may have implementation complexities and other implications which would hold back the current proposal if it required the forward declaration to be allowed in protocol extensions. <br></p><p>Alternatives considered<br></p><p>Specify forwarding as part of the member declaration<br></p><p>I originally thought it would make the most sense to specify forwarding alongside the forwardee member declaration. This proposal does not do so for the following reasons:<br></p><p>We must be able to specify access control for the forwarded members that are synthesized. Introducing a forwarding declaration is the most clear way to allow this.<br>It will sometimes be necessary to forward different protocols to the same forwardee with different access control levels. It would be very clunky to do this as part of the member declaration.<br>It should be possible to synthesize forwarding retroactively as part of an extension. This would not be possible if forwarding had to be specified in the original member declaration.<br>Require the forwardee to conform to the protocol(s) forwarded to it<br></p><p>There is not a compelling reason to require this. It is not necessary to synthesize and compile the forwarding methods and it would prevent the use of protocol existentials as the forwardee.<br></p><p>Automatically conform the forwarding type to the forwarded protocol(s)<br></p><p>It may seem reasonable to automatically synthesize conformance to the protocol in addition to the member implementations. This proposal does not do so for the following reasons:<br></p><p>Forwarding is considered an implementation detail that is not necessarily visible in the public interface of the type. The forwardee may be a private member of the type.<br>Type authors may wish to control where the actual conformance is declared, especially if protocol conformances are allowed to have access control in the future.<br>There may be use cases where it is desirable to have the forwarded members synthesized without actually conforming to the protocol. This is somewhat speculative, but there is not a compelling reason to disallow it.<br>Allow forwarding of all protocols conformed to by the forwardee without explicitly listing them<br></p><p>It may seem reasonable to have a * placeholder which will forward all visible protocol conformances of the forwardee type. This proposal does not include such a placeholder for the following reasons:<br></p><p>A placeholder like this could lead to unintended operations being synthesized if additional conformances are declared in the future. The new conformances could even lead to conflicts during synthesis which cause the code to fail to compile. The potential for such breakage is not acceptable.<br>A placeholder like this would not necessarily cause all desired forwarding methods to be synthesized. This would be the case when the members necessary to conform exist but actual conformance does not exist. This would be the case when the forwardee type is an existential. This could lead to programmer confusion.<br>An explicit list of protocols to forward is not unduely burdensome. It is straightforward to declare a new protocol that inherits from a group of protocols which are commonly forwarded together and use the new protocol in the forwarding declaration.<br>This is easily added as a future enhancement to the current proposal if we later decide it is necessary.<br>Allow forwarding of the entire interface of the forwardee type, not just specific protocols<br></p><p>It is impossible to synthesize forwarding of methods which contain the forwardee type as a parameter or return type that are not declared as part of a protocol interface in a correct and safe manner. This is because it may or may not be correct to promote the forwardee type in the signature to the forwarder. <br></p><p>As an example, consider the following extension to Double. Imagine trying to synthesize a forwarding method in a Pixel type that forwards to Double. Should the return type be Pixel or Double? It is impossible to tell for sure.<br></p><p>extension Double {<br>    func foo() -&gt; Double {<br>        return self<br>    }<br>}<br>When the method is declared in a protocol it becomes obvious what the signature of the forwarding method must be. If the protocol declares the return type as Self, the forwarding method must have a return type of Pixel. If the protocol declares the return type as Double the forwarding method will continue to have a return type of Double.<br></p><p>Allow forwarding to Optional members<br></p><p>It may seem like a good idea to allow synthesized forwarding to Optional members where a no-op results when the Optional is nil. There is no way to make this work in general as it would be impossible to forward any member requiring a return value. If use cases for forwarding to Optionalmembers emerege that are restricted to protocols with no members requiring return values the automatic protocol forwarding feature could be enhanced in the future to support these use cases.<br></p><p>Allow forwarding the same protocol(s) to more than one member<br></p><p>As with forwarding to Optional members, forwarding the same protocol to more than one member is not possible in general. However it is possible in cases where no protocol members have a return value. If compelling use cases emerge to motivate automatic forwarding of such protocols to more than one member an enhancement could be proposed in the future.<br></p><p>Provide a mechanism for forwardees to know about the forwarder<br></p><p>Some types may be designed to be used as components that are always forwarded to by other types. Such types may wish to be able to communicate with the forwarding type in some way. This can be accomplished manually. <br></p><p>If general patterns emerge in practice it may be possible to add support for them to the language. However, it would be preliminary to consider support for such a feature until we have significant experience with the basic forwarding mechanism itself.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/6917501d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>I briefly skimmed your proposal, so I apologize if you already addressed<br>this, but it occurs to me that we could support automatic protocol<br>forwarding today on a per-protocol basis simply by declaring a separate<br>protocol that provides default implementations doing the forwarding.<br>Handling of Self return types can then be done by adding a required<br>initializer (or just not implementing that method, so the concrete type<br>is forced to deal with it even though everything else is forwarded).<br></p><p>For example, if I want to automatically forward SequenceType to a<br>member, I can do something like<br></p><p>protocol SequenceTypeForwarder : SequenceType {<br></p><p>typealias ForwardedSequenceType : SequenceType<br></p><p><br></p><p><br>var forwardedSequence : ForwardedSequenceType { get }<br></p><p>}<br></p><p><br></p><p><br>extension SequenceTypeForwarder {<br></p><p>func generate() -&gt; ForwardedSequenceType.Generator {<br></p><p>return forwardedSequence.generate()<br></p><p>}<br></p><p><br></p><p><br>func underestimateCount() -&gt; Int {<br></p><p>return forwardedSequence.underestimateCount()<br></p><p>}<br></p><p><br></p><p><br>func map&lt;T&gt;(@noescape transform:<br>(ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br></p><p>return try forwardedSequence.map(transform)<br></p><p>}<br></p><p><br></p><p><br>func filter(@noescape includeElement:<br>(ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>[ForwardedSequenceType.Generator.Element] {<br></p><p>return try forwardedSequence.filter(includeElement)<br></p><p>}<br></p><p><br></p><p><br>func forEach(@noescape body: (ForwardedSequenceType.Generator.Element)<br>throws -&gt; Void) rethrows {<br></p><p>return try forwardedSequence.forEach(body)<br></p><p>}<br></p><p><br></p><p><br>func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br></p><p>return forwardedSequence.dropFirst(n)<br></p><p>}<br></p><p><br></p><p><br>func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br></p><p>return forwardedSequence.dropLast(n)<br></p><p>}<br></p><p><br></p><p><br>func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br></p><p>return forwardedSequence.prefix(maxLength)<br></p><p>}<br></p><p><br></p><p><br>func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br></p><p>return forwardedSequence.suffix(maxLength)<br></p><p>}<br></p><p><br></p><p><br>func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator:<br>(ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>[ForwardedSequenceType.SubSequence] {<br></p><p>return try forwardedSequence.split(maxSplit, allowEmptySlices:<br>allowEmptySlices, isSeparator: isSeparator)<br></p><p>}<br></p><p>}<br></p><p><br>With this protocol declared, I can then say something like<br></p><p>struct Foo {<br></p><p>var ary: [Int]<br></p><p>}<br></p><p><br></p><p><br>extension Foo : SequenceTypeForwarder {<br></p><p>var forwardedSequence: [Int] { return ary }<br></p><p>}<br></p><p><br>and my struct Foo now automatically implements SequenceType by<br>forwarding to its variable `ary`.<br></p><p>The downside to this is it needs to be manually declared for each<br>protocol. But I wager that most protocols actually aren&#39;t really<br>amenable to forwarding anyway.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/55040fdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>As the resident you-can-already-do-this grumpy guy, I tend to agree that most protocols aren&#39;t easily amenable to forwarding, and this solution works too.<br></p><p>In general, I think that Swift already doesn&#39;t impose too much boilerplate, and I think that most features to reduce boilerplate would be better served by having a sane macro system in Swift. (This is probably not in scope for Swift 3, though.)<br></p><p>Félix<br></p><p>&gt; Le 29 déc. 2015 à 15:06:48, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;  <br>&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;  <br>&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;     typealias ForwardedSequenceType : SequenceType<br>&gt; <br>&gt;     var forwardedSequence : ForwardedSequenceType { get }<br>&gt; }<br>&gt; <br>&gt; extension SequenceTypeForwarder {<br>&gt;     func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;         return forwardedSequence.generate()<br>&gt;     }<br>&gt; <br>&gt;     func underestimateCount() -&gt; Int {<br>&gt;         return forwardedSequence.underestimateCount()<br>&gt;     }<br>&gt; <br>&gt;     func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;         return try forwardedSequence.map(transform)<br>&gt;     }<br>&gt; <br>&gt;     func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;         return try forwardedSequence.filter(includeElement)<br>&gt;     }<br>&gt; <br>&gt;     func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;         return try forwardedSequence.forEach(body)<br>&gt;     }<br>&gt; <br>&gt;     func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.dropFirst(n)<br>&gt;     }<br>&gt; <br>&gt;     func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.dropLast(n)<br>&gt;     }<br>&gt; <br>&gt;     func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.prefix(maxLength)<br>&gt;     }<br>&gt; <br>&gt;     func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.suffix(maxLength)<br>&gt;     }<br>&gt; <br>&gt;     func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;         return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; With this protocol declared, I can then say something like<br>&gt;  <br>&gt; struct Foo {<br>&gt;     var ary: [Int]<br>&gt; }<br>&gt; <br>&gt; extension Foo : SequenceTypeForwarder {<br>&gt;     var forwardedSequence: [Int] { return ary }<br>&gt; }<br>&gt;  <br>&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;  <br>&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/c5cca168/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>Hi Kevin,<br></p><p>Thanks for taking time to look at the proposal.<br></p><p>The technique you show here is not bad, but it has several deficiencies IMO which are addressed by the solution in the proposal.<br></p><p>1. Forwarding should be an implementation detail, not exposed as it is with this method.<br>2. As such, the getter for the forwardee is visible.  The forwardee is an implementation detail that should not be visible in most cases.<br>3. There is no way to specify access control for the synthesized methods and if there were it would be coupled to the access control of the conformance.<br>4. You can&#39;t forward to a type that doesn&#39;t conform to the protocol.  This is particularly important for existential forwardees (at least until they conform to their protocol).<br>5. A type that can&#39;t conform to the protocol can&#39;t forward an implementation of the members of the protocol.  Specifically, non-final classes cannot automatically forward a group of methods to an implementer.<br>6. This solution does not lay the foundation for a newtype feature. It would be possible to have a specialized newtype feature, but why not build it on top of a more general forwarding feature?<br></p><p>You may be right that many protocols are not amenable to forwarding.  The motivation for this proposal is that it enables delegation-based designs to be implemented succinctly.  In that use case the protocols will be designed alongside concrete implementations and types that forward to them.  A secondary motivation for this proposal is to lay a foundation for a newtype feature.  In that case the protocols to be forwarded would be specifically designed to represent the portion of the interface of the wrapped type which should be visible to users of the newtype.<br></p><p>I hope these points might be enough to convince you that it is worth a closer look.<br></p><p>Matthew<br></p><p>&gt; On Dec 29, 2015, at 2:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;  <br>&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;  <br>&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;     typealias ForwardedSequenceType : SequenceType<br>&gt; <br>&gt;     var forwardedSequence : ForwardedSequenceType { get }<br>&gt; }<br>&gt; <br>&gt; extension SequenceTypeForwarder {<br>&gt;     func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;         return forwardedSequence.generate()<br>&gt;     }<br>&gt; <br>&gt;     func underestimateCount() -&gt; Int {<br>&gt;         return forwardedSequence.underestimateCount()<br>&gt;     }<br>&gt; <br>&gt;     func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;         return try forwardedSequence.map(transform)<br>&gt;     }<br>&gt; <br>&gt;     func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;         return try forwardedSequence.filter(includeElement)<br>&gt;     }<br>&gt; <br>&gt;     func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;         return try forwardedSequence.forEach(body)<br>&gt;     }<br>&gt; <br>&gt;     func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.dropFirst(n)<br>&gt;     }<br>&gt; <br>&gt;     func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.dropLast(n)<br>&gt;     }<br>&gt; <br>&gt;     func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.prefix(maxLength)<br>&gt;     }<br>&gt; <br>&gt;     func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.suffix(maxLength)<br>&gt;     }<br>&gt; <br>&gt;     func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;         return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; With this protocol declared, I can then say something like<br>&gt;  <br>&gt; struct Foo {<br>&gt;     var ary: [Int]<br>&gt; }<br>&gt; <br>&gt; extension Foo : SequenceTypeForwarder {<br>&gt;     var forwardedSequence: [Int] { return ary }<br>&gt; }<br>&gt;  <br>&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;  <br>&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/3ea02461/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 29, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 1:24 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Kevin,<br>&gt; <br>&gt; Thanks for taking time to look at the proposal.<br>&gt; <br>&gt; The technique you show here is not bad, but it has several deficiencies IMO which are addressed by the solution in the proposal.<br>&gt; <br>&gt; 1. Forwarding should be an implementation detail, not exposed as it is with this method.<br></p><p>This could theoretically be managed by access control on protocol conformances:<br></p><p>public struct Foo: internal SequenceTypeForwarder, public SequenceType { ... }<br></p><p>though that&#39;s even more boilerplatey, and makes it easy to accidentally expose more API than you intended to.<br></p><p>-Joe<br></p><p>&gt; 2. As such, the getter for the forwardee is visible.  The forwardee is an implementation detail that should not be visible in most cases.<br>&gt; 3. There is no way to specify access control for the synthesized methods and if there were it would be coupled to the access control of the conformance.<br>&gt; 4. You can&#39;t forward to a type that doesn&#39;t conform to the protocol.  This is particularly important for existential forwardees (at least until they conform to their protocol).<br>&gt; 5. A type that can&#39;t conform to the protocol can&#39;t forward an implementation of the members of the protocol.  Specifically, non-final classes cannot automatically forward a group of methods to an implementer.<br>&gt; 6. This solution does not lay the foundation for a newtype feature. It would be possible to have a specialized newtype feature, but why not build it on top of a more general forwarding feature?<br>&gt; <br>&gt; You may be right that many protocols are not amenable to forwarding.  The motivation for this proposal is that it enables delegation-based designs to be implemented succinctly.  In that use case the protocols will be designed alongside concrete implementations and types that forward to them.  A secondary motivation for this proposal is to lay a foundation for a newtype feature.  In that case the protocols to be forwarded would be specifically designed to represent the portion of the interface of the wrapped type which should be visible to users of the newtype.<br>&gt; <br>&gt; I hope these points might be enough to convince you that it is worth a closer look.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 2:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;&gt;  <br>&gt;&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;&gt;  <br>&gt;&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;&gt;     typealias ForwardedSequenceType : SequenceType<br>&gt;&gt; <br>&gt;&gt;     var forwardedSequence : ForwardedSequenceType { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SequenceTypeForwarder {<br>&gt;&gt;     func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;&gt;         return forwardedSequence.generate()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func underestimateCount() -&gt; Int {<br>&gt;&gt;         return forwardedSequence.underestimateCount()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;         return try forwardedSequence.map(transform)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;&gt;         return try forwardedSequence.filter(includeElement)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;&gt;         return try forwardedSequence.forEach(body)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.dropFirst(n)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.dropLast(n)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.prefix(maxLength)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.suffix(maxLength)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;&gt;         return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; With this protocol declared, I can then say something like<br>&gt;&gt;  <br>&gt;&gt; struct Foo {<br>&gt;&gt;     var ary: [Int]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Foo : SequenceTypeForwarder {<br>&gt;&gt;     var forwardedSequence: [Int] { return ary }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;&gt;  <br>&gt;&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/159f3d42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 29, 2015, at 4:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 1:24 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Kevin,<br>&gt;&gt; <br>&gt;&gt; Thanks for taking time to look at the proposal.<br>&gt;&gt; <br>&gt;&gt; The technique you show here is not bad, but it has several deficiencies IMO which are addressed by the solution in the proposal.<br>&gt;&gt; <br>&gt;&gt; 1. Forwarding should be an implementation detail, not exposed as it is with this method.<br>&gt; <br>&gt; This could theoretically be managed by access control on protocol conformances:<br>&gt; <br>&gt; public struct Foo: internal SequenceTypeForwarder, public SequenceType { ... }<br>&gt; <br>&gt; though that&#39;s even more boilerplatey, and makes it easy to accidentally expose more API than you intended to.<br></p><p>Yep.  I&#39;d like to see access control on protocol conformances for other reasons.  I&#39;ve always figured that would be accomplished by allowing access control on extensions that declare protocol conformance rather than directly in the conformance itself.  Both seem like reasonable approaches and aren&#39;t mutually exclusive.<br></p><p>I also brought up in point #3:<br></p><p>&gt; There is no way to specify access control for the synthesized methods and if there were it would be coupled to the access control of the conformance.<br></p><p><br>The coupling in this approach would still exist even with access control on conformances.  The synthesized methods would always have the same visibility as the conformance, which may not always be desired.<br></p><p>We&#39;ve talked in other threads about protocol forwarding a couple of times.  Do you have any general reaction to the approach in this proposal?<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; 2. As such, the getter for the forwardee is visible.  The forwardee is an implementation detail that should not be visible in most cases.<br>&gt;&gt; 3. There is no way to specify access control for the synthesized methods and if there were it would be coupled to the access control of the conformance.<br>&gt;&gt; 4. You can&#39;t forward to a type that doesn&#39;t conform to the protocol.  This is particularly important for existential forwardees (at least until they conform to their protocol).<br>&gt;&gt; 5. A type that can&#39;t conform to the protocol can&#39;t forward an implementation of the members of the protocol.  Specifically, non-final classes cannot automatically forward a group of methods to an implementer.<br>&gt;&gt; 6. This solution does not lay the foundation for a newtype feature. It would be possible to have a specialized newtype feature, but why not build it on top of a more general forwarding feature?<br>&gt;&gt; <br>&gt;&gt; You may be right that many protocols are not amenable to forwarding.  The motivation for this proposal is that it enables delegation-based designs to be implemented succinctly.  In that use case the protocols will be designed alongside concrete implementations and types that forward to them.  A secondary motivation for this proposal is to lay a foundation for a newtype feature.  In that case the protocols to be forwarded would be specifically designed to represent the portion of the interface of the wrapped type which should be visible to users of the newtype.<br>&gt;&gt; <br>&gt;&gt; I hope these points might be enough to convince you that it is worth a closer look.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 29, 2015, at 2:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;&gt;&gt;     typealias ForwardedSequenceType : SequenceType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var forwardedSequence : ForwardedSequenceType { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceTypeForwarder {<br>&gt;&gt;&gt;     func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;&gt;&gt;         return forwardedSequence.generate()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func underestimateCount() -&gt; Int {<br>&gt;&gt;&gt;         return forwardedSequence.underestimateCount()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;&gt;         return try forwardedSequence.map(transform)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;&gt;&gt;         return try forwardedSequence.filter(includeElement)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;&gt;&gt;         return try forwardedSequence.forEach(body)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt;         return forwardedSequence.dropFirst(n)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt;         return forwardedSequence.dropLast(n)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt;         return forwardedSequence.prefix(maxLength)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt;         return forwardedSequence.suffix(maxLength)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;&gt;&gt;         return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; With this protocol declared, I can then say something like<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     var ary: [Int]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Foo : SequenceTypeForwarder {<br>&gt;&gt;&gt;     var forwardedSequence: [Int] { return ary }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/52ce92a4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 02:00:00pm</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 02:11 PM, Joe Groff wrote:<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 1:24 PM, Matthew Johnson via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Kevin,<br>&gt;&gt;<br>&gt;&gt; Thanks for taking time to look at the proposal.<br>&gt;&gt;<br>&gt;&gt; The technique you show here is not bad, but it has several<br>&gt;&gt; deficiencies IMO which are addressed by the solution in the proposal.<br>&gt;&gt;<br>&gt;&gt; 1. Forwarding should be an implementation detail, not exposed as it<br>&gt;&gt;    is with this method.<br>&gt;<br>&gt; This could theoretically be managed by access control on protocol<br>&gt; conformances:<br>&gt;<br>&gt;&gt; public struct Foo: internal SequenceTypeForwarder, public<br>&gt;&gt; SequenceType { ... }<br>&gt;<br>&gt; though that&#39;s even more boilerplatey, and makes it easy to<br>&gt; accidentally expose more API than you intended to.<br></p><p>That&#39;s an interesting approach.<br></p><p>Another workaround for this today is to use an operator (similar to how<br>the stdlib uses ~&gt; internally for a lot of stuff) coupled with a phantom<br>type. As an example (using ~&gt; because why not):<br></p><p>// phantom type<br></p><p>struct _SequenceTypeForwarder {}<br></p><p><br></p><p><br>protocol SequenceTypeForwarder : SequenceType {<br></p><p>typealias ForwardedSequenceType : SequenceType<br></p><p><br></p><p><br>func ~&gt;(this: Self, _: _SequenceTypeForwarder) -&gt; ForwardedSequenceType<br></p><p>}<br></p><p><br>The need for the phantom type is a bit unfortunate (you can&#39;t just use<br>SequenceTypeForwarder.Protocol because it complains about the Self or<br>associated type requirements issue).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/8f55869c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 02:00:00pm</p></header><div class="content"><p>On Tue, Dec 29, 2015, at 01:24 PM, Matthew Johnson wrote:<br>&gt; Hi Kevin,<br>&gt;<br>&gt; Thanks for taking time to look at the proposal.<br>&gt;<br>&gt; The technique you show here is not bad, but it has several<br>&gt; deficiencies IMO which are addressed by the solution in the proposal.<br>&gt;<br>&gt; 1. Forwarding should be an implementation detail, not exposed as it is<br>&gt;    with this method.<br>&gt; 2. As such, the getter for the forwardee is visible.  The forwardee is<br>&gt;    an implementation detail that should not be visible in most cases.<br></p><p>I was tempted to call it `_forwardedSequence` instead, but I chose not<br>to do that because the _prefix convention right now means &quot;stdlib<br>things that we don&#39;t want to expose but have to do so because of<br>implementation details&quot;.<br></p><p>&gt; 3. There is no way to specify access control for the synthesized<br>&gt;    methods and if there were it would be coupled to the access control<br>&gt;    of the conformance.<br></p><p>I&#39;m not sure what you mean by this. Access control for these<br>methods should work identically to access control for the original<br>protocol. The forwarder protocol would simply be declared with the<br>same access control.<br></p><p>&gt; 4. You can&#39;t forward to a type that doesn&#39;t conform to the protocol.<br>&gt;    This is particularly important for existential forwardees (at least<br>&gt;    until they conform to their protocol).<br></p><p>It seems weird to me that your forwarding proposal allows you to forward<br>to a member that doesn&#39;t conform to the protocol. I suppose it makes<br>some sense if you only forward some methods and implement the others<br>yourself, but I&#39;m not convinced there&#39;s actually a good reason to<br>support this. What circumstances are you thinking of where you&#39;d<br>actually find yourself forwarding to a member that doesn&#39;t conform to<br>the protocol (that isn&#39;t an existential)? The only case that really<br>comes to mind is when the member is of a generic type that can&#39;t conform<br>to the protocol (e.g. Array&lt;Int&gt; doesn&#39;t conform to Equatable), but the<br>solution there is to allow for conditional protocol conformance (which<br>we already know is something we want in the language).<br></p><p>Forwarding to existentials is a valid concern, but I&#39;m not actually sure<br>why Swift doesn&#39;t make existential protocol values conform to the<br>protocol anyway. That limitation would make sense if you could create<br>existential protocol values from protocols with Self/associated types<br>where the existential simply omits the relevant members (because then it<br>obviously doesn&#39;t conform to the protocol), but  Swift doesn&#39;t actually<br>let you create existentials in that situation anyway.<br></p><p>&gt; 5. A type that can&#39;t conform to the protocol can&#39;t forward an<br>&gt;    implementation of the members of the protocol.  Specifically, non-<br>&gt;    final classes cannot automatically forward a group of methods to an<br>&gt;    implementer.<br></p><p>It sounds like you&#39;re talking here about the ability to forward members<br>that aren&#39;t actually associated with a protocol, right? I don&#39;t see why<br>you can&#39;t just declare a protocol in that case to represent the members<br>that you want to be able to forward.<br></p><p>&gt; 6. This solution does not lay the foundation for a newtype feature. It<br>&gt;    would be possible to have a specialized newtype feature, but why<br>&gt;    not build it on top of a more general forwarding feature?<br></p><p>Barring a detailed newtype proposal, it&#39;s hard to see how forwarding<br>would actually interact with it. Are you thinking that a newtype would<br>have some member that provides the underlying value (e.g. a `var<br>rawValue`)? Given such a member, a generalized forwarding mechanism<br>would then interact with it. But if e.g. newtype works by letting you<br>cast (with `as`) to the underlying type, then your generalized<br>forwarding mechanism can&#39;t actually work unless it has two different<br>modes (one of which uses a member and the other uses a cast), which<br>means you&#39;re specializing for newtype anyway.<br></p><p>Besides, when using a newtype mechanism like that, since the newtype has<br>the same in-memory representation as the original type, you don&#39;t<br>actually want to generate new methods at all for forwarding, instead you<br>just want to re-use the exact same methods as the original type<br>(otherwise you&#39;re just bloating your code with a bunch of stubs that do<br>nothing more than bitcast the value and call the original method).<br></p><p>-Kevin Ballard<br></p><p>&gt; You may be right that many protocols are not amenable to forwarding.<br>&gt; The motivation for this proposal is that it enables delegation-based<br>&gt; designs to be implemented succinctly.  In that use case the protocols<br>&gt; will be designed alongside concrete implementations and types that<br>&gt; forward to them.  A secondary motivation for this proposal is to lay a<br>&gt; foundation for a newtype feature.  In that case the protocols to be<br>&gt; forwarded would be specifically designed to represent the portion of<br>&gt; the interface of the wrapped type which should be visible to users of<br>&gt; the newtype.<br>&gt;<br>&gt; I hope these points might be enough to convince you that it is worth a<br>&gt; closer look.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;&gt; On Dec 29, 2015, at 2:06 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I briefly skimmed your proposal, so I apologize if you already<br>&gt;&gt; addressed this, but it occurs to me that we could support automatic<br>&gt;&gt; protocol forwarding today on a per-protocol basis simply by declaring<br>&gt;&gt; a separate protocol that provides default implementations doing the<br>&gt;&gt; forwarding. Handling of Self return types can then be done by adding<br>&gt;&gt; a required initializer (or just not implementing that method, so the<br>&gt;&gt; concrete type is forced to deal with it even though everything else<br>&gt;&gt; is forwarded).<br>&gt;&gt;<br>&gt;&gt; For example, if I want to automatically forward SequenceType to a<br>&gt;&gt; member, I can do something like<br>&gt;&gt;<br>&gt;&gt; protocol SequenceTypeForwarder : SequenceType { typealias<br>&gt;&gt; ForwardedSequenceType : SequenceType<br>&gt;&gt;<br>&gt;&gt; var forwardedSequence : ForwardedSequenceType { get } }<br>&gt;&gt;<br>&gt;&gt; extensionSequenceTypeForwarder { func generate() -&gt;<br>&gt;&gt; ForwardedSequenceType.Generator { return<br>&gt;&gt; forwardedSequence.generate()    }<br>&gt;&gt;<br>&gt;&gt; func underestimateCount() -&gt; Int { return<br>&gt;&gt; forwardedSequence.underestimateCount()    }<br>&gt;&gt;<br>&gt;&gt; func map&lt;T&gt;(@noescape transform:<br>&gt;&gt; (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt;<br>&gt;&gt; [T] { return try forwardedSequence.map(transform)    }<br>&gt;&gt;<br>&gt;&gt; func filter(@noescape includeElement:<br>&gt;&gt; (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt; [ForwardedSequenceType.Generator.Element] { return try<br>&gt;&gt; forwardedSequence.filter(includeElement)    }<br>&gt;&gt;<br>&gt;&gt; func forEach(@noescape body:<br>&gt;&gt; (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;&gt; return try forwardedSequence.forEach(body)    }<br>&gt;&gt;<br>&gt;&gt; func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence { return<br>&gt;&gt; forwardedSequence.dropFirst(n)    }<br>&gt;&gt;<br>&gt;&gt; func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence { return<br>&gt;&gt; forwardedSequence.dropLast(n)    }<br>&gt;&gt;<br>&gt;&gt; func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt; return forwardedSequence.prefix(maxLength)    }<br>&gt;&gt;<br>&gt;&gt; func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt; return forwardedSequence.suffix(maxLength)    }<br>&gt;&gt;<br>&gt;&gt; func split(maxSplit: Int, allowEmptySlices: Bool, @noescape<br>&gt;&gt; isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt;<br>&gt;&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] { return try<br>&gt;&gt; forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices,<br>&gt;&gt; isSeparator: isSeparator)    } }<br>&gt;&gt;<br>&gt;&gt; With this protocol declared, I can then say something like<br>&gt;&gt;<br>&gt;&gt; struct Foo { var ary: [Int] }<br>&gt;&gt;<br>&gt;&gt; extensionFoo : SequenceTypeForwarder { var forwardedSequence: [Int] {<br>&gt;&gt; return ary } }<br>&gt;&gt;<br>&gt;&gt; and my struct Foo now automatically implements SequenceType by<br>&gt;&gt; forwarding to its variable `ary`.<br>&gt;&gt;<br>&gt;&gt; The downside to this is it needs to be manually declared for each<br>&gt;&gt; protocol. But I wager that most protocols actually aren&#39;t really<br>&gt;&gt; amenable to forwarding anyway.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/d81b7fbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 4:29 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 29, 2015, at 01:24 PM, Matthew Johnson wrote:<br>&gt;&gt; Hi Kevin,<br>&gt;&gt;  <br>&gt;&gt; Thanks for taking time to look at the proposal.<br>&gt;&gt;  <br>&gt;&gt; The technique you show here is not bad, but it has several deficiencies IMO which are addressed by the solution in the proposal.<br>&gt;&gt;  <br>&gt;&gt; 1. Forwarding should be an implementation detail, not exposed as it is with this method.<br>&gt;&gt; 2. As such, the getter for the forwardee is visible.  The forwardee is an implementation detail that should not be visible in most cases.<br>&gt;  <br>&gt; I was tempted to call it `_forwardedSequence` instead, but I chose not to do that because the _prefix convention right now means &quot;stdlib things that we don&#39;t want to expose but have to do so because of implementation details”.<br></p><p>Sure, but naming conventions are not access control.<br></p><p>&gt;  <br>&gt;&gt; 3. There is no way to specify access control for the synthesized methods and if there were it would be coupled to the access control of the conformance.<br>&gt;  <br>&gt; I&#39;m not sure what you mean by this. Access control for these methods should work identically to access control for the original protocol. The forwarder protocol would simply be declared with the same access control.<br></p><p>There are 3 things at play here:<br></p><p>1. The protocol that is forwarded<br>2. The forwarding methods implementing the protocol requirements<br>3. Conformance to the protocol<br></p><p>When you write code manually it is possible to specify distinct access control for 1 and 2, and as Joe noted it would be nice to be able to specify access control for 3 as well.  If this becomes possible all 3 could have distinct access levels.  <br></p><p>For example, a public protocol, internal implementing methods, but private conformance.  Or public implementing methods, an internal protocol, and private conformance.  Or a public protocol, and internal implementing methods and conformance.  Or public implementing methods, but an internal protocol and internal conformance.  <br></p><p>Some of these combinations might be unusual, but there may be use cases for them.  Ideally a forwarding mechanism would allow granular control, just as is possible with manual forwarding implementations.<br></p><p>&gt;  <br>&gt;&gt; 4. You can&#39;t forward to a type that doesn&#39;t conform to the protocol.  This is particularly important for existential forwardees (at least until they conform to their protocol).<br>&gt;  <br>&gt; It seems weird to me that your forwarding proposal allows you to forward to a member that doesn&#39;t conform to the protocol. I suppose it makes some sense if you only forward some methods and implement the others yourself, but I&#39;m not convinced there&#39;s actually a good reason to support this. What circumstances are you thinking of where you&#39;d actually find yourself forwarding to a member that doesn&#39;t conform to the protocol (that isn&#39;t an existential)? The only case that really comes to mind is when the member is of a generic type that can&#39;t conform to the protocol (e.g. Array&lt;Int&gt; doesn&#39;t conform to Equatable), but the solution there is to allow for conditional protocol conformance (which we already know is something we want in the language).<br></p><p>The proposal requires the forwardee to be *conformable* but not necessarily conforming.  The difference is admittedly subtle, but there may be good reasons.  It may be that it isn’t desriable for the forwardee to actually conform for one reason or another, maybe because you don’t want it to be possible to cast values of the forwardee type to the existential type of the protocol.  <br></p><p>The reason the proposal doesn’t require actual conformance is simply because it isn’t necessary to synthesize the forwarding members and there are potential use cases that could take advantage of the additional flexibility.  And again, because actual conformance would not be required to write the forwarding methods manually.<br></p><p>Protocols are an essential part of the forwarding mechanism because they are the only place in the language to differentiate between Self and a parameter or return value that should be always be of a specific type.  However, actual conformance to the protocol by either the forwarder or the forwardee is not necessary to implement forwarding.  Rather than arbitrarily require that it seems best to allow users control over whether, how, and where actual conformance is declared by both the forwarder and the forwardee.<br></p><p>The proposal specifically does not support “partial forwarding”.  That was noted as a possible future enhancement.  If such an enhancement were ever brought forward I would not support dropping the requirement for the forwardee to be “theoretically conformable” to the protocol.  Partial forwarding would only exist to enable forwarders to “override” specific member implementations.<br></p><p>&gt;  <br>&gt; Forwarding to existentials is a valid concern, but I&#39;m not actually sure why Swift doesn&#39;t make existential protocol values conform to the protocol anyway. That limitation would make sense if you could create existential protocol values from protocols with Self/associated types where the existential simply omits the relevant members (because then it obviously doesn&#39;t conform to the protocol), but Swift doesn&#39;t actually let you create existentials in that situation anyway.<br></p><p>Yes, I agree that existential should conform to the corresponding protocol and I hope it is a temporary limitation.  It has been mentioned that there are some implementation complexities and possible performance issues to work through. <br></p><p>In any case, until this happens existential are a strong use case for taking advantage of forwarding to &quot;theoretically conformable but not actually conforming” types.  There is no reason not to support this use case and no reason not to enable any other use cases that might take advantage of that flexibility.<br></p><p><br>&gt;  <br>&gt;&gt; 5. A type that can&#39;t conform to the protocol can&#39;t forward an implementation of the members of the protocol.  Specifically, non-final classes cannot automatically forward a group of methods to an implementer.<br>&gt;  <br>&gt; It sounds like you&#39;re talking here about the ability to forward members that aren&#39;t actually associated with a protocol, right? I don&#39;t see why you can&#39;t just declare a protocol in that case to represent the members that you want to be able to forward.<br></p><p>No, I’m talking about the case where you might have a protocol with a Self return type.  non-final classes cannot conform to such a protocol. But it is possible to synthesize forwarding methods corresponding to a protocol where the return type of those methods is Forwarder.  You can’t declare conformance and don’t actually conform, but the forwarding methods could be synthesized without trouble and would work just fine in cases where a return type of Forwarder (rather than a covariant return type) is acceptable.  <br></p><p>&gt;  <br>&gt;&gt; 6. This solution does not lay the foundation for a newtype feature. It would be possible to have a specialized newtype feature, but why not build it on top of a more general forwarding feature?<br>&gt;  <br>&gt; Barring a detailed newtype proposal, it&#39;s hard to see how forwarding would actually interact with it. Are you thinking that a newtype would have some member that provides the underlying value (e.g. a `var rawValue`)? Given such a member, a generalized forwarding mechanism would then interact with it. But if e.g. newtype works by letting you cast (with `as`) to the underlying type, then your generalized forwarding mechanism can&#39;t actually work unless it has two different modes (one of which uses a member and the other uses a cast), which means you&#39;re specializing for newtype anyway.<br>&gt;  <br>&gt; Besides, when using a newtype mechanism like that, since the newtype has the same in-memory representation as the original type, you don&#39;t actually want to generate new methods at all for forwarding, instead you just want to re-use the exact same methods as the original type (otherwise you&#39;re just bloating your code with a bunch of stubs that do nothing more than bitcast the value and call the original method).<br></p><p>I roughly sketched what a newtype mechanism built on top of protocol forwarding might look like in a simple case in the future enhancements section of the proposal.  This is not a detailed proposal by any means, but it does suggest a possible direction.  The suggested direction is pretty similar to what Joe Groff mentioned in this post: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001137.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001137.html&gt;.<br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt; You may be right that many protocols are not amenable to forwarding.  The motivation for this proposal is that it enables delegation-based designs to be implemented succinctly.  In that use case the protocols will be designed alongside concrete implementations and types that forward to them.  A secondary motivation for this proposal is to lay a foundation for a newtype feature.  In that case the protocols to be forwarded would be specifically designed to represent the portion of the interface of the wrapped type which should be visible to users of the newtype.<br>&gt;&gt;  <br>&gt;&gt; I hope these points might be enough to convince you that it is worth a closer look.<br>&gt;&gt;  <br>&gt;&gt; Matthew<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 29, 2015, at 2:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;&gt;&gt; typealias ForwardedSequenceType : SequenceType<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; var forwardedSequence : ForwardedSequenceType { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionSequenceTypeForwarder {<br>&gt;&gt;&gt; func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;&gt;&gt; return forwardedSequence.generate()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func underestimateCount() -&gt; Int {<br>&gt;&gt;&gt; return forwardedSequence.underestimateCount()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;&gt; return try forwardedSequence.map(transform)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;&gt;&gt; return try forwardedSequence.filter(includeElement)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;&gt;&gt; return try forwardedSequence.forEach(body)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt; return forwardedSequence.dropFirst(n)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt; return forwardedSequence.dropLast(n)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt; return forwardedSequence.prefix(maxLength)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;&gt; return forwardedSequence.suffix(maxLength)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;&gt;&gt; return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; With this protocol declared, I can then say something like<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt; var ary: [Int]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionFoo : SequenceTypeForwarder {<br>&gt;&gt;&gt; var forwardedSequence: [Int] { return ary }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/604d650c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 29, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 12:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br></p><p>At least from a language-mechanics perspective, the only fundamental blocker I can think of that makes a protocol difficult to forward are nontrivial `Self` requirements, since you need a way to map from Foo&lt;Forwarder&gt; to Foo&lt;Forwardee&gt; anywhere the protocol requires Foo&lt;Self&gt;. There&#39;s quite a bit of that in the standard library thanks to the collection APIs, to be sure, but I wonder what the breakdown is in the wild for Self-inflicting protocols versus non  outside of the stdlib.<br></p><p>I like the idea of using Forwarder protocols with default implementations, since it&#39;s amenable to macro generation and doesn&#39;t require new language features, but like Matt noted, it&#39;s easy to do the wrong thing from an API exposure standpoint by accidentally publishing your type&#39;s FooableForwarder conformance when you only wanted to promise that your type was Fooable.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/ec5d85eb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 12:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;  <br>&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;  <br>&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;     typealias ForwardedSequenceType : SequenceType<br>&gt; <br>&gt;     var forwardedSequence : ForwardedSequenceType { get }<br>&gt; }<br>&gt; <br>&gt; extension SequenceTypeForwarder {<br>&gt;     func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;         return forwardedSequence.generate()<br>&gt;     }<br>&gt; <br>&gt;     func underestimateCount() -&gt; Int {<br>&gt;         return forwardedSequence.underestimateCount()<br>&gt;     }<br>&gt; <br>&gt;     func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;         return try forwardedSequence.map(transform)<br>&gt;     }<br>&gt; <br>&gt;     func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;         return try forwardedSequence.filter(includeElement)<br>&gt;     }<br>&gt; <br>&gt;     func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;         return try forwardedSequence.forEach(body)<br>&gt;     }<br>&gt; <br>&gt;     func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.dropFirst(n)<br>&gt;     }<br>&gt; <br>&gt;     func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.dropLast(n)<br>&gt;     }<br>&gt; <br>&gt;     func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.prefix(maxLength)<br>&gt;     }<br>&gt; <br>&gt;     func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;         return forwardedSequence.suffix(maxLength)<br>&gt;     }<br>&gt; <br>&gt;     func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;         return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;     }<br>&gt; }<br></p><p>FWIW,<br></p><p>https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceWrapper.swift<br></p><p>Though I don’t know why we still have this; it’s not used anywhere and should probably be removed.  I think it was supposed to be part of the new lazy sequence/collection subsystem but it was never incorporated.<br></p><p>&gt; With this protocol declared, I can then say something like<br>&gt;  <br>&gt; struct Foo {<br>&gt;     var ary: [Int]<br>&gt; }<br>&gt; <br>&gt; extension Foo : SequenceTypeForwarder {<br>&gt;     var forwardedSequence: [Int] { return ary }<br>&gt; }<br>&gt;  <br>&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;  <br>&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/ea987285/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 5:44 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 12:06 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I briefly skimmed your proposal, so I apologize if you already addressed this, but it occurs to me that we could support automatic protocol forwarding today on a per-protocol basis simply by declaring a separate protocol that provides default implementations doing the forwarding. Handling of Self return types can then be done by adding a required initializer (or just not implementing that method, so the concrete type is forced to deal with it even though everything else is forwarded).<br>&gt;&gt;  <br>&gt;&gt; For example, if I want to automatically forward SequenceType to a member, I can do something like<br>&gt;&gt;  <br>&gt;&gt; protocol SequenceTypeForwarder : SequenceType {<br>&gt;&gt;     typealias ForwardedSequenceType : SequenceType<br>&gt;&gt; <br>&gt;&gt;     var forwardedSequence : ForwardedSequenceType { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SequenceTypeForwarder {<br>&gt;&gt;     func generate() -&gt; ForwardedSequenceType.Generator {<br>&gt;&gt;         return forwardedSequence.generate()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func underestimateCount() -&gt; Int {<br>&gt;&gt;         return forwardedSequence.underestimateCount()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func map&lt;T&gt;(@noescape transform: (ForwardedSequenceType.Generator.Element) throws -&gt; T) rethrows -&gt; [T] {<br>&gt;&gt;         return try forwardedSequence.map(transform)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func filter(@noescape includeElement: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.Generator.Element] {<br>&gt;&gt;         return try forwardedSequence.filter(includeElement)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func forEach(@noescape body: (ForwardedSequenceType.Generator.Element) throws -&gt; Void) rethrows {<br>&gt;&gt;         return try forwardedSequence.forEach(body)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func dropFirst(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.dropFirst(n)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func dropLast(n: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.dropLast(n)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func prefix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.prefix(maxLength)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func suffix(maxLength: Int) -&gt; ForwardedSequenceType.SubSequence {<br>&gt;&gt;         return forwardedSequence.suffix(maxLength)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func split(maxSplit: Int, allowEmptySlices: Bool, @noescape isSeparator: (ForwardedSequenceType.Generator.Element) throws -&gt; Bool) rethrows -&gt; [ForwardedSequenceType.SubSequence] {<br>&gt;&gt;         return try forwardedSequence.split(maxSplit, allowEmptySlices: allowEmptySlices, isSeparator: isSeparator)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; FWIW,<br>&gt; <br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceWrapper.swift &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceWrapper.swift&gt;<br>&gt; <br>&gt; Though I don’t know why we still have this; it’s not used anywhere and should probably be removed.  I think it was supposed to be part of the new lazy sequence/collection subsystem but it was never incorporated.<br></p><p>Dave, thanks for pointing me to the Lazy Collections subsystem.  It made for a really great case study!  <br></p><p>A lot of what is happening in there is not directly forwarding related.  But I do think the implementation of the parts that involve forwarding is improved by using the forwarding mechanism in this proposal.  It is more clear and more robust than the current implementation. <br></p><p>As it turns out, _SequenceWrapperType and the extension to SequenceType in SequenceWrapper.swift actually are still in use.  They contain an implementation of the forwarding mechanism Kevin Ballard suggested in this thread.  _CollectionWrapperType and the extension to CollectionType are not in use.  LazyCollection uses manual forwarding in the type itself which avoids some of the drawbacks of the protocol extension approach.  Of course this begs the question of why two different mechanisms are in use and which is actually preferred.<br></p><p>I am working on a new draft of the proposal with a greatly expanded motivation section.  I don’t have that completed yet, but I have completed a first pass of the section on the lazy collection subsystem.  I am including the current draft here.  I hope you find it interesting.  I am interested in your thoughts on it.<br></p><p>Matthew<br>Motivation<br></p><p>Delegation is a robust, composition oriented design technique that keeps interface and implementation inheritance separate. The primary drawback to this technique is that it requires a lot of manual boilerplate to forward implemenation to the implementing member. This proposal eliminates the need to write such boilerplate manually, thus making delegation-based designs much more convenient and attractive.<br></p><p>This proposal may also serve as the foundation for a future enhancement allowing a very concise “newtype” declaration. In the meantime, it facilitates similar functionality, although in a slightly more verbose manner.<br></p><p>Examples<br></p><p>Several examples follow. <br></p><p>The first two show how this proposal could improve how forwarding is implemented by the lazy collection subsystem of the standard library. This makes an interesting case study as each example employs a different forwarding mechanism.<br></p><p>LazySequence<br></p><p>The relevant portion of the current implementation of LazySequence looks like this (with comments removed and formatting tweaks):<br></p><p>// in SequenceWrapper.swift:<br></p><p>public protocol _SequenceWrapperType {<br>  typealias Base : SequenceType<br>  typealias Generator : GeneratorType = Base.Generator<br>  <br>  var _base: Base {get}<br>}<br></p><p>extension SequenceType<br>  where Self : _SequenceWrapperType, Self.Generator == Self.Base.Generator {<br></p><p>  public func generate() -&gt; Base.Generator {<br>    return self._base.generate()<br>  }<br></p><p>  public func underestimateCount() -&gt; Int {<br>    return _base.underestimateCount()<br>  }<br></p><p>  @warn_unused_result<br>  public func map&lt;T&gt;(<br>    @noescape transform: (Base.Generator.Element) throws -&gt; T<br>  ) rethrows -&gt; [T] {<br>    return try _base.map(transform)<br>  }<br></p><p>  @warn_unused_result<br>  public func filter(<br>    @noescape includeElement: (Base.Generator.Element) throws -&gt; Bool<br>  ) rethrows -&gt; [Base.Generator.Element] {<br>    return try _base.filter(includeElement)<br>  }<br>  <br>  public func _customContainsEquatableElement(<br>    element: Base.Generator.Element<br>  ) -&gt; Bool? { <br>    return _base._customContainsEquatableElement(element)<br>  }<br>  <br>  public func _preprocessingPass&lt;R&gt;(@noescape preprocess: (Self) -&gt; R) -&gt; R? {<br>    return _base._preprocessingPass { _ in preprocess(self) }<br>  }<br></p><p>  public func _copyToNativeArrayBuffer()<br>    -&gt; _ContiguousArrayBuffer&lt;Base.Generator.Element&gt; {<br>    return _base._copyToNativeArrayBuffer()<br>  }<br></p><p>  public func _initializeTo(ptr: UnsafeMutablePointer&lt;Base.Generator.Element&gt;)<br>    -&gt; UnsafeMutablePointer&lt;Base.Generator.Element&gt; {<br>    return _base._initializeTo(ptr)<br>  }<br>}<br></p><p>// in LazySequence.swift:<br></p><p>public struct LazySequence&lt;Base : SequenceType&gt;<br>  : LazySequenceType, _SequenceWrapperType {<br></p><p>  public init(_ base: Base) {<br>    self._base = base<br>  }<br>  <br>  public var _base: Base<br>  public var elements: Base { return _base }<br>}<br>LazySequence is using the approach to forwarding mentioned by Kevin Ballard on the mailing list &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004755.html&gt;in response to this proposal. This approach has several deficiencies that directly impact LazySequence:<br></p><p>LazySequence must publicly expose implementation details. Both its _base property as well as its conformance to _SequenceWrapperType.<br>The forwarding members must be manually implemented. They are trivial, but mistakes are still possible. In this case, @warn_unused_result is missing in some places where it should probably be specified (and would be synthesized using the approach in this proposal due to its presence in the protocol member declarations).<br>It is not immediately apparent that _SequenceWrapperType and the corresponding extension only provide forwarding members. Even if the name clearly indicates that it is possible that the code does something different. It is possible for somebody to come along after the initial implementation and add a new method that does something other than simple forwarding.<br>Because the forwarding is implemented via a protocol extension as default methods it can be overriden by an extension on LazySequence.<br>Here is an alternative implemented using the current proposal:<br></p><p><br>// _LazySequenceForwarding redeclares the subset of the members of SequenceType we wish to forward.<br>// The protocol is an implementation detail and is marked private.<br>private protocol _LazySequenceForwarding {<br></p><p>  typealias Generator : GeneratorType<br></p><p>  @warn_unused_result<br>  func generate() -&gt; Generator<br></p><p>  @warn_unused_result<br>  func underestimateCount() -&gt; Int<br></p><p>  @warn_unused_result<br>  func map&lt;T&gt;(<br>    @noescape transform: (Generator.Element) throws -&gt; T<br>  ) rethrows -&gt; [T]<br>  <br>  @warn_unused_result<br>  func filter(<br>    @noescape includeElement: (Generator.Element) throws -&gt; Bool<br>  ) rethrows -&gt; [Generator.Element]<br>  <br>  @warn_unused_result<br>  func _customContainsEquatableElement(<br>    element: Generator.Element<br>  ) -&gt; Bool?<br></p><p>  func _copyToNativeArrayBuffer() -&gt; _ContiguousArrayBuffer&lt;Generator.Element&gt;<br></p><p>  func _initializeTo(ptr: UnsafeMutablePointer&lt;Generator.Element&gt;)<br>    -&gt; UnsafeMutablePointer&lt;Generator.Element&gt;<br>}<br></p><p>public struct LazySequence&lt;Base : SequenceType&gt; : LazySequenceType {<br></p><p>  public init(_ base: Base) {<br>    self._base = base<br>  }<br>  <br>  // NOTE: _base is now internal<br>  internal var _base: Base<br>  public var elements: Base { return _base }<br>  <br>  public forward _LazySequenceForwarding to _base<br>  <br>  // The current proposal does not currently support forwarding <br>  // of members with nontrivial Self requirements.<br>  // Because of this _preprocessingPass is forwarded manually.<br>  // A future enhancement may be able to support automatic<br>  // forwarding of protocols with some or all kinds of <br>  // nontrivial Self requirements.<br>  public func _preprocessingPass&lt;R&gt;(@noescape preprocess: (Self) -&gt; R) -&gt; R? {<br>    return _base._preprocessingPass { _ in preprocess(self) }<br>  }<br>}<br>This example takes advantage of a very important aspect of the design of this proposal. Neither Base nor LazySequence are required to conform to _LazySequenceForwarding. The only requirement is that Base contains the members specified in _LazySequenceForwarding as they will be used in the synthesized forwarding implementations. <br></p><p>The relaxed requirement is crucial to the application of the protocol forwarding feature in this implementation. We cannot conform Base to _LazySequenceForwarding. If it were possible to conform one protocol to another we could conform SequenceType to _LazySequenceForwarding, however it is doubtful that we would want that conformance. Despite this, it is clear to the compiler that Base does contain the necessary members for forwarding as it conforms to LazySequence which also declares all of the necessary members. <br></p><p>This implementation is more robust and more clear:<br></p><p>We no longer leak any implementation details.<br>There is no chance of making a mistake in the implementation of the forwarded members. It is possible that a mistake could be made in the member declarations in _LazySequenceForwarding. However, if a mistake is made there a compiler error will result.<br>The set of forwarded methods is immediately clear, with the exception of _preprocessingPass because of its nontrivial Self requirement. Removing the limitation on nontrivial Self requirements is a highly desired improvement to this proposal or future enhancement to this feature.<br>The forwarded members cannot be overriden in an extension on LazySequence. If somebody attempts to do so it will result in an ambiguous use error at call sites.<br>LazyCollection<br></p><p>The relevant portion of the current implementation of LazyCollection looks like this (with comments removed and formatting tweaks):<br></p><p>// in LazyCollection.swift:<br></p><p>public struct LazyCollection&lt;Base : CollectionType&gt;<br>  : LazyCollectionType {<br></p><p>  public typealias Elements = Base<br>  public var elements: Elements { return _base }<br></p><p>  public typealias Index = Base.Index<br></p><p>  public init(_ base: Base) {<br>    self._base = base<br>  }<br></p><p>  internal var _base: Base<br>}<br></p><p>extension LazyCollection : SequenceType {<br></p><p>  public func generate() -&gt; Base.Generator { return _base.generate() }<br>  <br>  public func underestimateCount() -&gt; Int { return _base.underestimateCount() }<br></p><p>  public func _copyToNativeArrayBuffer() <br>     -&gt; _ContiguousArrayBuffer&lt;Base.Generator.Element&gt; {<br>    return _base._copyToNativeArrayBuffer()<br>  }<br>  <br>  public func _initializeTo(<br>    ptr: UnsafeMutablePointer&lt;Base.Generator.Element&gt;<br>  ) -&gt; UnsafeMutablePointer&lt;Base.Generator.Element&gt; {<br>    return _base._initializeTo(ptr)<br>  }<br></p><p>  public func _customContainsEquatableElement(<br>    element: Base.Generator.Element<br>  ) -&gt; Bool? { <br>    return _base._customContainsEquatableElement(element)<br>  }<br>}<br></p><p>extension LazyCollection : CollectionType {<br>    <br>  public var startIndex: Base.Index {<br>    return _base.startIndex<br>  }<br>  <br>  public var endIndex: Base.Index {<br>    return _base.endIndex<br>  }<br></p><p>  public subscript(position: Base.Index) -&gt; Base.Generator.Element {<br>    return _base[position]<br>  }<br></p><p>  public subscript(bounds: Range&lt;Index&gt;) -&gt; LazyCollection&lt;Slice&lt;Base&gt;&gt; {<br>    return Slice(base: _base, bounds: bounds).lazy<br>  }<br>  <br>  public var isEmpty: Bool {<br>    return _base.isEmpty<br>  }<br></p><p>  public var count: Index.Distance {<br>    return _base.count<br>  }<br></p><p>  public func _customIndexOfEquatableElement(<br>    element: Base.Generator.Element<br>  ) -&gt; Index?? {<br>    return _base._customIndexOfEquatableElement(element)<br>  }<br></p><p>  public var first: Base.Generator.Element? {<br>    return _base.first<br>  }<br>}<br>LazyCollection is using direct manual implementations of forwarding methods. It corresponds exactly to implementations that would be synthesized by the compiler under this proposal. This approach avoids some of the problems with the first approach:<br></p><p>It does not leak implementation details. This is good!<br>The forwarded members cannot be overriden.<br>Unfortunately it still has some drawbacks:<br></p><p>It is still possible to make mistakes in the manual forwarding implementations.<br>The set of forwarded methods is even less clear than under the first approach as they are now potentially interspersed with custom, nontrivial member implementations, such as subscript(bounds: Range&lt;Index&gt;) -&gt; LazyCollection&lt;Slice&lt;Base&gt;&gt; in this example.<br>This approach requires reimplementing the forwarded members in every type which forwards them and is therefore less scalable than the first approach and this proposal. This may not matter for LazyCollection but it may well matter in other cases.<br>One intersting difference to note between LazySequence and LazyCollection is that LazySequence forwards three members which LazyCollection does not: map, filter, and _preprocessingPass. It is unclear whether this difference is intentional or not. <br></p><p>This difference is particularly interesting in the case of _preprocessingPass. LazyCollectionappears to be using the default implementation for CollectionType in Collection.swift, which results in _base._preprocessingPass not getting called. It is not apparent why this behavior would be correct for LazyCollection and not for LazySequence.<br></p><p>I wonder if the difference in forwarded members is partly due to the fact that the set of forwarded members is not as clear as it could be. <br></p><p>Here is an alternate approach implemented using the current proposal. It assumes that the same SequenceType members that are forwarded by LazySequence should also be forwarded by LazyCollection, allowing us to reuse the _LazySequenceForwarding protocol declared in the first example.<br></p><p><br>// _LazyCollectionForwarding redeclares the subset of the members of Indexable and CollectionType we wish to forward.<br>// The protocol is an implementation detail and is marked private.<br>private protocol _LazyCollectionForwarding: _LazySequenceForwarding {<br>  typealias Index : ForwardIndexType<br>  var startIndex: Index {get}<br>  var endIndex: Index {get}<br></p><p>  typealias _Element<br>  subscript(position: Index) -&gt; _Element {get}<br></p><p>  var isEmpty: Bool { get }<br>  var count: Index.Distance { get }<br>  var first: Generator.Element? { get }<br></p><p>  @warn_unused_result<br>  func _customIndexOfEquatableElement(element: Generator.Element) -&gt; Index??<br>}<br></p><p>public struct LazyCollection&lt;Base : CollectionType&gt;<br>  : LazyCollectionType {<br></p><p>  public typealias Elements = Base<br>  public var elements: Elements { return _base }<br></p><p>  public init(_ base: Base) {<br>    self._base = base<br>  }<br></p><p>  internal var _base: Base<br>  <br>  public forward _LazyCollectionForwarding to _base<br></p><p>  // It may be the case that LazyCollection should forward _preprocessingPass <br>  // in the same fashion that LazySequence uses, which cannot yet be automated<br>  // under the current proposal.<br>}<br></p><p>extension LazyCollection : CollectionType {<br>  // This implementation is nontrivial and thus not forwarded<br>  public subscript(bounds: Range&lt;Index&gt;) -&gt; LazyCollection&lt;Slice&lt;Base&gt;&gt; {<br>    return Slice(base: _base, bounds: bounds).lazy<br>  }<br>}<br>This approach to forwarding does not exhibit any of the issues with the manual approach and only takes about half as much code now that we are able to reuse the previous declaration of _LazySequenceForwarding.<br></p><p>NOTE: LazyMapCollection in Map.swift uses the same manual forwarding approach as LazyCollection to forward a handful of members and would therefore also be a candidate for adopting the new forwarding mechanism as well.<br></p><p><br></p><p><br>&gt; <br>&gt;&gt; With this protocol declared, I can then say something like<br>&gt;&gt;  <br>&gt;&gt; struct Foo {<br>&gt;&gt;     var ary: [Int]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Foo : SequenceTypeForwarder {<br>&gt;&gt;     var forwardedSequence: [Int] { return ary }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; and my struct Foo now automatically implements SequenceType by forwarding to its variable `ary`.<br>&gt;&gt;  <br>&gt;&gt; The downside to this is it needs to be manually declared for each protocol. But I wager that most protocols actually aren&#39;t really amenable to forwarding anyway.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a1d01c17/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 29, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br></p><p>Some things I don&#39;t see discussed here:<br></p><p>* Does it have to be a protocol? Why not also allow the concrete type of the property you&#39;re forwarding to? Obviously you couldn&#39;t form a subtype relationship (unless you could...), but this might be useful to reduce boilerplate when you&#39;re proxying something.<br></p><p>* Why the method-based conversion syntax for return values, rather than something a little more like a property declaration?<br></p><p>	var number: Int<br>	forward IntegerType to number {<br>		static return(newValue: Int) {<br>			return NumberWrapper(newValue)<br>		}<br>		return(newValue: Int) {<br>			return NumberWrapper(newValue)<br>		}<br>	}<br></p><p>* If you want to keep the method-based syntax, why use the `init(_:)` initializer instead of one specifically for forwarding, like `init(forwardedReturnValue:)`?<br></p><p>* If you want to keep the method-based syntax, why do all forwards, even to different members, share the same transformation method? Wouldn&#39;t it be better to have, for instance, `init(returnedNumber:)` and `transformedReturnedNumber(_:)`, so that forwards to other properties could use different logic?<br></p><p>* If you want to keep the method-based syntax, would it make sense to instead have an initializer for instance initializers too, and just have it take a second parameter with the instance?<br></p><p>	init(forwardedReturnValue: Int) {...}<br>	init(forwardedReturnValue: Int, from: NumberWrapper) {...}<br></p><p>* Does this mean that a `public forward` declaration would forward `internal` members through synthesized `public` interfaces, if the forwarder and forwardee happened to be in the same module?<br></p><p>&gt; All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br></p><p><br>* You don&#39;t explicitly mention this, but I assume mutating methods work and mutate `self`?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 3:08 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>&gt; <br>&gt; Some things I don&#39;t see discussed here:<br>&gt; <br>&gt; * Does it have to be a protocol? Why not also allow the concrete type of the property you&#39;re forwarding to? Obviously you couldn&#39;t form a subtype relationship (unless you could...), but this might be useful to reduce boilerplate when you&#39;re proxying something.<br></p><p>This is addressed in the alternatives considered section.  The short answer is that there the direct interface of the concrete type does not contain sufficient information about potential Self parameters to do this well.  This information does exist in the protocol declarations.  Allowing this information to be specified in concrete interfaces would add enough complexity to the language that I don’t think it is worthwhile.  Joe Groff and I discussed this briefly yesterday: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004660.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004660.html&gt;.<br></p><p>What you *can* do is declare a protocol containing the generalized signatures (substituting Self where appropriate) of all of the members of your concrete interface that you wish to be available to forward.  That is a one-time protocol declaration that allows you to forward the concrete interface as many times as you wish.  It seems like a reasonable tradeoff.<br></p><p>&gt; <br>&gt; * Why the method-based conversion syntax for return values, rather than something a little more like a property declaration?<br>&gt; <br>&gt; 	var number: Int<br>&gt; 	forward IntegerType to number {<br>&gt; 		static return(newValue: Int) {<br>&gt; 			return NumberWrapper(newValue)<br>&gt; 		}<br>&gt; 		return(newValue: Int) {<br>&gt; 			return NumberWrapper(newValue)<br>&gt; 		}<br>&gt; 	}<br></p><p>This is actually a really good idea to consider!  I didn’t consider something like this mostly because I didn’t think of it.  I’m going to seriously consider adopting an approach along these lines.<br></p><p>One possible advantage of the approach I used is that the initializer may already exist for other reasons and you would not need to do any extra work.<br></p><p>A big advantage of this approach is that it would work even when you are forwarding different protocols to more than one member with the same type.<br></p><p>&gt; <br>&gt; * If you want to keep the method-based syntax, why use the `init(_:)` initializer instead of one specifically for forwarding, like `init(forwardedReturnValue:)`?<br></p><p>That was a somewhat arbitrary decision I suppose.  I also considered having the compiler look for any initializer accepting the correct type regardless of label.<br></p><p>&gt; <br>&gt; * If you want to keep the method-based syntax, why do all forwards, even to different members, share the same transformation method? Wouldn&#39;t it be better to have, for instance, `init(returnedNumber:)` and `transformedReturnedNumber(_:)`, so that forwards to other properties could use different logic?<br></p><p>That is a limitation of the approach I used and the proposal disallows you to do such forwarding because of the ambiguity.  I am glad you identified a solution to that!<br></p><p>&gt; <br>&gt; * If you want to keep the method-based syntax, would it make sense to instead have an initializer for instance initializers too, and just have it take a second parameter with the instance?<br>&gt; <br>&gt; 	init(forwardedReturnValue: Int) {...}<br>&gt; 	init(forwardedReturnValue: Int, from: NumberWrapper) {…}<br></p><p>Part of the reason the instance method was used is because sometimes the right thing to do might be to mutate and then return self.  Using an instance method gives you the flexibility to do that if necessary.<br></p><p>&gt; <br>&gt; * Does this mean that a `public forward` declaration would forward `internal` members through synthesized `public` interfaces, if the forwarder and forwardee happened to be in the same module?<br>&gt; <br>&gt;&gt; All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br></p><p>Yes, if the forwardee had internal visibility and the forwarder was public the forwarder could publicly forward the interface.  This is intentional behavior.  The forwardee may well be an internal implementation detail while the methods of the protocol are part of the public interface of the forwarder.  It is possible to write code that does this manually today.<br></p><p>&gt; * You don&#39;t explicitly mention this, but I assume mutating methods work and mutate `self`?<br></p><p>Mutating methods are something I didn’t think about carefully yet.  Thanks for pointing that out!  But generally, yes a forwarding implementation of a mutating method would need to mutate the forwardee which is part of self, thus mutating self.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/2e1fb590/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; * Does it have to be a protocol? Why not also allow the concrete type of the property you&#39;re forwarding to? Obviously you couldn&#39;t form a subtype relationship (unless you could...), but this might be useful to reduce boilerplate when you&#39;re proxying something.<br>&gt; <br>&gt; This is addressed in the alternatives considered section.<br></p><p>Sorry, I missed that, probably because the sample code in that section didn&#39;t show such a forwarding.<br></p><p>&gt; The short answer is that there the direct interface of the concrete type does not contain sufficient information about potential Self parameters to do this well.  This information does exist in the protocol declarations.  Allowing this information to be specified in concrete interfaces would add enough complexity to the language that I don’t think it is worthwhile.<br></p><p>That&#39;s a good point. You could perhaps add a way to tweak the forwarding of certain members, but that&#39;d be a little tricky.<br></p><p>One of the things I&#39;d like to see is the ability to proxy for an instance without the person writing the proxy knowing which instances it&#39;ll be used with. Think, for example, of the Cocoa animator proxy, or `NSUndoManager.prepareWithInvocationTarget(_:)`. It&#39;d be nice if a Swift equivalent could return, say, `NSAnimatorProxy&lt;View&gt;` or `NSUndoManager.InvocationTarget&lt;Target&gt;`, which has all the methods of the generic type but records the calls for later use.<br></p><p>Of course, what you really want is for only a particular subset of the methods to be available on the proxy (animated methods on `NSAnimatorProxy`, Void methods on `NSUndoManager.InvocationTarget`), and of course in these cases you&#39;re not calling directly through to the underlying methods. So I might just be barking up the wrong tree here.<br></p><p>&gt;&gt; * Why the method-based conversion syntax for return values, rather than something a little more like a property declaration?<br>&gt;&gt; <br>&gt;&gt; 	var number: Int<br>&gt;&gt; 	forward IntegerType to number {<br>&gt;&gt; 		static return(newValue: Int) {<br>&gt;&gt; 			return NumberWrapper(newValue)<br>&gt;&gt; 		}<br>&gt;&gt; 		return(newValue: Int) {<br>&gt;&gt; 			return NumberWrapper(newValue)<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt; <br>&gt; This is actually a really good idea to consider!  I didn’t consider something like this mostly because I didn’t think of it.  I’m going to seriously consider adopting an approach along these lines.<br></p><p>Great.<br></p><p>&gt; One possible advantage of the approach I used is that the initializer may already exist for other reasons and you would not need to do any extra work.<br></p><p>True. But it may also exist and *not* do what you want in the forwarding case. It&#39;s easier to explicitly use the right initializer than it is to work around the forwarding system implicitly using the wrong one.<br></p><p>&gt; A big advantage of this approach is that it would work even when you are forwarding different protocols to more than one member with the same type.<br></p><p>But again, if that&#39;s the wrong behavior, there&#39;s no good way to fix it.<br></p><p>&gt;&gt; * If you want to keep the method-based syntax, would it make sense to instead have an initializer for instance initializers too, and just have it take a second parameter with the instance?<br>&gt;&gt; <br>&gt;&gt; 	init(forwardedReturnValue: Int) {...}<br>&gt;&gt; 	init(forwardedReturnValue: Int, from: NumberWrapper) {…}<br>&gt; <br>&gt; Part of the reason the instance method was used is because sometimes the right thing to do might be to mutate and then return self.  Using an instance method gives you the flexibility to do that if necessary.<br></p><p>In practice, I&#39;m not sure that&#39;s actually the case very often. How frequently will the internal type return a changed value, but your identically-named cover method ought to mutate the property? That completely changes the semantics of the underlying call.<br></p><p>I mean, what you&#39;re proposing would be something like this:<br></p><p>	class ListOfThings {<br>		private var actualList: [Thing]<br>		<br>		func filter(predicate: Thing -&gt; Bool) -&gt; ListOfThings {<br>			let returnValue = actualList.filter(predicate)<br>			actualList = returnValue<br>			return ListOfThings(returnValue)<br>		}<br>	}<br></p><p>Is that a thing you actually expect people to do?<br></p><p>&gt;&gt; * Does this mean that a `public forward` declaration would forward `internal` members through synthesized `public` interfaces, if the forwarder and forwardee happened to be in the same module?<br>&gt;&gt; <br>&gt;&gt;&gt; All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br>&gt; <br>&gt; Yes, if the forwardee had internal visibility and the forwarder was public the forwarder could publicly forward the interface.  This is intentional behavior.  The forwardee may well be an internal implementation detail while the methods of the protocol are part of the public interface of the forwarder.  It is possible to write code that does this manually today.<br></p><p>I suppose that, if it&#39;s always a protocol you&#39;re forwarding to, you can assume that none of the protocol methods are internal-only implementation details. But I have to admit that I&#39;m still concerned about this; it just seems like a recipe for accidentally exposing things you meant to keep private.<br></p><p>&gt;&gt; * You don&#39;t explicitly mention this, but I assume mutating methods work and mutate `self`?<br>&gt; <br>&gt; Mutating methods are something I didn’t think about carefully yet.  Thanks for pointing that out!  But generally, yes a forwarding implementation of a mutating method would need to mutate the forwardee which is part of self, thus mutating self.<br></p><p>Well, as long as they&#39;re thought about at some point!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 6:10 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; * Does it have to be a protocol? Why not also allow the concrete type of the property you&#39;re forwarding to? Obviously you couldn&#39;t form a subtype relationship (unless you could...), but this might be useful to reduce boilerplate when you&#39;re proxying something.<br>&gt;&gt; <br>&gt;&gt; This is addressed in the alternatives considered section.<br>&gt; <br>&gt; Sorry, I missed that, probably because the sample code in that section didn&#39;t show such a forwarding.<br>&gt; <br>&gt;&gt; The short answer is that there the direct interface of the concrete type does not contain sufficient information about potential Self parameters to do this well.  This information does exist in the protocol declarations.  Allowing this information to be specified in concrete interfaces would add enough complexity to the language that I don’t think it is worthwhile.<br>&gt; <br>&gt; That&#39;s a good point. You could perhaps add a way to tweak the forwarding of certain members, but that&#39;d be a little tricky.<br></p><p>I gave this enough consideration to be leaning pretty strongly in the direction that protocols are the best way to do this.  <br></p><p>Doing this properly for the concrete interface would require an `InvariantSelf` type that could be used in any method signature.  It would also need to be actually used correctly in practice by types that were forwarded to.  The distinction is pretty subtle when you’re dealing with a concrete interface and my instinct is that people would get it wrong a lot of the time.  <br></p><p>Because protocols are inherently generic it is a little more straightforward to think about when you mean `Self` and when you mean a concrete type.<br></p><p>The good news is that you can declare a protocol containing the full interface of a concrete type if you really want or need to and use that for forwarding.  The advantage of requiring a protocol here is that it requires you to consciously think about whether each parameter and return type is intended to be concrete or an abstract Self.  It also allows you to properly forward an interface even if the original author did not consider these issues when implementing the type.<br></p><p>In the following example, should the other parameter and the return type be `Self ` or `Double`?  It is not possible to know unless there is a protocol that declares foo.<br></p><p>extension Double {<br>    func foo(other: Double) -&gt; Double {<br>        return self<br>    }<br>}<br></p><p>&gt; <br>&gt; One of the things I&#39;d like to see is the ability to proxy for an instance without the person writing the proxy knowing which instances it&#39;ll be used with. Think, for example, of the Cocoa animator proxy, or `NSUndoManager.prepareWithInvocationTarget(_:)`. It&#39;d be nice if a Swift equivalent could return, say, `NSAnimatorProxy&lt;View&gt;` or `NSUndoManager.InvocationTarget&lt;Target&gt;`, which has all the methods of the generic type but records the calls for later use.<br>&gt; <br>&gt; Of course, what you really want is for only a particular subset of the methods to be available on the proxy (animated methods on `NSAnimatorProxy`, Void methods on `NSUndoManager.InvocationTarget`), and of course in these cases you&#39;re not calling directly through to the underlying methods. So I might just be barking up the wrong tree here.<br></p><p>I can see how it might be desirable to forward to a type you receive as a generic parameter.  However, you would need to constrain that type to a protocol(s) in order to actually do anything useful with it.  That same protocol(s) could also be used in the forwarding declaration.<br></p><p>If you want is to be able to forward a set of methods that is determined by the generic parameter, that just isn’t going to be possible.  At least not without significant changes to other parts of the language providing capabilities that would allow you to implement something like that manually.<br></p><p>&gt; <br>&gt;&gt;&gt; * Why the method-based conversion syntax for return values, rather than something a little more like a property declaration?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var number: Int<br>&gt;&gt;&gt; 	forward IntegerType to number {<br>&gt;&gt;&gt; 		static return(newValue: Int) {<br>&gt;&gt;&gt; 			return NumberWrapper(newValue)<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 		return(newValue: Int) {<br>&gt;&gt;&gt; 			return NumberWrapper(newValue)<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; This is actually a really good idea to consider!  I didn’t consider something like this mostly because I didn’t think of it.  I’m going to seriously consider adopting an approach along these lines.<br>&gt; <br>&gt; Great.<br>&gt; <br>&gt;&gt; One possible advantage of the approach I used is that the initializer may already exist for other reasons and you would not need to do any extra work.<br>&gt; <br>&gt; True. But it may also exist and *not* do what you want in the forwarding case. It&#39;s easier to explicitly use the right initializer than it is to work around the forwarding system implicitly using the wrong one.<br></p><p>Right, I am generally leaning pretty strongly towards changing the proposal to use a solution similar to what you suggest.<br></p><p>&gt; <br>&gt;&gt; A big advantage of this approach is that it would work even when you are forwarding different protocols to more than one member with the same type.<br>&gt; <br>&gt; But again, if that&#39;s the wrong behavior, there&#39;s no good way to fix it.<br></p><p>I was actually indicating an advantage of the approach you suggested because it provides a solution to that problem. :)<br></p><p>&gt; <br>&gt;&gt;&gt; * If you want to keep the method-based syntax, would it make sense to instead have an initializer for instance initializers too, and just have it take a second parameter with the instance?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	init(forwardedReturnValue: Int) {...}<br>&gt;&gt;&gt; 	init(forwardedReturnValue: Int, from: NumberWrapper) {…}<br>&gt;&gt; <br>&gt;&gt; Part of the reason the instance method was used is because sometimes the right thing to do might be to mutate and then return self.  Using an instance method gives you the flexibility to do that if necessary.<br>&gt; <br>&gt; In practice, I&#39;m not sure that&#39;s actually the case very often. How frequently will the internal type return a changed value, but your identically-named cover method ought to mutate the property? That completely changes the semantics of the underlying call.<br></p><p>I would guess you are right about this being something that is never or almost never the right thing to do.  Maybe a solution that actually prevents you from doing this would be a better one for that reason. <br></p><p>&gt; <br>&gt; I mean, what you&#39;re proposing would be something like this:<br>&gt; <br>&gt; 	class ListOfThings {<br>&gt; 		private var actualList: [Thing]<br>&gt; 		<br>&gt; 		func filter(predicate: Thing -&gt; Bool) -&gt; ListOfThings {<br>&gt; 			let returnValue = actualList.filter(predicate)<br>&gt; 			actualList = returnValue<br>&gt; 			return ListOfThings(returnValue)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; Is that a thing you actually expect people to do?<br></p><p>I hope not! :)  I hadn’t looked too hard for an example where it would be the right thing to do and I think you are right that such an example would be pretty hard to come by.  Thanks for pushing back on this one! :)<br></p><p>&gt; <br>&gt;&gt;&gt; * Does this mean that a `public forward` declaration would forward `internal` members through synthesized `public` interfaces, if the forwarder and forwardee happened to be in the same module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br>&gt;&gt; <br>&gt;&gt; Yes, if the forwardee had internal visibility and the forwarder was public the forwarder could publicly forward the interface.  This is intentional behavior.  The forwardee may well be an internal implementation detail while the methods of the protocol are part of the public interface of the forwarder.  It is possible to write code that does this manually today.<br>&gt; <br>&gt; I suppose that, if it&#39;s always a protocol you&#39;re forwarding to, you can assume that none of the protocol methods are internal-only implementation details. But I have to admit that I&#39;m still concerned about this; it just seems like a recipe for accidentally exposing things you meant to keep private.<br></p><p>Think of a state or strategy pattern.  You might have an internal protocol with several implementations representing the various states or strategies.  You forward to a private member that is an existential of the protocol type.  The synthesized forwarding methods represent the public interface.  However, the protocol itself is not public as it is an implementation detail and the forwarder doesn’t even conform to the protocol.  The protocol is strictly used as an implementation detail of the public interface of your type.<br></p><p>I honestly don’t understand the concern about this proposal accidentally exposing things you meant to keep private.  You have full control over access control of everything, including the synthesized methods.  The proposal doesn’t do anything you couldn’t already do manually and it makes it very easy to keep them private if desired.  If somebody wanted to manually write a forwarder that declares forwarding methods public while forwarding to internal methods on the forwardee they can do that already today!  <br></p><p>IMO the language needs to provide the tools to specify your intent clearly and easily and offer sensible defaults, but it can’t do more than that.  I believe this proposal falls in line with that principle and also inline with how access control already works in the language today (the default for synthesized members matches the default for manual member declarations).<br></p><p>I am very concerned about not exposing details that shouldn’t be exposed and that is one of the big drawbacks of the approach to protocol forwarding that Kevin Ballard shared.<br></p><p>&gt; <br>&gt;&gt;&gt; * You don&#39;t explicitly mention this, but I assume mutating methods work and mutate `self`?<br>&gt;&gt; <br>&gt;&gt; Mutating methods are something I didn’t think about carefully yet.  Thanks for pointing that out!  But generally, yes a forwarding implementation of a mutating method would need to mutate the forwardee which is part of self, thus mutating self.<br>&gt; <br>&gt; Well, as long as they&#39;re thought about at some point!<br></p><p>Yes, I’m glad you brought them up!<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/58cac2a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 29, 2015 at 05:00:00pm</p></header><div class="content"><p>Strong +1 on this proposal. I use Objective-C’s forwarding mechanisms quite often in my custom view code, in order to separate the code managing the outer view, the layout of subviews within the view, and business logic into separate classes, all while presenting a single, monolithic interface to the user. The loss of this ability without writing tons of boilerplate is one of the things about Swift that makes me sad.<br></p><p>The one thing I’d change is upgrading the partial forwarding synthesis to the original proposal, as that’s a rather important feature IMO.<br></p><p>Charles<br></p><p>&gt; On Dec 29, 2015, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>&gt; Automatic protocol forwarding<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-automatic-protocol-forwarding.md&gt;<br>&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Automatic protocol forwarding introduces the ability to use delegation without the need write forwarding member implementations manually. <br>&gt; <br>&gt; A preliminary mailing list thread on this topic had the subject protocol based invocation forwarding &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000931.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Delegation is a robust, composition oriented design technique that keeps interface and implementation inheritance separate. The primary drawback to this technique is that it requires a lot of manual boilerplate to forward implemenation to the implementing member. This proposal eliminates the need to write such boilerplate manually, thus making delegation-based designs much more convenient and attractive.<br>&gt; <br>&gt; This proposal may also serve as the foundation for a future enhancement allowing a very concise “newtype” declaration.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; I propose introducing a forward declaration be allowed within a type declaration or type extension. The forward declaration will cause the compiler to synthesize implementations of the members required by the forwarded protocols. The synthesized implementations will simply forward the method call to the specified member.<br>&gt; <br>&gt; The basic declaration looks like this:<br>&gt; <br>&gt; forward Protocol, OtherProtocol to memberIdentifier<br>&gt; The first clause contains a list of protocols to forward. <br>&gt; <br>&gt; The second clause specifies the identifier of the property to which the protocol members will be forwarded. Any visible property that implements the members required by the protocol is eligible for forwarding. It does not matter whether it is stored, computed, lazy, etc.<br>&gt; <br>&gt; It is also possible to include an access control declaration modifier to specify the visibility of the synthesized members.<br>&gt; <br>&gt; Self parameters<br>&gt; <br>&gt; When a protocol member includes a Self parameter forwarding implementations must accept the forwarding type but supply an argument of the forwardee type when making the forwarding call. The most straightforward way to do this is to simply use the same property getter that is used when forwarding. This is the proposed solution.<br>&gt; <br>&gt; Self return types<br>&gt; <br>&gt; When a protocol member includes a Self return type forwarding implementations must return the forwarding type. However, the forwardee implmentation will return a value of the forwardee type. This result must be used to produce a value of the forwarding type in some way.<br>&gt; <br>&gt; The solution in this proposal is based on an ad-hoc overloading convention. A protocol-based solution would probably be desirable if it were possible, however it is not. This proposal supports forwarding to more than one member, possibly with different types. A protocol-based solution would require the forwarding type to conform to the “Self return value conversion” protocol once for each forwardee type.<br>&gt; <br>&gt; Static members<br>&gt; <br>&gt; When a forwardee value is returned from a static member an initializer will be used to produce a final return value. The initializer must be visible at the source location of the forward declaration and must look like this:<br>&gt; <br>&gt; struct Forwarder {<br>&gt;     let forwardee: Forwardee<br>&gt;     forward P to forwardee<br>&gt;     init(_ forwardeeReturnValue: Forwardee) { //... }<br>&gt; }<br>&gt; Instance members<br>&gt; <br>&gt; When a forwardee value is returned from an instance member an instance method will be used to transform the return value into a value of the correct type. An instance method is necessary in order to allow the forwarding type to access the state of the instance upon which the method was called when performing the transformation.<br>&gt; <br>&gt; If the instance method is not implemented the initializer used for static members will be used instead.<br>&gt; <br>&gt; The transformation has the form:<br>&gt; <br>&gt; struct Forwarder {<br>&gt;     let forwardee: Forwardee<br>&gt;     forward P to forwardee<br>&gt;     func transformedForwardingReturnValue(forwardeeReturnValue: Forwardee) -&gt; Forwarder { //... }<br>&gt; }<br>&gt; NOTE: This method should have a better name. Suggestions are appreciated!<br>&gt; <br>&gt; Examples<br>&gt; <br>&gt; Basic example<br>&gt; <br>&gt; NOTE: Forwardee does not actually conform to P itself. Conformance is not required to synthesize the forwarding member implementations. It is only required that members necessary for forwarding exist. This is particularly important to the second example.<br>&gt; <br>&gt; public protocol P {<br>&gt;     typealias TA<br>&gt;     var i: Int<br>&gt;     func foo() -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; private struct Forwardee {<br>&gt;     typealias TA = String<br>&gt;     var i: Int = 42<br>&gt;     func foo() -&gt; Bool { return true }<br>&gt; }<br>&gt; <br>&gt; public struct Forwarder {<br>&gt;     private let forwardee: Forwardee<br>&gt; }<br>&gt; <br>&gt; extension Forwarder: P {	<br>&gt;     // user declares<br>&gt;     public forward P to forwardee<br>&gt;     <br>&gt;     // compiler synthesizes<br>&gt;     // TA must be synthesized as it cannot be inferred for this protocol<br>&gt;     public typealias TA = String <br>&gt;     public var i: Int {<br>&gt;         get { return forwardee.i }<br>&gt;         set { forwardee.i = newValue }<br>&gt;     }<br>&gt;     public func foo() -&gt; Bool { <br>&gt;         return forwardee.foo() <br>&gt;     }<br>&gt; }<br>&gt; Existential forwardee<br>&gt; <br>&gt; NOTE: Existentials of type P do not actually conform to P itself. Conformance is not required to synthesize the forwarding member implementations. It is only required that members necessary for forwarding exist.<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo() -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     private let p: P<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P to p<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo() -&gt; Bool {<br>&gt;         return p.foo()<br>&gt;     }<br>&gt; }<br>&gt; Self parameters<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo(value: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension Int: P {<br>&gt;     func foo(value: Int) -&gt; Bool {<br>&gt;         return value != self<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     private let i: Int<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P to i<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo(value: S) -&gt; Bool {<br>&gt;         return i.foo(value.i)<br>&gt;     }<br>&gt; }<br>&gt; Self return types<br>&gt; <br>&gt; Using the instance method:<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension Int: P {<br>&gt;     func foo() -&gt; Int {<br>&gt;         return self + 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     private let i: Int<br>&gt;     func transformedForwardingReturnValue(forwardeeReturnValue: Int) -&gt; S {<br>&gt;         return S(i: forwardeeReturnValue)<br>&gt;     }<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P to i<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo() -&gt; S {<br>&gt;         return self.transformedForwardingReturnValue(i.foo())<br>&gt;     }<br>&gt; }<br>&gt; Using the initializer:<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension Int: P {<br>&gt;     func foo() -&gt; Int {<br>&gt;         return self + 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     private let i: Int<br>&gt;     init(_ value: Int) {<br>&gt;         i = value<br>&gt;     }<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P to i<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo() -&gt; S {<br>&gt;         return S(i.foo())<br>&gt;     }<br>&gt; }<br>&gt; Forwarding multiple protocols<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo() -&gt; Bool<br>&gt; }<br>&gt; public protocol Q {<br>&gt;     func bar() -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension Int: P, Q {<br>&gt;     func foo() -&gt; Bool {<br>&gt;         return true<br>&gt;     }<br>&gt;     func bar() -&gt; Bool {<br>&gt;         return false<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; struct S: P, Q {<br>&gt;     private let i: Int<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P, Q to i<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo() -&gt; Bool {<br>&gt;         return i.foo()<br>&gt;     }<br>&gt;     func bar() -&gt; Bool {<br>&gt;         return i.bar()<br>&gt;     }<br>&gt; }<br>&gt; Forwarding to multiple members<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo() -&gt; Bool<br>&gt; }<br>&gt; public protocol Q {<br>&gt;     func bar() -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension Int: P {<br>&gt;     func foo() -&gt; Bool {<br>&gt;         return true<br>&gt;     }<br>&gt; }<br>&gt; extension Double: Q {<br>&gt;     func bar() -&gt; Bool {<br>&gt;         return false<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; struct S: P, Q {<br>&gt;     private let i: Int<br>&gt;     private let d: Double<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P to i<br>&gt;     forward Q to d<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo() -&gt; Bool {<br>&gt;         return i.foo()<br>&gt;     }<br>&gt;     func bar() -&gt; Bool {<br>&gt;         return d.bar()<br>&gt;     }<br>&gt; }<br>&gt; Non-final class<br>&gt; <br>&gt; NOTE: C cannot declare conformance to the protocol due to the Self return value requirement. However, the compiler still synthesizes the forwarding methods and allows them to be used directly by users of C.<br>&gt; <br>&gt; public protocol P {<br>&gt;     func foo() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension Int: P {<br>&gt;     func foo() -&gt; Int {<br>&gt;         return self + 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // C does not and cannot declare conformance to P<br>&gt; class C {<br>&gt;     private let i: Int<br>&gt;     init(_ value: Int) {<br>&gt;         i = value<br>&gt;     }<br>&gt;     <br>&gt;     // user declares:<br>&gt;     forward P to i<br>&gt;     <br>&gt;     // compiler synthesizes:<br>&gt;     func foo() -&gt; C {<br>&gt;         return C(i.foo())<br>&gt;     }<br>&gt; }<br>&gt; Detailed design<br>&gt; <br>&gt; TODO: grammar modification to add the forward declaration<br>&gt; <br>&gt; Automatic forwarding only synthesizes member implementations. It does not automatically conform the forwarding type to the protocol(s) that are forwarded. If actual conformance is desired (as it usually will be) it must be explicitly stated.<br>&gt; The forwardee type need not actually conform to the protocol forwarded to it. It only needs to implement the members the forwarder must access in the synthesized forwarding methods. This is particularly important as long as protocol existentials do not conform to the protocol itself.<br>&gt; While it will not be possible to conform non-final classes to protocols containing a Self return type forwarding should still be allowed. The synthesized methods will have a return type of the non-final class which in which the forwarding declaration occured. The synthesized methods may still be useful in cases where actual protocol conformance is not necessary.<br>&gt; All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br>&gt; TODO: How should other annotations on the forwardee implementations of forwarded members (such as @warn_unused_result) be handled? <br>&gt; It is possible that the member implementations synthesized by forwarding will conflict with existing members or with each other (when forwarding more than one protocol). All such conflicts, with one exception, should produce a compiler error at the site of the forwarding declaration which resulted in conflicting members.<br>&gt; One specific case that should not be considered a conflict is when forwarding more than one protocol with identical member declarations to the same member of the forwarding type. In this case the synthesized implementation required to forward all of the protocols is identical. The compiler should not synthesize multiple copies of the implementation and then report a redeclaration error.<br>&gt; It is likely that any attempt to forward different protocols with Self return types to more than one member of the same type will result in sensible behavior. This should probable be a compiler error. For example:<br>&gt; protocol P {<br>&gt;     func foo() -&gt; Self<br>&gt; }<br>&gt; protocol Q {<br>&gt;     func bar() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; struct Forwarder: P, Q {<br>&gt;     let d1: Double<br>&gt;     let d2: Double<br>&gt;     <br>&gt;     forward P to d1<br>&gt;     forward Q to d2<br>&gt; <br>&gt;     func transformedForwardingReturnValue(_ forwardeeReturnValue: Double) -&gt; Forwarder { <br>&gt;         // What do we do here?  <br>&gt;         // We don&#39;t know if the return value resulted from forwarding foo to d1 or bar to d2.<br>&gt;         // It is unlikely that the same behavior is correct in both cases.<br>&gt;     }<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt; <br>&gt; Future enhancements<br>&gt; <br>&gt; In the spirit of incremental change, this proposal focuses on core functionality. Several enhancements to the core functionality are possible and are likely to be explored in the future.<br>&gt; <br>&gt; Partial forwarding synthesis<br>&gt; <br>&gt; The current proposal makes automatic forwarding an “all or nothing” feature. In cases where you want to forward most of the implementation of a set of members but would need to “override” one or more specific members the current proposal will not help. You will still be required to forward the entire protocol manually. Attempting to implement some specific members manually will result in a redeclaration error.<br>&gt; <br>&gt; This proposal does not allow partial forwarding synthesis in order to focus on the basic forwarding mechanism and allow us to gain some experience with that first, before considering the best way to make partial forwarding possible without introducing unintended potential for error. One example of a consideration that may apply is whether or not forwardee types should be able to mark members as “final for forwarding” in some way that prevents them from being “overriden” by a forwarder.<br>&gt; <br>&gt; Newtype<br>&gt; <br>&gt; While the current proposal provides the basic behavior desired for newtype, it is not as concise as it could be. Adding syntactic sugar to make this common case more concise would be straightforward:<br>&gt; <br>&gt; // user declares<br>&gt; newtype Weight = Double forwarding P, Q<br>&gt; <br>&gt; // compiler synthesizes<br>&gt; struct Weight: P, Q {<br>&gt;     var value: Double<br>&gt;     forward P, Q to value<br>&gt;     init(_ value: Double) { self.value = value }<br>&gt; }<br>&gt; However, there are additional nuances related to associated types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004735.html&gt; that should be considered and addressed by a newtype proposal.<br>&gt; <br>&gt; Forwarding declaration in protocol extensions<br>&gt; <br>&gt; It may be possible to allow the forward declaration in protocol extensions by forwarding to a required property of the protocol. This may have implementation complexities and other implications which would hold back the current proposal if it required the forward declaration to be allowed in protocol extensions. <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Specify forwarding as part of the member declaration<br>&gt; <br>&gt; I originally thought it would make the most sense to specify forwarding alongside the forwardee member declaration. This proposal does not do so for the following reasons:<br>&gt; <br>&gt; We must be able to specify access control for the forwarded members that are synthesized. Introducing a forwarding declaration is the most clear way to allow this.<br>&gt; It will sometimes be necessary to forward different protocols to the same forwardee with different access control levels. It would be very clunky to do this as part of the member declaration.<br>&gt; It should be possible to synthesize forwarding retroactively as part of an extension. This would not be possible if forwarding had to be specified in the original member declaration.<br>&gt; Require the forwardee to conform to the protocol(s) forwarded to it<br>&gt; <br>&gt; There is not a compelling reason to require this. It is not necessary to synthesize and compile the forwarding methods and it would prevent the use of protocol existentials as the forwardee.<br>&gt; <br>&gt; Automatically conform the forwarding type to the forwarded protocol(s)<br>&gt; <br>&gt; It may seem reasonable to automatically synthesize conformance to the protocol in addition to the member implementations. This proposal does not do so for the following reasons:<br>&gt; <br>&gt; Forwarding is considered an implementation detail that is not necessarily visible in the public interface of the type. The forwardee may be a private member of the type.<br>&gt; Type authors may wish to control where the actual conformance is declared, especially if protocol conformances are allowed to have access control in the future.<br>&gt; There may be use cases where it is desirable to have the forwarded members synthesized without actually conforming to the protocol. This is somewhat speculative, but there is not a compelling reason to disallow it.<br>&gt; Allow forwarding of all protocols conformed to by the forwardee without explicitly listing them<br>&gt; <br>&gt; It may seem reasonable to have a * placeholder which will forward all visible protocol conformances of the forwardee type. This proposal does not include such a placeholder for the following reasons:<br>&gt; <br>&gt; A placeholder like this could lead to unintended operations being synthesized if additional conformances are declared in the future. The new conformances could even lead to conflicts during synthesis which cause the code to fail to compile. The potential for such breakage is not acceptable.<br>&gt; A placeholder like this would not necessarily cause all desired forwarding methods to be synthesized. This would be the case when the members necessary to conform exist but actual conformance does not exist. This would be the case when the forwardee type is an existential. This could lead to programmer confusion.<br>&gt; An explicit list of protocols to forward is not unduely burdensome. It is straightforward to declare a new protocol that inherits from a group of protocols which are commonly forwarded together and use the new protocol in the forwarding declaration.<br>&gt; This is easily added as a future enhancement to the current proposal if we later decide it is necessary.<br>&gt; Allow forwarding of the entire interface of the forwardee type, not just specific protocols<br>&gt; <br>&gt; It is impossible to synthesize forwarding of methods which contain the forwardee type as a parameter or return type that are not declared as part of a protocol interface in a correct and safe manner. This is because it may or may not be correct to promote the forwardee type in the signature to the forwarder. <br>&gt; <br>&gt; As an example, consider the following extension to Double. Imagine trying to synthesize a forwarding method in a Pixel type that forwards to Double. Should the return type be Pixel or Double? It is impossible to tell for sure.<br>&gt; <br>&gt; extension Double {<br>&gt;     func foo() -&gt; Double {<br>&gt;         return self<br>&gt;     }<br>&gt; }<br>&gt; When the method is declared in a protocol it becomes obvious what the signature of the forwarding method must be. If the protocol declares the return type as Self, the forwarding method must have a return type of Pixel. If the protocol declares the return type as Double the forwarding method will continue to have a return type of Double.<br>&gt; <br>&gt; Allow forwarding to Optional members<br>&gt; <br>&gt; It may seem like a good idea to allow synthesized forwarding to Optional members where a no-op results when the Optional is nil. There is no way to make this work in general as it would be impossible to forward any member requiring a return value. If use cases for forwarding to Optionalmembers emerege that are restricted to protocols with no members requiring return values the automatic protocol forwarding feature could be enhanced in the future to support these use cases.<br>&gt; <br>&gt; Allow forwarding the same protocol(s) to more than one member<br>&gt; <br>&gt; As with forwarding to Optional members, forwarding the same protocol to more than one member is not possible in general. However it is possible in cases where no protocol members have a return value. If compelling use cases emerge to motivate automatic forwarding of such protocols to more than one member an enhancement could be proposed in the future.<br>&gt; <br>&gt; Provide a mechanism for forwardees to know about the forwarder<br>&gt; <br>&gt; Some types may be designed to be used as components that are always forwarded to by other types. Such types may wish to be able to communicate with the forwarding type in some way. This can be accomplished manually. <br>&gt; <br>&gt; If general patterns emerge in practice it may be possible to add support for them to the language. However, it would be preliminary to consider support for such a feature until we have significant experience with the basic forwarding mechanism itself.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/3df49a0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 5:25 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Strong +1 on this proposal. I use Objective-C’s forwarding mechanisms quite often in my custom view code, in order to separate the code managing the outer view, the layout of subviews within the view, and business logic into separate classes, all while presenting a single, monolithic interface to the user. The loss of this ability without writing tons of boilerplate is one of the things about Swift that makes me sad.<br>&gt; <br>&gt; The one thing I’d change is upgrading the partial forwarding synthesis to the original proposal, as that’s a rather important feature IMO.<br>&gt; <br></p><p>Thanks Charles.  Do you disagree with the reasons I decided not to include partial forwarding in the initial proposal (it is discussed in alternatives considered)?<br></p><p><br>&gt; Charles<br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>&gt;&gt; Automatic protocol forwarding<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-automatic-protocol-forwarding.md&gt;<br>&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Automatic protocol forwarding introduces the ability to use delegation without the need write forwarding member implementations manually. <br>&gt;&gt; <br>&gt;&gt; A preliminary mailing list thread on this topic had the subject protocol based invocation forwarding &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000931.html&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Delegation is a robust, composition oriented design technique that keeps interface and implementation inheritance separate. The primary drawback to this technique is that it requires a lot of manual boilerplate to forward implemenation to the implementing member. This proposal eliminates the need to write such boilerplate manually, thus making delegation-based designs much more convenient and attractive.<br>&gt;&gt; <br>&gt;&gt; This proposal may also serve as the foundation for a future enhancement allowing a very concise “newtype” declaration.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose introducing a forward declaration be allowed within a type declaration or type extension. The forward declaration will cause the compiler to synthesize implementations of the members required by the forwarded protocols. The synthesized implementations will simply forward the method call to the specified member.<br>&gt;&gt; <br>&gt;&gt; The basic declaration looks like this:<br>&gt;&gt; <br>&gt;&gt; forward Protocol, OtherProtocol to memberIdentifier<br>&gt;&gt; The first clause contains a list of protocols to forward. <br>&gt;&gt; <br>&gt;&gt; The second clause specifies the identifier of the property to which the protocol members will be forwarded. Any visible property that implements the members required by the protocol is eligible for forwarding. It does not matter whether it is stored, computed, lazy, etc.<br>&gt;&gt; <br>&gt;&gt; It is also possible to include an access control declaration modifier to specify the visibility of the synthesized members.<br>&gt;&gt; <br>&gt;&gt; Self parameters<br>&gt;&gt; <br>&gt;&gt; When a protocol member includes a Self parameter forwarding implementations must accept the forwarding type but supply an argument of the forwardee type when making the forwarding call. The most straightforward way to do this is to simply use the same property getter that is used when forwarding. This is the proposed solution.<br>&gt;&gt; <br>&gt;&gt; Self return types<br>&gt;&gt; <br>&gt;&gt; When a protocol member includes a Self return type forwarding implementations must return the forwarding type. However, the forwardee implmentation will return a value of the forwardee type. This result must be used to produce a value of the forwarding type in some way.<br>&gt;&gt; <br>&gt;&gt; The solution in this proposal is based on an ad-hoc overloading convention. A protocol-based solution would probably be desirable if it were possible, however it is not. This proposal supports forwarding to more than one member, possibly with different types. A protocol-based solution would require the forwarding type to conform to the “Self return value conversion” protocol once for each forwardee type.<br>&gt;&gt; <br>&gt;&gt; Static members<br>&gt;&gt; <br>&gt;&gt; When a forwardee value is returned from a static member an initializer will be used to produce a final return value. The initializer must be visible at the source location of the forward declaration and must look like this:<br>&gt;&gt; <br>&gt;&gt; struct Forwarder {<br>&gt;&gt;     let forwardee: Forwardee<br>&gt;&gt;     forward P to forwardee<br>&gt;&gt;     init(_ forwardeeReturnValue: Forwardee) { //... }<br>&gt;&gt; }<br>&gt;&gt; Instance members<br>&gt;&gt; <br>&gt;&gt; When a forwardee value is returned from an instance member an instance method will be used to transform the return value into a value of the correct type. An instance method is necessary in order to allow the forwarding type to access the state of the instance upon which the method was called when performing the transformation.<br>&gt;&gt; <br>&gt;&gt; If the instance method is not implemented the initializer used for static members will be used instead.<br>&gt;&gt; <br>&gt;&gt; The transformation has the form:<br>&gt;&gt; <br>&gt;&gt; struct Forwarder {<br>&gt;&gt;     let forwardee: Forwardee<br>&gt;&gt;     forward P to forwardee<br>&gt;&gt;     func transformedForwardingReturnValue(forwardeeReturnValue: Forwardee) -&gt; Forwarder { //... }<br>&gt;&gt; }<br>&gt;&gt; NOTE: This method should have a better name. Suggestions are appreciated!<br>&gt;&gt; <br>&gt;&gt; Examples<br>&gt;&gt; <br>&gt;&gt; Basic example<br>&gt;&gt; <br>&gt;&gt; NOTE: Forwardee does not actually conform to P itself. Conformance is not required to synthesize the forwarding member implementations. It is only required that members necessary for forwarding exist. This is particularly important to the second example.<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     typealias TA<br>&gt;&gt;     var i: Int<br>&gt;&gt;     func foo() -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private struct Forwardee {<br>&gt;&gt;     typealias TA = String<br>&gt;&gt;     var i: Int = 42<br>&gt;&gt;     func foo() -&gt; Bool { return true }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct Forwarder {<br>&gt;&gt;     private let forwardee: Forwardee<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Forwarder: P {	<br>&gt;&gt;     // user declares<br>&gt;&gt;     public forward P to forwardee<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes<br>&gt;&gt;     // TA must be synthesized as it cannot be inferred for this protocol<br>&gt;&gt;     public typealias TA = String <br>&gt;&gt;     public var i: Int {<br>&gt;&gt;         get { return forwardee.i }<br>&gt;&gt;         set { forwardee.i = newValue }<br>&gt;&gt;     }<br>&gt;&gt;     public func foo() -&gt; Bool { <br>&gt;&gt;         return forwardee.foo() <br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Existential forwardee<br>&gt;&gt; <br>&gt;&gt; NOTE: Existentials of type P do not actually conform to P itself. Conformance is not required to synthesize the forwarding member implementations. It is only required that members necessary for forwarding exist.<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo() -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     private let p: P<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P to p<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo() -&gt; Bool {<br>&gt;&gt;         return p.foo()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Self parameters<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo(value: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int: P {<br>&gt;&gt;     func foo(value: Int) -&gt; Bool {<br>&gt;&gt;         return value != self<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     private let i: Int<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P to i<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo(value: S) -&gt; Bool {<br>&gt;&gt;         return i.foo(value.i)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Self return types<br>&gt;&gt; <br>&gt;&gt; Using the instance method:<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int: P {<br>&gt;&gt;     func foo() -&gt; Int {<br>&gt;&gt;         return self + 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     private let i: Int<br>&gt;&gt;     func transformedForwardingReturnValue(forwardeeReturnValue: Int) -&gt; S {<br>&gt;&gt;         return S(i: forwardeeReturnValue)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P to i<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo() -&gt; S {<br>&gt;&gt;         return self.transformedForwardingReturnValue(i.foo())<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Using the initializer:<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int: P {<br>&gt;&gt;     func foo() -&gt; Int {<br>&gt;&gt;         return self + 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     private let i: Int<br>&gt;&gt;     init(_ value: Int) {<br>&gt;&gt;         i = value<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P to i<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo() -&gt; S {<br>&gt;&gt;         return S(i.foo())<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Forwarding multiple protocols<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo() -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; public protocol Q {<br>&gt;&gt;     func bar() -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int: P, Q {<br>&gt;&gt;     func foo() -&gt; Bool {<br>&gt;&gt;         return true<br>&gt;&gt;     }<br>&gt;&gt;     func bar() -&gt; Bool {<br>&gt;&gt;         return false<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P, Q {<br>&gt;&gt;     private let i: Int<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P, Q to i<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo() -&gt; Bool {<br>&gt;&gt;         return i.foo()<br>&gt;&gt;     }<br>&gt;&gt;     func bar() -&gt; Bool {<br>&gt;&gt;         return i.bar()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Forwarding to multiple members<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo() -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; public protocol Q {<br>&gt;&gt;     func bar() -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int: P {<br>&gt;&gt;     func foo() -&gt; Bool {<br>&gt;&gt;         return true<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; extension Double: Q {<br>&gt;&gt;     func bar() -&gt; Bool {<br>&gt;&gt;         return false<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P, Q {<br>&gt;&gt;     private let i: Int<br>&gt;&gt;     private let d: Double<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P to i<br>&gt;&gt;     forward Q to d<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo() -&gt; Bool {<br>&gt;&gt;         return i.foo()<br>&gt;&gt;     }<br>&gt;&gt;     func bar() -&gt; Bool {<br>&gt;&gt;         return d.bar()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Non-final class<br>&gt;&gt; <br>&gt;&gt; NOTE: C cannot declare conformance to the protocol due to the Self return value requirement. However, the compiler still synthesizes the forwarding methods and allows them to be used directly by users of C.<br>&gt;&gt; <br>&gt;&gt; public protocol P {<br>&gt;&gt;     func foo() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int: P {<br>&gt;&gt;     func foo() -&gt; Int {<br>&gt;&gt;         return self + 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // C does not and cannot declare conformance to P<br>&gt;&gt; class C {<br>&gt;&gt;     private let i: Int<br>&gt;&gt;     init(_ value: Int) {<br>&gt;&gt;         i = value<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // user declares:<br>&gt;&gt;     forward P to i<br>&gt;&gt;     <br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     func foo() -&gt; C {<br>&gt;&gt;         return C(i.foo())<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; TODO: grammar modification to add the forward declaration<br>&gt;&gt; <br>&gt;&gt; Automatic forwarding only synthesizes member implementations. It does not automatically conform the forwarding type to the protocol(s) that are forwarded. If actual conformance is desired (as it usually will be) it must be explicitly stated.<br>&gt;&gt; The forwardee type need not actually conform to the protocol forwarded to it. It only needs to implement the members the forwarder must access in the synthesized forwarding methods. This is particularly important as long as protocol existentials do not conform to the protocol itself.<br>&gt;&gt; While it will not be possible to conform non-final classes to protocols containing a Self return type forwarding should still be allowed. The synthesized methods will have a return type of the non-final class which in which the forwarding declaration occured. The synthesized methods may still be useful in cases where actual protocol conformance is not necessary.<br>&gt;&gt; All synthesized members recieve access control modifiers matching the access control modifier applied to the forward declaration.<br>&gt;&gt; TODO: How should other annotations on the forwardee implementations of forwarded members (such as @warn_unused_result) be handled? <br>&gt;&gt; It is possible that the member implementations synthesized by forwarding will conflict with existing members or with each other (when forwarding more than one protocol). All such conflicts, with one exception, should produce a compiler error at the site of the forwarding declaration which resulted in conflicting members.<br>&gt;&gt; One specific case that should not be considered a conflict is when forwarding more than one protocol with identical member declarations to the same member of the forwarding type. In this case the synthesized implementation required to forward all of the protocols is identical. The compiler should not synthesize multiple copies of the implementation and then report a redeclaration error.<br>&gt;&gt; It is likely that any attempt to forward different protocols with Self return types to more than one member of the same type will result in sensible behavior. This should probable be a compiler error. For example:<br>&gt;&gt; protocol P {<br>&gt;&gt;     func foo() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; protocol Q {<br>&gt;&gt;     func bar() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Forwarder: P, Q {<br>&gt;&gt;     let d1: Double<br>&gt;&gt;     let d2: Double<br>&gt;&gt;     <br>&gt;&gt;     forward P to d1<br>&gt;&gt;     forward Q to d2<br>&gt;&gt; <br>&gt;&gt;     func transformedForwardingReturnValue(_ forwardeeReturnValue: Double) -&gt; Forwarder { <br>&gt;&gt;         // What do we do here?  <br>&gt;&gt;         // We don&#39;t know if the return value resulted from forwarding foo to d1 or bar to d2.<br>&gt;&gt;         // It is unlikely that the same behavior is correct in both cases.<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a strictly additive change. It has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Future enhancements<br>&gt;&gt; <br>&gt;&gt; In the spirit of incremental change, this proposal focuses on core functionality. Several enhancements to the core functionality are possible and are likely to be explored in the future.<br>&gt;&gt; <br>&gt;&gt; Partial forwarding synthesis<br>&gt;&gt; <br>&gt;&gt; The current proposal makes automatic forwarding an “all or nothing” feature. In cases where you want to forward most of the implementation of a set of members but would need to “override” one or more specific members the current proposal will not help. You will still be required to forward the entire protocol manually. Attempting to implement some specific members manually will result in a redeclaration error.<br>&gt;&gt; <br>&gt;&gt; This proposal does not allow partial forwarding synthesis in order to focus on the basic forwarding mechanism and allow us to gain some experience with that first, before considering the best way to make partial forwarding possible without introducing unintended potential for error. One example of a consideration that may apply is whether or not forwardee types should be able to mark members as “final for forwarding” in some way that prevents them from being “overriden” by a forwarder.<br>&gt;&gt; <br>&gt;&gt; Newtype<br>&gt;&gt; <br>&gt;&gt; While the current proposal provides the basic behavior desired for newtype, it is not as concise as it could be. Adding syntactic sugar to make this common case more concise would be straightforward:<br>&gt;&gt; <br>&gt;&gt; // user declares<br>&gt;&gt; newtype Weight = Double forwarding P, Q<br>&gt;&gt; <br>&gt;&gt; // compiler synthesizes<br>&gt;&gt; struct Weight: P, Q {<br>&gt;&gt;     var value: Double<br>&gt;&gt;     forward P, Q to value<br>&gt;&gt;     init(_ value: Double) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt; However, there are additional nuances related to associated types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004735.html&gt; that should be considered and addressed by a newtype proposal.<br>&gt;&gt; <br>&gt;&gt; Forwarding declaration in protocol extensions<br>&gt;&gt; <br>&gt;&gt; It may be possible to allow the forward declaration in protocol extensions by forwarding to a required property of the protocol. This may have implementation complexities and other implications which would hold back the current proposal if it required the forward declaration to be allowed in protocol extensions. <br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Specify forwarding as part of the member declaration<br>&gt;&gt; <br>&gt;&gt; I originally thought it would make the most sense to specify forwarding alongside the forwardee member declaration. This proposal does not do so for the following reasons:<br>&gt;&gt; <br>&gt;&gt; We must be able to specify access control for the forwarded members that are synthesized. Introducing a forwarding declaration is the most clear way to allow this.<br>&gt;&gt; It will sometimes be necessary to forward different protocols to the same forwardee with different access control levels. It would be very clunky to do this as part of the member declaration.<br>&gt;&gt; It should be possible to synthesize forwarding retroactively as part of an extension. This would not be possible if forwarding had to be specified in the original member declaration.<br>&gt;&gt; Require the forwardee to conform to the protocol(s) forwarded to it<br>&gt;&gt; <br>&gt;&gt; There is not a compelling reason to require this. It is not necessary to synthesize and compile the forwarding methods and it would prevent the use of protocol existentials as the forwardee.<br>&gt;&gt; <br>&gt;&gt; Automatically conform the forwarding type to the forwarded protocol(s)<br>&gt;&gt; <br>&gt;&gt; It may seem reasonable to automatically synthesize conformance to the protocol in addition to the member implementations. This proposal does not do so for the following reasons:<br>&gt;&gt; <br>&gt;&gt; Forwarding is considered an implementation detail that is not necessarily visible in the public interface of the type. The forwardee may be a private member of the type.<br>&gt;&gt; Type authors may wish to control where the actual conformance is declared, especially if protocol conformances are allowed to have access control in the future.<br>&gt;&gt; There may be use cases where it is desirable to have the forwarded members synthesized without actually conforming to the protocol. This is somewhat speculative, but there is not a compelling reason to disallow it.<br>&gt;&gt; Allow forwarding of all protocols conformed to by the forwardee without explicitly listing them<br>&gt;&gt; <br>&gt;&gt; It may seem reasonable to have a * placeholder which will forward all visible protocol conformances of the forwardee type. This proposal does not include such a placeholder for the following reasons:<br>&gt;&gt; <br>&gt;&gt; A placeholder like this could lead to unintended operations being synthesized if additional conformances are declared in the future. The new conformances could even lead to conflicts during synthesis which cause the code to fail to compile. The potential for such breakage is not acceptable.<br>&gt;&gt; A placeholder like this would not necessarily cause all desired forwarding methods to be synthesized. This would be the case when the members necessary to conform exist but actual conformance does not exist. This would be the case when the forwardee type is an existential. This could lead to programmer confusion.<br>&gt;&gt; An explicit list of protocols to forward is not unduely burdensome. It is straightforward to declare a new protocol that inherits from a group of protocols which are commonly forwarded together and use the new protocol in the forwarding declaration.<br>&gt;&gt; This is easily added as a future enhancement to the current proposal if we later decide it is necessary.<br>&gt;&gt; Allow forwarding of the entire interface of the forwardee type, not just specific protocols<br>&gt;&gt; <br>&gt;&gt; It is impossible to synthesize forwarding of methods which contain the forwardee type as a parameter or return type that are not declared as part of a protocol interface in a correct and safe manner. This is because it may or may not be correct to promote the forwardee type in the signature to the forwarder. <br>&gt;&gt; <br>&gt;&gt; As an example, consider the following extension to Double. Imagine trying to synthesize a forwarding method in a Pixel type that forwards to Double. Should the return type be Pixel or Double? It is impossible to tell for sure.<br>&gt;&gt; <br>&gt;&gt; extension Double {<br>&gt;&gt;     func foo() -&gt; Double {<br>&gt;&gt;         return self<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; When the method is declared in a protocol it becomes obvious what the signature of the forwarding method must be. If the protocol declares the return type as Self, the forwarding method must have a return type of Pixel. If the protocol declares the return type as Double the forwarding method will continue to have a return type of Double.<br>&gt;&gt; <br>&gt;&gt; Allow forwarding to Optional members<br>&gt;&gt; <br>&gt;&gt; It may seem like a good idea to allow synthesized forwarding to Optional members where a no-op results when the Optional is nil. There is no way to make this work in general as it would be impossible to forward any member requiring a return value. If use cases for forwarding to Optionalmembers emerege that are restricted to protocols with no members requiring return values the automatic protocol forwarding feature could be enhanced in the future to support these use cases.<br>&gt;&gt; <br>&gt;&gt; Allow forwarding the same protocol(s) to more than one member<br>&gt;&gt; <br>&gt;&gt; As with forwarding to Optional members, forwarding the same protocol to more than one member is not possible in general. However it is possible in cases where no protocol members have a return value. If compelling use cases emerge to motivate automatic forwarding of such protocols to more than one member an enhancement could be proposed in the future.<br>&gt;&gt; <br>&gt;&gt; Provide a mechanism for forwardees to know about the forwarder<br>&gt;&gt; <br>&gt;&gt; Some types may be designed to be used as components that are always forwarded to by other types. Such types may wish to be able to communicate with the forwarding type in some way. This can be accomplished manually. <br>&gt;&gt; <br>&gt;&gt; If general patterns emerge in practice it may be possible to add support for them to the language. However, it would be preliminary to consider support for such a feature until we have significant experience with the basic forwarding mechanism itself.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/addadfd1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 8:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Delegation is a robust, composition oriented design technique that keeps interface and implementation inheritance separate. The primary drawback to this technique is that it requires a lot of manual boilerplate to forward implemenation to the implementing member. This proposal eliminates the need to write such boilerplate manually, thus making delegation-based designs much more convenient and attractive.<br>&gt; <br>&gt; This proposal may also serve as the foundation for a future enhancement allowing a very concise “newtype” declaration.<br>&gt; <br>&gt; <br></p><p><br>Thanks for proposing this, Matthew!<br></p><p>The biggest thing missing here IMO (which has been missing from most of the other proposals I’ve seen) are examples of real-world problems solved by this proposal.  I have no doubt some forwarding mechanism would be a huge benefit, but without clear examples, how do I know that this proposal actually addresses the need?  One approach might be to show how the Lazy Collections subsystem in the standard library can be rewritten more simply using this mechanism.<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/f9ca5506/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 29, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 5:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 8:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Delegation is a robust, composition oriented design technique that keeps interface and implementation inheritance separate. The primary drawback to this technique is that it requires a lot of manual boilerplate to forward implemenation to the implementing member. This proposal eliminates the need to write such boilerplate manually, thus making delegation-based designs much more convenient and attractive.<br>&gt;&gt; <br>&gt;&gt; This proposal may also serve as the foundation for a future enhancement allowing a very concise “newtype” declaration.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; Thanks for proposing this, Matthew!<br>&gt; <br>&gt; The biggest thing missing here IMO (which has been missing from most of the other proposals I’ve seen) are examples of real-world problems solved by this proposal.  I have no doubt some forwarding mechanism would be a huge benefit, but without clear examples, how do I know that this proposal actually addresses the need?  One approach might be to show how the Lazy Collections subsystem in the standard library can be rewritten more simply using this mechanism.<br>&gt; <br>&gt; -Dave<br>&gt; <br></p><p>Thanks for the feedback Dave!  I agree that the motivation section is a bit light and will work on filling it out with more detail, including specific examples of how it could be used to address specific problems.  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/22439bed/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 30, 2015 at 12:00:00pm</p></header><div class="content"><p>Have you looked at how this is handled in Kotlin?<br>Imho Jetbrains solution is quite elegant — especially as it also has a natural answer to another problem (&quot;flexible memberwise initialization&quot;; the whole init process is only a short chapter in the docs).<br>Of course, their approach is different, but I&#39;d rather copy from the best than accept mediocrity because of the not invented here syndrome.<br></p><p>[short explanation: In Kotlin, we would have<br>class Forwarder(forwardee: Forwardee): P by forwardee {<br>…<br>}<br>forwardee would be available as a member, and because it is introduced before the protocol conformance, it can be used there without irritation.<br>Bonus: The designated initializer is defined at the same time.<br>]<br></p><p>As for the implementation:<br>Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/7d437afb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 5:47 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Have you looked at how this is handled in Kotlin?<br></p><p>I hadn’t, but I did look at a paper on a forwarding preprocessor for Java that was called Jaime.  The way forwarding is declared is very similar to Kotlin so it may have been a predecessor: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.3374&amp;rep=rep1&amp;type=pdf &lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.3374&amp;rep=rep1&amp;type=pdf&gt;<br></p><p>The initial approach I considered was similar.  I show an example following your Kotlin example down below.<br></p><p>&gt; Imho Jetbrains solution is quite elegant — especially as it also has a natural answer to another problem (&quot;flexible memberwise initialization&quot;; the whole init process is only a short chapter in the docs).<br></p><p>I don’t want this thread to get distracted with memberwise initialization so please move back to the appropriate thread if you want to discuss further.  However, I will briefly respond here.<br></p><p>Here is Kotlin:<br>class Person constructor(firstName: String, lastName: String) {<br>}<br></p><p>Here is Swift under my proposal:<br>class Person {<br>    var firstName: String<br>    var lastName: String<br>    // compiler synthesizes memberwise init<br>}<br></p><p>However, my proposal gives you a lot of additional flexibility:<br></p><p>1. It interacts well with access control<br>2. Partial memberwise initialization is possible<br>3. It allows memberwise initializers to accept non-memberwise parameters to initialize private state<br>4. More than one memberwise initializer is possible<br>5. Memberwise initialization of properties with declaration modifiers, behaviors / delegates is possible<br></p><p>And probably more.  My approach was to design a solution that fits into the current Swift language and is orthogonal to other language features as much as possible.<br></p><p>If you feel Kotlin’s approach is better please respond to the memberwise initialization thread with some examples written in both Kotlin and in Swift using the memberwise initialization feature I am proposing to demonstrate how and why you think it is better.<br></p><p>&gt; Of course, their approach is different, but I&#39;d rather copy from the best than accept mediocrity because of the not invented here syndrome.<br></p><p>Best is a judgement that depends on the criteria you are using to perform the evaluation.  If it really is better using criteria appropriate for evaluating new features for Swift then of course that would be the way to go.  I would never advocate different for the sake of different or NIH.<br></p><p>&gt; <br>&gt; [short explanation: In Kotlin, we would have<br>&gt; class Forwarder(forwardee: Forwardee): P by forwardee {<br>&gt; …<br>&gt; }<br>&gt; forwardee would be available as a member, and because it is introduced before the protocol conformance, it can be used there without irritation.<br>&gt; Bonus: The designated initializer is defined at the same time.<br>&gt; ]<br></p><p>One approach I considered would look like this:<br></p><p>class Forwarder: P {<br>    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>    var forwardee: Forwardee implements P <br>}<br></p><p>With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br></p><p>Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br></p><p>This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br></p><p>It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br></p><p>&gt; <br>&gt; As for the implementation:<br>&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br></p><p>That is exactly what this proposal does.  Why do you feel it is not doing that?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/94bb17ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 31, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; I don’t want this thread to get distracted with memberwise initialization<br>Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>But I&#39;ll skip everything that is not related to forwarding.<br></p><p>&gt; One approach I considered would look like this:<br>&gt; <br>&gt; class Forwarder: P {<br>&gt;     // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;     var forwardee: Forwardee implements P <br>&gt; }<br>Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br></p><p>&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br></p><p>&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br></p><p>&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br></p><p>&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>No, I value elegance and simplicity  — they often lead to clarity and safety.<br></p><p>&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt; <br>&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br></p><p>I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt; <br>&gt;&gt; One approach I considered would look like this:<br>&gt;&gt; <br>&gt;&gt; class Forwarder: P {<br>&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt; }<br>&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt; <br>&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br></p><p>What I mean is this.  In the example you gave and the syntax Kotlin uses:<br></p><p>class Forwarder(forwardee: Forwardee): P by forwardee {}<br></p><p>Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br></p><p>Here is a quick example using the syntax of my proposal to demonstrate the difference:<br></p><p>class Forwarder {<br>  let forwardee: Forwardee<br>  forward P to forwardee<br>}<br></p><p>vs<br></p><p>class Forwarder: P {<br>  let forwardee: Forwardee<br>  forward P to forwardee<br>}<br></p><p>In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br></p><p>In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br></p><p>&gt; <br>&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br></p><p>Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br></p><p>&gt; <br>&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br></p><p>Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br></p><p>As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br></p><p>Matthew<br></p><p>&gt; <br>&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt; <br>&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt; <br>&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt; <br>&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt; <br>&gt; Tino<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/1a47a56c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 08:00:00am</p></header><div class="content"><p>-Dave<br></p><p>&gt; On Dec 31, 2015, at 7:33 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt;&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt;&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt;&gt; <br>&gt;&gt;&gt; One approach I considered would look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt;&gt; }<br>&gt;&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt;&gt; <br>&gt;&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt;&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br>&gt; <br>&gt; What I mean is this.  In the example you gave and the syntax Kotlin uses:<br>&gt; <br>&gt; class Forwarder(forwardee: Forwardee): P by forwardee {}<br>&gt; <br>&gt; Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br>&gt; <br>&gt; Here is a quick example using the syntax of my proposal to demonstrate the difference:<br>&gt; <br>&gt; class Forwarder {<br>&gt;   let forwardee: Forwardee<br>&gt;   forward P to forwardee<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; class Forwarder: P {<br>&gt;   let forwardee: Forwardee<br>&gt;   forward P to forwardee<br>&gt; }<br>&gt; <br>&gt; In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br>&gt; <br>&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br></p><p>There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt;&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br>&gt; <br>&gt; Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt;&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br>&gt; <br>&gt; Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br>&gt; <br>&gt; As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt;&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt;&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt;&gt; <br>&gt;&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt;&gt; <br>&gt;&gt; Tino<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/f3a4b9e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 7:33 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt;&gt;&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt;&gt;&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One approach I considered would look like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt;&gt;&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br>&gt;&gt; <br>&gt;&gt; What I mean is this.  In the example you gave and the syntax Kotlin uses:<br>&gt;&gt; <br>&gt;&gt; classs Forwarder(forwardee: Forwardee): P by forwardee {}<br>&gt;&gt; <br>&gt;&gt; Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br>&gt;&gt; <br>&gt;&gt; Here is a quick example using the syntax of my proposal to demonstrate the difference:<br>&gt;&gt; <br>&gt;&gt; class Forwarder {<br>&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;   forward P to forwardee<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; class Forwarder: P {<br>&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;   forward P to forwardee<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br>&gt;&gt; <br>&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt; <br>&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br></p><p>I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br></p><p>What do you have in mind when you mention using a private or internal protocol to provide public API?  It sounds like that might be interesting but I&#39;m having trouble imagining what the syntax would look like and exactly how it would work.  Is this something that is planned?  What might it look like?<br></p><p>In any case, I don&#39;t see why that is related to requiring a Forwarder to conform to the forwarded protocol.  There doesn&#39;t appear to me to be a good reason to require that and there are reasons not to require it.  Protocols enable and drive the forwarding member synthesis mechanism but that mechanism doesn&#39;t need to require or provide conformance.  It is a third major way to use protocols in addition to generic constraints and existential types.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt;&gt;&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br>&gt;&gt; <br>&gt;&gt; Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt;&gt;&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br>&gt;&gt; <br>&gt;&gt; Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br>&gt;&gt; <br>&gt;&gt; As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt;&gt;&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt;&gt;&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tino<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/db21cb79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:01 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 7:33 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt;&gt;&gt;&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt;&gt;&gt;&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One approach I considered would look like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;&gt;&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt;&gt;&gt;&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean is this.  In the example you gave and the syntax Kotlin uses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; classs Forwarder(forwardee: Forwardee): P by forwardee {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a quick example using the syntax of my proposal to demonstrate the difference:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Forwarder {<br>&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt;&gt; <br>&gt;&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br>&gt; <br>&gt; I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br></p><p>Presumably both ends of the forwarding arrangement would have to conform to the same protocol, no?<br></p><p>&gt; What do you have in mind when you mention using a private or internal protocol to provide public API?  It sounds like that might be interesting but I&#39;m having trouble imagining what the syntax would look like and exactly how it would work.  Is this something that is planned?  <br></p><p>Not planned, but desired.<br></p><p>&gt; What might it look like?<br></p><p>Details need to be worked out.  One thing we were doing for a while in the stdlib, before the rules got tightened and made it impossible, was<br></p><p>struct X : PublicProtocol, PrivateProtocol {<br>   ...<br>}<br></p><p>extension PublicProtocol where Self : PrivateProtocol {<br>   // API that uses only PublicProtocol in its implementation here<br>}<br></p><p>&gt; In any case, I don&#39;t see why that is related to requiring a Forwarder to conform to the forwarded protocol.  There doesn&#39;t appear to me to be a good reason to require that and there are reasons not to require it.  Protocols enable and drive the forwarding member synthesis mechanism but that mechanism doesn&#39;t need to require or provide conformance.  It is a third major way to use protocols in addition to generic constraints and existential types.<br></p><p>Of course I could be wrong, but my instincts tell me that is an unneeded dimension of complexity, which is why I am resisting it.  The generic/existential duality is already problematic in some ways, IMO.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt;&gt;&gt;&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt;&gt;&gt;&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt;&gt;&gt;&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt;&gt;&gt;&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tino<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/31d66efe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 11:18 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:01 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 7:33 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt;&gt;&gt;&gt;&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt;&gt;&gt;&gt;&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One approach I considered would look like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;&gt;&gt;&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt;&gt;&gt;&gt;&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I mean is this.  In the example you gave and the syntax Kotlin uses:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; classs Forwarder(forwardee: Forwardee): P by forwardee {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a quick example using the syntax of my proposal to demonstrate the difference:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Forwarder {<br>&gt;&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br>&gt; <br>&gt; Presumably both ends of the forwarding arrangement would have to conform to the same protocol, no?<br></p><p>No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br></p><p>The forwardee needs to implement the members of the protocol but does not need to conform.  The forwarder will receive forwarding implementations of the members, but again does not need to declare conformance.  Forwarding is orthogonal to conformance, just as it is today when you manually write forwarding members today.<br></p><p>&gt; <br>&gt;&gt; What do you have in mind when you mention using a private or internal protocol to provide public API?  It sounds like that might be interesting but I&#39;m having trouble imagining what the syntax would look like and exactly how it would work.  Is this something that is planned?  <br>&gt; <br>&gt; Not planned, but desired.<br>&gt; <br>&gt;&gt; What might it look like?<br>&gt; <br>&gt; Details need to be worked out.  One thing we were doing for a while in the stdlib, before the rules got tightened and made it impossible, was<br>&gt; <br>&gt; struct X : PublicProtocol, PrivateProtocol {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; extension PublicProtocol where Self : PrivateProtocol {<br>&gt;    // API that uses only PublicProtocol in its implementation here<br>&gt; }<br></p><p>Presumably you implement public API here where members of PrivateProtocol can be accessed?  This would address the problem of leaking implementation details when adding default forwarding implementations so it is definitely better than current state.<br></p><p>&gt; <br>&gt;&gt; In any case, I don&#39;t see why that is related to requiring a Forwarder to conform to the forwarded protocol.  There doesn&#39;t appear to me to be a good reason to require that and there are reasons not to require it.  Protocols enable and drive the forwarding member synthesis mechanism but that mechanism doesn&#39;t need to require or provide conformance.  It is a third major way to use protocols in addition to generic constraints and existential types.<br>&gt; <br>&gt; Of course I could be wrong, but my instincts tell me that is an unneeded dimension of complexity, which is why I am resisting it.  The generic/existential duality is already problematic in some ways, IMO.<br></p><p>I don’t really understand what is complex about it.  Can you elaborate on why you think it introduces complexity?  The idea seems pretty simple to me - if you can write a forwarding implementation that compiles and works the compiler should be able to synthesize it for you.  I don’t see any reason to disallow that.  <br></p><p>Is your concern that we may not be able to support forwarding of every protocol someone might come up with and there would be confusion around what protocols are eligible for forwarding and which aren’t (similar to the current confusion around which protocols can be used as existentials and which can’t)?<br></p><p>Isn’t the primary problem with generic / existential the fact that existentials are pretty limited currently?  This is an unfortunate limitation and my understanding is that there is a desire to lift at least some parts of this limitation eventually, whether that starts to happen in Swift 3 or is a feature that comes later. https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002850.html<br></p><p>One specific problem with requiring conformance is that forwarding to existentials would not be straightforward because they do not conform to their protocol.  Obviously this is a limitation that should be lifted eventually but it isn’t clear when that might happen.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt;&gt;&gt;&gt;&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt;&gt;&gt;&gt;&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt;&gt;&gt;&gt;&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt;&gt;&gt;&gt;&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tino<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/d9d704cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 11:18 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 9:01 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 7:33 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt;&gt;&gt;&gt;&gt;&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt;&gt;&gt;&gt;&gt;&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One approach I considered would look like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt;&gt;&gt;&gt;&gt;&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I mean is this.  In the example you gave and the syntax Kotlin uses:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; classs Forwarder(forwardee: Forwardee): P by forwardee {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is a quick example using the syntax of my proposal to demonstrate the difference:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Forwarder {<br>&gt;&gt;&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br>&gt;&gt; <br>&gt;&gt; Presumably both ends of the forwarding arrangement would have to conform to the same protocol, no?<br>&gt; <br>&gt; No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br>&gt; <br>&gt; The forwardee needs to implement the members of the protocol but does not need to conform.  The forwarder will receive forwarding implementations of the members, but again does not need to declare conformance.  Forwarding is orthogonal to conformance, just as it is today when you manually write forwarding members today.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; What do you have in mind when you mention using a private or internal protocol to provide public API?  It sounds like that might be interesting but I&#39;m having trouble imagining what the syntax would look like and exactly how it would work.  Is this something that is planned?  <br>&gt;&gt; <br>&gt;&gt; Not planned, but desired.<br>&gt;&gt; <br>&gt;&gt;&gt; What might it look like?<br>&gt;&gt; <br>&gt;&gt; Details need to be worked out.  One thing we were doing for a while in the stdlib, before the rules got tightened and made it impossible, was<br>&gt;&gt; <br>&gt;&gt; struct X : PublicProtocol, PrivateProtocol {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension PublicProtocol where Self : PrivateProtocol {<br>&gt;&gt;    // API that uses only PublicProtocol in its implementation here<br>&gt;&gt; }<br>&gt; <br>&gt; Presumably you implement public API here where members of PrivateProtocol can be accessed?  This would address the problem of leaking implementation details when adding default forwarding implementations so it is definitely better than current state.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; In any case, I don&#39;t see why that is related to requiring a Forwarder to conform to the forwarded protocol.  There doesn&#39;t appear to me to be a good reason to require that and there are reasons not to require it.  Protocols enable and drive the forwarding member synthesis mechanism but that mechanism doesn&#39;t need to require or provide conformance.  It is a third major way to use protocols in addition to generic constraints and existential types.<br>&gt;&gt; <br>&gt;&gt; Of course I could be wrong, but my instincts tell me that is an unneeded dimension of complexity, which is why I am resisting it.  The generic/existential duality is already problematic in some ways, IMO.<br>&gt; <br>&gt; I don’t really understand what is complex about it.  Can you elaborate on why you think it introduces complexity?  The idea seems pretty simple to me - if you can write a forwarding implementation that compiles and works the compiler should be able to synthesize it for you.  I don’t see any reason to disallow that.  <br>&gt; <br>&gt; Is your concern that we may not be able to support forwarding of every protocol someone might come up with and there would be confusion around what protocols are eligible for forwarding and which aren’t (similar to the current confusion around which protocols can be used as existentials and which can’t)?<br></p><p>No, it just feels like an ad-hoc use of protocols to use their APIs as constraints without creating a conformance.<br></p><p>&gt; Isn’t the primary problem with generic / existential the fact that existentials are pretty limited currently?  This is an unfortunate limitation and my understanding is that there is a desire to lift at least some parts of this limitation eventually, whether that starts to happen in Swift 3 or is a feature that comes later. https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002850.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002850.html&gt;<br>Yes, there are plans to address this (and I’m looking forward to that!), but I think the difference is still going to be there and when to use one or the other is still going to remain a point of confusion.<br></p><p>&gt; One specific problem with requiring conformance is that forwarding to existentials would not be straightforward because they do not conform to their protocol.  Obviously this is a limitation that should be lifted eventually but it isn’t clear when that might happen.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt;&gt;&gt;&gt;&gt;&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt;&gt;&gt;&gt;&gt;&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt;&gt;&gt;&gt;&gt;&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tino<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -Dave<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/83454b22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 31, 2015, at 11:52 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 9:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 11:18 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 9:01 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 7:33 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 5:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t want this thread to get distracted with memberwise initialization<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Makes sense in general, but Kotlin solves those problems as a whole, and the major benefit of their approach is that everything fits together really fine.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I&#39;ll skip everything that is not related to forwarding.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One approach I considered would look like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // I didn’t like `implements` but didn’t have a better idea before I abandoned this approach<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var forwardee: Forwardee implements P <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Honestly, I&#39;m can&#39;t see the value this discarded variant has for this discussion… you have to pit your proposal against Kotlin if you really want to convince anyone of its superiority.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the memberwise initialization proposal you also have the initializer synthesized automatically.  The only thing it doesn’t do that your Kotlin example does is automatically declare conformance.  This was an intentional design decision because it allows for additional expressivity.  This is addressed in the alternatives considered section of the proposal.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you be more precise? Kotlin clearly states what a class is doing in its first line, with all expressivity that is necessary by practical means.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What I mean is this.  In the example you gave and the syntax Kotlin uses:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; classs Forwarder(forwardee: Forwardee): P by forwardee {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Forwarding is coupled to protocol conformance.  This means I cannot use forwarding without conforming to the protocol that is forwarded.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here is a quick example using the syntax of my proposal to demonstrate the difference:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Forwarder {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Forwarder: P {<br>&gt;&gt;&gt;&gt;&gt;&gt;   let forwardee: Forwardee<br>&gt;&gt;&gt;&gt;&gt;&gt;   forward P to forwardee<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the first example Forwarder does not conform to P.  Forwarding is only used to synthesize the members of P.  I am greatly expanding the motivation section of the proposal and will have examples showing where this is what you want.  The lazy collections section I posted last night includes the first examples where this is the case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Presumably both ends of the forwarding arrangement would have to conform to the same protocol, no?<br>&gt;&gt; <br>&gt;&gt; No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br>&gt;&gt; <br>&gt;&gt; The forwardee needs to implement the members of the protocol but does not need to conform.  The forwarder will receive forwarding implementations of the members, but again does not need to declare conformance.  Forwarding is orthogonal to conformance, just as it is today when you manually write forwarding members today.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you have in mind when you mention using a private or internal protocol to provide public API?  It sounds like that might be interesting but I&#39;m having trouble imagining what the syntax would look like and exactly how it would work.  Is this something that is planned?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not planned, but desired.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What might it look like?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Details need to be worked out.  One thing we were doing for a while in the stdlib, before the rules got tightened and made it impossible, was<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X : PublicProtocol, PrivateProtocol {<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension PublicProtocol where Self : PrivateProtocol {<br>&gt;&gt;&gt;    // API that uses only PublicProtocol in its implementation here<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Presumably you implement public API here where members of PrivateProtocol can be accessed?  This would address the problem of leaking implementation details when adding default forwarding implementations so it is definitely better than current state.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case, I don&#39;t see why that is related to requiring a Forwarder to conform to the forwarded protocol.  There doesn&#39;t appear to me to be a good reason to require that and there are reasons not to require it.  Protocols enable and drive the forwarding member synthesis mechanism but that mechanism doesn&#39;t need to require or provide conformance.  It is a third major way to use protocols in addition to generic constraints and existential types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course I could be wrong, but my instincts tell me that is an unneeded dimension of complexity, which is why I am resisting it.  The generic/existential duality is already problematic in some ways, IMO.<br>&gt;&gt; <br>&gt;&gt; I don’t really understand what is complex about it.  Can you elaborate on why you think it introduces complexity?  The idea seems pretty simple to me - if you can write a forwarding implementation that compiles and works the compiler should be able to synthesize it for you.  I don’t see any reason to disallow that.  <br>&gt;&gt; <br>&gt;&gt; Is your concern that we may not be able to support forwarding of every protocol someone might come up with and there would be confusion around what protocols are eligible for forwarding and which aren’t (similar to the current confusion around which protocols can be used as existentials and which can’t)?<br>&gt; <br>&gt; No, it just feels like an ad-hoc use of protocols to use their APIs as constraints without creating a conformance.<br></p><p>I can understand this perspective, but I think there is a fundamental difference between protocols as generic constraints or existential where conformance is required by the language model and using protocols to drive forwarding.  The forwarding mechanism is really just syntactic sugar for forwarding members that can be written manually without any need for conformance.  If the manually written code doesn&#39;t require conformance I don&#39;t think the syntactic sugar should.<br></p><p>Requiring conformance would artificially restrict the power of the feature in the language as it exists today.  A possible future language where that is not the case is speculative and does not help us in the meantime.<br></p><p>I will continue to work on motivating examples, several of which will take advantage of this relaxed requirement.<br></p><p>&gt; <br>&gt;&gt; Isn’t the primary problem with generic / existential the fact that existentials are pretty limited currently?  This is an unfortunate limitation and my understanding is that there is a desire to lift at least some parts of this limitation eventually, whether that starts to happen in Swift 3 or is a feature that comes later. https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002850.html<br>&gt; <br>&gt; Yes, there are plans to address this (and I’m looking forward to that!), but I think the difference is still going to be there and when to use one or the other is still going to remain a point of confusion.<br>&gt; <br>&gt;&gt; One specific problem with requiring conformance is that forwarding to existentials would not be straightforward because they do not conform to their protocol.  Obviously this is a limitation that should be lifted eventually but it isn’t clear when that might happen.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another difference that is maybe subtle but I think important is that with the approach I considered forwarding is declared in the body of a type or extension which emphasizes the fact that forwarding is an implementation detail, not something users of the type should be concerned with.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But what is the benefit of this emphasis? No solution requires to make the details visible in the public interface, and the ability to bury an important thing like protocol conformance somewhere in the class implementation is no advantage for me.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Protocol conformance is not buried in the implementation in my solution.  I hope the previous example makes that clear.  What is buried in the implementation is the forwarding declaration which causes the compiler to synthesize forwarding member implementations.  This synthesis is an implementation detail and should not be visible outside the implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This approach was abandoned as it leads to problems in expressivity and clarity.  Please see alternatives considered for an elaboration of that.  This is especially true with the new approach to handling Self values that Brent suggested.  That approach requires additional syntax around the forwarding declaration, but adds both clarity and expressiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there is little need to worry about expressiveness for a feature that most potential users will probably never utilize in real code — and I don&#39;t think options like not conforming to a protocol that is forwarded is a big win here. It looks to me like you are optimizing for very uncommon cases, and sacrificing ease of use in the situations that are the most common by far.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Like I stated, I am working on adding several examples of how this feature can be used in real code.  Please have a look at the lazy collections example I shared last night.  This example, as well as at least one other coming examples take advantage of the ability to use forwarding without requiring conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As with the memberwise initialization proposal, the syntax you would like to see can easily be added as syntactic sugar on top of the current proposal.  I would not support that as I do not like the syntax Kotlin uses for reasons already stated, but that shouldn’t stop you from pursuing a proposal for it.  Maybe a lot of people would agree with you and it would be accepted.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It appears to me that you value conciseness very highly.  I do value conciseness but I also value safety, clarity, and expressiveness.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, I value elegance and simplicity  — they often lead to clarity and safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why not simply make this feature syntactic sugar and just auto-generate the forwarding methods?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is exactly what this proposal does.  Why do you feel it is not doing that?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;re right, guess I mixed up the proposal with something else; so at least we agree on how it should work ;-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not saying Swift has to copy another language, but I doubt that anyone who knows Kotlin would actually consider to drop their solution in favor of what is currently discussed...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tino<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt; <br>&gt; -Dave<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/b7f1f973/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 11:42 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I will continue to work on motivating examples, several of which will take advantage of this relaxed requirement.<br></p><p>Looking forward to it!<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/c0027cd3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br>&gt;&gt; <br>&gt;&gt; Presumably both ends of the forwarding arrangement would have to conform to the same protocol, no?<br>&gt; <br>&gt; No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br></p><p><br>My only point was that if we’re going to require the forwarder to conform, we may as well require it of the forwardee.  I realize that you don’t want to require either conformance.<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/d167184c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 31, 2015, at 11:53 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the second example here Forwarder does conform to P.  The author of Forwarder has the flexibility to specify whether conformance is desired or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are ways to handle that, including factoring the APIs of interest out of P and into a private protocol Q, then declaring the Forwardee’s conformance to Q.  Now, there’s an expressivity problem with our current access control system that you can’t use an internal or private protocol to provide public API, but that should be fixed separately.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure where Q comes into play in this specific example.  The idea here is that forwarding implementations of all members of P are synthesized by the forward declaration.  It is left up to Forwarder to decide whether or not to declare actual conformance to P.  I am also confused by &quot;then declaring the Forwardee’s conformance to Q&quot; because we are discussing Forwarder&#39;s conformance here, not Forwardee’s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Presumably both ends of the forwarding arrangement would have to conform to the same protocol, no?<br>&gt;&gt; <br>&gt;&gt; No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br>&gt; <br>&gt; <br>&gt; My only point was that if we’re going to require the forwarder to conform, we may as well require it of the forwardee.  I realize that you don’t want to require either conformance.<br></p><p>There are independent reasons not to require it of the forwarded and the forwarder, so I disagree with &quot;may as well&quot;.<br></p><p>It may be possible that eventually enough of the language limitations would be lifted that requiring conformance of both wouldn&#39;t restrict the power of a forwarding feature and as such that requirement wouldn&#39;t have any downsides other than the need to declare an additional conformance here or there.  <br></p><p>I would prefer to no artificially restrict the power of the feature without compelling reasons to do so.  <br></p><p>&gt; <br>&gt; -Dave<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/25a447fc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:47 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br></p><p>Can you put your proposal on GitHub under your swift-evolution fork? It’s really hard to follow the current state of the proposal and the changes over time.<br></p><p><br>&gt; The forwardee needs to implement the members of the protocol but does not need to conform.  The forwarder will receive forwarding implementations of the members, but again does not need to declare conformance.  Forwarding is orthogonal to conformance, just as it is today when you manually write forwarding members today.<br></p><p>I cannot think of a time where I wanted this pseudo-conformance. The entire purpose of forwarding, that I’ve ever wanted or seen at least, is to act as a pass-through from the outer type’s conformance to a protocol to an internal specific implementor of that protocol without having to write all of the boiler-plate code to make that happen.<br></p><p>So I find it confusing that you say they are orthogonal.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/eaddc02a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 31, 2015, at 12:02 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:47 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; No.  This is addressed in the proposal and the lazy collections motivating example I replied with last night.  I don’t think it’s a good idea to require this.<br>&gt; <br>&gt; Can you put your proposal on GitHub under your swift-evolution fork? It’s really hard to follow the current state of the proposal and the changes over time.<br></p><p>It is up on my fork in the automatic-protocol-forwarding branch.  I haven&#39;t published the second draft yet.  I want to finish the second draft before updating Github.<br></p><p>I shared the section on lazy collections on the list last night because Dave specifically pointed me in that direction and I am interested in his feedback on it.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; The forwardee needs to implement the members of the protocol but does not need to conform.  The forwarder will receive forwarding implementations of the members, but again does not need to declare conformance.  Forwarding is orthogonal to conformance, just as it is today when you manually write forwarding members today.<br>&gt; <br>&gt; I cannot think of a time where I wanted this pseudo-conformance. The entire purpose of forwarding, that I’ve ever wanted or seen at least, is to act as a pass-through from the outer type’s conformance to a protocol to an internal specific implementor of that protocol without having to write all of the boiler-plate code to make that happen.<br>&gt; <br>&gt; So I find it confusing that you say they are orthogonal.<br></p><p>If you have a look at the lazy collections example maybe it will start to make more sense.  I will also have other examples.  If you don&#39;t want to find the post from last night, just wait until I finish the second draft.  I will announce the second draft on list when it&#39;s ready.<br></p><p>&gt; <br>&gt; -David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/0e678274/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>Thanks for writing this up.<br></p><p>Some quick points.<br></p><p>Firstly, I think it is best if the `init(_ forwardeeReturnValue: Forwardee)`-style initializer be replaced by something with a distinctly-named argument, e.g. `init(forwardeeReturnValue value: Forwardee)`. <br></p><p>For use with actual wrapper types the “init(_ wrappedValue: Wrapped)`-style init is too valuable to “claim” for this purpose (in particular b/c we may want to “adjust&quot; the forwarded result); it’s IMHO better if we use a distinct `init` for the forwardee-return-value scenario so we know where the value is coming from.<br></p><p>Secondly, I would prefer partial-forwarding be given more consideration, b/c it seems somewhat common for me in practice at this time.<br></p><p>EG: I would do the following somewhat frequently:<br></p><p>struct FooIdentifier: Equatable, Comparable, Hashable<br></p><p>class Foo {<br>  let identifier: FooIdentifier<br>  let name: String<br></p><p>  forward Hashable to identifier<br>}<br></p><p>func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>  return lhs.identifier == rhs.identifier &amp;&amp; lhs.name == rhs.name<br>}<br></p><p>…even though I agree that full-forwarding would the most-common scenario.<br></p><p>I have a few other similar cases involving non-standard-library types but they all fit the same basic pattern as above for `Hashable`.<br></p><p>Finally, I’m actually at a bit of a loss for too many uses for the generic forwarding mechanism; if it was added I’d use it to streamline some wrapper types, but beyond that I’m not seeing all that many places where I’d do much more than that with this feature if added.<br></p><p>Any chance at adding a few more-concrete motivating examples for the fancier cases?<br></p><p>&gt; On Dec 29, 2015, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:06 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for writing this up.<br></p><p>Thanks for responding with comments.<br></p><p>&gt; <br>&gt; Some quick points.<br>&gt; <br>&gt; Firstly, I think it is best if the `init(_ forwardeeReturnValue: Forwardee)`-style initializer be replaced by something with a distinctly-named argument, e.g. `init(forwardeeReturnValue value: Forwardee)`. <br>&gt; <br>&gt; For use with actual wrapper types the “init(_ wrappedValue: Wrapped)`-style init is too valuable to “claim” for this purpose (in particular b/c we may want to “adjust&quot; the forwarded result); it’s IMHO better if we use a distinct `init` for the forwardee-return-value scenario so we know where the value is coming from.<br></p><p>Did you look at the approach Brent suggested yesterday?  I’m going to update the proposal using something similar to that.  We won’t be claiming any init at all.  It will be slightly less concise in the common case but will add clarity, expressiveness, and resolve problems related to forwarding to more than one member of the same type.<br></p><p>&gt; <br>&gt; Secondly, I would prefer partial-forwarding be given more consideration, b/c it seems somewhat common for me in practice at this time.<br></p><p>If somebody from the core team was enthusiastic about including partial forwarding in the initial proposal rather than as an enhancement that would certainly motivate me to reconsider.<br></p><p>As I stated earlier and in the proposal, one reason I left it out is that partial forwarding introduces similar concerns that arise with subclassing.  Should a protocol or a type designed to be a forwardee be able to include annotations indicating that some members cannot be “overriden” by a forwarder?  I haven’t had time to fully consider whether that is a good idea or not and if it is, what it would look like, how it should work, etc.  I am reluctant to introduce partial forwarding without really thinking this through.<br></p><p>&gt; <br>&gt; EG: I would do the following somewhat frequently:<br>&gt; <br>&gt; struct FooIdentifier: Equatable, Comparable, Hashable<br>&gt; <br>&gt; class Foo {<br>&gt;  let identifier: FooIdentifier<br>&gt;  let name: String<br>&gt; <br>&gt;  forward Hashable to identifier<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;  return lhs.identifier == rhs.identifier &amp;&amp; lhs.name == rhs.name<br>&gt; }<br>&gt; <br></p><p>Thanks for providing an example!  It looks like you would have two different instances representing the same entity, possibly one serving as an edit buffer.  Is that why they might have the same identifier but different names?  <br></p><p>&gt; …even though I agree that full-forwarding would the most-common scenario.<br>&gt; <br>&gt; I have a few other similar cases involving non-standard-library types but they all fit the same basic pattern as above for `Hashable`.<br>&gt; <br>&gt; Finally, I’m actually at a bit of a loss for too many uses for the generic forwarding mechanism; if it was added I’d use it to streamline some wrapper types, but beyond that I’m not seeing all that many places where I’d do much more than that with this feature if added.<br>&gt; <br>&gt; Any chance at adding a few more-concrete motivating examples for the fancier cases?<br></p><p>Yes, this is needed and I am working on it now.<br></p><p>&gt; <br>&gt;&gt; On Dec 29, 2015, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:27 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 10:06 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for writing this up.<br>&gt; <br>&gt; Thanks for responding with comments.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Some quick points.<br>&gt;&gt; <br>&gt;&gt; Firstly, I think it is best if the `init(_ forwardeeReturnValue: Forwardee)`-style initializer be replaced by something with a distinctly-named argument, e.g. `init(forwardeeReturnValue value: Forwardee)`. <br>&gt;&gt; <br>&gt;&gt; For use with actual wrapper types the “init(_ wrappedValue: Wrapped)`-style init is too valuable to “claim” for this purpose (in particular b/c we may want to “adjust&quot; the forwarded result); it’s IMHO better if we use a distinct `init` for the forwardee-return-value scenario so we know where the value is coming from.<br>&gt; <br>&gt; Did you look at the approach Brent suggested yesterday?  I’m going to update the proposal using something similar to that.  We won’t be claiming any init at all.  It will be slightly less concise in the common case but will add clarity, expressiveness, and resolve problems related to forwarding to more than one member of the same type.<br></p><p>I did not but will make sure to read it.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Secondly, I would prefer partial-forwarding be given more consideration, b/c it seems somewhat common for me in practice at this time.<br>&gt; <br>&gt; If somebody from the core team was enthusiastic about including partial forwarding in the initial proposal rather than as an enhancement that would certainly motivate me to reconsider.<br>&gt; <br>&gt; As I stated earlier and in the proposal, one reason I left it out is that partial forwarding introduces similar concerns that arise with subclassing.  Should a protocol or a type designed to be a forwardee be able to include annotations indicating that some members cannot be “overriden” by a forwarder?  I haven’t had time to fully consider whether that is a good idea or not and if it is, what it would look like, how it should work, etc.  I am reluctant to introduce partial forwarding without really thinking this through.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; EG: I would do the following somewhat frequently:<br>&gt;&gt; <br>&gt;&gt; struct FooIdentifier: Equatable, Comparable, Hashable<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt; let identifier: FooIdentifier<br>&gt;&gt; let name: String<br>&gt;&gt; <br>&gt;&gt; forward Hashable to identifier<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt; return lhs.identifier == rhs.identifier &amp;&amp; lhs.name == rhs.name<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Thanks for providing an example!  It looks like you would have two different instances representing the same entity, possibly one serving as an edit buffer.  Is that why they might have the same identifier but different names?  <br></p><p>This is suffering from the “short examples will necessarily feel contrived, long examples are too long to be polite” problem. Sometimes it’s just from laziness — a good composite `hashValue` can be hard to write, so why not stick with a known-good `hashValue` implementation? — and often makes sense in context (if you know that same-ID, logically-different objects will be rare enough to have negligible overall impact).<br></p><p>I totally agree though I’m getting essentially nothing from forwarding here.<br></p><p>Similar scenarios can show up somewhat *artificially* in the context of generic code. Here’s a somewhat-contrived example:<br></p><p>Suppose you want to write a generic function that can look an “old” array and a “new” array and infer an “edit sequence” that can be applied to transform the “old” one into the “new” one, with an added complication: some values in the “new” one are *revisions* of values from the old one (and thus !=, but still “representing the same thing”). <br></p><p>This could be implemented a lot of different ways; one of them might look like this: <br></p><p>	protocol RecordIdentifierType : Equatable, Comparable, Hashable {} // etc<br>	protocol IdentifiableRecordType : Equatable, Hashable {<br>	  typealias Identifier: RecordIdentifierType<br>	  typealias Data: Equatable // weakest guarantee we need for what we plan to use this for<br>	  // deliberately-clunky names to avoid accidental collisions:	<br>	  var recordIdentifier: Identifier { get }<br>	  var recordData: Data { get }<br>	}<br></p><p>	func inferredEditOperations&lt;R:IdentifiableRecordType&gt;(<br>	  forPreviousRecords previousRecords: [R],<br>	  currentRecords: [R]) -&gt; ArrayEditOperation {<br>	  // exercise for reader<br>        }<br></p><p>…wherein 99% of the time a typical concrete conformance would just return `self` as `recordData` and some appropriate property as `recordIdentifier`, but it’d still be handy to have an “adaptor&quot; type laying around like this:<br></p><p>	struct IdentifiableRecordAdaptor&lt;I:RecordIdentifierType,D:Equatable&gt; : IdentifiableRecordType {<br>	  typealias Identifier = I<br>	  typealias Data = D<br>	  let recordIdentifier: I<br>	  let recordData: D<br></p><p>	  forwarding Hashable to RecordIdentifier<br>	}<br></p><p>…to support broader use of the generic algorithm in certain cases.<br></p><p>Note that this is still quite contrived — and it&#39;s still just `Equatable`/`Hashable` — but I think you can see how the scenario here could generalize in other contexts.<br></p><p>But at the same time, perhaps partial-forwarding is actually more of a niche use here than I thought?<br></p><p>&gt; <br>&gt;&gt; …even though I agree that full-forwarding would the most-common scenario.<br>&gt;&gt; <br>&gt;&gt; I have a few other similar cases involving non-standard-library types but they all fit the same basic pattern as above for `Hashable`.<br>&gt;&gt; <br>&gt;&gt; Finally, I’m actually at a bit of a loss for too many uses for the generic forwarding mechanism; if it was added I’d use it to streamline some wrapper types, but beyond that I’m not seeing all that many places where I’d do much more than that with this feature if added.<br>&gt;&gt; <br>&gt;&gt; Any chance at adding a few more-concrete motivating examples for the fancier cases?<br>&gt; <br>&gt; Yes, this is needed and I am working on it now.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 29, 2015, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:06 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for writing this up.<br>&gt; <br>&gt; Some quick points.<br>&gt; <br>&gt; Firstly, I think it is best if the `init(_ forwardeeReturnValue: Forwardee)`-style initializer be replaced by something with a distinctly-named argument, e.g. `init(forwardeeReturnValue value: Forwardee)`. <br>&gt; <br>&gt; For use with actual wrapper types the “init(_ wrappedValue: Wrapped)`-style init is too valuable to “claim” for this purpose (in particular b/c we may want to “adjust&quot; the forwarded result); it’s IMHO better if we use a distinct `init` for the forwardee-return-value scenario so we know where the value is coming from.<br>&gt; <br>&gt; Secondly, I would prefer partial-forwarding be given more consideration, b/c it seems somewhat common for me in practice at this time.<br>&gt; <br>&gt; EG: I would do the following somewhat frequently:<br>&gt; <br>&gt; struct FooIdentifier: Equatable, Comparable, Hashable<br>&gt; <br>&gt; class Foo {<br>&gt;  let identifier: FooIdentifier<br>&gt;  let name: String<br>&gt; <br>&gt;  forward Hashable to identifier<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;  return lhs.identifier == rhs.identifier &amp;&amp; lhs.name == rhs.name<br>&gt; }<br></p><p>I should have also mentioned a couple of other things here.  First, you’re not getting much because this only forwards the hashValue property.  But you could argue it is more clear and it does prevent you from making a silly mistake even though the forwarding implementation is really simple.<br></p><p>Second, even without partial forwarding it is possible to do this under the current proposal.  You just need to declare a new protocol that only contains the member you wish to forward:<br></p><p>protocol HashValuable {<br>    public var hashValue: Int { get }<br>}<br></p><p>class Foo: Hashable {<br> let identifier: FooIdentifier<br> let name: String<br></p><p> forward HashValuable to identifier<br>}<br></p><p>func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br> return lhs.identifier == rhs.identifier &amp;&amp; lhs.name == rhs.name<br>}<br></p><p>I<br></p><p>&gt; <br>&gt; …even though I agree that full-forwarding would the most-common scenario.<br>&gt; <br>&gt; I have a few other similar cases involving non-standard-library types but they all fit the same basic pattern as above for `Hashable`.<br>&gt; <br>&gt; Finally, I’m actually at a bit of a loss for too many uses for the generic forwarding mechanism; if it was added I’d use it to streamline some wrapper types, but beyond that I’m not seeing all that many places where I’d do much more than that with this feature if added.<br>&gt; <br>&gt; Any chance at adding a few more-concrete motivating examples for the fancier cases?<br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a first draft of a proposal to introduce automatic protocol forwarding.  I’m looking forward to feedback from everyone!<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>December 30, 2015 at 12:00:00pm</p></header><div class="content"><p>Just finished reading your write-up. It sounds similar to the Forwardable module supported by the Ruby standard library (http://ruby-doc.org/stdlib-2.0.0/libdoc/forwardable/rdoc/Forwardable.html). Is this the case?<br></p><p>Cheers,<br>-Patrick Gili<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 11:33 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Just finished reading your write-up. It sounds similar to the Forwardable module supported by the Ruby standard library (http://ruby-doc.org/stdlib-2.0.0/libdoc/forwardable/rdoc/Forwardable.html). Is this the case?<br></p><p>It works somewhat differently, but it provides similar functionality.  As far as I can tell the only thing Forwardable does that this proposal does not do is support member renaming.  That is something that might make an interesting future enhancement to this proposal.<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; -Patrick Gili<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal Draft] automatic protocol forwarding</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>December 30, 2015 at 07:00:00pm</p></header><div class="content"><p>+1 <br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 30, 2015, at 6:56 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 11:33 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just finished reading your write-up. It sounds similar to the Forwardable module supported by the Ruby standard library (http://ruby-doc.org/stdlib-2.0.0/libdoc/forwardable/rdoc/Forwardable.html). Is this the case?<br>&gt; <br>&gt; It works somewhat differently, but it provides similar functionality.  As far as I can tell the only thing Forwardable does that this proposal does not do is support member renaming.  That is something that might make an interesting future enhancement to this proposal.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick Gili<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
