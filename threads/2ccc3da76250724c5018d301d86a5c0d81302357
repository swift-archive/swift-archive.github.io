<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Implementation of Type Erasers</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>September  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello swift-dev,<br></p><p>I was wondering why type erasers (e.g. for AnyIterator) are implemented the<br>way they are. I would implement AnyIterator like this:<br></p><p>final class MyAnyIterator&lt;A&gt;: IteratorProtocol {<br>    var nextImpl: () -&gt; A?<br></p><p>    init&lt;I: IteratorProtocol&gt;(iterator: I) where I.Element == A {<br>        var copy = iterator<br>        nextImpl = { copy.next() }<br>    }<br></p><p>    func next() -&gt; A? {<br>        return nextImpl()<br>    }<br>}<br></p><p>Instead, it is implemented in a class which contains a box. The trick with<br>subclassing and generics to actually erase the type feels like a bit of a<br>hack, but I figured it would be there for performance reasons. In my<br>limited testing, I noticed my version is 20% slower when compiling without<br>optimizations. I didn&#39;t really understand why, even after reading through<br>the SIL. However, when compiling with optimizations, I noticed my version<br>is 10% faster.<br></p><p>I would like to make a PR to change the stdlib, but before I go through the<br>hassle, I&#39;d like to hear what the reasons (at the time?) were for the<br>current solution. Maybe it&#39;s just that the optimizer got better?<br></p><p>Thanks!<br></p><p>(Apologies if you receive this mail twice, my first message bounced saying<br>it was waiting for moderator approval, it didn&#39;t seem to get approved)<br></p><p>-- <br>Chris Eidhof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160905/2ccc2357/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Implementation of Type Erasers</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>September  5, 2016 at 12:00:00pm</p></header><div class="content"><p>On Mon, Sep 5, 2016 at 11:13 AM, Chris Eidhof via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hello swift-dev,<br>&gt;<br>&gt; I was wondering why type erasers (e.g. for AnyIterator) are implemented the<br>&gt; way they are. I would implement AnyIterator like this:<br>&gt;<br>&gt; final class MyAnyIterator&lt;A&gt;: IteratorProtocol {<br>&gt;     var nextImpl: () -&gt; A?<br>&gt;<br>&gt;     init&lt;I: IteratorProtocol&gt;(iterator: I) where I.Element == A {<br>&gt;         var copy = iterator<br>&gt;         nextImpl = { copy.next() }<br>&gt;     }<br>&gt;<br>&gt;     func next() -&gt; A? {<br>&gt;         return nextImpl()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Instead, it is implemented in a class which contains a box.<br></p><p>Your approach requires adding a new closure property for every method<br>that is forwarded.  Subclassing does not require that.<br></p><p>If you see a case where performance is not good, we would appreciate a<br>bugreport at https://bugs.swift.org/ .  Please attach a self-contained<br>reproducer.  Thank you.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Implementation of Type Erasers</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>September  6, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks! That explains a lot.<br></p><p>In my version, performance only is improved by 10%, so I&#39;m not sure if the<br>tradeoff is worth it:<br></p><p>In the isolated case of AnyIterator, there&#39;s only one method, so the sizeof<br>is the same (and the performance is worth it). In the case of AnySequence,<br>it would be a lot more work to write the implementation (and the size would<br>change a lot). Having two different mechanisms for type erasure seems like<br>it might confuse things even more.<br></p><p>On Mon, Sep 5, 2016 at 9:50 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Mon, Sep 5, 2016 at 11:13 AM, Chris Eidhof via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; Hello swift-dev,<br>&gt; &gt;<br>&gt; &gt; I was wondering why type erasers (e.g. for AnyIterator) are implemented<br>&gt; the<br>&gt; &gt; way they are. I would implement AnyIterator like this:<br>&gt; &gt;<br>&gt; &gt; final class MyAnyIterator&lt;A&gt;: IteratorProtocol {<br>&gt; &gt;     var nextImpl: () -&gt; A?<br>&gt; &gt;<br>&gt; &gt;     init&lt;I: IteratorProtocol&gt;(iterator: I) where I.Element == A {<br>&gt; &gt;         var copy = iterator<br>&gt; &gt;         nextImpl = { copy.next() }<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     func next() -&gt; A? {<br>&gt; &gt;         return nextImpl()<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Instead, it is implemented in a class which contains a box.<br>&gt;<br>&gt; Your approach requires adding a new closure property for every method<br>&gt; that is forwarded.  Subclassing does not require that.<br>&gt;<br>&gt; If you see a case where performance is not good, we would appreciate a<br>&gt; bugreport at https://bugs.swift.org/ .  Please attach a self-contained<br>&gt; reproducer.  Thank you.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br></p><p><br></p><p>-- <br>Chris Eidhof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160906/61484876/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
