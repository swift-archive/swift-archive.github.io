<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 18, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>I&#39;m generally in strong support, having long been a proponent of removing<br>operators from protocols (the first occurrence was in this thread:<br>http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br></p><p>I have several comments about the details of the proposal, however.<br></p><p>1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&quot;This document does not propose that the current way of defining operators<br>be removed or changed at this time. Rather, we describe an addition that<br>specifically provides improvements for protocol operator requirements.&quot;<br></p><p>Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>section which suggest to do exactly that, and this is reiterated in the<br>&quot;Impact on existing code&quot; section.<br></p><p>Since I think that the deprecation of global operator overloads is the<br>crucial point of the proposal, I assume that the former is an oversight.<br></p><p>2) The method signatures in the examples are not up to date with the current<br>Swift 3 syntax. For example:<br></p><p>protocol Equatable {<br>  static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>should be:<br></p><p>protocol Equatable {<br>  static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>}<br></p><p>3) As has already been noted by many others, the suggested syntax for<br>prefix/postfix operators is overcomplicated. The proposal is:<br></p><p>// These are deprecated, of course, but used here just to serve as an<br>// example.<br>static prefix func ++(_ value: inout Self) -&gt; Self<br>static postfix func ++(_ value: inout Self) -&gt; Self<br></p><p>We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>effectively just normal methods (apart from their names), we just need to<br>name the parameters accordingly:<br></p><p>static func ++(prefix value: inout Self) -&gt; Self<br>static func ++(postfix value: inout Self) -&gt; Self<br></p><p>4) I don&#39;t agree with the request to limit to static methods for the<br>operator implementations.<br>I support this for symmetrical binary operators like +, but there are other<br>operators like += that seem to work better with members. That is, the<br>proposed declaration:<br></p><p>static func +=(_ lhs: inout Self, _ rhs: Self)<br></p><p>is more similar to the global += operator definition, but is less clear than:<br></p><p>mutating func +=(_ rhs: Self)<br></p><p>this is apparent also at the call site. With the proposed syntax, one would<br>need to do:<br></p><p>func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>    T.+=(lhs, rhs)<br>}<br></p><p>while with a member function this would read more naturally as:<br></p><p>func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>    lhs.+=(rhs)<br>}<br></p><p>5) the proposal mentions the open question of ambiguities between the dot<br>syntax to access methods and operators whose name starts with a dot.<br>This seems to be a real issue: I don&#39;t think<br></p><p>return T....(minimum, maximum)<br></p><p>looks any good, even if the compiler was able to parse it.<br></p><p>However, this just means that the methods used to implement operators with<br>problematic names would need to use different names. Arguably, the only<br>cases where one would really want to use methods with operator names is for<br>arithmetical operators. Custom operators like ... are better expressed as<br>methods with more significant names.<br></p><p>6) It seems somewhat arbitrary to restrict method names to match an<br>operator, nor to put requirements on the function signature. I&#39;d say there<br>are two cases, either the compiler can handle a method name that uses<br>special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>won&#39;t help. If it can, why put limits? There could be other creative uses of<br>such names, which we would be ruling out for no particular reason. This is<br>something that seems better left to the author of the protocol.<br></p><p>7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>going to talk much about it, I only want to mention that it would make sense<br>to consider making such a feature as general as possible, instead of<br>focusing exclusively on operators.<br></p><p>For example, think of the common mathematical functions like sin, cos, etc.<br>It could make sense to give them the same treatment as operators, declaring<br>them as part of the FloatingPoint protocol but preserving the global<br>functions too.<br>It might even make sense to be able to create trampolines not only from<br>global space to a type, but also from one type to another type, or even for<br>all methods of a type (e.g. when boxing a value inside another type).<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Absolutely. The handling of operators in protocols has been one of the worst<br>pain points in my use of Swift.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes; it significantly increases clarity and consistency.<br></p><p>&gt; * If you have used other languages or libraries with a similar feature,<br>how do you feel that this proposal compares to those?<br></p><p>I only have experience with C++ operator overloading, which is much less<br>advanced.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>An in-depth study of the proposal, and I read all the relevant threads on<br>the mailing list.<br></p><p>--<br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt; operators from protocols (the first occurrence was in this thread:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;<br>&gt; I have several comments about the details of the proposal, however.<br>&gt;<br>&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt; &quot;This document does not propose that the current way of defining operators<br>&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;<br>&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt; &quot;Impact on existing code&quot; section.<br>&gt;<br>&gt; Since I think that the deprecation of global operator overloads is the<br>&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;<br></p><p>I could probably do a better job of clarifying the wording here. The<br>proposal does *not* deprecate *all* global operator overloads. Global<br>operators can still be implemented as they have been in Swift. So if you<br>have a concrete type like `struct Matrix`, you can still define at the<br>global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br></p><p>What&#39;s being deprecated is the current syntax used to define operator<br>requirements inside protocols (by making the functions static) and the<br>manner by which subtypes conform (ditto, through static methods instead of<br>global functions).<br></p><p><br>&gt; 2) The method signatures in the examples are not up to date with the<br>&gt; current<br>&gt; Swift 3 syntax. For example:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; should be:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br></p><p>Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>syntax changes don&#39;t appear to apply to operator functions. Since they are<br>a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>require them (or rather, the placeholders) here.<br></p><p><br>&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;<br>&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt; // example.<br>&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;<br>&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt; effectively just normal methods (apart from their names), we just need to<br>&gt; name the parameters accordingly:<br>&gt;<br>&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;<br>&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt; operator implementations.<br>&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt; operators like += that seem to work better with members. That is, the<br>&gt; proposed declaration:<br>&gt;<br>&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;<br>&gt; is more similar to the global += operator definition, but is less clear<br>&gt; than:<br>&gt;<br>&gt; mutating func +=(_ rhs: Self)<br>&gt;<br>&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt; need to do:<br>&gt;<br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;     T.+=(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; while with a member function this would read more naturally as:<br>&gt;<br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;     lhs.+=(rhs)<br>&gt; }<br>&gt;<br></p><p>I considered this, but eventually settled on &quot;everything is static&quot; for<br>consistency. As you mention, there&#39;s a stronger argument to be made for<br>assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>than there are for standard infix operators, but from a consistency point<br>of view (and ease of learning), I think having everything static and the<br>signatures of the static operators matching those of the global operators<br>is preferable. (Which is also why, as I mentioned in a previous reply, I<br>would be open to dropping the prefix/postfix keyword and making it an<br>argument label instead, in both contexts.)<br></p><p><br>&gt;<br>&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt; This seems to be a real issue: I don&#39;t think<br>&gt;<br>&gt; return T....(minimum, maximum)<br>&gt;<br>&gt; looks any good, even if the compiler was able to parse it.<br>&gt;<br>&gt; However, this just means that the methods used to implement operators with<br>&gt; problematic names would need to use different names. Arguably, the only<br>&gt; cases where one would really want to use methods with operator names is for<br>&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt; methods with more significant names.<br>&gt;<br></p><p>If there is a strong case where an operator is better implemented as a<br>global operator and a named method, this proposal still allows that, since<br>it&#39;s not deprecating all global operator definitions. A protocol could<br>certainly have a requirement that is a named method, and provide a global<br>generic operator that calls it.<br></p><p><br>&gt;<br>&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt; are two cases, either the compiler can handle a method name that uses<br>&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt; won&#39;t help. If it can, why put limits? There could be other creative uses<br>&gt; of<br>&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt; something that seems better left to the author of the protocol.<br>&gt;<br></p><p>IMO, to reduce potential confusion, I would argue that a function whose<br>name is the same as a defined operator should conform to the requirements<br>(such as argument count) of that operator. It&#39;s certainly worth discussion,<br>though! With that being said, it may be easier on users to &quot;rule something<br>out&quot; now and open it up later if need be, rather than to leave it open for<br>people to use and decide it needs to be closed later.<br></p><p><br>&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt; going to talk much about it, I only want to mention that it would make<br>&gt; sense<br>&gt; to consider making such a feature as general as possible, instead of<br>&gt; focusing exclusively on operators.<br>&gt;<br>&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt; functions too.<br>&gt; It might even make sense to be able to create trampolines not only from<br>&gt; global space to a type, but also from one type to another type, or even for<br>&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;<br>&gt; &gt; * Is the problem being addressed significant enough to warrant a change<br>&gt; to<br>&gt; Swift?<br>&gt;<br>&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt; worst<br>&gt; pain points in my use of Swift.<br>&gt;<br>&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes; it significantly increases clarity and consistency.<br>&gt;<br>&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I only have experience with C++ operator overloading, which is much less<br>&gt; advanced.<br>&gt;<br>&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt; reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt; the mailing list.<br>&gt;<br>&gt; --<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/45b8b4b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br></p><p>&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;<br>&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;<br>&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt;&gt; &quot;This document does not propose that the current way of defining operators<br>&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;<br>&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;<br>&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;<br>&gt;<br>&gt; I could probably do a better job of clarifying the wording here. The<br>&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;<br>&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt; requirements inside protocols (by making the functions static) and the<br>&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt; global functions).<br>&gt;<br></p><p>OK, I guess the unclear part is when you talk about &quot;an addition that<br>specifically provides improvements for protocol operator requirements.&quot;<br>This is not just an addition; it&#39;s intended to completely replace the<br>protocol operator syntax.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt; current<br>&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;<br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; should be:<br>&gt;&gt;<br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;<br>&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt; require them (or rather, the placeholders) here.<br>&gt;<br></p><p>I don&#39;t agree with this.<br></p><p>Operators are called like this:<br></p><p>x = y + z<br></p><p>Of course it doesn&#39;t make sense to have parameter labels there.<br></p><p>But the ones inside the protocol are not operators. They are methods, and<br>are called like methods. They happen to have funny names, but they are<br>still methods, and are called like this:<br></p><p>x = T.+(y, z)<br></p><p>In this case not only it makes sense for the parameters to have labels, but<br>making them behave differently from normal methods would be inconsistent,<br>and a step backwards from all the progress that has been made in Swift 3 on<br>that front.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;<br>&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt; // example.<br>&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt; name the parameters accordingly:<br>&gt;&gt;<br>&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt; operator implementations.<br>&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt; other<br>&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt; proposed declaration:<br>&gt;&gt;<br>&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;<br>&gt;&gt; is more similar to the global += operator definition, but is less clear<br>&gt;&gt; than:<br>&gt;&gt;<br>&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;<br>&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt; would<br>&gt;&gt; need to do:<br>&gt;&gt;<br>&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;<br>&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;<br>&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt; than there are for standard infix operators, but from a consistency point<br>&gt; of view (and ease of learning), I think having everything static and the<br>&gt; signatures of the static operators matching those of the global operators<br>&gt; is preferable.<br>&gt;<br></p><p>I think this would better be left as a choice to the author of the<br>protocol. There doesn&#39;t seem to be any technical reason to place this<br>restriction.<br></p><p><br>&gt; (Which is also why, as I mentioned in a previous reply, I would be open to<br>&gt; dropping the prefix/postfix keyword and making it an argument label<br>&gt; instead, in both contexts.)<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;<br>&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;<br>&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;<br>&gt;&gt; However, this just means that the methods used to implement operators with<br>&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt; cases where one would really want to use methods with operator names is<br>&gt;&gt; for<br>&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt; methods with more significant names.<br>&gt;&gt;<br>&gt;<br>&gt; If there is a strong case where an operator is better implemented as a<br>&gt; global operator and a named method, this proposal still allows that, since<br>&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt; certainly have a requirement that is a named method, and provide a global<br>&gt; generic operator that calls it.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative uses<br>&gt;&gt; of<br>&gt;&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;<br>&gt;<br>&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt; name is the same as a defined operator should conform to the requirements<br>&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt; people to use and decide it needs to be closed later.<br>&gt;<br></p><p>This doesn&#39;t seem different to me from having multiple functions with the<br>same name and different signature, which Swift allows without problems.<br>Again, I think this is a choice that the author of the protocol should<br>make, and there doesn&#39;t seem to be any technical reason to require<br>otherwise.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt; sense<br>&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;<br>&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt; etc.<br>&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt; declaring<br>&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt; functions too.<br>&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt; global space to a type, but also from one type to another type, or even<br>&gt;&gt; for<br>&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;<br>&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a change<br>&gt;&gt; to<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt; worst<br>&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;<br>&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;<br>&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;<br>&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt; advanced.<br>&gt;&gt;<br>&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt; the mailing list.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/0d864a31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt; operators from protocols (the first occurrence was in this thread:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7935&gt;)<br>&gt; <br>&gt; I have several comments about the details of the proposal, however.<br>&gt; <br>&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt; &quot;This document does not propose that the current way of defining operators<br>&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt; <br>&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt; &quot;Impact on existing code&quot; section.<br>&gt; <br>&gt; Since I think that the deprecation of global operator overloads is the<br>&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt; <br>&gt; I could probably do a better job of clarifying the wording here. The proposal does *not* deprecate *all* global operator overloads. Global operators can still be implemented as they have been in Swift. So if you have a concrete type like `struct Matrix`, you can still define at the global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt; <br>&gt; What&#39;s being deprecated is the current syntax used to define operator requirements inside protocols (by making the functions static) and the manner by which subtypes conform (ditto, through static methods instead of global functions).<br>&gt; <br>&gt; OK, I guess the unclear part is when you talk about &quot;an addition that specifically provides improvements for protocol operator requirements.&quot; This is not just an addition; it&#39;s intended to completely replace the protocol operator syntax.<br>&gt; <br>&gt; <br>&gt; 2) The method signatures in the examples are not up to date with the current<br>&gt; Swift 3 syntax. For example:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; should be:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the syntax changes don&#39;t appear to apply to operator functions. Since they are a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to require them (or rather, the placeholders) here.<br>&gt; <br>&gt; I don&#39;t agree with this.<br>&gt; <br>&gt; Operators are called like this:<br>&gt; <br>&gt; x = y + z<br>&gt; <br>&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt; <br>&gt; But the ones inside the protocol are not operators. They are methods, and are called like methods. They happen to have funny names, but they are still methods, and are called like this:<br>&gt; <br>&gt; x = T.+(y, z)<br>&gt; <br>&gt; In this case not only it makes sense for the parameters to have labels, but making them behave differently from normal methods would be inconsistent, and a step backwards from all the progress that has been made in Swift 3 on that front.<br>&gt;  <br>&gt; <br>&gt; <br>&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt; <br>&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt; // example.<br>&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt; <br>&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt; effectively just normal methods (apart from their names), we just need to<br>&gt; name the parameters accordingly:<br>&gt; <br>&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt; <br>&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt; operator implementations.<br>&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt; operators like += that seem to work better with members. That is, the<br>&gt; proposed declaration:<br>&gt; <br>&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt; <br>&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt; <br>&gt; mutating func +=(_ rhs: Self)<br>&gt; <br>&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt; need to do:<br>&gt; <br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;     T.+=(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; while with a member function this would read more naturally as:<br>&gt; <br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;     lhs.+=(rhs)<br>&gt; }<br>&gt; <br>&gt; I considered this, but eventually settled on &quot;everything is static&quot; for consistency. As you mention, there&#39;s a stronger argument to be made for assignment operators to have &quot;left hand side is the receiver&quot; semantics than there are for standard infix operators, but from a consistency point of view (and ease of learning), I think having everything static and the signatures of the static operators matching those of the global operators is preferable.<br>&gt; <br>&gt; I think this would better be left as a choice to the author of the protocol. There doesn&#39;t seem to be any technical reason to place this restriction.<br></p><p>The problem with this is that people will make different choices.  This may result in boilerplate where a type has to provide both static *and* instance methods to conform to different protocols.  Better to avoid that possibility.<br></p><p>What benefit do you perceive in allowing operator instance methods?<br></p><p>&gt;  <br>&gt; (Which is also why, as I mentioned in a previous reply, I would be open to dropping the prefix/postfix keyword and making it an argument label instead, in both contexts.)<br>&gt;  <br>&gt; <br>&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt; This seems to be a real issue: I don&#39;t think<br>&gt; <br>&gt; return T....(minimum, maximum)<br>&gt; <br>&gt; looks any good, even if the compiler was able to parse it.<br>&gt; <br>&gt; However, this just means that the methods used to implement operators with<br>&gt; problematic names would need to use different names. Arguably, the only<br>&gt; cases where one would really want to use methods with operator names is for<br>&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt; methods with more significant names.<br>&gt; <br>&gt; If there is a strong case where an operator is better implemented as a global operator and a named method, this proposal still allows that, since it&#39;s not deprecating all global operator definitions. A protocol could certainly have a requirement that is a named method, and provide a global generic operator that calls it.<br>&gt;  <br>&gt; <br>&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt; are two cases, either the compiler can handle a method name that uses<br>&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt; won&#39;t help. If it can, why put limits? There could be other creative uses of<br>&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt; something that seems better left to the author of the protocol.<br>&gt; <br>&gt; IMO, to reduce potential confusion, I would argue that a function whose name is the same as a defined operator should conform to the requirements (such as argument count) of that operator. It&#39;s certainly worth discussion, though! With that being said, it may be easier on users to &quot;rule something out&quot; now and open it up later if need be, rather than to leave it open for people to use and decide it needs to be closed later.<br>&gt; <br>&gt; This doesn&#39;t seem different to me from having multiple functions with the same name and different signature, which Swift allows without problems. Again, I think this is a choice that the author of the protocol should make, and there doesn&#39;t seem to be any technical reason to require otherwise.<br>&gt;  <br>&gt; <br>&gt; <br>&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt; going to talk much about it, I only want to mention that it would make sense<br>&gt; to consider making such a feature as general as possible, instead of<br>&gt; focusing exclusively on operators.<br>&gt; <br>&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt; functions too.<br>&gt; It might even make sense to be able to create trampolines not only from<br>&gt; global space to a type, but also from one type to another type, or even for<br>&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt; <br>&gt; &gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; <br>&gt; Absolutely. The handling of operators in protocols has been one of the worst<br>&gt; pain points in my use of Swift.<br>&gt; <br>&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes; it significantly increases clarity and consistency.<br>&gt; <br>&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I only have experience with C++ operator overloading, which is much less<br>&gt; advanced.<br>&gt; <br>&gt; &gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt; <br>&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt; the mailing list.<br>&gt; <br>&gt; --<br>&gt; Nicola<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/081dcf4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 10:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt; says<br>&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt; operators<br>&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;<br>&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt; global functions).<br>&gt;&gt;<br>&gt;<br>&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt; protocol operator syntax.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt; current<br>&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t agree with this.<br>&gt;<br>&gt; Operators are called like this:<br>&gt;<br>&gt; x = y + z<br>&gt;<br>&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;<br>&gt; But the ones inside the protocol are not operators. They are methods, and<br>&gt; are called like methods. They happen to have funny names, but they are<br>&gt; still methods, and are called like this:<br>&gt;<br>&gt; x = T.+(y, z)<br>&gt;<br>&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt; but making them behave differently from normal methods would be<br>&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt; in Swift 3 on that front.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt; // example.<br>&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt; other<br>&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is more similar to the global += operator definition, but is less clear<br>&gt;&gt;&gt; than:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt; would<br>&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt;&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt; is preferable.<br>&gt;&gt;<br>&gt;<br>&gt; I think this would better be left as a choice to the author of the<br>&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt; restriction.<br>&gt;<br>&gt;<br>&gt; The problem with this is that people will make different choices.  This<br>&gt; may result in boilerplate where a type has to provide both static *and*<br>&gt; instance methods to conform to different protocols.  Better to avoid that<br>&gt; possibility.<br>&gt;<br></p><p>Do you have a specific example in mind?<br></p><p>I expect the stdlib to illustrate what idiomatic Swift is expected to be,<br>and people to follow suit for the standard operators.<br></p><p><br>&gt; What benefit do you perceive in allowing operator instance methods?<br>&gt;<br></p><p>The fact that operators like += are more naturally implemented as an<br>instance method than as a static method is already a clear benefit to me.<br></p><p>But in general, there aren&#39;t only the standard operators; people will<br>define custom operators and will have different needs depending on their<br>semantics. If there isn&#39;t a technical limitation, I don&#39;t see a reason to<br>add arbitrary restrictions.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open<br>&gt;&gt; to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt; instead, in both contexts.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt; cases where one would really want to use methods with operator names is<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt; generic operator that calls it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt; there<br>&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt; uses of<br>&gt;&gt;&gt; such names, which we would be ruling out for no particular reason. This<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt;&gt; name is the same as a defined operator should conform to the requirements<br>&gt;&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt;&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt;&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt;&gt; people to use and decide it needs to be closed later.<br>&gt;&gt;<br>&gt;<br>&gt; This doesn&#39;t seem different to me from having multiple functions with the<br>&gt; same name and different signature, which Swift allows without problems.<br>&gt; Again, I think this is a choice that the author of the protocol should<br>&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt; otherwise.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m<br>&gt;&gt;&gt; not<br>&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt;&gt; sense<br>&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt;&gt; etc.<br>&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt; declaring<br>&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt; global space to a type, but also from one type to another type, or even<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt; change to<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt;&gt; worst<br>&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading,<br>&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/9d33a0fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:14 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 18, 2016 at 10:03 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7935&gt;)<br>&gt;&gt; <br>&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt; <br>&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt;&gt; &quot;This document does not propose that the current way of defining operators<br>&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt; <br>&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt; <br>&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt; <br>&gt;&gt; I could probably do a better job of clarifying the wording here. The proposal does *not* deprecate *all* global operator overloads. Global operators can still be implemented as they have been in Swift. So if you have a concrete type like `struct Matrix`, you can still define at the global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt; <br>&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator requirements inside protocols (by making the functions static) and the manner by which subtypes conform (ditto, through static methods instead of global functions).<br>&gt;&gt; <br>&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that specifically provides improvements for protocol operator requirements.&quot; This is not just an addition; it&#39;s intended to completely replace the protocol operator syntax.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2) The method signatures in the examples are not up to date with the current<br>&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; should be:<br>&gt;&gt; <br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the syntax changes don&#39;t appear to apply to operator functions. Since they are a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to require them (or rather, the placeholders) here.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt; <br>&gt;&gt; Operators are called like this:<br>&gt;&gt; <br>&gt;&gt; x = y + z<br>&gt;&gt; <br>&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt; <br>&gt;&gt; But the ones inside the protocol are not operators. They are methods, and are called like methods. They happen to have funny names, but they are still methods, and are called like this:<br>&gt;&gt; <br>&gt;&gt; x = T.+(y, z)<br>&gt;&gt; <br>&gt;&gt; In this case not only it makes sense for the parameters to have labels, but making them behave differently from normal methods would be inconsistent, and a step backwards from all the progress that has been made in Swift 3 on that front.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt; <br>&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt; // example.<br>&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt; name the parameters accordingly:<br>&gt;&gt; <br>&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt; operator implementations.<br>&gt;&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt; proposed declaration:<br>&gt;&gt; <br>&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt; <br>&gt;&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt;&gt; <br>&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt; <br>&gt;&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt;&gt; need to do:<br>&gt;&gt; <br>&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt; <br>&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for consistency. As you mention, there&#39;s a stronger argument to be made for assignment operators to have &quot;left hand side is the receiver&quot; semantics than there are for standard infix operators, but from a consistency point of view (and ease of learning), I think having everything static and the signatures of the static operators matching those of the global operators is preferable.<br>&gt;&gt; <br>&gt;&gt; I think this would better be left as a choice to the author of the protocol. There doesn&#39;t seem to be any technical reason to place this restriction.<br>&gt; <br>&gt; The problem with this is that people will make different choices.  This may result in boilerplate where a type has to provide both static *and* instance methods to conform to different protocols.  Better to avoid that possibility.<br>&gt; <br>&gt; Do you have a specific example in mind?<br></p><p>No, it’s not possible today so there is no existing code to reference.  However, if you give people a choice some people will inevitably make a different choice than other people.<br></p><p>&gt; <br>&gt; I expect the stdlib to illustrate what idiomatic Swift is expected to be, and people to follow suit for the standard operators.<br></p><p>That is exactly what this proposal is attempting to do, and in a way that the language enforces the decision.  <br></p><p>&gt; <br>&gt; <br>&gt; What benefit do you perceive in allowing operator instance methods?<br>&gt; <br>&gt; The fact that operators like += are more naturally implemented as an instance method than as a static method is already a clear benefit to me.<br></p><p>Are you specifically thinking of assignment operators?  If so, I wouldn’t have a problem if the proposal specified assignment operators as instance methods and all other operators as static methods.  As long as there is only one way to define a specific operator requirement I will be happy.<br></p><p>&gt; <br>&gt; But in general, there aren&#39;t only the standard operators; people will define custom operators and will have different needs depending on their semantics. If there isn&#39;t a technical limitation, I don&#39;t see a reason to add arbitrary restrictions.<br></p><p>There is no difference in capability here so I’m not sure what you mean by having different “needs”.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open to dropping the prefix/postfix keyword and making it an argument label instead, in both contexts.)<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt; <br>&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt; <br>&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt; <br>&gt;&gt; However, this just means that the methods used to implement operators with<br>&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt; cases where one would really want to use methods with operator names is for<br>&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt; methods with more significant names.<br>&gt;&gt; <br>&gt;&gt; If there is a strong case where an operator is better implemented as a global operator and a named method, this proposal still allows that, since it&#39;s not deprecating all global operator definitions. A protocol could certainly have a requirement that is a named method, and provide a global generic operator that calls it.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative uses of<br>&gt;&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt; <br>&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose name is the same as a defined operator should conform to the requirements (such as argument count) of that operator. It&#39;s certainly worth discussion, though! With that being said, it may be easier on users to &quot;rule something out&quot; now and open it up later if need be, rather than to leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with the same name and different signature, which Swift allows without problems. Again, I think this is a choice that the author of the protocol should make, and there doesn&#39;t seem to be any technical reason to require otherwise.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt;&gt; going to talk much about it, I only want to mention that it would make sense<br>&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt; focusing exclusively on operators.<br>&gt;&gt; <br>&gt;&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt;&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt; functions too.<br>&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt; global space to a type, but also from one type to another type, or even for<br>&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt; <br>&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt; <br>&gt;&gt; Absolutely. The handling of operators in protocols has been one of the worst<br>&gt;&gt; pain points in my use of Swift.<br>&gt;&gt; <br>&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt; <br>&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt; advanced.<br>&gt;&gt; <br>&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt; the mailing list.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Nicola<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/2a84d689/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 18, 2016 at 11:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 10:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 18, 2016, at 3:14 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, May 18, 2016 at 10:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of<br>&gt;&gt;&gt;&gt; removing<br>&gt;&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt;&gt; says<br>&gt;&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt;&gt; operators<br>&gt;&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol<br>&gt;&gt;&gt;&gt; operators&quot;<br>&gt;&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt;&gt; global functions).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt;&gt; protocol operator syntax.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt;&gt; current<br>&gt;&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;<br>&gt;&gt; Operators are called like this:<br>&gt;&gt;<br>&gt;&gt; x = y + z<br>&gt;&gt;<br>&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;<br>&gt;&gt; But the ones inside the protocol are not operators. They are methods, and<br>&gt;&gt; are called like methods. They happen to have funny names, but they are<br>&gt;&gt; still methods, and are called like this:<br>&gt;&gt;<br>&gt;&gt; x = T.+(y, z)<br>&gt;&gt;<br>&gt;&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt;&gt; but making them behave differently from normal methods would be<br>&gt;&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt;&gt; in Swift 3 on that front.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need<br>&gt;&gt;&gt;&gt; to<br>&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less clear<br>&gt;&gt;&gt;&gt; than:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt;&gt;&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt; restriction.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The problem with this is that people will make different choices.  This<br>&gt;&gt; may result in boilerplate where a type has to provide both static *and*<br>&gt;&gt; instance methods to conform to different protocols.  Better to avoid that<br>&gt;&gt; possibility.<br>&gt;&gt;<br>&gt;<br>&gt; Do you have a specific example in mind?<br>&gt;<br>&gt;<br>&gt; No, it’s not possible today so there is no existing code to reference.<br>&gt; However, if you give people a choice some people will inevitably make a<br>&gt; different choice than other people.<br>&gt;<br></p><p>You mentioned needing to add boilerplate to make a type conform to<br>different protocols. In which scenario could that happen?<br>Once you take out the standard operators which will be taken care of by the<br>stdlib, I can&#39;t readily think of an example of an operator which could be<br>defined by two different protocols.<br></p><p>Also, this isn&#39;t a problem specific to operators; the same kind of<br>incompatibility can happen with normal methods. We lease freedom with<br>normal methods, so why should operators be more limited?<br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt; I expect the stdlib to illustrate what idiomatic Swift is expected to be,<br>&gt; and people to follow suit for the standard operators.<br>&gt;<br>&gt;<br>&gt; That is exactly what this proposal is attempting to do, and in a way that<br>&gt; the language enforces the decision.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; What benefit do you perceive in allowing operator instance methods?<br>&gt;&gt;<br>&gt;<br>&gt; The fact that operators like += are more naturally implemented as an<br>&gt; instance method than as a static method is already a clear benefit to me.<br>&gt;<br>&gt;<br>&gt; Are you specifically thinking of assignment operators?  If so, I wouldn’t<br>&gt; have a problem if the proposal specified assignment operators as instance<br>&gt; methods and all other operators as static methods.  As long as there is<br>&gt; only one way to define a specific operator requirement I will be happy.<br>&gt;<br>&gt;<br>&gt; But in general, there aren&#39;t only the standard operators; people will<br>&gt; define custom operators and will have different needs depending on their<br>&gt; semantics. If there isn&#39;t a technical limitation, I don&#39;t see a reason to<br>&gt; add arbitrary restrictions.<br>&gt;<br>&gt;<br>&gt; There is no difference in capability here so I’m not sure what you mean by<br>&gt; having different “needs”.<br>&gt;<br></p><p>By needs I mean choosing the representation that better fits the semantics<br>of the operator.<br>For symmetrical binary operators, a static method is probably the best<br>choice, but for other kinds of operators it might not be.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open<br>&gt;&gt;&gt; to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the<br>&gt;&gt;&gt;&gt; dot<br>&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names is<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed<br>&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt;&gt; generic operator that calls it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason. This<br>&gt;&gt;&gt;&gt; is<br>&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt;&gt;&gt; name is the same as a defined operator should conform to the requirements<br>&gt;&gt;&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt;&gt;&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt;&gt;&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt;&gt;&gt; people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with the<br>&gt;&gt; same name and different signature, which Swift allows without problems.<br>&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt; otherwise.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m<br>&gt;&gt;&gt;&gt; not<br>&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt;&gt;&gt; sense<br>&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt;&gt;&gt; etc.<br>&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or even<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt;&gt;&gt; worst<br>&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads<br>&gt;&gt;&gt;&gt; on<br>&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/de013271/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 2:01 PM Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Wed, May 18, 2016 at 10:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On May 18, 2016, at 3:14 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 10:03 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of<br>&gt;&gt;&gt;&gt;&gt; removing<br>&gt;&gt;&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt;&gt;&gt; says<br>&gt;&gt;&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt;&gt;&gt; operators<br>&gt;&gt;&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol<br>&gt;&gt;&gt;&gt;&gt; operators&quot;<br>&gt;&gt;&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an<br>&gt;&gt;&gt;&gt;&gt; oversight.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt;&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt;&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt;&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt;&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt;&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt;&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt;&gt;&gt; global functions).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt;&gt;&gt; protocol operator syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt;&gt;&gt; current<br>&gt;&gt;&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt;&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt;&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt;&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Operators are called like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x = y + z<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But the ones inside the protocol are not operators. They are methods,<br>&gt;&gt;&gt; and are called like methods. They happen to have funny names, but they are<br>&gt;&gt;&gt; still methods, and are called like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x = T.+(y, z)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt;&gt;&gt; but making them behave differently from normal methods would be<br>&gt;&gt;&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt;&gt;&gt; in Swift 3 on that front.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need<br>&gt;&gt;&gt;&gt;&gt; to<br>&gt;&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less<br>&gt;&gt;&gt;&gt;&gt; clear than:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt;&gt;&gt;&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt;&gt; restriction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The problem with this is that people will make different choices.  This<br>&gt;&gt;&gt; may result in boilerplate where a type has to provide both static *and*<br>&gt;&gt;&gt; instance methods to conform to different protocols.  Better to avoid that<br>&gt;&gt;&gt; possibility.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Do you have a specific example in mind?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No, it’s not possible today so there is no existing code to reference.<br>&gt;&gt; However, if you give people a choice some people will inevitably make a<br>&gt;&gt; different choice than other people.<br>&gt;&gt;<br>&gt;<br>&gt; You mentioned needing to add boilerplate to make a type conform to<br>&gt; different protocols. In which scenario could that happen?<br>&gt; Once you take out the standard operators which will be taken care of by<br>&gt; the stdlib, I can&#39;t readily think of an example of an operator which could<br>&gt; be defined by two different protocols.<br>&gt;<br>&gt; Also, this isn&#39;t a problem specific to operators; the same kind of<br>&gt; incompatibility can happen with normal methods. We lease freedom with<br>&gt; normal methods, so why should operators be more limited?<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I expect the stdlib to illustrate what idiomatic Swift is expected to be,<br>&gt;&gt; and people to follow suit for the standard operators.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That is exactly what this proposal is attempting to do, and in a way that<br>&gt;&gt; the language enforces the decision.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; What benefit do you perceive in allowing operator instance methods?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The fact that operators like += are more naturally implemented as an<br>&gt;&gt; instance method than as a static method is already a clear benefit to me.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Are you specifically thinking of assignment operators?  If so, I wouldn’t<br>&gt;&gt; have a problem if the proposal specified assignment operators as instance<br>&gt;&gt; methods and all other operators as static methods.  As long as there is<br>&gt;&gt; only one way to define a specific operator requirement I will be happy.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But in general, there aren&#39;t only the standard operators; people will<br>&gt;&gt; define custom operators and will have different needs depending on their<br>&gt;&gt; semantics. If there isn&#39;t a technical limitation, I don&#39;t see a reason to<br>&gt;&gt; add arbitrary restrictions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is no difference in capability here so I’m not sure what you mean<br>&gt;&gt; by having different “needs”.<br>&gt;&gt;<br>&gt;<br>&gt; By needs I mean choosing the representation that better fits the semantics<br>&gt; of the operator.<br>&gt; For symmetrical binary operators, a static method is probably the best<br>&gt; choice, but for other kinds of operators it might not be.<br>&gt;<br></p><p>I&#39;m still not convinced that having assignment operators be mutating<br>instance methods buys you that much though, other than turning an argument<br>reference into a (possibly implicit) self reference. Is that really<br>significant enough to introduce an inconsistency between the syntax of the<br>global operator and the static method in the protocol? Can you think of any<br>examples where there are greater benefits?<br></p><p>Allowing user choice here seems like a bad idea. There really should only<br>be one way to declare operators (or at least, a particular kind of<br>operator) in a protocol; if they&#39;re functionally equivalent and the only<br>difference is `lhs` vs. `self`, we risk different developers making<br>different choices for arbitrary reasons (and, even worse, the other of the<br>protocol ends up making that decision for everyone who wants to conform to<br>it).<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open<br>&gt;&gt;&gt;&gt; to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the<br>&gt;&gt;&gt;&gt;&gt; dot<br>&gt;&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names<br>&gt;&gt;&gt;&gt;&gt; is for<br>&gt;&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed<br>&gt;&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt;&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt;&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt;&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt;&gt;&gt; generic operator that calls it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason.<br>&gt;&gt;&gt;&gt;&gt; This is<br>&gt;&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt;&gt;&gt;&gt; name is the same as a defined operator should conform to the requirements<br>&gt;&gt;&gt;&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt;&gt;&gt;&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt;&gt;&gt;&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt;&gt;&gt;&gt; people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with<br>&gt;&gt;&gt; the same name and different signature, which Swift allows without problems.<br>&gt;&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt;&gt; otherwise.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m<br>&gt;&gt;&gt;&gt;&gt; not<br>&gt;&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt;&gt;&gt;&gt; sense<br>&gt;&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt;&gt;&gt;&gt; etc.<br>&gt;&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or<br>&gt;&gt;&gt;&gt;&gt; even for<br>&gt;&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt;&gt;&gt;&gt; worst<br>&gt;&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much<br>&gt;&gt;&gt;&gt;&gt; less<br>&gt;&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads<br>&gt;&gt;&gt;&gt;&gt; on<br>&gt;&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/ac4c0457/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 4:01 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 18, 2016 at 10:36 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 18, 2016, at 3:14 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com &lt;mailto:nicola.salmoria at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, May 18, 2016 at 10:03 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7935&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt;&gt;&gt; &quot;This document does not propose that the current way of defining operators<br>&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The proposal does *not* deprecate *all* global operator overloads. Global operators can still be implemented as they have been in Swift. So if you have a concrete type like `struct Matrix`, you can still define at the global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator requirements inside protocols (by making the functions static) and the manner by which subtypes conform (ditto, through static methods instead of global functions).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that specifically provides improvements for protocol operator requirements.&quot; This is not just an addition; it&#39;s intended to completely replace the protocol operator syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the current<br>&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; should be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the syntax changes don&#39;t appear to apply to operator functions. Since they are a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to require them (or rather, the placeholders) here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Operators are called like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = y + z<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But the ones inside the protocol are not operators. They are methods, and are called like methods. They happen to have funny names, but they are still methods, and are called like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = T.+(y, z)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case not only it makes sense for the parameters to have labels, but making them behave differently from normal methods would be inconsistent, and a step backwards from all the progress that has been made in Swift 3 on that front.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt; // example.<br>&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for consistency. As you mention, there&#39;s a stronger argument to be made for assignment operators to have &quot;left hand side is the receiver&quot; semantics than there are for standard infix operators, but from a consistency point of view (and ease of learning), I think having everything static and the signatures of the static operators matching those of the global operators is preferable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this would better be left as a choice to the author of the protocol. There doesn&#39;t seem to be any technical reason to place this restriction.<br>&gt;&gt; <br>&gt;&gt; The problem with this is that people will make different choices.  This may result in boilerplate where a type has to provide both static *and* instance methods to conform to different protocols.  Better to avoid that possibility.<br>&gt;&gt; <br>&gt;&gt; Do you have a specific example in mind?<br>&gt; <br>&gt; No, it’s not possible today so there is no existing code to reference.  However, if you give people a choice some people will inevitably make a different choice than other people.<br>&gt; <br>&gt; You mentioned needing to add boilerplate to make a type conform to different protocols. In which scenario could that happen?<br></p><p>Not to make it conform.  To actually use the operator on your type.<br></p><p>Imagine this:<br></p><p>protocol P { <br>    static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>}<br></p><p>protocol Q { <br>    func ++++(rhs: Self) -&gt; Self<br>}<br></p><p>struct S: P, Q {<br>    static func ++++(lhs: Self, rhs: Self) -&gt; Self {<br>        // ...<br>    }<br>    func ++++(rhs: Self) -&gt; Self {<br>       // ...<br>   }<br>}<br></p><p>I’m required to implement the same operator twice if I want to conform to both protocols.  Allowing this possibility would be a flaw in the language IMO.<br></p><p><br>&gt; Once you take out the standard operators which will be taken care of by the stdlib, I can&#39;t readily think of an example of an operator which could be defined by two different protocols.<br></p><p>I can’t readily think of an example either, but I would prefer to rule out the possibility of the same operator being declared by two protocols in two different ways.<br></p><p>&gt; <br>&gt; Also, this isn&#39;t a problem specific to operators; the same kind of incompatibility can happen with normal methods. We lease freedom with normal methods, so why should operators be more limited?<br></p><p>This isn’t a problem with normal methods because they don’t typically use top-level trampolines as part of their implementation.<br></p><p>An alternative would be allowing the operator declaration itself to specify whether it should be implemented as a static or instance operator.<br></p><p>My primary concern is that there should only be one way to specify a protocol requirement for an individual operator.  <br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I expect the stdlib to illustrate what idiomatic Swift is expected to be, and people to follow suit for the standard operators.<br>&gt; <br>&gt; That is exactly what this proposal is attempting to do, and in a way that the language enforces the decision.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What benefit do you perceive in allowing operator instance methods?<br>&gt;&gt; <br>&gt;&gt; The fact that operators like += are more naturally implemented as an instance method than as a static method is already a clear benefit to me.<br>&gt; <br>&gt; Are you specifically thinking of assignment operators?  If so, I wouldn’t have a problem if the proposal specified assignment operators as instance methods and all other operators as static methods.  As long as there is only one way to define a specific operator requirement I will be happy.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; But in general, there aren&#39;t only the standard operators; people will define custom operators and will have different needs depending on their semantics. If there isn&#39;t a technical limitation, I don&#39;t see a reason to add arbitrary restrictions.<br>&gt; <br>&gt; There is no difference in capability here so I’m not sure what you mean by having different “needs”.<br>&gt; <br>&gt; By needs I mean choosing the representation that better fits the semantics of the operator.<br>&gt; For symmetrical binary operators, a static method is probably the best choice, but for other kinds of operators it might not be.<br></p><p>Sure.  But if you want to go in that direction maybe it’s worthwhile to try and define general classes of operators for which each syntax fits better and require that syntax to be used.  I can see a case for doing this, but a lot of people will argue against it on grounds that it is inconsistent.<br></p><p>&gt;  <br>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open to dropping the prefix/postfix keyword and making it an argument label instead, in both contexts.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, this just means that the methods used to implement operators with<br>&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt; cases where one would really want to use methods with operator names is for<br>&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a global operator and a named method, this proposal still allows that, since it&#39;s not deprecating all global operator definitions. A protocol could certainly have a requirement that is a named method, and provide a global generic operator that calls it.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative uses of<br>&gt;&gt;&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose name is the same as a defined operator should conform to the requirements (such as argument count) of that operator. It&#39;s certainly worth discussion, though! With that being said, it may be easier on users to &quot;rule something out&quot; now and open it up later if need be, rather than to leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with the same name and different signature, which Swift allows without problems. Again, I think this is a choice that the author of the protocol should make, and there doesn&#39;t seem to be any technical reason to require otherwise.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make sense<br>&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt;&gt;&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt; global space to a type, but also from one type to another type, or even for<br>&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the worst<br>&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/5d0796a1/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 25, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 18.05.2016 um 23:19 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 4:01 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, May 18, 2016 at 10:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 3:14 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 10:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 3:00 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;This document does not propose that the current way of defining operators<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The proposal does *not* deprecate *all* global operator overloads. Global operators can still be implemented as they have been in Swift. So if you have a concrete type like `struct Matrix`, you can still define at the global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator requirements inside protocols (by making the functions static) and the manner by which subtypes conform (ditto, through static methods instead of global functions).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that specifically provides improvements for protocol operator requirements.&quot; This is not just an addition; it&#39;s intended to completely replace the protocol operator syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the current<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the syntax changes don&#39;t appear to apply to operator functions. Since they are a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to require them (or rather, the placeholders) here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Operators are called like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x = y + z<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But the ones inside the protocol are not operators. They are methods, and are called like methods. They happen to have funny names, but they are still methods, and are called like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x = T.+(y, z)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this case not only it makes sense for the parameters to have labels, but making them behave differently from normal methods would be inconsistent, and a step backwards from all the progress that has been made in Swift 3 on that front.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for consistency. As you mention, there&#39;s a stronger argument to be made for assignment operators to have &quot;left hand side is the receiver&quot; semantics than there are for standard infix operators, but from a consistency point of view (and ease of learning), I think having everything static and the signatures of the static operators matching those of the global operators is preferable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this would better be left as a choice to the author of the protocol. There doesn&#39;t seem to be any technical reason to place this restriction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem with this is that people will make different choices.  This may result in boilerplate where a type has to provide both static *and* instance methods to conform to different protocols.  Better to avoid that possibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you have a specific example in mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it’s not possible today so there is no existing code to reference.  However, if you give people a choice some people will inevitably make a different choice than other people.<br>&gt;&gt; <br>&gt;&gt; You mentioned needing to add boilerplate to make a type conform to different protocols. In which scenario could that happen?<br>&gt; <br>&gt; Not to make it conform.  To actually use the operator on your type.<br>&gt; <br>&gt; Imagine this:<br>&gt; <br>&gt; protocol P { <br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; protocol Q { <br>&gt;     func ++++(rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; struct S: P, Q {<br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self {<br>&gt;         // ...<br>&gt;     }<br>&gt;     func ++++(rhs: Self) -&gt; Self {<br>&gt;        // ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I’m required to implement the same operator twice if I want to conform to both protocols.  Allowing this possibility would be a flaw in the language IMO.<br></p><p>I&#39;m not sure I understand this argument: if both operators had been defined with the same syntax I would have an even bigger problem, namely that conforming to both protocols is impossible without breaking the semantics of one operator. <br>Both operators have been defined in different protocols, so they will have diffent semantics, and as Swift currently provides no way to resolve name clashes (like Eiffel would), there is no way to conform to both protocols properly.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; Once you take out the standard operators which will be taken care of by the stdlib, I can&#39;t readily think of an example of an operator which could be defined by two different protocols.<br>&gt; <br>&gt; I can’t readily think of an example either, but I would prefer to rule out the possibility of the same operator being declared by two protocols in two different ways.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Also, this isn&#39;t a problem specific to operators; the same kind of incompatibility can happen with normal methods. We lease freedom with normal methods, so why should operators be more limited?<br>&gt; <br>&gt; This isn’t a problem with normal methods because they don’t typically use top-level trampolines as part of their implementation.<br>&gt; <br>&gt; An alternative would be allowing the operator declaration itself to specify whether it should be implemented as a static or instance operator.<br>&gt; <br>&gt; My primary concern is that there should only be one way to specify a protocol requirement for an individual operator.  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I expect the stdlib to illustrate what idiomatic Swift is expected to be, and people to follow suit for the standard operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is exactly what this proposal is attempting to do, and in a way that the language enforces the decision.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What benefit do you perceive in allowing operator instance methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The fact that operators like += are more naturally implemented as an instance method than as a static method is already a clear benefit to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you specifically thinking of assignment operators?  If so, I wouldn’t have a problem if the proposal specified assignment operators as instance methods and all other operators as static methods.  As long as there is only one way to define a specific operator requirement I will be happy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But in general, there aren&#39;t only the standard operators; people will define custom operators and will have different needs depending on their semantics. If there isn&#39;t a technical limitation, I don&#39;t see a reason to add arbitrary restrictions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no difference in capability here so I’m not sure what you mean by having different “needs”.<br>&gt;&gt; <br>&gt;&gt; By needs I mean choosing the representation that better fits the semantics of the operator.<br>&gt;&gt; For symmetrical binary operators, a static method is probably the best choice, but for other kinds of operators it might not be.<br>&gt; <br>&gt; Sure.  But if you want to go in that direction maybe it’s worthwhile to try and define general classes of operators for which each syntax fits better and require that syntax to be used.  I can see a case for doing this, but a lot of people will argue against it on grounds that it is inconsistent.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open to dropping the prefix/postfix keyword and making it an argument label instead, in both contexts.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names is for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a global operator and a named method, this proposal still allows that, since it&#39;s not deprecating all global operator definitions. A protocol could certainly have a requirement that is a named method, and provide a global generic operator that calls it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative uses of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose name is the same as a defined operator should conform to the requirements (such as argument count) of that operator. It&#39;s certainly worth discussion, though! With that being said, it may be easier on users to &quot;rule something out&quot; now and open it up later if need be, rather than to leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with the same name and different signature, which Swift allows without problems. Again, I think this is a choice that the author of the protocol should make, and there doesn&#39;t seem to be any technical reason to require otherwise.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make sense<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or even for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the worst<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/9a489c7b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 1:00 PM Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt; says<br>&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt; operators<br>&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;<br>&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt; global functions).<br>&gt;&gt;<br>&gt;<br>&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt; protocol operator syntax.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt; current<br>&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t agree with this.<br>&gt;<br>&gt; Operators are called like this:<br>&gt;<br>&gt; x = y + z<br>&gt;<br>&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;<br>&gt; But the ones inside the protocol are not operators. They are methods, and<br>&gt; are called like methods. They happen to have funny names, but they are<br>&gt; still methods, and are called like this:<br>&gt;<br>&gt; x = T.+(y, z)<br>&gt;<br>&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt; but making them behave differently from normal methods would be<br>&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt; in Swift 3 on that front.<br>&gt;<br></p><p>What I&#39;m saying is, if you look at the Swift 3 branch of stdlib, global<br>operator functions still do not have argument labels. Picking one at<br>random:<br>https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329<br></p><p>If you&#39;re arguing that those functions should be forced to include `_`<br>placeholders, that&#39;s fine, but it&#39;s not accurate to say that the way<br>they&#39;re written in this proposal is a step backwards from all the progress<br>made in Swift 3. It is *consistent* with the way global operator functions<br>are currently declared in Swift 3.<br></p><p>If it changes there, then it should change here as well. But they should be<br>the same, and making that change for global operator functions is not part<br>of the scope of this proposal.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt; // example.<br>&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt; other<br>&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is more similar to the global += operator definition, but is less clear<br>&gt;&gt;&gt; than:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt; would<br>&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt;&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt; is preferable.<br>&gt;&gt;<br>&gt;<br>&gt; I think this would better be left as a choice to the author of the<br>&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt; restriction.<br>&gt;<br></p><p>&gt;<br>&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open<br>&gt;&gt; to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt; instead, in both contexts.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt; cases where one would really want to use methods with operator names is<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt; generic operator that calls it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt; there<br>&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt; uses of<br>&gt;&gt;&gt; such names, which we would be ruling out for no particular reason. This<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt;&gt; name is the same as a defined operator should conform to the requirements<br>&gt;&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt;&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt;&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt;&gt; people to use and decide it needs to be closed later.<br>&gt;&gt;<br>&gt;<br>&gt; This doesn&#39;t seem different to me from having multiple functions with the<br>&gt; same name and different signature, which Swift allows without problems.<br>&gt; Again, I think this is a choice that the author of the protocol should<br>&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt; otherwise.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m<br>&gt;&gt;&gt; not<br>&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt;&gt; sense<br>&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt;&gt; etc.<br>&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt; declaring<br>&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt; global space to a type, but also from one type to another type, or even<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt; change to<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt;&gt; worst<br>&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading,<br>&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/639b5eab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 10:27 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br></p><p>&gt; On Wed, May 18, 2016 at 1:00 PM Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of<br>&gt;&gt;&gt;&gt; removing<br>&gt;&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt;&gt; says<br>&gt;&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt;&gt; operators<br>&gt;&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol<br>&gt;&gt;&gt;&gt; operators&quot;<br>&gt;&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt;&gt; global functions).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt;&gt; protocol operator syntax.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt;&gt; current<br>&gt;&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;<br>&gt;&gt; Operators are called like this:<br>&gt;&gt;<br>&gt;&gt; x = y + z<br>&gt;&gt;<br>&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;<br>&gt;&gt; But the ones inside the protocol are not operators. They are methods, and<br>&gt;&gt; are called like methods. They happen to have funny names, but they are<br>&gt;&gt; still methods, and are called like this:<br>&gt;&gt;<br>&gt;&gt; x = T.+(y, z)<br>&gt;&gt;<br>&gt;&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt;&gt; but making them behave differently from normal methods would be<br>&gt;&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt;&gt; in Swift 3 on that front.<br>&gt;&gt;<br>&gt;<br>&gt; What I&#39;m saying is, if you look at the Swift 3 branch of stdlib, global<br>&gt; operator functions still do not have argument labels. Picking one at<br>&gt; random:<br>&gt; https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329<br>&gt;<br>&gt; If you&#39;re arguing that those functions should be forced to include `_`<br>&gt; placeholders, that&#39;s fine, but it&#39;s not accurate to say that the way<br>&gt; they&#39;re written in this proposal is a step backwards from all the progress<br>&gt; made in Swift 3. It is *consistent* with the way global operator functions<br>&gt; are currently declared in Swift 3.<br>&gt;<br>&gt; If it changes there, then it should change here as well. But they should<br>&gt; be the same, and making that change for global operator functions is not<br>&gt; part of the scope of this proposal.<br>&gt;<br></p><p>I&#39;m not talking about the global operator functions; I&#39;m talking about the<br>methods inside the protocol, which are methods and are called like methods;<br>they are not operators.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need<br>&gt;&gt;&gt;&gt; to<br>&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less clear<br>&gt;&gt;&gt;&gt; than:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt;&gt;&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt; restriction.<br>&gt;&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open<br>&gt;&gt;&gt; to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the<br>&gt;&gt;&gt;&gt; dot<br>&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names is<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed<br>&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt;&gt; generic operator that calls it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason. This<br>&gt;&gt;&gt;&gt; is<br>&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt;&gt;&gt; name is the same as a defined operator should conform to the requirements<br>&gt;&gt;&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt;&gt;&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt;&gt;&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt;&gt;&gt; people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with the<br>&gt;&gt; same name and different signature, which Swift allows without problems.<br>&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt; otherwise.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m<br>&gt;&gt;&gt;&gt; not<br>&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt;&gt;&gt; sense<br>&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt;&gt;&gt; etc.<br>&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or even<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt;&gt;&gt; worst<br>&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads<br>&gt;&gt;&gt;&gt; on<br>&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/e4398c05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 3:37 PM, Nicola Salmoria via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Wed, May 18, 2016 at 10:27 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 1:00 PM Nicola Salmoria &lt;<br>&gt;&gt; nicola.salmoria at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of<br>&gt;&gt;&gt;&gt;&gt; removing<br>&gt;&gt;&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt;&gt;&gt; says<br>&gt;&gt;&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt;&gt;&gt; operators<br>&gt;&gt;&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol<br>&gt;&gt;&gt;&gt;&gt; operators&quot;<br>&gt;&gt;&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt;&gt;&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an<br>&gt;&gt;&gt;&gt;&gt; oversight.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt;&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt;&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt;&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt;&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt;&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt;&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt;&gt;&gt; global functions).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt;&gt;&gt; protocol operator syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt;&gt;&gt; current<br>&gt;&gt;&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt;&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt;&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt;&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Operators are called like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x = y + z<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But the ones inside the protocol are not operators. They are methods,<br>&gt;&gt;&gt; and are called like methods. They happen to have funny names, but they are<br>&gt;&gt;&gt; still methods, and are called like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x = T.+(y, z)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt;&gt;&gt; but making them behave differently from normal methods would be<br>&gt;&gt;&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt;&gt;&gt; in Swift 3 on that front.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What I&#39;m saying is, if you look at the Swift 3 branch of stdlib, global<br>&gt;&gt; operator functions still do not have argument labels. Picking one at<br>&gt;&gt; random:<br>&gt;&gt; https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329<br>&gt;&gt;<br>&gt;&gt; If you&#39;re arguing that those functions should be forced to include `_`<br>&gt;&gt; placeholders, that&#39;s fine, but it&#39;s not accurate to say that the way<br>&gt;&gt; they&#39;re written in this proposal is a step backwards from all the progress<br>&gt;&gt; made in Swift 3. It is *consistent* with the way global operator functions<br>&gt;&gt; are currently declared in Swift 3.<br>&gt;&gt;<br>&gt;&gt; If it changes there, then it should change here as well. But they should<br>&gt;&gt; be the same, and making that change for global operator functions is not<br>&gt;&gt; part of the scope of this proposal.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not talking about the global operator functions; I&#39;m talking about the<br>&gt; methods inside the protocol, which are methods and are called like methods;<br>&gt; they are not operators.<br>&gt;<br>&gt;<br>Thanks for expressing this so clearly. I&#39;m of the same feeling but fumbled<br>the communication of it.<br></p><p>On re-evaluation, I wonder if this proposal as it is would be a<br>sufficiently large improvement. It&#39;s essentially permitting the use of<br>characters reserved for operators in static method names, but it adds a set<br>of somewhat inconsistent rules for how those functions are to be declared<br>and called. As mentioned earlier, `T....(x, y)` looks rather unfortunate,<br>and since automatic trampolines are out of scope, I wonder if what we have<br>currently (naming static methods using words) is altogether that bad. Maybe<br>we could just standardize those names and be done with it; on a cursory<br>look, that seems to be Rust&#39;s approach.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just need<br>&gt;&gt;&gt;&gt;&gt; to<br>&gt;&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less<br>&gt;&gt;&gt;&gt;&gt; clear than:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for<br>&gt;&gt;&gt;&gt; consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt;&gt; restriction.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open<br>&gt;&gt;&gt;&gt; to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the<br>&gt;&gt;&gt;&gt;&gt; dot<br>&gt;&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names<br>&gt;&gt;&gt;&gt;&gt; is for<br>&gt;&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better expressed<br>&gt;&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt;&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt;&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt;&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt;&gt;&gt; generic operator that calls it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason.<br>&gt;&gt;&gt;&gt;&gt; This is<br>&gt;&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose<br>&gt;&gt;&gt;&gt; name is the same as a defined operator should conform to the requirements<br>&gt;&gt;&gt;&gt; (such as argument count) of that operator. It&#39;s certainly worth discussion,<br>&gt;&gt;&gt;&gt; though! With that being said, it may be easier on users to &quot;rule something<br>&gt;&gt;&gt;&gt; out&quot; now and open it up later if need be, rather than to leave it open for<br>&gt;&gt;&gt;&gt; people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with<br>&gt;&gt;&gt; the same name and different signature, which Swift allows without problems.<br>&gt;&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt;&gt; otherwise.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m<br>&gt;&gt;&gt;&gt;&gt; not<br>&gt;&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would make<br>&gt;&gt;&gt;&gt;&gt; sense<br>&gt;&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin, cos,<br>&gt;&gt;&gt;&gt;&gt; etc.<br>&gt;&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or<br>&gt;&gt;&gt;&gt;&gt; even for<br>&gt;&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of the<br>&gt;&gt;&gt;&gt;&gt; worst<br>&gt;&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much<br>&gt;&gt;&gt;&gt;&gt; less<br>&gt;&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads<br>&gt;&gt;&gt;&gt;&gt; on<br>&gt;&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/7cb9cd32/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:48 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 18, 2016 at 3:37 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Wed, May 18, 2016 at 10:27 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt; On Wed, May 18, 2016 at 1:00 PM Nicola Salmoria &lt;nicola.salmoria at gmail.com &lt;mailto:nicola.salmoria at gmail.com&gt;&gt; wrote:<br>&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I&#39;m generally in strong support, having long been a proponent of removing<br>&gt; operators from protocols (the first occurrence was in this thread:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7935&gt;)<br>&gt; <br>&gt; I have several comments about the details of the proposal, however.<br>&gt; <br>&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal says<br>&gt; &quot;This document does not propose that the current way of defining operators<br>&gt; be removed or changed at this time. Rather, we describe an addition that<br>&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt; <br>&gt; Later, however, there is a &quot;Deprecation of non-static protocol operators&quot;<br>&gt; section which suggest to do exactly that, and this is reiterated in the<br>&gt; &quot;Impact on existing code&quot; section.<br>&gt; <br>&gt; Since I think that the deprecation of global operator overloads is the<br>&gt; crucial point of the proposal, I assume that the former is an oversight.<br>&gt; <br>&gt; I could probably do a better job of clarifying the wording here. The proposal does *not* deprecate *all* global operator overloads. Global operators can still be implemented as they have been in Swift. So if you have a concrete type like `struct Matrix`, you can still define at the global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt; <br>&gt; What&#39;s being deprecated is the current syntax used to define operator requirements inside protocols (by making the functions static) and the manner by which subtypes conform (ditto, through static methods instead of global functions).<br>&gt; <br>&gt; OK, I guess the unclear part is when you talk about &quot;an addition that specifically provides improvements for protocol operator requirements.&quot; This is not just an addition; it&#39;s intended to completely replace the protocol operator syntax.<br>&gt; <br>&gt; <br>&gt; 2) The method signatures in the examples are not up to date with the current<br>&gt; Swift 3 syntax. For example:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; should be:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the syntax changes don&#39;t appear to apply to operator functions. Since they are a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to require them (or rather, the placeholders) here.<br>&gt; <br>&gt; I don&#39;t agree with this.<br>&gt; <br>&gt; Operators are called like this:<br>&gt; <br>&gt; x = y + z<br>&gt; <br>&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt; <br>&gt; But the ones inside the protocol are not operators. They are methods, and are called like methods. They happen to have funny names, but they are still methods, and are called like this:<br>&gt; <br>&gt; x = T.+(y, z)<br>&gt; <br>&gt; In this case not only it makes sense for the parameters to have labels, but making them behave differently from normal methods would be inconsistent, and a step backwards from all the progress that has been made in Swift 3 on that front.<br>&gt; <br>&gt; What I&#39;m saying is, if you look at the Swift 3 branch of stdlib, global operator functions still do not have argument labels. Picking one at random: https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329 &lt;https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329&gt;<br>&gt; <br>&gt; If you&#39;re arguing that those functions should be forced to include `_` placeholders, that&#39;s fine, but it&#39;s not accurate to say that the way they&#39;re written in this proposal is a step backwards from all the progress made in Swift 3. It is *consistent* with the way global operator functions are currently declared in Swift 3.<br>&gt; <br>&gt; If it changes there, then it should change here as well. But they should be the same, and making that change for global operator functions is not part of the scope of this proposal.<br>&gt; <br>&gt; I&#39;m not talking about the global operator functions; I&#39;m talking about the methods inside the protocol, which are methods and are called like methods; they are not operators.<br>&gt; <br>&gt; <br>&gt; Thanks for expressing this so clearly. I&#39;m of the same feeling but fumbled the communication of it.<br>&gt; <br>&gt; On re-evaluation, I wonder if this proposal as it is would be a sufficiently large improvement. It&#39;s essentially permitting the use of characters reserved for operators in static method names, but it adds a set of somewhat inconsistent rules for how those functions are to be declared and called. As mentioned earlier, `T....(x, y)` looks rather unfortunate, and since automatic trampolines are out of scope, I wonder if what we have currently (naming static methods using words) is altogether that bad. Maybe we could just standardize those names and be done with it; on a cursory look, that seems to be Rust&#39;s approach.<br></p><p>Personally, I find Rust’s approach a bit ugly.  And Tony makes a very good point in the proposal that using words requires us to learn the word associated with each operator.  <br></p><p>I noted some concerns about this proposal not including automatic trampolines.  However, if we are not going to be able to make a breaking change like this in the standard library after Swift 3 I do think it is important to give this proposal significant consideration even without them.  Automatic trampolines can be added later but we may not have the opportunity to fix the standard library protocols later.<br></p><p>&gt;  <br>&gt;  <br>&gt; <br>&gt;  <br>&gt;  <br>&gt; <br>&gt; <br>&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt; <br>&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt; // example.<br>&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt; <br>&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt; effectively just normal methods (apart from their names), we just need to<br>&gt; name the parameters accordingly:<br>&gt; <br>&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt; <br>&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt; operator implementations.<br>&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt; operators like += that seem to work better with members. That is, the<br>&gt; proposed declaration:<br>&gt; <br>&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt; <br>&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt; <br>&gt; mutating func +=(_ rhs: Self)<br>&gt; <br>&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt; need to do:<br>&gt; <br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;     T.+=(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; while with a member function this would read more naturally as:<br>&gt; <br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;     lhs.+=(rhs)<br>&gt; }<br>&gt; <br>&gt; I considered this, but eventually settled on &quot;everything is static&quot; for consistency. As you mention, there&#39;s a stronger argument to be made for assignment operators to have &quot;left hand side is the receiver&quot; semantics than there are for standard infix operators, but from a consistency point of view (and ease of learning), I think having everything static and the signatures of the static operators matching those of the global operators is preferable.<br>&gt; <br>&gt; I think this would better be left as a choice to the author of the protocol. There doesn&#39;t seem to be any technical reason to place this restriction.<br>&gt;  <br>&gt; (Which is also why, as I mentioned in a previous reply, I would be open to dropping the prefix/postfix keyword and making it an argument label instead, in both contexts.)<br>&gt;  <br>&gt; <br>&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt; This seems to be a real issue: I don&#39;t think<br>&gt; <br>&gt; return T....(minimum, maximum)<br>&gt; <br>&gt; looks any good, even if the compiler was able to parse it.<br>&gt; <br>&gt; However, this just means that the methods used to implement operators with<br>&gt; problematic names would need to use different names. Arguably, the only<br>&gt; cases where one would really want to use methods with operator names is for<br>&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt; methods with more significant names.<br>&gt; <br>&gt; If there is a strong case where an operator is better implemented as a global operator and a named method, this proposal still allows that, since it&#39;s not deprecating all global operator definitions. A protocol could certainly have a requirement that is a named method, and provide a global generic operator that calls it.<br>&gt;  <br>&gt; <br>&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt; are two cases, either the compiler can handle a method name that uses<br>&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt; won&#39;t help. If it can, why put limits? There could be other creative uses of<br>&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt; something that seems better left to the author of the protocol.<br>&gt; <br>&gt; IMO, to reduce potential confusion, I would argue that a function whose name is the same as a defined operator should conform to the requirements (such as argument count) of that operator. It&#39;s certainly worth discussion, though! With that being said, it may be easier on users to &quot;rule something out&quot; now and open it up later if need be, rather than to leave it open for people to use and decide it needs to be closed later.<br>&gt; <br>&gt; This doesn&#39;t seem different to me from having multiple functions with the same name and different signature, which Swift allows without problems. Again, I think this is a choice that the author of the protocol should make, and there doesn&#39;t seem to be any technical reason to require otherwise.<br>&gt;  <br>&gt; <br>&gt; <br>&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt; going to talk much about it, I only want to mention that it would make sense<br>&gt; to consider making such a feature as general as possible, instead of<br>&gt; focusing exclusively on operators.<br>&gt; <br>&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt; functions too.<br>&gt; It might even make sense to be able to create trampolines not only from<br>&gt; global space to a type, but also from one type to another type, or even for<br>&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt; <br>&gt; &gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; <br>&gt; Absolutely. The handling of operators in protocols has been one of the worst<br>&gt; pain points in my use of Swift.<br>&gt; <br>&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes; it significantly increases clarity and consistency.<br>&gt; <br>&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I only have experience with C++ operator overloading, which is much less<br>&gt; advanced.<br>&gt; <br>&gt; &gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt; <br>&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt; the mailing list.<br>&gt; <br>&gt; --<br>&gt; Nicola<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/ff4dd761/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 1:56 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Personally, I find Rust’s approach a bit ugly.  And Tony makes a very good<br>&gt; point in the proposal that using words requires us to learn the word<br>&gt; associated with each operator.<br>&gt;<br></p><p>Right—and in addition to the cognitive overload of knowing (and<br>remembering) the word associated with each operator, it introduced bloat in<br>those interfaces. End users of such an interface may question why there is<br>a named method for that operator, and whether the named method and the<br>operator function differently.<br></p><p>Likewise, in many cases (such as arithmetic operations), it seems contrived<br>to come up with names for an operator where that operator is already a term<br>of art that can express the idea better than the words can.<br></p><p><br>I noted some concerns about this proposal not including automatic<br>&gt; trampolines.  However, if we are not going to be able to make a breaking<br>&gt; change like this in the standard library after Swift 3 I do think it is<br>&gt; important to give this proposal significant consideration even without<br>&gt; them.  Automatic trampolines can be added later but we may not have the<br>&gt; opportunity to fix the standard library protocols later.<br>&gt;<br></p><p>I wish I had been able to keep automatic trampolines in—I thought it was<br>the &quot;killer feature&quot; that brings the whole proposal together. (Hey core<br>team, you can still change your mind! :)<br></p><p>That being said, I feel that the named-method approach is a huge step in<br>the wrong direction and this proposal is strong enough without them to<br>improve other existing ones, such as FloatingPoint, and would go a long way<br>toward cleaning up the language in other extremely common cases (like<br>anything that conforms to Equatable).<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols<br>&gt;&gt;&gt;&gt;&gt;&gt; are<br>&gt;&gt;&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just<br>&gt;&gt;&gt;&gt;&gt;&gt; need to<br>&gt;&gt;&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less<br>&gt;&gt;&gt;&gt;&gt;&gt; clear than:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot;<br>&gt;&gt;&gt;&gt;&gt; for consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt;&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt;&gt;&gt; restriction.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be<br>&gt;&gt;&gt;&gt;&gt; open to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the<br>&gt;&gt;&gt;&gt;&gt;&gt; dot<br>&gt;&gt;&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the<br>&gt;&gt;&gt;&gt;&gt;&gt; only<br>&gt;&gt;&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names<br>&gt;&gt;&gt;&gt;&gt;&gt; is for<br>&gt;&gt;&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better<br>&gt;&gt;&gt;&gt;&gt;&gt; expressed as<br>&gt;&gt;&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt;&gt;&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt;&gt;&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt;&gt;&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt;&gt;&gt;&gt; generic operator that calls it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator<br>&gt;&gt;&gt;&gt;&gt;&gt; name<br>&gt;&gt;&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason.<br>&gt;&gt;&gt;&gt;&gt;&gt; This is<br>&gt;&gt;&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function<br>&gt;&gt;&gt;&gt;&gt; whose name is the same as a defined operator should conform to the<br>&gt;&gt;&gt;&gt;&gt; requirements (such as argument count) of that operator. It&#39;s certainly<br>&gt;&gt;&gt;&gt;&gt; worth discussion, though! With that being said, it may be easier on users<br>&gt;&gt;&gt;&gt;&gt; to &quot;rule something out&quot; now and open it up later if need be, rather than to<br>&gt;&gt;&gt;&gt;&gt; leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with<br>&gt;&gt;&gt;&gt; the same name and different signature, which Swift allows without problems.<br>&gt;&gt;&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt;&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt;&gt;&gt; otherwise.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not<br>&gt;&gt;&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would<br>&gt;&gt;&gt;&gt;&gt;&gt; make sense<br>&gt;&gt;&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin,<br>&gt;&gt;&gt;&gt;&gt;&gt; cos, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only<br>&gt;&gt;&gt;&gt;&gt;&gt; from<br>&gt;&gt;&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or<br>&gt;&gt;&gt;&gt;&gt;&gt; even for<br>&gt;&gt;&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of<br>&gt;&gt;&gt;&gt;&gt;&gt; the worst<br>&gt;&gt;&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much<br>&gt;&gt;&gt;&gt;&gt;&gt; less<br>&gt;&gt;&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant<br>&gt;&gt;&gt;&gt;&gt;&gt; threads on<br>&gt;&gt;&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/75c7f23a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 4:06 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; On Wed, May 18, 2016 at 1:56 PM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Personally, I find Rust’s approach a bit ugly.  And Tony makes a very good point in the proposal that using words requires us to learn the word associated with each operator.  <br>&gt; <br>&gt; Right—and in addition to the cognitive overload of knowing (and remembering) the word associated with each operator, it introduced bloat in those interfaces. End users of such an interface may question why there is a named method for that operator, and whether the named method and the operator function differently.<br>&gt; <br>&gt; Likewise, in many cases (such as arithmetic operations), it seems contrived to come up with names for an operator where that operator is already a term of art that can express the idea better than the words can.<br>&gt; <br>&gt; <br>&gt; I noted some concerns about this proposal not including automatic trampolines.  However, if we are not going to be able to make a breaking change like this in the standard library after Swift 3 I do think it is important to give this proposal significant consideration even without them.  Automatic trampolines can be added later but we may not have the opportunity to fix the standard library protocols later.<br>&gt; <br>&gt; I wish I had been able to keep automatic trampolines in—I thought it was the &quot;killer feature&quot; that brings the whole proposal together. (Hey core team, you can still change your mind! :)<br>&gt; <br>&gt; That being said, I feel that the named-method approach is a huge step in the wrong direction and this proposal is strong enough without them to improve other existing ones, such as FloatingPoint, and would go a long way toward cleaning up the language in other extremely common cases (like anything that conforms to Equatable).<br></p><p>Tony (and core team), do you have any thoughts on the specific concerns I brought up?<br></p><p>Imagine this:<br></p><p>protocol P { <br>    static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>}<br>func ++++ &lt;T: P&gt;(lhs: T, rhs: T) -&gt; T {<br>    return T.++++(lhs, rhs)<br>}<br></p><p>protocol Q { <br>    static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>}<br>func ++++ &lt;T: Q&gt;(lhs: T, rhs: T) -&gt; T {<br>    return T.++++(lhs, rhs)<br>}<br></p><p>struct S: P, Q {<br>    static func ++++(lhs: Self, rhs: Self) -&gt; Self {<br>        // ...<br>    }<br>}<br></p><p>let s1 = S()<br>let s2 = S()<br>let s3 = s1 ++++ s2 // compiler error, both trampolines are an equally good match, resulting in ambiguity<br></p><p>// we have to add the following to resolve the ambiguity:<br></p><p>func ++++(lhs: S, rhs: S) -&gt; S {<br>    return S.++++(lhs, rhs)<br>}<br></p><p>You could argue that this is a contrived example and is unlikely to happen in real code.  My point is partly that it’s a regression from current state and partly that it is very likely to be confusing if people run into it.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt; <br>&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt; // example.<br>&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols are<br>&gt;&gt; effectively just normal methods (apart from their names), we just need to<br>&gt;&gt; name the parameters accordingly:<br>&gt;&gt; <br>&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt; operator implementations.<br>&gt;&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt; proposed declaration:<br>&gt;&gt; <br>&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt; <br>&gt;&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt;&gt; <br>&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt; <br>&gt;&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt;&gt; need to do:<br>&gt;&gt; <br>&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt; <br>&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot; for consistency. As you mention, there&#39;s a stronger argument to be made for assignment operators to have &quot;left hand side is the receiver&quot; semantics than there are for standard infix operators, but from a consistency point of view (and ease of learning), I think having everything static and the signatures of the static operators matching those of the global operators is preferable.<br>&gt;&gt; <br>&gt;&gt; I think this would better be left as a choice to the author of the protocol. There doesn&#39;t seem to be any technical reason to place this restriction.<br>&gt;&gt;  <br>&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be open to dropping the prefix/postfix keyword and making it an argument label instead, in both contexts.)<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt; <br>&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt; <br>&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt; <br>&gt;&gt; However, this just means that the methods used to implement operators with<br>&gt;&gt; problematic names would need to use different names. Arguably, the only<br>&gt;&gt; cases where one would really want to use methods with operator names is for<br>&gt;&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt;&gt; methods with more significant names.<br>&gt;&gt; <br>&gt;&gt; If there is a strong case where an operator is better implemented as a global operator and a named method, this proposal still allows that, since it&#39;s not deprecating all global operator definitions. A protocol could certainly have a requirement that is a named method, and provide a global generic operator that calls it.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say there<br>&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator name<br>&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative uses of<br>&gt;&gt; such names, which we would be ruling out for no particular reason. This is<br>&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt; <br>&gt;&gt; IMO, to reduce potential confusion, I would argue that a function whose name is the same as a defined operator should conform to the requirements (such as argument count) of that operator. It&#39;s certainly worth discussion, though! With that being said, it may be easier on users to &quot;rule something out&quot; now and open it up later if need be, rather than to leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with the same name and different signature, which Swift allows without problems. Again, I think this is a choice that the author of the protocol should make, and there doesn&#39;t seem to be any technical reason to require otherwise.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so I&#39;m not<br>&gt;&gt; going to talk much about it, I only want to mention that it would make sense<br>&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt; focusing exclusively on operators.<br>&gt;&gt; <br>&gt;&gt; For example, think of the common mathematical functions like sin, cos, etc.<br>&gt;&gt; It could make sense to give them the same treatment as operators, declaring<br>&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt; functions too.<br>&gt;&gt; It might even make sense to be able to create trampolines not only from<br>&gt;&gt; global space to a type, but also from one type to another type, or even for<br>&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt; <br>&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt; Swift?<br>&gt;&gt; <br>&gt;&gt; Absolutely. The handling of operators in protocols has been one of the worst<br>&gt;&gt; pain points in my use of Swift.<br>&gt;&gt; <br>&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt; <br>&gt;&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I only have experience with C++ operator overloading, which is much less<br>&gt;&gt; advanced.<br>&gt;&gt; <br>&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt; or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; An in-depth study of the proposal, and I read all the relevant threads on<br>&gt;&gt; the mailing list.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Nicola<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/7bcf0952/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 2:20 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On May 18, 2016, at 4:06 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;<br>&gt; On Wed, May 18, 2016 at 1:56 PM Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Personally, I find Rust’s approach a bit ugly.  And Tony makes a very<br>&gt;&gt; good point in the proposal that using words requires us to learn the word<br>&gt;&gt; associated with each operator.<br>&gt;&gt;<br>&gt;<br>&gt; Right—and in addition to the cognitive overload of knowing (and<br>&gt; remembering) the word associated with each operator, it introduced bloat in<br>&gt; those interfaces. End users of such an interface may question why there is<br>&gt; a named method for that operator, and whether the named method and the<br>&gt; operator function differently.<br>&gt;<br>&gt; Likewise, in many cases (such as arithmetic operations), it seems<br>&gt; contrived to come up with names for an operator where that operator is<br>&gt; already a term of art that can express the idea better than the words can.<br>&gt;<br>&gt;<br>&gt; I noted some concerns about this proposal not including automatic<br>&gt;&gt; trampolines.  However, if we are not going to be able to make a breaking<br>&gt;&gt; change like this in the standard library after Swift 3 I do think it is<br>&gt;&gt; important to give this proposal significant consideration even without<br>&gt;&gt; them.  Automatic trampolines can be added later but we may not have the<br>&gt;&gt; opportunity to fix the standard library protocols later.<br>&gt;&gt;<br>&gt;<br>&gt; I wish I had been able to keep automatic trampolines in—I thought it was<br>&gt; the &quot;killer feature&quot; that brings the whole proposal together. (Hey core<br>&gt; team, you can still change your mind! :)<br>&gt;<br>&gt; That being said, I feel that the named-method approach is a huge step in<br>&gt; the wrong direction and this proposal is strong enough without them to<br>&gt; improve other existing ones, such as FloatingPoint, and would go a long way<br>&gt; toward cleaning up the language in other extremely common cases (like<br>&gt; anything that conforms to Equatable).<br>&gt;<br>&gt;<br>&gt; Tony (and core team), do you have any thoughts on the specific concerns I<br>&gt; brought up?<br>&gt;<br></p><p>&gt; Imagine this:<br>&gt;<br>&gt; protocol P {<br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; func ++++ &lt;T: P&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;     return T.++++(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; protocol Q {<br>&gt;<br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; func ++++ &lt;T: Q&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;     return T.++++(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; struct S: P, Q {<br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self {<br>&gt;         // ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let s1 = S()<br>&gt; let s2 = S()<br>&gt; let s3 = s1 ++++ s2 // compiler error, both trampolines are an equally<br>&gt; good match, resulting in ambiguity<br>&gt;<br>&gt; // we have to add the following to resolve the ambiguity:<br>&gt;<br>&gt; func ++++(lhs: S, rhs: S) -&gt; S {<br>&gt;     return S.++++(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; You could argue that this is a contrived example and is unlikely to happen<br>&gt; in real code.  My point is partly that it’s a regression from current state<br>&gt; and partly that it is very likely to be confusing if people run into it.<br>&gt;<br></p><p>Agreed. Your suggestion of explicitly clarifying it on the concrete type is<br>the most obvious one I can think of, as well. I&#39;d be interested in the core<br>team&#39;s thoughts as well—I&#39;m inclined to say that since it&#39;s likely to be<br>rare, and since the more specific global operator lets us escape through a<br>trap door, it&#39;s acceptable, even though I have to acknowledge that it&#39;s not<br>ideal and I&#39;m not 100% happy with that.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; clear than:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; for consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt;&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt;&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt;&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt;&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt;&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt;&gt;&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt;&gt;&gt;&gt; restriction.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be<br>&gt;&gt;&gt;&gt;&gt;&gt; open to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt;&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, this just means that the methods used to implement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operators with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; If there is a strong case where an operator is better implemented as<br>&gt;&gt;&gt;&gt;&gt;&gt; a global operator and a named method, this proposal still allows that,<br>&gt;&gt;&gt;&gt;&gt;&gt; since it&#39;s not deprecating all global operator definitions. A protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; could certainly have a requirement that is a named method, and provide a<br>&gt;&gt;&gt;&gt;&gt;&gt; global generic operator that calls it.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; name<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function<br>&gt;&gt;&gt;&gt;&gt;&gt; whose name is the same as a defined operator should conform to the<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements (such as argument count) of that operator. It&#39;s certainly<br>&gt;&gt;&gt;&gt;&gt;&gt; worth discussion, though! With that being said, it may be easier on users<br>&gt;&gt;&gt;&gt;&gt;&gt; to &quot;rule something out&quot; now and open it up later if need be, rather than to<br>&gt;&gt;&gt;&gt;&gt;&gt; leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with<br>&gt;&gt;&gt;&gt;&gt; the same name and different signature, which Swift allows without problems.<br>&gt;&gt;&gt;&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt;&gt;&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt;&gt;&gt;&gt; otherwise.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; make sense<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; cos, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; even for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the worst<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; threads on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/387b8ebf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 25, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 18.05.2016 um 23:20 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 4:06 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, May 18, 2016 at 1:56 PM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I find Rust’s approach a bit ugly.  And Tony makes a very good point in the proposal that using words requires us to learn the word associated with each operator.  <br>&gt;&gt; <br>&gt;&gt; Right—and in addition to the cognitive overload of knowing (and remembering) the word associated with each operator, it introduced bloat in those interfaces. End users of such an interface may question why there is a named method for that operator, and whether the named method and the operator function differently.<br>&gt;&gt; <br>&gt;&gt; Likewise, in many cases (such as arithmetic operations), it seems contrived to come up with names for an operator where that operator is already a term of art that can express the idea better than the words can.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I noted some concerns about this proposal not including automatic trampolines.  However, if we are not going to be able to make a breaking change like this in the standard library after Swift 3 I do think it is important to give this proposal significant consideration even without them.  Automatic trampolines can be added later but we may not have the opportunity to fix the standard library protocols later.<br>&gt;&gt; <br>&gt;&gt; I wish I had been able to keep automatic trampolines in—I thought it was the &quot;killer feature&quot; that brings the whole proposal together. (Hey core team, you can still change your mind! :)<br>&gt;&gt; <br>&gt;&gt; That being said, I feel that the named-method approach is a huge step in the wrong direction and this proposal is strong enough without them to improve other existing ones, such as FloatingPoint, and would go a long way toward cleaning up the language in other extremely common cases (like anything that conforms to Equatable).<br>&gt; <br>&gt; Tony (and core team), do you have any thoughts on the specific concerns I brought up?<br>&gt; <br>&gt; Imagine this:<br>&gt; <br>&gt; protocol P { <br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; func ++++ &lt;T: P&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;     return T.++++(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; protocol Q { <br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; func ++++ &lt;T: Q&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;     return T.++++(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; struct S: P, Q {<br>&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self {<br>&gt;         // ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let s1 = S()<br>&gt; let s2 = S()<br>&gt; let s3 = s1 ++++ s2 // compiler error, both trampolines are an equally good match, resulting in ambiguity<br>&gt; <br>&gt; // we have to add the following to resolve the ambiguity:<br>&gt; <br>&gt; func ++++(lhs: S, rhs: S) -&gt; S {<br>&gt;     return S.++++(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; You could argue that this is a contrived example and is unlikely to happen in real code.  My point is partly that it’s a regression from current state and partly that it is very likely to be confusing if people run into it.<br></p><p>Actually I don&#39;t think this is a regression, it points to a deeper problem which already exists without the proposal and which is actually improved for the case you mentioned!<br></p><p>When S conforms to P and Q which define different operators (semantically different) which share the same name, this is a name clash which should be resolved properly. Currently Swift is missing the means for that in general cases like methods with the same name. I wrote how Eiffel does this in a different thread quite some time ago. In your specific example this problem *can* actually be resolved which is a good thing!<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/6ac03097/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:18 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 18.05.2016 um 23:20 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 4:06 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 1:56 PM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally, I find Rust’s approach a bit ugly.  And Tony makes a very good point in the proposal that using words requires us to learn the word associated with each operator.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right—and in addition to the cognitive overload of knowing (and remembering) the word associated with each operator, it introduced bloat in those interfaces. End users of such an interface may question why there is a named method for that operator, and whether the named method and the operator function differently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise, in many cases (such as arithmetic operations), it seems contrived to come up with names for an operator where that operator is already a term of art that can express the idea better than the words can.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I noted some concerns about this proposal not including automatic trampolines.  However, if we are not going to be able to make a breaking change like this in the standard library after Swift 3 I do think it is important to give this proposal significant consideration even without them.  Automatic trampolines can be added later but we may not have the opportunity to fix the standard library protocols later.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wish I had been able to keep automatic trampolines in—I thought it was the &quot;killer feature&quot; that brings the whole proposal together. (Hey core team, you can still change your mind! :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said, I feel that the named-method approach is a huge step in the wrong direction and this proposal is strong enough without them to improve other existing ones, such as FloatingPoint, and would go a long way toward cleaning up the language in other extremely common cases (like anything that conforms to Equatable).<br>&gt;&gt; <br>&gt;&gt; Tony (and core team), do you have any thoughts on the specific concerns I brought up?<br>&gt;&gt; <br>&gt;&gt; Imagine this:<br>&gt;&gt; <br>&gt;&gt; protocol P { <br>&gt;&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; func ++++ &lt;T: P&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;&gt;     return T.++++(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q { <br>&gt;&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; func ++++ &lt;T: Q&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;&gt;     return T.++++(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P, Q {<br>&gt;&gt;     static func ++++(lhs: Self, rhs: Self) -&gt; Self {<br>&gt;&gt;         // ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let s1 = S()<br>&gt;&gt; let s2 = S()<br>&gt;&gt; let s3 = s1 ++++ s2 // compiler error, both trampolines are an equally good match, resulting in ambiguity<br>&gt;&gt; <br>&gt;&gt; // we have to add the following to resolve the ambiguity:<br>&gt;&gt; <br>&gt;&gt; func ++++(lhs: S, rhs: S) -&gt; S {<br>&gt;&gt;     return S.++++(lhs, rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You could argue that this is a contrived example and is unlikely to happen in real code.  My point is partly that it’s a regression from current state and partly that it is very likely to be confusing if people run into it.<br>&gt; <br>&gt; Actually I don&#39;t think this is a regression, it points to a deeper problem which already exists without the proposal and which is actually improved for the case you mentioned!<br>&gt; <br>&gt; When S conforms to P and Q which define different operators (semantically different) which share the same name, this is a name clash which should be resolved properly. Currently Swift is missing the means for that in general cases like methods with the same name. I wrote how Eiffel does this in a different thread quite some time ago. In your specific example this problem *can* actually be resolved which is a good thing!<br></p><p>I agree that you should have the ability to resolve the name clash of so desired.  But it&#39;s also possible that your implementation is suitable for both protocols.   For example, maybe they come from different modules that both define similar protocols and you conform to both to interoperate with them.<br></p><p>&gt; <br>&gt; -Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/cb470ba7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 3:56 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 18, 2016, at 3:48 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, May 18, 2016 at 3:37 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, May 18, 2016 at 10:27 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Wed, May 18, 2016 at 1:00 PM Nicola Salmoria &lt;<br>&gt;&gt;&gt; nicola.salmoria at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 8:03 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, May 18, 2016 at 10:02 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m generally in strong support, having long been a proponent of<br>&gt;&gt;&gt;&gt;&gt;&gt; removing<br>&gt;&gt;&gt;&gt;&gt;&gt; operators from protocols (the first occurrence was in this thread:<br>&gt;&gt;&gt;&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/7935)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I have several comments about the details of the proposal, however.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 1) At the beginning, in the &quot;Proposed solution&quot; section, the proposal<br>&gt;&gt;&gt;&gt;&gt;&gt; says<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;This document does not propose that the current way of defining<br>&gt;&gt;&gt;&gt;&gt;&gt; operators<br>&gt;&gt;&gt;&gt;&gt;&gt; be removed or changed at this time. Rather, we describe an addition<br>&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Later, however, there is a &quot;Deprecation of non-static protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; operators&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; section which suggest to do exactly that, and this is reiterated in<br>&gt;&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Impact on existing code&quot; section.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Since I think that the deprecation of global operator overloads is the<br>&gt;&gt;&gt;&gt;&gt;&gt; crucial point of the proposal, I assume that the former is an<br>&gt;&gt;&gt;&gt;&gt;&gt; oversight.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I could probably do a better job of clarifying the wording here. The<br>&gt;&gt;&gt;&gt;&gt; proposal does *not* deprecate *all* global operator overloads. Global<br>&gt;&gt;&gt;&gt;&gt; operators can still be implemented as they have been in Swift. So if you<br>&gt;&gt;&gt;&gt;&gt; have a concrete type like `struct Matrix`, you can still define at the<br>&gt;&gt;&gt;&gt;&gt; global level `func +(lhs: Matrix, rhs: Matrix) -&gt; Matrix`.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What&#39;s being deprecated is the current syntax used to define operator<br>&gt;&gt;&gt;&gt;&gt; requirements inside protocols (by making the functions static) and the<br>&gt;&gt;&gt;&gt;&gt; manner by which subtypes conform (ditto, through static methods instead of<br>&gt;&gt;&gt;&gt;&gt; global functions).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; OK, I guess the unclear part is when you talk about &quot;an addition that<br>&gt;&gt;&gt;&gt; specifically provides improvements for protocol operator requirements.&quot;<br>&gt;&gt;&gt;&gt; This is not just an addition; it&#39;s intended to completely replace the<br>&gt;&gt;&gt;&gt; protocol operator syntax.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) The method signatures in the examples are not up to date with the<br>&gt;&gt;&gt;&gt;&gt;&gt; current<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift 3 syntax. For example:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; should be:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;&gt;   static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Unless I&#39;m mistaken, from looking at the Swift 3 branch of stdlib, the<br>&gt;&gt;&gt;&gt;&gt; syntax changes don&#39;t appear to apply to operator functions. Since they are<br>&gt;&gt;&gt;&gt;&gt; a special case that don&#39;t have argument labels, it wouldn&#39;t make sense to<br>&gt;&gt;&gt;&gt;&gt; require them (or rather, the placeholders) here.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t agree with this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Operators are called like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; x = y + z<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Of course it doesn&#39;t make sense to have parameter labels there.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But the ones inside the protocol are not operators. They are methods,<br>&gt;&gt;&gt;&gt; and are called like methods. They happen to have funny names, but they are<br>&gt;&gt;&gt;&gt; still methods, and are called like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; x = T.+(y, z)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In this case not only it makes sense for the parameters to have labels,<br>&gt;&gt;&gt;&gt; but making them behave differently from normal methods would be<br>&gt;&gt;&gt;&gt; inconsistent, and a step backwards from all the progress that has been made<br>&gt;&gt;&gt;&gt; in Swift 3 on that front.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What I&#39;m saying is, if you look at the Swift 3 branch of stdlib, global<br>&gt;&gt;&gt; operator functions still do not have argument labels. Picking one at<br>&gt;&gt;&gt; random:<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you&#39;re arguing that those functions should be forced to include `_`<br>&gt;&gt;&gt; placeholders, that&#39;s fine, but it&#39;s not accurate to say that the way<br>&gt;&gt;&gt; they&#39;re written in this proposal is a step backwards from all the progress<br>&gt;&gt;&gt; made in Swift 3. It is *consistent* with the way global operator functions<br>&gt;&gt;&gt; are currently declared in Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If it changes there, then it should change here as well. But they should<br>&gt;&gt;&gt; be the same, and making that change for global operator functions is not<br>&gt;&gt;&gt; part of the scope of this proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not talking about the global operator functions; I&#39;m talking about<br>&gt;&gt; the methods inside the protocol, which are methods and are called like<br>&gt;&gt; methods; they are not operators.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Thanks for expressing this so clearly. I&#39;m of the same feeling but fumbled<br>&gt; the communication of it.<br>&gt;<br>&gt; On re-evaluation, I wonder if this proposal as it is would be a<br>&gt; sufficiently large improvement. It&#39;s essentially permitting the use of<br>&gt; characters reserved for operators in static method names, but it adds a set<br>&gt; of somewhat inconsistent rules for how those functions are to be declared<br>&gt; and called. As mentioned earlier, `T....(x, y)` looks rather unfortunate,<br>&gt; and since automatic trampolines are out of scope, I wonder if what we have<br>&gt; currently (naming static methods using words) is altogether that bad. Maybe<br>&gt; we could just standardize those names and be done with it; on a cursory<br>&gt; look, that seems to be Rust&#39;s approach.<br>&gt;<br>&gt;<br>&gt; Personally, I find Rust’s approach a bit ugly.  And Tony makes a very good<br>&gt; point in the proposal that using words requires us to learn the word<br>&gt; associated with each operator.<br>&gt;<br></p><p>Yeah, also good points. Can I propose maybe another approach?<br></p><p>```<br>T.operator(+, a, b)<br>T.operator(prefix: ++, a)<br>T.operator(postfix: ++, a)<br>```<br></p><p><br>&gt; I noted some concerns about this proposal not including automatic<br>&gt; trampolines.  However, if we are not going to be able to make a breaking<br>&gt; change like this in the standard library after Swift 3 I do think it is<br>&gt; important to give this proposal significant consideration even without<br>&gt; them.  Automatic trampolines can be added later but we may not have the<br>&gt; opportunity to fix the standard library protocols later.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) As has already been noted by many others, the suggested syntax for<br>&gt;&gt;&gt;&gt;&gt;&gt; prefix/postfix operators is overcomplicated. The proposal is:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // These are deprecated, of course, but used here just to serve as an<br>&gt;&gt;&gt;&gt;&gt;&gt; // example.<br>&gt;&gt;&gt;&gt;&gt;&gt; static prefix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; static postfix func ++(_ value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t need that. Since the &#39;operators&#39; declared inside protocols<br>&gt;&gt;&gt;&gt;&gt;&gt; are<br>&gt;&gt;&gt;&gt;&gt;&gt; effectively just normal methods (apart from their names), we just<br>&gt;&gt;&gt;&gt;&gt;&gt; need to<br>&gt;&gt;&gt;&gt;&gt;&gt; name the parameters accordingly:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; static func ++(prefix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; static func ++(postfix value: inout Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt;&gt;&gt;&gt;&gt;&gt; operator implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt; I support this for symmetrical binary operators like +, but there are<br>&gt;&gt;&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt;&gt;&gt; operators like += that seem to work better with members. That is, the<br>&gt;&gt;&gt;&gt;&gt;&gt; proposed declaration:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; is more similar to the global += operator definition, but is less<br>&gt;&gt;&gt;&gt;&gt;&gt; clear than:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func +=(_ rhs: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; this is apparent also at the call site. With the proposed syntax, one<br>&gt;&gt;&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt;&gt;&gt; need to do:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     T.+=(lhs, rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; while with a member function this would read more naturally as:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     lhs.+=(rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I considered this, but eventually settled on &quot;everything is static&quot;<br>&gt;&gt;&gt;&gt;&gt; for consistency. As you mention, there&#39;s a stronger argument to be made for<br>&gt;&gt;&gt;&gt;&gt; assignment operators to have &quot;left hand side is the receiver&quot; semantics<br>&gt;&gt;&gt;&gt;&gt; than there are for standard infix operators, but from a consistency point<br>&gt;&gt;&gt;&gt;&gt; of view (and ease of learning), I think having everything static and the<br>&gt;&gt;&gt;&gt;&gt; signatures of the static operators matching those of the global operators<br>&gt;&gt;&gt;&gt;&gt; is preferable.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think this would better be left as a choice to the author of the<br>&gt;&gt;&gt;&gt; protocol. There doesn&#39;t seem to be any technical reason to place this<br>&gt;&gt;&gt;&gt; restriction.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; (Which is also why, as I mentioned in a previous reply, I would be<br>&gt;&gt;&gt;&gt;&gt; open to dropping the prefix/postfix keyword and making it an argument label<br>&gt;&gt;&gt;&gt;&gt; instead, in both contexts.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 5) the proposal mentions the open question of ambiguities between the<br>&gt;&gt;&gt;&gt;&gt;&gt; dot<br>&gt;&gt;&gt;&gt;&gt;&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt;&gt;&gt;&gt;&gt;&gt; This seems to be a real issue: I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; return T....(minimum, maximum)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; looks any good, even if the compiler was able to parse it.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; However, this just means that the methods used to implement operators<br>&gt;&gt;&gt;&gt;&gt;&gt; with<br>&gt;&gt;&gt;&gt;&gt;&gt; problematic names would need to use different names. Arguably, the<br>&gt;&gt;&gt;&gt;&gt;&gt; only<br>&gt;&gt;&gt;&gt;&gt;&gt; cases where one would really want to use methods with operator names<br>&gt;&gt;&gt;&gt;&gt;&gt; is for<br>&gt;&gt;&gt;&gt;&gt;&gt; arithmetical operators. Custom operators like ... are better<br>&gt;&gt;&gt;&gt;&gt;&gt; expressed as<br>&gt;&gt;&gt;&gt;&gt;&gt; methods with more significant names.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If there is a strong case where an operator is better implemented as a<br>&gt;&gt;&gt;&gt;&gt; global operator and a named method, this proposal still allows that, since<br>&gt;&gt;&gt;&gt;&gt; it&#39;s not deprecating all global operator definitions. A protocol could<br>&gt;&gt;&gt;&gt;&gt; certainly have a requirement that is a named method, and provide a global<br>&gt;&gt;&gt;&gt;&gt; generic operator that calls it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 6) It seems somewhat arbitrary to restrict method names to match an<br>&gt;&gt;&gt;&gt;&gt;&gt; operator, nor to put requirements on the function signature. I&#39;d say<br>&gt;&gt;&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt;&gt; are two cases, either the compiler can handle a method name that uses<br>&gt;&gt;&gt;&gt;&gt;&gt; special characters, or it can&#39;t. If it can&#39;t, matching an operator<br>&gt;&gt;&gt;&gt;&gt;&gt; name<br>&gt;&gt;&gt;&gt;&gt;&gt; won&#39;t help. If it can, why put limits? There could be other creative<br>&gt;&gt;&gt;&gt;&gt;&gt; uses of<br>&gt;&gt;&gt;&gt;&gt;&gt; such names, which we would be ruling out for no particular reason.<br>&gt;&gt;&gt;&gt;&gt;&gt; This is<br>&gt;&gt;&gt;&gt;&gt;&gt; something that seems better left to the author of the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; IMO, to reduce potential confusion, I would argue that a function<br>&gt;&gt;&gt;&gt;&gt; whose name is the same as a defined operator should conform to the<br>&gt;&gt;&gt;&gt;&gt; requirements (such as argument count) of that operator. It&#39;s certainly<br>&gt;&gt;&gt;&gt;&gt; worth discussion, though! With that being said, it may be easier on users<br>&gt;&gt;&gt;&gt;&gt; to &quot;rule something out&quot; now and open it up later if need be, rather than to<br>&gt;&gt;&gt;&gt;&gt; leave it open for people to use and decide it needs to be closed later.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This doesn&#39;t seem different to me from having multiple functions with<br>&gt;&gt;&gt;&gt; the same name and different signature, which Swift allows without problems.<br>&gt;&gt;&gt;&gt; Again, I think this is a choice that the author of the protocol should<br>&gt;&gt;&gt;&gt; make, and there doesn&#39;t seem to be any technical reason to require<br>&gt;&gt;&gt;&gt; otherwise.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 7) Automatic generation of trampoline functions is out of scope so<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not<br>&gt;&gt;&gt;&gt;&gt;&gt; going to talk much about it, I only want to mention that it would<br>&gt;&gt;&gt;&gt;&gt;&gt; make sense<br>&gt;&gt;&gt;&gt;&gt;&gt; to consider making such a feature as general as possible, instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; focusing exclusively on operators.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, think of the common mathematical functions like sin,<br>&gt;&gt;&gt;&gt;&gt;&gt; cos, etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to give them the same treatment as operators,<br>&gt;&gt;&gt;&gt;&gt;&gt; declaring<br>&gt;&gt;&gt;&gt;&gt;&gt; them as part of the FloatingPoint protocol but preserving the global<br>&gt;&gt;&gt;&gt;&gt;&gt; functions too.<br>&gt;&gt;&gt;&gt;&gt;&gt; It might even make sense to be able to create trampolines not only<br>&gt;&gt;&gt;&gt;&gt;&gt; from<br>&gt;&gt;&gt;&gt;&gt;&gt; global space to a type, but also from one type to another type, or<br>&gt;&gt;&gt;&gt;&gt;&gt; even for<br>&gt;&gt;&gt;&gt;&gt;&gt; all methods of a type (e.g. when boxing a value inside another type).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt; change to<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Absolutely. The handling of operators in protocols has been one of<br>&gt;&gt;&gt;&gt;&gt;&gt; the worst<br>&gt;&gt;&gt;&gt;&gt;&gt; pain points in my use of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yes; it significantly increases clarity and consistency.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt; feature,<br>&gt;&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I only have experience with C++ operator overloading, which is much<br>&gt;&gt;&gt;&gt;&gt;&gt; less<br>&gt;&gt;&gt;&gt;&gt;&gt; advanced.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt; reading,<br>&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; An in-depth study of the proposal, and I read all the relevant<br>&gt;&gt;&gt;&gt;&gt;&gt; threads on<br>&gt;&gt;&gt;&gt;&gt;&gt; the mailing list.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/17a13403/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 18 mai 2016, at 15:09, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Yeah, also good points. Can I propose maybe another approach?<br>&gt; <br>&gt; ```<br>&gt; T.operator(+, a, b)<br>&gt; T.operator(prefix: ++, a)<br>&gt; T.operator(postfix: ++, a)<br>&gt; ```<br></p><p>I like that this applies the “postfix” or “prefix” labels to what they qualify: the operator.<br>The original proposal applies them to the parameter, which makes my head spin.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, May 18, 2016 at 1:37 PM Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Wed, May 18, 2016 at 10:27 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; What I&#39;m saying is, if you look at the Swift 3 branch of stdlib, global<br>&gt;&gt; operator functions still do not have argument labels. Picking one at<br>&gt;&gt; random:<br>&gt;&gt; https://github.com/apple/swift/blob/swift-3.0-branch/stdlib/public/core/String.swift#L329<br>&gt;&gt;<br>&gt;&gt; If you&#39;re arguing that those functions should be forced to include `_`<br>&gt;&gt; placeholders, that&#39;s fine, but it&#39;s not accurate to say that the way<br>&gt;&gt; they&#39;re written in this proposal is a step backwards from all the progress<br>&gt;&gt; made in Swift 3. It is *consistent* with the way global operator functions<br>&gt;&gt; are currently declared in Swift 3.<br>&gt;&gt;<br>&gt;&gt; If it changes there, then it should change here as well. But they should<br>&gt;&gt; be the same, and making that change for global operator functions is not<br>&gt;&gt; part of the scope of this proposal.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not talking about the global operator functions; I&#39;m talking about the<br>&gt; methods inside the protocol, which are methods and are called like methods;<br>&gt; they are not operators.<br>&gt;<br></p><p>They&#39;re methods that have names that are operators, so the proposal treats<br>them like other functions that have names that are operators.<br></p><p>In Swift 3, there are two types of global functions:<br>1) Functions with names that are not operators, which have mandatory<br>argument labels; e.g., `func abs(_ x: Int)`<br>2) Functions with names that are operators, which mandatorily *lack*<br>argument labels; e.g., `func +(lhs: Int, rhs: Int)`<br></p><p>Static methods are just functions that are attached to a class type; why<br>introduce more inconsistency by requiring labels on them as methods but not<br>as global functions? This way, an operator as a static requirement of a<br>protocol looks just like the global operator that matches it.<br></p><p>Similarly, if you pass a bare operator into another algorithm (like<br>`reduce`), you call it without any argument labels, so there are already<br>situations where calling an operator in that way (even though it&#39;s<br>indirect) omits the labels.<br></p><p>I can&#39;t entirely disagree that there is inconsistency here; but IMO the<br>inconsistency is with operator functions *in general* lacking labels, not<br>with the treatment of them proposed here.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/dedd2459/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0091: Improving operator requirements in protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;]<br></p><p>Some comments on Nicola’s points (my own comments to come separately):<br></p><p>&gt; <br>&gt; 2) The method signatures in the examples are not up to date with the current<br>&gt; Swift 3 syntax. For example:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;  static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; should be:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;  static func ==(_ lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br></p><p><br>Operator functions (and subscript indexes) implicitly have no argument labels today, so this isn’t technically wrong. You can see that there are no labels when you use the functions like, well, functions:<br></p><p>func test(input: Int) { print(input) }<br>(test)(2) // error: missing argument label &#39;input:&#39; in call<br>(+)(2, 3) // okay<br></p><p>It may be worth changing, though.<br></p><p>&gt; <br>&gt; 4) I don&#39;t agree with the request to limit to static methods for the<br>&gt; operator implementations.<br>&gt; I support this for symmetrical binary operators like +, but there are other<br>&gt; operators like += that seem to work better with members. That is, the<br>&gt; proposed declaration:<br>&gt; <br>&gt; static func +=(_ lhs: inout Self, _ rhs: Self)<br>&gt; <br>&gt; is more similar to the global += operator definition, but is less clear than:<br>&gt; <br>&gt; mutating func +=(_ rhs: Self)<br>&gt; <br>&gt; this is apparent also at the call site. With the proposed syntax, one would<br>&gt; need to do:<br>&gt; <br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;    T.+=(lhs, rhs)<br>&gt; }<br>&gt; <br>&gt; while with a member function this would read more naturally as:<br>&gt; <br>&gt; func +=&lt;T: Foo&gt;(_ lhs: inout T, _ rhs: T) {<br>&gt;    lhs.+=(rhs)<br>&gt; }<br></p><p>I strongly agree with this for assignment operators, and I also think it’s important for things that make sense to override in a subclass. However, it then puts prefix and postfix operators right back in the space of needing a keyword instead of using argument label.<br></p><p><br>&gt; <br>&gt; 5) the proposal mentions the open question of ambiguities between the dot<br>&gt; syntax to access methods and operators whose name starts with a dot.<br>&gt; This seems to be a real issue: I don&#39;t think<br>&gt; <br>&gt; return T....(minimum, maximum)<br>&gt; <br>&gt; looks any good, even if the compiler was able to parse it.<br>&gt; <br>&gt; However, this just means that the methods used to implement operators with<br>&gt; problematic names would need to use different names. Arguably, the only<br>&gt; cases where one would really want to use methods with operator names is for<br>&gt; arithmetical operators. Custom operators like ... are better expressed as<br>&gt; methods with more significant names.<br></p><p>Backtick escaping could help with this as well:<br></p><p>return T.`…`(minimum, maximum)<br></p><p>It’s still not great but it’s at least less of a soup.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/b94a0385/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
