<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>December 13, 2015 at 06:00:00pm</p></header><div class="content"><p>The use-case for this comes first from proposals to have a weak-reference<br>version of collection types. Implementing a notification signal of some<br>sort to weak reference-holders when the reference becomes nil would make<br>implementing those more straightforward.<br></p><p>It would also enable implementing cascading-weakness (or propagating<br>weakness):<br></p><p>class Thing {<br>  var text: String<br>}<br></p><p>class ThingProxy {<br>  weak var thing: Thing?<br>}<br></p><p>class ContrivedExample {<br>  weak var proxy: ThingProxy?<br>}<br></p><p>var example = ContrivedExample()<br></p><p>such that when example.proxy.thing becomes nil, and the ThingProxy instance<br>is no longer meaningful, example.proxy becomes nil as well.<br></p><p>SInce this is the germ of an idea, I&#39;ll avoid suggesting a syntax for the<br>mechanism so the discussion focuses on whether or not this is useful enough<br>as a feature to be implemented.<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/85ef7c16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br></p><p>+1.  This is very useful for various kinds of APIs, like a weak hashtable that wants to remove the keys when/if they get deallocated.<br></p><p>&gt; SInce this is the germ of an idea, I&#39;ll avoid suggesting a syntax for the mechanism so the discussion focuses on whether or not this is useful enough as a feature to be implemented.<br></p><p>IMO, ideally, this would be more of a runtime API than a language feature.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 13, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 9:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br>&gt; <br>&gt; +1.  This is very useful for various kinds of APIs, like a weak hashtable that wants to remove the keys when/if they get deallocated.<br></p><p>Speak of the devil:<br></p><p>https://github.com/bustoutsolutions/siesta/blob/master/Source/Support/WeakCache.swift#L52<br>https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L299-L300<br></p><p>Both of these spots leave zombie entires in collections when weakly referenced objects go away (cached resources in the first link, observer owners in second). Siesta gets away with it only because a low memory event triggers a cleanup.<br></p><p>So yeah, this would be useful in the wild.<br></p><p>Not sure about this, but … perhaps Swift could get away with providing this only for properties and not for local variables? If so, might this fold into Joe Groff’s forthcoming property decoration mechanism?<br></p><p>Cheers, P<br></p><p>–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––<br>https://innig.net • @inthehands • http://siestaframework.com/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 7:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br>&gt; <br>&gt; +1.  This is very useful for various kinds of APIs, like a weak hashtable that wants to remove the keys when/if they get deallocated.<br></p><p>Yes.  This was always part of the long-term vision for weak references.<br></p><p>&gt;&gt; SInce this is the germ of an idea, I&#39;ll avoid suggesting a syntax for the mechanism so the discussion focuses on whether or not this is useful enough as a feature to be implemented.<br>&gt; <br>&gt; IMO, ideally, this would be more of a runtime API than a language feature.<br></p><p>We wouldn’t want to encumber every weak reference with the ability to support having callbacks dynamically registered on it.  So yeah, I think we’d want to provide some runtime functions that would be used to implement some stdlib API.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 11:54 , John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 7:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br>&gt;&gt; <br>&gt;&gt; +1.  This is very useful for various kinds of APIs, like a weak hashtable that wants to remove the keys when/if they get deallocated.<br>&gt; <br>&gt; Yes.  This was always part of the long-term vision for weak references.<br></p><p>Hm. I don&#39;t know. Allowing arbitrary callbacks during the deinit process is a little scary to me; it means that any API that vends an object publicly can no longer assume that deinitialization is cheap. I mean, deinit can already do arbitrary work, but the creator of the class has full control over what that work is (modulo their superclasses). This feels like something that a class might need to opt into, much like KVO requires opt-in in Swift with &#39;dynamic&#39;.<br></p><p>If one of the selling points of ARC over GC is &quot;deterministic destruction&quot;, there&#39;s value in being able to control what happens during that destruction.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>Hmm, just because something could be computationally expensive, it doesn&#39;t become non-deterministic.<br>The program itself as a unit still performs the same steps in the same order, every time.<br>Which is a huge advantage over GC. Still true for a world with deinit observers.<br></p><p><br>A similar argument could be brought for non-KVO property observers.<br></p><p>weak var someProperty: String? {<br>    didSet {<br>         // Mine some Bitcoins.<br>    }<br>}<br></p><p><br>This is possible right now, but noone does this, because convention dictates that property observers should not be computationally expensive.<br></p><p>The main thing that&#39;s being proposed here is that you additionally also get a notification when the property changed to nil.<br></p><p><br>The client of an API could already implement such a notification scheme in certain cases by wrapping the object returned by the API.<br>Then, performing the expensive operation when the outer object is deinited.<br>The API couldn&#39;t prevent this, unless it returns a handle instead of an object and requires passing tha thandle back to the API with every call.<br>This way, the API could ensure that the client has no way to know when a handle becomes invalid.<br></p><p><br>I don&#39;t think that property observers should be treated differently, just because the cause for the property change has a different reason.<br></p><p><br></p><p>Right now, the main pain point is that implementing weak collections is really hard.<br>(i.e. starting a timer that periodically clears the collection of zombies, or responding to low memory conditions,<br> or wrapping objects, or lazily cleanup when the collection is modified etc.)<br></p><p>Since a collection is something generic, you cannot require all passed-in objects to opt-in to deinit observing, either.<br></p><p><br></p><p>I don&#39;t think that KVO strictly requires the dynamic opt-in. If the compiler decides for whatever reasons to use dynamic dispatch,<br>i.e. because a class descends from NSObject, then KVO could still work by accident even though you have not explicitly opted in.<br></p><p><br></p><p>Etan<br></p><p><br>&gt; On 15 Dec 2015, at 19:29, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 11:54 , John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 7:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1.  This is very useful for various kinds of APIs, like a weak hashtable that wants to remove the keys when/if they get deallocated.<br>&gt;&gt; <br>&gt;&gt; Yes.  This was always part of the long-term vision for weak references.<br>&gt; <br>&gt; Hm. I don&#39;t know. Allowing arbitrary callbacks during the deinit process is a little scary to me; it means that any API that vends an object publicly can no longer assume that deinitialization is cheap. I mean, deinit can already do arbitrary work, but the creator of the class has full control over what that work is (modulo their superclasses). This feels like something that a class might need to opt into, much like KVO requires opt-in in Swift with &#39;dynamic&#39;.<br>&gt; <br>&gt; If one of the selling points of ARC over GC is &quot;deterministic destruction&quot;, there&#39;s value in being able to control what happens during that destruction.<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/fe0c2a00/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br></p><p>How do you want this to work in the presence of threads?<br></p><p>One option is that the nil transition and the callbacks are performed together, synchronously and atomically with respect to some things. The problem with this scheme is that the callback is limited in what it can do. If it does the wrong thing it will deadlock. The definition of &quot;wrong thing&quot; depends in part on the definition of &quot;atomically with respect to some things&quot;. For example, if the callbacks are called atomically with respect to other weak reference writes then the callback must not store to any weak references of its own.<br></p><p>Another option is that the callbacks are performed asynchronously some time after the nil transition itself. (Java&#39;s PhantomReference offers something like this.) The problem with this scheme is that the state of the world has moved on by the time the callback is called, which can make the callback difficult to write. In particular there is no guarantee that the weak variable&#39;s storage still exists when the callback for that weak variable is executed.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>Something occurred to me while I was thinking through a response to the<br>thread issue. The language already provides a couple of things that behave<br>similarly:<br></p><p>* deinit methods<br>* property setters<br></p><p>I couldn&#39;t find a documented guarantee for either of them to run on a<br>particular thread, or any explicit detail on guarantees of behavior in<br>threaded environments.<br></p><p>Given that every weak reference has to be an Optional type, I ran the<br>following test code to see if setters are called when a weak reference<br>becomes nil:<br></p><p>// swift-2.2-SNAPSHOT-2015-12-10-a-ubuntu15.10<br>import Glibc<br></p><p>class Beeper {<br>  func beep() {<br>    print(&quot;Beep&quot;)<br>  }<br>}<br></p><p>class Holder {<br>  weak var beeper: Beeper? {<br>    willSet {<br>      print(&quot;willSet: \(newValue)&quot;)<br>    }<br>    didSet {<br>      print(&quot;didSet: \(beeper)&quot;)<br>    }<br>  }<br></p><p>  func doExampleLogic() {<br>    // so there was, at one time, a strong reference in this context<br>    let beeper = Beeper()<br>    self.beeper = beeper<br>  }<br>}<br></p><p>let holder = Holder()<br>holder.doExampleLogic()<br></p><p>for i in 0..&lt;15 {<br>  print(&quot;\(i):&quot;)<br></p><p>  if let heldBeeper = holder.beeper {<br>    print(&quot;held beeper exists&quot;)<br>  } else {<br>    print(&quot;held beeper is nil&quot;)<br>  }<br>}<br></p><p>Results:<br>$ swift beeper.swift<br>willSet: Optional(beeper.Beeper)<br>didSet: Optional(beeper.Beeper)<br>0:<br>held beeper exists<br>1:<br>held beeper exists<br>2:<br>held beeper exists<br>3:<br>held beeper exists<br>4:<br>held beeper exists<br>5:<br>held beeper exists<br>6:<br>held beeper exists<br>7:<br>held beeper exists<br>8:<br>held beeper exists<br>9:<br>held beeper exists<br>10:<br>held beeper exists<br>11:<br>held beeper exists<br>12:<br>held beeper exists<br>13:<br>held beeper exists<br>14:<br>held beeper exists<br></p><p>I see the exact same results if I compile with swiftc. I expected the<br>weakened optional to set itself to nil when the strong reference went out<br>of scope at the end of doExampleLogic(). Have I misunderstood how weakening<br>works?<br></p><p>Mike<br></p><p><br>On Mon, Dec 14, 2015 at 1:06 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The use-case for this comes first from proposals to have a<br>&gt; weak-reference version of collection types. Implementing a notification<br>&gt; signal of some sort to weak reference-holders when the reference becomes<br>&gt; nil would make implementing those more straightforward.<br>&gt;<br>&gt; How do you want this to work in the presence of threads?<br>&gt;<br>&gt; One option is that the nil transition and the callbacks are performed<br>&gt; together, synchronously and atomically with respect to some things. The<br>&gt; problem with this scheme is that the callback is limited in what it can do.<br>&gt; If it does the wrong thing it will deadlock. The definition of &quot;wrong<br>&gt; thing&quot; depends in part on the definition of &quot;atomically with respect to<br>&gt; some things&quot;. For example, if the callbacks are called atomically with<br>&gt; respect to other weak reference writes then the callback must not store to<br>&gt; any weak references of its own.<br>&gt;<br>&gt; Another option is that the callbacks are performed asynchronously some<br>&gt; time after the nil transition itself. (Java&#39;s PhantomReference offers<br>&gt; something like this.) The problem with this scheme is that the state of the<br>&gt; world has moved on by the time the callback is called, which can make the<br>&gt; callback difficult to write. In particular there is no guarantee that the<br>&gt; weak variable&#39;s storage still exists when the callback for that weak<br>&gt; variable is executed.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/88d23114/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>Why not both?<br></p><p>Allow synchronous callbacks for people who know what they do<br>(writing a global exception handler in other languages can also create major issues if you do it the wrong way)<br>and allow asynchronous callbacks for people who just want to clean up their collection eventually.<br></p><p><br>Maybe an approach with `willDeinit` and `didDeinit` would be great here, mirroring the already existing `willSet` and `didSet`.<br></p><p>1. Last strong reference removed<br>2. All `willDeinit` observers are invoked. It is illegal to resurrect an object in these callbacks.<br>3. All weak references are zeroed.<br>4. All `didDeinit` observers are invoked, potentially asynchronously.<br></p><p>The `willDeinit` cannot be merged with the `willSet` because of the additional non-resurrection constraints.<br>The `didDeinit` could be merged with the `didSet`. Although a `didSet` without a preceding `willSet` is kind of strange.<br></p><p><br>Property would look like this:<br></p><p>weak var x: T? {<br>    willSet {<br>        // Not called on automatic zeroing.<br>    }<br>    didSet {<br>        // Not called on automatic zeroing.<br>    }<br>    willDeinit {<br>        // Object is dying.<br>    }<br>    didDeinit {<br>        // Object has died sometime ago.<br>    }<br>}<br></p><p><br></p><p>Alternatively, allow object resurrection between the removal of the last strong reference and the completion of all `willDeinit` callbacks.<br>`willDeinit` becomes advisory in this case, and may be called multiple times. Maybe `willTryToDeinit` would be clearer in the meaning.<br>Only if all `willTryToDeinit` callbacks completed and the object is not resurrected, the references are zeroed and `didDeinit` callbacks are called.<br></p><p>This way, the developer doesn&#39;t need to care about special restrictions that apply to `willDeinit`.<br></p><p><br></p><p>Maybe `unsafeWillDeinit` would be an okay name if you go with the restricted `willDeinit` to scare novices away from that area (similar to pointers).<br></p><p><br>Etan<br></p><p><br></p><p><br></p><p>&gt; On 14 Dec 2015, at 22:06, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br>&gt; <br>&gt; How do you want this to work in the presence of threads?<br>&gt; <br>&gt; One option is that the nil transition and the callbacks are performed together, synchronously and atomically with respect to some things. The problem with this scheme is that the callback is limited in what it can do. If it does the wrong thing it will deadlock. The definition of &quot;wrong thing&quot; depends in part on the definition of &quot;atomically with respect to some things&quot;. For example, if the callbacks are called atomically with respect to other weak reference writes then the callback must not store to any weak references of its own.<br>&gt; <br>&gt; Another option is that the callbacks are performed asynchronously some time after the nil transition itself. (Java&#39;s PhantomReference offers something like this.) The problem with this scheme is that the state of the world has moved on by the time the callback is called, which can make the callback difficult to write. In particular there is no guarantee that the weak variable&#39;s storage still exists when the callback for that weak variable is executed.<br>&gt; <br>&gt; <br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/54a298a4/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: Give weak references the ability to notify reference-holders when they transition to nil</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>The first case where `willDeinit` is not allowed to resurrect the object is probably not really usable.<br></p><p>Code needs to be able to assume that claiming a weakly referenced object is something nonblocking.<br></p><p>This can only be the case if `willDeinit` completes in a timely fashion - probably still too much if you need to call user code.<br>If it&#39;s fast enough, I would strongly suggest some wording like `unsafeWillDeinit` to emphasize that.<br></p><p><br></p><p>In the end, that leaves the `willTryToDeinit` / `didDeinit` concept.<br></p><p>`didDeinit` is essentially the same that we have now, when we post a notification at the end of `deinit`<br>that contains an identifier of the deallocated object to be removed from dictionaries etc.<br></p><p>`willTryToDeinit` is something invoked when all strong references are removed from the object,<br>and may be called multiple times if another thread concurrently claims a strong reference to the object,<br>or if one of the callbacks decides to resurrect the object past its runtime.<br></p><p>Etan<br></p><p><br></p><p>&gt; On 15 Dec 2015, at 19:10, Etan Kissling &lt;kissling at oberon.ch&gt; wrote:<br>&gt; <br>&gt; Why not both?<br>&gt; <br>&gt; Allow synchronous callbacks for people who know what they do<br>&gt; (writing a global exception handler in other languages can also create major issues if you do it the wrong way)<br>&gt; and allow asynchronous callbacks for people who just want to clean up their collection eventually.<br>&gt; <br>&gt; <br>&gt; Maybe an approach with `willDeinit` and `didDeinit` would be great here, mirroring the already existing `willSet` and `didSet`.<br>&gt; <br>&gt; 1. Last strong reference removed<br>&gt; 2. All `willDeinit` observers are invoked. It is illegal to resurrect an object in these callbacks.<br>&gt; 3. All weak references are zeroed.<br>&gt; 4. All `didDeinit` observers are invoked, potentially asynchronously.<br>&gt; <br>&gt; The `willDeinit` cannot be merged with the `willSet` because of the additional non-resurrection constraints.<br>&gt; The `didDeinit` could be merged with the `didSet`. Although a `didSet` without a preceding `willSet` is kind of strange.<br>&gt; <br>&gt; <br>&gt; Property would look like this:<br>&gt; <br>&gt; weak var x: T? {<br>&gt;    willSet {<br>&gt;        // Not called on automatic zeroing.<br>&gt;    }<br>&gt;    didSet {<br>&gt;        // Not called on automatic zeroing.<br>&gt;    }<br>&gt;    willDeinit {<br>&gt;        // Object is dying.<br>&gt;    }<br>&gt;    didDeinit {<br>&gt;        // Object has died sometime ago.<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; Alternatively, allow object resurrection between the removal of the last strong reference and the completion of all `willDeinit` callbacks.<br>&gt; `willDeinit` becomes advisory in this case, and may be called multiple times. Maybe `willTryToDeinit` would be clearer in the meaning.<br>&gt; Only if all `willTryToDeinit` callbacks completed and the object is not resurrected, the references are zeroed and `didDeinit` callbacks are called.<br>&gt; <br>&gt; This way, the developer doesn&#39;t need to care about special restrictions that apply to `willDeinit`.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Maybe `unsafeWillDeinit` would be an okay name if you go with the restricted `willDeinit` to scare novices away from that area (similar to pointers).<br>&gt; <br>&gt; <br>&gt; Etan<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 14 Dec 2015, at 22:06, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 6:24 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The use-case for this comes first from proposals to have a weak-reference version of collection types. Implementing a notification signal of some sort to weak reference-holders when the reference becomes nil would make implementing those more straightforward.<br>&gt;&gt; <br>&gt;&gt; How do you want this to work in the presence of threads?<br>&gt;&gt; <br>&gt;&gt; One option is that the nil transition and the callbacks are performed together, synchronously and atomically with respect to some things. The problem with this scheme is that the callback is limited in what it can do. If it does the wrong thing it will deadlock. The definition of &quot;wrong thing&quot; depends in part on the definition of &quot;atomically with respect to some things&quot;. For example, if the callbacks are called atomically with respect to other weak reference writes then the callback must not store to any weak references of its own.<br>&gt;&gt; <br>&gt;&gt; Another option is that the callbacks are performed asynchronously some time after the nil transition itself. (Java&#39;s PhantomReference offers something like this.) The problem with this scheme is that the state of the world has moved on by the time the callback is called, which can make the callback difficult to write. In particular there is no guarantee that the weak variable&#39;s storage still exists when the callback for that weak variable is executed.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/8e034735/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
