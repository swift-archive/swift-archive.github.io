<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17f3e4010ef1b1ed65d4926cbb191b2f?s=50"></div><header><strong>Why are Swift Loops slow?</strong> from <string>Gerriet M. Denkmann</string> &lt;g at mdenkmann.de&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>uint64_t nbrBytes = 4e8;<br>uint64_t count = 0;<br>for( uint64_t byteIndex = 0; byteIndex &lt; nbrBytes; byteIndex++ )<br>{<br>	count += byteIndex;<br>	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) { count += 1.3; }  (AAA) <br>};<br></p><p>Takes 260 msec.<br></p><p>Btw.: Without the (AAA) line the whole loop is done in 10 μsec. A really clever compiler!<br>And with “count += 1” instead of “count += 1.3” it takes 410 msec. Very strange. <br>But this is beside the point here.<br></p><p><br>Now Swift:<br>let nbrBytes = 400_000_000<br>var count = 0<br>for byteIndex in 0 ..&lt; nbrBytes<br>{<br>	count += byteIndex<br>	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) {count += Int(1.3);}<br>}<br></p><p>takes 390 msec - about 50 % more.<br></p><p>Release build with default options.<br></p><p>Gerriet.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Why are Swift Loops slow?</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>October 12, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 2:25 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; uint64_t nbrBytes = 4e8;<br>&gt; uint64_t count = 0;<br>&gt; for( uint64_t byteIndex = 0; byteIndex &lt; nbrBytes; byteIndex++ )<br>&gt; {<br>&gt; 	count += byteIndex;<br>&gt; 	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) { count += 1.3; }  (AAA) <br>&gt; };<br>&gt; <br>&gt; Takes 260 msec.<br>&gt; <br>&gt; Btw.: Without the (AAA) line the whole loop is done in 10 μsec. A really clever compiler!<br>&gt; And with “count += 1” instead of “count += 1.3” it takes 410 msec. Very strange. <br>&gt; But this is beside the point here.<br>&gt; <br>&gt; <br>&gt; Now Swift:<br>&gt; let nbrBytes = 400_000_000<br>&gt; var count = 0<br>&gt; for byteIndex in 0 ..&lt; nbrBytes<br>&gt; {<br>&gt; 	count += byteIndex<br>&gt; 	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) {count += Int(1.3);}<br>&gt; }<br>&gt; <br>&gt; takes 390 msec - about 50 % more.<br>&gt; <br>&gt; Release build with default options.<br></p><p>You&#39;ll need to read the generated assembly code if you want to analyze performance of this sort of small arithmetic loop. Performance of this kind of code can be greatly affected by small optimization changes.<br></p><p>clang&#39;s `count +=1` code is vectorized, and the `count += 1.3` code is not vectorized. For whatever reason that vectorization is unsuccessful and the vectorized loop runs slower (at least on your machine and on my machine). Optimization is hard.<br></p><p>The Swift loop runs slower because Swift performs arithmetic overflow checks that C does not, and in this case swiftc was unable to optimize them all away.<br></p><p>If you use &amp;+ instead of +, or compile with -Ounchecked, then Swift won&#39;t perform the overflow checks. Unfortunately in this case you then get the same slower vectorized code from swiftc as you did from clang&#39;s `count += 1` case; presumably both clang and swiftc get this pessimization from LLVM. I couldn&#39;t find a way to disable LLVM vectorization from swiftc.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/5d00b6ce/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Why are Swift Loops slow?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 2:25 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; uint64_t nbrBytes = 4e8;<br>&gt; uint64_t count = 0;<br>&gt; for( uint64_t byteIndex = 0; byteIndex &lt; nbrBytes; byteIndex++ )<br>&gt; {<br>&gt; 	count += byteIndex;<br>&gt; 	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) { count += 1.3; }  (AAA) <br>&gt; };<br>&gt; <br>&gt; Takes 260 msec.<br>&gt; <br>&gt; Btw.: Without the (AAA) line the whole loop is done in 10 μsec. A really clever compiler!<br>&gt; And with “count += 1” instead of “count += 1.3” it takes 410 msec. Very strange. <br>&gt; But this is beside the point here.<br>&gt; <br>&gt; <br>&gt; Now Swift:<br>&gt; let nbrBytes = 400_000_000<br>&gt; var count = 0<br>&gt; for byteIndex in 0 ..&lt; nbrBytes<br>&gt; {<br>&gt; 	count += byteIndex<br>&gt; 	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) {count += Int(1.3);}<br>&gt; }<br>&gt; <br>&gt; takes 390 msec - about 50 % more.<br>&gt; <br>&gt; Release build with default options.<br></p><p>This is a useless benchmark because the loop does no observable work in either language. The C version, if you look at the generated assembly, in fact optimizes away to nothing:<br></p><p>~/src/s/swift$ clang ~/butt.c -O3  -S -o -<br>	.section	__TEXT,__text,regular,pure_instructions<br>	.macosx_version_min 10, 9<br>	.globl	_main<br>	.p2align	4, 0x90<br>_main:                                  ## @main<br>	.cfi_startproc<br>## BB#0:                                ## %entry<br>	pushq	%rbp<br>Ltmp0:<br>	.cfi_def_cfa_offset 16<br>Ltmp1:<br>	.cfi_offset %rbp, -16<br>	movq	%rsp, %rbp<br>Ltmp2:<br>	.cfi_def_cfa_register %rbp<br>	xorl	%eax, %eax<br>	popq	%rbp<br>	retq<br>	.cfi_endproc<br></p><p>It looks like LLVM does not recognize the overflow traps Swift emits on arithmetic operations as dead code, so that prevents it from completely eliminating the Swift loop.  That&#39;s a bug worth fixing in Swift, but unlikely to make a major difference in real, non-dead code. However, if we make the work useful by factoring the loop into a function in both languages, the perf difference is unmeasurable. Try comparing:<br></p><p>#include &lt;stdint.h&gt;<br></p><p>__attribute__((noinline))<br>uint64_t getCount(uint64_t nbrBytes) {<br>  uint64_t count = 0;<br>  for( uint64_t byteIndex = 0; byteIndex &lt; nbrBytes; byteIndex++ )<br>  {<br>          count += byteIndex;<br>          if ( ( byteIndex &amp; 0xffffffff ) == 0 ) { count += 1.3; } <br>  };<br>  return count;<br>}<br></p><p>int main() {<br>  uint64_t nbrBytes = 4e8;<br>  return getCount(nbrBytes);<br>}<br></p><p><br>with:<br></p><p>import Darwin<br></p><p>@inline(never)<br>func getCount(nbrBytes: Int) -&gt; Int {<br>  var count = 0<br>  for byteIndex in 0 ..&lt; nbrBytes<br>  {<br>          count += byteIndex<br>          if ( ( byteIndex &amp; 0xffffffff ) == 0 ) {count += Int(1.3);}<br>  }<br>  return count<br>}<br></p><p>exit(Int32(truncatingBitPattern: getCount(nbrBytes: 400_000_000)))<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/42a1a7f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Why are Swift Loops slow?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 9:05 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It looks like LLVM does not recognize the overflow traps Swift emits on arithmetic operations as dead code, so that prevents it from completely eliminating the Swift loop.  That&#39;s a bug worth fixing in Swift, but unlikely to make a major difference in real, non-dead code. <br></p><p>The traps aren’t dead if they are reachable. Eventually we will teach LLVM about less-strict trap semantics so they can be speculated and reordered. But for now we can do that sort of thing in SIL in the most important cases.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/da15f454/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17f3e4010ef1b1ed65d4926cbb191b2f?s=50"></div><header><strong>Why are Swift Loops slow?</strong> from <string>Gerriet M. Denkmann</string> &lt;g at mdenkmann.de&gt;<p>October 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 12 Oct 2016, at 23:05, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 12, 2016, at 2:25 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; uint64_t nbrBytes = 4e8;<br>&gt;&gt; uint64_t count = 0;<br>&gt;&gt; for( uint64_t byteIndex = 0; byteIndex &lt; nbrBytes; byteIndex++ )<br>&gt;&gt; {<br>&gt;&gt; 	count += byteIndex;<br>&gt;&gt; 	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) { count += 1.3; }  (AAA) <br>&gt;&gt; };<br>&gt;&gt; <br>&gt;&gt; Takes 260 msec.<br>&gt;&gt; <br>&gt;&gt; Btw.: Without the (AAA) line the whole loop is done in 10 μsec. A really clever compiler!<br>&gt;&gt; And with “count += 1” instead of “count += 1.3” it takes 410 msec. Very strange. <br>&gt;&gt; But this is beside the point here.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now Swift:<br>&gt;&gt; let nbrBytes = 400_000_000<br>&gt;&gt; var count = 0<br>&gt;&gt; for byteIndex in 0 ..&lt; nbrBytes<br>&gt;&gt; {<br>&gt;&gt; 	count += byteIndex<br>&gt;&gt; 	if ( ( byteIndex &amp; 0xffffffff ) == 0 ) {count += Int(1.3);}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; takes 390 msec - about 50 % more.<br>&gt;&gt; <br>&gt;&gt; Release build with default options.<br>&gt; <br>&gt; This is a useless benchmark because the loop does no observable work in either language.<br></p><p>I quite agree that this is useless as a benchmark.<br>It is an abstraction of some real code, which has the common feature that inside the loop is not done anything lengthy.<br></p><p>Following some very helpful remarks from Greg Parker I was able to improve the Swift code by a factor of 3, making it on par with ObjC:<br>1. using a signed loop counter (factor of 2)<br>2. using “count = count &amp;+ something” instead of “count += something” (factor of 1.5).<br></p><p>So this exercise gave me some very valuable insights into using Swift (or into some shortcomings of the current Swift compiler).<br></p><p>Thanks again to Greg Parker for his comments and suggestions!<br></p><p>Kind regards,<br></p><p>Gerriet.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
