<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Hello!/Obs. Language Elements/extent Swift for loops/Tuples init. APL in Swift</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Hello. This is my first time here, so please allow me to introduce myself.. thank you.<br>Grab a chair. Coffee? <br>I&#39;ve worked with many programming languages since 1979. Interesting years.<br>Fortran, Cobol, PL/1 C, CSP, C++, Java, Microprocessor, Assembler, Rexx, Pascal, <br>Smalltalk, APL,  etc. Objective C, and also Swift since it became available. <br>OOD/OOP is my Holy Grail: the thing we found &quot;somehow-something-is-missing-but-dunno-what?”<br>before it came along :o)  My current creativity is RavelNotes, an ObjC/Swift hybrid iPad app <br>and under construction is a 3D game app with Swift/SceneKit for Apple TV. <br>I am 65: Now that I am retiring, app development will be the main thing for me to do <br>because it is fun and  also because I simply cannot stop making software… <br>and I have lots of time for it.. without any quality compromising deadlines...<br></p><p><br>I am quite happy with Swift! It connects really good with the stuff that is already inside <br>my head allowing me to transfer my ideas and creativity into the virtual world without<br>too much hassle in-between. Swift is still new, but right from the start it has everything <br>I need and could wish for!  There is really not that much missing, if any. <br>Thanks to Chris Lattner and team: you guys did a really amazing job!  <br></p><p>Thanks for reading.. <br>still here? OK<br>--------------------------------------------------------------------------------<br></p><p>1. On removing (possibly) superfluous language elements<br></p><p>IMHO it is nearly impossible to estimate whether or not a certain language element<br>will or will not useful now or in the future. It&#39;s like Lego. So don&#39;t remove bricks from the <br>box that you might think will not be used anymore, just because a quick scan in the <br>neighborhood in GitCity  reveals that at the moment no others are using this kinda bricks...<br></p><p>So why not keep these things like i++ i--<br>and the C-style for loop? More important imho: do the best to maintain downward compatibility <br>e.g. save us from modifying 10000 source files written in 2016 in say 2021 when Swift 8.0 arrives..<br></p><p>--------------------------------------------------------------------------------<br></p><p>2: Swift &quot;for&quot; statement: why not add this variants:<br> (to get rid of reverse, strides, generators..and other indirect stuff)<br></p><p>for i in 12 to 0 by -2 <br></p><p>for v:Double in x1 to -2.8 by -0.1   <br></p><p>Swift could handle that implicitly. Most languages have these loops.<br>--------------------------------------------------------------------------------<br></p><p>3 . I beg you! Please, please, please implement implicit conversion between Floats/CGFloats/Double..<br>Why does one need to convert floating point vars explicitly?<br>Yes, one can loose precision, but we know that, don&#39;t we? <br>--------------------------------------------------------------------------------<br></p><p>4 Tuples:  please take a look at this code:  <br></p><p> static var z: UInt8 = 0  // initalize tuple with 256 UInt8 values, bytes:<br>    <br>    // Silly: why not an array instead of this.. a tuple is needed.. length must be exact 256..<br>    // know of no other way to create a tuple with 256 elements...<br>    var midiDataTuple = (z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br> z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, <br>z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, <br>z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, <br>z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br> z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z)<br></p><p>    <br>    func midiSend(status: Int, val1: Int, val2 :Int)<br>    {<br>        var midipacket = MIDIPacket()<br>        <br>        midipacket.timeStamp = 0<br>        midipacket.length    = 3<br>        midipacket.data      = midiDataTuple  //&lt;-=&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>        <br>        midipacket.data.0 = UInt8(status)<br>        midipacket.data.1 = UInt8(val1  )<br>        midipacket.data.2 = UInt8(val2  )<br>        <br>        var midipacketlist = MIDIPacketList(numPackets: 1, packet: midipacket)<br>        <br>        MIDIReceived(midiSource, &amp;midipacketlist)<br>    }<br>    <br>I can&#39;t treat tuples as an array, which in this case would be handy to initialize all the tuple elements.<br></p><p>IfTrue: Why are tuples the only data type to use for unmanaged byte arrays? <br></p><p>--------------------------------------------------------------------------------<br></p><p>Sideways: fun &amp; inspiration: take a look at APL.. [I&#39;ll wait here]  this language uses mostly symbols for operations. <br>E.g. it has an excellent set of chars for Set operations. To experiment with this,  replaced Xcode&#39;s source font with <br>an APLFont and then define operator extensions for some APL characters like e.g. Ro to get or alter the shape <br>of a multi dimensional array    or  +/   to sum a vector.<br></p><p><br>Regards<br>Ted<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160214/f2002717/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/57885cfd0c4b4db16653e76d9e6f0266?s=50"></div><header><strong>Hello!/Obs. Language Elements/extent Swift for loops/Tuples init. APL in Swift</strong> from <string>Johan Jensen</string> &lt;jj at johanjensen.dk&gt;<p>February 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; 4 Tuples:  please take a look at this code:<br>&gt;<br>&gt;  static var z: UInt8 = 0  // initalize tuple with 256 UInt8 values, bytes:<br>&gt;<br>&gt;<br>&gt;     // Silly: why not an array instead of this.. a tuple is needed..<br>&gt; length must be exact 256..<br>&gt;     // know of no other way to create a tuple with 256 elements...<br>&gt;     var midiDataTuple = (z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt;  z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt;  z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z)<br>&gt;<br>&gt;<br>&gt;<br>&gt;     func midiSend(status: Int, val1: Int, val2 :Int)<br>&gt;     {<br>&gt;         var midipacket = MIDIPacket()<br>&gt;<br>&gt;<br>&gt;         midipacket.timeStamp = 0<br>&gt;         midipacket.length    = 3<br>&gt;         midipacket.data      = midiDataTuple<br>&gt; //&lt;-=&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>&gt;<br>&gt;<br>&gt;         midipacket.data.0 = UInt8(status)<br>&gt;         midipacket.data.1 = UInt8(val1  )<br>&gt;         midipacket.data.2 = UInt8(val2  )<br>&gt;<br>&gt;<br>&gt;         var midipacketlist = MIDIPacketList(numPackets: 1, packet:<br>&gt; midipacket)<br>&gt;<br>&gt;<br>&gt;         MIDIReceived(midiSource, &amp;midipacketlist)<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; I can&#39;t treat tuples as an array, which in this case would be handy to<br>&gt; initialize all the tuple elements.<br>&gt;<br>&gt; IfTrue: Why are tuples the only data type to use for unmanaged byte<br>&gt; arrays?<br>&gt;<br></p><p>There&#39;s currently some work on a proposal for Contiguous Variables (A.K.A.<br>Fixed Sized Array Type)<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007984.html&gt;<br>which should help with the creation of tuples. (It can be read in a better<br>fashion on gmane<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/4809&gt;)<br></p><p>— Johan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160214/49737f38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Contiguous storage byte arrays</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 17, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello Johan, thanks for your reply. <br>It would be nice if there was some kind of attribute like<br>var bytes: [UInt8] contiguous  = ...      //  to declare a contiguous array. <br></p><p>Ok then, I&#39;d suggest creating a new Swift type with an internal fixed length<br>and contiguous byte array inside. Perhaps to be implemented in a Swift library.<br></p><p>This swift class example here is just a Model<br> because to a programmer  [Swift any type]  arrays are undefined whether to be <br>be contiguous or not.  No error handling is implemented in this examplel)<br></p><p>final class ByteArray   // Note: Just a model for a lower level implementation! <br>{<br>    private var bytebuffer = [UInt8]()   // Not! Must be an internal contiguous byte array.<br>    <br>    init(contents: [UInt8])  // Constructor.<br>    {<br>        for byte in contents                  // load bytes into contiguous!! buffer<br>        {<br>            bytebuffer.append(byte)<br>        }<br>    }<br>    <br>    func setByte(index index: Int, byte: UInt8)     // set a byte in the buffer<br>    {<br>       if index.outsideRange(0..&lt;bytebuffer.count)  // should be valid index<br>       {<br>          // Aarrggh! throw: subscripting error<br>       }<br>       bytebuffer[index] = byte<br>    }<br></p><p>    // other functions could be added to clear, shift etc.<br>    <br>    func address() -&gt; Any<br>    {<br>        return bytebuffer //  use as someExternalFunc(bytes.address,…) <br>    }<br></p><p>    func length() -&gt; Int<br>    {<br>        return bytebuffer.count<br>    }<br>}<br> <br></p><p>// usage example:  <br></p><p>let bytes = ByteArray(contents:   someUInt8array )<br></p><p>// or -other constructor-  make a byte array of 512 zero bytes:<br></p><p>let bytes = ByteArray(length: 512, fillWith: 0) <br></p><p>bytes.setByte(index: 0, byte: midiCommandByte)<br>bytes.setByte(index: 1, byte: midiStatByte)<br></p><p>// define subscriptors? so that we could just write:  bytes[idx] = value<br></p><p>var offset = 2       // load databytes<br>for b in midiData<br>{<br>    bytes.setByte(index: offset, byte: b)<br>   offset++                    <br>}   <br></p><p><br>// pass the address of the contiguous byte buffer within (this instance of) ByteArray to some external function:<br></p><p>someExternalFunc(&amp;bytes.address, . . . ) <br></p><p><br></p><p>Regards<br>Ted<br></p><p>&gt; On 14.02.2016, at 20:26, Johan Jensen &lt;jj at johanjensen.dk&gt; wrote:<br>&gt; <br>&gt; 4 Tuples:  please take a look at this code:  <br>&gt; <br>&gt;  static var z: UInt8 = 0  // initalize tuple with 256 UInt8 values, bytes:<br>&gt;     <br>&gt;     // Silly: why not an array instead of this.. a tuple is needed.. length must be exact 256..<br>&gt;     // know of no other way to create a tuple with 256 elements...<br>&gt;     var midiDataTuple = (z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt;  z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, <br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, <br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, <br>&gt; z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,<br>&gt;  z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z)<br>&gt; <br>&gt;     <br>&gt;     func midiSend(status: Int, val1: Int, val2 :Int)<br>&gt;     {<br>&gt;         var midipacket = MIDIPacket()<br>&gt;         <br>&gt;         midipacket.timeStamp = 0<br>&gt;         midipacket.length    = 3<br>&gt;         midipacket.data      = midiDataTuple  //&lt;-=&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>&gt;         <br>&gt;         midipacket.data.0 = UInt8(status)<br>&gt;         midipacket.data.1 = UInt8(val1  )<br>&gt;         midipacket.data.2 = UInt8(val2  )<br>&gt;         <br>&gt;         var midipacketlist = MIDIPacketList(numPackets: 1, packet: midipacket)<br>&gt;         <br>&gt;         MIDIReceived(midiSource, &amp;midipacketlist)<br>&gt;     }<br>&gt;     <br>&gt; I can&#39;t treat tuples as an array, which in this case would be handy to initialize all the tuple elements.<br>&gt; <br>&gt; IfTrue: Why are tuples the only data type to use for unmanaged byte arrays? <br>&gt; <br>&gt; There&#39;s currently some work on a proposal for Contiguous Variables (A.K.A. Fixed Sized Array Type) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007984.html&gt; which should help with the creation of tuples. (It can be read in a better fashion on gmane &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/4809&gt;)<br>&gt; <br>&gt; — Johan<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/eff707cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Contiguous storage byte arrays</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 17, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Feb 17, 2016 at 6:53 AM, Ted F.A. van Gaalen via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Johan, thanks for your reply.<br>&gt; It would be nice if there was some kind of attribute like<br>&gt; var bytes: [UInt8] contiguous  = ...      //  to declare a contiguous array.<br></p><p>Unless you create an Array by bridging from NSArray, Swift&#39;s Array is<br>guaranteed to have contiguous storage.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Contiguous storage byte arrays</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 17, 2016 at 07:00:00pm</p></header><div class="content"><p>ok, thank you, didn’t know that.<br></p><p><br>Ted <br>&gt; On 17.02.2016, at 19:34, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Feb 17, 2016 at 6:53 AM, Ted F.A. van Gaalen via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Johan, thanks for your reply.<br>&gt;&gt; It would be nice if there was some kind of attribute like<br>&gt;&gt; var bytes: [UInt8] contiguous  = ...      //  to declare a contiguous array.<br>&gt; <br>&gt; Unless you create an Array by bridging from NSArray, Swift&#39;s Array is<br>&gt; guaranteed to have contiguous storage.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/73b7f411/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Contiguous storage byte arrays</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Unless you create an Array by bridging from NSArray, Swift&#39;s Array is<br>&gt; guaranteed to have contiguous storage.<br></p><p>And if you want to guarantee contiguous storage, `ContiguousArray` does that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Hello!/Obs. Language Elements/extent Swift for loops/Tuples init. APL in Swift</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Welcome to the Swift project, Ted!<br></p><p>A couple of general points:<br></p><p>* swift-dev is primarily for discussing Swift implementation details, like progress on fixing compiler bugs, binary representations of language metadata, or optimizations that should be applied. Discussion of high-level language features should generally be on swift-evolution.<br></p><p>* It&#39;s usually better to post unrelated proposals to swift-evolution as separate threads. This allows everyone to keep the discussion organized and avoids mixing discussion of unrelated topics together.<br></p><p>On your specific suggestions...<br></p><p>&gt; 1. On removing (possibly) superfluous language elements<br></p><p>Swift is pretty aggressive about removing things that are mistake-prone, rarely used, and easy to achieve in a different way. The C-style for loop and increment/decrement operators fit all three criteria.<br></p><p>&gt; More important imho: do the best to maintain downward compatibility <br>&gt; e.g. save us from modifying 10000 source files written in 2016 in say 2021 when Swift 8.0 arrives..<br></p><p>We are trying to stabilize the language; the hope is that Swift 4 will be a less jarring transition than Swift 3, and Swift 5 less jarring than Swift 4, and so on. But accomplishing that means removing as much cruft as possible as *early* as we can.<br></p><p>&gt; 2: Swift &quot;for&quot; statement: why not add this variants:<br>&gt;  (to get rid of reverse, strides, generators..and other indirect stuff)<br>&gt; <br>&gt; for i in 12 to 0 by -2 <br>&gt; <br>&gt; for v:Double in x1 to -2.8 by -0.1   <br></p><p>Swift&#39;s philosophy is that, where practical, it&#39;s actually *better* to implement features in the standard library than to create special syntax in the language. Doing it that way sometimes means you need some extra function names or punctuation characters, but it also means that when you want to do something a little bit different—maybe you need to multiply the previous value instead of adding it, or you need to stride over NSDates instead of numbers—you can build things just like the features everyone already knows how to use.<br></p><p>In general, we try to design features that allow us to put *more* things in the standard library, not less. For instance, swift-evolution is currently reviewing a proposal called Property Behaviors which would allow us to make `lazy` and possibly `willSet` and `didSet` into standard library features, rather than special built-in language features, and thereby allow anyone to define similar special behavior attached to a property. Building striding support into the `for` loop runs opposite to that trend, and it&#39;s unlikely to find very much support.<br></p><p>&gt; 3 . I beg you! Please, please, please implement implicit conversion between Floats/CGFloats/Double..<br>&gt; Why does one need to convert floating point vars explicitly?<br></p><p>There are long-term plans to do something about this, but for technical reasons it&#39;s actually somewhat difficult. Basically, type inference gets slower when it has to consider more types. Allowing implicit conversions like these increases the number of types involved, which makes compiling slower. And I don&#39;t mean it adds a couple of seconds here and there; I mean it can make a compilation take minutes instead of seconds or hours instead of minutes.<br></p><p>This isn&#39;t impossible to overcome, and like I said, we do hope to do something about it eventually. But the time isn&#39;t right yet.<br></p><p>&gt; I can&#39;t treat tuples as an array, which in this case would be handy to initialize all the tuple elements.<br></p><p>There is an active discussion on swift-evolution right now about treating tuples as fixed-size arrays, including subscripting and declaration shorthands. The current thread is called &quot;CollectionType on uniform tuples [forked off Contiguous Variables]&quot;.<br></p><p>If you&#39;d like to discuss any of these further, please start a thread on swift-evolution; that&#39;s the appropriate venue for this kind of discussion.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
