<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0127: Cleaning up stdlib Pointer and Buffer Routines&quot; begins now and runs through July 24. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0127-cleaning-up-stdlib-ptr-buffer.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0cf6ae15b5fae33e4627c33690ba81d?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Bob Wilson</string> &lt;bob.wilson at apple.com&gt;<p>July 22, 2016 at 11:00:00am</p></header><div class="content"><p>I have been looking at the parts of this proposal related to withUnsafe[Mutable]Pointer:<br></p><p>- https://bugs.swift.org/browse/SR-1937: &lt;https://bugs.swift.org/browse/SR-1937:&gt; withUnsafePointer(&amp;x) should have an argument label &#39;to:’<br>- https://bugs.swift.org/browse/SR-1956: &lt;https://bugs.swift.org/browse/SR-1956:&gt; `withUnsafePointer` shouldn&#39;t take its argument as `inout`<br></p><p>Adding the “to:” argument label seems like an obviously good thing to do for the one-argument version of these functions. Besides that, I&#39;d like to suggest that we remove the 2- and 3-argument versions: withUnsafe[Mutable]Pointers. The naming is already different than the 1-argument functions (plural vs. singular) and the argument label doesn&#39;t work so well with multiple arguments. These extra functions are not a complete solution (if you need more than 3 arguments) and they&#39;re not used much -- there is only one real use in the stdlib, with one more use in a validation-test. We can replace them by composing nested uses of the 1-argument functions in the few places where they are needed. I have already prototyped that and it seems to work fine.<br></p><p>It is not so clear what to do about SR-1956. (Charlie and I had some comments on this in https://github.com/apple/swift-evolution/pull/437 &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised the objection that when using withUnsafePointer with a global, there is an expectation that you’ll get the same address every time. Removing inout would cause the argument to be passed by value and the address would refer to a copy. Dmitri agreed that this could be a problem. On the other hand, if you don’t care about the address, or if you’re not using a value type, it would indeed be convenient to have a version of withUnsafePointer that does not require an inout argument.<br></p><p>Option 1: Keep inout (not addressing SR-1956). In this case, there’s no reason to have both withUnsafePointer and withUnsafeMutablePointer. If you want to call a function that expects an UnsafePointer, you can give it an UnsafeMutablePointer and there will be an implicit conversion to make it work. I discussed this with Apple’s stdlib team and they recommended that if we have only one function we use the shorter name “withUnsafePointer” and have it use an UnsafeMutablePointer.<br></p><p>Option 2: Fix SR-1956 and have two functions, one with inout and the other not. This would address the inconvenience of not being able to use withUnsafePointer with immutable values, while still supporting the existing behavior. The question then would be what to call these two functions.<br></p><p>- Option 2a. Combine the two existing functions as in Option 1 and use a new name for the non-inout version, e.g., withUnsafePointer(toCopyOf:), so that it won’t be confused with the old function. (That particular name doesn’t work very well when dealing with references to objects, since the object itself would not be copied. I haven’t yet come up with a better name, though.) One advantage of this approach is that we would not need to rush the new function into Swift 3 since it would be an additive change.<br></p><p>- Option 2b. Switch to use withUnsafeMutablePointer for all the cases where you care about the getting the same address. Change withUnsafePointer to be the non-inout version. Charlie suggested that we could have the migrator convert all existing uses on withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in Swift 3, but I’m not sure how well that would work.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/fda04ad8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 22, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 11:16 AM, Bob Wilson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I have been looking at the parts of this proposal related to<br>&gt; withUnsafe[Mutable]Pointer:<br>&gt;<br>[...]<br></p><p>I agree with everything that Bob said, and I would like to comment on this part:<br></p><p>&gt; unsafeAddressOf is removed, in favor of adding a unsafeAddress field on ObjectIdentifier. ObjectIdentifier already contains a raw pointer in the internal _value field and can be initialized with AnyObject just like the argument of unsafeAddressOf.<br></p><p>I think we should not add the ObjectIdentifier.unsafeAddress API.  I<br>don&#39;t agree with the motivation from the proposal:<br></p><p>&gt; Remove unsafeAddressOf and use Unmanaged.takeUnretainedValue(_:) instead. This, however, requires the caller to deal with retain logic for something as simple as getting an object address.<br></p><p>We want users to be explicit about their reference counting semantics<br>when working unsafely with object addresses.  Otherwise it is not<br>clear for how long the resulting pointer is valid.  Getting an unsafe<br>object address is not &quot;simple&quot;, it is not commonly when working with<br>Swift or Objective-C APIs, and there should be no need to have<br>shorthand convenience syntax for it.  The current way to perform<br>manual reference counting and bridging of objects to the unsafe world<br>is through Unmanaged, so the conversion from object to a pointer<br>should be on Unmanaged (where it is now).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 23, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 10:37 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 11:16 AM, Bob Wilson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I have been looking at the parts of this proposal related to<br>&gt;&gt; withUnsafe[Mutable]Pointer:<br>&gt;&gt; <br>&gt; [...]<br>&gt; <br>&gt; I agree with everything that Bob said, and I would like to comment on this part:<br>&gt; <br>&gt;&gt; unsafeAddressOf is removed, in favor of adding a unsafeAddress field on ObjectIdentifier. ObjectIdentifier already contains a raw pointer in the internal _value field and can be initialized with AnyObject just like the argument of unsafeAddressOf.<br>&gt; <br>&gt; I think we should not add the ObjectIdentifier.unsafeAddress API.  I<br>&gt; don&#39;t agree with the motivation from the proposal:<br>&gt; <br>&gt;&gt; Remove unsafeAddressOf and use Unmanaged.takeUnretainedValue(_:) instead. This, however, requires the caller to deal with retain logic for something as simple as getting an object address.<br>&gt; <br>&gt; We want users to be explicit about their reference counting semantics<br>&gt; when working unsafely with object addresses.  Otherwise it is not<br>&gt; clear for how long the resulting pointer is valid.  Getting an unsafe<br>&gt; object address is not &quot;simple&quot;, it is not commonly when working with<br>&gt; Swift or Objective-C APIs, and there should be no need to have<br>&gt; shorthand convenience syntax for it.  The current way to perform<br>&gt; manual reference counting and bridging of objects to the unsafe world<br>&gt; is through Unmanaged, so the conversion from object to a pointer<br>&gt; should be on Unmanaged (where it is now).<br></p><p>The general consensus on where the unsafeAddressOf is used the mosed has been settled (here in the original discussion and what I&#39;ve googled on Stackoverflow) on that it&#39;s mostly used for logging an object address as part of description or debugDescription (or various other debugging purposes).<br></p><p>In the original discussion about the pointer and buffer routines cleanup here Jordan suggested using ObjectIdentifier instead (http://article.gmane.org/gmane.comp.lang.swift.evolution/23168) - and I have to agree with him. Not that the entire ObjectIdentifier should be interpoled into the description string, but that ObjectIdentifier expresses what you want.<br></p><p>The ObjectIdentifier IMHO has potential for more - a lot of various debugging purposes come to mind since it can point to an object that is no longer allocated. In this sense, it could also hold dynamicType of the object it was created with, but that&#39;s purely additive, so I left it out of this proposal.<br></p><p>I still believe that the ObjectIdentifier is missing the &quot;unsafeAddress&quot; property that would expose the already-contained internal raw pointer. And for most uses of the current unsafeAddressOf, this is the equivalent behavior.<br></p><p>As Xiaodi has mentioned as an argument for keeping both withUnsafePointer and withUnsafeMutablePointer for the sake of readibility and expressing your intentions, this is a similar case:<br></p><p>print(Unmanaged.takeUnretained(obj))<br></p><p>vs.<br></p><p>print(ObjectIdentifer(obj).unsafeAddress)<br></p><p>The first doesn&#39;t express the intentions at all, while the latter does. Using the first one seems like an abuse of the fact that the &quot;Unretained&quot; returns the same address - AFAIK, if you have an ObjC class that implements its own retain selector, it can theoretically return another value via takeRetained.<br></p><p>Or, another alternative is to use<br></p><p>unsafeBitCast(obj, to: UnsafePointer&lt;Void&gt;.self)<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 02:00:00am</p></header><div class="content"><p>On Sat, Jul 23, 2016 at 1:52 AM, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 22, 2016, at 10:37 PM, Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Fri, Jul 22, 2016 at 11:16 AM, Bob Wilson via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; I have been looking at the parts of this proposal related to<br>&gt; &gt;&gt; withUnsafe[Mutable]Pointer:<br>&gt; &gt;&gt;<br>&gt; &gt; [...]<br>&gt; &gt;<br>&gt; &gt; I agree with everything that Bob said, and I would like to comment on<br>&gt; this part:<br>&gt; &gt;<br>&gt; &gt;&gt; unsafeAddressOf is removed, in favor of adding a unsafeAddress field on<br>&gt; ObjectIdentifier. ObjectIdentifier already contains a raw pointer in the<br>&gt; internal _value field and can be initialized with AnyObject just like the<br>&gt; argument of unsafeAddressOf.<br>&gt; &gt;<br>&gt; &gt; I think we should not add the ObjectIdentifier.unsafeAddress API.  I<br>&gt; &gt; don&#39;t agree with the motivation from the proposal:<br>&gt; &gt;<br>&gt; &gt;&gt; Remove unsafeAddressOf and use Unmanaged.takeUnretainedValue(_:)<br>&gt; instead. This, however, requires the caller to deal with retain logic for<br>&gt; something as simple as getting an object address.<br>&gt; &gt;<br>&gt; &gt; We want users to be explicit about their reference counting semantics<br>&gt; &gt; when working unsafely with object addresses.  Otherwise it is not<br>&gt; &gt; clear for how long the resulting pointer is valid.  Getting an unsafe<br>&gt; &gt; object address is not &quot;simple&quot;, it is not commonly when working with<br>&gt; &gt; Swift or Objective-C APIs, and there should be no need to have<br>&gt; &gt; shorthand convenience syntax for it.  The current way to perform<br>&gt; &gt; manual reference counting and bridging of objects to the unsafe world<br>&gt; &gt; is through Unmanaged, so the conversion from object to a pointer<br>&gt; &gt; should be on Unmanaged (where it is now).<br>&gt;<br>&gt; The general consensus on where the unsafeAddressOf is used the mosed has<br>&gt; been settled (here in the original discussion and what I&#39;ve googled on<br>&gt; Stackoverflow) on that it&#39;s mostly used for logging an object address as<br>&gt; part of description or debugDescription (or various other debugging<br>&gt; purposes).<br>&gt;<br>&gt; In the original discussion about the pointer and buffer routines cleanup<br>&gt; here Jordan suggested using ObjectIdentifier instead (<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/23168) - and I<br>&gt; have to agree with him. Not that the entire ObjectIdentifier should be<br>&gt; interpoled into the description string, but that ObjectIdentifier expresses<br>&gt; what you want.<br>&gt;<br></p><p>ObjectIdentifier itself conforms to Hashable, and I recently patched it to<br>be CustomDebugStringConvertible, so that you can not only compare<br>ObjectIdentifier instances to know if objects live at the same address, you<br>can now log a unique debug description for each instance. That should be<br>sufficient for most use cases you describe above. If you actually need the<br>*address* and not just some identifier for the object (presumably because<br>you&#39;ll use that information to do something at that address), then surely<br>you should explicitly indicate what you&#39;re doing about reference counting.<br></p><p><br>&gt; The ObjectIdentifier IMHO has potential for more - a lot of various<br>&gt; debugging purposes come to mind since it can point to an object that is no<br>&gt; longer allocated. In this sense, it could also hold dynamicType of the<br>&gt; object it was created with, but that&#39;s purely additive, so I left it out of<br>&gt; this proposal.<br>&gt;<br>&gt; I still believe that the ObjectIdentifier is missing the &quot;unsafeAddress&quot;<br>&gt; property that would expose the already-contained internal raw pointer. And<br>&gt; for most uses of the current unsafeAddressOf, this is the equivalent<br>&gt; behavior.<br>&gt;<br>&gt; As Xiaodi has mentioned as an argument for keeping both withUnsafePointer<br>&gt; and withUnsafeMutablePointer for the sake of readibility and expressing<br>&gt; your intentions, this is a similar case:<br>&gt;<br>&gt; print(Unmanaged.takeUnretained(obj))<br>&gt;<br>&gt; vs.<br>&gt;<br>&gt; print(ObjectIdentifer(obj).unsafeAddress)<br>&gt;<br>&gt; The first doesn&#39;t express the intentions at all, while the latter does.<br>&gt; Using the first one seems like an abuse of the fact that the &quot;Unretained&quot;<br>&gt; returns the same address - AFAIK, if you have an ObjC class that implements<br>&gt; its own retain selector, it can theoretically return another value via<br>&gt; takeRetained.<br>&gt;<br>&gt; Or, another alternative is to use<br>&gt;<br>&gt; unsafeBitCast(obj, to: UnsafePointer&lt;Void&gt;.self)<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Dmitri<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; &gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/d61a18a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; &gt; We want users to be explicit about their reference counting semantics<br>&gt; &gt; when working unsafely with object addresses.  Otherwise it is not<br>&gt; &gt; clear for how long the resulting pointer is valid.  Getting an unsafe<br>&gt; &gt; object address is not &quot;simple&quot;, it is not commonly when working with<br>&gt; &gt; Swift or Objective-C APIs, and there should be no need to have<br>&gt; &gt; shorthand convenience syntax for it.  The current way to perform<br>&gt; &gt; manual reference counting and bridging of objects to the unsafe world<br>&gt; &gt; is through Unmanaged, so the conversion from object to a pointer<br>&gt; &gt; should be on Unmanaged (where it is now).<br></p><p>Thanks for the patch. Nevertheless, see how ObjC prints an object:<br></p><p>&lt;NSView: 0x7fc9d11b2640&gt;<br></p><p>Using the ObjectIdentifier to mimic this behavior (using current implementation), you get<br></p><p>&lt;NSView: ObjectIdentifier(0x7fc9d11b2640)&gt;<br></p><p>Not everyone needs to be happy with this. Yes, you could really do this now:<br></p><p>let identifier = ObjectIdentifier(obj)<br>let ptr = (nil as UnsafePointer&lt;Void&gt;).advancedBy(Int(identifier.uintValue))<br></p><p>Since you can get the uintValue, which is in fact the numeric value of the pointer, I don&#39;t see the harm in exposing the pointer value as well, explicitly naming it &quot;unsafeAddress&quot;.<br></p><p>&gt; <br>&gt; The general consensus on where the unsafeAddressOf is used the mosed has been settled (here in the original discussion and what I&#39;ve googled on Stackoverflow) on that it&#39;s mostly used for logging an object address as part of description or debugDescription (or various other debugging purposes).<br>&gt; <br>&gt; In the original discussion about the pointer and buffer routines cleanup here Jordan suggested using ObjectIdentifier instead (http://article.gmane.org/gmane.comp.lang.swift.evolution/23168 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/23168&gt;) - and I have to agree with him. Not that the entire ObjectIdentifier should be interpoled into the description string, but that ObjectIdentifier expresses what you want.<br>&gt; <br>&gt; ObjectIdentifier itself conforms to Hashable, and I recently patched it to be CustomDebugStringConvertible, so that you can not only compare ObjectIdentifier instances to know if objects live at the same address, you can now log a unique debug description for each instance. That should be sufficient for most use cases you describe above. If you actually need the *address* and not just some identifier for the object (presumably because you&#39;ll use that information to do something at that address), then surely you should explicitly indicate what you&#39;re doing about reference counting.<br>&gt; <br>&gt; <br>&gt; The ObjectIdentifier IMHO has potential for more - a lot of various debugging purposes come to mind since it can point to an object that is no longer allocated. In this sense, it could also hold dynamicType of the object it was created with, but that&#39;s purely additive, so I left it out of this proposal.<br>&gt; <br>&gt; I still believe that the ObjectIdentifier is missing the &quot;unsafeAddress&quot; property that would expose the already-contained internal raw pointer. And for most uses of the current unsafeAddressOf, this is the equivalent behavior.<br>&gt; <br>&gt; As Xiaodi has mentioned as an argument for keeping both withUnsafePointer and withUnsafeMutablePointer for the sake of readibility and expressing your intentions, this is a similar case:<br>&gt; <br>&gt; print(Unmanaged.takeUnretained(obj))<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt; print(ObjectIdentifer(obj).unsafeAddress)<br>&gt; <br>&gt; The first doesn&#39;t express the intentions at all, while the latter does. Using the first one seems like an abuse of the fact that the &quot;Unretained&quot; returns the same address - AFAIK, if you have an ObjC class that implements its own retain selector, it can theoretically return another value via takeRetained.<br>&gt; <br>&gt; Or, another alternative is to use<br>&gt; <br>&gt; unsafeBitCast(obj, to: UnsafePointer&lt;Void&gt;.self)<br>&gt; <br>&gt; &gt;<br>&gt; &gt; Dmitri<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; &gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160724/b3241eef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
