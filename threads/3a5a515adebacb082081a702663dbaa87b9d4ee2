<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  4, 2016 at 05:00:00pm</p></header><div class="content"><p>on Fri Mar 04 2016, Patrick Pijnappel &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;<br>&gt;&gt; What algorithms or components can be simplified by taking advantage of this<br>&gt;&gt; extra guarantee?<br>&gt;<br>&gt; Any generator that somehow buffers their underlying generator (as it can&#39;t<br>&gt; tell whether it already tried to refill the buffer). For example UTF8 &amp;<br>&gt; UTF16&#39;s decode() both have 3 instead of 2 branches on ASCII input because<br>&gt; of this.<br>&gt;<br>&gt;&gt; Off the top of my head: a stream of random numbers that stops when it<br>&gt;&gt; encounters<br>&gt;&gt; a zero.<br>&gt;<br>&gt; You could generate the next random number in advance (you take a O(1) hit<br>&gt; instead of O(n)). Of course consuming more than you need is not always<br>&gt; allowed and the O(1) could outweigh the branch.<br>&gt;<br>&gt; Overall I&#39;d say performance-wise both categories are small (though taking<br>&gt; the standard library as sample case, we have some examples of the former<br>&gt; but not the latter).<br>&gt;<br>&gt; We&#39;d be left with the safety concern of code which fails in rare corner<br>&gt; cases.<br></p><p>Thanks, this is helpful.  I&#39;m leaning in favor of making the change.<br></p><p>&gt; On Sat, Mar 5, 2016 at 11:30 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Mar 03 2016, Patrick Pijnappel &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Hmm I see.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Do we have any example cases where returning nil repeatedly would require<br>&gt;&gt; &gt; extra branches or state?<br>&gt;&gt;<br>&gt;&gt; Off the top of my head: a stream of random numbers that stops when it<br>&gt;&gt; encounters a zero.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The generators in the standard library don&#39;t (*) – the usual pattern is<br>&gt;&gt; &gt; either of the following:<br>&gt;&gt; &gt; - 1) Check state if we&#39;re at end, if so return nil 2) get return value 3)<br>&gt;&gt; &gt; advance state. Since the state is not mutated before returning nil,<br>&gt;&gt; &gt; repeating nil is automatic.<br>&gt;&gt; &gt; - 1) Call next() on one or more wrapped generators 2) return some<br>&gt;&gt; &gt; transformation of that. If the wrapped generators repeat nil, repeating<br>&gt;&gt; nil<br>&gt;&gt; &gt; is also automatic for the wrapper.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you would have a generator setup that doesn&#39;t automatically repeat<br>&gt;&gt; nil,<br>&gt;&gt; &gt; omitting a nil-repeat check might be dangerous considering the risk other<br>&gt;&gt; &gt; code hadn&#39;t considered the case.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; (*) StrideThroughGenerator &amp; ZipGenerator have a done flag, but need<br>&gt;&gt; these<br>&gt;&gt; &gt; even without repeating nil. JoinGenerator has an .End state but actually<br>&gt;&gt; &gt; doesn&#39;t have to – even to repeat nil.<br>&gt;&gt;<br>&gt;&gt; What algorithms or components can be simplified by taking advantage of<br>&gt;&gt; this extra guarantee?  If the category of code that can use it is<br>&gt;&gt; broader than the category of generators that would suffer an overhead or<br>&gt;&gt; implementation complexity, it might be worth doing.<br>&gt;&gt;<br>&gt;&gt; My intuition is that both categories are small.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Thu, Mar 3, 2016 at 8:12 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Wed, Mar 2, 2016 at 10:47 PM, Patrick Pijnappel via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt; Situation<br>&gt;&gt; &gt;&gt; &gt; Currently GeneratorType.next() requires callers to not call next()<br>&gt;&gt; after<br>&gt;&gt; &gt;&gt; it<br>&gt;&gt; &gt;&gt; &gt; has returned nil once, even encouraging a preconditionFailure() if<br>&gt;&gt; this<br>&gt;&gt; &gt;&gt; is<br>&gt;&gt; &gt;&gt; &gt; violated:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;   /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt;&gt; &gt;&gt; &gt;   ///   since the copy was made, and no preceding call to<br>&gt;&gt; `self.next()`<br>&gt;&gt; &gt;&gt; &gt;   ///   has returned `nil`.  Specific implementations of this protocol<br>&gt;&gt; &gt;&gt; &gt;   ///   are encouraged to respond to violations of this requirement by<br>&gt;&gt; &gt;&gt; &gt;   ///   calling `preconditionFailure(&quot;...&quot;)`.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;d like to add more context to this discussion.  We added this<br>&gt;&gt; &gt;&gt; requirement a while ago.  [1]  The reason for introducing it was not<br>&gt;&gt; &gt;&gt; an attempt to flag bugs in client code.  Rather, we were not convinced<br>&gt;&gt; &gt;&gt; that all generators can return nil repeatedly without loss of<br>&gt;&gt; &gt;&gt; efficiency or extra storage burden.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; [1]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; https://github.com/apple/swift/commit/304b4f33ae74a5abd09da485bbc435dfa2ade522<br>&gt;&gt; &gt;&gt; and rdar://problem/17392226<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; Adds caller burden<br>&gt;&gt; &gt;&gt; &gt; To avoid breaking the requirement, the caller will not uncommonly have<br>&gt;&gt; &gt;&gt; to track extra state and branch<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I would actually say the opposite -- running a non-trivial algorithm<br>&gt;&gt; &gt;&gt; on generators is a very uncommon thing to do.  The 99% use case for<br>&gt;&gt; &gt;&gt; generators is implicit usage from the for-in loop.  This is why<br>&gt;&gt; &gt;&gt; allowing generators to be as simple as possible and pushing the<br>&gt;&gt; &gt;&gt; requirement for extra branches into non-trivial algorithms made sense<br>&gt;&gt; &gt;&gt; for us when we introduced this requirement.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; Silent corner case<br>&gt;&gt; &gt;&gt; &gt; Because basically all generators keep returning nil, it&#39;s not unlikely<br>&gt;&gt; &gt;&gt; people will write their code based on the assumption it will always<br>&gt;&gt; return<br>&gt;&gt; &gt;&gt; nil<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This is what concerns me the most about the current rules.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Dmitri<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; &gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  4, 2016 at 06:00:00pm</p></header><div class="content"><p>On Fri, Mar 4, 2016 at 5:51 PM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; on Fri Mar 04 2016, Patrick Pijnappel &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What algorithms or components can be simplified by taking advantage of this<br>&gt;&gt;&gt; extra guarantee?<br>&gt;&gt;<br>&gt;&gt; Any generator that somehow buffers their underlying generator (as it can&#39;t<br>&gt;&gt; tell whether it already tried to refill the buffer). For example UTF8 &amp;<br>&gt;&gt; UTF16&#39;s decode() both have 3 instead of 2 branches on ASCII input because<br>&gt;&gt; of this.<br>&gt;&gt;<br>&gt;&gt;&gt; Off the top of my head: a stream of random numbers that stops when it<br>&gt;&gt;&gt; encounters<br>&gt;&gt;&gt; a zero.<br>&gt;&gt;<br>&gt;&gt; You could generate the next random number in advance (you take a O(1) hit<br>&gt;&gt; instead of O(n)). Of course consuming more than you need is not always<br>&gt;&gt; allowed and the O(1) could outweigh the branch.<br>&gt;&gt;<br>&gt;&gt; Overall I&#39;d say performance-wise both categories are small (though taking<br>&gt;&gt; the standard library as sample case, we have some examples of the former<br>&gt;&gt; but not the latter).<br>&gt;&gt;<br>&gt;&gt; We&#39;d be left with the safety concern of code which fails in rare corner<br>&gt;&gt; cases.<br>&gt;<br>&gt; Thanks, this is helpful.  I&#39;m leaning in favor of making the change.<br></p><p>After thinking about this more, in context of implementation<br>experience, existing generators in the library, I&#39;m also in favor of<br>providing this guarantee.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March  5, 2016 at 02:00:00pm</p></header><div class="content"><p>Pull-request for the change here: https://github.com/apple/swift/pull/1544<br></p><p>On Sat, Mar 5, 2016 at 1:18 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Mar 4, 2016 at 5:51 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; on Fri Mar 04 2016, Patrick Pijnappel &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What algorithms or components can be simplified by taking advantage of<br>&gt; this<br>&gt; &gt;&gt;&gt; extra guarantee?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Any generator that somehow buffers their underlying generator (as it<br>&gt; can&#39;t<br>&gt; &gt;&gt; tell whether it already tried to refill the buffer). For example UTF8 &amp;<br>&gt; &gt;&gt; UTF16&#39;s decode() both have 3 instead of 2 branches on ASCII input<br>&gt; because<br>&gt; &gt;&gt; of this.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Off the top of my head: a stream of random numbers that stops when it<br>&gt; &gt;&gt;&gt; encounters<br>&gt; &gt;&gt;&gt; a zero.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You could generate the next random number in advance (you take a O(1)<br>&gt; hit<br>&gt; &gt;&gt; instead of O(n)). Of course consuming more than you need is not always<br>&gt; &gt;&gt; allowed and the O(1) could outweigh the branch.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Overall I&#39;d say performance-wise both categories are small (though<br>&gt; taking<br>&gt; &gt;&gt; the standard library as sample case, we have some examples of the former<br>&gt; &gt;&gt; but not the latter).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We&#39;d be left with the safety concern of code which fails in rare corner<br>&gt; &gt;&gt; cases.<br>&gt; &gt;<br>&gt; &gt; Thanks, this is helpful.  I&#39;m leaning in favor of making the change.<br>&gt;<br>&gt; After thinking about this more, in context of implementation<br>&gt; experience, existing generators in the library, I&#39;m also in favor of<br>&gt; providing this guarantee.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/fa19f9cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
