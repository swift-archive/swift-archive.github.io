<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 22, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 22, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 22 2016, David Waite &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Today, a Sequence differs from a Collection in that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - A sequence can be infinitely or indefinitely sized, or could require<br>&gt;&gt;&gt; an O(n) operation to count the values in the sequence. <br>&gt;&gt; <br>&gt;&gt; The latter being no different from Collection.<br>&gt;&gt; <br>&gt;&gt;&gt; A collection has a finite number of elements, and the fixed size is<br>&gt;&gt;&gt; exposed as an O(1) or O(n) operation via ‘count’<br>&gt;&gt; <br>&gt;&gt; I don&#39;t believe we&#39;ve actually nailed down that Collection is finite.<br>&gt;&gt; <br>&gt;&gt; Oh, gee, Nate&#39;s documentation edits do<br>&gt;&gt; that. (https://github.com/apple/swift/commit/6e274913)<br>&gt;&gt; Nate, did we discuss this explicitly or did it slip in unnoticed?<br>&gt;&gt; <br>&gt;&gt; The one crucial distinction in Collection is that you can make multiple<br>&gt;&gt; passes over the same elements.<br>&gt;&gt; <br>&gt;&gt;&gt; - A collection is indexable, with those indices being usable for<br>&gt;&gt;&gt; various operations including forming subsets, comparisons, and manual<br>&gt;&gt;&gt; iteration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - A sequence may or may not be destructive, where a destructive<br>&gt;&gt;&gt; sequence consumes elements during traversal, making them unavailable<br>&gt;&gt;&gt; on subsequent traversals. Collection operations are required to be<br>&gt;&gt;&gt; non-destructive<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to Pitch removing this third differentiation, the option<br>&gt;&gt;&gt; for destructive sequences.<br>&gt;&gt; <br>&gt;&gt; I have been strongly considering this direction myself, and it&#39;s<br>&gt;&gt; something we need to decide about for Swift 3.<br>&gt;<br>&gt; I believe this is a problem that should be solved.  <br>&gt;<br>&gt; I also believe distinguishing between finite and infinite sequences is<br>&gt; a good idea (along with preventing for..in from being used with an<br>&gt; infinite sequence)<br></p><p>for..in over an infinite sequence is not necessarily wrong.  I&#39;m not<br>confident it should be prevented.  It&#39;s certainly less dangerous than<br>using `forEach`, from which there is no possibility of escape.<br></p><p>&gt;&gt;&gt; My main motivation for proposing this is the potential for developer<br>&gt;&gt;&gt; confusion. As stated during one of the previous threads on the naming<br>&gt;&gt;&gt; of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>&gt;&gt;&gt; naming requirement not typical of the rest of the Swift standard<br>&gt;&gt;&gt; library in that many methods on Sequence may or may not be<br>&gt;&gt;&gt; destructive. As such, naming methods for any extensions on Sequence is<br>&gt;&gt;&gt; challenging as the names need to not imply immutability.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the names are really the worst potential cause of<br>&gt;&gt; confusion here.  There&#39;s also the fact that you can conform to Sequence<br>&gt;&gt; with a destructively-traversed “value type” that has no mutating<br>&gt;&gt; methods.<br>&gt;<br>&gt; I agree, names are not the primary issue.  <br>&gt;<br>&gt; Another issue is that you cannot currently write generic code that<br>&gt; might need to iterate a sequence more than once.  You currently have<br>&gt; to over-constrain types to `Collection` even if you don’t need to do<br>&gt; anything other than iterate the elements (the discussion about whether<br>&gt; `LazyFilterSequnce` has a bug in its `underestimateCount` is relevant<br>&gt; here).<br></p><p>That&#39;s not an over-constraint.  Multi-pass-ness *is* the fundamental<br>distinction between Sequence and Collection.  AFAIK there&#39;s no multipass<br>sequence that cannot support indices.<br></p><p>&gt;&gt;&gt; It would still be possible to have Generators which operate<br>&gt;&gt; <br>&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt; <br>&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt; <br>&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt; detail here:<br>&gt;&gt; <br>&gt;&gt; * Would you remove Sequence?<br>&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt; * If not, would you remove Collection?<br>&gt;&gt; * What role would Iterator play?<br>&gt;<br>&gt; If we’re going to consider alternative designs it is worth considering<br>&gt; the semantic space available.  For the sake of discussion, here is a<br>&gt; model that captures the various semantics that exist (the names are<br>&gt; just strawmen):<br>&gt;<br>&gt;                            Iterable <br>&gt;                            /          \<br>&gt;                           /             \<br>&gt;                          /               \<br>&gt;     FiniteIterable                 MultipassIterable<br>&gt;                         \                 /<br>&gt;                           \              / <br>&gt;                            \            /<br>&gt;                           Sequence<br>&gt;                                  |<br>&gt;                                  |<br>&gt;                           Collection<br>&gt;<br>&gt; `Iterable` corresponds to the current `Sequence` - no semantics beyond<br>&gt; iteration are required.  Infinite, single-pass “sequences” may<br>&gt; conform.<br></p><p>Just to keep things straight, let&#39;s please adjust one thing at a time.<br>Adding new concepts should be separated from renaming existing ones.  I<br>don&#39;t want to have to qualify “Sequence” every time I use it in this<br>thread to clarify whether I mean the existing one or what you&#39;re<br>proposing.<br></p><p>&gt; `for..in` naturally requires `FiniteIterable`, <br></p><p>I&#39;m less than confident.  <br></p><p>FWIW, I&#39;m also not entirely confident that single-pass things should be<br>part of *this* picture at all.  It might be that single-pass things<br>should be entirely separate and forced to be reference types where<br>traversal mutates the instance.  E.g., the current Iterator could gain a<br>class constraint and become the only representation of single-pass<br>sequences.<br></p><p>&gt; but does not require the `MultipassIterable`.<br>&gt;<br>&gt; There are many interesting infinite `MultipassIterable` types.  These<br>&gt; include any dynamically generated sequence, such as a mathematical<br>&gt; sequence (even numbers, odd numbers, etc).  <br></p><p>These are all potential Collections, AFAICT.  I see no reason they<br>shouldn&#39;t be treated as such.<br></p><p>&gt; This is also what the existing `Sequence` would become if we drop<br>&gt; support for destructive sequences and do nothing else (note: it would<br>&gt; still be possible to accidentally write a `for..in` loop over an<br>&gt; infinite sequence).<br>&gt;<br>&gt; Under this model `Sequence` brings together `FiniteIterable` and<br>&gt; `MultipassIterable`.  This describes the most common models of<br>&gt; `Sequence`, can safely be used in a `for..in` loop, and does support<br>&gt; “destructive” single pass sequences.<br>&gt;<br>&gt; `FiniteIterable` and `MultipassIterable` introduce independent and<br>&gt; important semantic requirements.  If we’re going to consider changes<br>&gt; here, I think it is worth at least considering introducing the<br>&gt; distinction.<br>&gt;<br>&gt; This is obviously much more complex than than the current design.  <br></p><p>Another reason I&#39;m reluctant.  Whatever we do, IMO, should simplify things.<br></p><p>&gt; The most obvious simplification would be to drop `Iterable` if we<br>&gt; don’t have any compelling use cases for infinite, single pass<br>&gt; sequences.  One downside to doing this is that the syntactic<br>&gt; requirements would need to be repeated in both `FiniteIterable` and<br>&gt; `MultipassIterable`<br>&gt;<br>&gt; Another obvious simplification would be to also remove `Sequence`<br>&gt; (which becomes a “convenience” protocol under this model) and require<br>&gt; types that can conform to both `FiniteIterable` and<br>&gt; `MultipassIterable` to do so directly.<br>&gt;<br>&gt; If chose to make both simplifications we could also rename the<br>&gt; remaining `FiniteIterable` and `MultipassIterable` to something<br>&gt; simpler like `Iterable` and `Sequence`.<br>&gt;<br>&gt;                (for..in)              (the existing `Sequence` with an additional multipass semantic requirement) <br>&gt;                Iterable             Sequence  <br>&gt;                         \                 /<br>&gt;                           \              / <br>&gt;                            \            /<br>&gt;                           Collection<br>&gt;<br>&gt; I’m interested in hearing what others think about this way of thinking about the available design space.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 6:41 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Today, a Sequence differs from a Collection in that:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - A sequence can be infinitely or indefinitely sized, or could require<br>&gt;&gt;&gt;&gt; an O(n) operation to count the values in the sequence. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter being no different from Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A collection has a finite number of elements, and the fixed size is<br>&gt;&gt;&gt;&gt; exposed as an O(1) or O(n) operation via ‘count’<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t believe we&#39;ve actually nailed down that Collection is finite.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, gee, Nate&#39;s documentation edits do<br>&gt;&gt;&gt; that. (https://github.com/apple/swift/commit/6e274913)<br>&gt;&gt;&gt; Nate, did we discuss this explicitly or did it slip in unnoticed?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The one crucial distinction in Collection is that you can make multiple<br>&gt;&gt;&gt; passes over the same elements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - A collection is indexable, with those indices being usable for<br>&gt;&gt;&gt;&gt; various operations including forming subsets, comparisons, and manual<br>&gt;&gt;&gt;&gt; iteration<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - A sequence may or may not be destructive, where a destructive<br>&gt;&gt;&gt;&gt; sequence consumes elements during traversal, making them unavailable<br>&gt;&gt;&gt;&gt; on subsequent traversals. Collection operations are required to be<br>&gt;&gt;&gt;&gt; non-destructive<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to Pitch removing this third differentiation, the option<br>&gt;&gt;&gt;&gt; for destructive sequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have been strongly considering this direction myself, and it&#39;s<br>&gt;&gt;&gt; something we need to decide about for Swift 3.<br>&gt;&gt; <br>&gt;&gt; I believe this is a problem that should be solved.  <br>&gt;&gt; <br>&gt;&gt; I also believe distinguishing between finite and infinite sequences is<br>&gt;&gt; a good idea (along with preventing for..in from being used with an<br>&gt;&gt; infinite sequence)<br>&gt; <br>&gt; for..in over an infinite sequence is not necessarily wrong.  I&#39;m not<br>&gt; confident it should be prevented.  It&#39;s certainly less dangerous than<br>&gt; using `forEach`, from which there is no possibility of escape.<br></p><p>Sure, it’s not wrong in the sense that sometimes an infinite loop is valid.  But I think it would almost always be wrong (an accident) in practice.  If you really want to loop over an infinite sequence maybe it’s a good thing to require you to do that explicitly.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; My main motivation for proposing this is the potential for developer<br>&gt;&gt;&gt;&gt; confusion. As stated during one of the previous threads on the naming<br>&gt;&gt;&gt;&gt; of map, flatMap, filter, etc. methods on Sequence, Sequence has a<br>&gt;&gt;&gt;&gt; naming requirement not typical of the rest of the Swift standard<br>&gt;&gt;&gt;&gt; library in that many methods on Sequence may or may not be<br>&gt;&gt;&gt;&gt; destructive. As such, naming methods for any extensions on Sequence is<br>&gt;&gt;&gt;&gt; challenging as the names need to not imply immutability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think the names are really the worst potential cause of<br>&gt;&gt;&gt; confusion here.  There&#39;s also the fact that you can conform to Sequence<br>&gt;&gt;&gt; with a destructively-traversed “value type” that has no mutating<br>&gt;&gt;&gt; methods.<br>&gt;&gt; <br>&gt;&gt; I agree, names are not the primary issue.  <br>&gt;&gt; <br>&gt;&gt; Another issue is that you cannot currently write generic code that<br>&gt;&gt; might need to iterate a sequence more than once.  You currently have<br>&gt;&gt; to over-constrain types to `Collection` even if you don’t need to do<br>&gt;&gt; anything other than iterate the elements (the discussion about whether<br>&gt;&gt; `LazyFilterSequnce` has a bug in its `underestimateCount` is relevant<br>&gt;&gt; here).<br>&gt; <br>&gt; That&#39;s not an over-constraint.  Multi-pass-ness *is* the fundamental<br>&gt; distinction between Sequence and Collection.  AFAIK there&#39;s no multipass<br>&gt; sequence that cannot support indices.<br></p><p>If we do nail down that Collection has to be finite then this is not the case.  There are infinite multipass sequences.<br></p><p>If we require Sequence to be multipass (that is the same as removing destructive consumption, isn’t it?) then what would be the distinction between Sequence and Collection?  The fact that we are making Collection finite?<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; It would still be possible to have Generators which operate<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt; * If not, would you remove Collection?<br>&gt;&gt;&gt; * What role would Iterator play?<br>&gt;&gt; <br>&gt;&gt; If we’re going to consider alternative designs it is worth considering<br>&gt;&gt; the semantic space available.  For the sake of discussion, here is a<br>&gt;&gt; model that captures the various semantics that exist (the names are<br>&gt;&gt; just strawmen):<br>&gt;&gt; <br>&gt;&gt;                           Iterable <br>&gt;&gt;                           /          \<br>&gt;&gt;                          /             \<br>&gt;&gt;                         /               \<br>&gt;&gt;    FiniteIterable                 MultipassIterable<br>&gt;&gt;                        \                 /<br>&gt;&gt;                          \              / <br>&gt;&gt;                           \            /<br>&gt;&gt;                          Sequence<br>&gt;&gt;                                 |<br>&gt;&gt;                                 |<br>&gt;&gt;                          Collection<br>&gt;&gt; <br>&gt;&gt; `Iterable` corresponds to the current `Sequence` - no semantics beyond<br>&gt;&gt; iteration are required.  Infinite, single-pass “sequences” may<br>&gt;&gt; conform.<br>&gt; <br>&gt; Just to keep things straight, let&#39;s please adjust one thing at a time.<br>&gt; Adding new concepts should be separated from renaming existing ones.  I<br>&gt; don&#39;t want to have to qualify “Sequence” every time I use it in this<br>&gt; thread to clarify whether I mean the existing one or what you&#39;re<br>&gt; proposing.<br>&gt; <br></p><p>I should have avoided using the name “Sequence” here just to keep things more clear.  Sorry about that.<br></p><p>&gt;&gt; `for..in` naturally requires `FiniteIterable`, <br>&gt; <br>&gt; I&#39;m less than confident.  <br></p><p>See above.<br></p><p>&gt; <br>&gt; FWIW, I&#39;m also not entirely confident that single-pass things should be<br>&gt; part of *this* picture at all.  It might be that single-pass things<br>&gt; should be entirely separate and forced to be reference types where<br>&gt; traversal mutates the instance.  <br></p><p>This seems like a reasonable direction.<br></p><p>&gt; E.g., the current Iterator could gain a<br>&gt; class constraint and become the only representation of single-pass<br>&gt; sequences.<br></p><p>Hmm.  I would have to give this more thought.  Do we really want to require all conformances of `Iterator` to be reference types?  What would be the performance impact of that?<br></p><p>&gt; <br>&gt;&gt; but does not require the `MultipassIterable`.<br>&gt;&gt; <br>&gt;&gt; There are many interesting infinite `MultipassIterable` types.  These<br>&gt;&gt; include any dynamically generated sequence, such as a mathematical<br>&gt;&gt; sequence (even numbers, odd numbers, etc).  <br>&gt; <br>&gt; These are all potential Collections, AFAICT.  I see no reason they<br>&gt; shouldn&#39;t be treated as such.<br></p><p>If we allow Collections to be infinite.<br></p><p>&gt; <br>&gt;&gt; This is also what the existing `Sequence` would become if we drop<br>&gt;&gt; support for destructive sequences and do nothing else (note: it would<br>&gt;&gt; still be possible to accidentally write a `for..in` loop over an<br>&gt;&gt; infinite sequence).<br>&gt;&gt; <br>&gt;&gt; Under this model `Sequence` brings together `FiniteIterable` and<br>&gt;&gt; `MultipassIterable`.  This describes the most common models of<br>&gt;&gt; `Sequence`, can safely be used in a `for..in` loop, and does support<br>&gt;&gt; “destructive” single pass sequences.<br>&gt;&gt; <br>&gt;&gt; `FiniteIterable` and `MultipassIterable` introduce independent and<br>&gt;&gt; important semantic requirements.  If we’re going to consider changes<br>&gt;&gt; here, I think it is worth at least considering introducing the<br>&gt;&gt; distinction.<br>&gt;&gt; <br>&gt;&gt; This is obviously much more complex than than the current design.  <br>&gt; <br>&gt; Another reason I&#39;m reluctant.  Whatever we do, IMO, should simplify things.<br></p><p>Sure.  I’m not actually proposing we implement this model, I am just trying to explore the design space and think through how we can simplify by introducing desirable semantic requirements.<br></p><p>I think part of the complexity of the current model is due to the protocols not introducing semantic requirements that the most heavily used models actually support.  Making it clear where multipass is valid and making a distinction between finite and infinite sequences will simplify things IMO.  Figuring out the best way to organize them is the tricky part.  I think Brent is heading in the right direction in his post.<br></p><p>&gt; <br>&gt;&gt; The most obvious simplification would be to drop `Iterable` if we<br>&gt;&gt; don’t have any compelling use cases for infinite, single pass<br>&gt;&gt; sequences.  One downside to doing this is that the syntactic<br>&gt;&gt; requirements would need to be repeated in both `FiniteIterable` and<br>&gt;&gt; `MultipassIterable`<br>&gt;&gt; <br>&gt;&gt; Another obvious simplification would be to also remove `Sequence`<br>&gt;&gt; (which becomes a “convenience” protocol under this model) and require<br>&gt;&gt; types that can conform to both `FiniteIterable` and<br>&gt;&gt; `MultipassIterable` to do so directly.<br>&gt;&gt; <br>&gt;&gt; If chose to make both simplifications we could also rename the<br>&gt;&gt; remaining `FiniteIterable` and `MultipassIterable` to something<br>&gt;&gt; simpler like `Iterable` and `Sequence`.<br>&gt;&gt; <br>&gt;&gt;               (for..in)              (the existing `Sequence` with an additional multipass semantic requirement) <br>&gt;&gt;               Iterable             Sequence  <br>&gt;&gt;                        \                 /<br>&gt;&gt;                          \              / <br>&gt;&gt;                           \            /<br>&gt;&gt;                          Collection<br>&gt;&gt; <br>&gt;&gt; I’m interested in hearing what others think about this way of thinking about the available design space.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/fb9cb75e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 7:12 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 22, 2016, at 6:41 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 22, 2016, at 3:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe this is a problem that should be solved.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also believe distinguishing between finite and infinite sequences is<br>&gt;&gt;&gt; a good idea (along with preventing for..in from being used with an<br>&gt;&gt;&gt; infinite sequence)<br>&gt;&gt; <br>&gt;&gt; for..in over an infinite sequence is not necessarily wrong.  I&#39;m not<br>&gt;&gt; confident it should be prevented.  It&#39;s certainly less dangerous than<br>&gt;&gt; using `forEach`, from which there is no possibility of escape.<br>&gt; <br>&gt; Sure, it’s not wrong in the sense that sometimes an infinite loop is valid.  But I think it would almost always be wrong (an accident) in practice.  If you really want to loop over an infinite sequence maybe it’s a good thing to require you to do that explicitly.<br>The problem is that the only way to know a loop is infinite reliably is to have the developer opt-in. <br></p><p>Also, operations on said infinite sequence might or might not be infinite - a Fibonacci sequence.first { $0 == 0 } would go forever since the sequence starts with 1 and never decreases.<br></p><p>Then we have the issue that we have finite sequences which will still take longer than the typical hardware lifetime.<br></p><p>let x = 0..&lt;Int.max #9223372036854775806<br>foo(1..&lt;Int.max) # even if foo contains a loop which evaluates a billion elements a second, will take ~292 years to complete<br></p><p>In UI programming unintentionally expensive operations are easier to detect since the runloop forms a natural watchdog. This is how spinning beachballs are born.<br></p><p>&gt;&gt; That&#39;s not an over-constraint.  Multi-pass-ness *is* the fundamental<br>&gt;&gt; distinction between Sequence and Collection.  AFAIK there&#39;s no multipass<br>&gt;&gt; sequence that cannot support indices.<br></p><p>That indices are expected to be O(1) in Collection (under penalty of documentation and/or surprise) means that there is an impact above just implementing an Iterator for implementing a Collection, is there not?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; FWIW, I&#39;m also not entirely confident that single-pass things should be<br>&gt;&gt; part of *this* picture at all.  It might be that single-pass things<br>&gt;&gt; should be entirely separate and forced to be reference types where<br>&gt;&gt; traversal mutates the instance.  <br>&gt; <br>&gt; This seems like a reasonable direction.<br>&gt; <br>&gt;&gt; E.g., the current Iterator could gain a<br>&gt;&gt; class constraint and become the only representation of single-pass<br>&gt;&gt; sequences.<br>&gt; <br>&gt; Hmm.  I would have to give this more thought.  Do we really want to require all conformances of `Iterator` to be reference types?  What would be the performance impact of that?<br></p><p>I am also unclear here - are you talking of moving the current functionality used for Iterator someplace else, or creating a new SinglePassIteratorProtocol?  <br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/8b7908bd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>There’s a great discussion going on here, and I don’t mean to distract. But I want to ask: to get an infinite sequence using the Swift standard library, you’re going to have to create one yourself, say using the new `sequence()` functions? There’s nothing built in that is already infinite, so people will know what they are creating, that’s the explicit step, and there’s no need to have safety to infinitely loop over something. And if someone accidentally creates an unwanted infinite loop, that’s a fix in the creation of the sequence, not in its looping.<br></p><p>Patrick<br></p><p>&gt; On 23 Jun 2016, at 11:12 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sure, it’s not wrong in the sense that sometimes an infinite loop is valid.  But I think it would almost always be wrong (an accident) in practice.  If you really want to loop over an infinite sequence maybe it’s a good thing to require you to do that explicitly.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/738c0670/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 6:12 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; E.g., the current Iterator could gain a<br>&gt;&gt; class constraint and become the only representation of single-pass<br>&gt;&gt; sequences.<br>&gt; <br>&gt; Hmm.  I would have to give this more thought.  Do we really want to require all conformances of `Iterator` to be reference types?  What would be the performance impact of that?<br></p><p>I wouldn’t think so.<br></p><p><br>&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt; <br>&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt; detail here:<br>&gt;&gt; <br>&gt;&gt; * Would you remove Sequence?<br>&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt; No, I would just remove the allowance in the documentation and API design for a destructive/consuming iteration. Sequence would be the interface to getting access to repeatable iteration, without the need for meeting the other requirements for Collection.<br>&gt; <br>&gt; Sequence would be what java would refer to as Iterable, C# refers to as IEnumerable&lt;&gt;, but perhaps it is closest to the Enumerable mixin module in Ruby in terms of default utility methods supplied based on an implementation of ‘each’ (forEach() in Swift). Sequence is for…in-able because Sequence defined makeIterator(). The only difference is that subsequent calls to makeIterator() are expected to return conceptually equivalent elements in the same order.<br>&gt; -DW<br></p><p>IEnumerable&lt;&gt; does not guarantee the ability to repeatedly enumerate, generally around I/O which is the same place I use a destructively iterating sequence in Swift - lazily enumerating rows from a database query.<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/df97c7c4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 5:41 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I agree, names are not the primary issue.<br>&gt;&gt; <br>&gt;&gt; Another issue is that you cannot currently write generic code that<br>&gt;&gt; might need to iterate a sequence more than once.  You currently have<br>&gt;&gt; to over-constrain types to `Collection` even if you don’t need to do<br>&gt;&gt; anything other than iterate the elements (the discussion about whether<br>&gt;&gt; `LazyFilterSequnce` has a bug in its `underestimateCount` is relevant<br>&gt;&gt; here).<br>&gt; <br>&gt; That&#39;s not an over-constraint.  Multi-pass-ness *is* the fundamental<br>&gt; distinction between Sequence and Collection.  AFAIK there&#39;s no multipass<br>&gt; sequence that cannot support indices.<br></p><p>Just wanted to communicate more around this point specifically. If Collections can be infinite (probably adding special meaning to count returning Collection.IndexDistance.max), then the only difference between Sequence and Collection is the indexes.<br></p><p>However, I’m concerned about the delta between an iterator and a full collection. For an example:<br></p><p>class FibIterator : IteratorProtocol {<br>  var last = 0, current = 1<br></p><p>  func next() -&gt; Int? {<br>    (last, current) = (current, current + last)<br>    return current<br>  }<br>}<br></p><p>If subscript indexing on collections isn&#39;t required to be an O(1) operation, I don’t see a reason for Sequence to exist - we can simply enumerate the sequence with a numeric index, and iterate up to that count to resolve. But this makes things surprising for those implementing generic algorithms across Collections.<br></p><p>I don’t see a way to get an O(1) integer index and meet all the efficiency constraints of Collection without either memoization or additional complexity on implementing FibIterator.<br></p><p>1. we could use integer indexes and use a non-recursive technique for calculating the fibonacci value at the specified index. FibIterator basically is rewritten into a function “fibonacci(at index:Int)”.<br></p><p>2. We could use a copy of FibIterator as the index, since it is a value type. FibIterator would need to implement Comparable.<br></p><p>	2a. We make the index InfiniteSequenceIndex&lt; FibIterator &gt;, where the wrapper is there to define a consistent EndIndex value.<br></p><p>	However, Collection’s index(_:offsetBy) allows for negative offsets, which would not be accomplished in O(n).<br></p><p>	2b. If FibIterator gains an extra method to become bidirectional we can support index(_:offsetBy) in O(n) time. Note that you would probably want to have a bidirectional iterator define its own endIndex.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/1954dd8f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/1954dd8f/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 26, 2016 at 07:00:00am</p></header><div class="content"><p>on Fri Jun 24 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 22, 2016, at 5:41 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I agree, names are not the primary issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another issue is that you cannot currently write generic code that<br>&gt;&gt;&gt; might need to iterate a sequence more than once.  You currently<br>&gt; have<br>&gt;&gt;&gt; to over-constrain types to `Collection` even if you don’t need to<br>&gt; do<br>&gt;&gt;&gt; anything other than iterate the elements (the discussion about<br>&gt; whether<br>&gt;&gt;&gt; `LazyFilterSequnce` has a bug in its `underestimateCount` is<br>&gt; relevant<br>&gt;&gt;&gt; here).<br>&gt;&gt; <br>&gt;&gt; That&#39;s not an over-constraint.  Multi-pass-ness *is* the fundamental<br>&gt;&gt; distinction between Sequence and Collection.  AFAIK there&#39;s no<br>&gt; multipass<br>&gt;&gt; sequence that cannot support indices.<br>&gt;<br>&gt; Just wanted to communicate more around this point specifically. If<br>&gt; Collections can be infinite (probably adding special meaning to count<br>&gt; returning Collection.IndexDistance.max), then the only difference<br>&gt; between Sequence and Collection is the indexes.<br>&gt;<br>&gt; However, I’m concerned about the delta between an iterator and a full<br>&gt; collection. For an example:<br>&gt;<br>&gt; class FibIterator : IteratorProtocol {<br>&gt;   var last = 0, current = 1<br>&gt;<br>&gt;   func next() -&gt; Int? {<br>&gt;     (last, current) = (current, current + last)<br>&gt;     return current<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; If subscript indexing on collections isn&#39;t required to be an O(1)<br>&gt; operation, I don’t see a reason for Sequence to exist - we can simply<br>&gt; enumerate the sequence with a numeric index, and iterate up to that<br>&gt; count to resolve. But this makes things surprising for those<br>&gt; implementing generic algorithms across Collections.<br>&gt;<br>&gt; I don’t see a way to get an O(1) integer index and meet all the<br>&gt; efficiency constraints of Collection without either memoization or<br>&gt; additional complexity on implementing FibIterator.<br></p><p>Indices don&#39;t have to be integers, and often arent.  You can always<br>bundle an integer with an Iterator and a single result buffer to produce<br>an Index.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
