<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br></p><p>&gt; Can you ping me off-list or in another thread and explain what the<br>&gt; issues are?<br></p><p>All of the following make me uncomfortable with our leading-dot thang:<br></p><p>* The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>  personal/subjective.<br></p><p>* There is some evidence that people think it means something it doesn&#39;t<br>  (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>  confusing feature.  That confusion may be fairly harmless so far, but<br>  still.<br></p><p>* The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>  to the language; why not just let those names be looked up without the<br>  dot?  You can always disambiguate with full qualification if you have<br>  to.<br></p><p>* Static members generally are too verbose to access from within members<br>  of a type (`Self.x` doesn&#39;t work; you have to write out<br>  `TheFullTypeName.x`), and leading-dot doesn&#39;t give the ability to do<br>  so. If we&#39;re going to have a special syntax for accessing static<br>  members, it should *at least* solve this problem.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 12:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt; <br>&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt; issues are?<br>&gt; <br>&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt; <br>&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;  personal/subjective.<br></p><p>Indeed.<br></p><p>&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;  (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;  confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;  still.<br></p><p>Noted.<br></p><p>&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;  to the language; why not just let those names be looked up without the<br>&gt;  dot?  You can always disambiguate with full qualification if you have<br>&gt;  to.<br></p><p>I kind of like the enumeration looking like an enumeration but I get your point.<br></p><p>&gt; * Static members generally are too verbose to access from within members<br>&gt;  of a type (`Self.x` doesn&#39;t work; you have to write out<br>&gt;  `TheFullTypeName.x`), and leading-dot doesn&#39;t give the ability to do<br>&gt;  so. If we&#39;re going to have a special syntax for accessing static<br>&gt;  members, it should *at least* solve this problem.<br>&gt; <br></p><p>Just happened to start a thread a little while ago:<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/13708 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13708&gt;<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/ec90f958/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt; <br>&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt; issues are?<br>&gt; <br>&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt; <br>&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;  personal/subjective.<br>&gt; <br>&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;  (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;  confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;  still.<br>&gt; <br>&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;  to the language; why not just let those names be looked up without the<br>&gt;  dot?  You can always disambiguate with full qualification if you have<br>&gt;  to.<br></p><p>Making every unqualified reference context-dependent would be impractical. `foo.bar(bas)` would become an exponential search to find a contextual type containing a `foo` which has a `bar` member that can accept an type containing a `bas` member.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt;&gt; issues are?<br>&gt;&gt; <br>&gt;&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt;&gt; <br>&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;&gt;  personal/subjective.<br>&gt;&gt; <br>&gt;&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;&gt;  (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;&gt;  confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;&gt;  still.<br>&gt;&gt; <br>&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;&gt;  to the language; why not just let those names be looked up without the<br>&gt;&gt;  dot?  You can always disambiguate with full qualification if you have<br>&gt;&gt;  to.<br>&gt;<br>&gt; Making every unqualified reference context-dependent would be<br>&gt; impractical. `foo.bar(bas)` would become an exponential search to find<br>&gt; a contextual type containing a `foo` which has a `bar` member that can<br>&gt; accept an type containing a `bas` member.<br></p><p>I don&#39;t think I&#39;m talking about making every unqualified reference<br>context-dependent.  When I have a context that demands an instance of a<br>particular enum type, I think it&#39;s reasonable to look up the names in<br>the enum without qualification, and I strongly question the value of<br>leading-dot syntax for general static member lookup.  I would normally<br>never think of using it that way—because, guess what? I think of<br>leading-dot as a notation for enums like everybody else does—and I don&#39;t<br>think there are any important idioms it supports, that couldn&#39;t be<br>equally well handled by something like `Self.x` if we were allowed to<br>use it.<br></p><p><br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 11:44 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt;&gt;&gt; issues are?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;&gt;&gt; personal/subjective.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;&gt;&gt; (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;&gt;&gt; confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;&gt;&gt; still.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;&gt;&gt; to the language; why not just let those names be looked up without the<br>&gt;&gt;&gt; dot?  You can always disambiguate with full qualification if you have<br>&gt;&gt;&gt; to.<br>&gt;&gt; <br>&gt;&gt; Making every unqualified reference context-dependent would be<br>&gt;&gt; impractical. `foo.bar(bas)` would become an exponential search to find<br>&gt;&gt; a contextual type containing a `foo` which has a `bar` member that can<br>&gt;&gt; accept an type containing a `bas` member.<br>&gt; <br>&gt; I don&#39;t think I&#39;m talking about making every unqualified reference<br>&gt; context-dependent.  When I have a context that demands an instance of a<br>&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt; the enum without qualification, and I strongly question the value of<br>&gt; leading-dot syntax for general static member lookup.<br></p><p>Therein lies the rub—*any* context an unqualified name can appear in could potentially demand an instance of a particular enum type, until the type checker rules that out. Limiting the behavior to enums doesn&#39;t simplify the implementation.<br></p><p>&gt; I would normally<br>&gt; never think of using it that way—because, guess what? I think of<br>&gt; leading-dot as a notation for enums like everybody else does—and I don&#39;t<br>&gt; think there are any important idioms it supports, that couldn&#39;t be<br>&gt; equally well handled by something like `Self.x` if we were allowed to<br>&gt; use it.<br></p><p>Enums are only the most common place where static members of Self type appear in numbers, but option sets also do. While this may be a matter of taste, being able to refer to `.max`, `.infinity`, `.nan`, or other abstract constants of numeric types in a concrete-type-agnostic way also seems like a win to me.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  4, 2016 at 12:00:00pm</p></header><div class="content"><p>on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Apr 4, 2016, at 11:44 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt;&gt;&gt;&gt; issues are?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;&gt;&gt;&gt; personal/subjective.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;&gt;&gt;&gt; (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;&gt;&gt;&gt; confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;&gt;&gt;&gt; still.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;&gt;&gt;&gt; to the language; why not just let those names be looked up without the<br>&gt;&gt;&gt;&gt; dot?  You can always disambiguate with full qualification if you have<br>&gt;&gt;&gt;&gt; to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Making every unqualified reference context-dependent would be<br>&gt;&gt;&gt; impractical. `foo.bar(bas)` would become an exponential search to find<br>&gt;&gt;&gt; a contextual type containing a `foo` which has a `bar` member that can<br>&gt;&gt;&gt; accept an type containing a `bas` member.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think I&#39;m talking about making every unqualified reference<br>&gt;&gt; context-dependent.  When I have a context that demands an instance of a<br>&gt;&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt;&gt; the enum without qualification, and I strongly question the value of<br>&gt;&gt; leading-dot syntax for general static member lookup.<br>&gt;<br>&gt; Therein lies the rub—*any* context an unqualified name can appear in<br>&gt; could potentially demand an instance of a particular enum type, until<br>&gt; the type checker rules that out. Limiting the behavior to enums<br>&gt; doesn&#39;t simplify the implementation.<br></p><p>I&#39;m afraid I don&#39;t understand how that&#39;s a serious problem yet.<br></p><p>&gt;&gt; I would normally<br>&gt;&gt; never think of using it that way—because, guess what? I think of<br>&gt;&gt; leading-dot as a notation for enums like everybody else does—and I don&#39;t<br>&gt;&gt; think there are any important idioms it supports, that couldn&#39;t be<br>&gt;&gt; equally well handled by something like `Self.x` if we were allowed to<br>&gt;&gt; use it.<br>&gt;<br>&gt; Enums are only the most common place where static members of Self type<br>&gt; appear in numbers, but option sets also do. While this may be a matter<br>&gt; of taste, being able to refer to `.max`, `.infinity`, `.nan`, or other<br>&gt; abstract constants of numeric types in a concrete-type-agnostic way<br>&gt; also seems like a win to me.<br></p><p>Agreed.  Let me ask the question differently: what value does the <br>leading `.` provide to the user of the language?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 12:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 4, 2016, at 11:44 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt;&gt;&gt;&gt;&gt; issues are?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;&gt;&gt;&gt;&gt; personal/subjective.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;&gt;&gt;&gt;&gt; confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;&gt;&gt;&gt;&gt; still.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;&gt;&gt;&gt;&gt; to the language; why not just let those names be looked up without the<br>&gt;&gt;&gt;&gt;&gt; dot?  You can always disambiguate with full qualification if you have<br>&gt;&gt;&gt;&gt;&gt; to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Making every unqualified reference context-dependent would be<br>&gt;&gt;&gt;&gt; impractical. `foo.bar(bas)` would become an exponential search to find<br>&gt;&gt;&gt;&gt; a contextual type containing a `foo` which has a `bar` member that can<br>&gt;&gt;&gt;&gt; accept an type containing a `bas` member.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think I&#39;m talking about making every unqualified reference<br>&gt;&gt;&gt; context-dependent.  When I have a context that demands an instance of a<br>&gt;&gt;&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt;&gt;&gt; the enum without qualification, and I strongly question the value of<br>&gt;&gt;&gt; leading-dot syntax for general static member lookup.<br>&gt;&gt; <br>&gt;&gt; Therein lies the rub—*any* context an unqualified name can appear in<br>&gt;&gt; could potentially demand an instance of a particular enum type, until<br>&gt;&gt; the type checker rules that out. Limiting the behavior to enums<br>&gt;&gt; doesn&#39;t simplify the implementation.<br>&gt; <br>&gt; I&#39;m afraid I don&#39;t understand how that&#39;s a serious problem yet.<br></p><p>Right now, we limit the contextual lookup to places where it&#39;s syntactically asked for, using the leading dot. Without the leading dot, we&#39;d have to extend it to every unqualified name, which makes it much more likely you&#39;ll fall into problematic cases.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>April  6, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Agreed.  Let me ask the question differently: what value does the <br>&gt; leading `.` provide to the user of the language?<br></p><p><br>I find the leading-dot syntax to be very useful; it&#39;s a pretty clear shorthand that I&#39;m not referencing something at global scope.<br></p><p>Here&#39;s a common example from our codebase:<br></p><p>completion(.Failed(.wrap(error)))<br></p><p>The completion function takes an enum value of type DataTransactionResult, of which .Failed is one case. The .Failed case takes an associated value of type DataTransactionError, which has a static function called wrap() that accepts an ErrorType and returns a DataTransactionError containing it.<br></p><p>Although .Failed is being used here in the common enum shorthand style, being able to very quickly determine that wrap() is not a global function is helpful. Without the leading dot, some context disappears:<br></p><p>completion(Failed(wrap(error)))<br></p><p>Now, it&#39;s a lot harder to tell what I&#39;m dealing with.<br></p><p>What is &#39;Failed&#39;? Is it a class with an initializer that we&#39;re passing the result of wrap(error) to? Or is it an enum case with an associated type? Further, what&#39;s wrap()? A function in the global scope? Sure looks like it!<br></p><p>If we got rid of the shorthand altogether, we end up with something much more verbose:<br></p><p>completion(DataTransactionResult.Failed(DataTransactionError.wrap(error)))<br></p><p>Yes, it&#39;s more explicit, but I would not necessarily argue that it&#39;s easier to read.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/5e4ef29b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; When I have a context that demands an instance of a<br>&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt; the enum without qualification, and I strongly question the value of<br>&gt; leading-dot syntax for general static member lookup.  I would normally<br>&gt; never think of using it that way—because, guess what? I think of<br>&gt; leading-dot as a notation for enums like everybody else does—and I don&#39;t<br>&gt; think there are any important idioms it supports, that couldn&#39;t be<br>&gt; equally well handled by something like `Self.x` if we were allowed to<br>&gt; use it.<br></p><p>Well, sure, they don&#39;t know that leading dot is more widely usable—&quot;The Swift Programming Language&quot; only mentions it in connection with enums. But once people know, they&#39;re very glad to use it.<br></p><p>I&#39;ve introduced several different people to the joys of universal leading-dot syntax, and I would characterize their reaction as *pleasant* surprise. They immediately start using the syntax for things like `.blackColor()` and `.passRetained(_:)` and `.min`, and often expand their usage beyond that. Now that unbound methods are uncurried, a small tweak to the leading dot syntax in function context will also open us up to things like `views.forEach(.removeFromSuperview)`. Lens functions may also eventually be used in this way. <br></p><p>If the feature is underused, that&#39;s because it&#39;s poorly explained, not because it&#39;s not widely desired.<br></p><p>(Besides, you probably at least use the syntax for option sets, which are enum-like but not enums.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April  4, 2016 at 06:00:00pm</p></header><div class="content"><p>I believe the confusion comes from language references only using the leading dot to access enumerated values, and not to access an option set implementation or something like UIColor.<br></p><p>I can’t speak to the compiler processing impact or language impact of potential conflicts of looking these up without the leading dot. I can see how it would be confusing for people to have a very terse syntax for looking up static members on *other* types, and expecting either that same terse syntax or something comparable for referring to static members on their *own* type. Such syntax would have to tread softly on distinguishing static vs dynamic type resolution for looking up said members.<br></p><p>-DW<br></p><p><br>&gt; On Apr 4, 2016, at 12:05 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;  (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;  confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;  still.<br>&gt; <br>&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;  to the language; why not just let those names be looked up without the<br>&gt;  dot?  You can always disambiguate with full qualification if you have<br>&gt;  to.<br>&gt; <br>&gt; * Static members generally are too verbose to access from within members<br>&gt;  of a type (`Self.x` doesn&#39;t work; you have to write out<br>&gt;  `TheFullTypeName.x`), and leading-dot doesn&#39;t give the ability to do<br>&gt;  so. If we&#39;re going to have a special syntax for accessing static<br>&gt;  members, it should *at least* solve this problem.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/4cdfcdfb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April  5, 2016 at 09:00:00am</p></header><div class="content"><p>As others noted:<br></p><p>* the ability to say .min, .max, .blackColor(), etc is extremely useful. Swift would be a lot worse off if only enum cases got their enum types inferred, and for any other static member of a type I would have type the fully qualified name<br>* the leading dot disambiguates the reference for the compiler **and for the reader**. I don’t have to guess if I’m not referencing something local, or explicitly disambiguate when needed. I just say, “.foo”, and it’s clear.<br>* I disagree that the rules of lookup are confusing. The feature is poorly documented in official guides, but it seems pretty straightforward to me. For any context implying T, .foo means a static member T.foo. Like you said, could be subjective ¯\_(ツ)_/¯<br></p><p>Best,<br>— Radek<br></p><p>&gt; On 04 Apr 2016, at 20:05, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt; <br>&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt; issues are?<br>&gt; <br>&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt; <br>&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;  personal/subjective.<br>&gt; <br>&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;  (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;  confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;  still.<br>&gt; <br>&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;  to the language; why not just let those names be looked up without the<br>&gt;  dot?  You can always disambiguate with full qualification if you have<br>&gt;  to.<br>&gt; <br>&gt; * Static members generally are too verbose to access from within members<br>&gt;  of a type (`Self.x` doesn&#39;t work; you have to write out<br>&gt;  `TheFullTypeName.x`), and leading-dot doesn&#39;t give the ability to do<br>&gt;  so. If we&#39;re going to have a special syntax for accessing static<br>&gt;  members, it should *at least* solve this problem.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 0:55 , Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As others noted:<br>&gt; <br>&gt; * the ability to say .min, .max, .blackColor(), etc is extremely useful. Swift would be a lot worse off if only enum cases got their enum types inferred, and for any other static member of a type I would have type the fully qualified name<br>&gt; * the leading dot disambiguates the reference for the compiler **and for the reader**. I don’t have to guess if I’m not referencing something local, or explicitly disambiguate when needed. I just say, “.foo”, and it’s clear.<br>&gt; * I disagree that the rules of lookup are confusing. The feature is poorly documented in official guides, but it seems pretty straightforward to me. For any context implying T, .foo means a static member T.foo. Like you said, could be subjective ¯\_(ツ)_/¯<br></p><p>I strongly agree with all of these points, especially the second.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 9:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 5, 2016, at 0:55 , Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As others noted:<br>&gt;&gt; <br>&gt;&gt; * the ability to say .min, .max, .blackColor(), etc is extremely useful. Swift would be a lot worse off if only enum cases got their enum types inferred, and for any other static member of a type I would have type the fully qualified name<br>&gt;&gt; * the leading dot disambiguates the reference for the compiler **and for the reader**. I don’t have to guess if I’m not referencing something local, or explicitly disambiguate when needed. I just say, “.foo”, and it’s clear.<br>&gt;&gt; * I disagree that the rules of lookup are confusing. The feature is poorly documented in official guides, but it seems pretty straightforward to me. For any context implying T, .foo means a static member T.foo. Like you said, could be subjective ¯\_(ツ)_/¯<br>&gt; <br>&gt; I strongly agree with all of these points, especially the second.<br></p><p>+1 to all these points.  Also, in Swift 3, “.blackColor()” becomes “.black()”.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
