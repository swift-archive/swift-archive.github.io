<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63a6ed80e3b54c31ea36dc2bf12f89e2?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Alsey Miller</string> &lt;alseycmiller at gmail.com&gt;<p>February 29, 2016 at 12:00:00am</p></header><div class="content"><p>- What is your evaluation of the proposal?<br></p><p>I am against the proposal because I feel it goes against the Protocol Oriented Programming patterns found in the Swift Standard Library. Current protocol functionality can provide a solution for the given example. If a protocol property is not implemented, the compiler will not let you compile. <br></p><p>• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No, protocols implement this functionality, but with a different syntax. There is no lacking or additional functionality this proposal provides.<br></p><p>• Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. It goes against protocol oriented programming. Furthermore, this is only for classes, structs are being excluded in this case. I feel that with most of the standard library being implemented as structs, this is not acceptable.<br></p><p>• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Similar to C# or Java abstract classes. Not much to add here.<br></p><p>• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth study. I understand the proposer’s point of view, but I feel this is only a syntax change in the wrong direction. No new functionality is being provided that protocols don’t already have.<br></p><p>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; • What is your evaluation of the proposal?<br>&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt;  <br></p><p><br>	Coleman,<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/645872b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; - What is your evaluation of the proposal?<br></p><p>I could not more strongly support the proposal to add abstract classes, functions and properties to Swift.<br></p><p>None of the proposals involving protocols as a solution to this have addressed the fundamental issue:<br></p><p>*ONLY* abstract classes ON THEIR OWN allow the compiler to enforce providing an implementation for a given function.<br></p><p>For example -- and not picking against the author of this, it&#39;s just the most recent example to grace my inbox:<br></p><p>&gt; I am against the proposal because I feel it goes against the Protocol Oriented Programming patterns found in the Swift Standard Library. Current protocol functionality can provide a solution for the given example. If a protocol property is not implemented, the compiler will not let you compile. <br></p><p>This does not address the fundamental concern of abstract classes.<br></p><p>Yes, a protocol will force you to provide an implementation. However, a protocol *by itself* cannot force the implementor of a class to provide an implementation unless that class declares itself in conformance with that protocol.<br></p><p>ONLY an abstract class, ON ITS OWN, can force concrete subclassers to provide an implementation for a given thing.<br></p><p>Protocols can&#39;t do this, because if you forget to declare conformance with the protocol, the compiler can&#39;t enforce anything. This pushes what could be caught at compile-time to a runtime (potentially crashing) problem.<br></p><p>Abstract classes enforce a requirement that a given portion of the class hierarchy provide an implementation of X.<br></p><p>&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; No, protocols implement this functionality, but with a different syntax. There is no lacking or additional functionality this proposal provides.<br></p><p>No, protocols *do not implement* this functionality. They provide something else, and are orthogonal to the class hierarchy.<br></p><p>&gt; • Does this proposal fit well with the feel and direction of Swift?<br></p><p>Absolutely. Swift is about safety, about letting the compiler perform safety checks. ONLY abstract classes allow the compiler to enforce that an implementor of a given subclass has provided an implementation for a given function.<br></p><p>Solutions that require the use of protocols can only be checked for correctness if the implementor of the subclass in question ALSO declares conformance to the protocol.<br></p><p>In other words, a protocol-based solution can only be checked by the compiler if the developer does 2 things correctly (declares protocol conformance and provides an implementation), whereas abstract classes allow the compiler to perform checks as long as the developer does 1 thing (subclass a given class).<br></p><p>&gt; No. It goes against protocol oriented programming.<br></p><p>Swift isn&#39;t ONLY about protocol oriented programming. Classes are here for a reason, and they should not be relegated to second-class status where people refuse to consider class-only functionality just because the concept can&#39;t be shoehorned into something protocol-related.<br></p><p>&gt; Furthermore, this is only for classes, structs are being excluded in this case. I feel that with most of the standard library being implemented as structs, this is not acceptable.<br></p><p>Rather than reject this proposal because &quot;this is only for classes,&quot; perhaps recognize that this is only for classes PRECISELY because this type of problem--the one that abstract classes addresses--only occurs with a class hierarchy.<br></p><p>&gt; • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>C++ and have found them EXTREMELY useful. This proposal is in line with that.<br></p><p>&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve been following this discussion very closely, and before I realized there was already a proposal in the queue for abstract classes, I also wrote a similar proposal:<br></p><p>https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/6d17a3ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Not necessarily commenting for or against abstract classes, but the<br>following logic confuses me:<br></p><p>&quot;ONLY an abstract class, ON ITS OWN, can force concrete subclassers to<br>provide an implementation for a given thing.<br></p><p>Protocols can&#39;t do this, because if you forget to declare conformance with<br>the protocol, the compiler can&#39;t enforce anything. This pushes what could<br>be caught at compile-time to a runtime (potentially crashing) problem.&quot;<br></p><p>What is the difference between forgetting to declare conformance to a<br>protocol and forgetting to subclass an abstract class? An abstract class,<br>ON ITS OWN, cannot force a class to do anything unless that class declares<br>itself a subclass of the abstract class.<br></p><p><br>On Thu, Mar 3, 2016 at 3:39 PM, Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; - What is your evaluation of the proposal?<br>&gt;<br>&gt;<br>&gt; I could not more strongly support the proposal to add abstract classes,<br>&gt; functions and properties to Swift.<br>&gt;<br>&gt; None of the proposals involving protocols as a solution to this have<br>&gt; addressed the fundamental issue:<br>&gt;<br>&gt; *ONLY* abstract classes ON THEIR OWN allow the compiler to enforce<br>&gt; providing an implementation for a given function.<br>&gt;<br>&gt; For example -- and not picking against the author of this, it&#39;s just the<br>&gt; most recent example to grace my inbox:<br>&gt;<br>&gt; I am against the proposal because I feel it goes against the Protocol<br>&gt; Oriented Programming patterns found in the Swift Standard Library. Current<br>&gt; protocol functionality can provide a solution for the given example. If a<br>&gt; protocol property is not implemented, the compiler will not let you<br>&gt; compile.<br>&gt;<br>&gt;<br>&gt; This does not address the fundamental concern of abstract classes.<br>&gt;<br>&gt; Yes, a protocol will force you to provide an implementation. However, a<br>&gt; protocol *by itself* cannot force the implementor of a class to provide an<br>&gt; implementation unless that class declares itself in conformance with that<br>&gt; protocol.<br>&gt;<br>&gt; ONLY an abstract class, ON ITS OWN, can force concrete subclassers to<br>&gt; provide an implementation for a given thing.<br>&gt;<br>&gt; Protocols can&#39;t do this, because if you forget to declare conformance with<br>&gt; the protocol, the compiler can&#39;t enforce anything. This pushes what could<br>&gt; be caught at compile-time to a runtime (potentially crashing) problem.<br>&gt;<br>&gt; Abstract classes enforce a requirement that a given portion of the class<br>&gt; hierarchy provide an implementation of X.<br>&gt;<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt; No, protocols implement this functionality, but with a different syntax.<br>&gt; There is no lacking or additional functionality this proposal provides.<br>&gt;<br>&gt;<br>&gt; No, protocols *do not implement* this functionality. They provide<br>&gt; something else, and are orthogonal to the class hierarchy.<br>&gt;<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; Absolutely. Swift is about safety, about letting the compiler perform<br>&gt; safety checks. ONLY abstract classes allow the compiler to enforce that an<br>&gt; implementor of a given subclass has provided an implementation for a given<br>&gt; function.<br>&gt;<br>&gt; Solutions that require the use of protocols can only be checked for<br>&gt; correctness if the implementor of the subclass in question ALSO declares<br>&gt; conformance to the protocol.<br>&gt;<br>&gt; In other words, a protocol-based solution can only be checked by the<br>&gt; compiler if the developer does 2 things correctly (declares protocol<br>&gt; conformance and provides an implementation), whereas abstract classes allow<br>&gt; the compiler to perform checks as long as the developer does 1 thing<br>&gt; (subclass a given class).<br>&gt;<br>&gt; No. It goes against protocol oriented programming.<br>&gt;<br>&gt;<br>&gt; Swift isn&#39;t ONLY about protocol oriented programming. Classes are here for<br>&gt; a reason, and they should not be relegated to second-class status where<br>&gt; people refuse to consider class-only functionality just because the concept<br>&gt; can&#39;t be shoehorned into something protocol-related.<br>&gt;<br>&gt; Furthermore, this is only for classes, structs are being excluded in this<br>&gt; case. I feel that with most of the standard library being implemented as<br>&gt; structs, this is not acceptable.<br>&gt;<br>&gt;<br>&gt; Rather than reject this proposal because &quot;this is only for classes,&quot;<br>&gt; perhaps recognize that this is only for classes PRECISELY because this type<br>&gt; of problem--the one that abstract classes addresses--only occurs with a<br>&gt; class hierarchy.<br>&gt;<br>&gt; • If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br>&gt;<br>&gt; C++ and have found them EXTREMELY useful. This proposal is in line with<br>&gt; that.<br>&gt;<br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt;<br>&gt; I&#39;ve been following this discussion very closely, and before I realized<br>&gt; there was already a proposal in the queue for abstract classes, I also<br>&gt; wrote a similar proposal:<br>&gt;<br>&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/f45fd40e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63a6ed80e3b54c31ea36dc2bf12f89e2?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Alsey Miller</string> &lt;alseycmiller at gmail.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>My thoughts exactly! I don’t not understand the following statement:<br></p><p>&gt; Yes, a protocol will force you to provide an implementation. However, a protocol *by itself* cannot force the implementor of a class to provide an implementation unless that class declares itself in conformance with that protocol.<br></p><p>My argument is that declaring to be the subclass of an abstract class, or declaring to be in conformance with a protocol would have the same effect. Even the syntax would be the same, e.g. <br></p><p>class ConcreteClass: AbstractSuperclass { … }<br></p><p>or <br></p><p>class ConcreteClass: ProtocolWithoutExtensions { … }<br></p><p>	Coleman,<br></p><p><br></p><p><br></p><p>&gt; On Mar 3, 2016, at 4:21 PM, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt; <br>&gt; Not necessarily commenting for or against abstract classes, but the following logic confuses me:<br>&gt; <br>&gt; &quot;ONLY an abstract class, ON ITS OWN, can force concrete subclassers to provide an implementation for a given thing.<br>&gt; <br>&gt; Protocols can&#39;t do this, because if you forget to declare conformance with the protocol, the compiler can&#39;t enforce anything. This pushes what could be caught at compile-time to a runtime (potentially crashing) problem.&quot;<br>&gt; <br>&gt; What is the difference between forgetting to declare conformance to a protocol and forgetting to subclass an abstract class? An abstract class, ON ITS OWN, cannot force a class to do anything unless that class declares itself a subclass of the abstract class.<br>&gt; <br>&gt; <br>&gt; On Thu, Mar 3, 2016 at 3:39 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; - What is your evaluation of the proposal?<br>&gt; <br>&gt; I could not more strongly support the proposal to add abstract classes, functions and properties to Swift.<br>&gt; <br>&gt; None of the proposals involving protocols as a solution to this have addressed the fundamental issue:<br>&gt; <br>&gt; *ONLY* abstract classes ON THEIR OWN allow the compiler to enforce providing an implementation for a given function.<br>&gt; <br>&gt; For example -- and not picking against the author of this, it&#39;s just the most recent example to grace my inbox:<br>&gt; <br>&gt;&gt; I am against the proposal because I feel it goes against the Protocol Oriented Programming patterns found in the Swift Standard Library. Current protocol functionality can provide a solution for the given example. If a protocol property is not implemented, the compiler will not let you compile. <br>&gt; <br>&gt; This does not address the fundamental concern of abstract classes.<br>&gt; <br>&gt; Yes, a protocol will force you to provide an implementation. However, a protocol *by itself* cannot force the implementor of a class to provide an implementation unless that class declares itself in conformance with that protocol.<br>&gt; <br>&gt; ONLY an abstract class, ON ITS OWN, can force concrete subclassers to provide an implementation for a given thing.<br>&gt; <br>&gt; Protocols can&#39;t do this, because if you forget to declare conformance with the protocol, the compiler can&#39;t enforce anything. This pushes what could be caught at compile-time to a runtime (potentially crashing) problem.<br>&gt; <br>&gt; Abstract classes enforce a requirement that a given portion of the class hierarchy provide an implementation of X.<br>&gt; <br>&gt;&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; No, protocols implement this functionality, but with a different syntax. There is no lacking or additional functionality this proposal provides.<br>&gt; <br>&gt; No, protocols *do not implement* this functionality. They provide something else, and are orthogonal to the class hierarchy.<br>&gt; <br>&gt;&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Absolutely. Swift is about safety, about letting the compiler perform safety checks. ONLY abstract classes allow the compiler to enforce that an implementor of a given subclass has provided an implementation for a given function.<br>&gt; <br>&gt; Solutions that require the use of protocols can only be checked for correctness if the implementor of the subclass in question ALSO declares conformance to the protocol.<br>&gt; <br>&gt; In other words, a protocol-based solution can only be checked by the compiler if the developer does 2 things correctly (declares protocol conformance and provides an implementation), whereas abstract classes allow the compiler to perform checks as long as the developer does 1 thing (subclass a given class).<br>&gt; <br>&gt;&gt; No. It goes against protocol oriented programming.<br>&gt; <br>&gt; Swift isn&#39;t ONLY about protocol oriented programming. Classes are here for a reason, and they should not be relegated to second-class status where people refuse to consider class-only functionality just because the concept can&#39;t be shoehorned into something protocol-related.<br>&gt; <br>&gt;&gt; Furthermore, this is only for classes, structs are being excluded in this case. I feel that with most of the standard library being implemented as structs, this is not acceptable.<br>&gt; <br>&gt; Rather than reject this proposal because &quot;this is only for classes,&quot; perhaps recognize that this is only for classes PRECISELY because this type of problem--the one that abstract classes addresses--only occurs with a class hierarchy.<br>&gt; <br>&gt;&gt; • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; C++ and have found them EXTREMELY useful. This proposal is in line with that.<br>&gt; <br>&gt;&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I&#39;ve been following this discussion very closely, and before I realized there was already a proposal in the queue for abstract classes, I also wrote a similar proposal:<br>&gt; <br>&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/7131ad75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>March  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 3 mars 2016 à 22:23, Alsey Miller via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; My thoughts exactly! I don’t not understand the following statement:<br>&gt; <br>&gt;&gt; Yes, a protocol will force you to provide an implementation. However, a protocol *by itself* cannot force the implementor of a class to provide an implementation unless that class declares itself in conformance with that protocol.<br>&gt; <br>&gt; My argument is that declaring to be the subclass of an abstract class, or declaring to be in conformance with a protocol would have the same effect. Even the syntax would be the same, e.g. <br>&gt; <br>&gt; class ConcreteClass: AbstractSuperclass { … }<br>&gt; <br>&gt; or <br>&gt; <br>&gt; class ConcreteClass: ProtocolWithoutExtensions { … }<br>&gt; <br>&gt; 	Coleman,<br>&gt; <br>Not really the same : The abstract class support encapsulation : In the abstract class, you can have private attributes and privates methods that encapsulate some kind of behavior and only some methods will be made abstract.<br></p><p>Encapsulation cannot be supported by protocols and if you want to add a full encapsulation in protocol, it will result of a kind of class in protocol syntax….<br></p><p>Regards,<br></p><p>David<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/ad56211f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/ad56211f/attachment.p7s&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 4:21 PM, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt; <br>&gt; Not necessarily commenting for or against abstract classes, but the following logic confuses me:<br>&gt; <br>&gt; &quot;ONLY an abstract class, ON ITS OWN, can force concrete subclassers to provide an implementation for a given thing.<br>&gt; <br>&gt; Protocols can&#39;t do this, because if you forget to declare conformance with the protocol, the compiler can&#39;t enforce anything. This pushes what could be caught at compile-time to a runtime (potentially crashing) problem.&quot;<br>&gt; <br>&gt; What is the difference between forgetting to declare conformance to a protocol and forgetting to subclass an abstract class? An abstract class, ON ITS OWN, cannot force a class to do anything unless that class declares itself a subclass of the abstract class.<br></p><p>It&#39;s the difference between forgetting to do two things and forgetting to do just one.<br></p><p>Let&#39;s say I have a framework that requires me to supply a subclass of Foo to do something useful.<br></p><p>With abstract classes, I just need to subclass Foo, and the compiler tells me what implementations I need to provide.<br></p><p>With the protocol-based &quot;solution&quot; being proposed, I need to subclass Foo *and* I need to remember to declare conformance to FooProtocol. Then and only then can the compiler enforce anything.<br></p><p>2 != 1<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63a6ed80e3b54c31ea36dc2bf12f89e2?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Alsey Miller</string> &lt;alseycmiller at gmail.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>So that is what it boils down to then. So you believe that this change is necessary so that:<br></p><p>class ContreteClass: SuperClass, AbstractProtocol { … }<br></p><p>becomes<br></p><p>class ContreteClass: AbstractClass { … }<br></p><p>?<br></p><p>It is my humble opinion that if this is the core advantage of this proposal, it should not be accepted. This is a major change in the language, not just a small new feature to be added, and if it can be done with existing functionality (like protocols) then at least it should be postponed for future review for Swift 4. For the sake of discussion lets say this does has its advantages, lets put that in the context of Swift 3 development.<br></p><p>Pros:<br>- Easier Syntax<br></p><p>Cons:<br>- Already possible with a little different syntax. Nonetheless, if you use protocols properly the EXACT functionality can be achieved. The compiler WILL force you to write an implementation for a protocol.<br>- Again, protocols are shared between structs and classes, its a syntax unifier to use protocols. With a language that uses structs for 97% of its Standard Library, protocols seem as a better idea for the sake of clarity and unity. Each new feature has o be learned by all Swift programmers. Why add a different syntax (that has to be learned) for existing functionality, when protocols are shared between value and reference types?<br>- Will disrupt stabilization of Swift 3, should be postponed for Swift 4 since its a mejor language change<br></p><p>If you could provide an example of functionality this proposal will implement, that cannot be achieved currently in Swift, then I believe it would be worth it to introduce such a major new syntax, only for classes.<br></p><p>	Coleman,<br></p><p><br>&gt; On Mar 3, 2016, at 4:26 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 3, 2016, at 4:21 PM, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not necessarily commenting for or against abstract classes, but the following logic confuses me:<br>&gt;&gt; <br>&gt;&gt; &quot;ONLY an abstract class, ON ITS OWN, can force concrete subclassers to provide an implementation for a given thing.<br>&gt;&gt; <br>&gt;&gt; Protocols can&#39;t do this, because if you forget to declare conformance with the protocol, the compiler can&#39;t enforce anything. This pushes what could be caught at compile-time to a runtime (potentially crashing) problem.&quot;<br>&gt;&gt; <br>&gt;&gt; What is the difference between forgetting to declare conformance to a protocol and forgetting to subclass an abstract class? An abstract class, ON ITS OWN, cannot force a class to do anything unless that class declares itself a subclass of the abstract class.<br>&gt; <br>&gt; It&#39;s the difference between forgetting to do two things and forgetting to do just one.<br>&gt; <br>&gt; Let&#39;s say I have a framework that requires me to supply a subclass of Foo to do something useful.<br>&gt; <br>&gt; With abstract classes, I just need to subclass Foo, and the compiler tells me what implementations I need to provide.<br>&gt; <br>&gt; With the protocol-based &quot;solution&quot; being proposed, I need to subclass Foo *and* I need to remember to declare conformance to FooProtocol. Then and only then can the compiler enforce anything.<br>&gt; <br>&gt; 2 != 1<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/71823c6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; It is my humble opinion that if this is the core advantage of this proposal, it should not be accepted. This is a major change in the language, not just a small new feature to be added, and if it can be done with existing functionality (like protocols)<br></p><p>But it can&#39;t be done with protocols. That&#39;s the point.<br></p><p>&gt; - Already possible with a little different syntax. Nonetheless, if you use protocols properly the EXACT functionality can be achieved. The compiler WILL force you to write an implementation for a protocol.<br></p><p>It&#39;s not the same functionality. <br></p><p>&gt; - Again, protocols are shared between structs and classes, its a syntax unifier to use protocols. With a language that uses structs for 97% of its Standard Library, protocols seem as a better idea for the sake of clarity and unity.<br></p><p>Ah, now we&#39;re getting to the crux of it, I think. So, the argument is that because 97% of the Swift standard library is structs, we should not consider any new functionality that is limited to classes?<br></p><p>The reason we&#39;re discussing a class-based solution to the problem is that the problem is inherently related to having an inheritance hierarchy.<br></p><p>This is why I keep going back to the fundamental question: are classes not first-class citizens in Swift? Your argument seems to be that they&#39;re not.<br></p><p>If they are, however, then I think it warrants a solution that&#39;s limited to classes.<br></p><p>&gt; Each new feature has o be learned by all Swift programmers. Why add a different syntax (that has to be learned) for existing functionality, when protocols are shared between value and reference types?<br></p><p>Because protocols don&#39;t provide the feature I seek, no matter how many times people tell me otherwise ;)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/63a6ed80e3b54c31ea36dc2bf12f89e2?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Alsey Miller</string> &lt;alseycmiller at gmail.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Classes are definitely first-class citizens. And I’ll concede that this proposal has its advantages. But I do strongly believe, that in accordance to the roadmap for Swift 3, this should not be accepted, and should instead be introduced in Swift 4. There is a precedence for good proposals being pushed to next year, since Swift 3’s goal is stabilization. <br></p><p>	Coleman,<br></p><p><br></p><p><br></p><p>&gt; On Mar 3, 2016, at 4:49 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt;&gt; It is my humble opinion that if this is the core advantage of this proposal, it should not be accepted. This is a major change in the language, not just a small new feature to be added, and if it can be done with existing functionality (like protocols)<br>&gt; <br>&gt; But it can&#39;t be done with protocols. That&#39;s the point.<br>&gt; <br>&gt;&gt; - Already possible with a little different syntax. Nonetheless, if you use protocols properly the EXACT functionality can be achieved. The compiler WILL force you to write an implementation for a protocol.<br>&gt; <br>&gt; It&#39;s not the same functionality. <br>&gt; <br>&gt;&gt; - Again, protocols are shared between structs and classes, its a syntax unifier to use protocols. With a language that uses structs for 97% of its Standard Library, protocols seem as a better idea for the sake of clarity and unity.<br>&gt; <br>&gt; Ah, now we&#39;re getting to the crux of it, I think. So, the argument is that because 97% of the Swift standard library is structs, we should not consider any new functionality that is limited to classes?<br>&gt; <br>&gt; The reason we&#39;re discussing a class-based solution to the problem is that the problem is inherently related to having an inheritance hierarchy.<br>&gt; <br>&gt; This is why I keep going back to the fundamental question: are classes not first-class citizens in Swift? Your argument seems to be that they&#39;re not.<br>&gt; <br>&gt; If they are, however, then I think it warrants a solution that&#39;s limited to classes.<br>&gt; <br>&gt;&gt; Each new feature has o be learned by all Swift programmers. Why add a different syntax (that has to be learned) for existing functionality, when protocols are shared between value and reference types?<br>&gt; <br>&gt; Because protocols don&#39;t provide the feature I seek, no matter how many times people tell me otherwise ;)<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/06e29293/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>March  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 3 mars 2016 à 22:52, Alsey Miller via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Classes are definitely first-class citizens. And I’ll concede that this proposal has its advantages. But I do strongly believe, that in accordance to the roadmap for Swift 3, this should not be accepted, and should instead be introduced in Swift 4. There is a precedence for good proposals being pushed to next year, since Swift 3’s goal is stabilization. <br>&gt; <br>&gt; 	Coleman,<br>&gt; <br>	abstract classes may have impact on ABI : that’s the reason we may add this in release 3 if we want to be able to introduction binary interrop in Swift 4 (such as dynamic code loading,etc…).<br></p><p>David<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/a1039d26/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/a1039d26/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 	abstract classes may have impact on ABI : that’s the reason we may add this in release 3 if we want to be able to introduction binary interrop in Swift 4 (such as dynamic code loading,etc…).<br></p><p>If making an existing public concrete class into an abstract class would be a nonresilient change anyway—and I cannot *possibly* imagine how it would not be—then any abstract classes would have to be new, post-Swift 4 code, and there would be no existing code to break ABI compatibility with.<br></p><p>Swift 3 is not last call for features which require additions to the ABI; it&#39;s last call for features which might *change* existing ABI.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>March  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; It&#39;s the difference between forgetting to do two things and forgetting to do just one.<br>&gt; <br>&gt; Let&#39;s say I have a framework that requires me to supply a subclass of Foo to do something useful.<br>&gt; <br>&gt; With abstract classes, I just need to subclass Foo, and the compiler tells me what implementations I need to provide.<br>&gt; <br>&gt; With the protocol-based &quot;solution&quot; being proposed, I need to subclass Foo *and* I need to remember to declare conformance to FooProtocol. Then and only then can the compiler enforce anything.<br>&gt; <br>&gt; 2 != 1<br></p><p>	In addition, there is a different meaning between protocol and inheritance. When you inherit, you specialize a behavior with some piece of code. For example, consider UIView class. When you want to make a custom class, you inherit UIView and with a custom drawRect. This has no meaning to create a protocol to implement the drawRect because drawRect handle a behavior (specializing UIView) and not a delegate or datasource external interface (i.e protocol).<br></p><p>	* Protocol  is the right choice to provide external interface such as datasource, event handler, delegate. <br>	* Extension is the right behavior for extension.<br>	* Inheritance is the right choice for specialization.<br></p><p>These 3 needs does not compete each other but are required for a multi-paradigme language that should handle severals kind of architecture designs.<br></p><p>That’s the reason I pull abstract class proposal because in our company we have the 3 kinds of architecture patterns.<br></p><p>That’s not easy to provide a simple and readable example for abstract classes, but there is actually a need. In some design, POP is a workaround for abstract classes. This works, but according to architecture design, it is a workaround.<br></p><p><br>Regards,<br></p><p>David<br></p><p><br></p><p><br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/f8db8291/attachment.p7s&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>March  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Let&#39;s say I DON&#39;T have a framework that requires me to supply a subclass of<br>(class) Foo to do something useful, instead I have a framework that<br>requires me to have my class conform to (protocol) Foo... my problem with<br>your &quot;2 things vs 1 thing&quot; argument is that it assumes that the subclassing<br>has to happen in the first place.<br></p><p>I&#39;m not convinced that using protocols in this way is a better solution<br>than an abstract class, but as protocols develop the POP argument isn&#39;t<br>necessarily &quot;subclass and conform&quot; it&#39;s &quot;conform instead of subclass&quot; - so<br>1 == 1<br></p><p>I do think that a proper evaluation of abstract classes cannot be done<br>without examining what Swift would look like with protocols expanded to<br>fill a similar role (which of the two approaches would add more complexity,<br>which would be more powerful, etc.)<br></p><p>On Thu, Mar 3, 2016 at 4:26 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br></p><p>&gt; &gt; On Mar 3, 2016, at 4:21 PM, Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Not necessarily commenting for or against abstract classes, but the<br>&gt; following logic confuses me:<br>&gt; &gt;<br>&gt; &gt; &quot;ONLY an abstract class, ON ITS OWN, can force concrete subclassers to<br>&gt; provide an implementation for a given thing.<br>&gt; &gt;<br>&gt; &gt; Protocols can&#39;t do this, because if you forget to declare conformance<br>&gt; with the protocol, the compiler can&#39;t enforce anything. This pushes what<br>&gt; could be caught at compile-time to a runtime (potentially crashing)<br>&gt; problem.&quot;<br>&gt; &gt;<br>&gt; &gt; What is the difference between forgetting to declare conformance to a<br>&gt; protocol and forgetting to subclass an abstract class? An abstract class,<br>&gt; ON ITS OWN, cannot force a class to do anything unless that class declares<br>&gt; itself a subclass of the abstract class.<br>&gt;<br>&gt; It&#39;s the difference between forgetting to do two things and forgetting to<br>&gt; do just one.<br>&gt;<br>&gt; Let&#39;s say I have a framework that requires me to supply a subclass of Foo<br>&gt; to do something useful.<br>&gt;<br>&gt; With abstract classes, I just need to subclass Foo, and the compiler tells<br>&gt; me what implementations I need to provide.<br>&gt;<br>&gt; With the protocol-based &quot;solution&quot; being proposed, I need to subclass Foo<br>&gt; *and* I need to remember to declare conformance to FooProtocol. Then and<br>&gt; only then can the compiler enforce anything.<br>&gt;<br>&gt; 2 != 1<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/4a9a9fbe/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Yes, a protocol will force you to provide an implementation. However, a protocol *by itself* cannot force the implementor of a class to provide an implementation unless that class declares itself in conformance with that protocol.<br>&gt; <br>&gt; ONLY an abstract class, ON ITS OWN, can force concrete subclassers to provide an implementation for a given thing.<br>&gt; <br>&gt; Protocols can&#39;t do this, because if you forget to declare conformance with the protocol, the compiler can&#39;t enforce anything. This pushes what could be caught at compile-time to a runtime (potentially crashing) problem.<br></p><p>If you forget to declare inheritance from an abstract class, it won&#39;t force you to implement those methods, either.<br></p><p>I do completely understand your concerns about the class + protocol workaround which is currently necessary here. That&#39;s why I&#39;m proposing we allow protocols to require inheritance, override members, create stored properties, etc. That would allow the protocol to *wholly* replace the base class, taking on the job of providing both the concrete portions of the implementation and the requirements subtypes need to satisfy.<br></p><p>&gt; Abstract classes enforce a requirement that a given portion of the class hierarchy provide an implementation of X.<br></p><p><br>Protocols don&#39;t operate entirely within the class hierarchy, but Swift&#39;s type system is broader than just a class hierarchy. In the context of the entire type (directed acyclic) graph, they play the same role of enforcing requirements on subtypes. And with the proper features in place, that&#39;s all we really need.<br></p><p>&gt; Swift isn&#39;t ONLY about protocol oriented programming. Classes are here for a reason, and they should not be relegated to second-class status where people refuse to consider class-only functionality just because the concept can&#39;t be shoehorned into something protocol-related.<br></p><p>For what it&#39;s worth, even though I prefer the protocol solution in this case, I share your frustration with the reviews that do little more than recite &quot;Protocol-Oriented Programming&quot; as a slogan. I believe there are strong, convincing reasons to prefer the protocol approach here, but none of them are captured by that phrase.<br></p><p>But I think the pro-abstract class side is suffering from the same problem. Why is it so important that this feature be expressed strictly within the class hierarchy? Both extending classes to support abstract class-style functionality *and* extending protocols to support abstract class-style functionality bring abstract class-style functionality into the language. I&#39;m not saying they&#39;re completely interchangeable and equivalent—there are differences, there are reasons to prefer one over the other—but they ultimately provide most of the same functionality.<br></p><p>If we went the abstract class route instead of the protocol route, I would be disappointed—I would think that we took the well-trodden path rather than explore something that was better and more consistent with the language. But I wouldn&#39;t feel like there was a gaping void in the language, because abstract classes *would* fulfill most of the use cases here.<br></p><p>I don&#39;t understand why you and the other abstract class supporters don&#39;t feel the same way—why you seem to treat this like a fight for your lives, not like a fight for the modestly superior design. The only thing that makes sense to me is dogmatism, but I want to give you more credit than that.<br></p><p>So explain to me: if this code worked:<br></p><p>	protocol ActivityViewControlling: UIViewController {<br>		func retrieveText() -&gt; String<br>	}<br>	extension ActivityViewControlling {<br>		@IBOutlet var messageLabel: UILabel!<br>		<br>		override func viewWillAppear(animated: Bool) {<br>			super.viewWillAppear(animated)<br>			messageLabel.text = retrieveText()<br>		}<br>	}<br></p><p>What would you feel was missing compared to this?<br></p><p>	abstract class ActivityViewController: UIViewController {<br>		abstract func retrieveText() -&gt; String<br>		<br>		@IBOutlet var messageLabel: UILabel!<br>		<br>		override func viewWillAppear(animated: Bool) {<br>			super.viewWillAppear(animated)<br>			messageLabel.text = retrieveText()<br>		}<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  3, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>I read through your proposal (skimmed it when it was posted, and then read<br>through it closely when you brought it up again). It&#39;s a really interesting<br>proposal and would be a strong addition to Swift, and I really think it<br>deserves to be proposed as a formal alternative to abstract classes. I<br>imagine it would garner considerably more support than has been shown in<br>this thread (which has been more about the philosophy of POP than concrete<br>solutions), and probably stands a decent chance of being accepted over this<br>proposal (if either is accepted at all).<br></p><p>That being said, here are my personal thoughts and/or objections. (I don&#39;t<br>hold any of these dearly, and would love to be convinced otherwise. I am<br>all too aware that today&#39;s &quot;this is too strange&quot; language concepts may<br>become tomorrow&#39;s indispensable tools :-)<br></p><p>First of all: I&#39;m wary about making protocols even more conceptually<br>complicated than they already are. The term &#39;protocol&#39; already refers to<br>two distinct concepts - protocols containing dynamically dispatched method<br>requirements, like the Objective-C equivalent, and protocols with<br>associated types that can only be used as constraints on generics. This is<br>a perennial source of confusion (c.f. multiple blog posts on trying and<br>failing to compare two &#39;Equatable&#39; objects). Now we have default<br>implementations for protocol methods, but those are statically dispatched<br>and so the rules of whether the default implementation or a type&#39;s specific<br>implementation are called have repeatedly surprised people (the IBM &#39;Swift<br>pitfalls&#39; article is a good example, as are the occasional proposals to<br>change this behavior).<br></p><p>I see the orthogonality of abstract classes to protocols as a desirable<br>thing: abstract classes/methods are a simple concept intended for a<br>specific use case and (in my opinion) well-suited towards fulfilling that<br>use case.<br></p><p>My second concern involves the ramifications of adding dynamic dispatch to<br>something like these augmented protocols (or multiple inheritance of<br>implementation in general, e.g. with mixins). How are calls to &#39;super&#39;, or<br>usage of an implementation defined in a supertype resolved? In the simple<br>case:<br></p><p>protocol P : C {<br>  override func foo() { super.foo() }<br>}<br></p><p>class C {<br>  func foo() { ... }<br>}<br></p><p>class C1 : C, P {<br>  override func foo() { super.foo() }<br>}<br></p><p>If C1().foo() is called, what is the call chain? C1&#39;s foo(), then P&#39;s, then<br>C&#39;s? What if you have multiple protocols that sit on the same level?<br></p><p>protocol Pa : C1 {<br>  override func foo() { super.foo() }<br>}<br>protocol Pb : C1 {<br>  override func foo() { super.foo() }<br>}<br></p><p>class C2 : C1, Pa, Pb {<br>  override func foo() { super.foo() }<br>}<br></p><p>At some point we&#39;d have to deal with method resolution order a la multiple<br>inheritance, and I think whether having multiple inheritance and requiring<br>developers to learn how Swift linearizes method calls is a good thing is<br>worth a major discussion itself. Another option would be to restrict a<br>class to conform to at most one protocol with an inheritance requirement,<br>but that would remove one of the most compelling advantages of the<br>protocol-based solution - the ability for a class to fulfill multiple<br>abstract type requirements.<br></p><p>(Default protocol implementations aren&#39;t subject to this problem; if you<br>try to create a situation in which there would be an ambiguity as to which<br>impl was called the compiler will complain, and there is no concept of<br>&#39;super&#39; there.)<br></p><p>Again, I see the limitation to single inheritance of abstract classes in<br>this regard as a virtue. Most of the things I want to model using abstract<br>classes are most clearly expressed in terms of a single inheritance of<br>implementation class hierarchy, in which responsibility for implementation<br>is neatly split into two categories: requirements implemented at the<br>abstract class (or above), and requirements implemented below the abstract<br>class. (This is recursive; responsibility for requirements in the second<br>category can again be split in two by further abstract classes, although<br>the usual deep class hierarchy caveats apply.)<br></p><p>Anyways, I hope this helps explain my reasoning wrt abstract classes vs<br>protocols. At the very least, I hope it allows you to sharpen your proposal<br>and make it even better.<br></p><p>Best,<br>Austin<br></p><p><br>On Thu, Mar 3, 2016 at 2:16 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Yes, a protocol will force you to provide an implementation. However, a<br>&gt; protocol *by itself* cannot force the implementor of a class to provide an<br>&gt; implementation unless that class declares itself in conformance with that<br>&gt; protocol.<br>&gt; &gt;<br>&gt; &gt; ONLY an abstract class, ON ITS OWN, can force concrete subclassers to<br>&gt; provide an implementation for a given thing.<br>&gt; &gt;<br>&gt; &gt; Protocols can&#39;t do this, because if you forget to declare conformance<br>&gt; with the protocol, the compiler can&#39;t enforce anything. This pushes what<br>&gt; could be caught at compile-time to a runtime (potentially crashing) problem.<br>&gt;<br>&gt; If you forget to declare inheritance from an abstract class, it won&#39;t<br>&gt; force you to implement those methods, either.<br>&gt;<br>&gt; I do completely understand your concerns about the class + protocol<br>&gt; workaround which is currently necessary here. That&#39;s why I&#39;m proposing we<br>&gt; allow protocols to require inheritance, override members, create stored<br>&gt; properties, etc. That would allow the protocol to *wholly* replace the base<br>&gt; class, taking on the job of providing both the concrete portions of the<br>&gt; implementation and the requirements subtypes need to satisfy.<br>&gt;<br>&gt; &gt; Abstract classes enforce a requirement that a given portion of the class<br>&gt; hierarchy provide an implementation of X.<br>&gt;<br>&gt;<br>&gt; Protocols don&#39;t operate entirely within the class hierarchy, but Swift&#39;s<br>&gt; type system is broader than just a class hierarchy. In the context of the<br>&gt; entire type (directed acyclic) graph, they play the same role of enforcing<br>&gt; requirements on subtypes. And with the proper features in place, that&#39;s all<br>&gt; we really need.<br>&gt;<br>&gt; &gt; Swift isn&#39;t ONLY about protocol oriented programming. Classes are here<br>&gt; for a reason, and they should not be relegated to second-class status where<br>&gt; people refuse to consider class-only functionality just because the concept<br>&gt; can&#39;t be shoehorned into something protocol-related.<br>&gt;<br>&gt; For what it&#39;s worth, even though I prefer the protocol solution in this<br>&gt; case, I share your frustration with the reviews that do little more than<br>&gt; recite &quot;Protocol-Oriented Programming&quot; as a slogan. I believe there are<br>&gt; strong, convincing reasons to prefer the protocol approach here, but none<br>&gt; of them are captured by that phrase.<br>&gt;<br>&gt; But I think the pro-abstract class side is suffering from the same<br>&gt; problem. Why is it so important that this feature be expressed strictly<br>&gt; within the class hierarchy? Both extending classes to support abstract<br>&gt; class-style functionality *and* extending protocols to support abstract<br>&gt; class-style functionality bring abstract class-style functionality into the<br>&gt; language. I&#39;m not saying they&#39;re completely interchangeable and<br>&gt; equivalent—there are differences, there are reasons to prefer one over the<br>&gt; other—but they ultimately provide most of the same functionality.<br>&gt;<br>&gt; If we went the abstract class route instead of the protocol route, I would<br>&gt; be disappointed—I would think that we took the well-trodden path rather<br>&gt; than explore something that was better and more consistent with the<br>&gt; language. But I wouldn&#39;t feel like there was a gaping void in the language,<br>&gt; because abstract classes *would* fulfill most of the use cases here.<br>&gt;<br>&gt; I don&#39;t understand why you and the other abstract class supporters don&#39;t<br>&gt; feel the same way—why you seem to treat this like a fight for your lives,<br>&gt; not like a fight for the modestly superior design. The only thing that<br>&gt; makes sense to me is dogmatism, but I want to give you more credit than<br>&gt; that.<br>&gt;<br>&gt; So explain to me: if this code worked:<br>&gt;<br>&gt;         protocol ActivityViewControlling: UIViewController {<br>&gt;                 func retrieveText() -&gt; String<br>&gt;         }<br>&gt;         extension ActivityViewControlling {<br>&gt;                 @IBOutlet var messageLabel: UILabel!<br>&gt;<br>&gt;                 override func viewWillAppear(animated: Bool) {<br>&gt;                         super.viewWillAppear(animated)<br>&gt;                         messageLabel.text = retrieveText()<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; What would you feel was missing compared to this?<br>&gt;<br>&gt;         abstract class ActivityViewController: UIViewController {<br>&gt;                 abstract func retrieveText() -&gt; String<br>&gt;<br>&gt;                 @IBOutlet var messageLabel: UILabel!<br>&gt;<br>&gt;                 override func viewWillAppear(animated: Bool) {<br>&gt;                         super.viewWillAppear(animated)<br>&gt;                         messageLabel.text = retrieveText()<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/3db4e56b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Why is it so important that this feature be expressed strictly within the class hierarchy? <br></p><p>Because it&#39;s a widely-understood concept within programming that I&#39;d venture most Swift developers already know.<br></p><p>&gt; I don&#39;t understand why you and the other abstract class supporters don&#39;t feel the same way—why you seem to treat this like a fight for your lives, not like a fight for the modestly superior design.<br></p><p>For those of us who support abstract classes, it&#39;s quite literally a fight for the life of SE-0026.<br></p><p>That&#39;s the proposal we&#39;re discussing.<br></p><p>The choice before us now isn&#39;t &quot;a solution involving protocols&quot; versus &quot;a solution involving abstract classes&quot;, the choice is between abstract classes or nothing.<br></p><p>It&#39;s an up-or-down vote on abstract classes.<br></p><p>So you&#39;ll have to forgive the adherents for being a bit animated about it. ;)<br></p><p>&gt; So explain to me: if this code worked:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: UIViewController {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling {<br>&gt; 		@IBOutlet var messageLabel: UILabel!<br>&gt; 		<br>&gt; 		override func viewWillAppear(animated: Bool) {<br>&gt; 			super.viewWillAppear(animated)<br>&gt; 			messageLabel.text = retrieveText()<br>&gt; 		}<br>&gt; 	}<br></p><p>Per se, I have no objections to your notation. When a specific proposal comes up for a vote, I might support it. So far I am intrigued.<br></p><p>But there&#39;s an awful lot that would have to change about Swift protocols in order to get the idea above to work, and that&#39;s assuming you could get the community to support it.<br></p><p>Pretty much everything related to protocols and static dispatch would need to be reconsidered in a proposal: for example, what&#39;s the order of execution when you have multiple viewWillAppear() overrides in several protocol extensions?<br></p><p>Such a proposal will require a lot thoughtful, careful design. Meanwhile, abstract classes are well-known concept with a well-understood design and well-defined behavior.<br></p><p>The abstract class proposal before us now, on the other hand, is much more limited in scope.<br></p><p>&gt; What would you feel was missing compared to this?<br>&gt; <br>&gt; 	abstract class ActivityViewController: UIViewController {<br>&gt; 		abstract func retrieveText() -&gt; String<br>&gt; 		<br>&gt; 		@IBOutlet var messageLabel: UILabel!<br>&gt; 		<br>&gt; 		override func viewWillAppear(animated: Bool) {<br>&gt; 			super.viewWillAppear(animated)<br>&gt; 			messageLabel.text = retrieveText()<br>&gt; 		}<br>&gt; 	}<br></p><p><br>The abstract class concept is quite common in computing, and therefore--for a lot of people--just seeing the &#39;abstract&#39; keyword conveys all that&#39;s needed.<br></p><p>Your notation, on the other hand:<br></p><p>&gt; protocol ActivityViewControlling: UIViewController<br></p><p><br>Did you just declare a protocol ActivityViewControlling that extends another protocol called UIViewController? Or did you somehow restrict the ActivityViewControlling protocol to only being used with the UIViewController class? What is being stated in your notation is not obvious to me at first glance.<br></p><p>Finally, I don&#39;t think your idea necessarily obviates the need for abstract classes. There doesn&#39;t have to be Just One Way to achieve something in Swift. I don&#39;t think the proposal for abstract classes needs to be torpedoed in order to build support for your proposal.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;&gt; Why is it so important that this feature be expressed strictly within the class hierarchy? <br>&gt; <br>&gt; Because it&#39;s a widely-understood concept within programming that I&#39;d venture most Swift developers already know.<br></p><p>Okay, so it&#39;s similar to features in other languages. That *is* a point in its favor, but all the same, Swift doesn&#39;t hesitate to ignore the conventional solution when it has a better idea—especially as it pertains to the type system.<br></p><p>&gt; Pretty much everything related to protocols and static dispatch would need to be reconsidered in a proposal: for example, what&#39;s the order of execution when you have multiple viewWillAppear() overrides in several protocol extensions?<br></p><p>I assume you mean in extensions to several protocols, all of which are conformed to by a single class?<br></p><p>Okay, let&#39;s first talk about the simple case with one protocol, just to get everyone on the same page. Suppose I have these types:<br></p><p>	class Foo { func foo() {} }<br>	<br>	protocol P: Foo {}<br>	extension P { override func foo() { super.foo() } }<br>	<br>	class Bar: Foo, P { override func foo() { super.foo() } }<br>	<br>	class Baz: Bar { override func foo() { super.foo() } }<br></p><p>I figure if you call `Baz.foo()`, it will call `Bar.foo()`, which calls `P.foo()`, which calls `Foo.foo()`. In other words, the protocol&#39;s methods are added &quot;between&quot; the conforming class and its superclass.<br></p><p>(As a digression, if the situation looked like this:<br></p><p>	class Foo { func foo() {} }<br>	<br>	class Bar: Foo { override func foo() { super.foo() } }<br>	<br>	protocol P: Foo {}<br>	extension P { override func foo() { super.foo() } }<br>	<br>	class Baz: Bar, P { override func foo() { super.foo() } }<br></p><p>The order would be `Baz.foo()`, `P.foo()`, `Bar.foo()`, `Foo.foo()`. Note that this is true even though `P` says you have to inherit from `Foo`: an override may end up overriding a subclass&#39;s implementation.)<br></p><p>Now, let&#39;s add conflicting conformances:<br></p><p>	protocol P1: Foo {}<br>	extension P1 { override func foo() { super.foo() } }<br>	<br>	protocol P2: Foo {}<br>	extension P2 { override func foo() { super.foo() } }<br>	<br>	class Bar: Foo, P1, P2 { override func foo() { super.foo() } }<br></p><p>Well, we already have a behavior when you do that: the Swift compiler complains at the site of the ambiguous call (in this case, the `super.foo()` in `Bar.foo()`) and to resolve it, you have to cast to the type of the protocol you want. We could do something similar:<br></p><p>	class Bar: Foo, P1, P2 { override func foo() { (super as P1).foo() } }<br></p><p>What if `Bar` doesn&#39;t override `foo()`? Currently, we wait until we see a conflicting call site, but honestly I think we should just require an override so that the conforming type&#39;s author can sort things out. (Actually, I think we should probably do that all the time. All of this strangeness ultimately flows from the weird hybrid status of protocol extension methods.)<br></p><p>An alternative would be to make it an error to conform to two protocols which override the same method. It will already have to be the case that you can&#39;t conform to two protocols which require you to inherit from different classes (unless one is a subclass of the other), so this would simply extend the scope of the existing &quot;conflict prevention&quot;.<br></p><p>&gt; Such a proposal will require a lot thoughtful, careful design.<br></p><p>You are absolutely right about this. But a lot of the odd corners here are things which already confuse people and probably ought to be revisited anyway.<br></p><p>&gt; Meanwhile, abstract classes are well-known concept with a well-understood design and well-defined behavior.<br></p><p>Yes, and their failings are well-documented as well. Remember what Sean Heber said in his review:<br></p><p>&gt; I’ve mentioned wanting this myself on this list and have run into situations where I *really* wished I had it at the time (instead of having to do fatalError()), but ultimately I’ve almost always gone back to redesign those things to get rid of the abstract base class pattern and improved the design in the process. Perhaps this is an anti-pattern and Swift should not encourage it. I’m not sure.<br></p><p><br>We all know what we&#39;re getting with abstract classes—and so we know that it has significant flaws and limitations. I think we&#39;d be better served trying something else, something that has a shot at improving on the state of the art.<br></p><p>(To be honest, I also think it&#39;s a good thing that a protocol with a class requirement will probably be pretty easy to refactor into a class with a delegate protocol.)<br></p><p>&gt;&gt; protocol ActivityViewControlling: UIViewController<br>&gt; <br>&gt; Did you just declare a protocol ActivityViewControlling that extends another protocol called UIViewController? Or did you somehow restrict the ActivityViewControlling protocol to only being used with the UIViewController class? What is being stated in your notation is not obvious to me at first glance.<br></p><p>Given that class declarations have the same problem—is the first type listed a superclass or a protocol?—I think that particular ship has sailed.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  4, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 03.03.2016 um 23:16 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I do completely understand your concerns about the class + protocol workaround which is currently necessary here. That&#39;s why I&#39;m proposing we allow protocols to require inheritance, override members, create stored properties, etc. That would allow the protocol to *wholly* replace the base class, taking on the job of providing both the concrete portions of the implementation and the requirements subtypes need to satisfy.<br></p><p>For modeling subtype requirements we would need the ability to declare protocol members with reduced access scope like private or internal and hopefully protected, as subtype requirements most often are not public.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; For modeling subtype requirements we would need the ability to declare protocol members with reduced access scope like private or internal and hopefully protected, as subtype requirements most often are not public.<br></p><p>I&#39;ve spoken about this elsewhere, but:<br></p><p>- For both abstract classes and protocols, all required/abstract members need to be visible everywhere you&#39;re permitted to conform/inherit.<br>- There is currently no way in Swift to decouple a protocol&#39;s/class&#39;s visibility from the ability to conform to/inherit from it, so neither construct can currently offer this feature.<br>- However, this feature is likely to come at least for classes as part of resiliency. I think it&#39;s a good idea for protocols, too.<br></p><p>&gt;&gt; Protocols don&#39;t operate entirely within the class hierarchy, but Swift&#39;s type system is broader than just a class hierarchy. In the context of the entire type (directed acyclic) graph, they play the same role of enforcing requirements on subtypes. And with the proper features in place, that&#39;s all we really need.<br>&gt; <br>&gt; If you argue that the type graph should governed by protocols only, then we should think about whether it makes sense to take classes (and structs, enums) out of that completely, i.e. these do not define types and classes just provide implementation inheritance. Protocols could then even have their own namespace solving some naming issues. But I&#39;m note sure whether that&#39;s really desirable. If not then IMO classes should have comparable capabilities to protocols with regards to shaping the type graph and not be second class citizens.<br></p><p>I don&#39;t think that the type graph should be governed entirely by protocols, and that structs, enums, and classes should be second-class citizens at the periphery of a graph of protocols. But I *do* think that this feature does not necessarily need to be implemented in classes.<br></p><p>In many languages, the class hierarchy is all there is, so of course the only way to solve the abstract class use cases is within the class hierarchy. But in Swift, the class hierarchy lives within a larger type graph, and that type graph already includes entities which are quite similar to abstract classes. I simply think that our preferred solution should be to extend the existing feature, rather than duplicating (parts of) it within the class hierarchy.<br></p><p>From my perspective, abstract classes have five defining traits:<br></p><p>1. They cannot be instantiated.<br>2. They impose requirements on their subclasses.<br>3. They provide a concrete implementation (which can use those requirements).<br>4. They anchor the class to the class hierarchy.<br>5. They can participate in inheritance by overriding and being overridden.<br></p><p>Protocols implement #1, #2, and (much of) #3; current Swift classes implement #3, #4, and #5.<br></p><p>But here&#39;s the thing: if we enhance protocols with #4 and #5, *all protocols* become more capable. For instance, if we allow protocol extensions to override superclass methods, that could *also* make conditional extensions more powerful.<br></p><p>	extension MyProtocol where Self: SomeClass {<br>		override func aMethod() {<br>			// Woohoo!<br>		}<br>	}<br></p><p>If we instead add abstract classes to classes...well, that&#39;s nice for when you want to write an abstract class, but it doesn&#39;t improve anything else.<br></p><p>The protocol route is off the beaten path, and it would take longer to develop. But I think it has significant benefits:<br></p><p>- It reuses an existing construct which already plays a similar role.<br>- By reusing that existing construct, it automatically gets useful features (like associated types) which there are no plans to provide with abstract classes.<br>- It enhances those constructs with new features that may be useful even for other use cases.<br>- It can be built out incrementally.<br>- When fully built, it will permit things that abstract classes don&#39;t (like inheriting from a subclass of the required class, rather than from the required class directly).<br></p><p>Abstract classes are (likely*) faster to add, and they&#39;re the more common solution. But if we think the protocol solution will do more good in the long run, I don&#39;t think this use case is so urgent that we can&#39;t afford to wait for something better.<br></p><p><br></p><p>* I say &quot;possibly&quot; because, as I pointed out in my review, SE-0026 is a very incomplete proposal and there are several significant details which it doesn&#39;t specify clearly.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>March  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 4 mars 2016 à 08:45, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; For modeling subtype requirements we would need the ability to declare protocol members with reduced access scope like private or internal and hopefully protected, as subtype requirements most often are not public.<br>&gt; <br>&gt; I&#39;ve spoken about this elsewhere, but:<br>&gt; <br>&gt; - For both abstract classes and protocols, all required/abstract members need to be visible everywhere you&#39;re permitted to conform/inherit.<br>&gt; - There is currently no way in Swift to decouple a protocol&#39;s/class&#39;s visibility from the ability to conform to/inherit from it, so neither construct can currently offer this feature.<br>&gt; - However, this feature is likely to come at least for classes as part of resiliency. I think it&#39;s a good idea for protocols, too.<br></p><p>Brent, please consider the sample code below:<br></p><p>	// Framework land<br>	public abstract class DatabaseRecord {<br>		// DatabaseRow initializer<br>		public required init(row: DatabaseRow) {<br>			referenceRow = row<br>		}<br></p><p>		// The table name<br>		public abstract class func databaseTableName() -&gt; String<br></p><p>		// What should be stored in the database<br>		public abstract var persistedRow: DatabaseRow<br>		<br>		// True if record has been changed since last fetch<br>		public var hasChanges: Bool { <br>			// return complex computation based on referenceRow and persistedRow<br>		}<br>		<br>		// Hidden implementation detail<br>		internal var referenceRow: DatabaseRow<br>	}<br>	<br>	// User land<br>	class Person : DatabaseRecord {<br>		var name: String<br>		class func databaseTableName() -&gt; String { return &quot;persons&quot; }<br>		init(row: DatabaseRow) {<br>			name = row[&quot;name&quot;]<br>			super.init(row)<br>		}<br>		var persistedRow: DatabaseRow { return Row(&quot;name&quot;: name) }<br>	}<br></p><p>	let person = Person(row: …)<br>	person.name			// &quot;foo&quot;<br>	person.hasChanges	// false<br>	person.name = &quot;bar&quot;<br>	person.hasChanges	// true<br></p><p><br>How do we express this with protocols?<br></p><p>	// Framework land<br>	public protocol DatabaseRecord {<br>		var referenceRow: DatabaseRow { get set }<br>		var persistedRow: DatabaseRow { get }<br>		static func databaseTableName() -&gt; String<br>		init(row: DatabaseRow)<br>	}<br></p><p>	extension DatabaseRecord {<br>		public var hasChanges: Bool { <br>			// return complex computation based on referenceRow and persistedRow<br>		}<br>	}<br>	<br>	// User land<br>	class Person: DatabaseRecord {<br>		var referenceRow: DatabaseRow<br>		var name: String<br>		init(row: DatabaseRow) {<br>			name = row[&quot;name&quot;]<br>			super.init(row)<br>		}<br>		class func databaseTableName() -&gt; String { return « persons&quot; }<br>		var persistedRow: DatabaseRow { return Row(&quot;name&quot;: name) }<br>	}<br></p><p>	let person = Person(row: …)<br>	person.name			// &quot;foo&quot;<br>	person.hasChanges	// false<br>	person.name = &quot;bar&quot;<br>	person.hasChanges	// true<br>	person.referenceRow = …	// messed up internal state<br></p><p>The problem with protocols is that the implementation detail referenceRow has to be public (when it should remain an implementation detail), and that the conforming types must provide it (when they should not even know about its existence).<br></p><p>So abstract classes and protocols are NOT on the same stage today regarding members visibility.<br></p><p>Gwendal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>March  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 4 mars 2016 à 20:24, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Le 4 mars 2016 à 08:45, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; For modeling subtype requirements we would need the ability to declare protocol members with reduced access scope like private or internal and hopefully protected, as subtype requirements most often are not public.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve spoken about this elsewhere, but:<br>&gt;&gt; <br>&gt;&gt; - For both abstract classes and protocols, all required/abstract members need to be visible everywhere you&#39;re permitted to conform/inherit.<br>&gt;&gt; - There is currently no way in Swift to decouple a protocol&#39;s/class&#39;s visibility from the ability to conform to/inherit from it, so neither construct can currently offer this feature.<br>&gt;&gt; - However, this feature is likely to come at least for classes as part of resiliency. I think it&#39;s a good idea for protocols, too.<br>&gt; <br>&gt; Brent, please consider the sample code below:<br></p><p>I just wanted to put focus on the visibility issues, which you could not see (it seems). Your general arguments about ways to improve protocols so that not only classes could be enhanced remain quite valid and inspiring.<br></p><p>Gwendal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>March  4, 2016 at 08:00:00pm</p></header><div class="content"><p>This should be resolved when PwS<br>&lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/3082&gt;(Protocol<br>with Storage) get alive:<br></p><p>  // Framework land<br>        public protocol DatabaseRecord {<br>                var persistedRow: DatabaseRow { get }<br>                static func databaseTableName() -&gt; String<br>                init(row: DatabaseRow)<br>        }<br>      internal extension DatabaseRecord {<br>*                var referenceRow: DatabaseRow*<br>                // or other storage. Syntax and place of declarations is<br>not defined.<br>       }<br>       public  extension DatabaseRecord {<br>                var hasChanges: Bool {<br>                        // return complex computation based on referenceRow<br>and persistedRow<br>                }<br>        }<br></p><p><br>This is another proposal, but the idea is improve the current protocol<br>model instead to create another type just because a single skill.<br></p><p>Em sex, 4 de mar de 2016 às 16:28, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>escreveu:<br></p><p>&gt;<br>&gt; &gt; Le 4 mars 2016 à 20:24, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Le 4 mars 2016 à 08:45, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; For modeling subtype requirements we would need the ability to declare<br>&gt; protocol members with reduced access scope like private or internal and<br>&gt; hopefully protected, as subtype requirements most often are not public.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;ve spoken about this elsewhere, but:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - For both abstract classes and protocols, all required/abstract<br>&gt; members need to be visible everywhere you&#39;re permitted to conform/inherit.<br>&gt; &gt;&gt; - There is currently no way in Swift to decouple a protocol&#39;s/class&#39;s<br>&gt; visibility from the ability to conform to/inherit from it, so neither<br>&gt; construct can currently offer this feature.<br>&gt; &gt;&gt; - However, this feature is likely to come at least for classes as part<br>&gt; of resiliency. I think it&#39;s a good idea for protocols, too.<br>&gt; &gt;<br>&gt; &gt; Brent, please consider the sample code below:<br>&gt;<br>&gt; I just wanted to put focus on the visibility issues, which you could not<br>&gt; see (it seems). Your general arguments about ways to improve protocols so<br>&gt; that not only classes could be enhanced remain quite valid and inspiring.<br>&gt;<br>&gt; Gwendal<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/a09d25ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>March  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 4 mars 2016 à 21:28, Wallacy &lt;wallacyf at gmail.com&gt; a écrit :<br>&gt; <br>&gt; This should be resolved when PwS  &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/3082&gt;(Protocol with Storage) get alive:<br>&gt; <br>&gt; […]<br>&gt; <br>&gt; This is another proposal, but the idea is improve the current protocol model instead to create another type just because a single skill.<br></p><p>Yes. But I wanted to talk about visibility, not about storage. Quoting myself:<br></p><p>The problem with protocols is that the implementation detail referenceRow has to be public (when it should remain an implementation detail), and that the conforming types must provide it (when they should not even know about its existence):<br></p><p>	// Framework land<br>	public abstract class DatabaseRecord {<br>		// DatabaseRow initializer<br>		public required init(row: DatabaseRow) {<br>			referenceRow = row<br>		}<br></p><p>		// The table name<br>		public abstract class func databaseTableName() -&gt; String<br></p><p>		// What should be stored in the database<br>		public abstract var persistedRow: DatabaseRow<br>		<br>		// True if record has been changed since last fetch<br>		public var hasChanges: Bool { <br>			// return complex computation based on referenceRow and persistedRow<br>		}<br>		<br>		// Hidden implementation detail<br>		internal var referenceRow: DatabaseRow<br>	}<br>	<br>	// User land<br>	class Person : DatabaseRecord {<br>		var name: String<br>		class func databaseTableName() -&gt; String { return &quot;persons&quot; }<br>		init(row: DatabaseRow) {<br>			name = row[&quot;name&quot;]<br>			super.init(row)<br>		}<br>		var persistedRow: DatabaseRow { return Row(&quot;name&quot;: name) }<br>	}<br></p><p>	let person = Person(row: …)<br>	person.name			// &quot;foo&quot;<br>	person.hasChanges	// false<br>	person.name = &quot;bar&quot;<br>	person.hasChanges	// true<br></p><p><br>How do we express this with protocols?<br></p><p>	// Framework land<br>	public protocol DatabaseRecord {<br>		var referenceRow: DatabaseRow { get set }<br>		var persistedRow: DatabaseRow { get }<br>		static func databaseTableName() -&gt; String<br>		init(row: DatabaseRow)<br>	}<br></p><p>	extension DatabaseRecord {<br>		public var hasChanges: Bool { <br>			// return complex computation based on referenceRow and persistedRow<br>		}<br>	}<br>	<br>	// User land<br>	class Person: DatabaseRecord {<br>		var referenceRow: DatabaseRow<br>		var name: String<br>		init(row: DatabaseRow) {<br>			name = row[&quot;name&quot;]<br>			super.init(row)<br>		}<br>		class func databaseTableName() -&gt; String { return « persons&quot; }<br>		var persistedRow: DatabaseRow { return Row(&quot;name&quot;: name) }<br>	}<br></p><p>	let person = Person(row: …)<br>	person.name			// &quot;foo&quot;<br>	person.hasChanges	// false<br>	person.name = &quot;bar&quot;<br>	person.hasChanges	// true<br>	person.referenceRow = …	// messed up internal state<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/242f85ad/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; This should be resolved when PwS  &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/3082&gt;(Protocol with Storage) get alive:<br>&gt; <br>&gt;   // Framework land<br>&gt;         public protocol DatabaseRecord {<br>&gt;       internal extension DatabaseRecord {<br>&gt;                 var referenceRow: DatabaseRow<br>&gt;        public  extension DatabaseRecord {<br></p><p>Yay for visibility and storage in protocols, and generally for being able to provide a different API to the implementers of the protocol compared to the clients of the protocol.<br></p><p>But.<br></p><p>&gt; So explain to me: if this code worked:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: UIViewController {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling {<br>&gt; 		@IBOutlet var messageLabel: UILabel!<br>&gt; 		<br>&gt; 		override func viewWillAppear(animated: Bool) {<br>&gt; 			super.viewWillAppear(animated)<br>&gt; 			messageLabel.text = retrieveText()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; What would you feel was missing compared to this?<br>&gt; <br>&gt; 	abstract class ActivityViewController: UIViewController {<br>&gt; 		abstract func retrieveText() -&gt; String<br>&gt; 		<br>&gt; 		@IBOutlet var messageLabel: UILabel!<br>&gt; 		<br>&gt; 		override func viewWillAppear(animated: Bool) {<br>&gt; 			super.viewWillAppear(animated)<br>&gt; 			messageLabel.text = retrieveText()<br>&gt; 		}<br>&gt; 	}<br></p><p>For all intents and purposes, you made an abstract class here, but calling it a protocol. <br></p><p>It has advantages:<br></p><p>+ you can achieve multiple inheritance that way<br>+ ... hm? what else?<br></p><p>and disadvantages:<br></p><p>+ it&#39;s still, for all intents and purposes, an abstract class, but for some reason you&#39;re now calling it a protocol — THAT&#39;S confusing, if you ask me;  now there&#39;s two kinds of protocols, the normal ones and the ones that do magic stuff when you implement them (I personally think those latter thingies should be called mixins)<br>+ it has additional limitations (I don&#39;t think you can call super, which is often very useful)<br>+ it&#39;s a concept that doesn&#39;t work or exist, and there&#39;s no telling if it&#39;ll be a part of Swift 3 or not<br></p><p>I believe we&#39;re confusing conceptual and implementation details here. Conceptually, both approaches seem to be using two different names for the same thing; I don&#39;t really care if the functionality I need comes through a supercharged protocol or a slightly enhanced class.<br></p><p>Are we really discussing anything more than a name? If yes, what is it?<br></p><p>Implementation-wise, the compiler can always translate abstract classes into protocols internally, so I don&#39;t really see the implementation difference as important.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/1448646b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  4, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 03.03.2016 um 23:16 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Protocols don&#39;t operate entirely within the class hierarchy, but Swift&#39;s type system is broader than just a class hierarchy. In the context of the entire type (directed acyclic) graph, they play the same role of enforcing requirements on subtypes. And with the proper features in place, that&#39;s all we really need.<br></p><p>If you argue that the type graph should governed by protocols only, then we should think about whether it makes sense to take classes (and structs, enums) out of that completely, i.e. these do not define types and classes just provide implementation inheritance. Protocols could then even have their own namespace solving some naming issues. But I&#39;m note sure whether that&#39;s really desirable. If not then IMO classes should have comparable capabilities to protocols with regards to shaping the type graph and not be second class citizens.<br></p><p>-Thorsten<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  3, 2016 at 03:00:00pm</p></header><div class="content"><p>There has been a proposal floated (by Dave Abrahams if I recall--and if I&#39;m wrong, sorry!) to change protocols so conformance is NOT inherited by subclasses by default.<br></p><p>I would just like to point out that if that happens, all of the arguments against abstract classes go out the window, and we absolutely WILL need abstract classes, because all the convoluted gymnastics required to get protocols to kinda-sorta (but not really) provide some of what abstract classes provide won&#39;t be possible.<br></p><p>Long live the class hierarchy!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 12:42 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt; There has been a proposal floated (by Dave Abrahams if I recall--and if I&#39;m wrong, sorry!) to change protocols so conformance is NOT inherited by subclasses by default.<br>&gt; <br>&gt; I would just like to point out that if that happens, all of the arguments against abstract classes go out the window, and we absolutely WILL need abstract classes, because all the convoluted gymnastics required to get protocols to kinda-sorta (but not really) provide some of what abstract classes provide won&#39;t be possible.<br>&gt; <br>&gt; Long live the class hierarchy!<br></p><p>That was me. I only proposed it as an *option* for the conformer, though, not as a sweeping change.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Without getting into a protracted argument, I just want to reiterate that:<br></p><p>* Foundation and Cocoa remain (and will remain for years) a critical part<br>of Swift software development.<br>* These frameworks are built around inheritance hierarchies; what you can<br>do to retrofit POP onto them is quite limited. If I want a partially<br>customized UIView that makes changes through the existing API hooks I&#39;m<br>going to subclass, not create a protocol.<br>* These frameworks already contain classes and methods that are &#39;abstract&#39;,<br>where that status is enforced through documentation or runtime asserts.<br>This is, in my opinion, a hole that should have been filled a long time ago<br>(but, for various technical reasons, couldn&#39;t); we have a chance now to do<br>exactly that.<br></p><p>In terms of whether or not it&#39;s worth making changes to Swift et al &#39;just&#39;<br>to improve Objective-C interop...I think the community has pretty much<br>decisively come down on the side of yes (see: typed selectors, importing of<br>user-defined Objective-C generics as Swift generics, systematic renaming of<br>imported Objective-C method names to conform with Swift compatibility...).<br></p><p>Austin<br></p><p><br>On Thu, Mar 3, 2016 at 12:55 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 3, 2016, at 12:42 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; There has been a proposal floated (by Dave Abrahams if I recall--and if<br>&gt; I&#39;m wrong, sorry!) to change protocols so conformance is NOT inherited by<br>&gt; subclasses by default.<br>&gt; &gt;<br>&gt; &gt; I would just like to point out that if that happens, all of the<br>&gt; arguments against abstract classes go out the window, and we absolutely<br>&gt; WILL need abstract classes, because all the convoluted gymnastics required<br>&gt; to get protocols to kinda-sorta (but not really) provide some of what<br>&gt; abstract classes provide won&#39;t be possible.<br>&gt; &gt;<br>&gt; &gt; Long live the class hierarchy!<br>&gt;<br>&gt; That was me. I only proposed it as an *option* for the conformer, though,<br>&gt; not as a sweeping change.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/c418a0ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Without getting into a protracted argument, I just want to reiterate that:<br>&gt; <br>&gt; * Foundation and Cocoa remain (and will remain for years) a critical part of Swift software development.<br>&gt; * These frameworks are built around inheritance hierarchies; what you can do to retrofit POP onto them is quite limited. If I want a partially customized UIView that makes changes through the existing API hooks I&#39;m going to subclass, not create a protocol.<br>&gt; * These frameworks already contain classes and methods that are &#39;abstract&#39;, where that status is enforced through documentation or runtime asserts. This is, in my opinion, a hole that should have been filled a long time ago (but, for various technical reasons, couldn&#39;t); we have a chance now to do exactly that.<br>&gt; <br>&gt; In terms of whether or not it&#39;s worth making changes to Swift et al &#39;just&#39; to improve Objective-C interop...I think the community has pretty much decisively come down on the side of yes (see: typed selectors, importing of user-defined Objective-C generics as Swift generics, systematic renaming of imported Objective-C method names to conform with Swift compatibility...).<br>&gt; <br>&gt; Austin<br></p><p>I couldn&#39;t agree more with Austin.<br></p><p>I feel like where getting close to a religious argument where the solution to everything is protocols.<br></p><p>The fact is, classes exist as first-class entities in Swift. Abstract classes solve a need that is only partially solved (and in a much more convoluted fashion) by protocols.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
