<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  7, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;<br>&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt; examples.<br>&gt;&gt; <br>&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt; can be made safe.  <br>&gt;&gt; <br>&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt; that<br>&gt;&gt; <br>&gt;&gt;  A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;  you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;  lifetime rules).<br>&gt;<br>&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt; the scope that was guaranteeing safety.<br>&gt;<br>&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt; type and how it would be used.<br></p><p>It sounds like you&#39;re saying that, to get static safety benefits from<br>ownership, we&#39;ll need a whole parallel universe of safe move-only<br>types. Seems a cryin&#39; shame.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt; <br>&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt; examples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt; lifetime rules).<br>&gt;&gt; <br>&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt; <br>&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt; type and how it would be used.<br>&gt; <br>&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt; types. Seems a cryin&#39; shame.<br></p><p>Well, if we can eliminate the unsafe, copyable types, that would be great, of course.<br>I don&#39;t know whether that&#39;s achievable given our C interop goals.<br></p><p>Another option is to attack escapes directly.  The safety guarantee you&#39;re looking<br>for is just that the value doesn&#39;t escape its scope, and while it&#39;s true that move-only<br>borrowed values aren&#39;t allowed to escape, that constraint doesn&#39;t *require* borrowing<br>or move-only-ness to work.  We already have non-escaping values in the language —<br>noescape functions — and there&#39;s nothing stopping us from applying that same logic<br>to other types.  There would be annotation problems, though, since existing functions<br>operating on pointers would be allowed to escape them.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  7, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Nov 07 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt; <br>&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;<br>&gt; Well, if we can eliminate the unsafe, copyable types, that would be<br>&gt; great, of course.  I don&#39;t know whether that&#39;s achievable given our C<br>&gt; interop goals.<br></p><p>I&#39;m not suggesting we can do that.  <br></p><p>I&#39;m suggesting that in order to get a copy of some borrowed thing, you<br>might have to utter the word &quot;unsafe&quot; because it&#39;s a thing that can&#39;t<br>escape without compromising static safety guarantees, e.g. (strawman<br>syntax):<br></p><p>   interop_with_c(unsafe { someBuffer })<br></p><p>&gt; Another option is to attack escapes directly.  The safety guarantee<br>&gt; you&#39;re looking for is just that the value doesn&#39;t escape its scope,<br>&gt; and while it&#39;s true that move-only borrowed values aren&#39;t allowed to<br>&gt; escape, that constraint doesn&#39;t *require* borrowing or move-only-ness<br>&gt; to work.  We already have non-escaping values in the language —<br>&gt; noescape functions — and there&#39;s nothing stopping us from applying<br>&gt; that same logic to other types.  <br></p><p>Sure, but if a copyable version of a type is unsafe to handle, and<br>“unsafe” is encoded into the type&#39;s name, we end up with no way to<br>represent in code the fact that an instance that&#39;s been statically<br>constrained to be borrowed and non-escaping is actually safe.<br></p><p>Look, today we have <br></p><p>   a.withUnsafeBufferPointer {<br>      ...<br>   }<br></p><p>Now, if we had a version of UnsafeBufferPointer that included bounds<br>checking, we&#39;d still need to spell that <br></p><p>   a.withUnsafeBoundsCheckedBufferPointer {<br>      ...<br>   }<br></p><p>today.  With first-class ownership, it could be<br></p><p>   a.withBoundsCheckedBufferPointer {<br>      ...<br>   }<br></p><p>totally safe!  So what does that imply about the name we&#39;ll use for the<br>type of the closure parameter?<br></p><p>&gt; There would be annotation problems, though, since existing functions<br>&gt; operating on pointers would be allowed to escape them.<br></p><p>Not sure what you have in mind here.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 4:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Mon Nov 07 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt; <br>&gt;&gt; Well, if we can eliminate the unsafe, copyable types, that would be<br>&gt;&gt; great, of course.  I don&#39;t know whether that&#39;s achievable given our C<br>&gt;&gt; interop goals.<br>&gt; <br>&gt; I&#39;m not suggesting we can do that.  <br>&gt; <br>&gt; I&#39;m suggesting that in order to get a copy of some borrowed thing, you<br>&gt; might have to utter the word &quot;unsafe&quot; because it&#39;s a thing that can&#39;t<br>&gt; escape without compromising static safety guarantees, e.g. (strawman<br>&gt; syntax):<br>&gt; <br>&gt;   interop_with_c(unsafe { someBuffer })<br></p><p>Hmm.  We might be able to to do this.<br></p><p>John.<br></p><p>&gt;&gt; Another option is to attack escapes directly.  The safety guarantee<br>&gt;&gt; you&#39;re looking for is just that the value doesn&#39;t escape its scope,<br>&gt;&gt; and while it&#39;s true that move-only borrowed values aren&#39;t allowed to<br>&gt;&gt; escape, that constraint doesn&#39;t *require* borrowing or move-only-ness<br>&gt;&gt; to work.  We already have non-escaping values in the language —<br>&gt;&gt; noescape functions — and there&#39;s nothing stopping us from applying<br>&gt;&gt; that same logic to other types.  <br>&gt; <br>&gt; Sure, but if a copyable version of a type is unsafe to handle, and<br>&gt; “unsafe” is encoded into the type&#39;s name, we end up with no way to<br>&gt; represent in code the fact that an instance that&#39;s been statically<br>&gt; constrained to be borrowed and non-escaping is actually safe.<br>&gt; <br>&gt; Look, today we have <br>&gt; <br>&gt;   a.withUnsafeBufferPointer {<br>&gt;      ...<br>&gt;   }<br>&gt; <br>&gt; Now, if we had a version of UnsafeBufferPointer that included bounds<br>&gt; checking, we&#39;d still need to spell that <br>&gt; <br>&gt;   a.withUnsafeBoundsCheckedBufferPointer {<br>&gt;      ...<br>&gt;   }<br>&gt; <br>&gt; today.  With first-class ownership, it could be<br>&gt; <br>&gt;   a.withBoundsCheckedBufferPointer {<br>&gt;      ...<br>&gt;   }<br>&gt; <br>&gt; totally safe!  So what does that imply about the name we&#39;ll use for the<br>&gt; type of the closure parameter?<br>&gt; <br>&gt;&gt; There would be annotation problems, though, since existing functions<br>&gt;&gt; operating on pointers would be allowed to escape them.<br>&gt; <br>&gt; Not sure what you have in mind here.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt; <br>&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt; examples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt; lifetime rules).<br>&gt;&gt; <br>&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt; <br>&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt; type and how it would be used.<br>&gt; <br>&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt; types. Seems a cryin&#39; shame.<br></p><p>We&#39;ve discussed the possibility of types being able to control their &quot;borrowed&quot; representation. Even if this isn&#39;t something we generalize, arrays and contiguous buffers might be important enough to the language that your safe BufferPointer could be called &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized out of the borrowed representation. Perhaps Array&#39;s own borrowed representation would benefit from acting like a slice rather than a whole-buffer borrow too.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt; <br>&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt; <br>&gt; We&#39;ve discussed the possibility of types being able to control their &quot;borrowed&quot; representation. Even if this isn&#39;t something we generalize, arrays and contiguous buffers might be important enough to the language that your safe BufferPointer could be called &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized out of the borrowed representation. Perhaps Array&#39;s own borrowed representation would benefit from acting like a slice rather than a whole-buffer borrow too.<br></p><p>The disadvantage of doing this is that it much more heavily penalizes the case where we actually do a copy from a borrowed reference — it becomes an actual array copy, not just a reference bump.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/fea6559b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt; <br>&gt;&gt; We&#39;ve discussed the possibility of types being able to control their &quot;borrowed&quot; representation. Even if this isn&#39;t something we generalize, arrays and contiguous buffers might be important enough to the language that your safe BufferPointer could be called &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized out of the borrowed representation. Perhaps Array&#39;s own borrowed representation would benefit from acting like a slice rather than a whole-buffer borrow too.<br>&gt; <br>&gt; The disadvantage of doing this is that it much more heavily penalizes the case where we actually do a copy from a borrowed reference — it becomes an actual array copy, not just a reference bump.<br></p><p>Fair point, though the ArraySlice/Array dichotomy strikes me as already kind of encouraging this—you might pass ArraySlices down into your algorithm, but we encourage people to use Array at storage and API boundaries, forcing copies.<br></p><p>From a philosophical perspective of making systems Swift feel like &quot;the same language&quot; as Swift today, it feels better to me to try to express this as making our high-level safe abstractions efficient rather than making our low-level unsafe abstractions safe. Given our short-term goals for the borrow model as I understand them, I don&#39;t think we can really make a BufferPointer-like type safe in the way Dave is suggesting, since the pointer fields *inside* the struct need to be first class lifetime-qualified rather than the value of the struct itself. Since Array and ArraySlice already communicate an ownership stake in the memory they reference, a borrowed Array or ArraySlice value *would* safely and efficiently provide access to contiguous memory with only support for first-order borrowed/consumed property declarations and not full first class lifetime support.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt; <br>&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt; bump.<br>&gt;<br>&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt; API boundaries, forcing copies.<br>&gt;<br>&gt; From a philosophical perspective of making systems Swift feel like<br>&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt; express this as making our high-level safe abstractions efficient<br>&gt; rather than making our low-level unsafe abstractions safe. <br></p><p>+1, or maybe 10<br></p><p>What worries me is that if systems programmers are trying to get static<br>guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>a copyable thing that carries ownership.<br></p><p>&gt; Given our short-term goals for the borrow model as I understand them,<br>&gt; I don&#39;t think we can really make a BufferPointer-like type safe in the<br>&gt; way Dave is suggesting, since the pointer fields *inside* the struct<br>&gt; need to be first class lifetime-qualified rather than the value of the<br>&gt; struct itself. <br></p><p>Well now, those fields don&#39;t have to be public API, and it would be fine<br>for the implementation of this thing to use unsafe constructs.<br></p><p>&gt; Since Array and ArraySlice already communicate an ownership stake in<br>&gt; the memory they reference, a borrowed Array or ArraySlice value<br>&gt; *would* safely and efficiently provide access to contiguous memory<br>&gt; with only support for first-order borrowed/consumed property<br>&gt; declarations and not full first class lifetime support.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>November 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt; bump.<br>&gt;&gt; <br>&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt;&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt;&gt; API boundaries, forcing copies.<br>&gt;&gt; <br>&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt; rather than making our low-level unsafe abstractions safe. <br>&gt; <br>&gt; +1, or maybe 10<br>&gt; <br>&gt; What worries me is that if systems programmers are trying to get static<br>&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt; a copyable thing that carries ownership.<br></p><p>FWIW, we (frequently) only need a static guarantee of no ARC traffic *within a critical section*. If we can guarantee that whatever ARC operations need to be done happen in a precisely-controlled manner at a known interface boundary, that’s often good enough.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November 10, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Nov 10 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt;&gt; bump.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt;&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt;&gt;&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt;&gt;&gt; API boundaries, forcing copies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt;&gt; rather than making our low-level unsafe abstractions safe. <br>&gt;&gt; <br>&gt;&gt; +1, or maybe 10<br>&gt;&gt; <br>&gt;&gt; What worries me is that if systems programmers are trying to get static<br>&gt;&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt;&gt; a copyable thing that carries ownership.<br>&gt;<br>&gt; FWIW, we (frequently) only need a static guarantee of no ARC traffic<br>&gt; *within a critical section*. If we can guarantee that whatever ARC<br>&gt; operations need to be done happen in a precisely-controlled manner at<br>&gt; a known interface boundary, that’s often good enough.<br></p><p>I don&#39;t think you can get those guarantees without static protection<br>against escaping borrowed references, though, can you?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 1:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Nov 10 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt;&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt;&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt;&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt;&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt;&gt;&gt; bump.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt;&gt;&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt;&gt;&gt;&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt;&gt;&gt;&gt; API boundaries, forcing copies.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt;&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt;&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt;&gt;&gt; rather than making our low-level unsafe abstractions safe. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1, or maybe 10<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What worries me is that if systems programmers are trying to get static<br>&gt;&gt;&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt;&gt;&gt; a copyable thing that carries ownership.<br>&gt;&gt; <br>&gt;&gt; FWIW, we (frequently) only need a static guarantee of no ARC traffic<br>&gt;&gt; *within a critical section*. If we can guarantee that whatever ARC<br>&gt;&gt; operations need to be done happen in a precisely-controlled manner at<br>&gt;&gt; a known interface boundary, that’s often good enough.<br>&gt; <br>&gt; I don&#39;t think you can get those guarantees without static protection<br>&gt; against escaping borrowed references, though, can you?<br></p><p>You shouldn&#39;t be able to do that without copying it, and copying a borrow seems like it ought to at least be explicit.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November 10, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 10, 2016, at 1:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Nov 10 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt;&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt;&gt;&gt;&gt; bump.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt;&gt;&gt;&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt;&gt;&gt;&gt;&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt;&gt;&gt;&gt;&gt; API boundaries, forcing copies.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt;&gt;&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt;&gt;&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt;&gt;&gt;&gt; rather than making our low-level unsafe abstractions safe. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1, or maybe 10<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What worries me is that if systems programmers are trying to get static<br>&gt;&gt;&gt;&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt;&gt;&gt;&gt; a copyable thing that carries ownership.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, we (frequently) only need a static guarantee of no ARC traffic<br>&gt;&gt;&gt; *within a critical section*. If we can guarantee that whatever ARC<br>&gt;&gt;&gt; operations need to be done happen in a precisely-controlled manner at<br>&gt;&gt;&gt; a known interface boundary, that’s often good enough.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think you can get those guarantees without static protection<br>&gt;&gt; against escaping borrowed references, though, can you?<br>&gt;<br>&gt; You shouldn&#39;t be able to do that without copying it, and copying a<br>&gt; borrow seems like it ought to at least be explicit.<br></p><p>I don&#39;t think that&#39;s true for all types (e.g. Int).<br></p><p>But regardless, we&#39;ve come full circle, because I&#39;m talking<br>about needing to do something explicit to copy a a borrowed type when<br>copying it will be unsafe.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 8:17 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com &lt;http://jgroff-at-apple.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 10, 2016, at 1:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Nov 10 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bump.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt;&gt;&gt;&gt;&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt;&gt;&gt;&gt;&gt;&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt;&gt;&gt;&gt;&gt;&gt; API boundaries, forcing copies.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt;&gt;&gt;&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt;&gt;&gt;&gt;&gt; rather than making our low-level unsafe abstractions safe. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1, or maybe 10<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What worries me is that if systems programmers are trying to get static<br>&gt;&gt;&gt;&gt;&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt;&gt;&gt;&gt;&gt; a copyable thing that carries ownership.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, we (frequently) only need a static guarantee of no ARC traffic<br>&gt;&gt;&gt;&gt; *within a critical section*. If we can guarantee that whatever ARC<br>&gt;&gt;&gt;&gt; operations need to be done happen in a precisely-controlled manner at<br>&gt;&gt;&gt;&gt; a known interface boundary, that’s often good enough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think you can get those guarantees without static protection<br>&gt;&gt;&gt; against escaping borrowed references, though, can you?<br>&gt;&gt; <br>&gt;&gt; You shouldn&#39;t be able to do that without copying it, and copying a<br>&gt;&gt; borrow seems like it ought to at least be explicit.<br>&gt; <br>&gt; I don&#39;t think that&#39;s true for all types (e.g. Int).<br>&gt; <br>&gt; But regardless, we&#39;ve come full circle, because I&#39;m talking<br>&gt; about needing to do something explicit to copy a a borrowed type when<br>&gt; copying it will be unsafe.<br></p><p>I’m a bit confused by this. Presumably 99.999% of string slices would be an immutable view. Almost no unicode correct code has any business mutating the contents of a fixed-sized string buffer. (data point: the `&amp;mut str` type exists in Rust, but literally every interface I’ve ever seen handles `&amp;str`). If the views are immutable, they’re safe to copy as long as every copy “remembers” that it’s noescape or whatever you want to call it.<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/0330152d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November 11, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Nov 11 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 10, 2016, at 8:17 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com &lt;http://jgroff-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Nov 10, 2016, at 1:02 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Nov 10 2016, Stephen Canon &lt;scanon-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Nov 10 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important enough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to the language that your safe BufferPointer could be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out of the borrowed representation. Perhaps Array&#39;s own borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation would benefit from acting like a slice rather than a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whole-buffer borrow too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bump.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; already kind of encouraging this—you might pass ArraySlices down into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; your algorithm, but we encourage people to use Array at storage and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; API boundaries, forcing copies.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than making our low-level unsafe abstractions safe. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1, or maybe 10<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What worries me is that if systems programmers are trying to get static<br>&gt;&gt;&gt;&gt;&gt;&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt;&gt;&gt;&gt;&gt;&gt; a copyable thing that carries ownership.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, we (frequently) only need a static guarantee of no ARC traffic<br>&gt;&gt;&gt;&gt;&gt; *within a critical section*. If we can guarantee that whatever ARC<br>&gt;&gt;&gt;&gt;&gt; operations need to be done happen in a precisely-controlled manner at<br>&gt;&gt;&gt;&gt;&gt; a known interface boundary, that’s often good enough.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think you can get those guarantees without static protection<br>&gt;&gt;&gt;&gt; against escaping borrowed references, though, can you?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You shouldn&#39;t be able to do that without copying it, and copying a<br>&gt;&gt;&gt; borrow seems like it ought to at least be explicit.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that&#39;s true for all types (e.g. Int).<br>&gt;&gt; <br>&gt;&gt; But regardless, we&#39;ve come full circle, because I&#39;m talking<br>&gt;&gt; about needing to do something explicit to copy a a borrowed type when<br>&gt;&gt; copying it will be unsafe.<br>&gt;<br>&gt; I’m a bit confused by this. Presumably 99.999% of string slices would<br>&gt; be an immutable view. Almost no unicode correct code has any business<br>&gt; mutating the contents of a fixed-sized string buffer. (data point: the<br>&gt; `&amp;mut str` type exists in Rust, but literally every interface I’ve<br>&gt; ever seen handles `&amp;str`). If the views are immutable, they’re safe to<br>&gt; copy as long as every copy “remembers” that it’s noescape or whatever<br>&gt; you want to call it.<br></p><p>If copies can do that, they are the moral equivalent of borrows.  The<br>unsafe copies are the ones that can escape.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 12, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 12:39 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Nov 10, 2016, at 1:30 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What worries me is that if systems programmers are trying to get static<br>&gt;&gt; guarantees that there&#39;s no ARC traffic, they won&#39;t be willing to handle<br>&gt;&gt; a copyable thing that carries ownership.<br>&gt; <br>&gt; FWIW, we (frequently) only need a static guarantee of no ARC traffic *within a critical section*. If we can guarantee that whatever ARC operations need to be done happen in a precisely-controlled manner at a known interface boundary, that’s often good enough.<br></p><p>“Critical section” is a phrase I normally associate with multi-threaded code… Do we need to start talking about concurrency to move this topic forward?<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November 10, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 9:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control their &quot;borrowed&quot; representation. Even if this isn&#39;t something we generalize, arrays and contiguous buffers might be important enough to the language that your safe BufferPointer could be called &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference optimized out of the borrowed representation. Perhaps Array&#39;s own borrowed representation would benefit from acting like a slice rather than a whole-buffer borrow too.<br>&gt;&gt; <br>&gt;&gt; The disadvantage of doing this is that it much more heavily penalizes the case where we actually do a copy from a borrowed reference — it becomes an actual array copy, not just a reference bump.<br>&gt; <br>&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as already kind of encouraging this—you might pass ArraySlices down into your algorithm, but we encourage people to use Array at storage and API boundaries, forcing copies.<br></p><p>Fair point.  In practice, though, I think most algorithms won&#39;t need to &quot;escape&quot; that array slice.<br></p><p>&gt; From a philosophical perspective of making systems Swift feel like &quot;the same language&quot; as Swift today, it feels better to me to try to express this as making our high-level safe abstractions efficient rather than making our low-level unsafe abstractions safe. Given our short-term goals for the borrow model as I understand them, I don&#39;t think we can really make a BufferPointer-like type safe in the way Dave is suggesting, since the pointer fields *inside* the struct need to be first class lifetime-qualified rather than the value of the struct itself. Since Array and ArraySlice already communicate an ownership stake in the memory they reference, a borrowed Array or ArraySlice value *would* safely and efficiently provide access to contiguous memory with only support for first-order borrowed/consumed property declarations and not full first class lifetime support.<br></p><p>I agree.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November 10, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Nov 10 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 10, 2016, at 9:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important<br>&gt;&gt;&gt;&gt; enough to the language that your safe BufferPointer could be<br>&gt;&gt;&gt;&gt; called &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference<br>&gt;&gt;&gt;&gt; optimized out of the borrowed representation. Perhaps Array&#39;s own<br>&gt;&gt;&gt;&gt; borrowed representation would benefit from acting like a slice<br>&gt;&gt;&gt;&gt; rather than a whole-buffer borrow too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt; bump.<br>&gt;&gt; <br>&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt; already kind of encouraging this—you might pass ArraySlices down<br>&gt;&gt; into your algorithm, but we encourage people to use Array at storage<br>&gt;&gt; and API boundaries, forcing copies.<br>&gt;<br>&gt; Fair point.  In practice, though, I think most algorithms won&#39;t need<br>&gt; to &quot;escape&quot; that array slice.<br></p><p>I disagree. I&#39;m working on some generic matching algorithms (to lay the<br>foundation for String search and regexes).  There&#39;s going to be a broad<br>category of functions in this area that work on Strings and return<br>SubStrings, or work on Collections and return slices thereof.  Often<br>they&#39;ll be called from a context where the resultant slices don&#39;t<br>outlive the collection, but they still do need to be returned.<br></p><p>&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt; rather than making our low-level unsafe abstractions safe. Given our<br>&gt;&gt; short-term goals for the borrow model as I understand them, I don&#39;t<br>&gt;&gt; think we can really make a BufferPointer-like type safe in the way<br>&gt;&gt; Dave is suggesting, since the pointer fields *inside* the struct<br>&gt;&gt; need to be first class lifetime-qualified rather than the value of<br>&gt;&gt; the struct itself. Since Array and ArraySlice already communicate an<br>&gt;&gt; ownership stake in the memory they reference, a borrowed Array or<br>&gt;&gt; ArraySlice value *would* safely and efficiently provide access to<br>&gt;&gt; contiguous memory with only support for first-order<br>&gt;&gt; borrowed/consumed property declarations and not full first class<br>&gt;&gt; lifetime support.<br>&gt;<br>&gt; I agree.<br>&gt;<br>&gt; John.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 5:16 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Thu Nov 10 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 10, 2016, at 9:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Nov 8, 2016, at 9:29 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 8, 2016, at 7:44 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 3:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 6, 2016, at 1:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that we&#39;re headed for ABI (and thus stdlib API) stability, I&#39;ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; been giving lots of thought to the bottom layer of our collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and how it may limit our potential for efficiency.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; particular, I want to keep the door open for optimizations that work on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contiguous memory regions.  Every cache-friendly data structure, even if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is not an array, contains contiguous memory regions over which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations can often be vectorized, that should define boundaries for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parallelism, etc.  Throughout Cocoa you can find patterns designed to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploit this fact when possible (NSFastEnumeration).  Posix I/O bottoms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out in readv/writev, and MPI datatypes essentially boil down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying the contiguous parts of data structures.  My point is that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is an important class of optimization, with numerous real-world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; examples.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you think about what it means to build APIs for contiguous memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into abstractions like Sequence or Collection, at least without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalizing the lowest-level code, it means exposing UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as a first-class part of the protocols, which is really<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unappealing... unless you consider that *borrowed* UnsafeBufferPointers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be made safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Well, it&#39;s slightly more complicated than that because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer is designed to bypass bounds checking in release<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; builds, and to ensure safety you&#39;d need a BoundsCheckedBuffer—or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something—that checks bounds unconditionally... but] the point remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A thing that is unsafe when it&#39;s arbitrarily copied can become safe if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you ensure that it&#39;s only borrowed (in accordance with well-understood<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lifetime rules).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeBufferPointer today is a copyable type.  Having a borrowed value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; doesn&#39;t prevent you from making your own copy, which could then escape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the scope that was guaranteeing safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is fixable, of course, but it&#39;s a more significant change to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type and how it would be used.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It sounds like you&#39;re saying that, to get static safety benefits from<br>&gt;&gt;&gt;&gt;&gt;&gt; ownership, we&#39;ll need a whole parallel universe of safe move-only<br>&gt;&gt;&gt;&gt;&gt;&gt; types. Seems a cryin&#39; shame.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We&#39;ve discussed the possibility of types being able to control<br>&gt;&gt;&gt;&gt;&gt; their &quot;borrowed&quot; representation. Even if this isn&#39;t something we<br>&gt;&gt;&gt;&gt;&gt; generalize, arrays and contiguous buffers might be important<br>&gt;&gt;&gt;&gt;&gt; enough to the language that your safe BufferPointer could be<br>&gt;&gt;&gt;&gt;&gt; called &#39;borrowed ArraySlice&lt;T&gt;&#39;, with the owner backreference<br>&gt;&gt;&gt;&gt;&gt; optimized out of the borrowed representation. Perhaps Array&#39;s own<br>&gt;&gt;&gt;&gt;&gt; borrowed representation would benefit from acting like a slice<br>&gt;&gt;&gt;&gt;&gt; rather than a whole-buffer borrow too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The disadvantage of doing this is that it much more heavily<br>&gt;&gt;&gt;&gt; penalizes the case where we actually do a copy from a borrowed<br>&gt;&gt;&gt;&gt; reference — it becomes an actual array copy, not just a reference<br>&gt;&gt;&gt;&gt; bump.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair point, though the ArraySlice/Array dichotomy strikes me as<br>&gt;&gt;&gt; already kind of encouraging this—you might pass ArraySlices down<br>&gt;&gt;&gt; into your algorithm, but we encourage people to use Array at storage<br>&gt;&gt;&gt; and API boundaries, forcing copies.<br>&gt;&gt; <br>&gt;&gt; Fair point.  In practice, though, I think most algorithms won&#39;t need<br>&gt;&gt; to &quot;escape&quot; that array slice.<br>&gt; <br>&gt; I disagree. I&#39;m working on some generic matching algorithms (to lay the<br>&gt; foundation for String search and regexes).  There&#39;s going to be a broad<br>&gt; category of functions in this area that work on Strings and return<br>&gt; SubStrings, or work on Collections and return slices thereof.  Often<br>&gt; they&#39;ll be called from a context where the resultant slices don&#39;t<br>&gt; outlive the collection, but they still do need to be returned.<br></p><p>Ok.  You&#39;re right, I was thinking about arrays more than I was thinking about strings.<br></p><p>Anyway, if you&#39;re talking about returning the value back, you&#39;re talking about<br>something we can&#39;t support as just a borrowed value without some sort of<br>lifetime-qualification system.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt;&gt; From a philosophical perspective of making systems Swift feel like<br>&gt;&gt;&gt; &quot;the same language&quot; as Swift today, it feels better to me to try to<br>&gt;&gt;&gt; express this as making our high-level safe abstractions efficient<br>&gt;&gt;&gt; rather than making our low-level unsafe abstractions safe. Given our<br>&gt;&gt;&gt; short-term goals for the borrow model as I understand them, I don&#39;t<br>&gt;&gt;&gt; think we can really make a BufferPointer-like type safe in the way<br>&gt;&gt;&gt; Dave is suggesting, since the pointer fields *inside* the struct<br>&gt;&gt;&gt; need to be first class lifetime-qualified rather than the value of<br>&gt;&gt;&gt; the struct itself. Since Array and ArraySlice already communicate an<br>&gt;&gt;&gt; ownership stake in the memory they reference, a borrowed Array or<br>&gt;&gt;&gt; ArraySlice value *would* safely and efficiently provide access to<br>&gt;&gt;&gt; contiguous memory with only support for first-order<br>&gt;&gt;&gt; borrowed/consumed property declarations and not full first class<br>&gt;&gt;&gt; lifetime support.<br>&gt;&gt; <br>&gt;&gt; I agree.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Contiguous Memory and the Effect of Borrowing on Safety</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>November 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 8:42 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok.  You&#39;re right, I was thinking about arrays more than I was thinking about strings.<br>&gt; <br>&gt; Anyway, if you&#39;re talking about returning the value back, you&#39;re talking about<br>&gt; something we can&#39;t support as just a borrowed value without some sort of<br>&gt; lifetime-qualification system.<br>&gt; <br>&gt; John.<br></p><p>When I see “borrow checking” I think of lifetime qualification system.<br></p><p>Is there a straw-man proposal or outline written up somewhere yet?<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161112/aacd46dc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
