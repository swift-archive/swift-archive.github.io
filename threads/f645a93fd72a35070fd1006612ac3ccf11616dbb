<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32bc8f3d077b26024665ae3904895569?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Tony Allevato</string> &lt;tony.allevato at gmail.com&gt;<p>May 14, 2016 at 11:00:00am</p></header><div class="content"><p>On 2016-05-14 16:29:40 +0000, Haravikk via swift-evolution said:<br></p><p>&gt; <br>&gt; On 14 May 2016, at 16:52, Tony Allevato via swift-evolution <br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; To me, this makes declarations with complex sets of constraints much <br>&gt;&gt; harder to read, because I have to hunt them down instead of finding <br>&gt;&gt; them all in one place. Under this proposal, the longer an argument list <br>&gt;&gt; gets, the further separated the constraints are from the type <br>&gt;&gt; parameters that use them.<br>&gt; <br>&gt; This is partly an issue of how you use the feature rather than an issue <br>&gt; with the feature itself, as you’re assuming that everything is all on <br>&gt; one line, but really I think the intent of this feature is to better <br>&gt; support multi-line declarations. It enables things like:<br>&gt; <br>&gt; 	func someMethod&lt;S:SequenceType, T&gt;(value:S) -&gt; AnySequence&lt;T&gt;<br>&gt; 		where S.Generator.Element == T { … }<br></p><p>I&#39;m not assuming that. Under the current syntax, I would format your <br>example as:<br></p><p>    func someMethod&lt;<br>        S: SequenceType, T<br>        where S.Generator.Element == T<br>    &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>        ...<br>    }<br></p><p>which I find to be quite readable across multiple lines without <br>scattering the generic type information in two places across the <br>function.<br></p><p><br>&gt; The actual function signature stays on the top, but the constraint can <br>&gt; now move down neatly, since it’s a supplementary condition that you may <br>&gt; not to consider right away, or at all, if it’s just reinforcing some <br>&gt; kind of common-sense limitation.<br></p><p>That&#39;s kind of a judgment call, though. Not all constraints fit that <br>mold—some encode very important information that it makes sense to keep <br>up front.<br></p><p><br>&gt; This is partly why I’d prefer to see it optional though, as some things <br>&gt; will fit on one line reasonably well (you probably could with the above <br>&gt; for example), but like you say, with it all on one line the return type <br>&gt; becomes less visible.<br></p><p>No matter how you format the proposed syntax, the return type is <br>sandwiched in the middle of two things that describe generic type <br>information—whether it&#39;s on one line or not doesn&#39;t change that. I <br>believe that harms readability, especially if you have some constraints <br>(conformance) on the left and some (associated types) on the right.<br></p><p>I would be strongly opposed to making this optional—that adds <br>complexity to the language to support parsing two patterns, as well as <br>the cognitive load of someone reading Swift code, especially if written <br>in the different style. As was mentioned in another thread, &quot;Swift is <br>an opinionated languge&quot;, and I hope we&#39;d be prescriptive about <br>syntactic constructs like this that are more significant than &quot;does the <br>curly brace go on the same line or the next line&quot;. (Even if the choice <br>is one that I disagree with in the end, I&#39;d rather there be one way <br>than multiple ways!)<br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Tony &amp; Haravikk,<br></p><p>(Reformatting your quoted examples just a bit…)<br></p><p>&gt;&gt; It enables things like:<br>&gt;&gt;     func someMethod&lt;S : SequenceType, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;&gt;         where S.Generator.Element == T { ... }<br>&gt; <br>&gt; I&#39;m not assuming that. Under the current syntax, I would format your example as:<br>&gt; <br>&gt;     func someMethod&lt;<br>&gt;         S : SequenceType, T<br>&gt;         where S.Generator.Element == T<br>&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;         ...<br>&gt;     }<br></p><p>You are both right here, but please note that the proposal still also allows moving all constraints to the `where` clause:<br></p><p>    func someMethod&lt;S, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>        where S : SequenceType,<br>              S.Generator.Element == T<br>    {<br>        ...<br>    }<br></p><p>just like Swift 2 allows doing so within the `&lt;...&gt;` brackets:<br></p><p>    func someMethod&lt;S, T<br>        where S : SequenceType, S.Generator.Element == T<br>    &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>        ...<br>    }<br></p><p>The reason I&#39;d recommend that style for anything but simple constraints is because:<br></p><p>1) It makes the call site `let items = someMethod(value: things)` lightest to visually match to the declaration, because the only thing between the function name and its argument list is the `&lt;...&gt;` bracketed list of introduced generic types which you&#39;ll expect to see in the function signature and constraints.<br></p><p>2) In general, the `where` constraints really apply to the whole function/type declaration, not just a single generic parameter.<br></p><p>3) It was claimed that all constraints should go right next to the introduction of the generic parameters. But that isn&#39;t the whole case because Swift also applies implicit constraints onto any generic parameters that are used in constrained positions. If that wasn&#39;t clearly said, take the following example in Swift 2.x:<br></p><p>    func aMethod&lt;S : SequenceType, T where S.Generator.Element == T&gt;(value: S) -&gt; Set&lt;T&gt; {<br>        return Set(value)<br>    }<br></p><p>That declaration actually makes you wait all the way until the return type `Set&lt;T&gt;` until you learn that `T` must also necessarily be `Hashable`. So I don&#39;t see how it&#39;s that different if the `where` clause isn&#39;t right next to the generic type arguments&#39; introduction:<br></p><p>    func aMethod&lt;S, T&gt;(value: S) -&gt; Set&lt;T&gt; // FWIW, this line contains what I usually have in mind when browsing code.<br>        where // T : Hashable, // (implicit)<br>              S : SequenceType,<br>              S.Generator.Element == T<br>    {<br>        return Set(value)<br>    }<br></p><p>— Pyry<br></p><p>PS. Besides, neither the original example nor mine was really fair; you don&#39;t need `where` for these. Instead, you&#39;d just write:<br></p><p>    func someMethod&lt;S : SequenceType&gt;(value: S) -&gt; AnySequence&lt;S.Generator.Element&gt; {<br>        ...<br>    }<br></p><p>which SE-0081 has nothing to argue for or against.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/aedc8c76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 14, 2016, at 9:43 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Tony &amp; Haravikk,<br>&gt; <br>&gt; (Reformatting your quoted examples just a bit…)<br>&gt; <br>&gt;&gt;&gt; It enables things like:<br>&gt;&gt;&gt;     func someMethod&lt;S : SequenceType, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;&gt;&gt;         where S.Generator.Element == T { ... }<br>&gt;&gt; <br>&gt;&gt; I&#39;m not assuming that. Under the current syntax, I would format your example as:<br>&gt;&gt; <br>&gt;&gt;     func someMethod&lt;<br>&gt;&gt;         S : SequenceType, T<br>&gt;&gt;         where S.Generator.Element == T<br>&gt;&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt; <br>&gt; You are both right here, but please note that the proposal still also allows moving all constraints to the `where` clause:<br>&gt; <br>&gt;     func someMethod&lt;S, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;         where S : SequenceType,<br>&gt;               S.Generator.Element == T<br>&gt;     {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; just like Swift 2 allows doing so within the `&lt;...&gt;` brackets:<br>&gt; <br>&gt;     func someMethod&lt;S, T<br>&gt;         where S : SequenceType, S.Generator.Element == T<br>&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; The reason I&#39;d recommend that style for anything but simple constraints is because:<br>&gt; <br>&gt; 1) It makes the call site `let items = someMethod(value: things)` lightest to visually match to the declaration, because the only thing between the function name and its argument list is the `&lt;...&gt;` bracketed list of introduced generic types which you&#39;ll expect to see in the function signature and constraints.<br>&gt; <br>&gt; 2) In general, the `where` constraints really apply to the whole function/type declaration, not just a single generic parameter.<br>&gt; <br>&gt; 3) It was claimed that all constraints should go right next to the introduction of the generic parameters. But that isn&#39;t the whole case because Swift also applies implicit constraints onto any generic parameters that are used in constrained positions. If that wasn&#39;t clearly said, take the following example in Swift 2.x:<br>&gt; <br>&gt;     func aMethod&lt;S : SequenceType, T where S.Generator.Element == T&gt;(value: S) -&gt; Set&lt;T&gt; {<br>&gt;         return Set(value)<br>&gt;     }<br>&gt; <br>&gt; That declaration actually makes you wait all the way until the return type `Set&lt;T&gt;` until you learn that `T` must also necessarily be `Hashable`. So I don&#39;t see how it&#39;s that different if the `where` clause isn&#39;t right next to the generic type arguments&#39; introduction:<br>&gt; <br>&gt;     func aMethod&lt;S, T&gt;(value: S) -&gt; Set&lt;T&gt; // FWIW, this line contains what I usually have in mind when browsing code.<br>&gt;         where // T : Hashable, // (implicit)<br>&gt;               S : SequenceType,<br>&gt;               S.Generator.Element == T<br>&gt;     {<br>&gt;         return Set(value)<br>&gt;     }<br>&gt; <br>&gt; — Pyry<br>&gt; <br></p><p>IMHO proposals like this should never be discussed in the context of trivial examples as the full scope of their value gets lost. I have written enough generics code in other languages to appreciate the idea of a &#39;headline-form-followed-by-the-details-idea&#39; for any complex declaration. My understanding is that the proposal offers to make us write explicitely what anyone reading the code will try to extract out of the declaration. Instead of 100&#39;s or 1000&#39;s doing the work in their heads, the code author does it once for all subsequent readers. What&#39;s not to like about this idea?<br></p><p>&gt; PS. Besides, neither the original example nor mine was really fair; you don&#39;t need `where` for these. Instead, you&#39;d just write:<br>&gt; <br>&gt;     func someMethod&lt;S : SequenceType&gt;(value: S) -&gt; AnySequence&lt;S.Generator.Element&gt; {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; which SE-0081 has nothing to argue for or against.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/29d7872b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 15, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; IMHO proposals like this should never be discussed in the context of trivial examples as the full scope of their value gets lost. I have written enough generics code in other languages to appreciate the idea of a &#39;headline-form-followed-by-the-details-idea&#39; for any complex declaration. My understanding is that the proposal offers to make us write explicitely what anyone reading the code will try to extract out of the declaration. Instead of 100&#39;s or 1000&#39;s doing the work in their heads, the code author does it once for all subsequent readers. What&#39;s not to like about this idea?<br></p><p>There is a lot not to like about the idea; even if it was optional. Personally, I feel the problem is solved in a much, much more elegant manner by other proposals.<br></p><p>Firstly, the stuff after the ‘where’ clause is getting shorter once typealiases come to protocols. C.Iterator.Element become C.Element. In this one example, that’s 18 characters down to 9 - a 50% reduction in length. We tend to use quite expressive names for associated types, so I expect we’ll see similar gains elsewhere from this very simple proposal.<br></p><p>Not only that, but there’s a very good proposal to add ‘where’ clauses to associated types in the protocols themselves, which will likely further reduce the verbosity of the constraints you need to specify at each declaration site. https://github.com/hartbit/swift-evolution/blob/9acd75abfbe626bbb3f9458cc3f6edb1d1f88c95/proposals/XXXX-associated-types-constraints.md &lt;https://github.com/hartbit/swift-evolution/blob/9acd75abfbe626bbb3f9458cc3f6edb1d1f88c95/proposals/XXXX-associated-types-constraints.md&gt;<br></p><p>And then we have generic typealiases and generalised existentials, which would allow us to wrap those ‘where’ clauses in to something much more intelligible to a human being at first glance. ‘StringCollection’ or ‘CollectionOfStrings’ is much clearer than &lt;C:Collection where C.Element==String&gt;, no matter how you chop it up.<br></p><p>If I look at the other proposals, and where we are headed with much more expressive typealiases and associated types, I just feel that that’s the future: that’s the “swift’ way. It’s like type inference - all of the strict constraints are still there under-the-hood, but you’re able to work at a much clearer and more obvious abstraction level. This proposal pulls us further away from things like ‘obviousness’, and like I said, simply feels like an inelegant solution.<br></p><p>At the very least, I think we should shelve the discussion until the larger expansion of typealiases, etc is complete. We should re-evaluate at that time, with a bigger set of more general-purpose tools to produce readable code.<br></p><p><br>&gt; On 14 May 2016, at 22:28, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 14, 2016, at 9:43 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Tony &amp; Haravikk,<br>&gt;&gt; <br>&gt;&gt; (Reformatting your quoted examples just a bit…)<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It enables things like:<br>&gt;&gt;&gt;&gt;     func someMethod&lt;S : SequenceType, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;         where S.Generator.Element == T { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not assuming that. Under the current syntax, I would format your example as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func someMethod&lt;<br>&gt;&gt;&gt;         S : SequenceType, T<br>&gt;&gt;&gt;         where S.Generator.Element == T<br>&gt;&gt;&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; You are both right here, but please note that the proposal still also allows moving all constraints to the `where` clause:<br>&gt;&gt; <br>&gt;&gt;     func someMethod&lt;S, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;&gt;         where S : SequenceType,<br>&gt;&gt;               S.Generator.Element == T<br>&gt;&gt;     {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; just like Swift 2 allows doing so within the `&lt;...&gt;` brackets:<br>&gt;&gt; <br>&gt;&gt;     func someMethod&lt;S, T<br>&gt;&gt;         where S : SequenceType, S.Generator.Element == T<br>&gt;&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; The reason I&#39;d recommend that style for anything but simple constraints is because:<br>&gt;&gt; <br>&gt;&gt; 1) It makes the call site `let items = someMethod(value: things)` lightest to visually match to the declaration, because the only thing between the function name and its argument list is the `&lt;...&gt;` bracketed list of introduced generic types which you&#39;ll expect to see in the function signature and constraints.<br>&gt;&gt; <br>&gt;&gt; 2) In general, the `where` constraints really apply to the whole function/type declaration, not just a single generic parameter.<br>&gt;&gt; <br>&gt;&gt; 3) It was claimed that all constraints should go right next to the introduction of the generic parameters. But that isn&#39;t the whole case because Swift also applies implicit constraints onto any generic parameters that are used in constrained positions. If that wasn&#39;t clearly said, take the following example in Swift 2.x:<br>&gt;&gt; <br>&gt;&gt;     func aMethod&lt;S : SequenceType, T where S.Generator.Element == T&gt;(value: S) -&gt; Set&lt;T&gt; {<br>&gt;&gt;         return Set(value)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; That declaration actually makes you wait all the way until the return type `Set&lt;T&gt;` until you learn that `T` must also necessarily be `Hashable`. So I don&#39;t see how it&#39;s that different if the `where` clause isn&#39;t right next to the generic type arguments&#39; introduction:<br>&gt;&gt; <br>&gt;&gt;     func aMethod&lt;S, T&gt;(value: S) -&gt; Set&lt;T&gt; // FWIW, this line contains what I usually have in mind when browsing code.<br>&gt;&gt;         where // T : Hashable, // (implicit)<br>&gt;&gt;               S : SequenceType,<br>&gt;&gt;               S.Generator.Element == T<br>&gt;&gt;     {<br>&gt;&gt;         return Set(value)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; — Pyry<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; PS. Besides, neither the original example nor mine was really fair; you don&#39;t need `where` for these. Instead, you&#39;d just write:<br>&gt;&gt; <br>&gt;&gt;     func someMethod&lt;S : SequenceType&gt;(value: S) -&gt; AnySequence&lt;S.Generator.Element&gt; {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; which SE-0081 has nothing to argue for or against.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/832c849a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 15, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Karl,<br></p><p>As author of this proposal, the one about constraints on associated types, and the one on type-aliases in protocols (all from the Generics Manifesto - original authorship to Douglas Gregor) I’d like to provide additional reasoning behind my wish to push this proposal through, as a whole.<br></p><p>First of all, there is a personal preference. I’ve used C# for many many years, which has its where clause at the end of the declaration (like this proposal), and I’ve used Swift since its unveiling. The experience with using both styles for several years makes me favour this proposal’s syntax because I find it much easier to read and format for readability.<br></p><p>Constraints on associated type will provide more expressivity but I doubt it will greatly reduce protocol constraint clauses in a majority of cases. And yes, type-aliases in protocols will shorten clauses, but I still think they will more readable with the where clause at the end.<br></p><p>For example, here is a method I took (as-is) from the Standard Library which has a few constraints, and which I further simplified if we imagine that Sequence has an Element typealias for Iterator.Element:<br></p><p><br>internal func _arrayOutOfPlaceReplace&lt;<br>  B : _ArrayBufferProtocol, C : Collection<br>  where<br>  C.Element == B.Element,<br>  B.Index == Int<br>&gt;(<br>  _ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int<br>) {<br></p><p>See how the Standard Library authors formatted it for readability and how as a consequence arguments which use the generic types are further apart from the declaration of those generic types. But with this proposal, the declaration might be formatted to:<br></p><p>internal func _arrayOutOfPlaceReplace&lt;B, C&gt;(_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int) where<br>  B : _ArrayBufferProtocol,<br>  C : Collection,<br>  C.Iterator.Element == B.Element,<br>  B.Index == Int<br>{<br></p><p>Do you need believe this is now more readable?<br></p><p>David.<br></p><p>&gt; On 15 May 2016, at 02:26, Karl Wagner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a lot not to like about the idea; even if it was optional. Personally, I feel the problem is solved in a much, much more elegant manner by other proposals.<br>&gt; <br>&gt; Firstly, the stuff after the ‘where’ clause is getting shorter once typealiases come to protocols. C.Iterator.Element become C.Element. In this one example, that’s 18 characters down to 9 - a 50% reduction in length. We tend to use quite expressive names for associated types, so I expect we’ll see similar gains elsewhere from this very simple proposal.<br>&gt; <br>&gt; Not only that, but there’s a very good proposal to add ‘where’ clauses to associated types in the protocols themselves, which will likely further reduce the verbosity of the constraints you need to specify at each declaration site. https://github.com/hartbit/swift-evolution/blob/9acd75abfbe626bbb3f9458cc3f6edb1d1f88c95/proposals/XXXX-associated-types-constraints.md &lt;https://github.com/hartbit/swift-evolution/blob/9acd75abfbe626bbb3f9458cc3f6edb1d1f88c95/proposals/XXXX-associated-types-constraints.md&gt;<br>&gt; <br>&gt; And then we have generic typealiases and generalised existentials, which would allow us to wrap those ‘where’ clauses in to something much more intelligible to a human being at first glance. ‘StringCollection’ or ‘CollectionOfStrings’ is much clearer than &lt;C:Collection where C.Element==String&gt;, no matter how you chop it up.<br>&gt; <br>&gt; If I look at the other proposals, and where we are headed with much more expressive typealiases and associated types, I just feel that that’s the future: that’s the “swift’ way. It’s like type inference - all of the strict constraints are still there under-the-hood, but you’re able to work at a much clearer and more obvious abstraction level. This proposal pulls us further away from things like ‘obviousness’, and like I said, simply feels like an inelegant solution.<br>&gt; <br>&gt; At the very least, I think we should shelve the discussion until the larger expansion of typealiases, etc is complete. We should re-evaluate at that time, with a bigger set of more general-purpose tools to produce readable code.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/ba9495fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 15, 2016, at 9:17 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Hi Karl,<br>&gt; <br>&gt; As author of this proposal, the one about constraints on associated types, and the one on type-aliases in protocols (all from the Generics Manifesto - original authorship to Douglas Gregor) I’d like to provide additional reasoning behind my wish to push this proposal through, as a whole.<br>&gt; <br>&gt; First of all, there is a personal preference. I’ve used C# for many many years, which has its where clause at the end of the declaration (like this proposal), and I’ve used Swift since its unveiling. The experience with using both styles for several years makes me favour this proposal’s syntax because I find it much easier to read and format for readability.<br>&gt; <br>&gt; Constraints on associated type will provide more expressivity but I doubt it will greatly reduce protocol constraint clauses in a majority of cases. And yes, type-aliases in protocols will shorten clauses, but I still think they will more readable with the where clause at the end.<br>&gt; <br>&gt; For example, here is a method I took (as-is) from the Standard Library which has a few constraints, and which I further simplified if we imagine that Sequence has an Element typealias for Iterator.Element:<br>&gt; <br>&gt; <br>&gt; internal func _arrayOutOfPlaceReplace&lt;<br>&gt;   B : _ArrayBufferProtocol, C : Collection<br>&gt;   where<br>&gt;   C.Element == B.Element,<br>&gt;   B.Index == Int<br>&gt; &gt;(<br>&gt;   _ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int<br>&gt; ) {<br>&gt; <br>&gt; See how the Standard Library authors formatted it for readability and how as a consequence arguments which use the generic types are further apart from the declaration of those generic types. But with this proposal, the declaration might be formatted to:<br>&gt; <br>&gt; internal func _arrayOutOfPlaceReplace&lt;B, C&gt;(_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int) where<br>&gt;   B : _ArrayBufferProtocol,<br>&gt;   C : Collection,<br>&gt;   C.Iterator.Element == B.Element,<br>&gt;   B.Index == Int<br>&gt; {<br></p><p>Reading this example reinforces my initial sense that while WHERE works well when the information is inlined, I would have preferred WITH in the case where the information is at the end. go figure...<br></p><p><br>&gt; <br>&gt; Do you need believe this is now more readable?<br>&gt; <br>&gt; David.<br>&gt; <br>&gt;&gt; On 15 May 2016, at 02:26, Karl Wagner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is a lot not to like about the idea; even if it was optional. Personally, I feel the problem is solved in a much, much more elegant manner by other proposals.<br>&gt;&gt; <br>&gt;&gt; Firstly, the stuff after the ‘where’ clause is getting shorter once typealiases come to protocols. C.Iterator.Element become C.Element. In this one example, that’s 18 characters down to 9 - a 50% reduction in length. We tend to use quite expressive names for associated types, so I expect we’ll see similar gains elsewhere from this very simple proposal.<br>&gt;&gt; <br>&gt;&gt; Not only that, but there’s a very good proposal to add ‘where’ clauses to associated types in the protocols themselves, which will likely further reduce the verbosity of the constraints you need to specify at each declaration site. https://github.com/hartbit/swift-evolution/blob/9acd75abfbe626bbb3f9458cc3f6edb1d1f88c95/proposals/XXXX-associated-types-constraints.md<br>&gt;&gt; <br>&gt;&gt; And then we have generic typealiases and generalised existentials, which would allow us to wrap those ‘where’ clauses in to something much more intelligible to a human being at first glance. ‘StringCollection’ or ‘CollectionOfStrings’ is much clearer than &lt;C:Collection where C.Element==String&gt;, no matter how you chop it up.<br>&gt;&gt; <br>&gt;&gt; If I look at the other proposals, and where we are headed with much more expressive typealiases and associated types, I just feel that that’s the future: that’s the “swift’ way. It’s like type inference - all of the strict constraints are still there under-the-hood, but you’re able to work at a much clearer and more obvious abstraction level. This proposal pulls us further away from things like ‘obviousness’, and like I said, simply feels like an inelegant solution.<br>&gt;&gt; <br>&gt;&gt; At the very least, I think we should shelve the discussion until the larger expansion of typealiases, etc is complete. We should re-evaluate at that time, with a bigger set of more general-purpose tools to produce readable code.<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/b81ce084/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 14, 2016 at 10:00:00pm</p></header><div class="content"><p>My only reservation would be the choice of WHERE which I would have kept for more *dynamic* situations int the language. My first choice for this would have been WITH which in my minds carries a more permanent, intemporal connotation in my mind. But that is off topic for this discussion.<br></p><p>&gt; On May 14, 2016, at 9:43 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Tony &amp; Haravikk,<br>&gt; <br>&gt; (Reformatting your quoted examples just a bit…)<br>&gt; <br>&gt;&gt;&gt; It enables things like:<br>&gt;&gt;&gt;     func someMethod&lt;S : SequenceType, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;&gt;&gt;         where S.Generator.Element == T { ... }<br>&gt;&gt; <br>&gt;&gt; I&#39;m not assuming that. Under the current syntax, I would format your example as:<br>&gt;&gt; <br>&gt;&gt;     func someMethod&lt;<br>&gt;&gt;         S : SequenceType, T<br>&gt;&gt;         where S.Generator.Element == T<br>&gt;&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt; <br>&gt; You are both right here, but please note that the proposal still also allows moving all constraints to the `where` clause:<br>&gt; <br>&gt;     func someMethod&lt;S, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>&gt;         where S : SequenceType,<br>&gt;               S.Generator.Element == T<br>&gt;     {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; just like Swift 2 allows doing so within the `&lt;...&gt;` brackets:<br>&gt; <br>&gt;     func someMethod&lt;S, T<br>&gt;         where S : SequenceType, S.Generator.Element == T<br>&gt;     &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; The reason I&#39;d recommend that style for anything but simple constraints is because:<br>&gt; <br>&gt; 1) It makes the call site `let items = someMethod(value: things)` lightest to visually match to the declaration, because the only thing between the function name and its argument list is the `&lt;...&gt;` bracketed list of introduced generic types which you&#39;ll expect to see in the function signature and constraints.<br>&gt; <br>&gt; 2) In general, the `where` constraints really apply to the whole function/type declaration, not just a single generic parameter.<br>&gt; <br>&gt; 3) It was claimed that all constraints should go right next to the introduction of the generic parameters. But that isn&#39;t the whole case because Swift also applies implicit constraints onto any generic parameters that are used in constrained positions. If that wasn&#39;t clearly said, take the following example in Swift 2.x:<br>&gt; <br>&gt;     func aMethod&lt;S : SequenceType, T where S.Generator.Element == T&gt;(value: S) -&gt; Set&lt;T&gt; {<br>&gt;         return Set(value)<br>&gt;     }<br>&gt; <br>&gt; That declaration actually makes you wait all the way until the return type `Set&lt;T&gt;` until you learn that `T` must also necessarily be `Hashable`. So I don&#39;t see how it&#39;s that different if the `where` clause isn&#39;t right next to the generic type arguments&#39; introduction:<br>&gt; <br>&gt;     func aMethod&lt;S, T&gt;(value: S) -&gt; Set&lt;T&gt; // FWIW, this line contains what I usually have in mind when browsing code.<br>&gt;         where // T : Hashable, // (implicit)<br>&gt;               S : SequenceType,<br>&gt;               S.Generator.Element == T<br>&gt;     {<br>&gt;         return Set(value)<br>&gt;     }<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; PS. Besides, neither the original example nor mine was really fair; you don&#39;t need `where` for these. Instead, you&#39;d just write:<br>&gt; <br>&gt;     func someMethod&lt;S : SequenceType&gt;(value: S) -&gt; AnySequence&lt;S.Generator.Element&gt; {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; which SE-0081 has nothing to argue for or against.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/f6d19e7a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 14.05.2016 um 20:19 schrieb Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On 2016-05-14 16:29:40 +0000, Haravikk via swift-evolution said:<br>&gt; <br>&gt;&gt; On 14 May 2016, at 16:52, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; To me, this makes declarations with complex sets of constraints much harder to read, because I have to hunt them down instead of finding them all in one place. Under this proposal, the longer an argument list gets, the further separated the constraints are from the type parameters that use them.<br>&gt;&gt; This is partly an issue of how you use the feature rather than an issue with the feature itself, as you’re assuming that everything is all on one line, but really I think the intent of this feature is to better support multi-line declarations. It enables things like:<br>&gt;&gt; 	func someMethod&lt;S:SequenceType, T&gt;(value:S) -&gt; AnySequence&lt;T&gt;<br>&gt;&gt; 		where S.Generator.Element == T { … }<br>&gt; <br>&gt; I&#39;m not assuming that. Under the current syntax, I would format your example as:<br>&gt; <br>&gt;   func someMethod&lt;<br>&gt;       S: SequenceType, T<br>&gt;       where S.Generator.Element == T<br>&gt;   &gt;(value: S) -&gt; AnySequence&lt;T&gt; {<br>&gt;       ...<br>&gt;   }<br>&gt; <br>&gt; which I find to be quite readable across multiple lines without scattering the generic type information in two places across the function.<br></p><p>But this scatters the function definition itself, i.e. the name of the function and its parameter list and return type over multiple lines.<br>And splitting the &lt;&gt; over multiple lines is really ugly. The leading &gt; even looks like an operator (is it func &gt;(value: S) being defined?).<br></p><p>I think <br></p><p>func someMethod&lt;S: SequenceType, T&gt;(value: S) -&gt; AnySequence&lt;T&gt;<br>	where S.Generator.Element == T {<br>	…<br>}<br></p><p>is much more readable.<br></p><p>Or what about using some more suggestive names for the generic paramters, so that the core of the function definition can be kept even shorter without loosing readability:<br></p><p>func someMethod&lt;Seq, Elem&gt;(value: Seq) -&gt; AnySequence&lt;Elem&gt;<br>	where<br>	Seq: SequenceType,<br>	Seq.Generator.Element == Elem {<br>	…<br>}<br></p><p>Here, I don’t see the need to keep all constraints up front because the generic parameters already suggest their nature. The where clause just fills in the technical constraints.<br></p><p>This would not be possible with the current syntax at all.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; The actual function signature stays on the top, but the constraint can now move down neatly, since it’s a supplementary condition that you may not to consider right away, or at all, if it’s just reinforcing some kind of common-sense limitation.<br>&gt; <br>&gt; That&#39;s kind of a judgment call, though. Not all constraints fit that mold—some encode very important information that it makes sense to keep up front.<br>&gt; <br>&gt; <br>&gt;&gt; This is partly why I’d prefer to see it optional though, as some things will fit on one line reasonably well (you probably could with the above for example), but like you say, with it all on one line the return type becomes less visible.<br>&gt; <br>&gt; No matter how you format the proposed syntax, the return type is sandwiched in the middle of two things that describe generic type information—whether it&#39;s on one line or not doesn&#39;t change that. I believe that harms readability, especially if you have some constraints (conformance) on the left and some (associated types) on the right.<br>&gt; <br>&gt; I would be strongly opposed to making this optional—that adds complexity to the language to support parsing two patterns, as well as the cognitive load of someone reading Swift code, especially if written in the different style. As was mentioned in another thread, &quot;Swift is an opinionated languge&quot;, and I hope we&#39;d be prescriptive about syntactic constructs like this that are more significant than &quot;does the curly brace go on the same line or the next line&quot;. (Even if the choice is one that I disagree with in the end, I&#39;d rather there be one way than multiple ways!)<br>&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
