<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7d8c9e1fbae20693c46f141d019e37da?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Edward Valentini</string> &lt;edwardvalentini at gmail.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined: <br></p><p>enum MyDirection {<br>   case east, west<br>}<br></p><p>My app for example also makes use of north and south, so I would love to be able to write: <br></p><p>extension MyDirection {<br>   case north,south<br>}<br></p><p>In objective c, one would probably have defined constants like MyDirectionEast etc...  these would probably have been mapped to ints or strings so a consumer of this library could have easily extended this to add additional functionality, but using constants like that is not very &quot;swifty&quot;<br></p><p>I&#39;m curious what the swift community thinks.<br></p><p>Thank you<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>By itself, this would break switch statements, since they have to be exhaustive.<br></p><p>If anyone has any ideas about how to fix that, I&#39;m all ears.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined: <br>&gt; <br>&gt; enum MyDirection {<br>&gt;   case east, west<br>&gt; }<br>&gt; <br>&gt; My app for example also makes use of north and south, so I would love to be able to write: <br>&gt; <br>&gt; extension MyDirection {<br>&gt;   case north,south<br>&gt; }<br>&gt; <br>&gt; In objective c, one would probably have defined constants like MyDirectionEast etc...  these would probably have been mapped to ints or strings so a consumer of this library could have easily extended this to add additional functionality, but using constants like that is not very &quot;swifty&quot;<br>&gt; <br>&gt; I&#39;m curious what the swift community thinks.<br>&gt; <br>&gt; Thank you <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7d8c9e1fbae20693c46f141d019e37da?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Edward Valentini</string> &lt;edwardvalentini at gmail.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>Existing switch statements would have to be modified to add a default statement.  Additionally enums could be marked final to disallow case option expansion<br></p><p><br></p><p>On Jun 30, 2016, at 16:04, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; By itself, this would break switch statements, since they have to be exhaustive.<br>&gt; <br>&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined: <br>&gt;&gt; <br>&gt;&gt; enum MyDirection {<br>&gt;&gt;  case east, west<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; My app for example also makes use of north and south, so I would love to be able to write: <br>&gt;&gt; <br>&gt;&gt; extension MyDirection {<br>&gt;&gt;  case north,south<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In objective c, one would probably have defined constants like MyDirectionEast etc...  these would probably have been mapped to ints or strings so a consumer of this library could have easily extended this to add additional functionality, but using constants like that is not very &quot;swifty&quot;<br>&gt;&gt; <br>&gt;&gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt; <br>&gt;&gt; Thank you <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb40b031ffdd8f92686a2a4f4caf0c68?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Guillermo Peralta Scura</string> &lt;gperaltascura at gmail.com&gt;<p>June 30, 2016 at 08:00:00pm</p></header><div class="content"><p>I think we have the same question as with the &quot;sealed&quot; classes by default<br>proposal. To allow or not extension of the public API by the user (at least<br>by default).<br></p><p>El jue., 30 jun. 2016 a las 16:10, Edward Valentini via swift-evolution (&lt;<br>swift-evolution at swift.org&gt;) escribi√≥:<br></p><p>&gt;<br>&gt; Existing switch statements would have to be modified to add a default<br>&gt; statement.  Additionally enums could be marked final to disallow case<br>&gt; option expansion<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jun 30, 2016, at 16:04, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; By itself, this would break switch statements, since they have to be<br>&gt; exhaustive.<br>&gt; &gt;<br>&gt; &gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt; &gt;<br>&gt; &gt; - Dave Sweeris<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt; solution would be to allow enum extensions to add to existing case<br>&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt; enum defined:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; enum MyDirection {<br>&gt; &gt;&gt;  case east, west<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My app for example also makes use of north and south, so I would love<br>&gt; to be able to write:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension MyDirection {<br>&gt; &gt;&gt;  case north,south<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In objective c, one would probably have defined constants like<br>&gt; MyDirectionEast etc...  these would probably have been mapped to ints or<br>&gt; strings so a consumer of this library could have easily extended this to<br>&gt; add additional functionality, but using constants like that is not very<br>&gt; &quot;swifty&quot;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m curious what the swift community thinks.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thank you<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/126c6799/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>June 30, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;ve had a draft of a proposal lying around for a while which addresses<br>exactly this, but I haven&#39;t gotten around to sending it out for comments<br>yet. Link<br>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br></p><p>Would appreciate if you guys took a look.<br>Dan Appel<br></p><p>Pasted inline below<br></p><p>Extensible Enums<br></p><p>   - Proposal: SE-NNNN<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>   - Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>   - Status: Awaiting review<br>   &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>   - Review manager: TBD<br></p><p>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;<br>Introduction<br></p><p>This proposal introduces a new keyword that can be applied to enums which<br>allows new cases to be introduced in extensions.<br></p><p>Swift-evolution thread: [RFC] Extensible Enums<br>&lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;<br>Motivation<br></p><p>Enums are a powerful feature which provides a lot of benefit if you have a<br>limited number of behaviors. For example, associated values provide the<br>ability to make every case essentially a separate type. However, due to the<br>static nature of enums, they cannot be used in situations where they would<br>otherwise be a perfect fit.<br></p><p>An example of this would be the use of an Error enum like so:<br></p><p>enum FileError: ErrorProtocol {<br>    case fileNotFound(path: String)<br>    case corruptedFile(bytes: [Int8])<br>}func readFile() throws { ... }<br>// elsewhere in the codebasedo {<br>    try readFile()<br>} catch let error as FileError {<br>    switch error {<br>        case .fileNotFound(let path): // handle error<br>        case .corruptedFile(let bytes): // handle error<br>    }<br>} catch { ... }<br></p><p>While this is generally a good approach, it can be very dangerous for<br>library consumers if the author exposes the error to the user. This is due<br>to the fact that the switch statement has to be exhaustive and is only<br>satisfied when all enum cases have been accounted for. What this means for<br>library authors is that every time they add a new case to a public enum,<br>they are breaking the exhaustivity of the switch and making their library<br>backwards-incompatible.<br></p><p>Currently, the best workaround is to use a struct with static instances and<br>overloading the ~= operator. This allows for similar switch behavior but<br>overall is much less flexible, missing key features such as associated<br>values.<br></p><p>Another example is when the library is split into multiple modules, where<br>the error is defined in the first module and the second module wants to add<br>some error cases. An enum is very rarely used in this case because you<br>cannot add cases in other modules. Instead, library authors either use an<br>error protocol, and add more types that conform to it, or use the struct<br>approach shown above. While this is not terrible, adding cases in<br>extensions would better translate the intention of the author and adds more<br>flexiblity.<br>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed<br>solution<br></p><p>The solution proposed is quite simple: add an extensible keyword/modifier<br>that can be applied to enums, which would require the default case when<br>switched on and allow new cases to be added in extensions.<br></p><p>Here is the translation of the very first example to the use an extensible enum<br>instead, with a new case added:<br></p><p>extensible enum ThingError: ErrorProtocol {<br>    case fileNotFound(path: String)<br>    case corruptedFile(bytes: [Int8])<br>    case failedReadingFile<br>}func readFile() throws { ... }<br>// elsewhere in the codebasedo {<br>    try readFile()<br>} catch let error as ThingError {<br>    switch error {<br>        case .fileNotFound(let path): // handle error<br>        case .corruptedFile(let bytes): // handle error<br>        default: // handle future errors that don&#39;t exist yet<br>    }<br>} catch { ... }<br></p><p>For the second example, we can simply extend the enum in the higher-level<br>module.<br></p><p>// Module FileProtocol<br></p><p>extensible enum FileError: ErrorProtocol {<br>    case fileNotFound(path: String)<br>}<br>protocol FileProtocol {<br>    func read() throws<br>}<br>// Module File<br>extension FileError {<br>    case corruptedFile(bytes: [Int8])<br>    case failedReadingFile<br>}<br>struct File: FileProtocol {<br>    func read() throws { ... }<br>}<br></p><p>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed<br>design<br></p><p>A new keyword would be added to the language which is only allowed in front<br>of the enum keyword. When an enum is marked extensible, new cases can be<br>added in extensions and switches that are performed on it require a default<br>case.<br>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>There is no impact on existing code since this is purely an additive<br>feature.<br>&lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives<br>considered<br></p><p>No alternatives have been considered (yet).<br></p><p><br></p><p>On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; By itself, this would break switch statements, since they have to be<br>&gt; exhaustive.<br>&gt;<br>&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt; solution would be to allow enum extensions to add to existing case<br>&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt; enum defined:<br>&gt; &gt;<br>&gt; &gt; enum MyDirection {<br>&gt; &gt;   case east, west<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; My app for example also makes use of north and south, so I would love to<br>&gt; be able to write:<br>&gt; &gt;<br>&gt; &gt; extension MyDirection {<br>&gt; &gt;   case north,south<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; In objective c, one would probably have defined constants like<br>&gt; MyDirectionEast etc...  these would probably have been mapped to ints or<br>&gt; strings so a consumer of this library could have easily extended this to<br>&gt; add additional functionality, but using constants like that is not very<br>&gt; &quot;swifty&quot;<br>&gt; &gt;<br>&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt; &gt;<br>&gt; &gt; Thank you<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/eddfdca2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7d8c9e1fbae20693c46f141d019e37da?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Edward Valentini</string> &lt;edwardvalentini at gmail.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>I really like the idea of making it opt in with the extensible keyword as opposed to opt out with final so this way there is no impact on existing code <br></p><p>&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses exactly this, but I haven&#39;t gotten around to sending it out for comments yet. Link.<br>&gt; <br>&gt; Would appreciate if you guys took a look.<br>&gt; Dan Appel<br>&gt; <br>&gt; Pasted inline below<br>&gt; <br>&gt; Extensible Enums<br>&gt; Proposal: SE-NNNN<br>&gt; Author: Dan Appel<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces a new keyword that can be applied to enums which allows new cases to be introduced in extensions.<br>&gt; <br>&gt; Swift-evolution thread: [RFC] Extensible Enums<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Enums are a powerful feature which provides a lot of benefit if you have a limited number of behaviors. For example, associated values provide the ability to make every case essentially a separate type. However, due to the static nature of enums, they cannot be used in situations where they would otherwise be a perfect fit. <br>&gt; <br>&gt; An example of this would be the use of an Error enum like so:<br>&gt; <br>&gt; enum FileError: ErrorProtocol {<br>&gt;     case fileNotFound(path: String)<br>&gt;     case corruptedFile(bytes: [Int8])<br>&gt; }<br>&gt; func readFile() throws { ... }<br>&gt; <br>&gt; // elsewhere in the codebase<br>&gt; do {<br>&gt;     try readFile()<br>&gt; } catch let error as FileError {<br>&gt;     switch error {<br>&gt;         case .fileNotFound(let path): // handle error<br>&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;     }<br>&gt; } catch { ... }<br>&gt; While this is generally a good approach, it can be very dangerous for library consumers if the author exposes the error to the user. This is due to the fact that the switch statement has to be exhaustive and is only satisfied when all enum cases have been accounted for. What this means for library authors is that every time they add a new case to a public enum, they are breaking the exhaustivity of the switch and making their library backwards-incompatible.<br>&gt; <br>&gt; Currently, the best workaround is to use a struct with static instances and overloading the ~= operator. This allows for similar switch behavior but overall is much less flexible, missing key features such as associated values.<br>&gt; <br>&gt; Another example is when the library is split into multiple modules, where the error is defined in the first module and the second module wants to add some error cases. An enum is very rarely used in this case because you cannot add cases in other modules. Instead, library authors either use an error protocol, and add more types that conform to it, or use the struct approach shown above. While this is not terrible, adding cases in extensions would better translate the intention of the author and adds more flexiblity.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution proposed is quite simple: add an extensible keyword/modifier that can be applied to enums, which would require the default case when switched on and allow new cases to be added in extensions.<br>&gt; <br>&gt; Here is the translation of the very first example to the use an extensible enum instead, with a new case added:<br>&gt; <br>&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;     case fileNotFound(path: String)<br>&gt;     case corruptedFile(bytes: [Int8])<br>&gt;     case failedReadingFile<br>&gt; }<br>&gt; func readFile() throws { ... }<br>&gt; <br>&gt; // elsewhere in the codebase<br>&gt; do {<br>&gt;     try readFile()<br>&gt; } catch let error as ThingError {<br>&gt;     switch error {<br>&gt;         case .fileNotFound(let path): // handle error<br>&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;     }<br>&gt; } catch { ... }<br>&gt; For the second example, we can simply extend the enum in the higher-level module.<br>&gt; <br>&gt; // Module FileProtocol<br>&gt; <br>&gt; extensible enum FileError: ErrorProtocol {<br>&gt;     case fileNotFound(path: String)<br>&gt; }<br>&gt; <br>&gt; protocol FileProtocol {<br>&gt;     func read() throws<br>&gt; }<br>&gt; <br>&gt; // Module File<br>&gt; <br>&gt; extension FileError {<br>&gt;     case corruptedFile(bytes: [Int8])<br>&gt;     case failedReadingFile<br>&gt; }<br>&gt; <br>&gt; struct File: FileProtocol {<br>&gt;     func read() throws { ... }<br>&gt; }<br>&gt; Detailed design<br>&gt; <br>&gt; A new keyword would be added to the language which is only allowed in front of the enum keyword. When an enum is marked extensible, new cases can be added in extensions and switches that are performed on it require a defaultcase.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; There is no impact on existing code since this is purely an additive feature.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; No alternatives have been considered (yet).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; By itself, this would break switch statements, since they have to be exhaustive.<br>&gt;&gt; <br>&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt; &gt;   case east, west<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My app for example also makes use of north and south, so I would love to be able to write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt; &gt;   case north,south<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In objective c, one would probably have defined constants like MyDirectionEast etc...  these would probably have been mapped to ints or strings so a consumer of this library could have easily extended this to add additional functionality, but using constants like that is not very &quot;swifty&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/b5a28773/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb40b031ffdd8f92686a2a4f4caf0c68?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Guillermo Peralta Scura</string> &lt;gperaltascura at gmail.com&gt;<p>June 30, 2016 at 08:00:00pm</p></header><div class="content"><p>I think the approach taken by your proporsal is really good. Would love to<br>have that feature for the language.<br></p><p>El jue., 30 jun. 2016 a las 16:19, Edward Valentini via swift-evolution (&lt;<br>swift-evolution at swift.org&gt;) escribi√≥:<br></p><p>&gt;<br>&gt; I really like the idea of making it opt in with the extensible keyword as<br>&gt; opposed to opt out with final so this way there is no impact on existing<br>&gt; code<br>&gt;<br>&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses<br>&gt; exactly this, but I haven&#39;t gotten around to sending it out for comments<br>&gt; yet. Link<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br>&gt;<br>&gt; Would appreciate if you guys took a look.<br>&gt; Dan Appel<br>&gt;<br>&gt; Pasted inline below<br>&gt;<br>&gt; Extensible Enums<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    - Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal introduces a new keyword that can be applied to enums which<br>&gt; allows new cases to be introduced in extensions.<br>&gt;<br>&gt; Swift-evolution thread: [RFC] Extensible Enums<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Enums are a powerful feature which provides a lot of benefit if you have a<br>&gt; limited number of behaviors. For example, associated values provide the<br>&gt; ability to make every case essentially a separate type. However, due to the<br>&gt; static nature of enums, they cannot be used in situations where they would<br>&gt; otherwise be a perfect fit.<br>&gt;<br>&gt; An example of this would be the use of an Error enum like so:<br>&gt;<br>&gt; enum FileError: ErrorProtocol {<br>&gt;     case fileNotFound(path: String)<br>&gt;     case corruptedFile(bytes: [Int8])<br>&gt; }func readFile() throws { ... }<br>&gt; // elsewhere in the codebasedo {<br>&gt;     try readFile()<br>&gt; } catch let error as FileError {<br>&gt;     switch error {<br>&gt;         case .fileNotFound(let path): // handle error<br>&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;     }<br>&gt; } catch { ... }<br>&gt;<br>&gt; While this is generally a good approach, it can be very dangerous for<br>&gt; library consumers if the author exposes the error to the user. This is due<br>&gt; to the fact that the switch statement has to be exhaustive and is only<br>&gt; satisfied when all enum cases have been accounted for. What this means for<br>&gt; library authors is that every time they add a new case to a public enum,<br>&gt; they are breaking the exhaustivity of the switch and making their library<br>&gt; backwards-incompatible.<br>&gt;<br>&gt; Currently, the best workaround is to use a struct with static instances<br>&gt; and overloading the ~= operator. This allows for similar switch behavior<br>&gt; but overall is much less flexible, missing key features such as associated<br>&gt; values.<br>&gt;<br>&gt; Another example is when the library is split into multiple modules, where<br>&gt; the error is defined in the first module and the second module wants to add<br>&gt; some error cases. An enum is very rarely used in this case because you<br>&gt; cannot add cases in other modules. Instead, library authors either use an<br>&gt; error protocol, and add more types that conform to it, or use the struct<br>&gt; approach shown above. While this is not terrible, adding cases in<br>&gt; extensions would better translate the intention of the author and adds more<br>&gt; flexiblity.<br>&gt;<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The solution proposed is quite simple: add an extensible keyword/modifier<br>&gt; that can be applied to enums, which would require the default case when<br>&gt; switched on and allow new cases to be added in extensions.<br>&gt;<br>&gt; Here is the translation of the very first example to the use an extensible enum<br>&gt; instead, with a new case added:<br>&gt;<br>&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;     case fileNotFound(path: String)<br>&gt;     case corruptedFile(bytes: [Int8])<br>&gt;     case failedReadingFile<br>&gt; }func readFile() throws { ... }<br>&gt; // elsewhere in the codebasedo {<br>&gt;     try readFile()<br>&gt; } catch let error as ThingError {<br>&gt;     switch error {<br>&gt;         case .fileNotFound(let path): // handle error<br>&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;     }<br>&gt; } catch { ... }<br>&gt;<br>&gt; For the second example, we can simply extend the enum in the higher-level<br>&gt; module.<br>&gt;<br>&gt; // Module FileProtocol<br>&gt;<br>&gt; extensible enum FileError: ErrorProtocol {<br>&gt;     case fileNotFound(path: String)<br>&gt; }<br>&gt; protocol FileProtocol {<br>&gt;     func read() throws<br>&gt; }<br>&gt; // Module File<br>&gt; extension FileError {<br>&gt;     case corruptedFile(bytes: [Int8])<br>&gt;     case failedReadingFile<br>&gt; }<br>&gt; struct File: FileProtocol {<br>&gt;     func read() throws { ... }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; A new keyword would be added to the language which is only allowed in<br>&gt; front of the enum keyword. When an enum is marked extensible, new cases<br>&gt; can be added in extensions and switches that are performed on it require a<br>&gt; defaultcase.<br>&gt;<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; There is no impact on existing code since this is purely an additive<br>&gt; feature.<br>&gt;<br>&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; No alternatives have been considered (yet).<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; By itself, this would break switch statements, since they have to be<br>&gt;&gt; exhaustive.<br>&gt;&gt;<br>&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt;&gt; solution would be to allow enum extensions to add to existing case<br>&gt;&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt;&gt; enum defined:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt; &gt;   case east, west<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My app for example also makes use of north and south, so I would love<br>&gt;&gt; to be able to write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt; &gt;   case north,south<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In objective c, one would probably have defined constants like<br>&gt;&gt; MyDirectionEast etc...  these would probably have been mapped to ints or<br>&gt;&gt; strings so a consumer of this library could have easily extended this to<br>&gt;&gt; add additional functionality, but using constants like that is not very<br>&gt;&gt; &quot;swifty&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Dan Appel<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/0148681a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>While it doesn‚Äôt give all the ‚Äúraw value‚Äù functionality of enum, it‚Äôs possible to use object instance uniqueness to get enum-like behavior that can be extended:<br></p><p>    public protocol OpenEnum: class, Hashable { }<br></p><p>    extension OpenEnum {<br>      public var hashValue: Int {<br>        return ObjectIdentifier(self).hashValue<br>      }<br>    }<br></p><p>    public func ==&lt;T: OpenEnum&gt;(lhs: T, rhs: T) -&gt; Bool {<br>      return lhs === rhs<br>    }<br></p><p>A library can provide:<br></p><p>    public final class Color: OpenEnum, CustomStringConvertible {<br>      public let description: String<br></p><p>      public init(description: String) {<br>        self.description = description<br>      }<br></p><p>      static let<br>        black = Color(description: &quot;black&quot;),<br>        white = Color(description: &quot;white&quot;)<br>    }<br></p><p>And then in a client project:<br></p><p>    extension Color {<br>      static let<br>        puce = Color(description: &quot;puce&quot;),<br>        mauve = Color(description: &quot;mauve&quot;),<br>        fuchsia = Color(description: &quot;fuchsia&quot;)<br>    }<br></p><p>(This is how Siesta provides an extensible set of pipeline stages. https://github.com/bustoutsolutions/siesta/pull/64)<br></p><p>With this approach, you still get the .member shortcut in some circumstances:<br></p><p>    let eyebleedPalette: [Color] = [.fuchsia, .black, .mauve]<br></p><p>‚Ä¶but not in others:<br></p><p>    // Compiles<br>    switch(color) {<br>      case Color.red: print(&quot;Danger!&quot;)<br>      case Color.mauve: print(&quot;Dancing!&quot;)<br>      default: print(&quot;Nothing notable&quot;)<br>    }<br></p><p>    // Does not compile<br>    switch(color) {<br>      case .red: print(&quot;Danger!&quot;)<br>      case .mauve: print(&quot;Dancing!&quot;)<br>      default: print(&quot;Nothing notable&quot;)<br>    }<br></p><p>Given that this already comes close to giving the sort of functionality one would want out of an extensible enum, perhaps it‚Äôs better to fill out the gaps in this approach instead of adding a new language feature? This would have the advantage of not adding a keyword, and presumably provide useful behaviors that generalize to patterns other than extensible enums.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>&gt; On Jun 30, 2016, at 3:23 PM, Guillermo Peralta Scura via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the approach taken by your proporsal is really good. Would love to have that feature for the language.<br>&gt; <br>&gt; El jue., 30 jun. 2016 a las 16:19, Edward Valentini via swift-evolution (&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) escribi√≥:<br>&gt; <br>&gt; I really like the idea of making it opt in with the extensible keyword as opposed to opt out with final so this way there is no impact on existing code <br>&gt; <br>&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com &lt;mailto:dan.appel00 at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses exactly this, but I haven&#39;t gotten around to sending it out for comments yet. Link &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br>&gt;&gt; <br>&gt;&gt; Would appreciate if you guys took a look.<br>&gt;&gt; Dan Appel<br>&gt;&gt; <br>&gt;&gt; Pasted inline below<br>&gt;&gt; <br>&gt;&gt; Extensible Enums<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt; Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>&gt;&gt; Status: Awaiting review &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces a new keyword that can be applied to enums which allows new cases to be introduced in extensions.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [RFC] Extensible Enums &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Enums are a powerful feature which provides a lot of benefit if you have a limited number of behaviors. For example, associated values provide the ability to make every case essentially a separate type. However, due to the static nature of enums, they cannot be used in situations where they would otherwise be a perfect fit. <br>&gt;&gt; <br>&gt;&gt; An example of this would be the use of an Error enum like so:<br>&gt;&gt; <br>&gt;&gt; enum FileError: ErrorProtocol {<br>&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt; }<br>&gt;&gt; func readFile() throws { ... }<br>&gt;&gt; <br>&gt;&gt; // elsewhere in the codebase<br>&gt;&gt; do {<br>&gt;&gt;     try readFile()<br>&gt;&gt; } catch let error as FileError {<br>&gt;&gt;     switch error {<br>&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;     }<br>&gt;&gt; } catch { ... }<br>&gt;&gt; While this is generally a good approach, it can be very dangerous for library consumers if the author exposes the error to the user. This is due to the fact that the switch statement has to be exhaustive and is only satisfied when all enum cases have been accounted for. What this means for library authors is that every time they add a new case to a public enum, they are breaking the exhaustivity of the switch and making their library backwards-incompatible.<br>&gt;&gt; <br>&gt;&gt; Currently, the best workaround is to use a struct with static instances and overloading the ~= operator. This allows for similar switch behavior but overall is much less flexible, missing key features such as associated values.<br>&gt;&gt; <br>&gt;&gt; Another example is when the library is split into multiple modules, where the error is defined in the first module and the second module wants to add some error cases. An enum is very rarely used in this case because you cannot add cases in other modules. Instead, library authors either use an error protocol, and add more types that conform to it, or use the struct approach shown above. While this is not terrible, adding cases in extensions would better translate the intention of the author and adds more flexiblity.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution proposed is quite simple: add an extensible keyword/modifier that can be applied to enums, which would require the default case when switched on and allow new cases to be added in extensions.<br>&gt;&gt; <br>&gt;&gt; Here is the translation of the very first example to the use an extensible enum instead, with a new case added:<br>&gt;&gt; <br>&gt;&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;     case failedReadingFile<br>&gt;&gt; }<br>&gt;&gt; func readFile() throws { ... }<br>&gt;&gt; <br>&gt;&gt; // elsewhere in the codebase<br>&gt;&gt; do {<br>&gt;&gt;     try readFile()<br>&gt;&gt; } catch let error as ThingError {<br>&gt;&gt;     switch error {<br>&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;&gt;     }<br>&gt;&gt; } catch { ... }<br>&gt;&gt; For the second example, we can simply extend the enum in the higher-level module.<br>&gt;&gt; <br>&gt;&gt; // Module FileProtocol<br>&gt;&gt; <br>&gt;&gt; extensible enum FileError: ErrorProtocol {<br>&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol FileProtocol {<br>&gt;&gt;     func read() throws<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Module File<br>&gt;&gt; <br>&gt;&gt; extension FileError {<br>&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;     case failedReadingFile<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct File: FileProtocol {<br>&gt;&gt;     func read() throws { ... }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; A new keyword would be added to the language which is only allowed in front of the enum keyword. When an enum is marked extensible, new cases can be added in extensions and switches that are performed on it require a defaultcase.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; There is no impact on existing code since this is purely an additive feature.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; No alternatives have been considered (yet).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; By itself, this would break switch statements, since they have to be exhaustive.<br>&gt;&gt; <br>&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt; &gt;   case east, west<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My app for example also makes use of north and south, so I would love to be able to write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt; &gt;   case north,south<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In objective c, one would probably have defined constants like MyDirectionEast etc...  these would probably have been mapped to ints or strings so a consumer of this library could have easily extended this to add additional functionality, but using constants like that is not very &quot;swifty&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; Dan Appel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/dd6bce5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>June 30, 2016 at 08:00:00pm</p></header><div class="content"><p>Paul,<br></p><p>That is the current workaround (as the proposal mentions), but it is still<br>missing support for enum features such as associated values and the pattern<br>matching power that they bring.<br></p><p>Also, by locking your OpenEnum conformers to reference types, you lose out<br>on the value-semantics (very important, even for enums), and bring in the<br>extra weight that a class is.<br></p><p>Dan<br></p><p>On Thu, Jun 30, 2016 at 1:42 PM Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p>&gt; While it doesn‚Äôt give all the ‚Äúraw value‚Äù functionality of enum, it‚Äôs<br>&gt; possible to use object instance uniqueness to get enum-like behavior that<br>&gt; can be extended:<br>&gt;<br>&gt;     public protocol OpenEnum: class, Hashable { }<br>&gt;<br>&gt;     extension OpenEnum {<br>&gt;       public var hashValue: Int {<br>&gt;         return ObjectIdentifier(self).hashValue<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt;     public func ==&lt;T: OpenEnum&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;       return lhs === rhs<br>&gt;     }<br>&gt;<br>&gt; A library can provide:<br>&gt;<br>&gt;     public final class Color: OpenEnum, CustomStringConvertible {<br>&gt;       public let description: String<br>&gt;<br>&gt;       public init(description: String) {<br>&gt;         self.description = description<br>&gt;       }<br>&gt;<br>&gt;       static let<br>&gt;         black = Color(description: &quot;black&quot;),<br>&gt;         white = Color(description: &quot;white&quot;)<br>&gt;     }<br>&gt;<br>&gt; And then in a client project:<br>&gt;<br>&gt;     extension Color {<br>&gt;       static let<br>&gt;         puce = Color(description: &quot;puce&quot;),<br>&gt;         mauve = Color(description: &quot;mauve&quot;),<br>&gt;         fuchsia = Color(description: &quot;fuchsia&quot;)<br>&gt;     }<br>&gt;<br>&gt; (This is how Siesta provides an extensible set of pipeline stages.<br>&gt; https://github.com/bustoutsolutions/siesta/pull/64)<br>&gt;<br>&gt; With this approach, you still get the .member shortcut in some<br>&gt; circumstances:<br>&gt;<br>&gt;     let eyebleedPalette: [Color] = [.fuchsia, .black, .mauve]<br>&gt;<br>&gt; ‚Ä¶but not in others:<br>&gt;<br>&gt;     // Compiles<br>&gt;     switch(color) {<br>&gt;       case *Color*.red: print(&quot;Danger!&quot;)<br>&gt;       case *Color*.mauve: print(&quot;Dancing!&quot;)<br>&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;     }<br>&gt;<br>&gt;     // Does not compile<br>&gt;     switch(color) {<br>&gt;       case .red: print(&quot;Danger!&quot;)<br>&gt;       case .mauve: print(&quot;Dancing!&quot;)<br>&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;     }<br>&gt;<br>&gt; Given that this already comes close to giving the sort of functionality<br>&gt; one would want out of an extensible enum, perhaps it‚Äôs better to fill out<br>&gt; the gaps in this approach instead of adding a new language feature? This<br>&gt; would have the advantage of not adding a keyword, and presumably provide<br>&gt; useful behaviors that generalize to patterns other than extensible enums.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; On Jun 30, 2016, at 3:23 PM, Guillermo Peralta Scura via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think the approach taken by your proporsal is really good. Would love to<br>&gt; have that feature for the language.<br>&gt;<br>&gt; El jue., 30 jun. 2016 a las 16:19, Edward Valentini via swift-evolution (&lt;<br>&gt; swift-evolution at swift.org&gt;) escribi√≥:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I really like the idea of making it opt in with the extensible keyword as<br>&gt;&gt; opposed to opt out with final so this way there is no impact on existing<br>&gt;&gt; code<br>&gt;&gt;<br>&gt;&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses<br>&gt;&gt; exactly this, but I haven&#39;t gotten around to sending it out for comments<br>&gt;&gt; yet. Link<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br>&gt;&gt;<br>&gt;&gt; Would appreciate if you guys took a look.<br>&gt;&gt; Dan Appel<br>&gt;&gt;<br>&gt;&gt; Pasted inline below<br>&gt;&gt;<br>&gt;&gt; Extensible Enums<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;    - Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal introduces a new keyword that can be applied to enums which<br>&gt;&gt; allows new cases to be introduced in extensions.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: [RFC] Extensible Enums<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Enums are a powerful feature which provides a lot of benefit if you have<br>&gt;&gt; a limited number of behaviors. For example, associated values provide the<br>&gt;&gt; ability to make every case essentially a separate type. However, due to the<br>&gt;&gt; static nature of enums, they cannot be used in situations where they would<br>&gt;&gt; otherwise be a perfect fit.<br>&gt;&gt;<br>&gt;&gt; An example of this would be the use of an Error enum like so:<br>&gt;&gt;<br>&gt;&gt; enum FileError: ErrorProtocol {<br>&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt; }func readFile() throws { ... }<br>&gt;&gt; // elsewhere in the codebasedo {<br>&gt;&gt;     try readFile()<br>&gt;&gt; } catch let error as FileError {<br>&gt;&gt;     switch error {<br>&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;     }<br>&gt;&gt; } catch { ... }<br>&gt;&gt;<br>&gt;&gt; While this is generally a good approach, it can be very dangerous for<br>&gt;&gt; library consumers if the author exposes the error to the user. This is due<br>&gt;&gt; to the fact that the switch statement has to be exhaustive and is only<br>&gt;&gt; satisfied when all enum cases have been accounted for. What this means for<br>&gt;&gt; library authors is that every time they add a new case to a public enum,<br>&gt;&gt; they are breaking the exhaustivity of the switch and making their<br>&gt;&gt; library backwards-incompatible.<br>&gt;&gt;<br>&gt;&gt; Currently, the best workaround is to use a struct with static instances<br>&gt;&gt; and overloading the ~= operator. This allows for similar switch behavior<br>&gt;&gt; but overall is much less flexible, missing key features such as associated<br>&gt;&gt; values.<br>&gt;&gt;<br>&gt;&gt; Another example is when the library is split into multiple modules, where<br>&gt;&gt; the error is defined in the first module and the second module wants to add<br>&gt;&gt; some error cases. An enum is very rarely used in this case because you<br>&gt;&gt; cannot add cases in other modules. Instead, library authors either use an<br>&gt;&gt; error protocol, and add more types that conform to it, or use the struct<br>&gt;&gt; approach shown above. While this is not terrible, adding cases in<br>&gt;&gt; extensions would better translate the intention of the author and adds more<br>&gt;&gt; flexiblity.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The solution proposed is quite simple: add an extensible keyword/modifier<br>&gt;&gt; that can be applied to enums, which would require the default case when<br>&gt;&gt; switched on and allow new cases to be added in extensions.<br>&gt;&gt;<br>&gt;&gt; Here is the translation of the very first example to the use an<br>&gt;&gt; extensible enum instead, with a new case added:<br>&gt;&gt;<br>&gt;&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;     case failedReadingFile<br>&gt;&gt; }func readFile() throws { ... }<br>&gt;&gt; // elsewhere in the codebasedo {<br>&gt;&gt;     try readFile()<br>&gt;&gt; } catch let error as ThingError {<br>&gt;&gt;     switch error {<br>&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;&gt;     }<br>&gt;&gt; } catch { ... }<br>&gt;&gt;<br>&gt;&gt; For the second example, we can simply extend the enum in the higher-level<br>&gt;&gt; module.<br>&gt;&gt;<br>&gt;&gt; // Module FileProtocol<br>&gt;&gt;<br>&gt;&gt; extensible enum FileError: ErrorProtocol {<br>&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt; }<br>&gt;&gt; protocol FileProtocol {<br>&gt;&gt;     func read() throws<br>&gt;&gt; }<br>&gt;&gt; // Module File<br>&gt;&gt; extension FileError {<br>&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;     case failedReadingFile<br>&gt;&gt; }<br>&gt;&gt; struct File: FileProtocol {<br>&gt;&gt;     func read() throws { ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; A new keyword would be added to the language which is only allowed in<br>&gt;&gt; front of the enum keyword. When an enum is marked extensible, new cases<br>&gt;&gt; can be added in extensions and switches that are performed on it require a<br>&gt;&gt; defaultcase.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; There is no impact on existing code since this is purely an additive<br>&gt;&gt; feature.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; No alternatives have been considered (yet).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; By itself, this would break switch statements, since they have to be<br>&gt;&gt;&gt; exhaustive.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt;&gt;&gt; solution would be to allow enum extensions to add to existing case<br>&gt;&gt;&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt;&gt;&gt; enum defined:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt;&gt; &gt;   case east, west<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; My app for example also makes use of north and south, so I would love<br>&gt;&gt;&gt; to be able to write:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt;&gt; &gt;   case north,south<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In objective c, one would probably have defined constants like<br>&gt;&gt;&gt; MyDirectionEast etc...  these would probably have been mapped to ints or<br>&gt;&gt;&gt; strings so a consumer of this library could have easily extended this to<br>&gt;&gt;&gt; add additional functionality, but using constants like that is not very<br>&gt;&gt;&gt; &quot;swifty&quot;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thank you<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dan Appel<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/4a0d942b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 2:54 PM, Dan Appel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Paul,<br>&gt; <br>&gt; That is the current workaround (as the proposal mentions), but it is still missing support for enum features such as associated values and the pattern matching power that they bring.<br></p><p>I don‚Äôt believe a developer would be able to extend an enum to support arbitrary associated values, the same as the limitation that one cannot extend a type today to have extra members. Value types need to have an understood size and structure at compile time of the file/module that they are in.<br></p><p>&gt; <br>&gt; Dan<br>&gt; <br>&gt; On Thu, Jun 30, 2016 at 1:42 PM Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt; While it doesn‚Äôt give all the ‚Äúraw value‚Äù functionality of enum, it‚Äôs possible to use object instance uniqueness to get enum-like behavior that can be extended:<br>&gt; <br>&gt;     public protocol OpenEnum: class, Hashable { }<br>&gt; <br>&gt;     extension OpenEnum {<br>&gt;       public var hashValue: Int {<br>&gt;         return ObjectIdentifier(self).hashValue<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt;     public func ==&lt;T: OpenEnum&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;       return lhs === rhs<br>&gt;     }<br>&gt; <br>&gt; A library can provide:<br>&gt; <br>&gt;     public final class Color: OpenEnum, CustomStringConvertible {<br>&gt;       public let description: String<br>&gt; <br>&gt;       public init(description: String) {<br>&gt;         self.description = description<br>&gt;       }<br>&gt; <br>&gt;       static let<br>&gt;         black = Color(description: &quot;black&quot;),<br>&gt;         white = Color(description: &quot;white&quot;)<br>&gt;     }<br>&gt; <br>&gt; And then in a client project:<br>&gt; <br>&gt;     extension Color {<br>&gt;       static let<br>&gt;         puce = Color(description: &quot;puce&quot;),<br>&gt;         mauve = Color(description: &quot;mauve&quot;),<br>&gt;         fuchsia = Color(description: &quot;fuchsia&quot;)<br>&gt;     }<br>&gt; <br>&gt; (This is how Siesta provides an extensible set of pipeline stages. https://github.com/bustoutsolutions/siesta/pull/64 &lt;https://github.com/bustoutsolutions/siesta/pull/64&gt;)<br>&gt; <br>&gt; With this approach, you still get the .member shortcut in some circumstances:<br>&gt; <br>&gt;     let eyebleedPalette: [Color] = [.fuchsia, .black, .mauve]<br>&gt; <br>&gt; ‚Ä¶but not in others:<br>&gt; <br>&gt;     // Compiles<br>&gt;     switch(color) {<br>&gt;       case Color.red: print(&quot;Danger!&quot;)<br>&gt;       case Color.mauve: print(&quot;Dancing!&quot;)<br>&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;     }<br>&gt; <br>&gt;     // Does not compile<br>&gt;     switch(color) {<br>&gt;       case .red: print(&quot;Danger!&quot;)<br>&gt;       case .mauve: print(&quot;Dancing!&quot;)<br>&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;     }<br>&gt; <br>&gt; Given that this already comes close to giving the sort of functionality one would want out of an extensible enum, perhaps it‚Äôs better to fill out the gaps in this approach instead of adding a new language feature? This would have the advantage of not adding a keyword, and presumably provide useful behaviors that generalize to patterns other than extensible enums.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 3:23 PM, Guillermo Peralta Scura via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think the approach taken by your proporsal is really good. Would love to have that feature for the language.<br>&gt;&gt; <br>&gt;&gt; El jue., 30 jun. 2016 a las 16:19, Edward Valentini via swift-evolution (&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) escribi√≥:<br>&gt;&gt; <br>&gt;&gt; I really like the idea of making it opt in with the extensible keyword as opposed to opt out with final so this way there is no impact on existing code<br>&gt;&gt; <br>&gt;&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com &lt;mailto:dan.appel00 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses exactly this, but I haven&#39;t gotten around to sending it out for comments yet. Link &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would appreciate if you guys took a look.<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pasted inline below<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensible Enums<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt; Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>&gt;&gt;&gt; Status: Awaiting review &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces a new keyword that can be applied to enums which allows new cases to be introduced in extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [RFC] Extensible Enums &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enums are a powerful feature which provides a lot of benefit if you have a limited number of behaviors. For example, associated values provide the ability to make every case essentially a separate type. However, due to the static nature of enums, they cannot be used in situations where they would otherwise be a perfect fit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An example of this would be the use of an Error enum like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum FileError: ErrorProtocol {<br>&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; func readFile() throws { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // elsewhere in the codebase<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     try readFile()<br>&gt;&gt;&gt; } catch let error as FileError {<br>&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; } catch { ... }<br>&gt;&gt;&gt; While this is generally a good approach, it can be very dangerous for library consumers if the author exposes the error to the user. This is due to the fact that the switch statement has to be exhaustive and is only satisfied when all enum cases have been accounted for. What this means for library authors is that every time they add a new case to a public enum, they are breaking the exhaustivity of the switch and making their library backwards-incompatible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, the best workaround is to use a struct with static instances and overloading the ~= operator. This allows for similar switch behavior but overall is much less flexible, missing key features such as associated values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another example is when the library is split into multiple modules, where the error is defined in the first module and the second module wants to add some error cases. An enum is very rarely used in this case because you cannot add cases in other modules. Instead, library authors either use an error protocol, and add more types that conform to it, or use the struct approach shown above. While this is not terrible, adding cases in extensions would better translate the intention of the author and adds more flexiblity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution proposed is quite simple: add an extensible keyword/modifier that can be applied to enums, which would require the default case when switched on and allow new cases to be added in extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is the translation of the very first example to the use an extensible enum instead, with a new case added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;     case failedReadingFile<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; func readFile() throws { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // elsewhere in the codebase<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     try readFile()<br>&gt;&gt;&gt; } catch let error as ThingError {<br>&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; } catch { ... }<br>&gt;&gt;&gt; For the second example, we can simply extend the enum in the higher-level module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Module FileProtocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extensible enum FileError: ErrorProtocol {<br>&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FileProtocol {<br>&gt;&gt;&gt;     func read() throws<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Module File<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension FileError {<br>&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;     case failedReadingFile<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct File: FileProtocol {<br>&gt;&gt;&gt;     func read() throws { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A new keyword would be added to the language which is only allowed in front of the enum keyword. When an enum is marked extensible, new cases can be added in extensions and switches that are performed on it require a defaultcase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no impact on existing code since this is purely an additive feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No alternatives have been considered (yet).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; By itself, this would break switch statements, since they have to be exhaustive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt;&gt; &gt;   case east, west<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; My app for example also makes use of north and south, so I would love to be able to write:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt;&gt; &gt;   case north,south<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In objective c, one would probably have defined constants like MyDirectionEast etc...  these would probably have been mapped to ints or strings so a consumer of this library could have easily extended this to add additional functionality, but using constants like that is not very &quot;swifty&quot;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thank you<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; --<br>&gt; Dan Appel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/8af101ee/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/8af101ee/attachment-0001.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>David,<br></p><p>Yeah, that&#39;s what I&#39;m worried about. I was meaning to ask some engineers<br>about the implementation of this during WWDC (hence why I didn&#39;t send it<br>out), but didn&#39;t get a chance to do so.<br></p><p>On Thu, Jun 30, 2016 at 2:09 PM David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; On Jun 30, 2016, at 2:54 PM, Dan Appel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Paul,<br>&gt;<br>&gt; That is the current workaround (as the proposal mentions), but it is still<br>&gt; missing support for enum features such as associated values and the pattern<br>&gt; matching power that they bring.<br>&gt;<br>&gt;<br>&gt; I don‚Äôt believe a developer would be able to extend an enum to support<br>&gt; arbitrary associated values, the same as the limitation that one cannot<br>&gt; extend a type today to have extra members. Value types need to have an<br>&gt; understood size and structure at compile time of the file/module that they<br>&gt; are in.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Dan<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 1:42 PM Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;<br>&gt;&gt; While it doesn‚Äôt give all the ‚Äúraw value‚Äù functionality of enum, it‚Äôs<br>&gt;&gt; possible to use object instance uniqueness to get enum-like behavior that<br>&gt;&gt; can be extended:<br>&gt;&gt;<br>&gt;&gt;     public protocol OpenEnum: class, Hashable { }<br>&gt;&gt;<br>&gt;&gt;     extension OpenEnum {<br>&gt;&gt;       public var hashValue: Int {<br>&gt;&gt;         return ObjectIdentifier(self).hashValue<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     public func ==&lt;T: OpenEnum&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;       return lhs === rhs<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; A library can provide:<br>&gt;&gt;<br>&gt;&gt;     public final class Color: OpenEnum, CustomStringConvertible {<br>&gt;&gt;       public let description: String<br>&gt;&gt;<br>&gt;&gt;       public init(description: String) {<br>&gt;&gt;         self.description = description<br>&gt;&gt;       }<br>&gt;&gt;<br>&gt;&gt;       static let<br>&gt;&gt;         black = Color(description: &quot;black&quot;),<br>&gt;&gt;         white = Color(description: &quot;white&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; And then in a client project:<br>&gt;&gt;<br>&gt;&gt;     extension Color {<br>&gt;&gt;       static let<br>&gt;&gt;         puce = Color(description: &quot;puce&quot;),<br>&gt;&gt;         mauve = Color(description: &quot;mauve&quot;),<br>&gt;&gt;         fuchsia = Color(description: &quot;fuchsia&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; (This is how Siesta provides an extensible set of pipeline stages.<br>&gt;&gt; https://github.com/bustoutsolutions/siesta/pull/64)<br>&gt;&gt;<br>&gt;&gt; With this approach, you still get the .member shortcut in some<br>&gt;&gt; circumstances:<br>&gt;&gt;<br>&gt;&gt;     let eyebleedPalette: [Color] = [.fuchsia, .black, .mauve]<br>&gt;&gt;<br>&gt;&gt; ‚Ä¶but not in others:<br>&gt;&gt;<br>&gt;&gt;     // Compiles<br>&gt;&gt;     switch(color) {<br>&gt;&gt;       case *Color*.red: print(&quot;Danger!&quot;)<br>&gt;&gt;       case *Color*.mauve: print(&quot;Dancing!&quot;)<br>&gt;&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     // Does not compile<br>&gt;&gt;     switch(color) {<br>&gt;&gt;       case .red: print(&quot;Danger!&quot;)<br>&gt;&gt;       case .mauve: print(&quot;Dancing!&quot;)<br>&gt;&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Given that this already comes close to giving the sort of functionality<br>&gt;&gt; one would want out of an extensible enum, perhaps it‚Äôs better to fill out<br>&gt;&gt; the gaps in this approach instead of adding a new language feature? This<br>&gt;&gt; would have the advantage of not adding a keyword, and presumably provide<br>&gt;&gt; useful behaviors that generalize to patterns other than extensible enums.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; Paul<br>&gt;&gt;<br>&gt;&gt; On Jun 30, 2016, at 3:23 PM, Guillermo Peralta Scura via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think the approach taken by your proporsal is really good. Would love<br>&gt;&gt; to have that feature for the language.<br>&gt;&gt;<br>&gt;&gt; El jue., 30 jun. 2016 a las 16:19, Edward Valentini via swift-evolution (&lt;<br>&gt;&gt; swift-evolution at swift.org&gt;) escribi√≥:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I really like the idea of making it opt in with the extensible keyword<br>&gt;&gt;&gt; as opposed to opt out with final so this way there is no impact on existing<br>&gt;&gt;&gt; code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses<br>&gt;&gt;&gt; exactly this, but I haven&#39;t gotten around to sending it out for comments<br>&gt;&gt;&gt; yet. Link<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would appreciate if you guys took a look.<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Pasted inline below<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Extensible Enums<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;    - Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;    &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal introduces a new keyword that can be applied to enums<br>&gt;&gt;&gt; which allows new cases to be introduced in extensions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: [RFC] Extensible Enums<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Enums are a powerful feature which provides a lot of benefit if you have<br>&gt;&gt;&gt; a limited number of behaviors. For example, associated values provide the<br>&gt;&gt;&gt; ability to make every case essentially a separate type. However, due to the<br>&gt;&gt;&gt; static nature of enums, they cannot be used in situations where they would<br>&gt;&gt;&gt; otherwise be a perfect fit.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An example of this would be the use of an Error enum like so:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum FileError: ErrorProtocol {<br>&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt; }func readFile() throws { ... }<br>&gt;&gt;&gt; // elsewhere in the codebasedo {<br>&gt;&gt;&gt;     try readFile()<br>&gt;&gt;&gt; } catch let error as FileError {<br>&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; } catch { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While this is generally a good approach, it can be very dangerous for<br>&gt;&gt;&gt; library consumers if the author exposes the error to the user. This is due<br>&gt;&gt;&gt; to the fact that the switch statement has to be exhaustive and is only<br>&gt;&gt;&gt; satisfied when all enum cases have been accounted for. What this means for<br>&gt;&gt;&gt; library authors is that every time they add a new case to a public enum,<br>&gt;&gt;&gt; they are breaking the exhaustivity of the switch and making their<br>&gt;&gt;&gt; library backwards-incompatible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, the best workaround is to use a struct with static instances<br>&gt;&gt;&gt; and overloading the ~= operator. This allows for similar switch behavior<br>&gt;&gt;&gt; but overall is much less flexible, missing key features such as associated<br>&gt;&gt;&gt; values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another example is when the library is split into multiple modules,<br>&gt;&gt;&gt; where the error is defined in the first module and the second module wants<br>&gt;&gt;&gt; to add some error cases. An enum is very rarely used in this case because<br>&gt;&gt;&gt; you cannot add cases in other modules. Instead, library authors either use<br>&gt;&gt;&gt; an error protocol, and add more types that conform to it, or use the struct<br>&gt;&gt;&gt; approach shown above. While this is not terrible, adding cases in<br>&gt;&gt;&gt; extensions would better translate the intention of the author and adds more<br>&gt;&gt;&gt; flexiblity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The solution proposed is quite simple: add an extensible keyword/modifier<br>&gt;&gt;&gt; that can be applied to enums, which would require the default case when<br>&gt;&gt;&gt; switched on and allow new cases to be added in extensions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is the translation of the very first example to the use an<br>&gt;&gt;&gt; extensible enum instead, with a new case added:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;     case failedReadingFile<br>&gt;&gt;&gt; }func readFile() throws { ... }<br>&gt;&gt;&gt; // elsewhere in the codebasedo {<br>&gt;&gt;&gt;     try readFile()<br>&gt;&gt;&gt; } catch let error as ThingError {<br>&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; } catch { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For the second example, we can simply extend the enum in the<br>&gt;&gt;&gt; higher-level module.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Module FileProtocol<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extensible enum FileError: ErrorProtocol {<br>&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; protocol FileProtocol {<br>&gt;&gt;&gt;     func read() throws<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // Module File<br>&gt;&gt;&gt; extension FileError {<br>&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;     case failedReadingFile<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; struct File: FileProtocol {<br>&gt;&gt;&gt;     func read() throws { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A new keyword would be added to the language which is only allowed in<br>&gt;&gt;&gt; front of the enum keyword. When an enum is marked extensible, new cases<br>&gt;&gt;&gt; can be added in extensions and switches that are performed on it require a<br>&gt;&gt;&gt; defaultcase.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is no impact on existing code since this is purely an additive<br>&gt;&gt;&gt; feature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No alternatives have been considered (yet).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; By itself, this would break switch statements, since they have to be<br>&gt;&gt;&gt;&gt; exhaustive.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt;&gt;&gt;&gt; solution would be to allow enum extensions to add to existing case<br>&gt;&gt;&gt;&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt;&gt;&gt;&gt; enum defined:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt;&gt;&gt; &gt;   case east, west<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; My app for example also makes use of north and south, so I would love<br>&gt;&gt;&gt;&gt; to be able to write:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt;&gt;&gt; &gt;   case north,south<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; In objective c, one would probably have defined constants like<br>&gt;&gt;&gt;&gt; MyDirectionEast etc...  these would probably have been mapped to ints or<br>&gt;&gt;&gt;&gt; strings so a consumer of this library could have easily extended this to<br>&gt;&gt;&gt;&gt; add additional functionality, but using constants like that is not very<br>&gt;&gt;&gt;&gt; &quot;swifty&quot;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Thank you<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt; Dan Appel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/4e8c4adc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>Paul,<br></p><p>&gt;Fair enough, it would be hard to generalize pattern matching to this<br>approach. Associated types are a whole other kettle of fish.<br></p><p>Right, but associated types are the main reason you would use this over<br>structs with static members.<br></p><p>&gt;The class approach is the more lightweight option when you aren‚Äôt trying<br>to get associated-value-like behavior.<br></p><p>You&#39;re right, that is true if the errors are static instances.<br></p><p>&gt;If you‚Äôre looking to have associated type-like behavior _and_ open cases,<br>then yes, this ‚Äúunique instances‚Äù approach breaks down. At that point,<br>though, why not just use a collection of separate struct types implementing<br>a shared protocol?<br></p><p>Yes, as I mentioned in the draft, this is as close as you get to associated<br>values on enum cases. However, I think that enums better represent user<br>intent + have better language support. You can definitely emulate the<br>extensible feature using other language constructs, but after all you can<br>also emulate generics using Any (how java does it). In this case I think<br>its helpful to have first-class language support.<br></p><p>Dan<br></p><p><br>On Thu, Jun 30, 2016 at 2:27 PM Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br></p><p>&gt; David,<br>&gt;<br>&gt; Yeah, that&#39;s what I&#39;m worried about. I was meaning to ask some engineers<br>&gt; about the implementation of this during WWDC (hence why I didn&#39;t send it<br>&gt; out), but didn&#39;t get a chance to do so.<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 2:09 PM David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 30, 2016, at 2:54 PM, Dan Appel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Paul,<br>&gt;&gt;<br>&gt;&gt; That is the current workaround (as the proposal mentions), but it is<br>&gt;&gt; still missing support for enum features such as associated values and the<br>&gt;&gt; pattern matching power that they bring.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don‚Äôt believe a developer would be able to extend an enum to support<br>&gt;&gt; arbitrary associated values, the same as the limitation that one cannot<br>&gt;&gt; extend a type today to have extra members. Value types need to have an<br>&gt;&gt; understood size and structure at compile time of the file/module that they<br>&gt;&gt; are in.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Dan<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 30, 2016 at 1:42 PM Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; While it doesn‚Äôt give all the ‚Äúraw value‚Äù functionality of enum, it‚Äôs<br>&gt;&gt;&gt; possible to use object instance uniqueness to get enum-like behavior that<br>&gt;&gt;&gt; can be extended:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     public protocol OpenEnum: class, Hashable { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     extension OpenEnum {<br>&gt;&gt;&gt;       public var hashValue: Int {<br>&gt;&gt;&gt;         return ObjectIdentifier(self).hashValue<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     public func ==&lt;T: OpenEnum&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;       return lhs === rhs<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A library can provide:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     public final class Color: OpenEnum, CustomStringConvertible {<br>&gt;&gt;&gt;       public let description: String<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       public init(description: String) {<br>&gt;&gt;&gt;         self.description = description<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       static let<br>&gt;&gt;&gt;         black = Color(description: &quot;black&quot;),<br>&gt;&gt;&gt;         white = Color(description: &quot;white&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And then in a client project:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     extension Color {<br>&gt;&gt;&gt;       static let<br>&gt;&gt;&gt;         puce = Color(description: &quot;puce&quot;),<br>&gt;&gt;&gt;         mauve = Color(description: &quot;mauve&quot;),<br>&gt;&gt;&gt;         fuchsia = Color(description: &quot;fuchsia&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (This is how Siesta provides an extensible set of pipeline stages.<br>&gt;&gt;&gt; https://github.com/bustoutsolutions/siesta/pull/64)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With this approach, you still get the .member shortcut in some<br>&gt;&gt;&gt; circumstances:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let eyebleedPalette: [Color] = [.fuchsia, .black, .mauve]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ‚Ä¶but not in others:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Compiles<br>&gt;&gt;&gt;     switch(color) {<br>&gt;&gt;&gt;       case *Color*.red: print(&quot;Danger!&quot;)<br>&gt;&gt;&gt;       case *Color*.mauve: print(&quot;Dancing!&quot;)<br>&gt;&gt;&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Does not compile<br>&gt;&gt;&gt;     switch(color) {<br>&gt;&gt;&gt;       case .red: print(&quot;Danger!&quot;)<br>&gt;&gt;&gt;       case .mauve: print(&quot;Dancing!&quot;)<br>&gt;&gt;&gt;       default: print(&quot;Nothing notable&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Given that this already comes close to giving the sort of functionality<br>&gt;&gt;&gt; one would want out of an extensible enum, perhaps it‚Äôs better to fill out<br>&gt;&gt;&gt; the gaps in this approach instead of adding a new language feature? This<br>&gt;&gt;&gt; would have the advantage of not adding a keyword, and presumably provide<br>&gt;&gt;&gt; useful behaviors that generalize to patterns other than extensible enums.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 30, 2016, at 3:23 PM, Guillermo Peralta Scura via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the approach taken by your proporsal is really good. Would love<br>&gt;&gt;&gt; to have that feature for the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; El jue., 30 jun. 2016 a las 16:19, Edward Valentini via swift-evolution<br>&gt;&gt;&gt; (&lt;swift-evolution at swift.org&gt;) escribi√≥:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I really like the idea of making it opt in with the extensible keyword<br>&gt;&gt;&gt;&gt; as opposed to opt out with final so this way there is no impact on existing<br>&gt;&gt;&gt;&gt; code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 30, 2016, at 16:15, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ve had a draft of a proposal lying around for a while which addresses<br>&gt;&gt;&gt;&gt; exactly this, but I haven&#39;t gotten around to sending it out for comments<br>&gt;&gt;&gt;&gt; yet. Link<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5&gt;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Would appreciate if you guys took a look.<br>&gt;&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Pasted inline below<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Extensible Enums<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;&gt;    - Author: Dan Appel &lt;https://github.com/danappelxx&gt;<br>&gt;&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;&gt;    &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#rationale&gt;<br>&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#introduction&gt;<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal introduces a new keyword that can be applied to enums<br>&gt;&gt;&gt;&gt; which allows new cases to be introduced in extensions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift-evolution thread: [RFC] Extensible Enums<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#motivation&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Enums are a powerful feature which provides a lot of benefit if you<br>&gt;&gt;&gt;&gt; have a limited number of behaviors. For example, associated values provide<br>&gt;&gt;&gt;&gt; the ability to make every case essentially a separate type. However, due to<br>&gt;&gt;&gt;&gt; the static nature of enums, they cannot be used in situations where they<br>&gt;&gt;&gt;&gt; would otherwise be a perfect fit.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; An example of this would be the use of an Error enum like so:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; enum FileError: ErrorProtocol {<br>&gt;&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;&gt; }func readFile() throws { ... }<br>&gt;&gt;&gt;&gt; // elsewhere in the codebasedo {<br>&gt;&gt;&gt;&gt;     try readFile()<br>&gt;&gt;&gt;&gt; } catch let error as FileError {<br>&gt;&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; } catch { ... }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; While this is generally a good approach, it can be very dangerous for<br>&gt;&gt;&gt;&gt; library consumers if the author exposes the error to the user. This is due<br>&gt;&gt;&gt;&gt; to the fact that the switch statement has to be exhaustive and is only<br>&gt;&gt;&gt;&gt; satisfied when all enum cases have been accounted for. What this means for<br>&gt;&gt;&gt;&gt; library authors is that every time they add a new case to a public enum,<br>&gt;&gt;&gt;&gt; they are breaking the exhaustivity of the switch and making their<br>&gt;&gt;&gt;&gt; library backwards-incompatible.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently, the best workaround is to use a struct with static<br>&gt;&gt;&gt;&gt; instances and overloading the ~= operator. This allows for similar<br>&gt;&gt;&gt;&gt; switch behavior but overall is much less flexible, missing key<br>&gt;&gt;&gt;&gt; features such as associated values.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another example is when the library is split into multiple modules,<br>&gt;&gt;&gt;&gt; where the error is defined in the first module and the second module wants<br>&gt;&gt;&gt;&gt; to add some error cases. An enum is very rarely used in this case because<br>&gt;&gt;&gt;&gt; you cannot add cases in other modules. Instead, library authors either use<br>&gt;&gt;&gt;&gt; an error protocol, and add more types that conform to it, or use the struct<br>&gt;&gt;&gt;&gt; approach shown above. While this is not terrible, adding cases in<br>&gt;&gt;&gt;&gt; extensions would better translate the intention of the author and adds more<br>&gt;&gt;&gt;&gt; flexiblity.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The solution proposed is quite simple: add an extensible keyword/modifier<br>&gt;&gt;&gt;&gt; that can be applied to enums, which would require the default case<br>&gt;&gt;&gt;&gt; when switched on and allow new cases to be added in extensions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here is the translation of the very first example to the use an<br>&gt;&gt;&gt;&gt; extensible enum instead, with a new case added:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extensible enum ThingError: ErrorProtocol {<br>&gt;&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;&gt;     case failedReadingFile<br>&gt;&gt;&gt;&gt; }func readFile() throws { ... }<br>&gt;&gt;&gt;&gt; // elsewhere in the codebasedo {<br>&gt;&gt;&gt;&gt;     try readFile()<br>&gt;&gt;&gt;&gt; } catch let error as ThingError {<br>&gt;&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;&gt;         case .fileNotFound(let path): // handle error<br>&gt;&gt;&gt;&gt;         case .corruptedFile(let bytes): // handle error<br>&gt;&gt;&gt;&gt;         default: // handle future errors that don&#39;t exist yet<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; } catch { ... }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For the second example, we can simply extend the enum in the<br>&gt;&gt;&gt;&gt; higher-level module.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Module FileProtocol<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extensible enum FileError: ErrorProtocol {<br>&gt;&gt;&gt;&gt;     case fileNotFound(path: String)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; protocol FileProtocol {<br>&gt;&gt;&gt;&gt;     func read() throws<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // Module File<br>&gt;&gt;&gt;&gt; extension FileError {<br>&gt;&gt;&gt;&gt;     case corruptedFile(bytes: [Int8])<br>&gt;&gt;&gt;&gt;     case failedReadingFile<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; struct File: FileProtocol {<br>&gt;&gt;&gt;&gt;     func read() throws { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A new keyword would be added to the language which is only allowed in<br>&gt;&gt;&gt;&gt; front of the enum keyword. When an enum is marked extensible, new<br>&gt;&gt;&gt;&gt; cases can be added in extensions and switches that are performed on it<br>&gt;&gt;&gt;&gt; require a defaultcase.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There is no impact on existing code since this is purely an additive<br>&gt;&gt;&gt;&gt; feature.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/Danappelxx/41b7c2e86787f75698bd48135cc616f5#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt;&gt; considered<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; No alternatives have been considered (yet).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 1:04 PM David Sweeris via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; By itself, this would break switch statements, since they have to be<br>&gt;&gt;&gt;&gt;&gt; exhaustive.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If anyone has any ideas about how to fix that, I&#39;m all ears.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 30, 2016, at 14:58, Edward Valentini via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt;&gt;&gt;&gt;&gt; solution would be to allow enum extensions to add to existing case<br>&gt;&gt;&gt;&gt;&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt;&gt;&gt;&gt;&gt; enum defined:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; enum MyDirection {<br>&gt;&gt;&gt;&gt;&gt; &gt;   case east, west<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; My app for example also makes use of north and south, so I would<br>&gt;&gt;&gt;&gt;&gt; love to be able to write:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension MyDirection {<br>&gt;&gt;&gt;&gt;&gt; &gt;   case north,south<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In objective c, one would probably have defined constants like<br>&gt;&gt;&gt;&gt;&gt; MyDirectionEast etc...  these would probably have been mapped to ints or<br>&gt;&gt;&gt;&gt;&gt; strings so a consumer of this library could have easily extended this to<br>&gt;&gt;&gt;&gt;&gt; add additional functionality, but using constants like that is not very<br>&gt;&gt;&gt;&gt;&gt; &quot;swifty&quot;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m curious what the swift community thinks.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thank you<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt; Dan Appel<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt; Dan Appel<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/3149effd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e69290a3790e6238aa81297d183274a5?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Marc Palmer</string> &lt;marc at anyware.co.uk&gt;<p>July  1, 2016 at 12:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I too groan when faced with the lack of extensibility on enums. As a potential framework writer, I&#39;d like to be able to use an enum as a key to dictionaries, supplying a minimum set of such enum cases, but allowing app developers to add new ones they require. <br></p><p>Having read the proposal however, I have a major concern and question the entire idea. <br></p><p>Given that there is unlikely to be a sane way to order the extended enum cases supplied by other modules, we will never be able to rely on the automatic ordinal values applied, nor their relative position in the natural sequence, for there isn&#39;t one outside of the first set of cases in the original definition. <br></p><p>For many cases this may be fine, on the understanding that everything would have to compile from source, but my understanding is that we don&#39;t want that in future with ABI around the corner. Binary libraries would probably need to bake in the value of e.g. Int enum cases. (I think?)<br></p><p>I fear that if this proposal were implemented without some major restrictions (such as never allowing use of rawValue), we would regret it and suffer for example having to explicitly set enum case Int raw values for every case in these enums in every module always, and suffer compilation errors when other (maybe binary) modules change their explicit raw values and clash with other modules. It could be a dependency nightmare.<br></p><p>Essentially consigning extensible enums to never being useful for serialising their raw values seems of limited use to me, as often you may not know you need them to have unmoving raw values until it is too late and your code is in the wild. <br></p><p>Perhaps I am missing some secret sauce?<br></p><p>--<br>Marc Palmer<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/a675746c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>How many of these use cases would be safely addressed if two Enum types<br>could be unioned to form a new type?<br></p><p>It could use syntax similar to what is being proposed for existentials:<br>(A|B), or something like this:<br></p><p>enum C: A, B {}<br></p><p>Swift could generate code like this:<br></p><p>enum A {<br>  case A1, A2<br>}<br>enum B {<br>  case B1, B2<br>}<br>enum C {<br>  case A(Module.A)<br>  case B(Module.B)<br></p><p>  init(_ a: Module.A) { self = .A(a) }<br>  init(_ b: Module.B) { self = .B(b)  }<br></p><p>  static let A1 = C(A.A1)<br>  static let A2 = C(A.A2)<br>  static let B1 = C(B.B1)<br>  static let B2 = C(B.B2)<br>}<br>extension A {<br>  init?(_ c: C) {<br>    guard let case .A(a) = c else { return nil }<br>    self = a<br>  }<br>}<br>extension B {<br>  init?(_ c: C) {<br>    guard let case .B(b) = c else { return nil }<br>    self = b<br>  }<br>}<br></p><p><br>If I remember correctly there was already some proposals like this, they<br>are probably more thought out than this suggestion.  I know I&#39;d find that<br>useful, I don&#39;t think I&#39;d want the exhaustibility implications of extending<br>an enum in another module.<br></p><p><br>On Friday, 1 July 2016, Marc Palmer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I too groan when faced with the lack of extensibility on enums. As a<br>&gt; potential framework writer, I&#39;d like to be able to use an enum as a key to<br>&gt; dictionaries, supplying a minimum set of such enum cases, but allowing app<br>&gt; developers to add new ones they require.<br>&gt;<br>&gt; Having read the proposal however, I have a major concern and question the<br>&gt; entire idea.<br>&gt;<br>&gt; Given that there is unlikely to be a sane way to order the extended enum<br>&gt; cases supplied by other modules, we will never be able to rely on the<br>&gt; automatic ordinal values applied, nor their relative position in the<br>&gt; natural sequence, for there isn&#39;t one outside of the first set of cases in<br>&gt; the original definition.<br>&gt;<br>&gt; For many cases this may be fine, on the understanding that everything<br>&gt; would have to compile from source, but my understanding is that we don&#39;t<br>&gt; want that in future with ABI around the corner. Binary libraries would<br>&gt; probably need to bake in the value of e.g. Int enum cases. (I think?)<br>&gt;<br>&gt; I fear that if this proposal were implemented without some major<br>&gt; restrictions (such as never allowing use of rawValue), we would regret it<br>&gt; and suffer for example having to explicitly set enum case Int raw values<br>&gt; for every case in these enums in every module always, and suffer<br>&gt; compilation errors when other (maybe binary) modules change their explicit<br>&gt; raw values and clash with other modules. It could be a dependency nightmare.<br>&gt;<br>&gt; Essentially consigning extensible enums to never being useful for<br>&gt; serialising their raw values seems of limited use to me, as often you may<br>&gt; not know you need them to have unmoving raw values until it is too late and<br>&gt; your code is in the wild.<br>&gt;<br>&gt; Perhaps I am missing some secret sauce?<br>&gt;<br>&gt; --<br>&gt; Marc Palmer<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/c0d9a110/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Unions are a no-go.<br></p><p>https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br></p><p><br>&gt; On Jun 30, 2016, at 5:00 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How many of these use cases would be safely addressed if two Enum types could be unioned to form a new type?<br>&gt; <br>&gt; It could use syntax similar to what is being proposed for existentials: (A|B), or something like this:<br>&gt; <br>&gt; enum C: A, B {}<br>&gt; <br>&gt; Swift could generate code like this:<br>&gt; <br>&gt; enum A {<br>&gt;   case A1, A2<br>&gt; }<br>&gt; enum B {<br>&gt;   case B1, B2<br>&gt; }<br>&gt; enum C {<br>&gt;   case A(Module.A)<br>&gt;   case B(Module.B)<br>&gt; <br>&gt;   init(_ a: Module.A) { self = .A(a) }<br>&gt;   init(_ b: Module.B) { self = .B(b)  }<br>&gt; <br>&gt;   static let A1 = C(A.A1)<br>&gt;   static let A2 = C(A.A2)<br>&gt;   static let B1 = C(B.B1)<br>&gt;   static let B2 = C(B.B2)<br>&gt; }<br>&gt; extension A {<br>&gt;   init?(_ c: C) {<br>&gt;     guard let case .A(a) = c else { return nil }<br>&gt;     self = a<br>&gt;   }<br>&gt; }<br>&gt; extension B {<br>&gt;   init?(_ c: C) {<br>&gt;     guard let case .B(b) = c else { return nil }<br>&gt;     self = b<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; If I remember correctly there was already some proposals like this, they are probably more thought out than this suggestion.  I know I&#39;d find that useful, I don&#39;t think I&#39;d want the exhaustibility implications of extending an enum in another module.<br>&gt; <br>&gt; <br>&gt; On Friday, 1 July 2016, Marc Palmer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; I too groan when faced with the lack of extensibility on enums. As a potential framework writer, I&#39;d like to be able to use an enum as a key to dictionaries, supplying a minimum set of such enum cases, but allowing app developers to add new ones they require. <br>&gt; <br>&gt; Having read the proposal however, I have a major concern and question the entire idea. <br>&gt; <br>&gt; Given that there is unlikely to be a sane way to order the extended enum cases supplied by other modules, we will never be able to rely on the automatic ordinal values applied, nor their relative position in the natural sequence, for there isn&#39;t one outside of the first set of cases in the original definition. <br>&gt; <br>&gt; For many cases this may be fine, on the understanding that everything would have to compile from source, but my understanding is that we don&#39;t want that in future with ABI around the corner. Binary libraries would probably need to bake in the value of e.g. Int enum cases. (I think?)<br>&gt; <br>&gt; I fear that if this proposal were implemented without some major restrictions (such as never allowing use of rawValue), we would regret it and suffer for example having to explicitly set enum case Int raw values for every case in these enums in every module always, and suffer compilation errors when other (maybe binary) modules change their explicit raw values and clash with other modules. It could be a dependency nightmare.<br>&gt; <br>&gt; Essentially consigning extensible enums to never being useful for serialising their raw values seems of limited use to me, as often you may not know you need them to have unmoving raw values until it is too late and your code is in the wild. <br>&gt; <br>&gt; Perhaps I am missing some secret sauce?<br>&gt; <br>&gt; --<br>&gt; Marc Palmer<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/189c912c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>Ah right, sorry. In that case I don&#39;t see this happening, it would likely<br>introduce undefined behaviour.<br></p><p>On Friday, 1 July 2016, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; Unions are a no-go.<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;<br>&gt;<br>&gt; On Jun 30, 2016, at 5:00 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; How many of these use cases would be safely addressed if two Enum types<br>&gt; could be unioned to form a new type?<br>&gt;<br>&gt; It could use syntax similar to what is being proposed for existentials:<br>&gt; (A|B), or something like this:<br>&gt;<br>&gt; enum C: A, B {}<br>&gt;<br>&gt; Swift could generate code like this:<br>&gt;<br>&gt; enum A {<br>&gt;   case A1, A2<br>&gt; }<br>&gt; enum B {<br>&gt;   case B1, B2<br>&gt; }<br>&gt; enum C {<br>&gt;   case A(Module.A)<br>&gt;   case B(Module.B)<br>&gt;<br>&gt;   init(_ a: Module.A) { self = .A(a) }<br>&gt;   init(_ b: Module.B) { self = .B(b)  }<br>&gt;<br>&gt;   static let A1 = C(A.A1)<br>&gt;   static let A2 = C(A.A2)<br>&gt;   static let B1 = C(B.B1)<br>&gt;   static let B2 = C(B.B2)<br>&gt; }<br>&gt; extension A {<br>&gt;   init?(_ c: C) {<br>&gt;     guard let case .A(a) = c else { return nil }<br>&gt;     self = a<br>&gt;   }<br>&gt; }<br>&gt; extension B {<br>&gt;   init?(_ c: C) {<br>&gt;     guard let case .B(b) = c else { return nil }<br>&gt;     self = b<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If I remember correctly there was already some proposals like this, they<br>&gt; are probably more thought out than this suggestion.  I know I&#39;d find that<br>&gt; useful, I don&#39;t think I&#39;d want the exhaustibility implications of extending<br>&gt; an enum in another module.<br>&gt;<br>&gt;<br>&gt; On Friday, 1 July 2016, Marc Palmer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I too groan when faced with the lack of extensibility on enums. As a<br>&gt;&gt; potential framework writer, I&#39;d like to be able to use an enum as a key to<br>&gt;&gt; dictionaries, supplying a minimum set of such enum cases, but allowing app<br>&gt;&gt; developers to add new ones they require.<br>&gt;&gt;<br>&gt;&gt; Having read the proposal however, I have a major concern and question the<br>&gt;&gt; entire idea.<br>&gt;&gt;<br>&gt;&gt; Given that there is unlikely to be a sane way to order the extended enum<br>&gt;&gt; cases supplied by other modules, we will never be able to rely on the<br>&gt;&gt; automatic ordinal values applied, nor their relative position in the<br>&gt;&gt; natural sequence, for there isn&#39;t one outside of the first set of cases in<br>&gt;&gt; the original definition.<br>&gt;&gt;<br>&gt;&gt; For many cases this may be fine, on the understanding that everything<br>&gt;&gt; would have to compile from source, but my understanding is that we don&#39;t<br>&gt;&gt; want that in future with ABI around the corner. Binary libraries would<br>&gt;&gt; probably need to bake in the value of e.g. Int enum cases. (I think?)<br>&gt;&gt;<br>&gt;&gt; I fear that if this proposal were implemented without some major<br>&gt;&gt; restrictions (such as never allowing use of rawValue), we would regret it<br>&gt;&gt; and suffer for example having to explicitly set enum case Int raw values<br>&gt;&gt; for every case in these enums in every module always, and suffer<br>&gt;&gt; compilation errors when other (maybe binary) modules change their explicit<br>&gt;&gt; raw values and clash with other modules. It could be a dependency nightmare.<br>&gt;&gt;<br>&gt;&gt; Essentially consigning extensible enums to never being useful for<br>&gt;&gt; serialising their raw values seems of limited use to me, as often you may<br>&gt;&gt; not know you need them to have unmoving raw values until it is too late and<br>&gt;&gt; your code is in the wild.<br>&gt;&gt;<br>&gt;&gt; Perhaps I am missing some secret sauce?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Marc Palmer<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/678a043d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>Looking into the commonly rejected proposals unions are only rejected in<br>the general case because they &quot;cannot and should not&quot; be supported by the<br>type system.<br></p><p>What I suggested is only for enums, and is possible in the type system, as<br>demonstrated.<br></p><p>On Friday, 1 July 2016, Austin Zheng &lt;austinzheng at gmail.com<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;austinzheng at gmail.com&#39;);&gt;&gt; wrote:<br></p><p>&gt; Unions are a no-go.<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;<br>&gt;<br>&gt; On Jun 30, 2016, at 5:00 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; How many of these use cases would be safely addressed if two Enum types<br>&gt; could be unioned to form a new type?<br>&gt;<br>&gt; It could use syntax similar to what is being proposed for existentials:<br>&gt; (A|B), or something like this:<br>&gt;<br>&gt; enum C: A, B {}<br>&gt;<br>&gt; Swift could generate code like this:<br>&gt;<br>&gt; enum A {<br>&gt;   case A1, A2<br>&gt; }<br>&gt; enum B {<br>&gt;   case B1, B2<br>&gt; }<br>&gt; enum C {<br>&gt;   case A(Module.A)<br>&gt;   case B(Module.B)<br>&gt;<br>&gt;   init(_ a: Module.A) { self = .A(a) }<br>&gt;   init(_ b: Module.B) { self = .B(b)  }<br>&gt;<br>&gt;   static let A1 = C(A.A1)<br>&gt;   static let A2 = C(A.A2)<br>&gt;   static let B1 = C(B.B1)<br>&gt;   static let B2 = C(B.B2)<br>&gt; }<br>&gt; extension A {<br>&gt;   init?(_ c: C) {<br>&gt;     guard let case .A(a) = c else { return nil }<br>&gt;     self = a<br>&gt;   }<br>&gt; }<br>&gt; extension B {<br>&gt;   init?(_ c: C) {<br>&gt;     guard let case .B(b) = c else { return nil }<br>&gt;     self = b<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If I remember correctly there was already some proposals like this, they<br>&gt; are probably more thought out than this suggestion.  I know I&#39;d find that<br>&gt; useful, I don&#39;t think I&#39;d want the exhaustibility implications of extending<br>&gt; an enum in another module.<br>&gt;<br>&gt;<br>&gt; On Friday, 1 July 2016, Marc Palmer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I too groan when faced with the lack of extensibility on enums. As a<br>&gt;&gt; potential framework writer, I&#39;d like to be able to use an enum as a key to<br>&gt;&gt; dictionaries, supplying a minimum set of such enum cases, but allowing app<br>&gt;&gt; developers to add new ones they require.<br>&gt;&gt;<br>&gt;&gt; Having read the proposal however, I have a major concern and question the<br>&gt;&gt; entire idea.<br>&gt;&gt;<br>&gt;&gt; Given that there is unlikely to be a sane way to order the extended enum<br>&gt;&gt; cases supplied by other modules, we will never be able to rely on the<br>&gt;&gt; automatic ordinal values applied, nor their relative position in the<br>&gt;&gt; natural sequence, for there isn&#39;t one outside of the first set of cases in<br>&gt;&gt; the original definition.<br>&gt;&gt;<br>&gt;&gt; For many cases this may be fine, on the understanding that everything<br>&gt;&gt; would have to compile from source, but my understanding is that we don&#39;t<br>&gt;&gt; want that in future with ABI around the corner. Binary libraries would<br>&gt;&gt; probably need to bake in the value of e.g. Int enum cases. (I think?)<br>&gt;&gt;<br>&gt;&gt; I fear that if this proposal were implemented without some major<br>&gt;&gt; restrictions (such as never allowing use of rawValue), we would regret it<br>&gt;&gt; and suffer for example having to explicitly set enum case Int raw values<br>&gt;&gt; for every case in these enums in every module always, and suffer<br>&gt;&gt; compilation errors when other (maybe binary) modules change their explicit<br>&gt;&gt; raw values and clash with other modules. It could be a dependency nightmare.<br>&gt;&gt;<br>&gt;&gt; Essentially consigning extensible enums to never being useful for<br>&gt;&gt; serialising their raw values seems of limited use to me, as often you may<br>&gt;&gt; not know you need them to have unmoving raw values until it is too late and<br>&gt;&gt; your code is in the wild.<br>&gt;&gt;<br>&gt;&gt; Perhaps I am missing some secret sauce?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Marc Palmer<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/83e37d40/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 3:54 PM, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is the current workaround (as the proposal mentions), but it is still missing support for enum features such as associated values and the pattern matching power that they bring.<br></p><p>Fair enough, it would be hard to generalize pattern matching to this approach. Associated types are a whole other kettle of fish.<br></p><p>&gt; Also, by locking your OpenEnum conformers to reference types, you lose out on the value-semantics (very important, even for enums), and bring in the extra weight that a class is.<br></p><p>The class approach is the more lightweight option when you aren‚Äôt trying to get associated-value-like behavior.<br></p><p>There‚Äôs a fixed pool of instances, one per possible value, so there‚Äôs no per-usage allocation overhead. All one passes around are references to those fixed instances, so passing and comparing values is a one-word operation. The class is final, so any method dispatch is static.<br></p><p>Finally, you get the simplicity of leaning on pointer uniqueness to give you case uniqueness. Nothing to sneeze at there.<br></p><p>‚Ä¢ ‚Ä¢ ‚Ä¢<br></p><p>If you‚Äôre looking to have associated type-like behavior _and_ open cases, then yes, this ‚Äúunique instances‚Äù approach breaks down.<br></p><p>At that point, though, why not just use a collection of separate struct types implementing a shared protocol?<br></p><p>    public protocol FileError: ErrorProtocol { }<br></p><p>    struct FileNotFound: FileError {<br>      let path: String<br>    }<br></p><p>    struct CorruptedFile {<br>      let bytes: [Int8]<br>    }<br></p><p>    func handleFileError(error: FileError) {<br>      switch(error) {<br>        case is CorruptedFile:<br>          print(&quot;Bummer&quot;)<br>        case let fileNotFound as FileNotFound:<br>          print(&quot;Can‚Äôt find \(fileNotFound.path)&quot;)<br>      }<br>    }<br></p><p>Here the dynamic type takes on the role of the enum value, and case let x as X gives you must of what associated types give.<br></p><p>Separate struct types are what I use for the problem the proposal mentions ‚Äî structured, matchable errors with diagnostic data ‚Äî and it does work out nicely in practice. Nicer, in fact; I‚Äôd say that this:<br></p><p>    if error is FileError { ‚Ä¶ }<br></p><p>‚Ä¶is easier to read and to remember than this:<br></p><p>    if case .fileError = error { ‚Ä¶ }<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/a8e5be1b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 30, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 12:58 PM, Edward Valentini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I am finding myself in a situation where the most elegant &quot;swifty&quot; solution would be to allow enum extensions to add to existing case options.  For example lets say I&#39;m using a library that has the following enum defined: <br></p><p>This is an additive proposal, so the core team would prefer you to wait until after Swift 3.0 to discuss this.  Thanks,<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Allowing enum extensions to also be able to expand case options</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>July  1, 2016 at 05:00:00pm</p></header><div class="content"><p>That makes sense, thanks for letting us know.<br></p><p>Dan<br>On Thu, Jun 30, 2016 at 11:32 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 30, 2016, at 12:58 PM, Edward Valentini via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I am finding myself in a situation where the most elegant &quot;swifty&quot;<br>&gt; solution would be to allow enum extensions to add to existing case<br>&gt; options.  For example lets say I&#39;m using a library that has the following<br>&gt; enum defined:<br>&gt;<br>&gt; This is an additive proposal, so the core team would prefer you to wait<br>&gt; until after Swift 3.0 to discuss this.  Thanks,<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/45466604/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
