<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>December 27, 2015 at 07:00:00pm</p></header><div class="content"><p>-- Introduction<br></p><p>There should be a property on CollectionType that returns a sequence of<br>(Index, Element) tuples.<br>Currently enumerate() is often used instead, but it is not well suited to<br>the task and can lead to bugs.<br></p><p><br></p><p>-- Motivation<br></p><p>Using enumerate() instead of an (Index, Element) sequence has two main<br>problems.<br>Both arise because enumerate() returns a sequence of (n, Element) tuples,<br>where n is the element *number*, instead of a sequence of (Index, Element).<br></p><p>1) It doesn&#39;t work for collections not indexed by integers.<br></p><p>2) It doesn&#39;t do what you might expect in some cases, as indices do not<br>always start at 0.<br>For example ArraySlice&#39;s indices do not: array[2..&lt;5] starts with index 2.<br>Consider the following code to take the 2nd half of the array and remove<br>all empty elements:<br></p><p>var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ]<br>var secondHalf = array[array.count/2..&lt;array.count]<br>for (index, element) in secondHalf.enumerate() {<br>  if element == &quot;&quot; {<br>  secondHalf.removeAtIndex(index)<br>  }<br>}<br></p><p>This code will crash (ignoring for a moment this should probably be using<br>filter).<br></p><p><br></p><p>-- Alternatives<br></p><p>The same effect can already be achieved using the following:<br></p><p>for index in collection.indices {<br>  let element = collection[index]<br>  // ...<br>}<br></p><p>However having a dedicated (Index, Element) sequence has the following<br>advantages:<br>a) It can help prevent people from using enumerate() inappropriately.<br>b) It is very common use case that deserves shortening.<br>c) It can be chained (e.g. to map).<br></p><p><br></p><p>-- Proposed Solution<br></p><p>Add a property/method on CollectionType that returns a sequence of (Index,<br>Element) tuples.<br>For example, using a property named indexed:<br></p><p>for (index, element) in collection.indexed {<br>  // ...<br>}<br></p><p>This should be the preferred idiom when you want both the index and the<br>element.<br></p><p>Note that enumerate() does still have valid roles to play:<br>- When you actually do want the element number, not the index.<br>- When you have a SequenceType, as it isn&#39;t indexed.<br></p><p><br></p><p>-- Implementation<br></p><p>The feature could be entirely implemented using existing constructs:<br></p><p>extension CollectionType {<br>  var indexed: AnySequence&lt;(Index, Generator.Element)&gt; {<br>    return AnySequence(indices.lazy.map { ($0, self[$0]) })<br>  }<br>}<br></p><p>Alternatively, a dedicated SequenceType and/or GeneratorType could be added.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/975f6ca9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 27, 2015 at 10:00:00pm</p></header><div class="content"><p>What you&#39;re asking for can already be done with `zip(col.indices, col)`.<br>And in my experience the need for this sort of thing is rare enough that<br>there&#39;s no need to have a dedicated property for it in the stdlib. The<br>few times that I&#39;ve needed this sort of thing, I&#39;ve always just said<br></p><p>for index in col.indices {    let elt = col[index]    // ... }<br></p><p>and that&#39;s pretty simple. But if I ever did need to map it, I&#39;d just use<br>the aforementioned zip() expression.<br></p><p>-Kevin Ballard<br></p><p>On Sun, Dec 27, 2015, at 12:08 AM, Patrick Pijnappel via swift-evolution wrote:<br>&gt; -- Introduction<br>&gt;<br>&gt; There should be a property on CollectionType that returns a sequence<br>&gt; of (Index, Element) tuples. Currently enumerate() is often used<br>&gt; instead, but it is not well suited to the task and can lead to bugs.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Motivation<br>&gt;<br>&gt; Using enumerate() instead of an (Index, Element) sequence has two main<br>&gt; problems. Both arise because enumerate() returns a sequence of (n,<br>&gt; Element) tuples, where n is the element *number*, instead of a<br>&gt; sequence of (Index, Element).<br>&gt;<br>&gt; 1) It doesn&#39;t work for collections not indexed by integers.<br>&gt;<br>&gt; 2) It doesn&#39;t do what you might expect in some cases, as indices do<br>&gt;    not always start at 0. For example ArraySlice&#39;s indices do not:<br>&gt;    array[2..&lt;5] starts with index 2. Consider the following code to<br>&gt;    take the 2nd half of the array and remove all empty elements:<br>&gt;<br>&gt; var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ] var secondHalf =<br>&gt; array[array.count/2..&lt;array.count] for (index, element) in<br>&gt; secondHalf.enumerate() { if element == &quot;&quot; {<br>&gt; secondHalf.removeAtIndex(index) } }<br>&gt;<br>&gt; This code will crash (ignoring for a moment this should probably be<br>&gt; using filter).<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Alternatives<br>&gt;<br>&gt; The same effect can already be achieved using the following:<br>&gt;<br>&gt; for index in collection.indices {  let element = collection[index]<br>&gt; // ... }<br>&gt;<br>&gt; However having a dedicated (Index, Element) sequence has the following<br>&gt; advantages:<br>&gt; a) It can help prevent people from using enumerate() inappropriately.<br>&gt; b) It is very common use case that deserves shortening.<br>&gt; c) It can be chained (e.g. to map).<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Proposed Solution<br>&gt;<br>&gt; Add a property/method on CollectionType that returns a sequence of<br>&gt; (Index, Element) tuples. For example, using a property named indexed:<br>&gt;<br>&gt; for (index, element) in collection.indexed {  // ... }<br>&gt;<br>&gt; This should be the preferred idiom when you want both the index and<br>&gt; the element.<br>&gt;<br>&gt; Note that enumerate() does still have valid roles to play:<br>&gt; - When you actually do want the element number, not the index.<br>&gt; - When you have a SequenceType, as it isn&#39;t indexed.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Implementation<br>&gt;<br>&gt; The feature could be entirely implemented using existing constructs:<br>&gt;<br>&gt; extension CollectionType {  var indexed: AnySequence&lt;(Index,<br>&gt; Generator.Element)&gt; {    return AnySequence(indices.lazy.map { ($0,<br>&gt; self[$0]) })  } }<br>&gt;<br>&gt; Alternatively, a dedicated SequenceType and/or GeneratorType could<br>&gt; be added.<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/45e6f544/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 27, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; What you&#39;re asking for can already be done with `zip(col.indices, col)`. And in my experience the need for this sort of thing is rare enough that there&#39;s no need to have a dedicated property for it in the stdlib. The few times that I&#39;ve needed this sort of thing, I&#39;ve always just said<br>&gt;  <br>&gt; for index in col.indices {<br>&gt;     let elt = col[index]<br>&gt;     // ...<br>&gt; }<br>&gt;  <br>&gt; and that&#39;s pretty simple. But if I ever did need to map it, I&#39;d just use the aforementioned zip() expression. <br></p><p>I know the zip trick and have used it several times. In one project, I used it frequently enough that I created an extension. Personally, I would like to see a more convenient way to do this, although it&#39;s not that strong of a preference.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>December 28, 2015 at 09:00:00pm</p></header><div class="content"><p>The original example contains a bug which is present on all looping version/alternative due to the mutating nature of the array. Using the zip implementation:<br></p><p>var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ]<br>var secondHalf = array[array.count/2..&lt;array.count]<br>for (index, element) in zip(secondHalf.indices, secondHalf) {<br>    if element == &quot;&quot; {<br>        secondHalf.removeAtIndex(index)<br>    }<br>}<br></p><p>The variable index cycles through 3,4 and 5; but in order to be able to remove the right element beyond the first removal, the variable index should have cycled through 3, 4 and 4 (as some elements got shifted after the first mutation). Mutating the array/list which one loops over is a risky business and is a nice source of bugs (including infinite loop). If this (Index, Element) is further investigated, it should consider that one may also want to do a insert(:atIndex:), and may expect the (Index, Element) to have proper Index but only for the original Element.<br></p><p>Dany St-Amant<br></p><p><br>&gt; Le 28 déc. 2015 à 01:06, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; What you&#39;re asking for can already be done with `zip(col.indices, col)`. And in my experience the need for this sort of thing is rare enough that there&#39;s no need to have a dedicated property for it in the stdlib. The few times that I&#39;ve needed this sort of thing, I&#39;ve always just said<br>&gt;  <br>&gt; for index in col.indices {<br>&gt;     let elt = col[index]<br>&gt;     // ...<br>&gt; }<br>&gt;  <br>&gt; and that&#39;s pretty simple. But if I ever did need to map it, I&#39;d just use the aforementioned zip() expression.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Sun, Dec 27, 2015, at 12:08 AM, Patrick Pijnappel via swift-evolution wrote:<br>&gt;&gt; -- Introduction<br>&gt;&gt;  <br>&gt;&gt; There should be a property on CollectionType that returns a sequence of (Index, Element) tuples.<br>&gt;&gt; Currently enumerate() is often used instead, but it is not well suited to the task and can lead to bugs.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; -- Motivation<br>&gt;&gt;  <br>&gt;&gt; Using enumerate() instead of an (Index, Element) sequence has two main problems.<br>&gt;&gt; Both arise because enumerate() returns a sequence of (n, Element) tuples,<br>&gt;&gt; where n is the element *number*, instead of a sequence of (Index, Element).<br>&gt;&gt;  <br>&gt;&gt; 1) It doesn&#39;t work for collections not indexed by integers.<br>&gt;&gt;  <br>&gt;&gt; 2) It doesn&#39;t do what you might expect in some cases, as indices do not always start at 0.<br>&gt;&gt; For example ArraySlice&#39;s indices do not: array[2..&lt;5] starts with index 2.<br>&gt;&gt; Consider the following code to take the 2nd half of the array and remove all empty elements:<br>&gt;&gt;  <br>&gt;&gt; var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ]<br>&gt;&gt; var secondHalf = array[array.count/2..&lt;array.count]<br>&gt;&gt; for (index, element) in secondHalf.enumerate() {<br>&gt;&gt; if element == &quot;&quot; {<br>&gt;&gt; secondHalf.removeAtIndex(index)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; This code will crash (ignoring for a moment this should probably be using filter).<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; -- Alternatives<br>&gt;&gt;  <br>&gt;&gt; The same effect can already be achieved using the following:<br>&gt;&gt;  <br>&gt;&gt; for index in collection.indices {<br>&gt;&gt;   let element = collection[index]<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; However having a dedicated (Index, Element) sequence has the following advantages:<br>&gt;&gt; a) It can help prevent people from using enumerate() inappropriately.<br>&gt;&gt; b) It is very common use case that deserves shortening.<br>&gt;&gt; c) It can be chained (e.g. to map).<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; -- Proposed Solution<br>&gt;&gt;  <br>&gt;&gt; Add a property/method on CollectionType that returns a sequence of (Index, Element) tuples.<br>&gt;&gt; For example, using a property named indexed:<br>&gt;&gt;  <br>&gt;&gt; for (index, element) in collection.indexed {<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; This should be the preferred idiom when you want both the index and the element.<br>&gt;&gt;  <br>&gt;&gt; Note that enumerate() does still have valid roles to play:<br>&gt;&gt; - When you actually do want the element number, not the index.<br>&gt;&gt; - When you have a SequenceType, as it isn&#39;t indexed.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; -- Implementation<br>&gt;&gt;  <br>&gt;&gt; The feature could be entirely implemented using existing constructs:<br>&gt;&gt;  <br>&gt;&gt; extension CollectionType {<br>&gt;&gt;   var indexed: AnySequence&lt;(Index, Generator.Element)&gt; {<br>&gt;&gt;     return AnySequence(indices.lazy.map { ($0, self[$0]) })<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; Alternatively, a dedicated SequenceType and/or GeneratorType could be added.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/fc67c4fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 28, 2015 at 10:00:00pm</p></header><div class="content"><p>What you describe isn&#39;t a bug in the implementation, it&#39;s a bug in the<br>expectation that you can mutate an array that you&#39;re iterating over.<br>With any other collection, the mutation would actually invalidate the<br>index. It so happens that Arrays use Int as their index, so they can&#39;t<br>really be considered invalid, but you should treat them the same way in<br>cases like this; mutating the array means the index range you&#39;re<br>iterating over is no longer representative of the array.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 28, 2015, at 06:30 PM, Dany St-Amant via swift-evolution wrote:<br>&gt;<br>&gt; The original example contains a bug which is present on all looping<br>&gt; version/alternative due to the mutating nature of the array. Using the<br>&gt; zip implementation:<br>&gt;<br>&gt; var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ] var secondHalf =<br>&gt; array[array.count/2..&lt;array.count] for (index, element) in<br>&gt; zip(secondHalf.indices, secondHalf) { if element == &quot;&quot; {<br>&gt; secondHalf.removeAtIndex(index)    } }<br>&gt;<br>&gt; The variable index cycles through 3,4 and 5; but in order to be able<br>&gt; to remove the right element beyond the first removal, the variable<br>&gt; index should have cycled through 3, 4 and 4 (as some elements got<br>&gt; shifted after the first mutation). Mutating the array/list which one<br>&gt; loops over is a risky business and is a nice source of bugs (including<br>&gt; infinite loop). If this (Index, Element) is further investigated, it<br>&gt; should consider that one may also want to do a insert(:atIndex:), and<br>&gt; may expect the (Index, Element) to have proper Index but only for the<br>&gt; original Element.<br>&gt;<br>&gt; Dany St-Amant<br>&gt;<br>&gt;<br>&gt;&gt; Le 28 déc. 2015 à 01:06, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; What you&#39;re asking for can already be done with `zip(col.indices,<br>&gt;&gt; col)`. And in my experience the need for this sort of thing is rare<br>&gt;&gt; enough that there&#39;s no need to have a dedicated property for it in<br>&gt;&gt; the stdlib. The few times that I&#39;ve needed this sort of thing, I&#39;ve<br>&gt;&gt; always just said<br>&gt;&gt;<br>&gt;&gt; for index in col.indices {    let elt = col[index]    // ... }<br>&gt;&gt;<br>&gt;&gt; and that&#39;s pretty simple. But if I ever did need to map it, I&#39;d just<br>&gt;&gt; use the aforementioned zip() expression.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 27, 2015, at 12:08 AM, Patrick Pijnappel via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt; -- Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There should be a property on CollectionType that returns a sequence<br>&gt;&gt;&gt; of (Index, Element) tuples. Currently enumerate() is often used<br>&gt;&gt;&gt; instead, but it is not well suited to the task and can lead to bugs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Using enumerate() instead of an (Index, Element) sequence has two<br>&gt;&gt;&gt; main problems. Both arise because enumerate() returns a sequence of<br>&gt;&gt;&gt; (n, Element) tuples, where n is the element *number*, instead of a<br>&gt;&gt;&gt; sequence of (Index, Element).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) It doesn&#39;t work for collections not indexed by integers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) It doesn&#39;t do what you might expect in some cases, as indices do<br>&gt;&gt;&gt;    not always start at 0. For example ArraySlice&#39;s indices do not:<br>&gt;&gt;&gt;    array[2..&lt;5] starts with index 2. Consider the following code to<br>&gt;&gt;&gt;    take the 2nd half of the array and remove all empty elements:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ] var secondHalf =<br>&gt;&gt;&gt; array[array.count/2..&lt;array.count] for (index, element) in<br>&gt;&gt;&gt; secondHalf.enumerate() { if element == &quot;&quot; {<br>&gt;&gt;&gt; secondHalf.removeAtIndex(index) } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This code will crash (ignoring for a moment this should probably be<br>&gt;&gt;&gt; using filter).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Alternatives<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The same effect can already be achieved using the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; for index in collection.indices {  let element = collection[index]<br>&gt;&gt;&gt; // ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However having a dedicated (Index, Element) sequence has the<br>&gt;&gt;&gt; following advantages:<br>&gt;&gt;&gt; a) It can help prevent people from using enumerate()<br>&gt;&gt;&gt;    inappropriately.<br>&gt;&gt;&gt; b) It is very common use case that deserves shortening.<br>&gt;&gt;&gt; c) It can be chained (e.g. to map).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Proposed Solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Add a property/method on CollectionType that returns a sequence of<br>&gt;&gt;&gt; (Index, Element) tuples. For example, using a property named<br>&gt;&gt;&gt; indexed:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; for (index, element) in collection.indexed {  // ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This should be the preferred idiom when you want both the index and<br>&gt;&gt;&gt; the element.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that enumerate() does still have valid roles to play:<br>&gt;&gt;&gt; - When you actually do want the element number, not the index.<br>&gt;&gt;&gt; - When you have a SequenceType, as it isn&#39;t indexed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Implementation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The feature could be entirely implemented using existing constructs:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension CollectionType {  var indexed: AnySequence&lt;(Index,<br>&gt;&gt;&gt; Generator.Element)&gt; {    return AnySequence(indices.lazy.map { ($0,<br>&gt;&gt;&gt; self[$0]) })  } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatively, a dedicated SequenceType and/or GeneratorType could<br>&gt;&gt;&gt; be added.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/d9abe971/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 29, 2015 at 04:00:00pm</p></header><div class="content"><p>FWIW: In cases like this, just remember call &quot;.reverse()&quot; and remove from<br>the back.<br></p><p>var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ]<br>for (index, element) in array.enumerate().reverse() {<br>    if element == &quot;&quot; {<br>        array.removeAtIndex(index)<br>    }<br>}<br>print(array) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]<br></p><p>zip is useful when we have ArraySlice as has been said before:<br></p><p>var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot;, &quot;&quot;, &quot;e&quot;, &quot;&quot; , &quot;f&quot;, &quot;g&quot;, &quot;&quot;]<br>var secondHalf = array[array.count/2..&lt;array.count]<br>print(secondHalf) // [&quot;&quot;, &quot;e&quot;, &quot;&quot;, &quot;f&quot;, &quot;g&quot;, &quot;&quot;]<br>for (index, element) in zip(secondHalf.indices, secondHalf).reverse() {<br>    if element == &quot;&quot; {<br>        secondHalf.removeAtIndex(index)<br>    }<br>}<br></p><p>print(secondHalf) // [&quot;e&quot;, &quot;f&quot;, &quot;g&quot;]<br></p><p>Anyway, it would not be correct to &quot;.enumerate()&quot; returns (Index, Element)<br>instead of (n, Element)?<br></p><p>I believe that the current behavior was thought when Slices had indices<br>starting with zero.<br></p><p>Em ter, 29 de dez de 2015 às 00:30, Dany St-Amant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; The original example contains a bug which is present on all looping<br>&gt; version/alternative due to the mutating nature of the array. Using the zip<br>&gt; implementation:<br>&gt;<br>&gt; var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ]<br>&gt; var secondHalf = array[array.count/2..&lt;array.count]<br>&gt; for (index, element) in zip(secondHalf.indices, secondHalf) {<br>&gt;     if element == &quot;&quot; {<br>&gt;         secondHalf.removeAtIndex(index)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; The variable index cycles through 3,4 and 5; but in order to be able to<br>&gt; remove the right element beyond the first removal, the variable index<br>&gt; should have cycled through 3, 4 and 4 (as some elements got shifted after<br>&gt; the first mutation). Mutating the array/list which one loops over is a<br>&gt; risky business and is a nice source of bugs (including infinite loop). If<br>&gt; this (Index, Element) is further investigated, it should consider that one<br>&gt; may also want to do a insert(:atIndex:), and may expect the (Index,<br>&gt; Element) to have proper Index but only for the original Element.<br>&gt;<br>&gt; Dany St-Amant<br>&gt;<br>&gt;<br>&gt; Le 28 déc. 2015 à 01:06, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; What you&#39;re asking for can already be done with `zip(col.indices, col)`.<br>&gt; And in my experience the need for this sort of thing is rare enough that<br>&gt; there&#39;s no need to have a dedicated property for it in the stdlib. The few<br>&gt; times that I&#39;ve needed this sort of thing, I&#39;ve always just said<br>&gt;<br>&gt; for index in col.indices {<br>&gt;     let elt = col[index]<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; and that&#39;s pretty simple. But if I ever did need to map it, I&#39;d just use<br>&gt; the aforementioned zip() expression.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Sun, Dec 27, 2015, at 12:08 AM, Patrick Pijnappel via swift-evolution<br>&gt; wrote:<br>&gt;<br>&gt; -- Introduction<br>&gt;<br>&gt; There should be a property on CollectionType that returns a sequence of<br>&gt; (Index, Element) tuples.<br>&gt; Currently enumerate() is often used instead, but it is not well suited to<br>&gt; the task and can lead to bugs.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Motivation<br>&gt;<br>&gt; Using enumerate() instead of an (Index, Element) sequence has two main<br>&gt; problems.<br>&gt; Both arise because enumerate() returns a sequence of (n, Element) tuples,<br>&gt; where n is the element *number*, instead of a sequence of (Index, Element)<br>&gt; .<br>&gt;<br>&gt; 1) It doesn&#39;t work for collections not indexed by integers.<br>&gt;<br>&gt; 2) It doesn&#39;t do what you might expect in some cases, as indices do not<br>&gt; always start at 0.<br>&gt; For example ArraySlice&#39;s indices do not: array[2..&lt;5] starts with index 2.<br>&gt; Consider the following code to take the 2nd half of the array and remove<br>&gt; all empty elements:<br>&gt;<br>&gt; var array = [ &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot; ]<br>&gt; var secondHalf = array[array.count/2..&lt;array.count]<br>&gt; for (index, element) in secondHalf.enumerate() {<br>&gt; if element == &quot;&quot; {<br>&gt; secondHalf.removeAtIndex(index)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; This code will crash (ignoring for a moment this should probably be using<br>&gt; filter).<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Alternatives<br>&gt;<br>&gt; The same effect can already be achieved using the following:<br>&gt;<br>&gt; for index in collection.indices {<br>&gt;   let element = collection[index]<br>&gt;   // ...<br>&gt; }<br>&gt;<br>&gt; However having a dedicated (Index, Element) sequence has the following<br>&gt; advantages:<br>&gt; a) It can help prevent people from using enumerate() inappropriately.<br>&gt; b) It is very common use case that deserves shortening.<br>&gt; c) It can be chained (e.g. to map).<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Proposed Solution<br>&gt;<br>&gt; Add a property/method on CollectionType that returns a sequence of (Index,<br>&gt; Element) tuples.<br>&gt; For example, using a property named indexed:<br>&gt;<br>&gt; for (index, element) in collection.indexed {<br>&gt;   // ...<br>&gt; }<br>&gt;<br>&gt; This should be the preferred idiom when you want both the index and the<br>&gt; element.<br>&gt;<br>&gt; Note that enumerate() does still have valid roles to play:<br>&gt; - When you actually do want the element number, not the index.<br>&gt; - When you have a SequenceType, as it isn&#39;t indexed.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -- Implementation<br>&gt;<br>&gt; The feature could be entirely implemented using existing constructs:<br>&gt;<br>&gt; extension CollectionType {<br>&gt;   var indexed: AnySequence&lt;(Index, Generator.Element)&gt; {<br>&gt;     return AnySequence(indices.lazy.map { ($0, self[$0]) })<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Alternatively, a dedicated SequenceType and/or GeneratorType could be<br>&gt; added.<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/83f60a16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Anyway, it would not be correct to &quot;.enumerate()&quot; returns (Index, Element) instead of (n, Element)?<br>&gt; <br>&gt; I believe that the current behavior was thought when Slices had indices starting with zero.<br>&gt; <br></p><p>The behavior of enumerate is easiest to explain when you give everything a name and lay them all out on the table: In particular, there is a difference between a Counter, an Index, a Key, a Value, and an Element.<br></p><p>Enumerate always works in terms of adding a counter, not an index. It was perhaps better served as a global method, since one cannot really improve its default implementation.<br></p><p>The rest are as follows:<br></p><p>╔════════════╦═════════════════╦═══════════════╦═════════════════╦════════════════════╗<br>║ Type       ║ Index*          ║ Key           ║ Value           ║ Element**          ║<br>╠════════════╬═════════════════╬═══════════════╬═════════════════╬════════════════════╣<br>║ Array      ║ 0-based offset  ║ N/A           ║ N/A             ║ Generic &quot;T&quot;        ║<br>╠════════════╬═════════════════╬═══════════════╬═════════════════╬════════════════════╣<br>║ ArraySlice ║ non-zero offset ║ N/A           ║ N/A             ║ Generic &quot;T&quot;        ║<br>╠════════════╬═════════════════╬═══════════════╬═════════════════╬════════════════════╣<br>║ Dictionary ║ DictionaryIndex ║ Generic &quot;Key&quot; ║ Generic &quot;Value&quot; ║ Tuple (Key, Value) ║<br>╚════════════╩═════════════════╩═══════════════╩═════════════════╩════════════════════╝<br></p><p>* Index is declared on CollectionType<br>** Element is declared on GeneratorType and referenced by SequenceType<br></p><p>That Array [T] does not behave like a Dictionary [Int:T] is possibly a sign that an AssociativeCollectionType is needed, something like:<br></p><p>protocol AssociativeCollectionType : CollectionType {<br>    typealias Key<br>    typealias Value<br>    typealias Element = (Key, Value)<br>    typealias KeySequenceType = AnySequence&lt;Key&gt;<br>    typealias ValueSequenceType = AnySequence&lt;Value&gt;<br>    <br>    var keys: KeySequenceType { get }<br>    var values: ValueSequenceType { get }<br>    subscript (key: Key) -&gt; Value? { get set }<br>    func indexForKey(key:Key) -&gt; Index<br></p><p>    mutating func removeValueForKey(key: Key) -&gt; Value?<br>    mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>}<br></p><p>Dictionary would support such a protocol directly. Array and ArraySlice (or even every CollectionType) might have a mapping function (lets bike shed “associative()” for now) to return an implementation of the interface, mapping:<br></p><p>- AssociativeCollectionType.Index = old Index<br>- AssociativeCollectionType.Key = old Index<br>- AssociativeCollectionType.Value = old Element<br>- AssociativeCollectionType.Element = old (Index, Element)<br></p><p>So maybe:<br></p><p>for (index, element) in someArray.associative() { … }<br></p><p>would do what the original idea requested: provide a (Index, Element) sequence for CollectionTypes.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/a8e00e28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 2:37 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Anyway, it would not be correct to &quot;.enumerate()&quot; returns (Index, Element) instead of (n, Element)?<br>&gt;&gt; <br>&gt;&gt; I believe that the current behavior was thought when Slices had indices starting with zero.<br>&gt;&gt; <br>&gt; <br>&gt; The behavior of enumerate is easiest to explain when you give everything a name and lay them all out on the table: In particular, there is a difference between a Counter, an Index, a Key, a Value, and an Element.<br>&gt; <br>&gt; Enumerate always works in terms of adding a counter, not an index. It was perhaps better served as a global method, since one cannot really improve its default implementation.<br>&gt; <br>&gt; The rest are as follows:<br>&gt; <br>&gt; ╔════════════╦═════════════════╦═══════════════╦═════════════════╦════════════════════╗<br>&gt; ║ Type       ║ Index*          ║ Key           ║ Value           ║ Element**          ║<br>&gt; ╠════════════╬═════════════════╬═══════════════╬═════════════════╬════════════════════╣<br>&gt; ║ Array      ║ 0-based offset  ║ N/A           ║ N/A             ║ Generic &quot;T&quot;        ║<br>&gt; ╠════════════╬═════════════════╬═══════════════╬═════════════════╬════════════════════╣<br>&gt; ║ ArraySlice ║ non-zero offset ║ N/A           ║ N/A             ║ Generic &quot;T&quot;        ║<br>&gt; ╠════════════╬═════════════════╬═══════════════╬═════════════════╬════════════════════╣<br>&gt; ║ Dictionary ║ DictionaryIndex ║ Generic &quot;Key&quot; ║ Generic &quot;Value&quot; ║ Tuple (Key, Value) ║<br>&gt; ╚════════════╩═════════════════╩═══════════════╩═════════════════╩════════════════════╝<br>&gt; <br>&gt; * Index is declared on CollectionType<br>&gt; ** Element is declared on GeneratorType and referenced by SequenceType<br>&gt; <br>&gt; That Array [T] does not behave like a Dictionary [Int:T] is possibly a sign that an AssociativeCollectionType is needed, something like:<br>&gt; <br>&gt; protocol AssociativeCollectionType : CollectionType {<br>&gt;     typealias Key<br>&gt;     typealias Value<br>&gt;     typealias Element = (Key, Value)<br>&gt;     typealias KeySequenceType = AnySequence&lt;Key&gt;<br>&gt;     typealias ValueSequenceType = AnySequence&lt;Value&gt;<br>&gt;     <br>&gt;     var keys: KeySequenceType { get }<br>&gt;     var values: ValueSequenceType { get }<br>&gt;     subscript (key: Key) -&gt; Value? { get set }<br>&gt;     func indexForKey(key:Key) -&gt; Index<br>&gt; <br>&gt;     mutating func removeValueForKey(key: Key) -&gt; Value?<br>&gt;     mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>&gt; }<br></p><p>What is the use-case for this protocol?<br></p><p>&gt; <br>&gt; Dictionary would support such a protocol directly. Array and ArraySlice (or even every CollectionType) might have a mapping function (lets bike shed “associative()” for now) to return an implementation of the interface, mapping:<br>&gt; <br>&gt; - AssociativeCollectionType.Index = old Index<br>&gt; - AssociativeCollectionType.Key = old Index<br>&gt; - AssociativeCollectionType.Value = old Element<br>&gt; - AssociativeCollectionType.Element = old (Index, Element)<br>&gt; <br>&gt; So maybe:<br>&gt; <br>&gt; for (index, element) in someArray.associative() { … }<br>&gt; <br>&gt; would do what the original idea requested: provide a (Index, Element) sequence for CollectionTypes.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/d063fe87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 31, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:53 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; What is the use-case for this protocol?<br></p><p>I actually suspect you have a better grasp of the pros and cons based on your prior experience, but here goes:<br></p><p>An AssociativeCollectionType would allow for alternate implementations from Dictionary, which provide space optimization, lookup performance, and functionality, to be used closer to the level of first-class citizenship that Dictionary has. This is similar IMHO to the status of say ArraySlice vs Array.<br></p><p>1. While there is a protocol for implementing your own collection, there is none for implementing your own associative collection. Without such a protocol, interfaces must be written to require Dictionary, and to get things into the Dictionary representation (rather than just exposing an associative interface) will require data copying as well as other probably smaller details like the value be Hashable<br></p><p>2. A single dictionary-like type means that features which may be desirable in an associative collection (preserving insertion order, sorting by key, atomicity guarantees, searching by closest match, computed/default/prototype-fallback value lookup) as well as problem-space optimized algorithms (hash vs tree vs splay vs skip list) would each either need to be features of Dictionary, or be second-class citizens. <br></p><p>3. People who wish to have arrays behave like dictionaries (and are willing to take the performance hit re: array index out of bounds returning nil instead of raising a fatal error) could get the appropriate interface to do so<br></p><p>4. Array is mostly described (excluding certain mutating operations) by CollectionType. Dictionary on the other hand only really uses CollectionType to allow iteration and to reference items in buckets (I assume). The Raison d&#39;etre of Dictionary as a core type is just not represented via protocols the way Array is<br></p><p><br>Some of this though is that many CollectionType and SequenceType operations are useful when considering a Dictionary as a sequence in a functional style - but is not the default way I at least think of Dictionaries. For instance, how often will people want to filter a dictionary into a tuple array, vs mutating or forming a new dictionary with predicate-failing entries removed?<br></p><p>As least in my personal experience, the difference in relationship between Array and CollectionType (Array being a type of collection) and Dictionary and CollectionType (dictionaries can be represented by a collection) is a constant source of confusion. <br></p><p>Some the cons I’ve identified:<br>- Protocols today do not have generic arguments, making any function declaration wanting to take “any string to string associative collection” vs “[String:String]” be significantly more complex.<br></p><p>- It is more pragmatic and simpler from a type perspective to push code to use a single Array or Dictionary implementation rather than needing to support generic implementations, except when opted into. This is similar to the use of lazy, or the use of Int vs smaller or more specific types.<br></p><p>- Array has additional mutating methods which are not described by CollectionType or any other protocol. The ease of getting a new copy of an array and mutating it means code needing the ability to append (for instance) today will be declared using an explicit Array type. If this was desired to be fixed, it would require more protocols (ModifiableCollectionType?)<br></p><p>- Related to the previous point, there is no way to require value semantics via a protocol. If a ModifiableCollectionType was created today, there would need to be requirements on implementation outside what a protocol can enforce. <br></p><p>- An array could not implement AssociativeCollectionType directly, because the index value and key would both be Int and there is a subscript property for both, but with different semantics and a different return type. You would need to ‘wrap’ an array to get this effect<br></p><p><br>And one final thought - It might have make sense for Dictionary to not directly be a CollectionType at all, but rather have a property that exposes the Dictionary as a CollectionType, similar to how I propose a wrapping an Array to make it act like an associative array. If you were to take a cue from Java, this would be an “entries” property on Dictionary (or AssociativeCollectionType)<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/76910d6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 11:17 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:53 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What is the use-case for this protocol?<br>&gt; <br>&gt; I actually suspect you have a better grasp of the pros and cons based on your prior experience, but here goes:<br>&gt; <br>&gt; An AssociativeCollectionType would allow for alternate implementations from Dictionary, which provide space optimization, lookup performance, and functionality, to be used closer to the level of first-class citizenship that Dictionary has.<br></p><p>That’s pretty abstract.  Note also that one shouldn’t design protocols without a batch of concrete models that you can examine to see how they should conform.<br></p><p>&gt; This is similar IMHO to the status of say ArraySlice vs Array.<br>&gt; <br>&gt; 1. While there is a protocol for implementing your own collection, there is none for implementing your own associative collection. Without such a protocol, interfaces must be written to require Dictionary, and to get things into the Dictionary representation (rather than just exposing an associative interface) will require data copying as well as other probably smaller details like the value be Hashable<br>&gt; <br>&gt; 2. A single dictionary-like type means that features which may be desirable in an associative collection (preserving insertion order, sorting by key, atomicity guarantees, searching by closest match, computed/default/prototype-fallback value lookup) as well as problem-space optimized algorithms (hash vs tree vs splay vs skip list) would each either need to be features of Dictionary, or be second-class citizens. <br>&gt; <br>&gt; 3. People who wish to have arrays behave like dictionaries (and are willing to take the performance hit re: array index out of bounds returning nil instead of raising a fatal error) could get the appropriate interface to do so<br>&gt; <br>&gt; 4. Array is mostly described (excluding certain mutating operations) by CollectionType. Dictionary on the other hand only really uses CollectionType to allow iteration and to reference items in buckets (I assume). The Raison d&#39;etre of Dictionary as a core type is just not represented via protocols the way Array is<br>&gt; <br>&gt; <br>&gt; Some of this though is that many CollectionType and SequenceType operations are useful when considering a Dictionary as a sequence in a functional style - but is not the default way I at least think of Dictionaries. For instance, how often will people want to filter a dictionary into a tuple array, vs mutating or forming a new dictionary with predicate-failing entries removed?<br>&gt; <br>&gt; As least in my personal experience, the difference in relationship between Array and CollectionType (Array being a type of collection) and Dictionary and CollectionType (dictionaries can be represented by a collection) is a constant source of confusion. <br></p><p>That sounds like a different issue.  Are you suggesting dictionaries should have-a collection rather than be-a collection?<br></p><p>&gt; Some the cons I’ve identified:<br>&gt; - Protocols today do not have generic arguments, making any function declaration wanting to take “any string to string associative collection” vs “[String:String]” be significantly more complex.<br></p><p>I don’t see why you think that increases complexity.  I don’t agree that it does.  This also seems like a completely separate issue from whether we have AssociativeCollection.<br></p><p>&gt; <br>&gt; - It is more pragmatic and simpler from a type perspective to push code to use a single Array or Dictionary implementation rather than needing to support generic implementations, except when opted into. This is similar to the use of lazy, or the use of Int vs smaller or more specific types.<br></p><p>True, and it will always be that way AFAICT.  And again this seems like a completely separate issue.<br></p><p>&gt; <br>&gt; - Array has additional mutating methods which are not described by CollectionType or any other protocol. The ease of getting a new copy of an array and mutating it means code needing the ability to append (for instance) today will be declared using an explicit Array type. If this was desired to be fixed, it would require more protocols (ModifiableCollectionType?)<br>&gt; <br>&gt; - Related to the previous point, there is no way to require value semantics via a protocol. If a ModifiableCollectionType was created today, there would need to be requirements on implementation outside what a protocol can enforce. <br>&gt; <br>&gt; - An array could not implement AssociativeCollectionType directly, because the index value and key would both be Int and there is a subscript property for both, but with different semantics and a different return type. You would need to ‘wrap’ an array to get this effect<br>&gt; <br>&gt; <br>&gt; And one final thought - It might have make sense for Dictionary to not directly be a CollectionType at all, but rather have a property that exposes the Dictionary as a CollectionType, similar to how I propose a wrapping an Array to make it act like an associative array. If you were to take a cue from Java, this would be an “entries” property on Dictionary (or AssociativeCollectionType)<br></p><p>I’m clearly not understanding something here.  What you’re talking about are all real issues, but they seem unrelated to each other and without any particular focus.  Sorry…<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/8d335380/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 31, 2015 at 08:00:00pm</p></header><div class="content"><p>First, let me say that basic premise was intended to be “I would like the ability to have a protocol for dictionary-type objects rather than have it be a single implementation for several reasons, but I expect that there would also be several hurdles to doing so”. It is more of an idea than a design or proposal at this point, partly because I suspect some of the hurdles may either be blocking until other enhancements land in Swift, or that having a concrete dictionary type is just preferred based on the design goals of the language. <br></p><p>My interface was just a copying of the methods on Dictionary which I thought made sense for illustration purposes.<br></p><p>&lt;rest inlnine&gt;<br></p><p>&gt; On Dec 31, 2015, at 2:27 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 11:17 AM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt; An AssociativeCollectionType would allow for alternate implementations from Dictionary, which provide space optimization, lookup performance, and functionality, to be used closer to the level of first-class citizenship that Dictionary has.<br>&gt; That’s pretty abstract.  Note also that one shouldn’t design protocols without a batch of concrete models that you can examine to see how they should conform.<br></p><p>Languages like Java and C# which are interface heavy come with a wide assortment of collections implementations, and third party implementations of even more. I’ve implemented core collection types (in Mono) and several of my own custom implementations over the years in these languages. <br></p><p>And yes, I would expect design and implementation to go hand-in-hand for just about any collections changes - although the current process for swift evolution does not integrate as well as I personally would like with iterative or prototype-driven design, that would be my personal preferred approach for any larger feature, especially one impacting the collections portion of the standard library.<br></p><p>&gt;&gt; Some of this though is that many CollectionType and SequenceType operations are useful when considering a Dictionary as a sequence in a functional style - but is not the default way I at least think of Dictionaries. For instance, how often will people want to filter a dictionary into a tuple array, vs mutating or forming a new dictionary with predicate-failing entries removed?<br>&gt;&gt; <br>&gt;&gt; As least in my personal experience, the difference in relationship between Array and CollectionType (Array being a type of collection) and Dictionary and CollectionType (dictionaries can be represented by a collection) is a constant source of confusion. <br>&gt; <br>&gt; That sounds like a different issue.  Are you suggesting dictionaries should have-a collection rather than be-a collection?<br></p><p>Oh boy. Prefacing with “I am unsure if I want to get into that conversation due to the impact being too great for any bike shedding to ever be relevant”, mostly yes. If it is worth further discussion, it is probably worth doing so in a separate thread.<br></p><p>A Dictionary is as representable as a collection as a Set would be. The underlying implementation of both both could just as well be an array of optionals (I’ve implemented one as such).<br></p><p>However, there is a pattern in Swift collections of pushing down as much default implementation as possible balanced against the expense of a naive default implementation. As such, there is a complexity imported directly into Dictionary to deal with what I perceive as a secondary representation of the information in the dictionary - a list of key, value pairs.<br></p><p>&gt; <br>&gt;&gt; Some the cons I’ve identified:<br>&gt;&gt; - Protocols today do not have generic arguments, making any function declaration wanting to take “any string to string associative collection” vs “[String:String]” be significantly more complex.<br>&gt; <br>&gt; I don’t see why you think that increases complexity.  I don’t agree that it does.  This also seems like a completely separate issue from whether we have AssociativeCollection.<br></p><p>I was speaking to the declarative complexity and verbosity in today’s syntax:<br></p><p>	func process(data:[String:String]) <br>vs.<br>	func process&lt;ACT:AssociativeCollectionType where ACT.Key == String, ACT.Value == String&gt;(data:ACT)<br></p><p>This would make it very difficult for one to have a custom implementation of an associative collection which accepted by third party code, simply because the API designers went with the simpler, more readable syntax.<br></p><p>&gt;&gt; <br>&gt;&gt; - It is more pragmatic and simpler from a type perspective to push code to use a single Array or Dictionary implementation rather than needing to support generic implementations, except when opted into. This is similar to the use of lazy, or the use of Int vs smaller or more specific types.<br>&gt; <br>&gt; True, and it will always be that way AFAICT.  And again this seems like a completely separate issue.<br></p><p>I don’t know if it is an issue - it may very well be an explicit design goal to reduce decisions around types. I say that it *may* be an explicit design goal, because some of the cases cited may indeed be the result of the featureset of the current language.<br></p><p>I can’t say if the push toward using Int for everything would be lessened with an updated numerics system, or if operations like map return arrays rather than a new sequence because of current limitations in the generics system - I simply don’t know.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/f4b10737/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January  1, 2016 at 12:00:00am</p></header><div class="content"><p>On Thu, Dec 31, 2015 at 9:17 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; - Array has additional mutating methods which are not described by<br>&gt; CollectionType or any other protocol. The ease of getting a new copy of an<br>&gt; array and mutating it means code needing the ability to append (for<br>&gt; instance) today will be declared using an explicit Array type. If this was<br>&gt; desired to be fixed, it would require more protocols<br>&gt; (ModifiableCollectionType?)<br>&gt;<br>&gt;<br>There is a protocol, RangeReplaceableCollectionType.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/047c6e77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 31, 2015 at 07:00:00pm</p></header><div class="content"><p>Interesting! I never saw any collections outside of the String views implement that, probably because the swift standard library docs don’t publish underscore-prefixed protocols.<br></p><p>-DW<br></p><p>&gt; On Dec 31, 2015, at 3:34 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 31, 2015 at 9:17 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; - Array has additional mutating methods which are not described by CollectionType or any other protocol. The ease of getting a new copy of an array and mutating it means code needing the ability to append (for instance) today will be declared using an explicit Array type. If this was desired to be fixed, it would require more protocols (ModifiableCollectionType?)<br>&gt; <br>&gt; There is a protocol, RangeReplaceableCollectionType.<br>&gt; <br>&gt; Dmitri <br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/8eace8c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] Add AssociativeCollectionType to represent Dictionary-type relationships (was: Add an (Index, Element) sequence to CollectionType)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 6:09 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Interesting! I never saw any collections outside of the String views implement that, probably because the swift standard library docs don’t publish underscore-prefixed protocols.<br></p><p>The Array types all implement it.<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 3:34 PM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 31, 2015 at 9:17 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - Array has additional mutating methods which are not described by CollectionType or any other protocol. The ease of getting a new copy of an array and mutating it means code needing the ability to append (for instance) today will be declared using an explicit Array type. If this was desired to be fixed, it would require more protocols (ModifiableCollectionType?)<br>&gt;&gt; <br>&gt;&gt; There is a protocol, RangeReplaceableCollectionType.<br>&gt;&gt; <br>&gt;&gt; Dmitri <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/2679f6cf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] Add an (Index, Element) sequence to CollectionType</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 8:06 AM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe that the current behavior was thought when Slices had indices starting with zero.<br></p><p>The current behavior was intentional (and intentionally left as-is when array slices changed); indices are not integers for all collections, and there are many ways to get the indices with the elements, including zip(x.indices, x)<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/fcb30727/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
