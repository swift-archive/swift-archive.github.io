<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 24, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Feb 24 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 22, 2016, at 11:02 AM, Jordan Rose via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In case it&#39;s been lost in all the discussion, the -ing/-ed rule is<br>&gt;&gt; essentially the rule Objective-C uses, minus the noun labels for the<br>&gt;&gt; return value and types and the word &quot;by&quot;. It&#39;s definitely very<br>&gt;&gt; different grammatically from most other API guidelines, but so are<br>&gt;&gt; Objective-C&#39;s guidelines.<br>&gt;&gt; <br>&gt;<br>&gt; Sure, but I&#39;d actually argue that the noun-labels in ObjC are what<br>&gt; actually provide the context of the non-mutating nature of the<br>&gt; function. <br></p><p>I disagree with that assertion.  The nouns tell you what type is going<br>to be returned and what type is being passed, not whether there will be<br>mutation to the receiver.<br></p><p>&gt; The -ed/-ing suffixes are a by-product of the preceding noun-phrase<br>&gt; and/or trailing preposition.<br>&gt;<br>&gt; stringByTrimmingCharactersInSet(_:)<br>&gt;<br>&gt; We are taking information about the returned data out of the function<br>&gt; name and assuming that the return type makes up for it.<br></p><p>The return type and context, yes.  <br>&gt; trimming(_:)<br>&gt;<br>&gt; For a string-type, that may be ok, but I&#39;d argue that `trimming` is<br>&gt; significantly more ambiguous that the ObjC version. There is no<br>&gt; reasonable assumption that `stringByTrimmingCharactersInSet` would<br>&gt; ever mutate the caller. However, `trimming` carries no such<br>&gt; implication _unless_ you are well versed in the API guidelines, <br></p><p>I disagree with that assertion.  We didn&#39;t invent that usage out of thin<br>air; it&#39;s based on regular English usage.  Neither of these names really<br>directly addresses mutation at all; to do that you&#39;d have to append<br>&quot;WithoutChangingSelf&quot; or something.<br></p><p>It seems like you may (quite reasonably) associate having a return value<br>with being non-mutating, and you may be making the conclusion that<br>removing information about the return type removes any implication that<br>there *is* a returned value.  But there are still lots of clues left<br>about that:<br></p><p>* the call forms a noun phrase, therefore must be non-side-effectful, so<br>  to be useful must return something.<br>* unused result warnings ensure that the fact that it returns a value is<br>  quite visible at the call site.<br></p><p>&gt; and even then, I&#39;d still argue that your confidence level between the<br>&gt; two versions is not equal.<br></p><p>I understand that you may be less confident with APIs written according<br>to the new guidelines.<br></p><p>&gt; A counter example for -ing usage: if we have a streaming-type and<br>&gt; `trimming` is actually the process for continually removing those<br>&gt; characters from the stream. The likely implementation of this is going<br>&gt; to be a mutating function that fires events, or maybe it&#39;s a<br>&gt; promise-like API that wraps the event handling differently. The<br>&gt; corollary is that `trim` would actually be the one that produces no<br>&gt; side-effects as it would be able to give a snapshot of the current<br>&gt; state of a trimmed stream.<br></p><p>I don&#39;t believe this is actually a confusable scenario; please show us<br>what that code looks like.<br></p><p>&gt; I think we are opening ourselves up to the potential of many confusing<br>&gt; APIs when an -ed/-ing form of a function name is an appropriate<br>&gt; candidate with the opposite meaning that the guidelines set out.<br>&gt;<br>&gt; The -ed/-ing suffix choice doesn&#39;t seem outright bad, but it does seem<br>&gt; to be &quot;death by paper cuts&quot; bad, at least to me. The guidelines are<br>&gt; already a bit complicated in this area. Also, like others, I find the<br>&gt; -ing suffix to imply a state of work to be done that will be completed<br>&gt; later or cover an extended amount of time; mutation has no bearing on<br>&gt; the implementation choice here.<br>&gt;<br>&gt; Side note: the guidelines are also unintentionally narrow: &quot;Use the<br>&gt; “ed/ing” rule to name the nonmutating counterpart of a mutating<br>&gt; method.&quot;<br>&gt;<br>&gt; We should *always* be following this pattern regardless of the<br>&gt; existence of a nonmutating counterpart. Otherwise, if you implement<br>&gt; just a non-mutating function for sorting without the counterpart, you<br>&gt; need to use a noun-phrase, like `sortBy`. Then if you later add a<br>&gt; mutating version, you need to rename the `sortBy` to `sorted`. That<br>&gt; seems like the wrong outcome of the guidelines.<br></p><p>I think you&#39;re confused: `sortBy(x)`—or more properly, `sort(by:<br>x)`—isn&#39;t a noun-phrase; it&#39;s an imperative verb phrase, so it would be<br>an ineligible form for a nonmutating method call.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 24, 2016, at 11:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Feb 24 2016, David Owens II &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 22, 2016, at 11:02 AM, Jordan Rose via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In case it&#39;s been lost in all the discussion, the -ing/-ed rule is<br>&gt;&gt;&gt; essentially the rule Objective-C uses, minus the noun labels for the<br>&gt;&gt;&gt; return value and types and the word &quot;by&quot;. It&#39;s definitely very<br>&gt;&gt;&gt; different grammatically from most other API guidelines, but so are<br>&gt;&gt;&gt; Objective-C&#39;s guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sure, but I&#39;d actually argue that the noun-labels in ObjC are what<br>&gt;&gt; actually provide the context of the non-mutating nature of the<br>&gt;&gt; function. <br>&gt; <br>&gt; I disagree with that assertion.  The nouns tell you what type is going<br>&gt; to be returned and what type is being passed, not whether there will be<br>&gt; mutation to the receiver.<br></p><p>For the Cocoa value types, I agree with DavidO that a return-type noun reliably distinguishes mutation from non-mutation, and is a better-than-50% indicator for methods on other types as well. This is part of the established Cocoa convention and is (sort of) called out &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-1001751-BCIJHEDH&gt; in the existing (sparse) naming guidelines.<br></p><p>However, I don&#39;t think that&#39;s that much less subtle than the -ing ending. It&#39;s a different cue but not one that&#39;s really any more or less noticeable. (Evidence: DaveA did not know it or infer it despite driving this effort, i.e. getting plenty of exposure to many different APIs.)<br></p><p>(The participle ending for nullary methods or properties may be a little more subtle, especially for non-English speakers..)<br></p><p>&gt;&gt; A counter example for -ing usage: if we have a streaming-type and `trimming` is actually the process for continually removing those characters from the stream. The likely implementation of this is going to be a mutating function that fires events, or maybe it&#39;s a promise-like API that wraps the event handling differently. The corollary is that `trim` would actually be the one that produces no side-effects as it would be able to give a snapshot of the current state of a trimmed stream.<br></p><p>I can&#39;t actually picture this API. &#39;trimming&#39; and &#39;trim&#39; don&#39;t seem to follow the naming conventions for the operations you&#39;ve described. Can you write it out?<br></p><p>&gt;&gt; Side note: the guidelines are also unintentionally narrow: &quot;Use the “ed/ing” rule to name the nonmutating counterpart of a mutating method.&quot;<br>&gt;&gt; <br>&gt;&gt; We should *always* be following this pattern regardless of the existence of a nonmutating counterpart. Otherwise, if you implement just a non-mutating function for sorting without the counterpart, you need to use a noun-phrase, like `sortBy`. Then if you later add a mutating version, you need to rename the `sortBy` to `sorted`. That seems like the wrong outcome of the guidelines.<br></p><p>This I definitely agree with. If you have a non-mutating member that returns the same type as the receiver, it should be named as if there could be an in-place version added later.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/98151c03/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>API Guidelines Update</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 24, 2016, at 11:25 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Feb 24 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 22, 2016, at 11:02 AM, Jordan Rose via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In case it&#39;s been lost in all the discussion, the -ing/-ed rule is<br>&gt;&gt;&gt; essentially the rule Objective-C uses, minus the noun labels for the<br>&gt;&gt;&gt; return value and types and the word &quot;by&quot;. It&#39;s definitely very<br>&gt;&gt;&gt; different grammatically from most other API guidelines, but so are<br>&gt;&gt;&gt; Objective-C&#39;s guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sure, but I&#39;d actually argue that the noun-labels in ObjC are what<br>&gt;&gt; actually provide the context of the non-mutating nature of the<br>&gt;&gt; function. <br>&gt; <br>&gt; I disagree with that assertion.  The nouns tell you what type is going<br>&gt; to be returned and what type is being passed, not whether there will be<br>&gt; mutation to the receiver.<br></p><p>The noun tells you the object that will be worked with.<br></p><p>`stringByTrimmingCharactersInSet(_:)` - return a string by trimming characters in set<br></p><p>`trimCharactersInSet(_:)`, `trim(_:)`, and `trimming(_:)` all read: return myself by trimming characters in set; there is no noun, so it is implied that it&#39;s the caller of the function.<br></p><p>The first two guidelines already captures this sentiment as well:<br></p><p>  1. &quot;Those without side-effects should read as noun phrases&quot;.<br>  2. &quot;Those with side-effects should read as imperative verb phrases.&quot;<br></p><p>&gt;&gt; I think we are opening ourselves up to the potential of many confusing<br>&gt;&gt; APIs when an -ed/-ing form of a function name is an appropriate<br>&gt;&gt; candidate with the opposite meaning that the guidelines set out.<br>&gt;&gt; <br>&gt;&gt; The -ed/-ing suffix choice doesn&#39;t seem outright bad, but it does seem<br>&gt;&gt; to be &quot;death by paper cuts&quot; bad, at least to me. The guidelines are<br>&gt;&gt; already a bit complicated in this area. Also, like others, I find the<br>&gt;&gt; -ing suffix to imply a state of work to be done that will be completed<br>&gt;&gt; later or cover an extended amount of time; mutation has no bearing on<br>&gt;&gt; the implementation choice here.<br>&gt;&gt; <br>&gt;&gt; Side note: the guidelines are also unintentionally narrow: &quot;Use the<br>&gt;&gt; “ed/ing” rule to name the nonmutating counterpart of a mutating<br>&gt;&gt; method.&quot;<br>&gt;&gt; <br>&gt;&gt; We should *always* be following this pattern regardless of the<br>&gt;&gt; existence of a nonmutating counterpart. Otherwise, if you implement<br>&gt;&gt; just a non-mutating function for sorting without the counterpart, you<br>&gt;&gt; need to use a noun-phrase, like `sortBy`. Then if you later add a<br>&gt;&gt; mutating version, you need to rename the `sortBy` to `sorted`. That<br>&gt;&gt; seems like the wrong outcome of the guidelines.<br>&gt; <br>&gt; I think you&#39;re confused: `sortBy(x)`—or more properly, `sort(by:<br>&gt; x)`—isn&#39;t a noun-phrase; it&#39;s an imperative verb phrase, so it would be<br>&gt; an ineligible form for a nonmutating method call.<br></p><p>I think you threw out the baby with the bathwater because of a technicality there. Let&#39;s try again.<br></p><p>The stages of an API development process might look like this:<br></p><p>version 1: &quot;Those without side-effects should read as noun phrases&quot;<br></p><p>func contentsOf(filter:) -&gt; Self  // returns a copy<br></p><p>version 2: &quot;Those with side-effects should read as imperative verb phrases&quot;<br></p><p>func contentsOf(filter:) -&gt; Self  // returns a copy<br>mutating func filter(by:)         // honestly, I&#39;m not sure where the preposition debate has landed...<br></p><p>version 3, bug comes in that the API doesn&#39;t meet the guidelines.<br></p><p>func filtered(by:) -&gt; Self  // returns a copy<br>mutating func filter(by:)<br></p><p>Unless I&#39;m misunderstanding the guidelines, this is the natural progression of the API (minus the `by` preposition, which is irrelevant to this discussion). <br></p><p>In my opinion, the guidelines should not lead us down breaking API changes as the API evolves. The entire -ed/-ing confuses the entire section, and requires future knowledge of what the future API will look like beforehand. This circles back to my first point about the noun actually serving as more information that the type.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/3ef69fac/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
