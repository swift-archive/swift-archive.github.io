<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I find that optional protocol methods to be very useful. However,<br>&gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt; does not map to objective-c. What do you think about removing the<br>&gt; requirement of using @objc and allow to create optional methods<br>&gt; without these limitations?<br></p><p>Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>(no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>“optional requirement” is nonsensical to begin with, and the use of<br>optional protocol requirements encourages a style of programming that<br>lifts the responsibility of the protocol designer for careful design at<br>the expense of clients of the protocol.  There are better ways to do<br>things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>already gone.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0ca88ca6c43034ed39668bb10783618?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Yuval Tal</string> &lt;yuvalt at pblc.co&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>None taken. However, most of the delegate concept of UIKit relies heavily<br>on this &quot;nonsensical&quot; requirement. It is impossible for someone to<br>implement a control in swift which is &quot;in the spirit&quot; of UIKit, meaning the<br>control has a delegate, with several methods that share the same name with<br>different parameters, some are required and some are optional. I think it<br>is not fair to tell users that they cannot implement something that is such<br>a common and repeating pattern in the core.<br></p><p>On Thu, Mar 31, 2016 at 2:23 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I find that optional protocol methods to be very useful. However,<br>&gt; &gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt; &gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt; &gt; does not map to objective-c. What do you think about removing the<br>&gt; &gt; requirement of using @objc and allow to create optional methods<br>&gt; &gt; without these limitations?<br>&gt;<br>&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt; optional protocol requirements encourages a style of programming that<br>&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt; already gone.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/befc3f21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>This shouldn&#39;t be an issue in practice, though, since any UIKit control subclass has to inherit from NSObject anyways, which means they can always conform to any @objc protocol.<br></p><p>The main utility of removing the @objc requirement for optional protocol requirements would to allow their use in Swift code oriented away from Cocoa/Foundation, which is part of what Dave is objecting to.<br></p><p>Austin<br></p><p>&gt; On Mar 31, 2016, at 11:49 AM, Yuval Tal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; None taken. However, most of the delegate concept of UIKit relies heavily on this &quot;nonsensical&quot; requirement. It is impossible for someone to implement a control in swift which is &quot;in the spirit&quot; of UIKit, meaning the control has a delegate, with several methods that share the same name with different parameters, some are required and some are optional. I think it is not fair to tell users that they cannot implement something that is such a common and repeating pattern in the core. <br>&gt; <br>&gt; On Thu, Mar 31, 2016 at 2:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I find that optional protocol methods to be very useful. However,<br>&gt; &gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt; &gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt; &gt; does not map to objective-c. What do you think about removing the<br>&gt; &gt; requirement of using @objc and allow to create optional methods<br>&gt; &gt; without these limitations?<br>&gt; <br>&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt; optional protocol requirements encourages a style of programming that<br>&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt; already gone.<br>&gt; <br>&gt; --<br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/74d81dde/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>To be fair, the &quot;spirit of UIKit&quot; that you mention comes from a time and language that encouraged OO and OO alone.  Optional methods are, more often than not, backed by gigantic bit fields that keep track of whether or not the delegate actually conforms to the entirety of a protocol, which opens up a huge vector for bugs and complicates the internal logic of the control.  I think Swift gives us a better opportunity to rethink the old approach not encourage it, don&#39;t you think?<br></p><p>For example, using a method returning an optional (or even better, a proper value) means you can give a proper semantics for what it means to not implement a particular method rather than &quot;no selector here&quot;.  <br></p><p>~Robert Widmann<br></p><p>2016/03/31 14:49、Yuval Tal via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; None taken. However, most of the delegate concept of UIKit relies heavily on this &quot;nonsensical&quot; requirement. It is impossible for someone to implement a control in swift which is &quot;in the spirit&quot; of UIKit, meaning the control has a delegate, with several methods that share the same name with different parameters, some are required and some are optional. I think it is not fair to tell users that they cannot implement something that is such a common and repeating pattern in the core. <br>&gt; <br>&gt;&gt; On Thu, Mar 31, 2016 at 2:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I find that optional protocol methods to be very useful. However,<br>&gt;&gt; &gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt;&gt; &gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt;&gt; &gt; does not map to objective-c. What do you think about removing the<br>&gt;&gt; &gt; requirement of using @objc and allow to create optional methods<br>&gt;&gt; &gt; without these limitations?<br>&gt;&gt; <br>&gt;&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt;&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt;&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt;&gt; optional protocol requirements encourages a style of programming that<br>&gt;&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt;&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt;&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt;&gt; already gone.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/867e10be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 31, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 11:49 AM, Yuval Tal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; None taken. However, most of the delegate concept of UIKit relies heavily on this &quot;nonsensical&quot; requirement. It is impossible for someone to implement a control in swift which is &quot;in the spirit&quot; of UIKit, meaning the control has a delegate, with several methods that share the same name with different parameters, some are required and some are optional. I think it is not fair to tell users that they cannot implement something that is such a common and repeating pattern in the core. <br></p><p>Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br></p><p>-Chris<br></p><p>&gt; <br>&gt; On Thu, Mar 31, 2016 at 2:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I find that optional protocol methods to be very useful. However,<br>&gt; &gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt; &gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt; &gt; does not map to objective-c. What do you think about removing the<br>&gt; &gt; requirement of using @objc and allow to create optional methods<br>&gt; &gt; without these limitations?<br>&gt; <br>&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt; optional protocol requirements encourages a style of programming that<br>&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt; already gone.<br>&gt; <br>&gt; --<br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/1c474316/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>March 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 31 mars 2016, at 22:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br></p><p>They do, but that is not clear for everyone. And after protocol extensions appeared with 2.0, it took a little while to make that leap...<br></p><p>Documentation-wise, maybe the current “Optional Protocol Requirements” section should be moved from “The Swift Programming Language” to “Using Swift with Cocoa and Objective-C”. It would make it clearer that the feature exists for Objective-C interop. At the very least, moving that section to after the “Protocol Extensions&quot; section would at least present the more important feature first.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; None taken. However, most of the delegate concept of UIKit relies heavily on this &quot;nonsensical&quot; requirement. It is impossible for someone to implement a control in swift which is &quot;in the spirit&quot; of UIKit, meaning the control has a delegate, with several methods that share the same name with different parameters, some are required and some are optional. I think it is not fair to tell users that they cannot implement something that is such a common and repeating pattern in the core. <br>&gt; <br>&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt; <br>&gt; -Chris<br></p><p>I agree that’s the case, but what happens for situations like UIKit where I do not have access to the source? If there is a protocol extension for, say, UITableViewDelegate that implements default behaviors, that extension’s existence might be publicly declared somewhere so I could know, but the implementation bodies would not be, correct? So as a user of UITableViewDelegate and without access to UIKit’s source code, I cannot examine the protocol extension to see what the extension is *actually* doing by default. The situation is then no better than it is now where the information about the default behavior or result of a missing delegate function is buried somewhere in the documentation. If the protocol spec itself included the “effective” default and there was no way to provide a default implementation that did anything *except* return a value (or do nothing), then the protocol declaration itself documents the intent and I, as an external user of UITableViewDelegate without access to the source code, could see exactly what it does.<br></p><p>Perhaps my understanding/reasoning there is flawed, but that&#39;s why I continue to suggest something like this:<br></p><p>protocol MyProtocol {<br>  default func semiOptionalFunctionA() -&gt; Int = 42  // if unspecified, compiler generates implementation that returns 42<br>  default func semiOptionalFunctionB(thing: Int)   // if unspecified, compiler generates implementation that does nothing<br>  func normalRequiredFunction()   // requires an implementation by the user<br>}<br></p><p>l8r<br>Sean<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br></p><p>Kind of. If I may steelman* optional members for a moment...<br></p><p>In cases where a default implementation would do, the default implementation will usually also be the behavior you want for a nil instance, but there&#39;s no convenient way to share logic between the two. For example, consider this:<br></p><p>	protocol UITableViewDelegate {<br>		...<br>		func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat<br>	}<br>	extension UITableViewDelegate {<br>		func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {<br>			return tableView.rowHeight<br>		}<br>	}<br>	<br>	class UITableView {<br>		...<br>		private func addRow(at indexPath: NSIndexPath) {<br>			...<br>			cell.size.height = delegate?.tableView(self, heightForRowAtIndexPath: indexPath) ?? rowHeight<br>			...<br>		}<br>		...<br></p><p>You have to duplicate the default logic both in the default implementation and at the call site, but there is no convenient way to share it—the extension method can&#39;t call into an expression at some call site, and contrarily the call site can&#39;t invoke the default logic from the extension.<br></p><p>If the method were optional, then optional chaining would solve this problem for us:<br></p><p>	protocol UITableViewDelegate {<br>		...<br>		optional func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat<br>	}<br>	<br>	class UITableView {<br>		...<br>		private func addRow(at indexPath: NSIndexPath) {<br>			...<br>			cell.size.height = delegate?.tableView?(self, heightForRowAtIndexPath: indexPath) ?? rowHeight<br>			...<br>		}<br>		...<br></p><p>This way, there is only one source of default behavior: the call site.<br></p><p>I&#39;m also concerned by the thought of just how many sub-protocols we might end up with. When I try to fully factor NSTableViewDelegate (as it currently exists in the headers), I end up with ten protocols:<br></p><p>	NSTableViewDelegate<br>		- tableView:willDisplayCell:forTableColumn:row:<br></p><p>	NSTableViewLayoutDelegate: NSTableViewDelegate<br>		- tableView:heightOfRow:<br></p><p>	NSTableViewRowSelectionDelegate: NSTableViewDelegate<br>		- tableView:shouldSelectRow:<br>		- selectionShouldChangeInTableView:<br>		- tableViewSelectionIsChanging:<br>		- tableViewSelectionDidChange:<br>		- tableView:shouldTrackCell:forTableColumn:row: (10.5)<br>		- tableView:selectionIndexesForProposedSelection: (10.5)<br></p><p>	NSTableViewTypeSelectDelegate: NSTableViewDelegate (10.5)<br>		- tableView:typeSelectStringForTableColumn:row:<br>		- tableView:nextTypeSelectMatchFromRow:toRow:forString:<br>		- tableView:shouldTypeSelectForEvent:withCurrentSearchString:<br></p><p>	NSTableViewToolTipDelegate: NSTableViewDelegate<br>		- tableView:toolTipForCell:rect:tableColumn:row:mouseLocation:<br></p><p>	NSTableViewColumnDelegate: NSTableViewDelegate<br>		- tableView:shouldEditTableColumn:row:<br>		- tableView:shouldSelectTableColumn:<br>		- tableView:mouseDownInHeaderOfTableColumn:<br>		- tableView:didClickTableColumn:<br>		- tableView:didDragTableColumn:<br>		- tableViewColumnDidMove:<br>		- tableViewColumnDidResize:<br>		- tableView:sizeToFitWidthOfColumn: (10.6)<br>		- tableView:shouldReorderColumn:toColumn: (10.6)<br></p><p>	NSTableViewCellExpansionDelegate: NSTableViewDelegate (10.5)<br>		- tableView:shouldShowCellExpansionForTableColumn:row:<br>	<br>	NSTableViewCustomCellDelegate: NSTableViewDelegate (10.5)<br>		- tableView:dataCellForTableColumn:row:<br>		- tableView:isGroupRow:<br></p><p>	NSTableViewCellViewDelegate: NSTableViewDelegate (10.7)<br>		- tableView:viewForTableColumn:row:<br></p><p>	NSTableViewRowViewDelegate: NSTableViewDelegate (10.7)<br>		- tableView:rowViewForRow:<br>		- tableView:didAddRowView:forRow:<br>		- tableView:didRemoveRowView:forRow:<br>		- tableView:rowActionsForRow:edge: (10.11)<br></p><p>Some of these are probably unnecessary; they could be merged into NSTableViewDelegate and given default implementations. But at least a few of them would be very much needed. Would users be able to navigate this mess? Would they discover the features tucked away in sub-protocols? I&#39;m just not sure.<br></p><p>And of course the safety issues that make optional protocol members dangerous in Objective-C don&#39;t exist in Swift. Swift will force you to test for the presence of an optional member; you can&#39;t carelessly call one.<br></p><p>(Incidentally, resilience might also benefit from supporting optional protocol members and adding a `public(optional)` feature which made all call sites outside the resilience domain treat all members as optional. You could then mark protocols meant to be called only by clients inside the resilience domain—like data sources and delegates—with `public(optional)` and gain the ability to delete obsolete members.)<br></p><p><br></p><p>* Steelmanning is the opposite of strawmanning.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April  2, 2016 at 06:00:00am</p></header><div class="content"><p>-1<br>I hope that default implementations living in the protocol will address<br>this. I would even prefer to move in &#39;the other direction&#39; and have<br>optional methods on protocols come into swift as default implementations.<br>TJ<br></p><p>On Sat, Apr 2, 2016 at 6:07 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Protocol requirements with default (no-op) implementations already<br>&gt; satisfy that design goal, no?<br>&gt;<br>&gt; Kind of. If I may steelman* optional members for a moment...<br>&gt;<br>&gt; In cases where a default implementation would do, the default<br>&gt; implementation will usually also be the behavior you want for a nil<br>&gt; instance, but there&#39;s no convenient way to share logic between the two. For<br>&gt; example, consider this:<br>&gt;<br>&gt;         protocol UITableViewDelegate {<br>&gt;                 ...<br>&gt;                 func tableView(_ tableView: UITableView,<br>&gt; heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat<br>&gt;         }<br>&gt;         extension UITableViewDelegate {<br>&gt;                 func tableView(_ tableView: UITableView,<br>&gt; heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {<br>&gt;                         return tableView.rowHeight<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         class UITableView {<br>&gt;                 ...<br>&gt;                 private func addRow(at indexPath: NSIndexPath) {<br>&gt;                         ...<br>&gt;                         cell.size.height = delegate?.tableView(self,<br>&gt; heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt;                         ...<br>&gt;                 }<br>&gt;                 ...<br>&gt;<br>&gt; You have to duplicate the default logic both in the default implementation<br>&gt; and at the call site, but there is no convenient way to share it—the<br>&gt; extension method can&#39;t call into an expression at some call site, and<br>&gt; contrarily the call site can&#39;t invoke the default logic from the extension.<br>&gt;<br>&gt; If the method were optional, then optional chaining would solve this<br>&gt; problem for us:<br>&gt;<br>&gt;         protocol UITableViewDelegate {<br>&gt;                 ...<br>&gt;                 optional func tableView(_ tableView: UITableView,<br>&gt; heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat<br>&gt;         }<br>&gt;<br>&gt;         class UITableView {<br>&gt;                 ...<br>&gt;                 private func addRow(at indexPath: NSIndexPath) {<br>&gt;                         ...<br>&gt;                         cell.size.height = delegate?.tableView?(self,<br>&gt; heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt;                         ...<br>&gt;                 }<br>&gt;                 ...<br>&gt;<br>&gt; This way, there is only one source of default behavior: the call site.<br>&gt;<br>&gt; I&#39;m also concerned by the thought of just how many sub-protocols we might<br>&gt; end up with. When I try to fully factor NSTableViewDelegate (as it<br>&gt; currently exists in the headers), I end up with ten protocols:<br>&gt;<br>&gt;         NSTableViewDelegate<br>&gt;                 - tableView:willDisplayCell:forTableColumn:row:<br>&gt;<br>&gt;         NSTableViewLayoutDelegate: NSTableViewDelegate<br>&gt;                 - tableView:heightOfRow:<br>&gt;<br>&gt;         NSTableViewRowSelectionDelegate: NSTableViewDelegate<br>&gt;                 - tableView:shouldSelectRow:<br>&gt;                 - selectionShouldChangeInTableView:<br>&gt;                 - tableViewSelectionIsChanging:<br>&gt;                 - tableViewSelectionDidChange:<br>&gt;                 - tableView:shouldTrackCell:forTableColumn:row: (10.5)<br>&gt;                 - tableView:selectionIndexesForProposedSelection: (10.5)<br>&gt;<br>&gt;         NSTableViewTypeSelectDelegate: NSTableViewDelegate (10.5)<br>&gt;                 - tableView:typeSelectStringForTableColumn:row:<br>&gt;                 - tableView:nextTypeSelectMatchFromRow:toRow:forString:<br>&gt;                 -<br>&gt; tableView:shouldTypeSelectForEvent:withCurrentSearchString:<br>&gt;<br>&gt;         NSTableViewToolTipDelegate: NSTableViewDelegate<br>&gt;                 -<br>&gt; tableView:toolTipForCell:rect:tableColumn:row:mouseLocation:<br>&gt;<br>&gt;         NSTableViewColumnDelegate: NSTableViewDelegate<br>&gt;                 - tableView:shouldEditTableColumn:row:<br>&gt;                 - tableView:shouldSelectTableColumn:<br>&gt;                 - tableView:mouseDownInHeaderOfTableColumn:<br>&gt;                 - tableView:didClickTableColumn:<br>&gt;                 - tableView:didDragTableColumn:<br>&gt;                 - tableViewColumnDidMove:<br>&gt;                 - tableViewColumnDidResize:<br>&gt;                 - tableView:sizeToFitWidthOfColumn: (10.6)<br>&gt;                 - tableView:shouldReorderColumn:toColumn: (10.6)<br>&gt;<br>&gt;         NSTableViewCellExpansionDelegate: NSTableViewDelegate (10.5)<br>&gt;                 - tableView:shouldShowCellExpansionForTableColumn:row:<br>&gt;<br>&gt;         NSTableViewCustomCellDelegate: NSTableViewDelegate (10.5)<br>&gt;                 - tableView:dataCellForTableColumn:row:<br>&gt;                 - tableView:isGroupRow:<br>&gt;<br>&gt;         NSTableViewCellViewDelegate: NSTableViewDelegate (10.7)<br>&gt;                 - tableView:viewForTableColumn:row:<br>&gt;<br>&gt;         NSTableViewRowViewDelegate: NSTableViewDelegate (10.7)<br>&gt;                 - tableView:rowViewForRow:<br>&gt;                 - tableView:didAddRowView:forRow:<br>&gt;                 - tableView:didRemoveRowView:forRow:<br>&gt;                 - tableView:rowActionsForRow:edge: (10.11)<br>&gt;<br>&gt; Some of these are probably unnecessary; they could be merged into<br>&gt; NSTableViewDelegate and given default implementations. But at least a few<br>&gt; of them would be very much needed. Would users be able to navigate this<br>&gt; mess? Would they discover the features tucked away in sub-protocols? I&#39;m<br>&gt; just not sure.<br>&gt;<br>&gt; And of course the safety issues that make optional protocol members<br>&gt; dangerous in Objective-C don&#39;t exist in Swift. Swift will force you to test<br>&gt; for the presence of an optional member; you can&#39;t carelessly call one.<br>&gt;<br>&gt; (Incidentally, resilience might also benefit from supporting optional<br>&gt; protocol members and adding a `public(optional)` feature which made all<br>&gt; call sites outside the resilience domain treat all members as optional. You<br>&gt; could then mark protocols meant to be called only by clients inside the<br>&gt; resilience domain—like data sources and delegates—with `public(optional)`<br>&gt; and gain the ability to delete obsolete members.)<br>&gt;<br>&gt;<br>&gt;<br>&gt; * Steelmanning is the opposite of strawmanning.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/eb37e291/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>April  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;<br>&gt;<br>&gt;         class UITableView {<br>&gt;                 ...<br>&gt;                 private func addRow(at indexPath: NSIndexPath) {<br>&gt;                         ...<br>&gt;                         cell.size.height = delegate?.tableView(self,<br>&gt; heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt;                         ...<br>&gt;                 }<br>&gt;                 ...<br>&gt;<br></p><p>You need not duplicate the default logic:<br></p><p><br>private class DefaultDelegate: NSObject, UITableViewDelegate { }<br>private let defaultDelegate = DefaultDelegate()<br></p><p>public class UITableView {<br></p><p>    private func addRow(at indexPath: NSIndexPath) {<br>        ...<br>        cell.size.height = (delegate ?? defaultDelegate).tableView(self,<br>heightForRowAtIndexPath: indexPath)<br>        ...<br>    }<br></p><p>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/e7f883b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>April  1, 2016 at 06:00:00pm</p></header><div class="content"><p>That’s an interesting idea. Although I still do not like the fact that the Swift model forces me to split up the implementation between the delegating type and the delegate whereas the ObjC model allows me to keep the default and non-default implementation in a single place, namely the type.<br></p><p>There are some additional questions that I think have not received a satisfactory answer yet:<br></p><p>a) the ObjC model makes it straight forward to ADD new functionality to a delegate without breaking existing apps. Eg the tableView(heightForRowAtIndexPath:) method was added in Mac OS X 10.4. Before that the NSTableView did not support variable row heights. The only change to the API that Apple had to introduce in order to allow apps to create tables with variable row heights was this one optional delegate method. App implements it -&gt; table view stores a per-row height; app does not implement it -&gt; table view uses a fixed row height which is set as a property on the table. And so existing apps would continue to run with the new AppKit version just fine.<br></p><p>How would this work in the Swift model?<br></p><p><br>b) the ObjC model allows for significant and in some cases important optimizations:<br></p><p>b1) NSTableView support fixed and variable row heights. Layout can be much simpler for fixed row heights and there is no need to store the per-row height in an internal cache. In the ObjC model the table view has an efficient means to detect whether the delegate wants fixed or variable row heights since all it needs to do is check whether the tableView(heightForRowAtIndexPath:) is implemented. If it is -&gt; call it for every row and cache the row height and enable the variable row height layout code; otherwise -&gt; do not cache per row heights and enable the fixed row height layout code. Note that the code that does the actual heavy duty work (the layout code) may be far remove from the code that calls the tableView(heightForRowAtIndexPath:) method. In the Swift model though, we would have to invoke the tableView(heightForRowAtIndexPath:) for every row and compare the return results before we could even decide if the delegate wants variable or fixed row heights.<br></p><p>b2) the ObjC model allows me to get the implementation of the optional delegate method which in turn allows me to completely remove dynamic dispatch from the performance critical path.<br></p><p>How would these things work in the Swift model?<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p><br>&gt; On Apr 1, 2016, at 18:20, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;         class UITableView {<br>&gt;                 ...<br>&gt;                 private func addRow(at indexPath: NSIndexPath) {<br>&gt;                         ...<br>&gt;                         cell.size.height = delegate?.tableView(self, heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt;                         ...<br>&gt;                 }<br>&gt;                 ...<br>&gt; <br>&gt; You need not duplicate the default logic:<br>&gt; <br>&gt; private class DefaultDelegate: NSObject, UITableViewDelegate { }<br>&gt; private let defaultDelegate = DefaultDelegate()<br>&gt; <br>&gt; public class UITableView {<br>&gt; <br>&gt;     private func addRow(at indexPath: NSIndexPath) {<br>&gt;         ...<br>&gt;         cell.size.height = (delegate ?? defaultDelegate).tableView(self, heightForRowAtIndexPath: indexPath)<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April  2, 2016 at 07:00:00am</p></header><div class="content"><p>Very good points Dietmar, but there is one more bit about default implementations in extensions that makes it worse to use than the old Objective-C model... the complex dispatch rules that can make the executed method type dependent and not instance dependent. We really need dynamic dispatch there to make it work.<br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 2 Apr 2016, at 02:50, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That’s an interesting idea. Although I still do not like the fact that the Swift model forces me to split up the implementation between the delegating type and the delegate whereas the ObjC model allows me to keep the default and non-default implementation in a single place, namely the type.<br>&gt; <br>&gt; There are some additional questions that I think have not received a satisfactory answer yet:<br>&gt; <br>&gt; a) the ObjC model makes it straight forward to ADD new functionality to a delegate without breaking existing apps. Eg the tableView(heightForRowAtIndexPath:) method was added in Mac OS X 10.4. Before that the NSTableView did not support variable row heights. The only change to the API that Apple had to introduce in order to allow apps to create tables with variable row heights was this one optional delegate method. App implements it -&gt; table view stores a per-row height; app does not implement it -&gt; table view uses a fixed row height which is set as a property on the table. And so existing apps would continue to run with the new AppKit version just fine.<br>&gt; <br>&gt; How would this work in the Swift model?<br>&gt; <br>&gt; <br>&gt; b) the ObjC model allows for significant and in some cases important optimizations:<br>&gt; <br>&gt; b1) NSTableView support fixed and variable row heights. Layout can be much simpler for fixed row heights and there is no need to store the per-row height in an internal cache. In the ObjC model the table view has an efficient means to detect whether the delegate wants fixed or variable row heights since all it needs to do is check whether the tableView(heightForRowAtIndexPath:) is implemented. If it is -&gt; call it for every row and cache the row height and enable the variable row height layout code; otherwise -&gt; do not cache per row heights and enable the fixed row height layout code. Note that the code that does the actual heavy duty work (the layout code) may be far remove from the code that calls the tableView(heightForRowAtIndexPath:) method. In the Swift model though, we would have to invoke the tableView(heightForRowAtIndexPath:) for every row and compare the return results before we could even decide if the delegate wants variable or fixed row heights.<br>&gt; <br>&gt; b2) the ObjC model allows me to get the implementation of the optional delegate method which in turn allows me to completely remove dynamic dispatch from the performance critical path.<br>&gt; <br>&gt; How would these things work in the Swift model?<br>&gt; <br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; Dietmar Planitzer<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 1, 2016, at 18:20, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        class UITableView {<br>&gt;&gt;                ...<br>&gt;&gt;                private func addRow(at indexPath: NSIndexPath) {<br>&gt;&gt;                        ...<br>&gt;&gt;                        cell.size.height = delegate?.tableView(self, heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt;&gt;                        ...<br>&gt;&gt;                }<br>&gt;&gt;                ...<br>&gt;&gt; <br>&gt;&gt; You need not duplicate the default logic:<br>&gt;&gt; <br>&gt;&gt; private class DefaultDelegate: NSObject, UITableViewDelegate { }<br>&gt;&gt; private let defaultDelegate = DefaultDelegate()<br>&gt;&gt; <br>&gt;&gt; public class UITableView {<br>&gt;&gt; <br>&gt;&gt;    private func addRow(at indexPath: NSIndexPath) {<br>&gt;&gt;        ...<br>&gt;&gt;        cell.size.height = (delegate ?? defaultDelegate).tableView(self, heightForRowAtIndexPath: indexPath)<br>&gt;&gt;        ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April  2, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 1, 2016, at 7:37 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt; <br>&gt; Kind of. If I may steelman* optional members for a moment…<br></p><p>I’d actually go a bit further: for at least *some* of the uses of optional protocol methods, default implementations are necessary but not sufficient; to really “Swift-ify” without *losing* functionality you also would need to do a much-more-involved redesign of the protocol methods.<br></p><p>As just one example, I *think* the following API sketch is *adequate* for a Swift-ified` `tableView:heightForRowAtIndexPath:`:<br></p><p>  /// Mocked-up, &quot;Swifty&quot; table-view-delegate protocol:<br>  protocol TableViewDelegate : class {<br></p><p>    /// Non-optional method, returning a &quot;policy&quot; enum that e.g. provides enough<br>    /// information to the table view to let it choose the appropriate layout strategy...<br>    func rowHeightPolicyForTableView(tableView: TableView) -&gt; TableViewRowHeightPolicy<br>    <br>  }<br></p><p>  /// “How to calculate height” information for an entire table view.<br>  enum TableViewRowHeightPolicy {<br>  <br>    /// all rows have identical height, table-view can operate in the &quot;fast&quot;<br>    /// mode, like setting `tableView.rowHeight = $someHeight` w/o delegate.<br>    case Uniform(CGFloat) <br>  <br>    /// table view should use auto-layout to measure each cell automatically;<br>    /// like `tableView.rowHeight = UITableViewAutomaticDimension` w/o delegate.<br>    case Automatic<br>  <br>    /// get per-row height info from `RowHeightCalculator`; equivalent to your<br>    /// having a delegate that implements `tableView:heightForRowAtIndexPath:`.<br>    case Manual(RowHeightCalculator)<br>    <br>  }<br>  <br>  /// A dedicated “row-height-calculator” protocol. On the one hand, this could<br>  /// also be &quot;just a closure&quot;, but promoting it into a protocol seems more <br>  /// future-proof (e.g. if additional calculation-options become supported later).<br>  ///<br>  /// Unfortunately, making this an object means having to think harder than<br>  /// before about ownership issues; this seems mildly thorny.<br>  protocol RowHeightCalculator : class {<br>  <br>    /// Returns the height-information for the given row; to *fully* recapture<br>    /// existing `UITableView` functionality we need to return more than `CGFloat`.<br>    func heightForRow(in tableView: UITableView, at indexPath: NSIndexPath) -&gt; RowHeight<br>  <br>  }<br>  <br>  /// Height-calculation result for a single row.<br>  enum RowHeight {<br>  <br>    /// Tells the table view to use auto-layout to measure this row&#39;s cell;<br>    /// equivalent to *returning* `UITableViewAutomaticDimension`.<br>    case Automatic <br>  <br>    /// Tells the table view to use the specified height for this row.<br>    case Height(CGFloat)<br>  <br>  }<br></p><p>…and at least AIUI that’s a complete representation of the various row-height-related behaviors it’s possible arrive-at, today, via various combinations of “did you implement `tableView:heightForRowAtIndexPath:` or not?” and/or “are you setting/returning `UITableViewAutomaticDimension`?.<br></p><p>Note also that this is just the behavior for row-heights; to fully-cover today’s user-exposed functionality, you’d need to handle header-heights and footer-heights (which have similar methods/semantics), and probably also the estimated-height methods for rows, headers, and footers.<br></p><p>Pausing here for a moment, I think the above illustrates why the topic keeps coming up: although it’s certainly *possible* to get to the same place w/out optional protocol methods, it sometimes takes a bit of a design rethink to get there. The API surface also seems to get quite a bit larger; I think it’s fair to classify this as simply “making already-present complexity actually-visible”, but it’d still be bit of a shift.<br></p><p>For the actual `tableView:heightForRowAtIndexPath:` family I’m not sure what I think; I personally like a more-explicit approach as per the above, but once you start to include the header-and-footer heights and also the estimated height APIs, it gets to be a bit much; more so when you think about how this API looks with similar approaches for other currently-optional method “suites&quot; (like highlight/selection management “suite&quot;, the menu/action “suite”, etc.).<br></p><p>To conclude, in many cases &quot;optional methods =&gt; methods w/ reasonable default implementation” is all you need, but in *some* cases you would also need to design your API very differently to have equivalent functionality. <br></p><p>I assume patterns and idioms for such designs will evolve over time, but at present there’s not a lot of Swift-ified datasource/delegate-style APIs out there to use for inspiration.<br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 1, 2016, at 5:37 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt; <br>&gt; Kind of. If I may steelman* optional members for a moment...<br>&gt; <br>&gt; In cases where a default implementation would do, the default implementation will usually also be the behavior you want for a nil instance, but there&#39;s no convenient way to share logic between the two. For example, consider this:<br>&gt; <br>&gt; 	protocol UITableViewDelegate {<br>&gt; 		...<br>&gt; 		func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat<br>&gt; 	}<br>&gt; 	extension UITableViewDelegate {<br>&gt; 		func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {<br>&gt; 			return tableView.rowHeight<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	class UITableView {<br>&gt; 		...<br>&gt; 		private func addRow(at indexPath: NSIndexPath) {<br>&gt; 			...<br>&gt; 			cell.size.height = delegate?.tableView(self, heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt; 			...<br>&gt; 		}<br>&gt; 		...<br>&gt; <br>&gt; You have to duplicate the default logic both in the default implementation and at the call site, but there is no convenient way to share it—the extension method can&#39;t call into an expression at some call site, and contrarily the call site can&#39;t invoke the default logic from the extension.<br></p><p>Interesting point.<br></p><p>&gt; <br>&gt; If the method were optional, then optional chaining would solve this problem for us:<br>&gt; <br>&gt; 	protocol UITableViewDelegate {<br>&gt; 		...<br>&gt; 		optional func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat<br>&gt; 	}<br>&gt; 	<br>&gt; 	class UITableView {<br>&gt; 		...<br>&gt; 		private func addRow(at indexPath: NSIndexPath) {<br>&gt; 			...<br>&gt; 			cell.size.height = delegate?.tableView?(self, heightForRowAtIndexPath: indexPath) ?? rowHeight<br>&gt; 			...<br>&gt; 		}<br>&gt; 		...<br>&gt; <br>&gt; This way, there is only one source of default behavior: the call site.<br></p><p>It’s “each&quot; call site, not “the” call site. If there are multiple call sites, we’d presumably want to factor out the default behavior computation anyway.<br></p><p>&gt; I&#39;m also concerned by the thought of just how many sub-protocols we might end up with. When I try to fully factor NSTableViewDelegate (as it currently exists in the headers), I end up with ten protocols:<br>&gt; <br>&gt; 	NSTableViewDelegate<br>&gt; 		- tableView:willDisplayCell:forTableColumn:row:<br>&gt; <br>&gt; 	NSTableViewLayoutDelegate: NSTableViewDelegate<br>&gt; 		- tableView:heightOfRow:<br>&gt; <br>&gt; 	NSTableViewRowSelectionDelegate: NSTableViewDelegate<br>&gt; 		- tableView:shouldSelectRow:<br>&gt; 		- selectionShouldChangeInTableView:<br>&gt; 		- tableViewSelectionIsChanging:<br>&gt; 		- tableViewSelectionDidChange:<br>&gt; 		- tableView:shouldTrackCell:forTableColumn:row: (10.5)<br>&gt; 		- tableView:selectionIndexesForProposedSelection: (10.5)<br>&gt; <br>&gt; 	NSTableViewTypeSelectDelegate: NSTableViewDelegate (10.5)<br>&gt; 		- tableView:typeSelectStringForTableColumn:row:<br>&gt; 		- tableView:nextTypeSelectMatchFromRow:toRow:forString:<br>&gt; 		- tableView:shouldTypeSelectForEvent:withCurrentSearchString:<br>&gt; <br>&gt; 	NSTableViewToolTipDelegate: NSTableViewDelegate<br>&gt; 		- tableView:toolTipForCell:rect:tableColumn:row:mouseLocation:<br>&gt; <br>&gt; 	NSTableViewColumnDelegate: NSTableViewDelegate<br>&gt; 		- tableView:shouldEditTableColumn:row:<br>&gt; 		- tableView:shouldSelectTableColumn:<br>&gt; 		- tableView:mouseDownInHeaderOfTableColumn:<br>&gt; 		- tableView:didClickTableColumn:<br>&gt; 		- tableView:didDragTableColumn:<br>&gt; 		- tableViewColumnDidMove:<br>&gt; 		- tableViewColumnDidResize:<br>&gt; 		- tableView:sizeToFitWidthOfColumn: (10.6)<br>&gt; 		- tableView:shouldReorderColumn:toColumn: (10.6)<br>&gt; <br>&gt; 	NSTableViewCellExpansionDelegate: NSTableViewDelegate (10.5)<br>&gt; 		- tableView:shouldShowCellExpansionForTableColumn:row:<br>&gt; 	<br>&gt; 	NSTableViewCustomCellDelegate: NSTableViewDelegate (10.5)<br>&gt; 		- tableView:dataCellForTableColumn:row:<br>&gt; 		- tableView:isGroupRow:<br>&gt; <br>&gt; 	NSTableViewCellViewDelegate: NSTableViewDelegate (10.7)<br>&gt; 		- tableView:viewForTableColumn:row:<br>&gt; <br>&gt; 	NSTableViewRowViewDelegate: NSTableViewDelegate (10.7)<br>&gt; 		- tableView:rowViewForRow:<br>&gt; 		- tableView:didAddRowView:forRow:<br>&gt; 		- tableView:didRemoveRowView:forRow:<br>&gt; 		- tableView:rowActionsForRow:edge: (10.11)<br>&gt; <br>&gt; Some of these are probably unnecessary; they could be merged into NSTableViewDelegate and given default implementations. But at least a few of them would be very much needed. Would users be able to navigate this mess? Would they discover the features tucked away in sub-protocols? I&#39;m just not sure.<br></p><p>This is what concerns me most. Delegate protocols tend to grow large over time (for good reason), and having a large family of related protocols is hard to navigate.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br></p><p>Chris, as we&#39;ve discussed in a thread that I think got forked from this one:<br></p><p>Yes, they do technically, but it would be nice to both:<br></p><p>1) make it an obvious documented part of the signature, possibly including the default return value<br></p><p>2) possibly make it less verbose by getting rid of the explicitly spelled out protocol extension<br></p><p>A.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/7831fe27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 3, 2016, at 10:40 AM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt; <br>&gt; Chris, as we&#39;ve discussed in a thread that I think got forked from this one:<br>&gt; <br>&gt; Yes, they do technically, but it would be nice to both:<br>&gt; <br>&gt; 1) make it an obvious documented part of the signature, possibly including the default return value<br>&gt; <br>&gt; 2) possibly make it less verbose by getting rid of the explicitly spelled out protocol extension<br></p><p>Right, but “more is worse” when it comes to language design.  Having a &quot;more general&quot; facility that greatly overlaps with a “more narrow” facility always makes us question whether it is worth the complexity to have both.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/e15f115f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0ca88ca6c43034ed39668bb10783618?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Yuval Tal</string> &lt;yuvalt at pblc.co&gt;<p>April  3, 2016 at 06:00:00pm</p></header><div class="content"><p>For readability and specifically in this case, I think it does make sense<br>IMHO.<br></p><p>On Sunday, April 3, 2016, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 3, 2016, at 10:40 AM, Andrey Tarantsov &lt;andrey at tarantsov.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;andrey at tarantsov.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Protocol requirements with default (no-op) implementations already satisfy<br>&gt; that design goal, no?<br>&gt;<br>&gt;<br>&gt; Chris, as we&#39;ve discussed in a thread that I think got forked from this<br>&gt; one:<br>&gt;<br>&gt; Yes, they do technically, but it would be nice to both:<br>&gt;<br>&gt; 1) make it an obvious documented part of the signature, possibly including<br>&gt; the default return value<br>&gt;<br>&gt; 2) possibly make it less verbose by getting rid of the explicitly spelled<br>&gt; out protocol extension<br>&gt;<br>&gt;<br>&gt; Right, but “more is worse” when it comes to language design.  Having a<br>&gt; &quot;more general&quot; facility that greatly overlaps with a “more narrow” facility<br>&gt; always makes us question whether it is worth the complexity to have both.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/87eef989/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>I understand the concern.<br></p><p>To me, the answer is clearly yes. The language cannot be considered in isolation from its use cases; imagine UIKit written in Swift.<br></p><p>You want the developers to be able to quickly understand which table view delegate methods they need to implement, and what the contract is (are cells editable or non-editable by default?).<br></p><p>We need the same thing for our own UIKit-style controls we&#39;re writing today (and we don&#39;t want to be limited to @objc types when doing that — those are particularly ill-suited for the return values of optional delegate methods; I often want a CGFloat? or a enum).<br></p><p>I don&#39;t see this as a separate faculty as much as a shorthand, similar to how T? is a shorthand for Optional&lt;T&gt;.<br></p><p>The general opinion on shorthands varies from “there should be exactly one way to do everything” Python-style to “the language should help the developer express themselves” Ruby/Perl-style.<br></p><p>I personally am firmly in the “Ruby camp” here, so I&#39;m all for use case-specific shorthands for general facilities.<br></p><p>You, sir (together with your dream team), should probably pick an official stance on this matter. :-)<br></p><p>A.<br></p><p><br>On 4 Apr 2016 04:15 +0600, Yuval Tal&lt;yuvalt at pblc.co&gt;, wrote:<br>&gt; For readability and specifically in this case, I think it does make sense IMHO.<br>&gt;  <br>&gt; On Sunday, April 3, 2016, Chris Lattner&lt;clattner at apple.com(mailto:clattner at apple.com)&gt;wrote:<br>&gt; &gt;  <br>&gt; &gt; &gt; On Apr 3, 2016, at 10:40 AM, Andrey Tarantsov&lt;andrey at tarantsov.com(javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;andrey at tarantsov.com&#39;);)&gt;wrote:<br>&gt; &gt; &gt; &gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt; &gt; &gt; Chris, as we&#39;ve discussed in a thread that I think got forked from this one:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Yes, they do technically, but it would be nice to both:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; 1) make it an obvious documented part of the signature, possibly including the default return value<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; 2) possibly make it less verbose by getting rid of the explicitly spelled out protocol extension<br>&gt; &gt; Right, but “more is worse” when it comes to language design.Having a &quot;more general&quot; facility that greatly overlaps with a “more narrow” facility always makes us question whether it is worth the complexity to have both.<br>&gt; &gt;  <br>&gt; &gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/3c55eba4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  4, 2016 at 07:00:00am</p></header><div class="content"><p>As the problem seems to be to eliminate having to write the extension with all its duplication, I&#39;d prefer a more general solution instead of introducing the notion of an &quot;optional&quot; function: just make it possible to write default implementations inline in a protocol definition. <br></p><p>Documenting the optionality can be done in the doc comment, maybe with a new documentation keyword &quot;default&quot;. Having &quot;optional&quot; in the code has no additional value over a comment because the method is not optional in the Obj-C sense and the proposal requires a default value. Therefore the presence of &quot;optional&quot; has essentially no effect at all and is better moved into a comment.<br></p><p>-Thorsten <br></p><p>&gt; Am 04.04.2016 um 00:13 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 3, 2016, at 10:40 AM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt;&gt; <br>&gt;&gt; Chris, as we&#39;ve discussed in a thread that I think got forked from this one:<br>&gt;&gt; <br>&gt;&gt; Yes, they do technically, but it would be nice to both:<br>&gt;&gt; <br>&gt;&gt; 1) make it an obvious documented part of the signature, possibly including the default return value<br>&gt;&gt; <br>&gt;&gt; 2) possibly make it less verbose by getting rid of the explicitly spelled out protocol extension<br>&gt; <br>&gt; Right, but “more is worse” when it comes to language design.  Having a &quot;more general&quot; facility that greatly overlaps with a “more narrow” facility always makes us question whether it is worth the complexity to have both.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/b58c5037/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I&#39;d prefer a more general solution instead of introducing the notion of an &quot;optional&quot; function: just make it possible to write default implementations inline in a protocol definition. <br></p><p>This would work, too. I guess there&#39;s no need for an “optional” keyword if the implementation is right there in the protocol declaration.<br></p><p>A.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 3, 2016, at 10:21 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As the problem seems to be to eliminate having to write the extension with all its duplication, I&#39;d prefer a more general solution instead of introducing the notion of an &quot;optional&quot; function: just make it possible to write default implementations inline in a protocol definition. <br></p><p>I think we can consider it as a given that, at some point, we’ll be able to write default implementations inline in the protocol definition. It’s not there now because we never got around to implementing it.<br></p><p>&gt; Documenting the optionality can be done in the doc comment, maybe with a new documentation keyword &quot;default&quot;. Having &quot;optional&quot; in the code has no additional value over a comment because the method is not optional in the Obj-C sense and the proposal requires a default value. Therefore the presence of &quot;optional&quot; has essentially no effect at all and is better moved into a comment.<br></p><p>I tend to agree. ‘optional’ and the ‘= value’ syntax are fairly heavyweight language mechanisms for what is effectively documentation.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 04.04.2016 um 00:13 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 3, 2016, at 10:40 AM, Andrey Tarantsov &lt;andrey at tarantsov.com &lt;mailto:andrey at tarantsov.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocol requirements with default (no-op) implementations already satisfy that design goal, no?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris, as we&#39;ve discussed in a thread that I think got forked from this one:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, they do technically, but it would be nice to both:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) make it an obvious documented part of the signature, possibly including the default return value<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) possibly make it less verbose by getting rid of the explicitly spelled out protocol extension<br>&gt;&gt; <br>&gt;&gt; Right, but “more is worse” when it comes to language design.  Having a &quot;more general&quot; facility that greatly overlaps with a “more narrow” facility always makes us question whether it is worth the complexity to have both.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/86186c3f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt; optional protocol requirements encourages a style of programming that<br>&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt; already gone.<br></p><p>This is why my suggestion to solve this required the protocol to include default values for any optional function with a return value - I don’t think that a function should be optional as in “no presence” or even in a way that the caller can identify if the function is or isn’t defined, but just optional as in “it has a clear documented default.” I don’t agree that the caller of an optional protocol function should be able to tell if the function is present or not - the protocol itself should be defined as if all functions are there, but the “optional-ness” is then no worse than default values on function parameters - but that might just be me.<br></p><p>Perhaps a better term for my way of thinking about it would be “default” rather than optional:<br></p><p>protocol UIGestureRecognizerDelegate {<br> default func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer) -&gt; Bool = true<br> // etc<br>}<br></p><p>l8r<br>Sean<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 31, 2016 at 04:00:00pm</p></header><div class="content"><p>+1<br></p><p>We need to support optional methods in @objc protocols because it is required for interoperability. However, there are in my experience only reasons for an optional protocol method:<br></p><p>- There is a very common default behavior for a delegate (such as return immediately with a value of 0/nil/false) which would be a burden to require everyone to implement. We can instead accomplish this with protocol extensions<br></p><p>- The absence of a method in a delegate indicates a behavior that is otherwise impossible for the delegate to implement. The easiest example of this would be  tableView:heightForRowAtIndexPath:, where the absence triggers an optimization where UITableView.rowHeight is used for all math, and its presence means that performance will be degraded, and the delegate will be called repeatedly for every single index path in order to figure out the table positioning/scroll height. I believe this has been shown to be much better solved via an optional additional protocol conformance to indicate that you are supporting a different ‘class’ of behavior, in this case that might be something like UITableViewVaribleHeightDelegate.<br></p><p>I’d hate for there to be a push for optional protocol methods just because it can be confusing which methods are required in swift protocol implementations (vs defaulted by a protocol extension).<br></p><p>-DW<br></p><p>&gt; On Mar 31, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I find that optional protocol methods to be very useful. However,<br>&gt;&gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt;&gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt;&gt; does not map to objective-c. What do you think about removing the<br>&gt;&gt; requirement of using @objc and allow to create optional methods<br>&gt;&gt; without these limitations?<br>&gt; <br>&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt; optional protocol requirements encourages a style of programming that<br>&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt; already gone.<br>&gt; <br>&gt; --<br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/a3ff0657/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 5:51 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; We need to support optional methods in @objc protocols because it is required for interoperability. However, there are in my experience only reasons for an optional protocol method:<br>&gt; <br>&gt; - There is a very common default behavior for a delegate (such as return immediately with a value of 0/nil/false) which would be a burden to require everyone to implement. We can instead accomplish this with protocol extensions<br>&gt; <br>&gt; - The absence of a method in a delegate indicates a behavior that is otherwise impossible for the delegate to implement. The easiest example of this would be  tableView:heightForRowAtIndexPath:, where the absence triggers an optimization where UITableView.rowHeight is used for all math, and its presence means that performance will be degraded, and the delegate will be called repeatedly for every single index path in order to figure out the table positioning/scroll height. I believe this has been shown to be much better solved via an optional additional protocol conformance to indicate that you are supporting a different ‘class’ of behavior, in this case that might be something like UITableViewVaribleHeightDelegate.<br></p><p>+1.  I am not fully pleased with the design of the UITableViewDelegate and UITableViewDataSource protocols and this is one point that is problematic.  It makes it impossible to implement a generic delegate that might sometimes need to have variable row height, but in other cases should take the fast path.<br></p><p>&gt; <br>&gt; I’d hate for there to be a push for optional protocol methods just because it can be confusing which methods are required in swift protocol implementations (vs defaulted by a protocol extension).<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 12:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Mar 30 2016, Yuval Tal &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find that optional protocol methods to be very useful. However,<br>&gt;&gt;&gt; there is a caveat -- it needs to be mapped to @objc.  This puts a set<br>&gt;&gt;&gt; of limitations, such as: structures cannot be used as parameters as it<br>&gt;&gt;&gt; does not map to objective-c. What do you think about removing the<br>&gt;&gt;&gt; requirement of using @objc and allow to create optional methods<br>&gt;&gt;&gt; without these limitations?<br>&gt;&gt; <br>&gt;&gt; Caveat: this is going to be strongly-worded; sorry in advance.  I think<br>&gt;&gt; (no offense intended) it&#39;s a terrible idea.  The whole notion of an<br>&gt;&gt; “optional requirement” is nonsensical to begin with, and the use of<br>&gt;&gt; optional protocol requirements encourages a style of programming that<br>&gt;&gt; lifts the responsibility of the protocol designer for careful design at<br>&gt;&gt; the expense of clients of the protocol.  There are better ways to do<br>&gt;&gt; things; let&#39;s not propagate this anti-pattern any further than it&#39;s<br>&gt;&gt; already gone.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
