<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 12:00:00am</p></header><div class="content"><p>Disclaimer: I have not (yet) prepared a proposal, or even something that<br>could be considered a draft, but I want to hear public opinion on the topic.<br></p><p>SE-0077 (about precedence groups) has been successfully implemented for<br>Swift 3. (A thousand thanks to John McCall!) It suggests a model where we<br>can prohibit certain operators from standing next to each other.<br></p><p>This was intended to be the second part of that proposal. We now have to<br>think if we should drop some precedence relationships between standard<br>operators. Here are examples of parentheses dropping that can be ambiguous<br>to reader:<br></p><p>1/3 as Double   // should we prohibit this?<br>1 | 2 ^ 3   // or this?<br>a &amp;&amp; b | c   // or this?<br></p><p>Should we break standard precedence hierarchy and if yes, how?<br>For those involved in the mentioned proposal, how exactly should standard<br>precedence groups relate?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/374984ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  1, 2016 at 04:00:00pm</p></header><div class="content"><p>On Mon, Aug 1, 2016 at 4:41 PM, Anton Zhilin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Disclaimer: I have not (yet) prepared a proposal, or even something that<br>&gt; could be considered a draft, but I want to hear public opinion on the topic.<br>&gt;<br>&gt; SE-0077 (about precedence groups) has been successfully implemented for<br>&gt; Swift 3. (A thousand thanks to John McCall!) It suggests a model where we<br>&gt; can prohibit certain operators from standing next to each other.<br>&gt;<br>&gt; This was intended to be the second part of that proposal. We now have to<br>&gt; think if we should drop some precedence relationships between standard<br>&gt; operators. Here are examples of parentheses dropping that can be ambiguous<br>&gt; to reader:<br>&gt;<br>&gt; 1/3 as Double   // should we prohibit this?<br>&gt;<br></p><p>Why should we? I would absolutely want that to work exactly as it does now<br>(0.333333...).<br></p><p>1 | 2 ^ 3   // or this?<br>&gt;<br></p><p>No. Both of those are bitwise operations. They are often used together.<br>They have a refined relative precedence in Swift that makes sense.<br></p><p>a &amp;&amp; b | c   // or this?<br>&gt;<br></p><p>Now that&#39;s more interesting. Maybe?<br></p><p>Should we break standard precedence hierarchy and if yes, how?<br>&gt; For those involved in the mentioned proposal, how exactly should standard<br>&gt; precedence groups relate?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160801/a9245770/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 01:00:00am</p></header><div class="content"><p>2016-08-02 0:52 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; On Mon, Aug 1, 2016 at 4:41 PM, Anton Zhilin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Disclaimer: I have not (yet) prepared a proposal, or even something that<br>&gt;&gt; could be considered a draft, but I want to hear public opinion on the topic.<br>&gt;&gt;<br>&gt;&gt; SE-0077 (about precedence groups) has been successfully implemented for<br>&gt;&gt; Swift 3. (A thousand thanks to John McCall!) It suggests a model where we<br>&gt;&gt; can prohibit certain operators from standing next to each other.<br>&gt;&gt;<br>&gt;&gt; This was intended to be the second part of that proposal. We now have to<br>&gt;&gt; think if we should drop some precedence relationships between standard<br>&gt;&gt; operators. Here are examples of parentheses dropping that can be ambiguous<br>&gt;&gt; to reader:<br>&gt;&gt;<br>&gt;&gt; 1/3 as Double   // should we prohibit this?<br>&gt;&gt;<br>&gt;<br>&gt; Why should we? I would absolutely want that to work exactly as it does now<br>&gt; (0.333333...).<br>&gt;<br></p><p>Strange enough, I&#39;ve just run it and yes, 0.333333... But casting<br>precedence is lower than multiplicative, so I thought it would parse as<br>&#39;(1/3) as Double&#39;. Is it a bug?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/a228da60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 3:01 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; 2016-08-02 0:52 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;:<br>&gt; On Mon, Aug 1, 2016 at 4:41 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Disclaimer: I have not (yet) prepared a proposal, or even something that could be considered a draft, but I want to hear public opinion on the topic.<br>&gt; <br>&gt; SE-0077 (about precedence groups) has been successfully implemented for Swift 3. (A thousand thanks to John McCall!) It suggests a model where we can prohibit certain operators from standing next to each other.<br>&gt; <br>&gt; This was intended to be the second part of that proposal. We now have to think if we should drop some precedence relationships between standard operators. Here are examples of parentheses dropping that can be ambiguous to reader:<br>&gt; <br>&gt; 1/3 as Double   // should we prohibit this?<br>&gt; <br>&gt; Why should we? I would absolutely want that to work exactly as it does now (0.333333...).<br>&gt; <br>&gt; Strange enough, I&#39;ve just run it and yes, 0.333333... But casting precedence is lower than multiplicative, so I thought it would parse as &#39;(1/3) as Double&#39;. Is it a bug?<br></p><p>You&#39;re applying C-style thinking.  Swift does not have implicit promotions.  Coercing the result of 1/3 to Double forces the operands to be Doubles as well.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160801/3fa71f88/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Not a bug. `(1 as Int/3) as Double` is a type error, because you can&#39;t<br>cast Int to Double that way, so in order to resolve the types in this<br>expression the 1 and 3 end up inferred as Doubles as that&#39;s the only way<br>to make the output compatible with `as Double`.<br></p><p>In other words, with this example, the precedence doesn&#39;t<br>actually matter.<br></p><p>-Kevin<br></p><p>On Mon, Aug 1, 2016, at 03:01 PM, Anton Zhilin via swift-evolution wrote:<br>&gt; 2016-08-02 0:52 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt; On Mon, Aug 1, 2016 at 4:41 PM, Anton Zhilin via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Disclaimer: I have not (yet) prepared a proposal, or even something<br>&gt;&gt;&gt; that could be considered a draft, but I want to hear public opinion<br>&gt;&gt;&gt; on the topic.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; SE-0077 (about precedence groups) has been successfully implemented<br>&gt;&gt;&gt; for Swift 3. (A thousand thanks to John McCall!) It suggests a model<br>&gt;&gt;&gt; where we can prohibit certain operators from standing next to each<br>&gt;&gt;&gt; other.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This was intended to be the second part of that proposal. We now<br>&gt;&gt;&gt; have to think if we should drop some precedence relationships<br>&gt;&gt;&gt; between standard operators. Here are examples of parentheses<br>&gt;&gt;&gt; dropping that can be ambiguous to reader:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1/3 as Double   // should we prohibit this?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why should we? I would absolutely want that to work exactly as it<br>&gt;&gt; does now (0.333333...).<br>&gt;<br>&gt; Strange enough, I&#39;ve just run it and yes, 0.333333... But casting<br>&gt; precedence is lower than multiplicative, so I thought it would parse<br>&gt; as &#39;(1/3) as Double&#39;. Is it a bug?<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160801/91894d00/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>August  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;&gt; 1 | 2 ^ 3   // or this?<br>&gt;<br>&gt;<br>&gt; No. Both of those are bitwise operations. They are often used together. They<br>&gt; have a refined relative precedence in Swift that makes sense.<br></p><p>I have no idea what the relative precedence of those operators is in<br>Swift, C, or any other language, and thinking about it now, no<br>relative precedence seems sensible or obvious to me. Those operators<br>(and bitwise-&amp;) are excellent examples of operators that should<br>require parentheses.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  1, 2016 at 09:00:00pm</p></header><div class="content"><p>I disagree. The binary operators have properties that are comparable to arithmetic operators, and their precedence is easy to define as such. &amp; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br></p><p>The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br></p><p>Binary operators get especially confusing in some languages because their precedence is lower than comparison operators. For instance, in C, `a &amp; b == c` gets parsed as `a &amp; (b == c)`. In Swift, the precedence of binary operators is above that of comparison operators, so we don&#39;t have that problem.<br></p><p>Félix<br></p><p>&gt; Le 1 août 2016 à 20:48:21, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt;&gt; 1 | 2 ^ 3   // or this?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; No. Both of those are bitwise operations. They are often used together. They<br>&gt;&gt; have a refined relative precedence in Swift that makes sense.<br>&gt; <br>&gt; I have no idea what the relative precedence of those operators is in<br>&gt; Swift, C, or any other language, and thinking about it now, no<br>&gt; relative precedence seems sensible or obvious to me. Those operators<br>&gt; (and bitwise-&amp;) are excellent examples of operators that should<br>&gt; require parentheses.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160801/d1f47dc2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 04:00:00am</p></header><div class="content"><p>Right. I asked about this issue some months ago on this list, and Chris was<br>very patient to confirm that what you described was indeed the thinking<br>behind the rationalized precedence of bitwise operators in Swift.<br></p><p><br>On Mon, Aug 1, 2016 at 23:18 Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I disagree. The binary operators have properties that are comparable to<br>&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;<br>&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;<br>&gt; Binary operators get especially confusing in some languages because their<br>&gt; precedence is lower than comparison operators. For instance, in C, `a &amp; b<br>&gt; == c` gets parsed as `a &amp; (b == c)`. In Swift, the precedence of binary<br>&gt; operators is above that of comparison operators, so we don&#39;t have that<br>&gt; problem.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 1 août 2016 à 20:48:21, Rob Mayoff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; 1 | 2 ^ 3   // or this?<br>&gt;<br>&gt;<br>&gt;<br>&gt; No. Both of those are bitwise operations. They are often used together.<br>&gt; They<br>&gt; have a refined relative precedence in Swift that makes sense.<br>&gt;<br>&gt;<br>&gt; I have no idea what the relative precedence of those operators is in<br>&gt; Swift, C, or any other language, and thinking about it now, no<br>&gt; relative precedence seems sensible or obvious to me. Those operators<br>&gt; (and bitwise-&amp;) are excellent examples of operators that should<br>&gt; require parentheses.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/83a7a266/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 12:00:00pm</p></header><div class="content"><p>2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt; I disagree. The binary operators have properties that are comparable to<br>&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;<br>&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;<br></p><p>I believe that such way of thinking is non-intuitive. In C, bitwise<br>operators are not intervened by any others, except for comparison operators<br>(agreed, it was a mistake). We now have possibilities to do so in Swift,<br>even better. I suggest to branch off right before AdditionPrecedence:<br></p><p>RangeFormation &lt; Addition &lt; Multiplication<br>RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br></p><p>Another concern is NilCoalescing, which can be though to be semantically<br>similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>would bring it between LogicalConjunction and Comparison.<br>Also, do Casting and RangeFormation stand where they should?<br></p><p>Next, Ternary operator is unique. Noone would ever like to put operators in<br>this precedence group, because it would be confusing. Why not simplify our<br>model and say that ?: has lower precedence than all binary operators,<br>including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/66b46409/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>August  2, 2016 at 10:00:00am</p></header><div class="content"><p>Assignment has the lowest precedence. &#39;x = condition ? y : z&#39; doesn&#39;t make<br>sense if assignment is resolved before the ternary; the compiler would<br>complain that perhaps you meant &#39;==&#39; instead of &#39;=&#39;.<br></p><p>There was an idea ages ago for essentially a &#39;switch expression&#39; which was<br>effectively ternary for cases; if we ever make that a reality, it should<br>probably have the same precedence as ternary. But otherwise it&#39;s probably<br>going to continue to be a group of one.<br></p><p>On Tue, Aug 2, 2016 at 10:29 AM, Anton Zhilin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; I disagree. The binary operators have properties that are comparable to<br>&gt;&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt;&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;<br>&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;<br>&gt;<br>&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt; operators are not intervened by any others, except for comparison operators<br>&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;<br>&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;<br>&gt; Another concern is NilCoalescing, which can be though to be semantically<br>&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt; would bring it between LogicalConjunction and Comparison.<br>&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;<br>&gt; Next, Ternary operator is unique. Noone would ever like to put operators<br>&gt; in this precedence group, because it would be confusing. Why not simplify<br>&gt; our model and say that ?: has lower precedence than all binary operators,<br>&gt; including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/d8023c74/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>What&#39;s your evidence that it&#39;s non-intuitive? I literally use &lt;&lt; for powers<br>of 2, as I&#39;m sure do many others. As in, 1 &lt;&lt; 3 == 8. Do you have a better<br>way of computing, say, 2^53?<br></p><p>On Tue, Aug 2, 2016 at 04:29 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; I disagree. The binary operators have properties that are comparable to<br>&gt;&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt;&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;<br>&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;<br>&gt;<br>&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt; operators are not intervened by any others, except for comparison operators<br>&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;<br>&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;<br>&gt; Another concern is NilCoalescing, which can be though to be semantically<br>&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt; would bring it between LogicalConjunction and Comparison.<br>&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;<br>&gt; Next, Ternary operator is unique. Noone would ever like to put operators<br>&gt; in this precedence group, because it would be confusing. Why not simplify<br>&gt; our model and say that ?: has lower precedence than all binary operators,<br>&gt; including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/e9154eb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Re: ternary operators--this goes far beyond the boundaries of the<br>discussion you yourself started. Removing certain relative precedences so<br>that parentheses are required is one thing; *changing* relative precedences<br>is quite another. For me at least, the latter is an absolute nonstarter.<br>Every existing usage of the operator could potentially *silently* break.<br></p><p>As to removing certain precedences--the current Swift precedences are<br>rationally defensible. Perhaps anything you propose would be too, but<br>trading one rational scheme for another (at best) is not justification<br>enough for a source-breaking change. Instead, show me a scenario in which<br>you write something today that could plausibly do something other than what<br>it might look like, where forcing parentheses would fix the issue--i.e.<br>convince me a change would eliminate actual user errors--and I&#39;m on board.<br>So far, I haven&#39;t seen one (even the &quot;maybe&quot; scenario above, a &amp;&amp; b | c,<br>wouldn&#39;t work in Swift unless you defined custom operator functions<br>yourself, so there&#39;s no real possibility of a silent error).<br>On Tue, Aug 2, 2016 at 08:31 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; What&#39;s your evidence that it&#39;s non-intuitive? I literally use &lt;&lt; for<br>&gt; powers of 2, as I&#39;m sure do many others. As in, 1 &lt;&lt; 3 == 8. Do you have a<br>&gt; better way of computing, say, 2^53?<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 04:29 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable to<br>&gt;&gt;&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt;&gt;&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt;&gt; operators are not intervened by any others, except for comparison operators<br>&gt;&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt;&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;<br>&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;<br>&gt;&gt; Another concern is NilCoalescing, which can be though to be semantically<br>&gt;&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt;&gt; would bring it between LogicalConjunction and Comparison.<br>&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;<br>&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put operators<br>&gt;&gt; in this precedence group, because it would be confusing. Why not simplify<br>&gt;&gt; our model and say that ?: has lower precedence than all binary operators,<br>&gt;&gt; including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/eb1252c6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  2, 2016 at 08:00:00am</p></header><div class="content"><p>I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be looking for. There is nothing intuitive about multiplications having a higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m not a maths expert (as Stephen showed, I didn&#39;t even give the right explanation to binary operators!), but it seems to me that there could well be a parallel universe in which additions have precedence over multiplications without other serious implications.<br></p><p>And as it happens, a majority of people don&#39;t know that there is one for binary operators. I believe that the right question should be: do we want to pretend that this convention doesn&#39;t exist, to the benefit of people who don&#39;t know about it, and the detriment of those who do? Also, do we want to break it for &amp;&amp; and || too?<br></p><p>I think that the biggest use case for binary operators in other languages are flags, and in Swift we treat these as collections. I&#39;d venture that &amp;, | and ^ would show up about as frequently as UnsafePointers and the like. It seems to me that Swift&#39;s approach has been to make things easy by default without locking away the power tools, and my personal expectation is that if you have to write code that has binary operators despite everything else that Swift has for you, you can be bothered to learn a precedence rule.<br></p><p>That said, one thing that I could definitely get behind is breaking precedence between binary operators and arithmetic operators. I don&#39;t think that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my code, the only place where I needed to mix binary operators and arithmetic operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and that one needs parentheses anyway.<br></p><p>Félix<br></p><p>&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a écrit :<br>&gt; <br>&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; I disagree. The binary operators have properties that are comparable to arithmetic operators, and their precedence is easy to define as such. &amp; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt; <br>&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt; <br>&gt; I believe that such way of thinking is non-intuitive. In C, bitwise operators are not intervened by any others, except for comparison operators (agreed, it was a mistake). We now have possibilities to do so in Swift, even better. I suggest to branch off right before AdditionPrecedence:<br>&gt; <br>&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt; <br>&gt; Another concern is NilCoalescing, which can be though to be semantically similar to Ternary. And at the same time it looks like || and &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt; <br>&gt; Next, Ternary operator is unique. Noone would ever like to put operators in this precedence group, because it would be confusing. Why not simplify our model and say that ?: has lower precedence than all binary operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good? <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/72eee8e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be looking<br>&gt; for. There is nothing intuitive about multiplications having a higher<br>&gt; precedence than additions; it&#39;s just a matter of conventions. I&#39;m not a<br>&gt; maths expert (as Stephen showed, I didn&#39;t even give the right explanation<br>&gt; to binary operators!), but it seems to me that there could well be a<br>&gt; parallel universe in which additions have precedence over multiplications<br>&gt; without other serious implications.<br>&gt;<br>&gt; And as it happens, a majority of people don&#39;t know that there is one for<br>&gt; binary operators. I believe that the right question should be: do we want<br>&gt; to pretend that this convention doesn&#39;t exist, to the benefit of people who<br>&gt; don&#39;t know about it, and the detriment of those who do? Also, do we want to<br>&gt; break it for &amp;&amp; and || too?<br>&gt;<br>&gt; I think that the biggest use case for binary operators in other languages<br>&gt; are flags, and in Swift we treat these as collections. I&#39;d venture that &amp;,<br>&gt; | and ^ would show up about as frequently as UnsafePointers and the like.<br>&gt; It seems to me that Swift&#39;s approach has been to make things easy by<br>&gt; default without locking away the power tools, and my personal expectation<br>&gt; is that if you have to write code that has binary operators despite<br>&gt; everything else that Swift has for you, you can be bothered to learn a<br>&gt; precedence rule.<br>&gt;<br>&gt; That said, one thing that I could definitely get behind is breaking<br>&gt; precedence between binary operators and arithmetic operators. I don&#39;t think<br>&gt; that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my<br>&gt; code, the only place where I needed to mix binary operators and arithmetic<br>&gt; operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and<br>&gt; that one needs parentheses anyway.<br>&gt;<br></p><p>Although here, your same argument applies. If you need to write `a &amp; b /<br>c`, then you can be bothered either to learn or look up a table, or you can<br>just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the<br>code, it&#39;s highly likely that this is a complex formula anyway; you can<br>either know the relative precedence or look it up, but that&#39;s the *least*<br>of your worries in terms of what it will take to understand that code. I<br>see no reason to force parentheses unless it actually prevents user error.<br></p><p><br>&gt;<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a écrit :<br>&gt;<br>&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; I disagree. The binary operators have properties that are comparable to<br>&gt;&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt;&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;<br>&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;<br>&gt;<br>&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt; operators are not intervened by any others, except for comparison operators<br>&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;<br>&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;<br>&gt; Another concern is NilCoalescing, which can be though to be semantically<br>&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt; would bring it between LogicalConjunction and Comparison.<br>&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;<br>&gt; Next, Ternary operator is unique. Noone would ever like to put operators<br>&gt; in this precedence group, because it would be confusing. Why not simplify<br>&gt; our model and say that ?: has lower precedence than all binary operators,<br>&gt; including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/37c0b269/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  2, 2016 at 09:00:00am</p></header><div class="content"><p>These expressions mix two types of logic that have different implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;, except that `a * 16` will crash on overflow. In these cases, I find that grouping provides some visual insulation that groups off the somewhat subtle differences.<br></p><p>Félix<br></p><p>&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be looking for. There is nothing intuitive about multiplications having a higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m not a maths expert (as Stephen showed, I didn&#39;t even give the right explanation to binary operators!), but it seems to me that there could well be a parallel universe in which additions have precedence over multiplications without other serious implications.<br>&gt; <br>&gt; And as it happens, a majority of people don&#39;t know that there is one for binary operators. I believe that the right question should be: do we want to pretend that this convention doesn&#39;t exist, to the benefit of people who don&#39;t know about it, and the detriment of those who do? Also, do we want to break it for &amp;&amp; and || too?<br>&gt; <br>&gt; I think that the biggest use case for binary operators in other languages are flags, and in Swift we treat these as collections. I&#39;d venture that &amp;, | and ^ would show up about as frequently as UnsafePointers and the like. It seems to me that Swift&#39;s approach has been to make things easy by default without locking away the power tools, and my personal expectation is that if you have to write code that has binary operators despite everything else that Swift has for you, you can be bothered to learn a precedence rule.<br>&gt; <br>&gt; That said, one thing that I could definitely get behind is breaking precedence between binary operators and arithmetic operators. I don&#39;t think that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my code, the only place where I needed to mix binary operators and arithmetic operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and that one needs parentheses anyway.<br>&gt; <br>&gt; Although here, your same argument applies. If you need to write `a &amp; b / c`, then you can be bothered either to learn or look up a table, or you can just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the code, it&#39;s highly likely that this is a complex formula anyway; you can either know the relative precedence or look it up, but that&#39;s the *least* of your worries in terms of what it will take to understand that code. I see no reason to force parentheses unless it actually prevents user error.<br>&gt;  <br>&gt; <br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; I disagree. The binary operators have properties that are comparable to arithmetic operators, and their precedence is easy to define as such. &amp; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt; <br>&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt; <br>&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise operators are not intervened by any others, except for comparison operators (agreed, it was a mistake). We now have possibilities to do so in Swift, even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt; <br>&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt; <br>&gt;&gt; Another concern is NilCoalescing, which can be though to be semantically similar to Ternary. And at the same time it looks like || and &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt; <br>&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put operators in this precedence group, because it would be confusing. Why not simplify our model and say that ?: has lower precedence than all binary operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good? <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/8932cb79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 04:00:00pm</p></header><div class="content"><p>That&#39;s an excellent point, actually. Would there be downsides not yet<br>considered?<br></p><p>On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; These expressions mix two types of logic that have different implications.<br>&gt; For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;, except that `a<br>&gt; * 16` will crash on overflow. In these cases, I find that grouping provides<br>&gt; some visual insulation that groups off the somewhat subtle differences.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be<br>&gt;&gt; looking for. There is nothing intuitive about multiplications having a<br>&gt;&gt; higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m<br>&gt;&gt; not a maths expert (as Stephen showed, I didn&#39;t even give the right<br>&gt;&gt; explanation to binary operators!), but it seems to me that there could well<br>&gt;&gt; be a parallel universe in which additions have precedence over<br>&gt;&gt; multiplications without other serious implications.<br>&gt;&gt;<br>&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one for<br>&gt;&gt; binary operators. I believe that the right question should be: do we want<br>&gt;&gt; to pretend that this convention doesn&#39;t exist, to the benefit of people who<br>&gt;&gt; don&#39;t know about it, and the detriment of those who do? Also, do we want to<br>&gt;&gt; break it for &amp;&amp; and || too?<br>&gt;&gt;<br>&gt;&gt; I think that the biggest use case for binary operators in other languages<br>&gt;&gt; are flags, and in Swift we treat these as collections. I&#39;d venture that &amp;,<br>&gt;&gt; | and ^ would show up about as frequently as UnsafePointers and the like.<br>&gt;&gt; It seems to me that Swift&#39;s approach has been to make things easy by<br>&gt;&gt; default without locking away the power tools, and my personal expectation<br>&gt;&gt; is that if you have to write code that has binary operators despite<br>&gt;&gt; everything else that Swift has for you, you can be bothered to learn a<br>&gt;&gt; precedence rule.<br>&gt;&gt;<br>&gt;&gt; That said, one thing that I could definitely get behind is breaking<br>&gt;&gt; precedence between binary operators and arithmetic operators. I don&#39;t think<br>&gt;&gt; that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my<br>&gt;&gt; code, the only place where I needed to mix binary operators and arithmetic<br>&gt;&gt; operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and<br>&gt;&gt; that one needs parentheses anyway.<br>&gt;&gt;<br>&gt;<br>&gt; Although here, your same argument applies. If you need to write `a &amp; b /<br>&gt; c`, then you can be bothered either to learn or look up a table, or you can<br>&gt; just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the<br>&gt; code, it&#39;s highly likely that this is a complex formula anyway; you can<br>&gt; either know the relative precedence or look it up, but that&#39;s the *least*<br>&gt; of your worries in terms of what it will take to understand that code. I<br>&gt; see no reason to force parentheses unless it actually prevents user error.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a écrit<br>&gt;&gt; :<br>&gt;&gt;<br>&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable to<br>&gt;&gt;&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt;&gt;&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt;&gt; operators are not intervened by any others, except for comparison operators<br>&gt;&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt;&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;<br>&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;<br>&gt;&gt; Another concern is NilCoalescing, which can be though to be semantically<br>&gt;&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt;&gt; would bring it between LogicalConjunction and Comparison.<br>&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;<br>&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put operators<br>&gt;&gt; in this precedence group, because it would be confusing. Why not simplify<br>&gt;&gt; our model and say that ?: has lower precedence than all binary operators,<br>&gt;&gt; including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/6a45eabc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Speaking for myself, I will *never* remember which of `&amp;&amp;` and `||` has<br>higher precedence. I think of them as peers, so I always use parentheses<br>around them, and whenever I read code that mingles them without parentheses<br>its meaning is *unclear* to me.<br></p><p>One of Swift’s main goals is clarity at the point of use. After all, code<br>is read far more often than it is written. To me, an expression like `a &amp;&amp;<br>b || c &amp;&amp; d` is not clear when I read it.<br></p><p>The same goes for bitwise operators: I view them as peers. I do not think<br>of them as “additive” or “multiplicative” (and definitely not<br>“subtractive”), so code that relies on their precedences will always send<br>me scrambling to look up which comes first.<br></p><p>Certainly something like `a + b | c &amp; d - e * f ^ g` is meaningless to me<br>without parentheses.<br></p><p>Nevin<br></p><p><br></p><p>On Tue, Aug 2, 2016 at 12:08 PM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That&#39;s an excellent point, actually. Would there be downsides not yet<br>&gt; considered?<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; These expressions mix two types of logic that have different<br>&gt;&gt; implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;,<br>&gt;&gt; except that `a * 16` will crash on overflow. In these cases, I find that<br>&gt;&gt; grouping provides some visual insulation that groups off the somewhat<br>&gt;&gt; subtle differences.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be<br>&gt;&gt;&gt; looking for. There is nothing intuitive about multiplications having a<br>&gt;&gt;&gt; higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m<br>&gt;&gt;&gt; not a maths expert (as Stephen showed, I didn&#39;t even give the right<br>&gt;&gt;&gt; explanation to binary operators!), but it seems to me that there could well<br>&gt;&gt;&gt; be a parallel universe in which additions have precedence over<br>&gt;&gt;&gt; multiplications without other serious implications.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one for<br>&gt;&gt;&gt; binary operators. I believe that the right question should be: do we want<br>&gt;&gt;&gt; to pretend that this convention doesn&#39;t exist, to the benefit of people who<br>&gt;&gt;&gt; don&#39;t know about it, and the detriment of those who do? Also, do we want to<br>&gt;&gt;&gt; break it for &amp;&amp; and || too?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that the biggest use case for binary operators in other<br>&gt;&gt;&gt; languages are flags, and in Swift we treat these as collections. I&#39;d<br>&gt;&gt;&gt; venture that &amp;, | and ^ would show up about as frequently as UnsafePointers<br>&gt;&gt;&gt; and the like. It seems to me that Swift&#39;s approach has been to make things<br>&gt;&gt;&gt; easy by default without locking away the power tools, and my personal<br>&gt;&gt;&gt; expectation is that if you have to write code that has binary operators<br>&gt;&gt;&gt; despite everything else that Swift has for you, you can be bothered to<br>&gt;&gt;&gt; learn a precedence rule.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That said, one thing that I could definitely get behind is breaking<br>&gt;&gt;&gt; precedence between binary operators and arithmetic operators. I don&#39;t think<br>&gt;&gt;&gt; that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my<br>&gt;&gt;&gt; code, the only place where I needed to mix binary operators and arithmetic<br>&gt;&gt;&gt; operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and<br>&gt;&gt;&gt; that one needs parentheses anyway.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Although here, your same argument applies. If you need to write `a &amp; b /<br>&gt;&gt; c`, then you can be bothered either to learn or look up a table, or you can<br>&gt;&gt; just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the<br>&gt;&gt; code, it&#39;s highly likely that this is a complex formula anyway; you can<br>&gt;&gt; either know the relative precedence or look it up, but that&#39;s the *least*<br>&gt;&gt; of your worries in terms of what it will take to understand that code. I<br>&gt;&gt; see no reason to force parentheses unless it actually prevents user error.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a<br>&gt;&gt;&gt; écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable to<br>&gt;&gt;&gt;&gt; arithmetic operators, and their precedence is easy to define as such. &amp; has<br>&gt;&gt;&gt;&gt; multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt;&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt;&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt;&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt;&gt;&gt; operators are not intervened by any others, except for comparison operators<br>&gt;&gt;&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt;&gt;&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another concern is NilCoalescing, which can be though to be semantically<br>&gt;&gt;&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt;&gt;&gt; would bring it between LogicalConjunction and Comparison.<br>&gt;&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put operators<br>&gt;&gt;&gt; in this precedence group, because it would be confusing. Why not simplify<br>&gt;&gt;&gt; our model and say that ?: has lower precedence than all binary operators,<br>&gt;&gt;&gt; including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/c9d0a0db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>August  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 10:30 AM, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Speaking for myself, I will *never* remember which of `&amp;&amp;` and `||` has higher precedence.<br></p><p>I had the opposite experience. The point here is don’t rob others for our own conveniences, which are definitionally subjective.<br></p><p>&gt; I think of them as peers, so I always use parentheses around them, and whenever I read code that mingles them without parentheses its meaning is *unclear* to me.<br>&gt; <br>&gt; One of Swift’s main goals is clarity at the point of use. After all, code is read far more often than it is written. To me, an expression like `a &amp;&amp; b || c &amp;&amp; d` is not clear when I read it.<br>&gt; <br>&gt; The same goes for bitwise operators: I view them as peers. I do not think of them as “additive” or “multiplicative” (and definitely not “subtractive”), so code that relies on their precedences will always send me scrambling to look up which comes first.<br>&gt; <br>&gt; Certainly something like `a + b | c &amp; d - e * f ^ g` is meaningless to me without parentheses.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 12:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; That&#39;s an excellent point, actually. Would there be downsides not yet considered?<br>&gt; <br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; These expressions mix two types of logic that have different implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;, except that `a * 16` will crash on overflow. In these cases, I find that grouping provides some visual insulation that groups off the somewhat subtle differences.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be looking for. There is nothing intuitive about multiplications having a higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m not a maths expert (as Stephen showed, I didn&#39;t even give the right explanation to binary operators!), but it seems to me that there could well be a parallel universe in which additions have precedence over multiplications without other serious implications.<br>&gt;&gt; <br>&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one for binary operators. I believe that the right question should be: do we want to pretend that this convention doesn&#39;t exist, to the benefit of people who don&#39;t know about it, and the detriment of those who do? Also, do we want to break it for &amp;&amp; and || too?<br>&gt;&gt; <br>&gt;&gt; I think that the biggest use case for binary operators in other languages are flags, and in Swift we treat these as collections. I&#39;d venture that &amp;, | and ^ would show up about as frequently as UnsafePointers and the like. It seems to me that Swift&#39;s approach has been to make things easy by default without locking away the power tools, and my personal expectation is that if you have to write code that has binary operators despite everything else that Swift has for you, you can be bothered to learn a precedence rule.<br>&gt;&gt; <br>&gt;&gt; That said, one thing that I could definitely get behind is breaking precedence between binary operators and arithmetic operators. I don&#39;t think that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my code, the only place where I needed to mix binary operators and arithmetic operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and that one needs parentheses anyway.<br>&gt;&gt; <br>&gt;&gt; Although here, your same argument applies. If you need to write `a &amp; b / c`, then you can be bothered either to learn or look up a table, or you can just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the code, it&#39;s highly likely that this is a complex formula anyway; you can either know the relative precedence or look it up, but that&#39;s the *least* of your worries in terms of what it will take to understand that code. I see no reason to force parentheses unless it actually prevents user error.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable to arithmetic operators, and their precedence is easy to define as such. &amp; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise operators are not intervened by any others, except for comparison operators (agreed, it was a mistake). We now have possibilities to do so in Swift, even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another concern is NilCoalescing, which can be though to be semantically similar to Ternary. And at the same time it looks like || and &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt;&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put operators in this precedence group, because it would be confusing. Why not simplify our model and say that ?: has lower precedence than all binary operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good? <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/bec6c3a7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>This is an expansive argument you advance. Should users be expected to<br>learn *any* rules of precedence beyond those of basic arithmetic? It would<br>seem that you are arguing no. Yet Swift just went through an arduous<br>redesign to permit--nay, improve--exactly that.<br>On Tue, Aug 2, 2016 at 12:30 Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; Speaking for myself, I will *never* remember which of `&amp;&amp;` and `||` has<br>&gt; higher precedence. I think of them as peers, so I always use parentheses<br>&gt; around them, and whenever I read code that mingles them without parentheses<br>&gt; its meaning is *unclear* to me.<br>&gt;<br>&gt; One of Swift’s main goals is clarity at the point of use. After all, code<br>&gt; is read far more often than it is written. To me, an expression like `a &amp;&amp;<br>&gt; b || c &amp;&amp; d` is not clear when I read it.<br>&gt;<br>&gt; The same goes for bitwise operators: I view them as peers. I do not think<br>&gt; of them as “additive” or “multiplicative” (and definitely not<br>&gt; “subtractive”), so code that relies on their precedences will always send<br>&gt; me scrambling to look up which comes first.<br>&gt;<br>&gt; Certainly something like `a + b | c &amp; d - e * f ^ g` is meaningless to me<br>&gt; without parentheses.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 12:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; That&#39;s an excellent point, actually. Would there be downsides not yet<br>&gt;&gt; considered?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; These expressions mix two types of logic that have different<br>&gt;&gt;&gt; implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;,<br>&gt;&gt;&gt; except that `a * 16` will crash on overflow. In these cases, I find that<br>&gt;&gt;&gt; grouping provides some visual insulation that groups off the somewhat<br>&gt;&gt;&gt; subtle differences.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be<br>&gt;&gt;&gt;&gt; looking for. There is nothing intuitive about multiplications having a<br>&gt;&gt;&gt;&gt; higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m<br>&gt;&gt;&gt;&gt; not a maths expert (as Stephen showed, I didn&#39;t even give the right<br>&gt;&gt;&gt;&gt; explanation to binary operators!), but it seems to me that there could well<br>&gt;&gt;&gt;&gt; be a parallel universe in which additions have precedence over<br>&gt;&gt;&gt;&gt; multiplications without other serious implications.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one<br>&gt;&gt;&gt;&gt; for binary operators. I believe that the right question should be: do we<br>&gt;&gt;&gt;&gt; want to pretend that this convention doesn&#39;t exist, to the benefit of<br>&gt;&gt;&gt;&gt; people who don&#39;t know about it, and the detriment of those who do? Also, do<br>&gt;&gt;&gt;&gt; we want to break it for &amp;&amp; and || too?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think that the biggest use case for binary operators in other<br>&gt;&gt;&gt;&gt; languages are flags, and in Swift we treat these as collections. I&#39;d<br>&gt;&gt;&gt;&gt; venture that &amp;, | and ^ would show up about as frequently as UnsafePointers<br>&gt;&gt;&gt;&gt; and the like. It seems to me that Swift&#39;s approach has been to make things<br>&gt;&gt;&gt;&gt; easy by default without locking away the power tools, and my personal<br>&gt;&gt;&gt;&gt; expectation is that if you have to write code that has binary operators<br>&gt;&gt;&gt;&gt; despite everything else that Swift has for you, you can be bothered to<br>&gt;&gt;&gt;&gt; learn a precedence rule.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That said, one thing that I could definitely get behind is breaking<br>&gt;&gt;&gt;&gt; precedence between binary operators and arithmetic operators. I don&#39;t think<br>&gt;&gt;&gt;&gt; that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my<br>&gt;&gt;&gt;&gt; code, the only place where I needed to mix binary operators and arithmetic<br>&gt;&gt;&gt;&gt; operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and<br>&gt;&gt;&gt;&gt; that one needs parentheses anyway.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Although here, your same argument applies. If you need to write `a &amp; b /<br>&gt;&gt;&gt; c`, then you can be bothered either to learn or look up a table, or you can<br>&gt;&gt;&gt; just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the<br>&gt;&gt;&gt; code, it&#39;s highly likely that this is a complex formula anyway; you can<br>&gt;&gt;&gt; either know the relative precedence or look it up, but that&#39;s the *least*<br>&gt;&gt;&gt; of your worries in terms of what it will take to understand that code. I<br>&gt;&gt;&gt; see no reason to force parentheses unless it actually prevents user error.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a<br>&gt;&gt;&gt;&gt; écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable<br>&gt;&gt;&gt;&gt;&gt; to arithmetic operators, and their precedence is easy to define as such. &amp;<br>&gt;&gt;&gt;&gt;&gt; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt;&gt;&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt;&gt;&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt;&gt;&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt;&gt;&gt;&gt; operators are not intervened by any others, except for comparison operators<br>&gt;&gt;&gt;&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt;&gt;&gt;&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt;&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another concern is NilCoalescing, which can be though to be<br>&gt;&gt;&gt;&gt; semantically similar to Ternary. And at the same time it looks like || and<br>&gt;&gt;&gt;&gt; &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt;&gt;&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put<br>&gt;&gt;&gt;&gt; operators in this precedence group, because it would be confusing. Why not<br>&gt;&gt;&gt;&gt; simplify our model and say that ?: has lower precedence than all binary<br>&gt;&gt;&gt;&gt; operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/3fb5282a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>@Xiaodi<br>Actually, I think just about all the rest of the precedence rules “make<br>sense” intuitively:<br></p><p>`a | b == c % d`<br>`a &lt; b ? c : d * e`<br>`a ?? b - c`<br>`a...b+c`<br></p><p>These all do what they ought to, and of course assignment naturally has low<br>precedence. Really the only confusing ones are operators that “seem like<br>peers” but actually have different precedences. Namely the two groups I<br>mentioned: logical operators and bitwise operators.<br></p><p>@Daniel<br>Making it easy to write code that is unclear to other people who read it,<br>is an explicit anti-goal for Swift.<br></p><p>Nevin<br></p><p><br>On Tue, Aug 2, 2016 at 1:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; This is an expansive argument you advance. Should users be expected to<br>&gt; learn *any* rules of precedence beyond those of basic arithmetic? It would<br>&gt; seem that you are arguing no. Yet Swift just went through an arduous<br>&gt; redesign to permit--nay, improve--exactly that.<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 12:30 Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Speaking for myself, I will *never* remember which of `&amp;&amp;` and `||` has<br>&gt;&gt; higher precedence. I think of them as peers, so I always use parentheses<br>&gt;&gt; around them, and whenever I read code that mingles them without parentheses<br>&gt;&gt; its meaning is *unclear* to me.<br>&gt;&gt;<br>&gt;&gt; One of Swift’s main goals is clarity at the point of use. After all, code<br>&gt;&gt; is read far more often than it is written. To me, an expression like `a &amp;&amp;<br>&gt;&gt; b || c &amp;&amp; d` is not clear when I read it.<br>&gt;&gt;<br>&gt;&gt; The same goes for bitwise operators: I view them as peers. I do not think<br>&gt;&gt; of them as “additive” or “multiplicative” (and definitely not<br>&gt;&gt; “subtractive”), so code that relies on their precedences will always send<br>&gt;&gt; me scrambling to look up which comes first.<br>&gt;&gt;<br>&gt;&gt; Certainly something like `a + b | c &amp; d - e * f ^ g` is meaningless to me<br>&gt;&gt; without parentheses.<br>&gt;&gt;<br>&gt;&gt; Nevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 12:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; That&#39;s an excellent point, actually. Would there be downsides not yet<br>&gt;&gt;&gt; considered?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; These expressions mix two types of logic that have different<br>&gt;&gt;&gt;&gt; implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;,<br>&gt;&gt;&gt;&gt; except that `a * 16` will crash on overflow. In these cases, I find that<br>&gt;&gt;&gt;&gt; grouping provides some visual insulation that groups off the somewhat<br>&gt;&gt;&gt;&gt; subtle differences.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be<br>&gt;&gt;&gt;&gt;&gt; looking for. There is nothing intuitive about multiplications having a<br>&gt;&gt;&gt;&gt;&gt; higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m<br>&gt;&gt;&gt;&gt;&gt; not a maths expert (as Stephen showed, I didn&#39;t even give the right<br>&gt;&gt;&gt;&gt;&gt; explanation to binary operators!), but it seems to me that there could well<br>&gt;&gt;&gt;&gt;&gt; be a parallel universe in which additions have precedence over<br>&gt;&gt;&gt;&gt;&gt; multiplications without other serious implications.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one<br>&gt;&gt;&gt;&gt;&gt; for binary operators. I believe that the right question should be: do we<br>&gt;&gt;&gt;&gt;&gt; want to pretend that this convention doesn&#39;t exist, to the benefit of<br>&gt;&gt;&gt;&gt;&gt; people who don&#39;t know about it, and the detriment of those who do? Also, do<br>&gt;&gt;&gt;&gt;&gt; we want to break it for &amp;&amp; and || too?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think that the biggest use case for binary operators in other<br>&gt;&gt;&gt;&gt;&gt; languages are flags, and in Swift we treat these as collections. I&#39;d<br>&gt;&gt;&gt;&gt;&gt; venture that &amp;, | and ^ would show up about as frequently as UnsafePointers<br>&gt;&gt;&gt;&gt;&gt; and the like. It seems to me that Swift&#39;s approach has been to make things<br>&gt;&gt;&gt;&gt;&gt; easy by default without locking away the power tools, and my personal<br>&gt;&gt;&gt;&gt;&gt; expectation is that if you have to write code that has binary operators<br>&gt;&gt;&gt;&gt;&gt; despite everything else that Swift has for you, you can be bothered to<br>&gt;&gt;&gt;&gt;&gt; learn a precedence rule.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That said, one thing that I could definitely get behind is breaking<br>&gt;&gt;&gt;&gt;&gt; precedence between binary operators and arithmetic operators. I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt; that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my<br>&gt;&gt;&gt;&gt;&gt; code, the only place where I needed to mix binary operators and arithmetic<br>&gt;&gt;&gt;&gt;&gt; operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and<br>&gt;&gt;&gt;&gt;&gt; that one needs parentheses anyway.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Although here, your same argument applies. If you need to write `a &amp; b<br>&gt;&gt;&gt;&gt; / c`, then you can be bothered either to learn or look up a table, or you<br>&gt;&gt;&gt;&gt; can just put in the parenthesis yourself. Likewise, if you&#39;re a reader of<br>&gt;&gt;&gt;&gt; the code, it&#39;s highly likely that this is a complex formula anyway; you can<br>&gt;&gt;&gt;&gt; either know the relative precedence or look it up, but that&#39;s the *least*<br>&gt;&gt;&gt;&gt; of your worries in terms of what it will take to understand that code. I<br>&gt;&gt;&gt;&gt; see no reason to force parentheses unless it actually prevents user error.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a<br>&gt;&gt;&gt;&gt;&gt; écrit :<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable<br>&gt;&gt;&gt;&gt;&gt;&gt; to arithmetic operators, and their precedence is easy to define as such. &amp;<br>&gt;&gt;&gt;&gt;&gt;&gt; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt;&gt;&gt;&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt;&gt;&gt;&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt;&gt;&gt;&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt;&gt;&gt;&gt;&gt; operators are not intervened by any others, except for comparison operators<br>&gt;&gt;&gt;&gt;&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt;&gt;&gt;&gt;&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt;&gt;&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Another concern is NilCoalescing, which can be though to be<br>&gt;&gt;&gt;&gt;&gt; semantically similar to Ternary. And at the same time it looks like || and<br>&gt;&gt;&gt;&gt;&gt; &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt;&gt;&gt;&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put<br>&gt;&gt;&gt;&gt;&gt; operators in this precedence group, because it would be confusing. Why not<br>&gt;&gt;&gt;&gt;&gt; simplify our model and say that ?: has lower precedence than all binary<br>&gt;&gt;&gt;&gt;&gt; operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/84d26abb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, Aug 2, 2016 at 1:09 PM, Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; @Xiaodi<br>&gt; Actually, I think just about all the rest of the precedence rules “make<br>&gt; sense” intuitively:<br>&gt;<br></p><p>Disagree vehemently. See below:<br></p><p><br>&gt; `a | b == c % d`<br>&gt; `a &lt; b ? c : d * e`<br>&gt;<br></p><p>I, like you, know what this means; but it is out of habit, not intuition.<br>There have been people *on this very list* who have argued in the past that<br>ternary operator precedence is unintuitive and that parentheses should be<br>required. To them, the more intuitive (and counterfactual) meaning of the<br>above is`a &lt; (b ? c : d) * e`.<br></p><p><br>&gt; `a ?? b - c`<br>&gt;<br></p><p>Here, I&#39;m in the exact scenario you mentioned about bitwise operators. I<br>literally do not recall, staring at this statement, whether it&#39;s `(a ?? b)<br>- c` or `a ?? (b - c)`. I actually look this up every time.<br></p><p><br>&gt; `a...b+c`<br>&gt;<br>&gt; These all do what they ought to, and of course assignment naturally has<br>&gt; low precedence.<br>&gt;<br></p><p>Naturally. Also, essentially how it works in math.<br></p><p><br>&gt; Really the only confusing ones are operators that “seem like peers” but<br>&gt; actually have different precedences. Namely the two groups I mentioned:<br>&gt; logical operators and bitwise operators.<br>&gt;<br></p><p>Which brings me to my original question: aren&#39;t you really saying that<br>people should not be required to *learn* any rules of precedence beyond<br>those of basic arithmetic? Put another way, unless you learned it in<br>elementary school math or can &quot;intuit&quot; the result--usually because the<br>alternative interpretations wouldn&#39;t even typecheck--then there should be<br>no precedence relationship?<br></p><p><br>&gt;<br>&gt; @Daniel<br>&gt; Making it easy to write code that is unclear to other people who read it,<br>&gt; is an explicit anti-goal for Swift.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 1:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; This is an expansive argument you advance. Should users be expected to<br>&gt;&gt; learn *any* rules of precedence beyond those of basic arithmetic? It would<br>&gt;&gt; seem that you are arguing no. Yet Swift just went through an arduous<br>&gt;&gt; redesign to permit--nay, improve--exactly that.<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 12:30 Nevin Brackett-Rozinsky &lt;<br>&gt;&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Speaking for myself, I will *never* remember which of `&amp;&amp;` and `||` has<br>&gt;&gt;&gt; higher precedence. I think of them as peers, so I always use parentheses<br>&gt;&gt;&gt; around them, and whenever I read code that mingles them without parentheses<br>&gt;&gt;&gt; its meaning is *unclear* to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One of Swift’s main goals is clarity at the point of use. After all,<br>&gt;&gt;&gt; code is read far more often than it is written. To me, an expression like<br>&gt;&gt;&gt; `a &amp;&amp; b || c &amp;&amp; d` is not clear when I read it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The same goes for bitwise operators: I view them as peers. I do not<br>&gt;&gt;&gt; think of them as “additive” or “multiplicative” (and definitely not<br>&gt;&gt;&gt; “subtractive”), so code that relies on their precedences will always send<br>&gt;&gt;&gt; me scrambling to look up which comes first.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Certainly something like `a + b | c &amp; d - e * f ^ g` is meaningless to<br>&gt;&gt;&gt; me without parentheses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 2, 2016 at 12:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s an excellent point, actually. Would there be downsides not yet<br>&gt;&gt;&gt;&gt; considered?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; These expressions mix two types of logic that have different<br>&gt;&gt;&gt;&gt;&gt; implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;,<br>&gt;&gt;&gt;&gt;&gt; except that `a * 16` will crash on overflow. In these cases, I find that<br>&gt;&gt;&gt;&gt;&gt; grouping provides some visual insulation that groups off the somewhat<br>&gt;&gt;&gt;&gt;&gt; subtle differences.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be<br>&gt;&gt;&gt;&gt;&gt;&gt; looking for. There is nothing intuitive about multiplications having a<br>&gt;&gt;&gt;&gt;&gt;&gt; higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt; not a maths expert (as Stephen showed, I didn&#39;t even give the right<br>&gt;&gt;&gt;&gt;&gt;&gt; explanation to binary operators!), but it seems to me that there could well<br>&gt;&gt;&gt;&gt;&gt;&gt; be a parallel universe in which additions have precedence over<br>&gt;&gt;&gt;&gt;&gt;&gt; multiplications without other serious implications.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one<br>&gt;&gt;&gt;&gt;&gt;&gt; for binary operators. I believe that the right question should be: do we<br>&gt;&gt;&gt;&gt;&gt;&gt; want to pretend that this convention doesn&#39;t exist, to the benefit of<br>&gt;&gt;&gt;&gt;&gt;&gt; people who don&#39;t know about it, and the detriment of those who do? Also, do<br>&gt;&gt;&gt;&gt;&gt;&gt; we want to break it for &amp;&amp; and || too?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I think that the biggest use case for binary operators in other<br>&gt;&gt;&gt;&gt;&gt;&gt; languages are flags, and in Swift we treat these as collections. I&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; venture that &amp;, | and ^ would show up about as frequently as UnsafePointers<br>&gt;&gt;&gt;&gt;&gt;&gt; and the like. It seems to me that Swift&#39;s approach has been to make things<br>&gt;&gt;&gt;&gt;&gt;&gt; easy by default without locking away the power tools, and my personal<br>&gt;&gt;&gt;&gt;&gt;&gt; expectation is that if you have to write code that has binary operators<br>&gt;&gt;&gt;&gt;&gt;&gt; despite everything else that Swift has for you, you can be bothered to<br>&gt;&gt;&gt;&gt;&gt;&gt; learn a precedence rule.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That said, one thing that I could definitely get behind is breaking<br>&gt;&gt;&gt;&gt;&gt;&gt; precedence between binary operators and arithmetic operators. I don&#39;t think<br>&gt;&gt;&gt;&gt;&gt;&gt; that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my<br>&gt;&gt;&gt;&gt;&gt;&gt; code, the only place where I needed to mix binary operators and arithmetic<br>&gt;&gt;&gt;&gt;&gt;&gt; operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and<br>&gt;&gt;&gt;&gt;&gt;&gt; that one needs parentheses anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Although here, your same argument applies. If you need to write `a &amp; b<br>&gt;&gt;&gt;&gt;&gt; / c`, then you can be bothered either to learn or look up a table, or you<br>&gt;&gt;&gt;&gt;&gt; can just put in the parenthesis yourself. Likewise, if you&#39;re a reader of<br>&gt;&gt;&gt;&gt;&gt; the code, it&#39;s highly likely that this is a complex formula anyway; you can<br>&gt;&gt;&gt;&gt;&gt; either know the relative precedence or look it up, but that&#39;s the *least*<br>&gt;&gt;&gt;&gt;&gt; of your worries in terms of what it will take to understand that code. I<br>&gt;&gt;&gt;&gt;&gt; see no reason to force parentheses unless it actually prevents user error.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; a<br>&gt;&gt;&gt;&gt;&gt;&gt; écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to arithmetic operators, and their precedence is easy to define as such. &amp;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise<br>&gt;&gt;&gt;&gt;&gt;&gt; operators are not intervened by any others, except for comparison operators<br>&gt;&gt;&gt;&gt;&gt;&gt; (agreed, it was a mistake). We now have possibilities to do so in Swift,<br>&gt;&gt;&gt;&gt;&gt;&gt; even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt;&gt;&gt;&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Another concern is NilCoalescing, which can be though to be<br>&gt;&gt;&gt;&gt;&gt;&gt; semantically similar to Ternary. And at the same time it looks like || and<br>&gt;&gt;&gt;&gt;&gt;&gt; &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt;&gt;&gt;&gt;&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put<br>&gt;&gt;&gt;&gt;&gt;&gt; operators in this precedence group, because it would be confusing. Why not<br>&gt;&gt;&gt;&gt;&gt;&gt; simplify our model and say that ?: has lower precedence than all binary<br>&gt;&gt;&gt;&gt;&gt;&gt; operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/912d8a48/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 09:00:00pm</p></header><div class="content"><p>2016-08-02 21:09 GMT+03:00 Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt;:<br></p><p>&gt; @Xiaodi<br>&gt; Actually, I think just about all the rest of the precedence rules “make<br>&gt; sense” intuitively:<br>&gt;<br>&gt; `a | b == c % d`<br>&gt; `a &lt; b ? c : d * e`<br>&gt; `a ?? b - c`<br>&gt; `a...b+c`<br>&gt;<br>&gt; These all do what they ought to, and of course assignment naturally has<br>&gt; low precedence. Really the only confusing ones are operators that “seem<br>&gt; like peers” but actually have different precedences. Namely the two groups<br>&gt; I mentioned: logical operators and bitwise operators.<br>&gt;<br>&gt; @Daniel<br>&gt; Making it easy to write code that is unclear to other people who read it,<br>&gt; is an explicit anti-goal for Swift.<br>&gt;<br></p><p>Here&#39;s another possible plan:<br>https://gist.github.com/Anton3/e00026409a6f948ca3ba41acf24e9672<br></p><p>There is a base line of &quot;core&quot;, control-like operators, which everyone must<br>know. &quot;Applied&quot; operators are branched off them. For example, Ternary,<br>Comparison or Casting can be selected as base for a new mini-tree of<br>related operators.<br></p><p>Following this scheme, there are at least 3 &quot;applied&quot; domains with<br>operators: arithmetic, bitwise and range formation. You can see result in<br>the gist.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/6cd1207a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I can sort of see what this is getting at, but I simply have no way of<br>evaluating whether it&#39;s sensible or not without actual examples in code.<br>This is, again, a more expansive change than discussed. I&#39;d be interested<br>in seeing your write-up on separating arithmetic and bitwise/bitshift<br>operators :)<br></p><p>On Tue, Aug 2, 2016 at 1:36 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-02 21:09 GMT+03:00 Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt;:<br>&gt;<br>&gt;&gt; @Xiaodi<br>&gt;&gt; Actually, I think just about all the rest of the precedence rules “make<br>&gt;&gt; sense” intuitively:<br>&gt;&gt;<br>&gt;&gt; `a | b == c % d`<br>&gt;&gt; `a &lt; b ? c : d * e`<br>&gt;&gt; `a ?? b - c`<br>&gt;&gt; `a...b+c`<br>&gt;&gt;<br>&gt;&gt; These all do what they ought to, and of course assignment naturally has<br>&gt;&gt; low precedence. Really the only confusing ones are operators that “seem<br>&gt;&gt; like peers” but actually have different precedences. Namely the two groups<br>&gt;&gt; I mentioned: logical operators and bitwise operators.<br>&gt;&gt;<br>&gt;&gt; @Daniel<br>&gt;&gt; Making it easy to write code that is unclear to other people who read it,<br>&gt;&gt; is an explicit anti-goal for Swift.<br>&gt;&gt;<br>&gt;<br>&gt; Here&#39;s another possible plan:<br>&gt; https://gist.github.com/Anton3/e00026409a6f948ca3ba41acf24e9672<br>&gt;<br>&gt; There is a base line of &quot;core&quot;, control-like operators, which everyone<br>&gt; must know. &quot;Applied&quot; operators are branched off them. For example, Ternary,<br>&gt; Comparison or Casting can be selected as base for a new mini-tree of<br>&gt; related operators.<br>&gt;<br>&gt; Following this scheme, there are at least 3 &quot;applied&quot; domains with<br>&gt; operators: arithmetic, bitwise and range formation. You can see result in<br>&gt; the gist.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/a0f41a1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 10:00:00pm</p></header><div class="content"><p>2016-08-02 21:56 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; I can sort of see what this is getting at, but I simply have no way of<br>&gt; evaluating whether it&#39;s sensible or not without actual examples in code.<br>&gt; This is, again, a more expansive change than discussed. I&#39;d be interested<br>&gt; in seeing your write-up on separating arithmetic and bitwise/bitshift<br>&gt; operators :)<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 1:36 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Here&#39;s another possible plan:<br>&gt;&gt; https://gist.github.com/Anton3/e00026409a6f948ca3ba41acf24e9672<br>&gt;&gt;<br>&gt;&gt; There is a base line of &quot;core&quot;, control-like operators, which everyone<br>&gt;&gt; must know. &quot;Applied&quot; operators are branched off them. For example, Ternary,<br>&gt;&gt; Comparison or Casting can be selected as base for a new mini-tree of<br>&gt;&gt; related operators.<br>&gt;&gt;<br>&gt;&gt; Following this scheme, there are at least 3 &quot;applied&quot; domains with<br>&gt;&gt; operators: arithmetic, bitwise and range formation. You can see result in<br>&gt;&gt; the gist.<br>&gt;&gt;<br>&gt;<br>Well, I don&#39;t suggest changing precedence relationships there (just<br>removing some), so that should be on-topic, I guess?<br></p><p>The main change I suggest over separating bitwise operators is separating<br>RangeFormation, because it&#39;s a separate, &quot;applied&quot; operator domain. It is<br>not control-structure-like, so it does not deserve to be in the main tree.<br></p><p>Simplifying even more, I want to prohibit this:  a...b+c<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/34d356ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 07:00:00pm</p></header><div class="content"><p>What&#39;s the benefit? Is there anyone confused by a...b+c?<br>On Tue, Aug 2, 2016 at 14:13 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-02 21:56 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; I can sort of see what this is getting at, but I simply have no way of<br>&gt;&gt; evaluating whether it&#39;s sensible or not without actual examples in code.<br>&gt;&gt; This is, again, a more expansive change than discussed. I&#39;d be interested<br>&gt;&gt; in seeing your write-up on separating arithmetic and bitwise/bitshift<br>&gt;&gt; operators :)<br>&gt;&gt;<br>&gt; On Tue, Aug 2, 2016 at 1:36 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt; Here&#39;s another possible plan:<br>&gt;&gt;&gt; https://gist.github.com/Anton3/e00026409a6f948ca3ba41acf24e9672<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is a base line of &quot;core&quot;, control-like operators, which everyone<br>&gt;&gt;&gt; must know. &quot;Applied&quot; operators are branched off them. For example, Ternary,<br>&gt;&gt;&gt; Comparison or Casting can be selected as base for a new mini-tree of<br>&gt;&gt;&gt; related operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Following this scheme, there are at least 3 &quot;applied&quot; domains with<br>&gt;&gt;&gt; operators: arithmetic, bitwise and range formation. You can see result in<br>&gt;&gt;&gt; the gist.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; Well, I don&#39;t suggest changing precedence relationships there (just<br>&gt; removing some), so that should be on-topic, I guess?<br>&gt;<br>&gt; The main change I suggest over separating bitwise operators is separating<br>&gt; RangeFormation, because it&#39;s a separate, &quot;applied&quot; operator domain. It is<br>&gt; not control-structure-like, so it does not deserve to be in the main tree.<br>&gt;<br>&gt; Simplifying even more, I want to prohibit this:  a...b+c<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/19359bff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 10:00:00pm</p></header><div class="content"><p>If operator &lt;+&gt; is used in one domain area, and operator &lt;-&gt; is used in<br>another domain area, then we should not make everyone keep in mind both<br>domain areas simultaneously.<br></p><p>Another explanation: operator ... does not belong to &quot;core&quot;, &quot;control&quot;<br>operators, it belongs to Ranges part of standard library. Likewise, +<br>operates on numbers. Therefore they should not have precedence relationship.<br></p><p>Yet another explanation: I believe that optionals and booleans are a lot<br>more fundamental in Swift than ranges. Ranges don&#39;t have any support in<br>language itself, they belong to standard library.<br></p><p>2016-08-02 22:19 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; What&#39;s the benefit? Is there anyone confused by a...b+c?<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 14:13 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; 2016-08-02 21:56 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; I can sort of see what this is getting at, but I simply have no way of<br>&gt;&gt;&gt; evaluating whether it&#39;s sensible or not without actual examples in code.<br>&gt;&gt;&gt; This is, again, a more expansive change than discussed. I&#39;d be interested<br>&gt;&gt;&gt; in seeing your write-up on separating arithmetic and bitwise/bitshift<br>&gt;&gt;&gt; operators :)<br>&gt;&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 1:36 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt; Here&#39;s another possible plan:<br>&gt;&gt;&gt;&gt; https://gist.github.com/Anton3/e00026409a6f948ca3ba41acf24e9672<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There is a base line of &quot;core&quot;, control-like operators, which everyone<br>&gt;&gt;&gt;&gt; must know. &quot;Applied&quot; operators are branched off them. For example, Ternary,<br>&gt;&gt;&gt;&gt; Comparison or Casting can be selected as base for a new mini-tree of<br>&gt;&gt;&gt;&gt; related operators.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Following this scheme, there are at least 3 &quot;applied&quot; domains with<br>&gt;&gt;&gt;&gt; operators: arithmetic, bitwise and range formation. You can see result in<br>&gt;&gt;&gt;&gt; the gist.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Well, I don&#39;t suggest changing precedence relationships there (just<br>&gt;&gt; removing some), so that should be on-topic, I guess?<br>&gt;&gt;<br>&gt;&gt; The main change I suggest over separating bitwise operators is separating<br>&gt;&gt; RangeFormation, because it&#39;s a separate, &quot;applied&quot; operator domain. It is<br>&gt;&gt; not control-structure-like, so it does not deserve to be in the main tree.<br>&gt;&gt;<br>&gt;&gt; Simplifying even more, I want to prohibit this:  a...b+c<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/eb68dfd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m not sure how you&#39;re coming up with &quot;domain areas&quot;. Ranges have numbers<br>as bounds; those are typically computed by arithmetic.<br></p><p>Virtually the entire stdlib exists to support language features; all other<br>facilities found in other languages&#39; &quot;standard library&quot; are in Foundation.<br></p><p>As I mentioned, theoretical justifications have no sway with me. Show me<br>how a real user error is averted by such a change. I see none here; thus, I<br>disagree with the change.<br>On Tue, Aug 2, 2016 at 14:45 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; If operator &lt;+&gt; is used in one domain area, and operator &lt;-&gt; is used in<br>&gt; another domain area, then we should not make everyone keep in mind both<br>&gt; domain areas simultaneously.<br>&gt;<br>&gt; Another explanation: operator ... does not belong to &quot;core&quot;, &quot;control&quot;<br>&gt; operators, it belongs to Ranges part of standard library. Likewise, +<br>&gt; operates on numbers. Therefore they should not have precedence relationship.<br>&gt;<br>&gt; Yet another explanation: I believe that optionals and booleans are a lot<br>&gt; more fundamental in Swift than ranges. Ranges don&#39;t have any support in<br>&gt; language itself, they belong to standard library.<br>&gt;<br>&gt; 2016-08-02 22:19 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; What&#39;s the benefit? Is there anyone confused by a...b+c?<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 14:13 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; 2016-08-02 21:56 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I can sort of see what this is getting at, but I simply have no way of<br>&gt;&gt;&gt;&gt; evaluating whether it&#39;s sensible or not without actual examples in code.<br>&gt;&gt;&gt;&gt; This is, again, a more expansive change than discussed. I&#39;d be interested<br>&gt;&gt;&gt;&gt; in seeing your write-up on separating arithmetic and bitwise/bitshift<br>&gt;&gt;&gt;&gt; operators :)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 2, 2016 at 1:36 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Here&#39;s another possible plan:<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/Anton3/e00026409a6f948ca3ba41acf24e9672<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There is a base line of &quot;core&quot;, control-like operators, which everyone<br>&gt;&gt;&gt;&gt;&gt; must know. &quot;Applied&quot; operators are branched off them. For example, Ternary,<br>&gt;&gt;&gt;&gt;&gt; Comparison or Casting can be selected as base for a new mini-tree of<br>&gt;&gt;&gt;&gt;&gt; related operators.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Following this scheme, there are at least 3 &quot;applied&quot; domains with<br>&gt;&gt;&gt;&gt;&gt; operators: arithmetic, bitwise and range formation. You can see result in<br>&gt;&gt;&gt;&gt;&gt; the gist.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Well, I don&#39;t suggest changing precedence relationships there (just<br>&gt;&gt;&gt; removing some), so that should be on-topic, I guess?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main change I suggest over separating bitwise operators is<br>&gt;&gt;&gt; separating RangeFormation, because it&#39;s a separate, &quot;applied&quot; operator<br>&gt;&gt;&gt; domain. It is not control-structure-like, so it does not deserve to be in<br>&gt;&gt;&gt; the main tree.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Simplifying even more, I want to prohibit this:  a...b+c<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/84ccaacb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 11:00:00pm</p></header><div class="content"><p>2016-08-02 23:06 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; I&#39;m not sure how you&#39;re coming up with &quot;domain areas&quot;. Ranges have numbers<br>&gt; as bounds; those are typically computed by arithmetic.<br>&gt;<br>&gt; Virtually the entire stdlib exists to support language features; all other<br>&gt; facilities found in other languages&#39; &quot;standard library&quot; are in Foundation.<br>&gt;<br>&gt; As I mentioned, theoretical justifications have no sway with me. Show me<br>&gt; how a real user error is averted by such a change. I see none here; thus, I<br>&gt; disagree with the change.<br></p><p><br>Okay, I&#39;m creating a proposal for branching off binary operators, and after<br>that I&#39;ll try to do a separate proposal for my crazy ideas :)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/de2a8b06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Let me give you theoretical basis for why I&#39;m +0.5 on branching off binary<br>operators but not these other ones. Félix is absolutely right that `a &lt;&lt; b<br>/ c` mixes two things. It&#39;s not merely that they&#39;re in two &quot;different&quot;<br>domains. It&#39;s that these two operators take the same values of the same<br>type and operate on them in fundamentally disparate ways.<br></p><p>This is a bad way of phrasing it, I know--let me try to clarify: the<br>operator `&lt;&lt;` operates on an integer as a fixed-length collection of bits;<br>the operator `/` operates on an integer as a number, an element in the set<br>of all integers. The practical consequence is that overflow behavior can be<br>subtly different; the overflow behavior of &lt;&lt; is &#39;obvious&#39; if you&#39;re<br>thinking about an integer as a fixed-length collection of bits but<br>surprising if you think of it as an integer being multiplied by an exponent<br>of two. Thus, it is best to separate operators that work on integers as a<br>collection of bits from the other numeric operators.<br></p><p>In no other of your proposed branches do I find the same fundamental<br>conflict.<br></p><p>On Tue, Aug 2, 2016 at 3:14 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-02 23:06 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; I&#39;m not sure how you&#39;re coming up with &quot;domain areas&quot;. Ranges have<br>&gt;&gt; numbers as bounds; those are typically computed by arithmetic.<br>&gt;&gt;<br>&gt;&gt; Virtually the entire stdlib exists to support language features; all<br>&gt;&gt; other facilities found in other languages&#39; &quot;standard library&quot; are in<br>&gt;&gt; Foundation.<br>&gt;&gt;<br>&gt;&gt; As I mentioned, theoretical justifications have no sway with me. Show me<br>&gt;&gt; how a real user error is averted by such a change. I see none here; thus, I<br>&gt;&gt; disagree with the change.<br>&gt;<br>&gt;<br>&gt; Okay, I&#39;m creating a proposal for branching off binary operators, and<br>&gt; after that I&#39;ll try to do a separate proposal for my crazy ideas :)<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/4f79e69c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  3, 2016 at 12:00:00am</p></header><div class="content"><p>Here is the proposal draft:<br>https://github.com/Anton3/swift-evolution/blob/remove-precedence-bitwise-arithmetic.md/proposals/NNNN-remove-precedence-bitwise-arithmetic.md<br></p><p>Motivation will be the most difficult section here.<br></p><p>2016-08-02 23:30 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; Let me give you theoretical basis for why I&#39;m +0.5 on branching off binary<br>&gt; operators but not these other ones. Félix is absolutely right that `a &lt;&lt; b<br>&gt; / c` mixes two things. It&#39;s not merely that they&#39;re in two &quot;different&quot;<br>&gt; domains. It&#39;s that these two operators take the same values of the same<br>&gt; type and operate on them in fundamentally disparate ways.<br>&gt;<br>&gt; This is a bad way of phrasing it, I know--let me try to clarify: the<br>&gt; operator `&lt;&lt;` operates on an integer as a fixed-length collection of bits;<br>&gt; the operator `/` operates on an integer as a number, an element in the set<br>&gt; of all integers. The practical consequence is that overflow behavior can be<br>&gt; subtly different; the overflow behavior of &lt;&lt; is &#39;obvious&#39; if you&#39;re<br>&gt; thinking about an integer as a fixed-length collection of bits but<br>&gt; surprising if you think of it as an integer being multiplied by an exponent<br>&gt; of two. Thus, it is best to separate operators that work on integers as a<br>&gt; collection of bits from the other numeric operators.<br>&gt;<br>&gt; In no other of your proposed branches do I find the same fundamental<br>&gt; conflict.<br>&gt;<br></p><p>And that argumentation seems insufficient to me. Assuming that everyone<br>knows precedence table, &#39;a &lt;&lt; b / c` should not be ambiguous. I&#39;d argue<br>that it&#39;s easy to understand that &lt;&lt; operation will overflow here and /<br>will not.<br>Instead, I suggest that these operations are so different that any<br>precedence relationship between them is meaningless (another wording of<br>explanation with domains).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/b421aa73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 09:00:00pm</p></header><div class="content"><p>It&#39;s not that &lt;&lt; will overflow and / will not. Substitute * for / and the<br>argument would be the same. The difference is that &lt;&lt; traps when you shift<br>more than the total number of bits but does *not* trap when you shift<br>numbers off as would arithmetic exponentiation; * traps on overflow. Thus,<br>what &lt;&lt; is concerned about is the bits (as it should), but * is concerned<br>about the max representable value.<br>On Tue, Aug 2, 2016 at 16:41 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; Here is the proposal draft:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/remove-precedence-bitwise-arithmetic.md/proposals/NNNN-remove-precedence-bitwise-arithmetic.md<br>&gt;<br>&gt; Motivation will be the most difficult section here.<br>&gt;<br>&gt; 2016-08-02 23:30 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; Let me give you theoretical basis for why I&#39;m +0.5 on branching off<br>&gt;&gt; binary operators but not these other ones. Félix is absolutely right that<br>&gt;&gt; `a &lt;&lt; b / c` mixes two things. It&#39;s not merely that they&#39;re in two<br>&gt;&gt; &quot;different&quot; domains. It&#39;s that these two operators take the same values of<br>&gt;&gt; the same type and operate on them in fundamentally disparate ways.<br>&gt;&gt;<br>&gt;&gt; This is a bad way of phrasing it, I know--let me try to clarify: the<br>&gt;&gt; operator `&lt;&lt;` operates on an integer as a fixed-length collection of bits;<br>&gt;&gt; the operator `/` operates on an integer as a number, an element in the set<br>&gt;&gt; of all integers. The practical consequence is that overflow behavior can be<br>&gt;&gt; subtly different; the overflow behavior of &lt;&lt; is &#39;obvious&#39; if you&#39;re<br>&gt;&gt; thinking about an integer as a fixed-length collection of bits but<br>&gt;&gt; surprising if you think of it as an integer being multiplied by an exponent<br>&gt;&gt; of two. Thus, it is best to separate operators that work on integers as a<br>&gt;&gt; collection of bits from the other numeric operators.<br>&gt;&gt;<br>&gt;&gt; In no other of your proposed branches do I find the same fundamental<br>&gt;&gt; conflict.<br>&gt;&gt;<br>&gt;<br>&gt; And that argumentation seems insufficient to me. Assuming that everyone<br>&gt; knows precedence table, &#39;a &lt;&lt; b / c` should not be ambiguous. I&#39;d argue<br>&gt; that it&#39;s easy to understand that &lt;&lt; operation will overflow here and /<br>&gt; will not.<br>&gt; Instead, I suggest that these operations are so different that any<br>&gt; precedence relationship between them is meaningless (another wording of<br>&gt; explanation with domains).<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/76fa1e11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  3, 2016 at 12:00:00am</p></header><div class="content"><p>2016-08-03 0:46 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; It&#39;s not that &lt;&lt; will overflow and / will not. Substitute * for / and the<br>&gt; argument would be the same. The difference is that &lt;&lt; traps when you shift<br>&gt; more than the total number of bits but does *not* trap when you shift<br>&gt; numbers off as would arithmetic exponentiation; * traps on overflow. Thus,<br>&gt; what &lt;&lt; is concerned about is the bits (as it should), but * is concerned<br>&gt; about the max representable value.<br></p><p><br>Substitute * for / and my argument would also be the same :)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/e95d197e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Well, there I disagree. All of these operations take integers and produce<br>other integers. As we&#39;ve discussed, the bitwise operators resemble<br>multiplication or addition in particular ways; not so different at all.<br>This is IMO a weak argument because you&#39;re arguing gradations of &quot;so<br>different&quot;, which is entirely subjective in the end.<br></p><p>What I&#39;m saying is that I would be mildly in favor of your proposal because<br>I can justify it on the basis of something black-and-white: conflicting<br>&quot;levels&quot; at which these operators work on integers (collection of bits vs.<br>element in the set of all integers) and the concomitant differences<br>regarding when these operators trap.<br>On Tue, Aug 2, 2016 at 16:49 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-03 0:46 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; It&#39;s not that &lt;&lt; will overflow and / will not. Substitute * for / and the<br>&gt;&gt; argument would be the same. The difference is that &lt;&lt; traps when you shift<br>&gt;&gt; more than the total number of bits but does *not* trap when you shift<br>&gt;&gt; numbers off as would arithmetic exponentiation; * traps on overflow. Thus,<br>&gt;&gt; what &lt;&lt; is concerned about is the bits (as it should), but * is concerned<br>&gt;&gt; about the max representable value.<br>&gt;<br>&gt;<br>&gt; Substitute * for / and my argument would also be the same :)<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/5ff118e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August  3, 2016 at 12:00:00am</p></header><div class="content"><p>C is my working language，I don&#39; want to remember too much rules for<br>operator, just use parentheses.<br></p><p>It&#39;s more reliable than the complicated rules.<br></p><p><br>Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月3日<br>周三05:55写道：<br></p><p>&gt; Well, there I disagree. All of these operations take integers and produce<br>&gt; other integers. As we&#39;ve discussed, the bitwise operators resemble<br>&gt; multiplication or addition in particular ways; not so different at all.<br>&gt; This is IMO a weak argument because you&#39;re arguing gradations of &quot;so<br>&gt; different&quot;, which is entirely subjective in the end.<br>&gt;<br>&gt; What I&#39;m saying is that I would be mildly in favor of your proposal<br>&gt; because I can justify it on the basis of something black-and-white:<br>&gt; conflicting &quot;levels&quot; at which these operators work on integers (collection<br>&gt; of bits vs. element in the set of all integers) and the concomitant<br>&gt; differences regarding when these operators trap.<br>&gt; On Tue, Aug 2, 2016 at 16:49 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; 2016-08-03 0:46 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; It&#39;s not that &lt;&lt; will overflow and / will not. Substitute * for / and<br>&gt;&gt;&gt; the argument would be the same. The difference is that &lt;&lt; traps when you<br>&gt;&gt;&gt; shift more than the total number of bits but does *not* trap when you shift<br>&gt;&gt;&gt; numbers off as would arithmetic exponentiation; * traps on overflow. Thus,<br>&gt;&gt;&gt; what &lt;&lt; is concerned about is the bits (as it should), but * is concerned<br>&gt;&gt;&gt; about the max representable value.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Substitute * for / and my argument would also be the same :)<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/3e107723/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  3, 2016 at 12:00:00am</p></header><div class="content"><p>I think we can all agree that you should be allowed to use parentheses<br>whenever it helps you to clarify your meaning. I can also assure you,<br>however, that when you really get into using these operators for heavy<br>math, nesting (((()))) also hinders clarity.<br></p><p>As always, the question of how much of this choice should be enforced by<br>the compiler and standard library is a nuanced discussion. C, at one<br>extreme, has flourished with a much more complicated set of precedence<br>rules and no enforcement of how parentheses are used. Swift can and already<br>does do better; now, the question is, are even more restrictions better?<br>How much more and how much better?<br></p><p>My personal opinion is that we have nearly the right amount of rules, with<br>maybe one or two more tweaks at most. Reason: any additional requirements<br>by the compiler and standard library cannot be optionally waived by the<br>user, but a user can always choose to add more parentheses than required.<br>Designers of Swift can help readers of code by _encouraging_ writers of<br>code to improve clarity, but in the end we must design the language for a<br>reasonably well-meaning writer; it&#39;s a fool&#39;s errand to try to use the<br>standard library to defend clarity against the wishes of an unwilling<br>writer.<br>On Tue, Aug 2, 2016 at 19:10 Boris Wang &lt;kona.ming at gmail.com&gt; wrote:<br></p><p>&gt; C is my working language，I don&#39; want to remember too much rules for<br>&gt; operator, just use parentheses.<br>&gt;<br>&gt; It&#39;s more reliable than the complicated rules.<br>&gt;<br>&gt;<br>&gt; Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月3日<br>&gt; 周三05:55写道：<br>&gt;<br>&gt;&gt; Well, there I disagree. All of these operations take integers and produce<br>&gt;&gt; other integers. As we&#39;ve discussed, the bitwise operators resemble<br>&gt;&gt; multiplication or addition in particular ways; not so different at all.<br>&gt;&gt; This is IMO a weak argument because you&#39;re arguing gradations of &quot;so<br>&gt;&gt; different&quot;, which is entirely subjective in the end.<br>&gt;&gt;<br>&gt;&gt; What I&#39;m saying is that I would be mildly in favor of your proposal<br>&gt;&gt; because I can justify it on the basis of something black-and-white:<br>&gt;&gt; conflicting &quot;levels&quot; at which these operators work on integers (collection<br>&gt;&gt; of bits vs. element in the set of all integers) and the concomitant<br>&gt;&gt; differences regarding when these operators trap.<br>&gt;&gt; On Tue, Aug 2, 2016 at 16:49 Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; 2016-08-03 0:46 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It&#39;s not that &lt;&lt; will overflow and / will not. Substitute * for / and<br>&gt;&gt;&gt;&gt; the argument would be the same. The difference is that &lt;&lt; traps when you<br>&gt;&gt;&gt;&gt; shift more than the total number of bits but does *not* trap when you shift<br>&gt;&gt;&gt;&gt; numbers off as would arithmetic exponentiation; * traps on overflow. Thus,<br>&gt;&gt;&gt;&gt; what &lt;&lt; is concerned about is the bits (as it should), but * is concerned<br>&gt;&gt;&gt;&gt; about the max representable value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Substitute * for / and my argument would also be the same :)<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;<br>&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/8a1d14db/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 2:41 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is the proposal draft:<br>&gt; https://github.com/Anton3/swift-evolution/blob/remove-precedence-bitwise-arithmetic.md/proposals/NNNN-remove-precedence-bitwise-arithmetic.md &lt;https://github.com/Anton3/swift-evolution/blob/remove-precedence-bitwise-arithmetic.md/proposals/NNNN-remove-precedence-bitwise-arithmetic.md&gt;<br>&gt; <br>&gt; Motivation will be the most difficult section here.<br></p><p>Yes, it will.  Some 2c to consider:<br></p><p>1) Swift 4 is being designed with the ability to all us to make “source changes&quot; that don’t break existing source code.<br></p><p>2) It is really important that we continue to polish the language to make it great for the long term, so the spirit of your proposal is great to explore.<br></p><p>3) That said, any source breaking change needs to be *very* strongly motivated.  To make this change, you should find evidence of common bugs that would be solved by this, evidence of actual user confusion in practice, etc.<br></p><p>4) Assuming all of the above works out, we still won’t be able to evaluate the proposal until we have the exact details of how the “source stability” model works.  Until we have that model, we don’t know that this proposal will be able to be covered by it.<br></p><p>On #4, I’m pretty certain that we will be fine, but until we have the model nailed down, we procedurally can’t even have the formal review period.  In any case, you need to build a specific proposal with very strong rationale first.  :-)<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/967741c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>August  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 11:09 AM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; @Xiaodi<br>&gt; Actually, I think just about all the rest of the precedence rules “make sense” intuitively:<br>&gt; <br>&gt; `a | b == c % d`<br>&gt; `a &lt; b ? c : d * e`<br>&gt; `a ?? b - c`<br>&gt; `a...b+c`<br>&gt; <br>&gt; These all do what they ought to, and of course assignment naturally has low precedence. Really the only confusing ones are operators that “seem like peers” but actually have different precedences. Namely the two groups I mentioned: logical operators and bitwise operators.<br>&gt; <br>&gt; @Daniel<br>&gt; Making it easy to write code that is unclear to other people who read it, is an explicit anti-goal for Swift.<br>&gt; <br></p><p>Again, one’s “easy” might not apply to others, it’s easy *to him/her*. For people who intuitively pick out these precedences, extra parens is just noise that makes them second guess their understandings.<br></p><p>The goal we should pursue is *clarity*. Today, if one wants to emphasize the precedence, they can add parens anyways:  ` a || (b &amp;&amp; c)`. But if we make `a || b &amp;&amp; c` have different meaning, that makes the code really really unclear (to the rest of us, who have assumptions about how precedences from our backgrounds) and will be a source for bugs. Assuming neither option is objectively better than the other, you need to convince us why the change is worth this cost.<br></p><p>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 1:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; This is an expansive argument you advance. Should users be expected to learn *any* rules of precedence beyond those of basic arithmetic? It would seem that you are arguing no. Yet Swift just went through an arduous redesign to permit--nay, improve--exactly that.<br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 12:30 Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com &lt;mailto:nevin.brackettrozinsky at gmail.com&gt;&gt; wrote:<br>&gt; Speaking for myself, I will *never* remember which of `&amp;&amp;` and `||` has higher precedence. I think of them as peers, so I always use parentheses around them, and whenever I read code that mingles them without parentheses its meaning is *unclear* to me.<br>&gt; <br>&gt; One of Swift’s main goals is clarity at the point of use. After all, code is read far more often than it is written. To me, an expression like `a &amp;&amp; b || c &amp;&amp; d` is not clear when I read it.<br>&gt; <br>&gt; The same goes for bitwise operators: I view them as peers. I do not think of them as “additive” or “multiplicative” (and definitely not “subtractive”), so code that relies on their precedences will always send me scrambling to look up which comes first.<br>&gt; <br>&gt; Certainly something like `a + b | c &amp; d - e * f ^ g` is meaningless to me without parentheses.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 12:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; That&#39;s an excellent point, actually. Would there be downsides not yet considered?<br>&gt; <br>&gt; <br>&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; These expressions mix two types of logic that have different implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;, except that `a * 16` will crash on overflow. In these cases, I find that grouping provides some visual insulation that groups off the somewhat subtle differences.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 2 août 2016 à 08:49:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 2, 2016 at 10:41 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; I don&#39;t think that &quot;intuitive&quot; or &quot;non-intuitive&quot; is what you&#39;d be looking for. There is nothing intuitive about multiplications having a higher precedence than additions; it&#39;s just a matter of conventions. I&#39;m not a maths expert (as Stephen showed, I didn&#39;t even give the right explanation to binary operators!), but it seems to me that there could well be a parallel universe in which additions have precedence over multiplications without other serious implications.<br>&gt;&gt; <br>&gt;&gt; And as it happens, a majority of people don&#39;t know that there is one for binary operators. I believe that the right question should be: do we want to pretend that this convention doesn&#39;t exist, to the benefit of people who don&#39;t know about it, and the detriment of those who do? Also, do we want to break it for &amp;&amp; and || too?<br>&gt;&gt; <br>&gt;&gt; I think that the biggest use case for binary operators in other languages are flags, and in Swift we treat these as collections. I&#39;d venture that &amp;, | and ^ would show up about as frequently as UnsafePointers and the like. It seems to me that Swift&#39;s approach has been to make things easy by default without locking away the power tools, and my personal expectation is that if you have to write code that has binary operators despite everything else that Swift has for you, you can be bothered to learn a precedence rule.<br>&gt;&gt; <br>&gt;&gt; That said, one thing that I could definitely get behind is breaking precedence between binary operators and arithmetic operators. I don&#39;t think that it makes sense to write something like &quot;a &amp; b / c&quot;. Looking at my code, the only place where I needed to mix binary operators and arithmetic operators were `a &amp; (a - 1)` (results in 0 if a is a power of two), and that one needs parentheses anyway.<br>&gt;&gt; <br>&gt;&gt; Although here, your same argument applies. If you need to write `a &amp; b / c`, then you can be bothered either to learn or look up a table, or you can just put in the parenthesis yourself. Likewise, if you&#39;re a reader of the code, it&#39;s highly likely that this is a complex formula anyway; you can either know the relative precedence or look it up, but that&#39;s the *least* of your worries in terms of what it will take to understand that code. I see no reason to force parentheses unless it actually prevents user error.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 2 août 2016 à 02:29:41, Anton Zhilin &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-08-02 7:18 GMT+03:00 Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; I disagree. The binary operators have properties that are comparable to arithmetic operators, and their precedence is easy to define as such. &amp; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same applies to &amp;&amp; and ||. Bit shifts are exponentiative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe that such way of thinking is non-intuitive. In C, bitwise operators are not intervened by any others, except for comparison operators (agreed, it was a mistake). We now have possibilities to do so in Swift, even better. I suggest to branch off right before AdditionPrecedence:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt;&gt;&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; LogicalShift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another concern is NilCoalescing, which can be though to be semantically similar to Ternary. And at the same time it looks like || and &amp;&amp;, which would bring it between LogicalConjunction and Comparison.<br>&gt;&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Next, Ternary operator is unique. Noone would ever like to put operators in this precedence group, because it would be confusing. Why not simplify our model and say that ?: has lower precedence than all binary operators, including Assignment? Unary &gt; binary &gt; ternary, sounds good? <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/624e1baf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August  2, 2016 at 09:00:00pm</p></header><div class="content"><p>2016-08-02 19:08 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; That&#39;s an excellent point, actually. Would there be downsides not yet<br>&gt; considered?<br>&gt;<br>&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; These expressions mix two types of logic that have different<br>&gt;&gt; implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;,<br>&gt;&gt; except that `a * 16` will crash on overflow. In these cases, I find that<br>&gt;&gt; grouping provides some visual insulation that groups off the somewhat<br>&gt;&gt; subtle differences.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;<br>So it at least makes sense to create a proposal about this:<br></p><p>RangeFormation &lt; Addition &lt; Multiplication<br>RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; BitwiseShift<br></p><p>Pretty much everyone says that moving Ternary below Assignment would be a<br>regression.<br>I feel like a bit more discussion is needed on this:<br></p><p>Another concern is NilCoalescing, which can be thought to be semantically<br>&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt; would bring it between LogicalConjunction and Comparison.<br>&gt; Also, do Casting and RangeFormation stand where they should?<br></p><p><br>Someone said that this is actually not what was planned -- sure, it may<br>need a separate proposal and a separate thread, but I think it&#39;s OK to use<br>this one for now.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/ef695e60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, Aug 2, 2016 at 1:07 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; 2016-08-02 19:08 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt; That&#39;s an excellent point, actually. Would there be downsides not yet<br>&gt;&gt; considered?<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 2, 2016 at 11:03 Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; These expressions mix two types of logic that have different<br>&gt;&gt;&gt; implications. For instance, `a * 16` and `a &lt;&lt; 4` are &quot;mostly equivalent&quot;,<br>&gt;&gt;&gt; except that `a * 16` will crash on overflow. In these cases, I find that<br>&gt;&gt;&gt; grouping provides some visual insulation that groups off the somewhat<br>&gt;&gt;&gt; subtle differences.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; So it at least makes sense to create a proposal about this:<br>&gt;<br>&gt; RangeFormation &lt; Addition &lt; Multiplication<br>&gt; RangeFormation &lt; BitwiseOr &lt; BitwiseAnd &lt; BitwiseShift<br>&gt;<br>&gt; Pretty much everyone says that moving Ternary below Assignment would be a<br>&gt; regression.<br>&gt; I feel like a bit more discussion is needed on this:<br>&gt;<br>&gt; Another concern is NilCoalescing, which can be thought to be semantically<br>&gt;&gt; similar to Ternary. And at the same time it looks like || and &amp;&amp;, which<br>&gt;&gt; would bring it between LogicalConjunction and Comparison.<br>&gt;&gt; Also, do Casting and RangeFormation stand where they should?<br>&gt;<br>&gt;<br>&gt; Someone said that this is actually not what was planned -- sure, it may<br>&gt; need a separate proposal and a separate thread, but I think it&#39;s OK to use<br>&gt; this one for now.<br>&gt;<br></p><p>Anton, since this list is high-volume, people may skip entire conversations<br>because the subject line is not of interest to them. If you&#39;re going to<br>discuss additional topics, please do start new threads. That way, we can<br>get the maximum participation.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/9311bdbc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Discussion] Breaking precedence</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>August  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 12:18 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I disagree. The binary operators have properties that are comparable to arithmetic operators, and their precedence is easy to define as such. &amp; has multiplication-like properties (0*0=0, 0*1=0, 1*0=0, 1*1=1); | has addition-like properties (0+0=0, 0+1=1, 1+0=1, 1+1=2); ^ has subtraction-like properties (0-0=0, 0-1=-1, 1-0=1, 1-1=0), and their precedences are set accordingly (&amp; is multiplicative, | and ^ are additive).<br></p><p>&lt;extreme pedantry&gt;<br>`^` is actually the *addition* operator on Boolean rings[1].  `x | y` corresponds to the Boolean ring operation `x + y + xy`, which is definitely “addition-like” but isn’t addition.<br>&lt;/extreme pedantry&gt;<br></p><p>Otherwise, spot on.<br></p><p>– Steve<br></p><p>[1] Of course, it’s *also* the subtraction operator, because `x = -x` for all members `x` of a Boolean ring (https://en.wikipedia.org/wiki/Boolean_ring &lt;https://en.wikipedia.org/wiki/Boolean_ring&gt;), but one usually calls it “addition&quot;.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/be112374/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
