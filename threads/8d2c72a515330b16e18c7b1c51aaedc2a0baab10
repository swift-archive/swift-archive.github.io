<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Align @objc inference with the semantic model</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Right now, Swift infers @objc (meaning that you don’t have to write it explicitly) in a number of places:<br></p><p>1) When overriding an @objc declaration<br>2) When implementing a requirement of an @objc protocol (note: this behavior was recently enabled in the Swift compiler)<br>3) When the declaration is‘@IBOutlet’, or ‘@NSManaged’<br>4) When the declaration is ‘dynamic’<br>5) When the declaration is non-private and occurs within a subclass of NSObject or an extension thereof, so long as it *can* be expressed in Objective-C<br></p><p>There are different motivations behind the various rules, some of which bear re-examination. Before going into the individual rules, here’s why I’m bringing this up now:<br></p><p>a) There is no easy way to articulate the rules we have. They mostly came from a desire to avoid making Swift programmers write ‘@objc’, but that’s not very principled.<br></p><p>b) When Swift code follows the Swift API design guidelines, the Objective-C names provided by the Swift compiler by default aren’t good names in Objective-C, a topic I brought up a few months ago &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/7733&gt;. The upshot is that, for entities that are intended to be used in Objective-C, inferring ‘@objc’ doesn’t help when you’re going to explicit write out the Objective-C selector anyway (‘@objc(objectAtIndex:)’). The Grand Renaming is forcing this on Swift programmers already, so it’s a reasonable time to make a change in the area of @objc inference.<br></p><p>c) The “thunks” generated for the compiler to provide Objective-C entry points have a non-trivial cost. I measured the code size of a handful of Swift projects (all Cocoa[Touch] apps, most Swift-only, some mixed Swift/Objective-C), and 6-8% of code size was in these @objc thunks. We have some ideas to reduce the code size of @objc thunks in general. However,  I suspect that most of these @objc thunks are completely unused, although I haven’t done the legwork to prove it, and there is no automatic way to remove them.<br></p><p>d) Removing @objc inference for a particular case can silently break working code, because something invisible to the Swift compiler (e.g., in Objective-C in a mixed-source project, in a system framework, etc.) might be depending on that Objective-C entry point. We can probably tolerate such breakage in Swift 3 where we’re breaking lots of things, but our ability to make sure changes here will be diminish rapidly over time. Hence, we’re talking about this now, and we need to live with our decisions for a long time.<br></p><p>In general, I’d like to remove @objc inference from places where it isn’t needed for the “semantic model”, loosely construed. Let’s go case-by-case with the places we do inference now:<br></p><p>(1) and (2) are geared toward consistency of the semantic model. For example, you need @objc inference for overrides of @objc declarations because otherwise Objective-C code won’t see the override and you’ll get divergent behavior. Similarly when you are implementing a requirement of an @objc protocol: Objective-C callers need to be able to have something to call. I consider it critical that we maintain @objc inference for these cases because maintaining a consistent semantic model across Swift and Objective-C code is fundamental to interoperability. No proposed change here, aside from noting that the ability to infer @objc (including the selector names) when implementing requirements of an @objc protocol was very recently introduced in the Swift compiler.<br></p><p>(3) is about interoperability with certain frameworks and tools. @objc inference helps eliminate some boilerplate today, because these features depend on the Objective-C runtime. Will these features, with their current spelling in Swift, *always* depend on the Objective-C runtime? If so, we can keep the @objc inference. Or is there some probable future where the same features could get implementations that don’t rely on the Objective-C runtime? If so, we might want to eliminate @objc inference for them: today, that means having to write ‘@objc’ explicitly on such declarations, and if that future comes to pass the requirement to add ‘@objc’ will go away (no existing code will break unless a user manually deletes an ‘@objc’ from that code). With ‘@NSManaged’, I feel like the underlying feature would look *very* different if implemented without a backing Objective-C runtime, so I’m inclined to leave @objc inference in place. With ‘@IBOutlet’ it’s a whole lot more murky, and the confusion is magnified by the fact that ‘@IBAction’ doesn’t currently have @objc inference. We should align IBOutlet and IBAction in this regard (so some change is needed), but I don’t have a strong sense of which way to go.<br></p><p>(4) ‘dynamic’ infers ‘@objc’ because the Swift runtime doesn’t have support for replacing a method at runtime. There are two possible futures here: Swift’s runtime gets support for ‘dynamic’ on pure Swift methods (in which case the ‘@objc’ inference would become vestigial cruft that would be hard to take away), or we decide that ‘dynamic’ is an Objective-C compatibility feature that always implies Objective-C. With SE-0070 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md&gt;, we started requiring an explicit ‘@objc’ for optional requirements to make it clear that this is an Objective-C compatibility feature, so in a sense both futures point to requiring explicit ‘@objc’ on ‘dynamic’. Therefore, I propose to drop @objc inference for ‘dynamic’ declarations. For now (and maybe forever), that means requiring ‘@objc’ to be written along with ‘dynamic’.<br></p><p>(5) was designed to reduce the need for programmers to explicitly write ‘@objc’. I also suspect it’s the culprit behind many of the unused @objc thunks hypothesized in (c). It is useful in mixed-source projects because you get more of your Swift APIs accessible to your Objective-C code for free, but it’s usefulness in Swift-only projects is far more limited. I propose that we eliminate @objc inference for non-private members of NSObject subclasses and extensions thereof. It means that one will need to be much more explicit for those @objc entry points that are needed (and yes, this will break code), but we will eliminate a (probably significant) number of unnecessary @objc entry points. It also eliminates reflexively inheriting from NSObject “just because it saves typing”, which can help nudge Swift classes toward the more-efficient Swift object model. There is a possible middle path here: eliminate the inference by default, then add a Swift compiler flag that enables @objc inference for these cases. One’s build system would be expected to pass this flag for mixed-source projects.<br></p><p>That’s the meat of the proposal. There are two minor follow-ons:<br></p><p>* Allow one to add @objc (or @nonobjc) to an extension, which will apply to all members of the extension not explicitly marked @objc or @nonobjc, e.g.,<br></p><p>@objc extension MyClass {<br>  func anObjCMethod() { }<br>  var anObjCProperty: String { … }<br>}<br></p><p>This makes it more convenient to add Objective-C entrypoints to a bunch of declarations at once.<br></p><p>* Require one to add @nonobjc to members of extensions of @objc protocols. Members of extensions of @objc protocols cannot be @objc, because there’s no way to implement this without major surgery in the Objective-C runtime or admitting inconsistent behavior (e.g., it only works for subclasses of NSObject). Requiring @nonobjc makes it explicit that these members are only available in Swift. I’ve proposed this before &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2136&gt;, and it didn’t really get a whole lot of support, but I think it’s important for clarifying the model.<br></p><p>What’s everyone think?<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/8d2cab10/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
