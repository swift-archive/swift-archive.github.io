<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Feb 03 2016, Charles Constant &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I find arguments with prepositions easier to read, on the whole, even when<br>&gt; they&#39;re not strictly necessary.<br>&gt;<br></p><p>Hi Charles,<br></p><p>FWIW, your personal style notwithstanding, we *are* standardizing on<br>camelCase, and CamelCase (for types), so writing your examples that way<br>would help us evaluate them as useful for the guidelines.<br></p><p>&gt; Even though, this code makes sense:<br>&gt;<br>&gt; *     a.move_to( b )*<br>&gt;<br>&gt; *     draw_line( origin: b, conclusion: c )*<br>&gt;<br>&gt; I&#39;d prefer to see this:<br>&gt;<br>&gt; *     a.move( to_point: b )*<br></p><p>The difference between this and the first example isn&#39;t a preposition;<br>it&#39;s a (IMO needless) noun.  What point (NPI) are you trying to<br>illustrate?<br></p><p>&gt; *     draw_line( from_point: b, to_point: c )*<br>&gt;<br>&gt; Similarly, for the example &quot;*a.read_from( u, of_type: b )*&quot; I find this<br>&gt; easier to read:<br>&gt;<br>&gt; *     a.read( from_url: u, from_type: b)*<br></p><p>The difference here is just in your *choice* of preposition.<br></p><p>&gt; Which makes it easier to understand if it&#39;s followed by:<br>&gt;<br>&gt; *     a.read( from_url: u, to_type: b)*<br>&gt;<br>&gt; I find it helpful in my own code. Having said that, I&#39;m not sure if it<br>&gt; would suit huge multi-person projects, since it leads to a lot of similarly<br>&gt; named functions.<br></p><p>I don&#39;t see how, but then I can&#39;t pick out any regularity in what you&#39;re<br>suggesting so I don&#39;t really know how to evaluate it.<br></p><p>&gt;<br>&gt; On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt; guidelines that:<br>&gt;&gt;<br>&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt; * are understandable by humans<br>&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt;<br>&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt;<br>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;    beginning in the base name and describing the primary semantics of<br>&gt;&gt;    the call, it gets no argument label:<br>&gt;&gt;<br>&gt;&gt;      a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;      a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;<br>&gt;&gt;      a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but<br>&gt;&gt;                             // doesn&#39;t describe the semantics at all,<br>&gt;&gt;                             // thus we add a label for b.<br>&gt;&gt;<br>&gt;&gt;      a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence<br>&gt;&gt;                               // but doesn&#39;t describe the primary<br>&gt;&gt;                               // semantics, which are to move in both<br>&gt;&gt;                               // x and y.  Thus, x gets a label.<br>&gt;&gt;<br>&gt;&gt;      a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                               // the primary semantics, so u gets no<br>&gt;&gt;                               // label. b is an<br>&gt;&gt;                               // option that tunes the primary<br>&gt;&gt;                               // semantics<br>&gt;&gt;<br>&gt;&gt;    [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;    all the default argument cases too, so maybe that exception can be<br>&gt;&gt;    dropped.  We still need the exceptions for full-width type<br>&gt;&gt;    conversions and indistinguishable peers]<br>&gt;&gt;<br>&gt;&gt;    Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;    first argument, we skip it in considering this criterion:<br>&gt;&gt;<br>&gt;&gt;       a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing<br>&gt;&gt;                        // the semantics.  &quot;Observer&quot; is omitted in<br>&gt;&gt;                        // making this determination.<br>&gt;&gt;<br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;   clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;   https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;   point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;   universally-understood term.<br>&gt;&gt;<br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;    should go in the base name rather than in a label:<br>&gt;&gt;<br>&gt;&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;<br>&gt;&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;<br>&gt;&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;    ambiguous]<br>&gt;&gt;<br>&gt;&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;&gt;    initializers):<br>&gt;&gt;<br>&gt;&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;<br>&gt;&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;<br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;    *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;    describe it in the base name.<br>&gt;&gt;<br>&gt;&gt;       a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;       a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;<br>&gt;&gt;       let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;       let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;       let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;<br>&gt; &gt; Even though, this code makes sense:<br>&gt; &gt;<br>&gt; &gt; *     a.moveTo( b )*<br>&gt; &gt;<br>&gt; &gt; I&#39;d prefer to see this:<br>&gt; &gt;<br>&gt;<br>&gt; *     a.move( toPoint: b )*<br>&gt;<br></p><p><br>The difference between this and the first example isn&#39;t a preposition;<br>&gt; it&#39;s a (IMO needless) noun.  What point (NPI) are you trying to<br>&gt; illustrate?<br></p><p><br>It looks like I didn&#39;t express myself well enough. My point is, it&#39;s not<br>entirely a &quot;needless noun&quot; in the context of an actual project. In<br>isolation, if your project only has that one function, it&#39;s needless. But,<br>when it&#39;s sitting there along with dozens of other functions and methods,<br>it&#39;s nice if you can predict which the argument labels you&#39;re looking for<br>will be called. Because, with my suggestion &quot;toPoint&quot; is  &quot;toPoint&quot; is<br>&quot;toPoint&quot; everywhere and with no exceptions.<br></p><p>FWIW, your personal style notwithstanding, we *are* standardizing on<br>&gt; camelCase<br></p><p><br>oK, no more snake case. ;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/0785db00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; it&#39;s nice if you can predict which the argument labels<br></p><p>As an example, so you can use your IDE to search and highlight every place<br>on the page that you&#39;re calling a function that calls &quot;toPoint&quot; or<br>&quot;fromURL&quot; etc.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/027a7c43/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 9:07 AM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt; <br>&gt; &gt; Even though, this code makes sense:<br>&gt; &gt;<br>&gt; &gt; *     a.moveTo( b )*<br>&gt; &gt;<br>&gt; &gt; I&#39;d prefer to see this:<br>&gt; &gt;<br>&gt; &gt; *     a.move( toPoint: b )*<br>&gt;  <br>&gt; The difference between this and the first example isn&#39;t a preposition;<br>&gt; it&#39;s a (IMO needless) noun.  What point (NPI) are you trying to<br>&gt; illustrate?<br>&gt; <br>&gt; It looks like I didn&#39;t express myself well enough. My point is, it&#39;s not entirely a &quot;needless noun&quot; in the context of an actual project.<br></p><p>Yes, but you phrased it as illustrating something about prepositions.<br></p><p>&gt; In isolation, if your project only has that one function, it&#39;s needless. But, when it&#39;s sitting there along with dozens of other functions and methods, it&#39;s nice if you can predict which the argument labels you&#39;re looking for will be called. Because, with my suggestion &quot;toPoint&quot; is  &quot;toPoint&quot; is &quot;toPoint&quot; everywhere and with no exceptions. <br></p><p>Why isn&#39;t &quot;to&quot; more predictable than &quot;toPoint?&quot;  It&#39;s certainly more universal.<br></p><p>&gt; FWIW, your personal style notwithstanding, we *are* standardizing on camelCase<br>&gt; <br>&gt; oK, no more snake case. ;)<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/b3e7f8ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Why isn&#39;t &quot;to&quot; more predictable than &quot;toPoint?&quot;  It&#39;s certainly more<br>&gt; universal.<br></p><p><br>Function arguments can be unordered, if they have default values. A<br>contrived example here...<br></p><p>func rename( from nameA=&quot;index&quot;, from extA=&quot;html&quot;, to nameB=&quot;converted&quot;, to<br>extB=&quot;shtml&quot; )<br></p><p><br>Maybe I&#39;m confused, but that seems like it has to be illegal at worst, and<br>confusing at best. But if you don&#39;t consistently use &quot;from&quot; and &quot;to&quot; then<br>you&#39;re back to making special rules about everything.<br></p><p>It wouldn&#39;t matter if every argument has a unique Type, or if you take the<br>time to create structs or tuples to bundle every piece of data together<br>about &quot;from&quot; or about &quot;with&quot; etc. Maybe that&#39;s usually the case, but it&#39;s<br>nice to have freedom to be lazy.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/90941a86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;<br>&gt; Why isn&#39;t &quot;to&quot; more predictable than &quot;toPoint?&quot;  It&#39;s certainly more<br>&gt; universal.<br></p><p><br>I also forgot to mention, &quot;to&quot; is so much more universal, that it stops<br>being very useful. If we rewrite my contrived example as...<br></p><p>    func rename( fromName=&quot;index&quot;, fromEx=&quot;html&quot;, toName=&quot;converted&quot;,<br>toExt=&quot;shtml&quot; )<br></p><p>The we have labels that I can easily imagine the programmer might want to<br>search code for, or plug in to a second, similar function. I can imagine<br>working on a file and thinking &quot;what other functions did i use here that<br>change an extension&quot; - searching for &quot;toExt&quot; is helpful there, whereas I&#39;m<br>not sure why I would want to find &quot;to[Anything].&quot; I also find it helps me<br>understand what functions do, when I&#39;m browsing suggestions from code<br>completion, but that&#39;s only my opinion for me to make, so it&#39;s hard for me<br>to make a convincing argument.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/d1772642/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
