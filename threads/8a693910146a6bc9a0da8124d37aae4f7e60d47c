<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed316d3a58253c2d51b67b1ed906bf5?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>David Beck</string> &lt;swift at tnku.co&gt;<p>September 16, 2016 at 08:00:00am</p></header><div class="content"><p>With the transition from Swift 2 -&gt; 3 I’ve started running into one particular issue VERY often (although it’s not necessarily specific to the transition). If a protocol method is optional (either because it is an @objc optional or because it has a default implementation) there is a risk that the conformer will have a misspelled or slightly incorrectly typed implementation of the method. For instance:<br></p><p>protocol RouteDestinationViewController: class {<br>	static func viewController(with url: URL, properties: [String:String]) -&gt; UIViewController?<br>}<br></p><p>extension RouteDestinationViewController where Self: UIViewController {<br>	static func viewController(with url: URL, properties: [String:String]) -&gt; UIViewController? {<br>		return Self.init()<br>	}<br>}<br></p><p>class FooController: UIViewController, RouteDestinationViewController {<br>	static func viewController(with url: URL, properties: [String:Any]) -&gt; UIViewController? {<br>		return FooController(properties: properties)<br>	}<br>}<br></p><p>Notice the issue there? Properties is supposed to be [String:String], but FooController uses [String:Any] (this is an exact issue I ran into after a small refactor). When viewController(with:properties:) is called, it will use the default implementation instead of what the compiler sees as a completely different method. Over the betas the compiler has gotten better warnings about this, but is still not 100%.<br></p><p>Other cases of this issue are common with imported ObjC protocols that have different naming in Swift. In some cases an @objc name must be applied to ensure it is declared in a way that the protocol can see it.<br></p><p>We solve this problem with subclassing by requiring “override”. If the override keyword is present but the superclass doesn’t have a matching method, the compiler warns us about it. Similarly if the superclass implements the same method and the subclass doesn’t include override, we get a warning so that it is clear that you are overriding behavior.<br></p><p>For protocols, I don’t think a required keyword would be the best approach. It’s a completely valid case that a type could conform to a protocol using existing methods, perhaps even from a different module. Further, a single method could satisfy multiple protocols, and be overriden from a superclass. What I would propose would be something like an optional override(&lt;#protocol name#&gt;). Something like the following:<br></p><p>	override(RouteDestinationViewController) static func viewController(with url: URL, properties: [String:Any]) -&gt; UIViewController? {<br>		return FooController(properties: properties)<br>	}<br></p><p>A method should be able to include multiple overrides (including a bare override to indicate that it is overriding a class method).<br></p><p>Thoughts? Are you seeing similar issues?<br></p><p>David Beck<br>http://davidbeck.co<br>http://twitter.com/davbeck<br>http://facebook.com/davbeck<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/8a69d47c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 16, 2016 at 09:00:00pm</p></header><div class="content"><p>David, thank you for a real-word example when such feature will be very <br>useful and can protect from hard-to-find bugs. IMO This shows that we <br>should find a solution for the problem as soon as possible.<br></p><p>Such or similar question was discussed already in an number of threads, for <br>example in &quot;Requiring proactive overrides for default protocol <br>implementations.&quot; and in &quot;Requiring special keyword to mark protocol <br>implementation methods&quot;, probably in other threads also.<br></p><p>The first is that `override` is not used in structs, so IMO it will be <br>alien here.<br>Second, if protocol has no default implementation for the method- would you <br>require the `override(Protocol)` also?<br></p><p>Then, in case you will not require a keyword when no default implementation <br>- you should think about retrospective adding of extension.<br></p><p>I.e. imagine, you have a source file, let&#39;s call it SomeClass.swift which <br>you can&#39;t or don&#39;t want to change(this could be some complex source from <br>3rd party, from github, or from other developer of your company). This file <br>compiles without problems. It contains:<br></p><p>public protocol Foo { func foo() }<br>public class Some: Foo { func foo() {...} }<br></p><p>You added SomeClass.swift to your project and in your My.swift you added <br>default implementation for Foo protocol:<br></p><p>extension Foo { func foo() {...} }<br></p><p>So, now, when you compile your project, there is default implementation for <br>foo() and class Some should contains `override(Foo)`, but you can&#39;t change <br>SomeClass.swift.<br></p><p><br>The only solution I see here, is if this `override(Foo)` will be optional, <br>and just express developer&#39;s intention, if he/she wants this. I.e. it is <br>not required, but if you specify it - compiler will check this intention.<br>But AFAIR unfortunately someone from core team mentioned that they don&#39;t <br>want such optional solution.<br></p><p>And, at the end, I do think the real reason of your problem is not that <br>protocol method has default implementation, but that <br>`viewController(with:properties:)` definition in `FooController` does not <br>say for compiler(and compiler does not check this) that this method was <br>defined *exactly* to confirm to protocol. I.e. you can&#39;t clearly express <br>your intention regarding why this method is here. Check this example:<br></p><p>Let&#39;s assume you defined protocol Foo in FooProto.swift file:<br></p><p>public protocol Foo { func foo() }<br></p><p>and have class `Some` conformed to Foo in SomeClass.swift:<br></p><p>public class Some : Foo { func foo() {...} }<br></p><p>it is clear *why* foo is here..<br></p><p>OK, now, let&#39;s assume you changed Foo protocol in the way, that <br>SomeClass.swift *still* compiles :<br></p><p>public protocol Foo { func bar() }<br>extension Foo {<br>   func bar() {...}<br>}<br></p><p>Now, SomeClass.swift still compiles but it contains *wrong* intention that <br>foo() method is an implementation of protocol requirement. And this can <br>lead to bugs/unexpected behavior.<br></p><p><br>I think what we do need a way to clearly shows intention that we defined <br>some method *exactly* because the conformed protocol has it and to make <br>compiler check this.<br></p><p>My favorite solution is &#39;implements&#39; keyword inside class/struct to <br>highlight that I defined this method as implementation for the protocol <br>requirement. IMO solves a big percent of discussed issues with just one <br>added keyword, that also will help with understanding the code when you <br>read it.<br></p><p>Other solution that was mentioned by (as I remember) member of core team is <br>treat class extension with protocol conformance as such intention, i.e. <br>when you say<br>extension Some: Foo {..}<br>compiler will understand this as all methods inside such extension must <br>&#39;belongs&#39; to the Foo protocol, i.e. if there is some method that does not <br>exist in Foo - it will raise an error. But in this case we need to require <br>that each protocol conformance will be declared as extension, not inline in <br>class definition. Personally I don&#39;t believe in this solution.<br></p><p><br>On 16.09.2016 18:29, David Beck via swift-evolution wrote:<br>&gt; With the transition from Swift 2 -&gt; 3 IБ─≥ve started running into one<br>&gt; particular issue VERY often (although itБ─≥s not necessarily specific to the<br>&gt; transition). If a protocol method is optional (either because it is an<br>&gt; @objc optional or because it has a default implementation) there is a risk<br>&gt; that the conformer will have a misspelled or slightly incorrectly typed<br>&gt; implementation of the method. For instance:<br>&gt;<br>&gt; protocolRouteDestinationViewController: class{<br>&gt; staticfuncviewController(with url: URL, properties: [String:String]) -&gt;<br>&gt; UIViewController?<br>&gt; }<br>&gt;<br>&gt; extensionRouteDestinationViewControllerwhereSelf: UIViewController {<br>&gt; staticfuncviewController(with url: URL, properties: [String:String]) -&gt;<br>&gt; UIViewController? {<br>&gt; returnSelf.init()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; classFooController: UIViewController, RouteDestinationViewController{<br>&gt; staticfuncviewController(with url: URL, properties: [String:Any]) -&gt;<br>&gt; UIViewController? {<br>&gt; returnFooController(properties: properties)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Notice the issue there? Properties is supposed to be [String:String], but<br>&gt; FooController uses [String:Any] (this is an exact issue I ran into after a<br>&gt; small refactor). When viewController(with:properties:) is called, it will<br>&gt; use the default implementation instead of what the compiler sees as a<br>&gt; completely different method. Over the betas the compiler has gotten better<br>&gt; warnings about this, but is still not 100%.<br>&gt;<br>&gt; Other cases of this issue are common with imported ObjC protocols that have<br>&gt; different naming in Swift. In some cases an @objc name must be applied to<br>&gt; ensure it is declared in a way that the protocol can see it.<br>&gt;<br>&gt; We solve this problem with subclassing by requiring Б─°overrideБ─². If the<br>&gt; override keyword is present but the superclass doesnБ─≥t have a matching<br>&gt; method, the compiler warns us about it. Similarly if the superclass<br>&gt; implements the same method and the subclass doesnБ─≥t include override, we<br>&gt; get a warning so that it is clear that you are overriding behavior.<br>&gt;<br>&gt; For protocols, I donБ─≥t think a required keyword would be the best approach.<br>&gt; ItБ─≥s a completely valid case that a type could conform to a protocol using<br>&gt; existing methods, perhaps even from a different module. Further, a single<br>&gt; method could satisfy multiple protocols, and be overriden from a<br>&gt; superclass. What I would propose would be something like an optional<br>&gt; override(&lt;#protocol name#&gt;). Something like the following:<br>&gt;<br>&gt; override(RouteDestinationViewController) staticfuncviewController(with url:<br>&gt; URL, properties: [String:Any]) -&gt; UIViewController? {<br>&gt; returnFooController(properties: properties)<br>&gt; }<br>&gt;<br>&gt; A method should be able to include multiple overrides (including a bare<br>&gt; override to indicate that it is overriding a class method).<br>&gt;<br>&gt; Thoughts? Are you seeing similar issues?<br>&gt;<br>&gt; *David Beck*<br>&gt; http://davidbeck.co<br>&gt; http://twitter.com/davbeck<br>&gt; http://facebook.com/davbeck<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 16, 2016 at 10:00:00pm</p></header><div class="content"><p>I don’t really like the idea of override(ProtocolName), but I’d support the single override here. On value types it’s easier to recognize the member of a protocol which had a default implementation.<br></p><p>I don’t feel like adding override to all members that replaces some default implementation will break anything. Furthermore, I’d love to see the addition where we could call the default implementation.<br></p><p>Here is some bikeshedding:<br></p><p>protocol A {}<br></p><p>extension A {<br>   func foo() { .. }<br>}<br></p><p>protocol B : A {}<br></p><p>extension B {<br>   // overriding default implementation from an other one!?  <br>   override func foo() {<br>        // call default implementation of A<br>       default.foo()<br>    }   <br>}<br></p><p>struct C : A {<br>   // overriding some default implementation  <br>   override func foo() {<br>      // call default implementation<br>       default.foo()<br>    }<br>}<br></p><p>struct D : B {<br>      // overriding some default implementation  <br>   override func foo() {<br>      // call default implementation B<br>      // which will also call default implementation of A<br>       default.foo()<br>    }<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 16. September 2016 um 20:45:05, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>David, thank you for a real-word example when such feature will be very  <br>useful and can protect from hard-to-find bugs. IMO This shows that we  <br>should find a solution for the problem as soon as possible.<br></p><p>Such or similar question was discussed already in an number of threads, for  <br>example in &quot;Requiring proactive overrides for default protocol  <br>implementations.&quot; and in &quot;Requiring special keyword to mark protocol  <br>implementation methods&quot;, probably in other threads also.<br></p><p>The first is that `override` is not used in structs, so IMO it will be  <br>alien here.<br>Second, if protocol has no default implementation for the method- would you  <br>require the `override(Protocol)` also?<br></p><p>Then, in case you will not require a keyword when no default implementation  <br>- you should think about retrospective adding of extension.<br></p><p>I.e. imagine, you have a source file, let&#39;s call it SomeClass.swift which  <br>you can&#39;t or don&#39;t want to change(this could be some complex source from  <br>3rd party, from github, or from other developer of your company). This file  <br>compiles without problems. It contains:<br></p><p>public protocol Foo { func foo() }<br>public class Some: Foo { func foo() {...} }<br></p><p>You added SomeClass.swift to your project and in your My.swift you added  <br>default implementation for Foo protocol:<br></p><p>extension Foo { func foo() {...} }<br></p><p>So, now, when you compile your project, there is default implementation for  <br>foo() and class Some should contains `override(Foo)`, but you can&#39;t change  <br>SomeClass.swift.<br></p><p><br>The only solution I see here, is if this `override(Foo)` will be optional,  <br>and just express developer&#39;s intention, if he/she wants this. I.e. it is  <br>not required, but if you specify it - compiler will check this intention.<br>But AFAIR unfortunately someone from core team mentioned that they don&#39;t  <br>want such optional solution.<br></p><p>And, at the end, I do think the real reason of your problem is not that  <br>protocol method has default implementation, but that  <br>`viewController(with:properties:)` definition in `FooController` does not  <br>say for compiler(and compiler does not check this) that this method was  <br>defined *exactly* to confirm to protocol. I.e. you can&#39;t clearly express  <br>your intention regarding why this method is here. Check this example:<br></p><p>Let&#39;s assume you defined protocol Foo in FooProto.swift file:<br></p><p>public protocol Foo { func foo() }<br></p><p>and have class `Some` conformed to Foo in SomeClass.swift:<br></p><p>public class Some : Foo { func foo() {...} }<br></p><p>it is clear *why* foo is here..<br></p><p>OK, now, let&#39;s assume you changed Foo protocol in the way, that  <br>SomeClass.swift *still* compiles :<br></p><p>public protocol Foo { func bar() }<br>extension Foo {<br>func bar() {...}<br>}<br></p><p>Now, SomeClass.swift still compiles but it contains *wrong* intention that  <br>foo() method is an implementation of protocol requirement. And this can  <br>lead to bugs/unexpected behavior.<br></p><p><br>I think what we do need a way to clearly shows intention that we defined  <br>some method *exactly* because the conformed protocol has it and to make  <br>compiler check this.<br></p><p>My favorite solution is &#39;implements&#39; keyword inside class/struct to  <br>highlight that I defined this method as implementation for the protocol  <br>requirement. IMO solves a big percent of discussed issues with just one  <br>added keyword, that also will help with understanding the code when you  <br>read it.<br></p><p>Other solution that was mentioned by (as I remember) member of core team is  <br>treat class extension with protocol conformance as such intention, i.e.  <br>when you say<br>extension Some: Foo {..}<br>compiler will understand this as all methods inside such extension must  <br>&#39;belongs&#39; to the Foo protocol, i.e. if there is some method that does not  <br>exist in Foo - it will raise an error. But in this case we need to require  <br>that each protocol conformance will be declared as extension, not inline in  <br>class definition. Personally I don&#39;t believe in this solution.<br></p><p><br>On 16.09.2016 18:29, David Beck via swift-evolution wrote:<br>&gt; With the transition from Swift 2 -&gt; 3 IБ─≥ve started running into one<br>&gt; particular issue VERY often (although itБ─≥s not necessarily specific to the<br>&gt; transition). If a protocol method is optional (either because it is an<br>&gt; @objc optional or because it has a default implementation) there is a risk<br>&gt; that the conformer will have a misspelled or slightly incorrectly typed<br>&gt; implementation of the method. For instance:<br>&gt;<br>&gt; protocolRouteDestinationViewController: class{<br>&gt; staticfuncviewController(with url: URL, properties: [String:String]) -&gt;<br>&gt; UIViewController?<br>&gt; }<br>&gt;<br>&gt; extensionRouteDestinationViewControllerwhereSelf: UIViewController {<br>&gt; staticfuncviewController(with url: URL, properties: [String:String]) -&gt;<br>&gt; UIViewController? {<br>&gt; returnSelf.init()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; classFooController: UIViewController, RouteDestinationViewController{<br>&gt; staticfuncviewController(with url: URL, properties: [String:Any]) -&gt;<br>&gt; UIViewController? {<br>&gt; returnFooController(properties: properties)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Notice the issue there? Properties is supposed to be [String:String], but<br>&gt; FooController uses [String:Any] (this is an exact issue I ran into after a<br>&gt; small refactor). When viewController(with:properties:) is called, it will<br>&gt; use the default implementation instead of what the compiler sees as a<br>&gt; completely different method. Over the betas the compiler has gotten better<br>&gt; warnings about this, but is still not 100%.<br>&gt;<br>&gt; Other cases of this issue are common with imported ObjC protocols that have<br>&gt; different naming in Swift. In some cases an @objc name must be applied to<br>&gt; ensure it is declared in a way that the protocol can see it.<br>&gt;<br>&gt; We solve this problem with subclassing by requiring Б─°overrideБ─². If the<br>&gt; override keyword is present but the superclass doesnБ─≥t have a matching<br>&gt; method, the compiler warns us about it. Similarly if the superclass<br>&gt; implements the same method and the subclass doesnБ─≥t include override, we<br>&gt; get a warning so that it is clear that you are overriding behavior.<br>&gt;<br>&gt; For protocols, I donБ─≥t think a required keyword would be the best approach.<br>&gt; ItБ─≥s a completely valid case that a type could conform to a protocol using<br>&gt; existing methods, perhaps even from a different module. Further, a single<br>&gt; method could satisfy multiple protocols, and be overriden from a<br>&gt; superclass. What I would propose would be something like an optional<br>&gt; override(&lt;#protocol name#&gt;). Something like the following:<br>&gt;<br>&gt; override(RouteDestinationViewController) staticfuncviewController(with url:<br>&gt; URL, properties: [String:Any]) -&gt; UIViewController? {<br>&gt; returnFooController(properties: properties)<br>&gt; }<br>&gt;<br>&gt; A method should be able to include multiple overrides (including a bare<br>&gt; override to indicate that it is overriding a class method).<br>&gt;<br>&gt; Thoughts? Are you seeing similar issues?<br>&gt;<br>&gt; *David Beck*<br>&gt; http://davidbeck.co<br>&gt; http://twitter.com/davbeck<br>&gt; http://facebook.com/davbeck<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/d0db309c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 16, 2016 at 09:00:00pm</p></header><div class="content"><p>We&#39;ve had this discussion on the list multiple times already. The gist of<br>the difficulty here is that most proposals for a mandatory keyword don&#39;t<br>permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core<br>team seems to take a dim view to optional syntax, since that&#39;s more in the<br>ballpark of linters.<br></p><p>I really don&#39;t see anything new here that we haven&#39;t already discussed at<br>length...<br></p><p><br>On Fri, Sep 16, 2016 at 15:25 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don’t really like the idea of override(ProtocolName), but I’d support<br>&gt; the single override here. On value types it’s easier to recognize the<br>&gt; member of a protocol which had a default implementation.<br>&gt;<br>&gt; I don’t feel like adding override to all members that replaces some<br>&gt; default implementation will break anything. Furthermore, I’d love to see<br>&gt; the addition where we could call the default implementation.<br>&gt;<br>&gt; Here is some bikeshedding:<br>&gt;<br>&gt; protocol A {}<br>&gt;<br>&gt; extension A {<br>&gt;    func foo() { .. }<br>&gt; }<br>&gt;<br>&gt; protocol B : A {}<br>&gt;<br>&gt; extension B {<br>&gt;    // overriding default implementation from an other one!?<br>&gt;    override func foo() {<br>&gt;         // call default implementation of A<br>&gt;        default.foo()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; struct C : A {<br>&gt;    // overriding some default implementation<br>&gt;    override func foo() {<br>&gt;       // call default implementation<br>&gt;        default.foo()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; struct D : B {<br>&gt;       // overriding some default implementation<br>&gt;    override func foo() {<br>&gt;       // call default implementation B<br>&gt;       // which will also call default implementation of A<br>&gt;        default.foo()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 16. September 2016 um 20:45:05, Vladimir.S via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; David, thank you for a real-word example when such feature will be very<br>&gt; useful and can protect from hard-to-find bugs. IMO This shows that we<br>&gt; should find a solution for the problem as soon as possible.<br>&gt;<br>&gt; Such or similar question was discussed already in an number of threads,<br>&gt; for<br>&gt; example in &quot;Requiring proactive overrides for default protocol<br>&gt; implementations.&quot; and in &quot;Requiring special keyword to mark protocol<br>&gt; implementation methods&quot;, probably in other threads also.<br>&gt;<br>&gt; The first is that `override` is not used in structs, so IMO it will be<br>&gt; alien here.<br>&gt; Second, if protocol has no default implementation for the method- would<br>&gt; you<br>&gt; require the `override(Protocol)` also?<br>&gt;<br>&gt; Then, in case you will not require a keyword when no default<br>&gt; implementation<br>&gt; - you should think about retrospective adding of extension.<br>&gt;<br>&gt; I.e. imagine, you have a source file, let&#39;s call it SomeClass.swift which<br>&gt; you can&#39;t or don&#39;t want to change(this could be some complex source from<br>&gt; 3rd party, from github, or from other developer of your company). This<br>&gt; file<br>&gt; compiles without problems. It contains:<br>&gt;<br>&gt; public protocol Foo { func foo() }<br>&gt; public class Some: Foo { func foo() {...} }<br>&gt;<br>&gt; You added SomeClass.swift to your project and in your My.swift you added<br>&gt; default implementation for Foo protocol:<br>&gt;<br>&gt; extension Foo { func foo() {...} }<br>&gt;<br>&gt; So, now, when you compile your project, there is default implementation<br>&gt; for<br>&gt; foo() and class Some should contains `override(Foo)`, but you can&#39;t change<br>&gt; SomeClass.swift.<br>&gt;<br>&gt;<br>&gt; The only solution I see here, is if this `override(Foo)` will be optional,<br>&gt; and just express developer&#39;s intention, if he/she wants this. I.e. it is<br>&gt; not required, but if you specify it - compiler will check this intention.<br>&gt; But AFAIR unfortunately someone from core team mentioned that they don&#39;t<br>&gt; want such optional solution.<br>&gt;<br>&gt; And, at the end, I do think the real reason of your problem is not that<br>&gt; protocol method has default implementation, but that<br>&gt; `viewController(with:properties:)` definition in `FooController` does not<br>&gt; say for compiler(and compiler does not check this) that this method was<br>&gt; defined *exactly* to confirm to protocol. I.e. you can&#39;t clearly express<br>&gt; your intention regarding why this method is here. Check this example:<br>&gt;<br>&gt; Let&#39;s assume you defined protocol Foo in FooProto.swift file:<br>&gt;<br>&gt; public protocol Foo { func foo() }<br>&gt;<br>&gt; and have class `Some` conformed to Foo in SomeClass.swift:<br>&gt;<br>&gt; public class Some : Foo { func foo() {...} }<br>&gt;<br>&gt; it is clear *why* foo is here..<br>&gt;<br>&gt; OK, now, let&#39;s assume you changed Foo protocol in the way, that<br>&gt; SomeClass.swift *still* compiles :<br>&gt;<br>&gt; public protocol Foo { func bar() }<br>&gt; extension Foo {<br>&gt; func bar() {...}<br>&gt; }<br>&gt;<br>&gt; Now, SomeClass.swift still compiles but it contains *wrong* intention that<br>&gt; foo() method is an implementation of protocol requirement. And this can<br>&gt; lead to bugs/unexpected behavior.<br>&gt;<br>&gt;<br>&gt; I think what we do need a way to clearly shows intention that we defined<br>&gt; some method *exactly* because the conformed protocol has it and to make<br>&gt; compiler check this.<br>&gt;<br>&gt; My favorite solution is &#39;implements&#39; keyword inside class/struct to<br>&gt; highlight that I defined this method as implementation for the protocol<br>&gt; requirement. IMO solves a big percent of discussed issues with just one<br>&gt; added keyword, that also will help with understanding the code when you<br>&gt; read it.<br>&gt;<br>&gt; Other solution that was mentioned by (as I remember) member of core team<br>&gt; is<br>&gt; treat class extension with protocol conformance as such intention, i.e.<br>&gt; when you say<br>&gt; extension Some: Foo {..}<br>&gt; compiler will understand this as all methods inside such extension must<br>&gt; &#39;belongs&#39; to the Foo protocol, i.e. if there is some method that does not<br>&gt; exist in Foo - it will raise an error. But in this case we need to require<br>&gt; that each protocol conformance will be declared as extension, not inline<br>&gt; in<br>&gt; class definition. Personally I don&#39;t believe in this solution.<br>&gt;<br>&gt;<br>&gt; On 16.09.2016 18:29, David Beck via swift-evolution wrote:<br>&gt; &gt; With the transition from Swift 2 -&gt; 3 IБ─≥ve started running into one<br>&gt; &gt; particular issue VERY often (although itБ─≥s not necessarily specific to<br>&gt; the<br>&gt; &gt; transition). If a protocol method is optional (either because it is an<br>&gt; &gt; @objc optional or because it has a default implementation) there is a<br>&gt; risk<br>&gt; &gt; that the conformer will have a misspelled or slightly incorrectly typed<br>&gt; &gt; implementation of the method. For instance:<br>&gt; &gt;<br>&gt; &gt; protocolRouteDestinationViewController: class{<br>&gt; &gt; staticfuncviewController(with url: URL, properties: [String:String]) -&gt;<br>&gt; &gt; UIViewController?<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extensionRouteDestinationViewControllerwhereSelf: UIViewController {<br>&gt; &gt; staticfuncviewController(with url: URL, properties: [String:String]) -&gt;<br>&gt; &gt; UIViewController? {<br>&gt; &gt; returnSelf.init()<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; classFooController: UIViewController, RouteDestinationViewController{<br>&gt; &gt; staticfuncviewController(with url: URL, properties: [String:Any]) -&gt;<br>&gt; &gt; UIViewController? {<br>&gt; &gt; returnFooController(properties: properties)<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Notice the issue there? Properties is supposed to be [String:String], but<br>&gt; &gt; FooController uses [String:Any] (this is an exact issue I ran into after<br>&gt; a<br>&gt; &gt; small refactor). When viewController(with:properties:) is called, it will<br>&gt; &gt; use the default implementation instead of what the compiler sees as a<br>&gt; &gt; completely different method. Over the betas the compiler has gotten<br>&gt; better<br>&gt; &gt; warnings about this, but is still not 100%.<br>&gt; &gt;<br>&gt; &gt; Other cases of this issue are common with imported ObjC protocols that<br>&gt; have<br>&gt; &gt; different naming in Swift. In some cases an @objc name must be applied to<br>&gt; &gt; ensure it is declared in a way that the protocol can see it.<br>&gt; &gt;<br>&gt; &gt; We solve this problem with subclassing by requiring Б─°overrideБ─². If<br>&gt; the<br>&gt; &gt; override keyword is present but the superclass doesnБ─≥t have a matching<br>&gt; &gt; method, the compiler warns us about it. Similarly if the superclass<br>&gt; &gt; implements the same method and the subclass doesnБ─≥t include override,<br>&gt; we<br>&gt; &gt; get a warning so that it is clear that you are overriding behavior.<br>&gt; &gt;<br>&gt; &gt; For protocols, I donБ─≥t think a required keyword would be the best<br>&gt; approach.<br>&gt; &gt; ItБ─≥s a completely valid case that a type could conform to a protocol<br>&gt; using<br>&gt; &gt; existing methods, perhaps even from a different module. Further, a single<br>&gt; &gt; method could satisfy multiple protocols, and be overriden from a<br>&gt; &gt; superclass. What I would propose would be something like an optional<br>&gt; &gt; override(&lt;#protocol name#&gt;). Something like the following:<br>&gt; &gt;<br>&gt; &gt; override(RouteDestinationViewController) staticfuncviewController(with<br>&gt; url:<br>&gt; &gt; URL, properties: [String:Any]) -&gt; UIViewController? {<br>&gt; &gt; returnFooController(properties: properties)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; A method should be able to include multiple overrides (including a bare<br>&gt; &gt; override to indicate that it is overriding a class method).<br>&gt; &gt;<br>&gt; &gt; Thoughts? Are you seeing similar issues?<br>&gt; &gt;<br>&gt; &gt; *David Beck*<br>&gt; &gt; http://davidbeck.co<br>&gt; &gt; http://twitter.com/davbeck<br>&gt; &gt; http://facebook.com/davbeck<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/f6acc590/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>September 16, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We&#39;ve had this discussion on the list multiple times already. The gist of the difficulty here is that most proposals for a mandatory keyword don&#39;t permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core team seems to take a dim view to optional syntax, since that&#39;s more in the ballpark of linters.<br></p><p>Numerous solutions to your objection have been proposed; you always simply dismiss all of them in favor of your dogmatic stance. It’s really quite tiring. You can have this and support retroactive modeling; you just might need to have a separate syntax for retroactive conformances. You keep bringing that up as a hard-and-fast objection, but you know what? Maybe retroactive conformances should have a separate syntax, because they’re not saying the same thing! One is saying &quot;here are some methods that will make this type conform to this protocol”, where the other is saying “this type already has the methods that conform to this protocol somewhere.” These are not the same thing, and it might be confusing to see a conformance declaration and assume it’s the former when it’s actually the latter, and then have trouble finding the conformances. Maybe it would actually make your code clearer if retroactive conformances were required to declare “this method exists somewhere else already.” Maybe you could even command-click on it and jump to the actual declaration. Anything would be better than the current situation, because:<br></p><p>The reason this keeps coming up is because it’s a real problem. I myself have started taking up the practice of always using copy-and-paste to declare conformances to protocols, because otherwise the chances of mistyping something and having the bug not manifest itself until runtime is simply too high. This is not a “linter” problem; this affects basic functionality and makes protocols, honestly, really dangerous to use. For a language that bills itself as “protocol-oriented”, it’s really quite damning that its protocol support is this brittle and fragile compared to its support for traditional inheritance. I’ve been bitten by this enough times by now to somewhat regret the decision to go with a protocol-based design. This is a real shame because conceptually, the idea of Swift’s protocol-based design is really cool.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/8a21c21b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 16, 2016 at 11:00:00pm</p></header><div class="content"><p>I absolutely agree that it&#39;s a problem worth solving. However, the question<br>is whether a particular proposed design solves the problem and avoids<br>previously stated weaknesses. What I&#39;m saying here is that, so far, the<br>conversation in this thread has involved reiterating already-proposed<br>designs that have been critiqued. It&#39;s really quite tiring for me too to<br>repeat the same critique when someone raises the same proposal a second or<br>third time.<br></p><p>It&#39;s possible that it makes sense to have a separate syntax for retroactive<br>modeling. I haven&#39;t been able to come up with one that seems reasonable to<br>me, or I would have written to this list to propose it. Do you have such a<br>design in mind?<br>On Fri, Sep 16, 2016 at 16:59 Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; We&#39;ve had this discussion on the list multiple times already. The gist of<br>&gt; the difficulty here is that most proposals for a mandatory keyword don&#39;t<br>&gt; permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core<br>&gt; team seems to take a dim view to optional syntax, since that&#39;s more in the<br>&gt; ballpark of linters.<br>&gt;<br>&gt;<br>&gt; Numerous solutions to your objection have been proposed; you always simply<br>&gt; dismiss all of them in favor of your dogmatic stance. It’s really quite<br>&gt; tiring. You can have this and support retroactive modeling; you just might<br>&gt; need to have a separate syntax for retroactive conformances. You keep<br>&gt; bringing that up as a hard-and-fast objection, but you know what? Maybe<br>&gt; retroactive conformances *should* have a separate syntax, because they’re<br>&gt; not saying the same thing! One is saying &quot;here are some methods that will<br>&gt; make this type conform to this protocol”, where the other is saying “this<br>&gt; type already has the methods that conform to this protocol somewhere.”<br>&gt; These are not the same thing, and it might be confusing to see a<br>&gt; conformance declaration and assume it’s the former when it’s actually the<br>&gt; latter, and then have trouble finding the conformances. Maybe it would<br>&gt; actually make your code clearer if retroactive conformances were required<br>&gt; to declare “this method exists somewhere else already.” Maybe you could<br>&gt; even command-click on it and jump to the actual declaration. Anything would<br>&gt; be better than the current situation, because:<br>&gt;<br>&gt; The reason this keeps coming up is because it’s a real problem. I myself<br>&gt; have started taking up the practice of always using copy-and-paste to<br>&gt; declare conformances to protocols, because otherwise the chances of<br>&gt; mistyping something and having the bug not manifest itself until runtime is<br>&gt; simply too high. This is not a “linter” problem; this affects basic<br>&gt; functionality and makes protocols, honestly, really dangerous to use. For a<br>&gt; language that bills itself as “protocol-oriented”, it’s really quite<br>&gt; damning that its protocol support is this brittle and fragile compared to<br>&gt; its support for traditional inheritance. I’ve been bitten by this enough<br>&gt; times by now to somewhat regret the decision to go with a protocol-based<br>&gt; design. This is a real shame because conceptually, the idea of Swift’s<br>&gt; protocol-based design is really cool.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/c0166fb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 17, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 17 Sep 2016, at 01:45, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I absolutely agree that it&#39;s a problem worth solving. However, the question is whether a particular proposed design solves the problem and avoids previously stated weaknesses. What I&#39;m saying here is that, so far, the conversation in this thread has involved reiterating already-proposed designs that have been critiqued. It&#39;s really quite tiring for me too to repeat the same critique when someone raises the same proposal a second or third time.<br>&gt; <br>&gt; It&#39;s possible that it makes sense to have a separate syntax for retroactive modeling. I haven&#39;t been able to come up with one that seems reasonable to me, or I would have written to this list to propose it. Do you have such a design in mind?<br>&gt; On Fri, Sep 16, 2016 at 16:59 Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We&#39;ve had this discussion on the list multiple times already. The gist of the difficulty here is that most proposals for a mandatory keyword don&#39;t permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core team seems to take a dim view to optional syntax, since that&#39;s more in the ballpark of linters.<br>&gt; <br>&gt; Numerous solutions to your objection have been proposed; you always simply dismiss all of them in favor of your dogmatic stance. It’s really quite tiring. You can have this and support retroactive modeling; you just might need to have a separate syntax for retroactive conformances. You keep bringing that up as a hard-and-fast objection, but you know what? Maybe retroactive conformances should have a separate syntax, because they’re not saying the same thing! One is saying &quot;here are some methods that will make this type conform to this protocol”, where the other is saying “this type already has the methods that conform to this protocol somewhere.” These are not the same thing, and it might be confusing to see a conformance declaration and assume it’s the former when it’s actually the latter, and then have trouble finding the conformances. Maybe it would actually make your code clearer if retroactive conformances were required to declare “this method exists somewhere else already.” Maybe you could even command-click on it and jump to the actual declaration. Anything would be better than the current situation, because:<br>&gt; <br>&gt; The reason this keeps coming up is because it’s a real problem. I myself have started taking up the practice of always using copy-and-paste to declare conformances to protocols, because otherwise the chances of mistyping something and having the bug not manifest itself until runtime is simply too high. This is not a “linter” problem; this affects basic functionality and makes protocols, honestly, really dangerous to use. For a language that bills itself as “protocol-oriented”, it’s really quite damning that its protocol support is this brittle and fragile compared to its support for traditional inheritance. I’ve been bitten by this enough times by now to somewhat regret the decision to go with a protocol-based design. This is a real shame because conceptually, the idea of Swift’s protocol-based design is really cool.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>I don’t see what the big problem about retroactive modelling is.<br></p><p>Basically, the way I see it, if my class MyClass implements MyProtocol, providing someRequiredFunc(), there’s an “ownership” chain there (reading it backwards).<br></p><p>Now what happens if MyClass implements MyOtherProtocol, which also has someRequiredFunc()? In that case, I want to MyClass as a MyOtherProtocol and get another function pointer, which just happens to have the same human-readable name as some other property. Just because they have the same function signature, absolutely doesn’t mean they’re the same thing.<br></p><p>Now, if we strongly bind all protocol conformances to the protocol they implement, what happens to instance methods? They don’t belong to any protocol, their parent is the class itself. If you have an instance method called someRequiredFunc(), and you later add a conformance to MyProtocol, you would need to declare that it belongs to MyProtocol. If you don’t want it to be an API-breaking change, you have to provide a thunk (or we could provide a shorthand syntax which emits thunks for you) to let us know that MyClass::someRequiredFunc() is the same thing as MyClass::MyProtocol::someRequiredFunc().<br></p><p>Let’s take an example where retroactive modelling could go wrong. You’ve got different teams working on different parts of an App, and they’ve all got their own convention for “copy()”. Sometimes it’s a deep-copy, sometimes a shallow-copy, sometimes it’s used in a fragile way for a specific case, whatever. Now you want to go and clean that up by creating a “Copyable” protocol with codified guarantees. Some objects may already conform, others may need tweaks, and some may want both behaviours simultaneously (preserving the old, non-Copytable-compliant behaviour until the next API break), depending on how you look at the object. A system like this allows all of those different ways of looking at the object live together. You could have the old, non-comforming API as an extension with a FIXME to delete it for version 2.<br></p><p>I think it’s pretty arcane that members of a type are resolved only by their names. If you want to provide types which allow flexible views of data, each view of that data needs to be completely free in its expressivity.<br></p><p>I would actually like to see a syntax like:<br></p><p>```<br>let testObject = MyClass()<br>let testMyProto = testObject.MyProtocol // the protocol-witness table for testObject as a MyProtocol.<br></p><p>testObject.MyProtocol.someRequiredFunc() // that’s one function<br>testObject.someRequiredFunc() // is a different function. May happen to have the same implementation as above if MyProtocol was retroactively modelled.<br>```<br></p><p>I think it would fit well with the dispatch system for protocol extensions, too. I sometimes have code like the following:<br></p><p>```<br>protocol Base {}<br>protocol Derived : Base {}<br></p><p>extension Base { <br>  func doSomething() { … }<br>}<br>extension Derived {<br>  func doSomething() {<br>   …<br>   (self as Base).doSomething() // Would be better if we could say “self.Base.doSomething()” to disambiguate instead of casting.<br>  }<br>}<br>```<br></p><p>So yeah, a big +1 to marking protocol methods with their protocol (whatever the syntax ends up looking like), and actually I’d take it further and bake them in to the ABI. That also makes it relevant for Swift 4 phase 1.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160917/e36a74eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 16, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Sep 16, 2016 at 20:28 Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; On 17 Sep 2016, at 01:45, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I absolutely agree that it&#39;s a problem worth solving. However, the<br>&gt; question is whether a particular proposed design solves the problem and<br>&gt; avoids previously stated weaknesses. What I&#39;m saying here is that, so far,<br>&gt; the conversation in this thread has involved reiterating already-proposed<br>&gt; designs that have been critiqued. It&#39;s really quite tiring for me too to<br>&gt; repeat the same critique when someone raises the same proposal a second or<br>&gt; third time.<br>&gt;<br>&gt; It&#39;s possible that it makes sense to have a separate syntax for<br>&gt; retroactive modeling. I haven&#39;t been able to come up with one that seems<br>&gt; reasonable to me, or I would have written to this list to propose it. Do<br>&gt; you have such a design in mind?<br>&gt; On Fri, Sep 16, 2016 at 16:59 Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; We&#39;ve had this discussion on the list multiple times already. The gist of<br>&gt;&gt; the difficulty here is that most proposals for a mandatory keyword don&#39;t<br>&gt;&gt; permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core<br>&gt;&gt; team seems to take a dim view to optional syntax, since that&#39;s more in the<br>&gt;&gt; ballpark of linters.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Numerous solutions to your objection have been proposed; you always<br>&gt;&gt; simply dismiss all of them in favor of your dogmatic stance. It’s really<br>&gt;&gt; quite tiring. You can have this and support retroactive modeling; you just<br>&gt;&gt; might need to have a separate syntax for retroactive conformances. You keep<br>&gt;&gt; bringing that up as a hard-and-fast objection, but you know what? Maybe<br>&gt;&gt; retroactive conformances *should* have a separate syntax, because<br>&gt;&gt; they’re not saying the same thing! One is saying &quot;here are some methods<br>&gt;&gt; that will make this type conform to this protocol”, where the other is<br>&gt;&gt; saying “this type already has the methods that conform to this protocol<br>&gt;&gt; somewhere.” These are not the same thing, and it might be confusing to see<br>&gt;&gt; a conformance declaration and assume it’s the former when it’s actually the<br>&gt;&gt; latter, and then have trouble finding the conformances. Maybe it would<br>&gt;&gt; actually make your code clearer if retroactive conformances were required<br>&gt;&gt; to declare “this method exists somewhere else already.” Maybe you could<br>&gt;&gt; even command-click on it and jump to the actual declaration. Anything would<br>&gt;&gt; be better than the current situation, because:<br>&gt;&gt;<br>&gt;&gt; The reason this keeps coming up is because it’s a real problem. I myself<br>&gt;&gt; have started taking up the practice of always using copy-and-paste to<br>&gt;&gt; declare conformances to protocols, because otherwise the chances of<br>&gt;&gt; mistyping something and having the bug not manifest itself until runtime is<br>&gt;&gt; simply too high. This is not a “linter” problem; this affects basic<br>&gt;&gt; functionality and makes protocols, honestly, really dangerous to use. For a<br>&gt;&gt; language that bills itself as “protocol-oriented”, it’s really quite<br>&gt;&gt; damning that its protocol support is this brittle and fragile compared to<br>&gt;&gt; its support for traditional inheritance. I’ve been bitten by this enough<br>&gt;&gt; times by now to somewhat regret the decision to go with a protocol-based<br>&gt;&gt; design. This is a real shame because conceptually, the idea of Swift’s<br>&gt;&gt; protocol-based design is really cool.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; I don’t see what the big problem about retroactive modelling is.<br>&gt;<br></p><p>Let me give a concrete example of how retroactively modeling is used.<br>Currently, there is a JIRA bug that Set does not conform to SetAlgebra. To<br>fix this issue, someone simply needs to write `extension Set : SetAlgebra {<br>}` and some tests. That&#39;s literally what the bug (filed by a core team<br>member) tells you to do. It&#39;s a starter bug, and if someone hasn&#39;t taken it<br>yet, you the reader could have a go at it. What&#39;s neat about Swift is that<br>it&#39;s super easy to provide the same functionality in your own project<br>without waiting on that bug to be fixed in Swift itself. You can simply<br>write a single line of code. By contrast, if your proposal were to be<br>implemented, this would become much more difficult.<br></p><p>This is actively used in Swift today. For example, in the Swift<br>implementation of NSScanner, you&#39;ll find the following lines:<br></p><p>```<br>internal protocol _BitShiftable {<br>    static func &gt;&gt;(lhs: Self, rhs: Self) -&gt; Self<br>    static func &lt;&lt;(lhs: Self, rhs: Self) -&gt; Self<br>}<br></p><p>internal protocol _IntegerLike : Integer, _BitShiftable {<br>    init(_ value: Int)<br>    static var max: Self { get }<br>    static var min: Self { get }<br>}<br></p><p>extension Int : _IntegerLike { }<br>extension Int32 : _IntegerLike { }<br>extension Int64 : _IntegerLike { }<br>extension UInt32 : _IntegerLike { }<br>extension UInt64 : _IntegerLike { }<br>```<br></p><p>If we adopted your proposed syntax below, it would take considerably more<br>lines of boilerplate code to express the same thing. The burden increases<br>significantly with the complexity of the retroactive modeling. For<br>instance, if the retroactively modeled protocol had 20 requirements and you<br>were retroactively conforming 20 types, that&#39;d be at least 400 lines of<br>boilerplate.<br></p><p><br>&gt; Basically, the way I see it, if my class MyClass implements MyProtocol,<br>&gt; providing someRequiredFunc(), there’s an “ownership” chain there (reading<br>&gt; it backwards).<br>&gt;<br>&gt; Now what happens if MyClass implements MyOtherProtocol, which also has<br>&gt; someRequiredFunc()? In that case, I want to MyClass as a MyOtherProtocol<br>&gt; and get another function pointer, which just happens to have the same<br>&gt; human-readable name as some other property. Just because they have the same<br>&gt; function signature, absolutely doesn’t mean they’re the same thing.<br>&gt;<br>&gt; Now, if we strongly bind all protocol conformances to the protocol they<br>&gt; implement, what happens to instance methods? They don’t belong to any<br>&gt; protocol, their parent is the class itself. If you have an instance method<br>&gt; called someRequiredFunc(), and you later add a conformance to MyProtocol,<br>&gt; you would need to declare that it belongs to MyProtocol. If you don’t want<br>&gt; it to be an API-breaking change, you have to provide a thunk (or we could<br>&gt; provide a shorthand syntax which emits thunks for you) to let us know that<br>&gt; MyClass::someRequiredFunc() is the same thing as MyClass::MyProtocol::<br>&gt; someRequiredFunc().<br>&gt;<br></p><p>Your argument is that two methods with the same name should not in any way<br>conflict with each other. This is a fundamental change from the status quo.<br>If we were to take your argument to its logical conclusion, any member A of<br>a type T should be capable of being designated as the implementation of a<br>requirement B of protocol P. In the most general case, two functions A and<br>B shouldn&#39;t even need to take the same number of arguments, or arguments of<br>the same type; you should be able to supply default arguments, or even<br>write custom code that takes arguments for A and computes suitable<br>arguments for B in order to forward A to B, and the language should allow<br>you to designate A as an implementation of B. But that is simply not how<br>Swift protocols are designed.<br></p><p><br>&gt; Let’s take an example where retroactive modelling could go wrong. You’ve<br>&gt; got different teams working on different parts of an App, and they’ve all<br>&gt; got their own convention for “copy()”. Sometimes it’s a deep-copy,<br>&gt; sometimes a shallow-copy, sometimes it’s used in a fragile way for a<br>&gt; specific case, whatever. Now you want to go and clean that up by creating a<br>&gt; “Copyable” protocol with codified guarantees. Some objects may already<br>&gt; conform, others may need tweaks, and some may want both behaviours<br>&gt; simultaneously (preserving the old, non-Copytable-compliant behaviour until<br>&gt; the next API break), depending on how you look at the object. A system like<br>&gt; this allows all of those different ways of looking at the object live<br>&gt; together. You could have the old, non-comforming API as an extension with a<br>&gt; FIXME to delete it for version 2.<br>&gt;<br></p><p>Even if you design a protocol called Copyable, you still need to explicitly<br>extend concrete types in order to conform to Copyable. Swift does not<br>automagically make anything conform to your protocol. If you choose<br>*explicitly* to conform different types that don&#39;t guarantee the same<br>semantics, and then you erroneously assume that they all have the same<br>semantics even though you *explicitly* chose types that don&#39;t have the same<br>semantics, you&#39;re the one who shot yourself in the foot, so to speak. It&#39;s<br>not the fault of Swift at all.<br></p><p><br>&gt; I think it’s pretty arcane that members of a type are resolved only by<br>&gt; their names. If you want to provide types which allow flexible views of<br>&gt; data, each view of that data needs to be completely free in its<br>&gt; expressivity.<br>&gt;<br>&gt; I would actually like to see a syntax like:<br>&gt;<br>&gt; ```<br>&gt; let testObject = MyClass()<br>&gt; let testMyProto = testObject.MyProtocol // the protocol-witness table for<br>&gt; testObject as a MyProtocol.<br>&gt;<br>&gt; testObject.MyProtocol.someRequiredFunc() // that’s one function<br>&gt; testObject.someRequiredFunc() // is a different function. May happen to<br>&gt; have the same implementation as above if MyProtocol was retroactively<br>&gt; modelled.<br>&gt; ```<br>&gt;<br>&gt; I think it would fit well with the dispatch system for protocol<br>&gt; extensions, too. I sometimes have code like the following:<br>&gt;<br>&gt; ```<br>&gt; protocol Base {}<br>&gt; protocol Derived : Base {}<br>&gt;<br>&gt; extension Base {<br>&gt;   func doSomething() { … }<br>&gt; }<br>&gt; extension Derived {<br>&gt;   func doSomething() {<br>&gt;    …<br>&gt;    (self as Base).doSomething() // Would be better if we could say<br>&gt; “self.Base.doSomething()” to disambiguate instead of casting.<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br></p><p>This is a complete redesign of protocols in Swift. With the emphasis on<br>minimizing source-breaking changes, I doubt such a change would be in scope<br>for any phase of Swift unless you could show an overwhelming benefit.<br></p><p>So yeah, a big +1 to marking protocol methods with their protocol (whatever<br>&gt; the syntax ends up looking like), and actually I’d take it further and bake<br>&gt; them in to the ABI. That also makes it relevant for Swift 4 phase 1.<br>&gt;<br>&gt; Karl<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160916/b1ca7a29/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 17, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On 17 Sep 2016, at 05:32, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Sep 16, 2016 at 20:28 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On 17 Sep 2016, at 01:45, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I absolutely agree that it&#39;s a problem worth solving. However, the question is whether a particular proposed design solves the problem and avoids previously stated weaknesses. What I&#39;m saying here is that, so far, the conversation in this thread has involved reiterating already-proposed designs that have been critiqued. It&#39;s really quite tiring for me too to repeat the same critique when someone raises the same proposal a second or third time.<br>&gt;&gt; <br>&gt;&gt; It&#39;s possible that it makes sense to have a separate syntax for retroactive modeling. I haven&#39;t been able to come up with one that seems reasonable to me, or I would have written to this list to propose it. Do you have such a design in mind?<br>&gt;&gt; On Fri, Sep 16, 2016 at 16:59 Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve had this discussion on the list multiple times already. The gist of the difficulty here is that most proposals for a mandatory keyword don&#39;t permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core team seems to take a dim view to optional syntax, since that&#39;s more in the ballpark of linters.<br>&gt;&gt; <br>&gt;&gt; Numerous solutions to your objection have been proposed; you always simply dismiss all of them in favor of your dogmatic stance. It’s really quite tiring. You can have this and support retroactive modeling; you just might need to have a separate syntax for retroactive conformances. You keep bringing that up as a hard-and-fast objection, but you know what? Maybe retroactive conformances should have a separate syntax, because they’re not saying the same thing! One is saying &quot;here are some methods that will make this type conform to this protocol”, where the other is saying “this type already has the methods that conform to this protocol somewhere.” These are not the same thing, and it might be confusing to see a conformance declaration and assume it’s the former when it’s actually the latter, and then have trouble finding the conformances. Maybe it would actually make your code clearer if retroactive conformances were required to declare “this method exists somewhere else already.” Maybe you could even command-click on it and jump to the actual declaration. Anything would be better than the current situation, because:<br>&gt;&gt; <br>&gt;&gt; The reason this keeps coming up is because it’s a real problem. I myself have started taking up the practice of always using copy-and-paste to declare conformances to protocols, because otherwise the chances of mistyping something and having the bug not manifest itself until runtime is simply too high. This is not a “linter” problem; this affects basic functionality and makes protocols, honestly, really dangerous to use. For a language that bills itself as “protocol-oriented”, it’s really quite damning that its protocol support is this brittle and fragile compared to its support for traditional inheritance. I’ve been bitten by this enough times by now to somewhat regret the decision to go with a protocol-based design. This is a real shame because conceptually, the idea of Swift’s protocol-based design is really cool.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; I don’t see what the big problem about retroactive modelling is.<br>&gt; <br>&gt; Let me give a concrete example of how retroactively modeling is used. Currently, there is a JIRA bug that Set does not conform to SetAlgebra. To fix this issue, someone simply needs to write `extension Set : SetAlgebra { }` and some tests. That&#39;s literally what the bug (filed by a core team member) tells you to do. It&#39;s a starter bug, and if someone hasn&#39;t taken it yet, you the reader could have a go at it. What&#39;s neat about Swift is that it&#39;s super easy to provide the same functionality in your own project without waiting on that bug to be fixed in Swift itself. You can simply write a single line of code. By contrast, if your proposal were to be implemented, this would become much more difficult.<br>&gt; <br>&gt; This is actively used in Swift today. For example, in the Swift implementation of NSScanner, you&#39;ll find the following lines:<br>&gt; <br>&gt; ```<br>&gt; internal protocol _BitShiftable {<br>&gt;     static func &gt;&gt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     static func &lt;&lt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; internal protocol _IntegerLike : Integer, _BitShiftable {<br>&gt;     init(_ value: Int)<br>&gt;     static var max: Self { get }<br>&gt;     static var min: Self { get }<br>&gt; }<br>&gt; <br>&gt; extension Int : _IntegerLike { }<br>&gt; extension Int32 : _IntegerLike { }<br>&gt; extension Int64 : _IntegerLike { }<br>&gt; extension UInt32 : _IntegerLike { }<br>&gt; extension UInt64 : _IntegerLike { }<br>&gt; ```<br>&gt; <br>&gt; If we adopted your proposed syntax below, it would take considerably more lines of boilerplate code to express the same thing. The burden increases significantly with the complexity of the retroactive modeling. For instance, if the retroactively modeled protocol had 20 requirements and you were retroactively conforming 20 types, that&#39;d be at least 400 lines of boilerplate.<br>&gt;  <br></p><p>Yes, this is necessarily going to be a big chunk of boilerplate, because there are n integer types with no useful common ancestors. We could come up with all kinds of shorthands for making this easier, but there are basically two situations when adding a conformance of a new protocol P when there are existing members with the same names:<br></p><p>- You’re adapting the semantics of new protocol P to your internal way of working. You need a more advanced bridge between the two models which may require maintenance as your internal workings change. Nothing much we can do about that.<br>- You’re ensuring capabilities which may be provided by other protocols. You want to forward to the implementation of P.member to your an existing protocol’s X.member because they have the same semantics.<br></p><p>Ideally, you would use a protocol extension for the latter case. It would say that “all types which conform to StandardLibraryBitShiftable conform to _BitShiftable”. In this case, as we don’t have protocol-oriented Integers, and the current design makes this one particular case really annoying. We could probably have a shorthand syntax for this sort of case, too. I’m not worried about that at all; the important thing is that we get the semantics correct and that the model makes Swift types even more powerful. We can worry about reducing boilerplate later, because in theory it’s all about hooking up the correct protocol-witness table with the correct function pointer and we’ll have all the information to do that.<br></p><p><br>&gt; Basically, the way I see it, if my class MyClass implements MyProtocol, providing someRequiredFunc(), there’s an “ownership” chain there (reading it backwards).<br>&gt; <br>&gt; Now what happens if MyClass implements MyOtherProtocol, which also has someRequiredFunc()? In that case, I want to MyClass as a MyOtherProtocol and get another function pointer, which just happens to have the same human-readable name as some other property. Just because they have the same function signature, absolutely doesn’t mean they’re the same thing.<br>&gt; <br>&gt; Now, if we strongly bind all protocol conformances to the protocol they implement, what happens to instance methods? They don’t belong to any protocol, their parent is the class itself. If you have an instance method called someRequiredFunc(), and you later add a conformance to MyProtocol, you would need to declare that it belongs to MyProtocol. If you don’t want it to be an API-breaking change, you have to provide a thunk (or we could provide a shorthand syntax which emits thunks for you) to let us know that MyClass::someRequiredFunc() is the same thing as MyClass::MyProtocol::someRequiredFunc().<br>&gt; <br>&gt; Your argument is that two methods with the same name should not in any way conflict with each other. This is a fundamental change from the status quo. If we were to take your argument to its logical conclusion, any member A of a type T should be capable of being designated as the implementation of a requirement B of protocol P. In the most general case, two functions A and B shouldn&#39;t even need to take the same number of arguments, or arguments of the same type; you should be able to supply default arguments, or even write custom code that takes arguments for A and computes suitable arguments for B in order to forward A to B, and the language should allow you to designate A as an implementation of B. But that is simply not how Swift protocols are designed.<br></p><p>Yes, that’s my argument. Changing the status quo is basically what swift-evo is _for_.<br></p><p>And yes, you’ve basically got the concept - you should connect up the protocol requirement &lt;-&gt; implementation table by manually marking the protocol name on them (as the proposal says). Migration would be straight-forward.<br>But actually, I do think this fits with how Swift protocols are designed. In Objective-C, anything that responds to the same selectors as NSCopying conforms to NSCopying, because Objective-C’s dispatch works by selector names. In Swift, as you point out later, you need to manually declare that conformance even if it responds to the equivalent of “-(id) copyWithZone:”. A Swift protocol is a guarantee of a certain kind of behaviour, not just of functions with certain names. <br></p><p>The status quo is that we are stuck in the middle - members are disambiguated only by their name, but just having the name isn’t enough for conformance. So when you come across a conflict in names, you need to rename all uses of one of them. If the protocol comes from a source you cannot change, you may be stuck in a situation where you *cannot conform to the protocol* and have to write your own wrapping thunk-er which does. Basically, you end up looking with code that looks like my proposal.<br></p><p>&gt;  <br>&gt; Let’s take an example where retroactive modelling could go wrong. You’ve got different teams working on different parts of an App, and they’ve all got their own convention for “copy()”. Sometimes it’s a deep-copy, sometimes a shallow-copy, sometimes it’s used in a fragile way for a specific case, whatever. Now you want to go and clean that up by creating a “Copyable” protocol with codified guarantees. Some objects may already conform, others may need tweaks, and some may want both behaviours simultaneously (preserving the old, non-Copytable-compliant behaviour until the next API break), depending on how you look at the object. A system like this allows all of those different ways of looking at the object live together. You could have the old, non-comforming API as an extension with a FIXME to delete it for version 2.<br>&gt; <br>&gt; Even if you design a protocol called Copyable, you still need to explicitly extend concrete types in order to conform to Copyable. Swift does not automagically make anything conform to your protocol. If you choose *explicitly* to conform different types that don&#39;t guarantee the same semantics, and then you erroneously assume that they all have the same semantics even though you *explicitly* chose types that don&#39;t have the same semantics, you&#39;re the one who shot yourself in the foot, so to speak. It&#39;s not the fault of Swift at all.<br>&gt; <br></p><p>Yes, and the best bit about this is that you’d need to explicitly add it to every would-be member of Copyable too, so you’d have to check that the new semantics you are imposing with the conformance are correct (unless using some retroactive modelling shorthand which tells the compiler to emit thunks for all members of MyClass-&gt;Copyable in to MyClass). That’s the right thing to do, IMO (and also, would be the perfect cue for Xcode’s rename tool to start supporting Swift…).<br></p><p>&gt; <br>&gt; I think it’s pretty arcane that members of a type are resolved only by their names. If you want to provide types which allow flexible views of data, each view of that data needs to be completely free in its expressivity.<br>&gt; <br>&gt; I would actually like to see a syntax like:<br>&gt; <br>&gt; ```<br>&gt; let testObject = MyClass()<br>&gt; let testMyProto = testObject.MyProtocol // the protocol-witness table for testObject as a MyProtocol.<br>&gt; <br>&gt; testObject.MyProtocol.someRequiredFunc() // that’s one function<br>&gt; testObject.someRequiredFunc() // is a different function. May happen to have the same implementation as above if MyProtocol was retroactively modelled.<br>&gt; ```<br>&gt; <br>&gt; I think it would fit well with the dispatch system for protocol extensions, too. I sometimes have code like the following:<br>&gt; <br>&gt; ```<br>&gt; protocol Base {}<br>&gt; protocol Derived : Base {}<br>&gt; <br>&gt; extension Base { <br>&gt;   func doSomething() { … }<br>&gt; }<br>&gt; extension Derived {<br>&gt;   func doSomething() {<br>&gt;    …<br>&gt;    (self as Base).doSomething() // Would be better if we could say “self.Base.doSomething()” to disambiguate instead of casting.<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This is a complete redesign of protocols in Swift. With the emphasis on minimizing source-breaking changes, I doubt such a change would be in scope for any phase of Swift unless you could show an overwhelming benefit.<br></p><p>Not really a complete redesign - it fits with the semantic model of protocols which has already been established. I expect that protocols are going to change a lot in Swift 4 anyway, what with conditional conformances and better existentials, they’re going to be way more powerful than Swift 3 protocols. It is important we unlock full expressivity to allow them to be fully exploited, so we have to tackle the naming-conflict problem.<br></p><p>Also, I’m not sure source-breaking changes are such a big deal since we decided to support Swift 3 syntax. We could still support that - if you write “MyClass.someRequiredFunc()” which only exists inside a protocol, the compiler can search for the correct one to use.<br></p><p>There are great ways we can extend this, too - if you’ve got the ability to disambiguate the protocol witnesses yourself, perhaps you could override the “MyProtocol” witness getter and return an optimised wrapper which conforms to the protocol on your behalf. That would mean that all of the various String views (UTF8/16/Scalars/Characters) could be implemented as protocols on the single String type. So now suddenly we have a standard protocol for “a collection of UTF code points” which String is able to conform to, so it’s much easier to write generic code works with String and my own custom data-type which is also representable as some UTF code points.<br></p><p>I think that’s a pretty big win. It would allow us incredible new flexibility to model, which is ultimately what protocols are there to do.<br>It’s not even such a big change **at a high level** (I’m aware that, especially the first one, would touch just about every component of the compiler and standard library):<br></p><p>- Protocol conformances own their members; Members which are part of a protocol conformance no longer belong to their enclosing type directly.<br>- Synthesise getter for “.ProtocolName”, which returns the protocol witness<br>- (Optional) Make overridable to supply your own protocol witness<br>- Insert jumps to allow for retroactive modelling, with shorthand syntax<br></p><p>I’m not sure if it’s really a non-starter though. It would make the language much better and it would be pretty easy to migrate existing code (since we don’t allow non-unique names right now). Like I said, I expect the Swift 4 standard library (with conditional conformances) to look very different to Swift 3 at any rate.<br></p><p>&gt; <br>&gt; So yeah, a big +1 to marking protocol methods with their protocol (whatever the syntax ends up looking like), and actually I’d take it further and bake them in to the ABI. That also makes it relevant for Swift 4 phase 1.<br>&gt; <br>&gt; Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160917/6e98d937/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 17, 2016 at 09:00:00am</p></header><div class="content"><p>I started putting together a proposal, hopefully better explaining what I’m suggesting:<br></p><p>https://github.com/karwa/swift-evolution/blob/patch-2/0000-template.md &lt;https://github.com/karwa/swift-evolution/blob/patch-2/0000-template.md&gt;<br></p><p>&gt; On 17 Sep 2016, at 05:32, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Sep 16, 2016 at 20:28 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On 17 Sep 2016, at 01:45, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I absolutely agree that it&#39;s a problem worth solving. However, the question is whether a particular proposed design solves the problem and avoids previously stated weaknesses. What I&#39;m saying here is that, so far, the conversation in this thread has involved reiterating already-proposed designs that have been critiqued. It&#39;s really quite tiring for me too to repeat the same critique when someone raises the same proposal a second or third time.<br>&gt;&gt; <br>&gt;&gt; It&#39;s possible that it makes sense to have a separate syntax for retroactive modeling. I haven&#39;t been able to come up with one that seems reasonable to me, or I would have written to this list to propose it. Do you have such a design in mind?<br>&gt;&gt; On Fri, Sep 16, 2016 at 16:59 Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Sep 16, 2016, at 4:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve had this discussion on the list multiple times already. The gist of the difficulty here is that most proposals for a mandatory keyword don&#39;t permit retroactive modeling, so it&#39;s a no-go. On the other hand, the core team seems to take a dim view to optional syntax, since that&#39;s more in the ballpark of linters.<br>&gt;&gt; <br>&gt;&gt; Numerous solutions to your objection have been proposed; you always simply dismiss all of them in favor of your dogmatic stance. It’s really quite tiring. You can have this and support retroactive modeling; you just might need to have a separate syntax for retroactive conformances. You keep bringing that up as a hard-and-fast objection, but you know what? Maybe retroactive conformances should have a separate syntax, because they’re not saying the same thing! One is saying &quot;here are some methods that will make this type conform to this protocol”, where the other is saying “this type already has the methods that conform to this protocol somewhere.” These are not the same thing, and it might be confusing to see a conformance declaration and assume it’s the former when it’s actually the latter, and then have trouble finding the conformances. Maybe it would actually make your code clearer if retroactive conformances were required to declare “this method exists somewhere else already.” Maybe you could even command-click on it and jump to the actual declaration. Anything would be better than the current situation, because:<br>&gt;&gt; <br>&gt;&gt; The reason this keeps coming up is because it’s a real problem. I myself have started taking up the practice of always using copy-and-paste to declare conformances to protocols, because otherwise the chances of mistyping something and having the bug not manifest itself until runtime is simply too high. This is not a “linter” problem; this affects basic functionality and makes protocols, honestly, really dangerous to use. For a language that bills itself as “protocol-oriented”, it’s really quite damning that its protocol support is this brittle and fragile compared to its support for traditional inheritance. I’ve been bitten by this enough times by now to somewhat regret the decision to go with a protocol-based design. This is a real shame because conceptually, the idea of Swift’s protocol-based design is really cool.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; I don’t see what the big problem about retroactive modelling is.<br>&gt; <br>&gt; Let me give a concrete example of how retroactively modeling is used. Currently, there is a JIRA bug that Set does not conform to SetAlgebra. To fix this issue, someone simply needs to write `extension Set : SetAlgebra { }` and some tests. That&#39;s literally what the bug (filed by a core team member) tells you to do. It&#39;s a starter bug, and if someone hasn&#39;t taken it yet, you the reader could have a go at it. What&#39;s neat about Swift is that it&#39;s super easy to provide the same functionality in your own project without waiting on that bug to be fixed in Swift itself. You can simply write a single line of code. By contrast, if your proposal were to be implemented, this would become much more difficult.<br>&gt; <br>&gt; This is actively used in Swift today. For example, in the Swift implementation of NSScanner, you&#39;ll find the following lines:<br>&gt; <br>&gt; ```<br>&gt; internal protocol _BitShiftable {<br>&gt;     static func &gt;&gt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     static func &lt;&lt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; internal protocol _IntegerLike : Integer, _BitShiftable {<br>&gt;     init(_ value: Int)<br>&gt;     static var max: Self { get }<br>&gt;     static var min: Self { get }<br>&gt; }<br>&gt; <br>&gt; extension Int : _IntegerLike { }<br>&gt; extension Int32 : _IntegerLike { }<br>&gt; extension Int64 : _IntegerLike { }<br>&gt; extension UInt32 : _IntegerLike { }<br>&gt; extension UInt64 : _IntegerLike { }<br>&gt; ```<br>&gt; <br>&gt; If we adopted your proposed syntax below, it would take considerably more lines of boilerplate code to express the same thing. The burden increases significantly with the complexity of the retroactive modeling. For instance, if the retroactively modeled protocol had 20 requirements and you were retroactively conforming 20 types, that&#39;d be at least 400 lines of boilerplate.<br>&gt;  <br>&gt; Basically, the way I see it, if my class MyClass implements MyProtocol, providing someRequiredFunc(), there’s an “ownership” chain there (reading it backwards).<br>&gt; <br>&gt; Now what happens if MyClass implements MyOtherProtocol, which also has someRequiredFunc()? In that case, I want to MyClass as a MyOtherProtocol and get another function pointer, which just happens to have the same human-readable name as some other property. Just because they have the same function signature, absolutely doesn’t mean they’re the same thing.<br>&gt; <br>&gt; Now, if we strongly bind all protocol conformances to the protocol they implement, what happens to instance methods? They don’t belong to any protocol, their parent is the class itself. If you have an instance method called someRequiredFunc(), and you later add a conformance to MyProtocol, you would need to declare that it belongs to MyProtocol. If you don’t want it to be an API-breaking change, you have to provide a thunk (or we could provide a shorthand syntax which emits thunks for you) to let us know that MyClass::someRequiredFunc() is the same thing as MyClass::MyProtocol::someRequiredFunc().<br>&gt; <br>&gt; Your argument is that two methods with the same name should not in any way conflict with each other. This is a fundamental change from the status quo. If we were to take your argument to its logical conclusion, any member A of a type T should be capable of being designated as the implementation of a requirement B of protocol P. In the most general case, two functions A and B shouldn&#39;t even need to take the same number of arguments, or arguments of the same type; you should be able to supply default arguments, or even write custom code that takes arguments for A and computes suitable arguments for B in order to forward A to B, and the language should allow you to designate A as an implementation of B. But that is simply not how Swift protocols are designed.<br>&gt;  <br>&gt; Let’s take an example where retroactive modelling could go wrong. You’ve got different teams working on different parts of an App, and they’ve all got their own convention for “copy()”. Sometimes it’s a deep-copy, sometimes a shallow-copy, sometimes it’s used in a fragile way for a specific case, whatever. Now you want to go and clean that up by creating a “Copyable” protocol with codified guarantees. Some objects may already conform, others may need tweaks, and some may want both behaviours simultaneously (preserving the old, non-Copytable-compliant behaviour until the next API break), depending on how you look at the object. A system like this allows all of those different ways of looking at the object live together. You could have the old, non-comforming API as an extension with a FIXME to delete it for version 2.<br>&gt; <br>&gt; Even if you design a protocol called Copyable, you still need to explicitly extend concrete types in order to conform to Copyable. Swift does not automagically make anything conform to your protocol. If you choose *explicitly* to conform different types that don&#39;t guarantee the same semantics, and then you erroneously assume that they all have the same semantics even though you *explicitly* chose types that don&#39;t have the same semantics, you&#39;re the one who shot yourself in the foot, so to speak. It&#39;s not the fault of Swift at all.<br>&gt; <br>&gt; <br>&gt; I think it’s pretty arcane that members of a type are resolved only by their names. If you want to provide types which allow flexible views of data, each view of that data needs to be completely free in its expressivity.<br>&gt; <br>&gt; I would actually like to see a syntax like:<br>&gt; <br>&gt; ```<br>&gt; let testObject = MyClass()<br>&gt; let testMyProto = testObject.MyProtocol // the protocol-witness table for testObject as a MyProtocol.<br>&gt; <br>&gt; testObject.MyProtocol.someRequiredFunc() // that’s one function<br>&gt; testObject.someRequiredFunc() // is a different function. May happen to have the same implementation as above if MyProtocol was retroactively modelled.<br>&gt; ```<br>&gt; <br>&gt; I think it would fit well with the dispatch system for protocol extensions, too. I sometimes have code like the following:<br>&gt; <br>&gt; ```<br>&gt; protocol Base {}<br>&gt; protocol Derived : Base {}<br>&gt; <br>&gt; extension Base { <br>&gt;   func doSomething() { … }<br>&gt; }<br>&gt; extension Derived {<br>&gt;   func doSomething() {<br>&gt;    …<br>&gt;    (self as Base).doSomething() // Would be better if we could say “self.Base.doSomething()” to disambiguate instead of casting.<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This is a complete redesign of protocols in Swift. With the emphasis on minimizing source-breaking changes, I doubt such a change would be in scope for any phase of Swift unless you could show an overwhelming benefit.<br>&gt; <br>&gt; So yeah, a big +1 to marking protocol methods with their protocol (whatever the syntax ends up looking like), and actually I’d take it further and bake them in to the ABI. That also makes it relevant for Swift 4 phase 1.<br>&gt; <br>&gt; Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160917/3c348e27/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 19, 2016 at 08:00:00pm</p></header><div class="content"><p>On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;<br>&gt; Let me give a concrete example of how retroactively modeling is used.<br></p><p>Karl is suggesting interesting but complex and IMO too much code-breaking <br>idea that I don&#39;t believe can be implemented at all in a reasonable amount <br>of time to be a part of Swift as soon as possible, to address the discussed <br>issue with protocols.<br></p><p>I wonder what objections could be made on the solution proposed below, <br>which should solve a major(IMO) number of issues with protocol conformance <br>and introduce only 1 keyword. Such solution will make Swift better as <br>Protocol-Oriented language and later we can even improve it, but it can <br>already solve a big number of issues:<br></p><p>1. As soon as possible we add &#39;implement&#39; keyword which is required to mark <br>method/property that was defined in type or extension exactly to conform to <br>some protocol.<br></p><p>2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance, i.e. <br>when you declare methods/props of the type/extension that explicitly <br>conformed to protocol.<br></p><p>3. Retrospective conformance will not require this keyword and will work <br>for now just like it is working today.<br></p><p>4. Later, if this will be possible at all, we can extend this model to <br>support separate implementation of protocols with same requirements in the <br>same type, explicit protocol name in implemented methods/props and <br>improvements for retrospective conformance. For example some variants for <br>*future* improvements:<br></p><p>4.1 Different implementation for different protocols<br>class Foo : ProtocolA, ProtocolB {<br>   implement(ProtocolA) func foo() {...}<br>   implement(ProtocolB) func foo() {...}<br>}<br>class Foo : ProtocolA, ProtocolB {<br>   implement ProtocolA {<br>  	func foo() {...}<br>   }<br>   implement ProtocolB {<br>  	func foo() {...}<br>   }<br>}<br>etc<br></p><p>4.2 Retrospective conformance: What is the main problem with retrospective <br>conformance? As I see it now(correct me, if I missing something), the <br>problem arises in such situation:<br>* we *expect* that some method(s) in type will play the role of <br>implementation of protocol&#39;s requirements, so we retrospectively conform <br>that type to the protocol.<br>* but protocol has default implementation for its requirements<br>* and type&#39;s methods, that we *expect* to play roles for protocol <br>implementation, has different parameters or slightly different method name <br>at all.<br></p><p>I.e. when we have this set of code logic:<br></p><p>type T {<br>   func foo()<br>}<br></p><p>protocol P {<br>   func foo(x: Int)<br>}<br></p><p>extension P {<br>   func foo(x: Int) {...}<br>}<br></p><p>extension T : P { // expect foo in T will play role of P.foo<br>}<br></p><p>I support the opinion that it is not an option to require to explicitly <br>list conformed methods/props in type extension for retrospective conformance.<br>But I do believe we need a way to *express our intention* regarding the <br>retrospective conformance: do we expect that type already contains <br>implementation for some protocol&#39;s requirements OR we are aware that <br>protocol can have defaults for some methods and our type does not contains <br>some implementations.<br></p><p>So, the solution here IMO is some syntax to express that intention. Right <br>now I think that we can use current syntax &quot;extension T : P&quot; to keep it <br>working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat <br>this as usually you did&quot;. But for example something like &quot;extension T: <br>implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we <br>*expect* that all requirements of P protocol should be implemented inside T <br>type. Or some syntax inside extension to specify the list of methods/props <br>we expect to be implemented in T. Or &quot;extension T : P(implement foo, <br>bar(x:y:)) {..}&quot;.. Should be discussed.<br></p><p>But again, IMO this could be discussed later, after we&#39;ll have &#39;implement&#39; <br>for most important place - in type definition for method/prop that we <br>created exactly for the conformed protocol.<br></p><p>Opinions?<br></p><p>&gt; Currently, there is a JIRA bug that Set does not conform to SetAlgebra. To<br>&gt; fix this issue, someone simply needs to write `extension Set : SetAlgebra {<br>&gt; }` and some tests. That&#39;s literally what the bug (filed by a core team<br>&gt; member) tells you to do. It&#39;s a starter bug, and if someone hasn&#39;t taken it<br>&gt; yet, you the reader could have a go at it. What&#39;s neat about Swift is that<br>&gt; it&#39;s super easy to provide the same functionality in your own project<br>&gt; without waiting on that bug to be fixed in Swift itself. You can simply<br>&gt; write a single line of code. By contrast, if your proposal were to be<br>&gt; implemented, this would become much more difficult.<br>&gt;<br>&gt; This is actively used in Swift today. For example, in the Swift<br>&gt; implementation of NSScanner, you&#39;ll find the following lines:<br>&gt;<br>&gt; ```<br>&gt; internal protocol _BitShiftable {<br>&gt;     static func &gt;&gt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     static func &lt;&lt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; internal protocol _IntegerLike : Integer, _BitShiftable {<br>&gt;     init(_ value: Int)<br>&gt;     static var max: Self { get }<br>&gt;     static var min: Self { get }<br>&gt; }<br>&gt;<br>&gt; extension Int : _IntegerLike { }<br>&gt; extension Int32 : _IntegerLike { }<br>&gt; extension Int64 : _IntegerLike { }<br>&gt; extension UInt32 : _IntegerLike { }<br>&gt; extension UInt64 : _IntegerLike { }<br>&gt; ```<br>&gt;<br>&gt; If we adopted your proposed syntax below, it would take considerably more<br>&gt; lines of boilerplate code to express the same thing. The burden increases<br>&gt; significantly with the complexity of the retroactive modeling. For<br>&gt; instance, if the retroactively modeled protocol had 20 requirements and you<br>&gt; were retroactively conforming 20 types, that&#39;d be at least 400 lines of<br>&gt; boilerplate.<br>&gt;<br>&gt;<br>&gt;     Basically, the way I see it, if my class MyClass implements MyProtocol,<br>&gt;     providing someRequiredFunc(), there’s an “ownership” chain there<br>&gt;     (reading it backwards).<br>&gt;<br>&gt;     Now what happens if MyClass implements MyOtherProtocol, which also has<br>&gt;     someRequiredFunc()? In that case, I want to MyClass as a<br>&gt;     MyOtherProtocol and get another function pointer, which just happens to<br>&gt;     have the same human-readable name as some other property. Just because<br>&gt;     they have the same function signature, absolutely doesn’t mean they’re<br>&gt;     the same thing.<br>&gt;<br>&gt;     Now, if we strongly bind all protocol conformances to the protocol they<br>&gt;     implement, what happens to instance methods? They don’t belong to any<br>&gt;     protocol, their parent is the class itself. If you have an instance<br>&gt;     method called someRequiredFunc(), and you later add a conformance to<br>&gt;     MyProtocol, you would need to declare that it belongs to MyProtocol. If<br>&gt;     you don’t want it to be an API-breaking change, you have to provide a<br>&gt;     thunk (or we could provide a shorthand syntax which emits thunks for<br>&gt;     you) to let us know that MyClass::someRequiredFunc() is the same thing<br>&gt;     as MyClass::MyProtocol::someRequiredFunc().<br>&gt;<br>&gt;<br>&gt; Your argument is that two methods with the same name should not in any way<br>&gt; conflict with each other. This is a fundamental change from the status quo.<br>&gt; If we were to take your argument to its logical conclusion, any member A of<br>&gt; a type T should be capable of being designated as the implementation of a<br>&gt; requirement B of protocol P. In the most general case, two functions A and<br>&gt; B shouldn&#39;t even need to take the same number of arguments, or arguments of<br>&gt; the same type; you should be able to supply default arguments, or even<br>&gt; write custom code that takes arguments for A and computes suitable<br>&gt; arguments for B in order to forward A to B, and the language should allow<br>&gt; you to designate A as an implementation of B. But that is simply not how<br>&gt; Swift protocols are designed.<br>&gt;<br>&gt;<br>&gt;     Let’s take an example where retroactive modelling could go wrong.<br>&gt;     You’ve got different teams working on different parts of an App, and<br>&gt;     they’ve all got their own convention for “copy()”. Sometimes it’s a<br>&gt;     deep-copy, sometimes a shallow-copy, sometimes it’s used in a fragile<br>&gt;     way for a specific case, whatever. Now you want to go and clean that up<br>&gt;     by creating a “Copyable” protocol with codified guarantees. Some<br>&gt;     objects may already conform, others may need tweaks, and some may want<br>&gt;     both behaviours simultaneously (preserving the old,<br>&gt;     non-Copytable-compliant behaviour until the next API break), depending<br>&gt;     on how you look at the object. A system like this allows all of those<br>&gt;     different ways of looking at the object live together. You could have<br>&gt;     the old, non-comforming API as an extension with a FIXME to delete it<br>&gt;     for version 2.<br>&gt;<br>&gt;<br>&gt; Even if you design a protocol called Copyable, you still need to explicitly<br>&gt; extend concrete types in order to conform to Copyable. Swift does not<br>&gt; automagically make anything conform to your protocol. If you choose<br>&gt; *explicitly* to conform different types that don&#39;t guarantee the same<br>&gt; semantics, and then you erroneously assume that they all have the same<br>&gt; semantics even though you *explicitly* chose types that don&#39;t have the same<br>&gt; semantics, you&#39;re the one who shot yourself in the foot, so to speak. It&#39;s<br>&gt; not the fault of Swift at all.<br>&gt;<br>&gt;<br>&gt;     I think it’s pretty arcane that members of a type are resolved only by<br>&gt;     their names. If you want to provide types which allow flexible views of<br>&gt;     data, each view of that data needs to be completely free in its<br>&gt;     expressivity.<br>&gt;<br>&gt;     I would actually like to see a syntax like:<br>&gt;<br>&gt;     ```<br>&gt;     let testObject = MyClass()<br>&gt;     let testMyProto = testObject.MyProtocol // the protocol-witness table<br>&gt;     for testObject as a MyProtocol.<br>&gt;<br>&gt;     testObject.MyProtocol.someRequiredFunc() // that’s one function<br>&gt;     testObject.someRequiredFunc() // is a different function. May happen to<br>&gt;     have the same implementation as above if MyProtocol was retroactively<br>&gt;     modelled.<br>&gt;     ```<br>&gt;<br>&gt;     I think it would fit well with the dispatch system for protocol<br>&gt;     extensions, too. I sometimes have code like the following:<br>&gt;<br>&gt;     ```<br>&gt;     protocol Base {}<br>&gt;     protocol Derived : Base {}<br>&gt;<br>&gt;     extension Base {<br>&gt;       func doSomething() { … }<br>&gt;     }<br>&gt;     extension Derived {<br>&gt;       func doSomething() {<br>&gt;        …<br>&gt;        (self as Base).doSomething() // Would be better if we could say<br>&gt;     “self.Base.doSomething()” to disambiguate instead of casting.<br>&gt;       }<br>&gt;     }<br>&gt;     ```<br>&gt;<br>&gt;<br>&gt; This is a complete redesign of protocols in Swift. With the emphasis on<br>&gt; minimizing source-breaking changes, I doubt such a change would be in scope<br>&gt; for any phase of Swift unless you could show an overwhelming benefit.<br>&gt;<br>&gt;     So yeah, a big +1 to marking protocol methods with their protocol<br>&gt;     (whatever the syntax ends up looking like), and actually I’d take it<br>&gt;     further and bake them in to the ABI. That also makes it relevant for<br>&gt;     Swift 4 phase 1.<br>&gt;<br>&gt;     Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>September 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 19, 2016, at 12:10 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt; <br>&gt; Karl is suggesting interesting but complex and IMO too much code-breaking idea that I don&#39;t believe can be implemented at all in a reasonable amount of time to be a part of Swift as soon as possible, to address the discussed issue with protocols.<br>&gt; <br>&gt; I wonder what objections could be made on the solution proposed below, which should solve a major(IMO) number of issues with protocol conformance and introduce only 1 keyword. Such solution will make Swift better as Protocol-Oriented language and later we can even improve it, but it can already solve a big number of issues:<br>&gt; <br>&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to mark method/property that was defined in type or extension exactly to conform to some protocol.<br>&gt; <br>&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance, i.e. when you declare methods/props of the type/extension that explicitly conformed to protocol.<br>&gt; <br>&gt; 3. Retrospective conformance will not require this keyword and will work for now just like it is working today.<br>&gt; <br>&gt; 4. Later, if this will be possible at all, we can extend this model to support separate implementation of protocols with same requirements in the same type, explicit protocol name in implemented methods/props and improvements for retrospective conformance. For example some variants for *future* improvements:<br>&gt; <br>&gt; 4.1 Different implementation for different protocols<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement(ProtocolA) func foo() {...}<br>&gt;  implement(ProtocolB) func foo() {...}<br>&gt; }<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement ProtocolA {<br>&gt; 	func foo() {...}<br>&gt;  }<br>&gt;  implement ProtocolB {<br>&gt; 	func foo() {...}<br>&gt;  }<br>&gt; }<br>&gt; etc<br>&gt; <br>&gt; 4.2 Retrospective conformance: What is the main problem with retrospective conformance? As I see it now(correct me, if I missing something), the problem arises in such situation:<br>&gt; * we *expect* that some method(s) in type will play the role of implementation of protocol&#39;s requirements, so we retrospectively conform that type to the protocol.<br>&gt; * but protocol has default implementation for its requirements<br>&gt; * and type&#39;s methods, that we *expect* to play roles for protocol implementation, has different parameters or slightly different method name at all.<br>&gt; <br>&gt; I.e. when we have this set of code logic:<br>&gt; <br>&gt; type T {<br>&gt;  func foo()<br>&gt; }<br>&gt; <br>&gt; protocol P {<br>&gt;  func foo(x: Int)<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;  func foo(x: Int) {...}<br>&gt; }<br>&gt; <br>&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt; }<br>&gt; <br>&gt; I support the opinion that it is not an option to require to explicitly list conformed methods/props in type extension for retrospective conformance.<br>&gt; But I do believe we need a way to *express our intention* regarding the retrospective conformance: do we expect that type already contains implementation for some protocol&#39;s requirements OR we are aware that protocol can have defaults for some methods and our type does not contains some implementations.<br>&gt; <br>&gt; So, the solution here IMO is some syntax to express that intention. Right now I think that we can use current syntax &quot;extension T : P&quot; to keep it working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat this as usually you did&quot;. But for example something like &quot;extension T: implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we *expect* that all requirements of P protocol should be implemented inside T type. Or some syntax inside extension to specify the list of methods/props we expect to be implemented in T. Or &quot;extension T : P(implement foo, bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt; <br>&gt; But again, IMO this could be discussed later, after we&#39;ll have &#39;implement&#39; for most important place - in type definition for method/prop that we created exactly for the conformed protocol.<br></p><p>I would be completely +1 on this.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/b0028dc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 19, 2016 at 09:00:00pm</p></header><div class="content"><p>If Swift 4 will make it impossible to tackle this again, I do not think discussing this can be avoided for Swift 3.1... I am afraid we are rushing into Swift 4 a bit too quickly, but perhaps it is just silly old me :).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 19 Sep 2016, at 19:18, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 19, 2016, at 12:10 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt;&gt; <br>&gt;&gt; Karl is suggesting interesting but complex and IMO too much code-breaking idea that I don&#39;t believe can be implemented at all in a reasonable amount of time to be a part of Swift as soon as possible, to address the discussed issue with protocols.<br>&gt;&gt; <br>&gt;&gt; I wonder what objections could be made on the solution proposed below, which should solve a major(IMO) number of issues with protocol conformance and introduce only 1 keyword. Such solution will make Swift better as Protocol-Oriented language and later we can even improve it, but it can already solve a big number of issues:<br>&gt;&gt; <br>&gt;&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to mark method/property that was defined in type or extension exactly to conform to some protocol.<br>&gt;&gt; <br>&gt;&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance, i.e. when you declare methods/props of the type/extension that explicitly conformed to protocol.<br>&gt;&gt; <br>&gt;&gt; 3. Retrospective conformance will not require this keyword and will work for now just like it is working today.<br>&gt;&gt; <br>&gt;&gt; 4. Later, if this will be possible at all, we can extend this model to support separate implementation of protocols with same requirements in the same type, explicit protocol name in implemented methods/props and improvements for retrospective conformance. For example some variants for *future* improvements:<br>&gt;&gt; <br>&gt;&gt; 4.1 Different implementation for different protocols<br>&gt;&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;  implement(ProtocolA) func foo() {...}<br>&gt;&gt;  implement(ProtocolB) func foo() {...}<br>&gt;&gt; }<br>&gt;&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;  implement ProtocolA {<br>&gt;&gt; 	func foo() {...}<br>&gt;&gt;  }<br>&gt;&gt;  implement ProtocolB {<br>&gt;&gt; 	func foo() {...}<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; 4.2 Retrospective conformance: What is the main problem with retrospective conformance? As I see it now(correct me, if I missing something), the problem arises in such situation:<br>&gt;&gt; * we *expect* that some method(s) in type will play the role of implementation of protocol&#39;s requirements, so we retrospectively conform that type to the protocol.<br>&gt;&gt; * but protocol has default implementation for its requirements<br>&gt;&gt; * and type&#39;s methods, that we *expect* to play roles for protocol implementation, has different parameters or slightly different method name at all.<br>&gt;&gt; <br>&gt;&gt; I.e. when we have this set of code logic:<br>&gt;&gt; <br>&gt;&gt; type T {<br>&gt;&gt;  func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  func foo(x: Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;  func foo(x: Int) {...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I support the opinion that it is not an option to require to explicitly list conformed methods/props in type extension for retrospective conformance.<br>&gt;&gt; But I do believe we need a way to *express our intention* regarding the retrospective conformance: do we expect that type already contains implementation for some protocol&#39;s requirements OR we are aware that protocol can have defaults for some methods and our type does not contains some implementations.<br>&gt;&gt; <br>&gt;&gt; So, the solution here IMO is some syntax to express that intention. Right now I think that we can use current syntax &quot;extension T : P&quot; to keep it working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat this as usually you did&quot;. But for example something like &quot;extension T: implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we *expect* that all requirements of P protocol should be implemented inside T type. Or some syntax inside extension to specify the list of methods/props we expect to be implemented in T. Or &quot;extension T : P(implement foo, bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt;&gt; <br>&gt;&gt; But again, IMO this could be discussed later, after we&#39;ll have &#39;implement&#39; for most important place - in type definition for method/prop that we created exactly for the conformed protocol.<br>&gt; <br>&gt; I would be completely +1 on this.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/fa51071f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 19, 2016 at 07:00:00pm</p></header><div class="content"><p>I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br></p><p>However, I think it could be improved in one key respect where previous<br>proposals using `override` are superior. Namely, the proposed `implement`<br>keyword adds no additional safety when a type implements a protocol<br>requirement that doesn&#39;t have a default implementation. This is because, if<br>there&#39;s a &quot;near-miss&quot; typo in the function signature, an error is already<br>generated at compile time because the type doesn&#39;t conform to the stated<br>protocol. Currently, the error is very unhelpful, but IMO that&#39;s a<br>straight-up bug; improving the diagnostics for that error can be done<br>without evolution.<br></p><p>On the other hand, if we require `implement`, the simplest use case of<br>conforming a type to a protocol with no default implementations would take<br>more effort but provide no benefit to justify that additional effort.<br>Moreover (I think a core team member has expressed this more elegantly in<br>the past), there&#39;s the philosophical point that POP represents the<br>theoretical process by which we discover and express our discovery that<br>certain types happen to share common semantic characteristics. In that<br>conception of POP, it would be backwards to declare a certain member as<br>fulfilling certain protocol requirements.<br></p><p>So, if such a source breaking change were to be in scope for Swift, I would<br>suggest modifying Vladimir&#39;s proposal to use `override` instead and<br>requiring the keyword only when a default implementation is being<br>overridden. To accommodate retroactive conformance, we could either propose<br>that `extension Foo : Bar` is automatically understood to contain members<br>that override default implementations (as Vladimir has essentially<br>suggested), or stipulate that we must write `extension Foo : override Bar`.<br>This has the advantage of not introducing an additional keyword and avoids<br>the seemingly reduplicative spelling `extension Foo : implement Bar` (for<br>what else would an `extension Foo : Bar` reasonably do but implement the<br>requirements of Bar?).<br></p><p><br>On Mon, Sep 19, 2016 at 3:10 PM, Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If Swift 4 will make it impossible to tackle this again, I do not think<br>&gt; discussing this can be avoided for Swift 3.1... I am afraid we are rushing<br>&gt; into Swift 4 a bit too quickly, but perhaps it is just silly old me :).<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 19 Sep 2016, at 19:18, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sep 19, 2016, at 12:10 PM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt;<br>&gt;<br>&gt; Karl is suggesting interesting but complex and IMO too much code-breaking<br>&gt; idea that I don&#39;t believe can be implemented at all in a reasonable amount<br>&gt; of time to be a part of Swift as soon as possible, to address the discussed<br>&gt; issue with protocols.<br>&gt;<br>&gt; I wonder what objections could be made on the solution proposed below,<br>&gt; which should solve a major(IMO) number of issues with protocol conformance<br>&gt; and introduce only 1 keyword. Such solution will make Swift better as<br>&gt; Protocol-Oriented language and later we can even improve it, but it can<br>&gt; already solve a big number of issues:<br>&gt;<br>&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to<br>&gt; mark method/property that was defined in type or extension exactly to<br>&gt; conform to some protocol.<br>&gt;<br>&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance, i.e.<br>&gt; when you declare methods/props of the type/extension that explicitly<br>&gt; conformed to protocol.<br>&gt;<br>&gt; 3. Retrospective conformance will not require this keyword and will work<br>&gt; for now just like it is working today.<br>&gt;<br>&gt; 4. Later, if this will be possible at all, we can extend this model to<br>&gt; support separate implementation of protocols with same requirements in the<br>&gt; same type, explicit protocol name in implemented methods/props and<br>&gt; improvements for retrospective conformance. For example some variants for<br>&gt; *future* improvements:<br>&gt;<br>&gt; 4.1 Different implementation for different protocols<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement(ProtocolA) func foo() {...}<br>&gt;  implement(ProtocolB) func foo() {...}<br>&gt; }<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement ProtocolA {<br>&gt; func foo() {...}<br>&gt;  }<br>&gt;  implement ProtocolB {<br>&gt; func foo() {...}<br>&gt;  }<br>&gt; }<br>&gt; etc<br>&gt;<br>&gt; 4.2 Retrospective conformance: What is the main problem with retrospective<br>&gt; conformance? As I see it now(correct me, if I missing something), the<br>&gt; problem arises in such situation:<br>&gt; * we *expect* that some method(s) in type will play the role of<br>&gt; implementation of protocol&#39;s requirements, so we retrospectively conform<br>&gt; that type to the protocol.<br>&gt; * but protocol has default implementation for its requirements<br>&gt; * and type&#39;s methods, that we *expect* to play roles for protocol<br>&gt; implementation, has different parameters or slightly different method name<br>&gt; at all.<br>&gt;<br>&gt; I.e. when we have this set of code logic:<br>&gt;<br>&gt; type T {<br>&gt;  func foo()<br>&gt; }<br>&gt;<br>&gt; protocol P {<br>&gt;  func foo(x: Int)<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;  func foo(x: Int) {...}<br>&gt; }<br>&gt;<br>&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt; }<br>&gt;<br>&gt; I support the opinion that it is not an option to require to explicitly<br>&gt; list conformed methods/props in type extension for retrospective<br>&gt; conformance.<br>&gt; But I do believe we need a way to *express our intention* regarding the<br>&gt; retrospective conformance: do we expect that type already contains<br>&gt; implementation for some protocol&#39;s requirements OR we are aware that<br>&gt; protocol can have defaults for some methods and our type does not contains<br>&gt; some implementations.<br>&gt;<br>&gt; So, the solution here IMO is some syntax to express that intention. Right<br>&gt; now I think that we can use current syntax &quot;extension T : P&quot; to keep it<br>&gt; working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat<br>&gt; this as usually you did&quot;. But for example something like &quot;extension T:<br>&gt; implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we<br>&gt; *expect* that all requirements of P protocol should be implemented inside T<br>&gt; type. Or some syntax inside extension to specify the list of methods/props<br>&gt; we expect to be implemented in T. Or &quot;extension T : P(implement foo,<br>&gt; bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt;<br>&gt; But again, IMO this could be discussed later, after we&#39;ll have &#39;implement&#39;<br>&gt; for most important place - in type definition for method/prop that we<br>&gt; created exactly for the conformed protocol.<br>&gt;<br>&gt;<br>&gt; I would be completely +1 on this.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/03d2d742/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>September 20, 2016 at 12:00:00am</p></header><div class="content"><p>I don&#39;t think &quot;override&quot; is a good idea. It&#39;s not overriding.<br></p><p>Protocol is not Class.<br></p><p><br>Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年9月20日<br>周二08:04写道：<br></p><p>&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;<br>&gt; However, I think it could be improved in one key respect where previous<br>&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt; keyword adds no additional safety when a type implements a protocol<br>&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt; there&#39;s a &quot;near-miss&quot; typo in the function signature, an error is already<br>&gt; generated at compile time because the type doesn&#39;t conform to the stated<br>&gt; protocol. Currently, the error is very unhelpful, but IMO that&#39;s a<br>&gt; straight-up bug; improving the diagnostics for that error can be done<br>&gt; without evolution.<br>&gt;<br>&gt; On the other hand, if we require `implement`, the simplest use case of<br>&gt; conforming a type to a protocol with no default implementations would take<br>&gt; more effort but provide no benefit to justify that additional effort.<br>&gt; Moreover (I think a core team member has expressed this more elegantly in<br>&gt; the past), there&#39;s the philosophical point that POP represents the<br>&gt; theoretical process by which we discover and express our discovery that<br>&gt; certain types happen to share common semantic characteristics. In that<br>&gt; conception of POP, it would be backwards to declare a certain member as<br>&gt; fulfilling certain protocol requirements.<br>&gt;<br>&gt; So, if such a source breaking change were to be in scope for Swift, I<br>&gt; would suggest modifying Vladimir&#39;s proposal to use `override` instead and<br>&gt; requiring the keyword only when a default implementation is being<br>&gt; overridden. To accommodate retroactive conformance, we could either propose<br>&gt; that `extension Foo : Bar` is automatically understood to contain members<br>&gt; that override default implementations (as Vladimir has essentially<br>&gt; suggested), or stipulate that we must write `extension Foo : override Bar`.<br>&gt; This has the advantage of not introducing an additional keyword and avoids<br>&gt; the seemingly reduplicative spelling `extension Foo : implement Bar` (for<br>&gt; what else would an `extension Foo : Bar` reasonably do but implement the<br>&gt; requirements of Bar?).<br>&gt;<br>&gt;<br>&gt; On Mon, Sep 19, 2016 at 3:10 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; If Swift 4 will make it impossible to tackle this again, I do not think<br>&gt;&gt; discussing this can be avoided for Swift 3.1... I am afraid we are rushing<br>&gt;&gt; into Swift 4 a bit too quickly, but perhaps it is just silly old me :).<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On 19 Sep 2016, at 19:18, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Sep 19, 2016, at 12:10 PM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Karl is suggesting interesting but complex and IMO too much code-breaking<br>&gt;&gt; idea that I don&#39;t believe can be implemented at all in a reasonable amount<br>&gt;&gt; of time to be a part of Swift as soon as possible, to address the discussed<br>&gt;&gt; issue with protocols.<br>&gt;&gt;<br>&gt;&gt; I wonder what objections could be made on the solution proposed below,<br>&gt;&gt; which should solve a major(IMO) number of issues with protocol conformance<br>&gt;&gt; and introduce only 1 keyword. Such solution will make Swift better as<br>&gt;&gt; Protocol-Oriented language and later we can even improve it, but it can<br>&gt;&gt; already solve a big number of issues:<br>&gt;&gt;<br>&gt;&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to<br>&gt;&gt; mark method/property that was defined in type or extension exactly to<br>&gt;&gt; conform to some protocol.<br>&gt;&gt;<br>&gt;&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance,<br>&gt;&gt; i.e. when you declare methods/props of the type/extension that explicitly<br>&gt;&gt; conformed to protocol.<br>&gt;&gt;<br>&gt;&gt; 3. Retrospective conformance will not require this keyword and will work<br>&gt;&gt; for now just like it is working today.<br>&gt;&gt;<br>&gt;&gt; 4. Later, if this will be possible at all, we can extend this model to<br>&gt;&gt; support separate implementation of protocols with same requirements in the<br>&gt;&gt; same type, explicit protocol name in implemented methods/props and<br>&gt;&gt; improvements for retrospective conformance. For example some variants for<br>&gt;&gt; *future* improvements:<br>&gt;&gt;<br>&gt;&gt; 4.1 Different implementation for different protocols<br>&gt;&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;  implement(ProtocolA) func foo() {...}<br>&gt;&gt;  implement(ProtocolB) func foo() {...}<br>&gt;&gt; }<br>&gt;&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;  implement ProtocolA {<br>&gt;&gt; func foo() {...}<br>&gt;&gt;  }<br>&gt;&gt;  implement ProtocolB {<br>&gt;&gt; func foo() {...}<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; etc<br>&gt;&gt;<br>&gt;&gt; 4.2 Retrospective conformance: What is the main problem with<br>&gt;&gt; retrospective conformance? As I see it now(correct me, if I missing<br>&gt;&gt; something), the problem arises in such situation:<br>&gt;&gt; * we *expect* that some method(s) in type will play the role of<br>&gt;&gt; implementation of protocol&#39;s requirements, so we retrospectively conform<br>&gt;&gt; that type to the protocol.<br>&gt;&gt; * but protocol has default implementation for its requirements<br>&gt;&gt; * and type&#39;s methods, that we *expect* to play roles for protocol<br>&gt;&gt; implementation, has different parameters or slightly different method name<br>&gt;&gt; at all.<br>&gt;&gt;<br>&gt;&gt; I.e. when we have this set of code logic:<br>&gt;&gt;<br>&gt;&gt; type T {<br>&gt;&gt;  func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;  func foo(x: Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt;  func foo(x: Int) {...}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I support the opinion that it is not an option to require to explicitly<br>&gt;&gt; list conformed methods/props in type extension for retrospective<br>&gt;&gt; conformance.<br>&gt;&gt; But I do believe we need a way to *express our intention* regarding the<br>&gt;&gt; retrospective conformance: do we expect that type already contains<br>&gt;&gt; implementation for some protocol&#39;s requirements OR we are aware that<br>&gt;&gt; protocol can have defaults for some methods and our type does not contains<br>&gt;&gt; some implementations.<br>&gt;&gt;<br>&gt;&gt; So, the solution here IMO is some syntax to express that intention. Right<br>&gt;&gt; now I think that we can use current syntax &quot;extension T : P&quot; to keep it<br>&gt;&gt; working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat<br>&gt;&gt; this as usually you did&quot;. But for example something like &quot;extension T:<br>&gt;&gt; implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we<br>&gt;&gt; *expect* that all requirements of P protocol should be implemented inside T<br>&gt;&gt; type. Or some syntax inside extension to specify the list of methods/props<br>&gt;&gt; we expect to be implemented in T. Or &quot;extension T : P(implement foo,<br>&gt;&gt; bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt;&gt;<br>&gt;&gt; But again, IMO this could be discussed later, after we&#39;ll have<br>&gt;&gt; &#39;implement&#39; for most important place - in type definition for method/prop<br>&gt;&gt; that we created exactly for the conformed protocol.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I would be completely +1 on this.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/6d456311/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 19, 2016 at 07:00:00pm</p></header><div class="content"><p>On Mon, Sep 19, 2016 at 7:15 PM, Boris Wang &lt;kona.ming at gmail.com&gt; wrote:<br></p><p>&gt; I don&#39;t think &quot;override&quot; is a good idea. It&#39;s not overriding.<br>&gt;<br>&gt; Protocol is not Class.<br>&gt;<br></p><p><br>I think you make a good point. It seems like people have generally written<br>about &quot;overriding&quot; default implementations, but that might not be the best<br>term and it may be a little confusing. Is there a &quot;more correct&quot; word for<br>this scenario?<br></p><p><br>Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年9月20日<br>&gt; 周二08:04写道：<br>&gt;<br>&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;<br>&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt; there&#39;s a &quot;near-miss&quot; typo in the function signature, an error is already<br>&gt;&gt; generated at compile time because the type doesn&#39;t conform to the stated<br>&gt;&gt; protocol. Currently, the error is very unhelpful, but IMO that&#39;s a<br>&gt;&gt; straight-up bug; improving the diagnostics for that error can be done<br>&gt;&gt; without evolution.<br>&gt;&gt;<br>&gt;&gt; On the other hand, if we require `implement`, the simplest use case of<br>&gt;&gt; conforming a type to a protocol with no default implementations would take<br>&gt;&gt; more effort but provide no benefit to justify that additional effort.<br>&gt;&gt; Moreover (I think a core team member has expressed this more elegantly in<br>&gt;&gt; the past), there&#39;s the philosophical point that POP represents the<br>&gt;&gt; theoretical process by which we discover and express our discovery that<br>&gt;&gt; certain types happen to share common semantic characteristics. In that<br>&gt;&gt; conception of POP, it would be backwards to declare a certain member as<br>&gt;&gt; fulfilling certain protocol requirements.<br>&gt;&gt;<br>&gt;&gt; So, if such a source breaking change were to be in scope for Swift, I<br>&gt;&gt; would suggest modifying Vladimir&#39;s proposal to use `override` instead and<br>&gt;&gt; requiring the keyword only when a default implementation is being<br>&gt;&gt; overridden. To accommodate retroactive conformance, we could either propose<br>&gt;&gt; that `extension Foo : Bar` is automatically understood to contain members<br>&gt;&gt; that override default implementations (as Vladimir has essentially<br>&gt;&gt; suggested), or stipulate that we must write `extension Foo : override Bar`.<br>&gt;&gt; This has the advantage of not introducing an additional keyword and avoids<br>&gt;&gt; the seemingly reduplicative spelling `extension Foo : implement Bar` (for<br>&gt;&gt; what else would an `extension Foo : Bar` reasonably do but implement the<br>&gt;&gt; requirements of Bar?).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Sep 19, 2016 at 3:10 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; If Swift 4 will make it impossible to tackle this again, I do not think<br>&gt;&gt;&gt; discussing this can be avoided for Swift 3.1... I am afraid we are rushing<br>&gt;&gt;&gt; into Swift 4 a bit too quickly, but perhaps it is just silly old me :).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 19 Sep 2016, at 19:18, Charles Srstka via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sep 19, 2016, at 12:10 PM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Karl is suggesting interesting but complex and IMO too much<br>&gt;&gt;&gt; code-breaking idea that I don&#39;t believe can be implemented at all in a<br>&gt;&gt;&gt; reasonable amount of time to be a part of Swift as soon as possible, to<br>&gt;&gt;&gt; address the discussed issue with protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I wonder what objections could be made on the solution proposed below,<br>&gt;&gt;&gt; which should solve a major(IMO) number of issues with protocol conformance<br>&gt;&gt;&gt; and introduce only 1 keyword. Such solution will make Swift better as<br>&gt;&gt;&gt; Protocol-Oriented language and later we can even improve it, but it can<br>&gt;&gt;&gt; already solve a big number of issues:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to<br>&gt;&gt;&gt; mark method/property that was defined in type or extension exactly to<br>&gt;&gt;&gt; conform to some protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance,<br>&gt;&gt;&gt; i.e. when you declare methods/props of the type/extension that explicitly<br>&gt;&gt;&gt; conformed to protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3. Retrospective conformance will not require this keyword and will work<br>&gt;&gt;&gt; for now just like it is working today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4. Later, if this will be possible at all, we can extend this model to<br>&gt;&gt;&gt; support separate implementation of protocols with same requirements in the<br>&gt;&gt;&gt; same type, explicit protocol name in implemented methods/props and<br>&gt;&gt;&gt; improvements for retrospective conformance. For example some variants for<br>&gt;&gt;&gt; *future* improvements:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4.1 Different implementation for different protocols<br>&gt;&gt;&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;&gt;  implement(ProtocolA) func foo() {...}<br>&gt;&gt;&gt;  implement(ProtocolB) func foo() {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;&gt;  implement ProtocolA {<br>&gt;&gt;&gt; func foo() {...}<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  implement ProtocolB {<br>&gt;&gt;&gt; func foo() {...}<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; etc<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4.2 Retrospective conformance: What is the main problem with<br>&gt;&gt;&gt; retrospective conformance? As I see it now(correct me, if I missing<br>&gt;&gt;&gt; something), the problem arises in such situation:<br>&gt;&gt;&gt; * we *expect* that some method(s) in type will play the role of<br>&gt;&gt;&gt; implementation of protocol&#39;s requirements, so we retrospectively conform<br>&gt;&gt;&gt; that type to the protocol.<br>&gt;&gt;&gt; * but protocol has default implementation for its requirements<br>&gt;&gt;&gt; * and type&#39;s methods, that we *expect* to play roles for protocol<br>&gt;&gt;&gt; implementation, has different parameters or slightly different method name<br>&gt;&gt;&gt; at all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I.e. when we have this set of code logic:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; type T {<br>&gt;&gt;&gt;  func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;  func foo(x: Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;  func foo(x: Int) {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I support the opinion that it is not an option to require to explicitly<br>&gt;&gt;&gt; list conformed methods/props in type extension for retrospective<br>&gt;&gt;&gt; conformance.<br>&gt;&gt;&gt; But I do believe we need a way to *express our intention* regarding the<br>&gt;&gt;&gt; retrospective conformance: do we expect that type already contains<br>&gt;&gt;&gt; implementation for some protocol&#39;s requirements OR we are aware that<br>&gt;&gt;&gt; protocol can have defaults for some methods and our type does not contains<br>&gt;&gt;&gt; some implementations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, the solution here IMO is some syntax to express that intention.<br>&gt;&gt;&gt; Right now I think that we can use current syntax &quot;extension T : P&quot; to keep<br>&gt;&gt;&gt; it working as it now works: &quot;I&#39;m aware of all the names, defaults etc.<br>&gt;&gt;&gt; Treat this as usually you did&quot;. But for example something like &quot;extension<br>&gt;&gt;&gt; T: implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we<br>&gt;&gt;&gt; *expect* that all requirements of P protocol should be implemented inside T<br>&gt;&gt;&gt; type. Or some syntax inside extension to specify the list of methods/props<br>&gt;&gt;&gt; we expect to be implemented in T. Or &quot;extension T : P(implement foo,<br>&gt;&gt;&gt; bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But again, IMO this could be discussed later, after we&#39;ll have<br>&gt;&gt;&gt; &#39;implement&#39; for most important place - in type definition for method/prop<br>&gt;&gt;&gt; that we created exactly for the conformed protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would be completely +1 on this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/c604cbd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>September 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 20 Sep 2016, at 02:25, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Sep 19, 2016 at 7:15 PM, Boris Wang &lt;kona.ming at gmail.com&gt; wrote:<br>&gt;&gt; I don&#39;t think &quot;override&quot; is a good idea. It&#39;s not overriding.<br>&gt;&gt; <br>&gt;&gt; Protocol is not Class.<br>&gt;&gt; <br>&gt; <br>&gt; I think you make a good point. It seems like people have generally written about &quot;overriding&quot; default implementations, but that might not be the best term and it may be a little confusing. Is there a “more correct&quot; word for this scenario?<br></p><p>It feels to me like it’s about the ordering (preference) of overloads for method lookups on types. vOv<br></p><p><br>	Daniel.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 20, 2016 at 04:00:00pm</p></header><div class="content"><p>Inline..<br></p><p>On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;<br>&gt; However, I think it could be improved in one key respect where previous<br>&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt; keyword adds no additional safety when a type implements a protocol<br>&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br></p><p>Yes, *at the moment of writing* the type&#39;s code there could be no default <br>implementation for protocol requirement. But, *at the moment of <br>compilation* such default implementation could appear.<br></p><p>Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br></p><p>You got SomeClass.swift file, 3rd party file you don&#39;t want to change or <br>changes are not allowed. Content:<br></p><p>public protocol SomeProtocol {<br>	func foo()<br>}<br></p><p>public class SomeClass : SomeProtocol {<br>	func foo() {...} // no default implementation *at the moment of writing*, <br>no need in `overload`<br>}<br></p><p>Now, you adds SomeClass.swift file to your project and in some *other* file <br>you write:<br></p><p>extension SomeProtocol {<br>	func foo() {...}<br>}<br></p><p>As you see, you don&#39;t control the SomeClass.swift but you suggest in this <br>case SomeClass.foo() should be defined with `override`.<br></p><p>With &#39;implement&#39; SomeClass.foo() will be marked initially and will save us <br>if protocol&#39;s requirement PLUS default implementation changed.<br></p><p>&gt; there&#39;s a &quot;near-miss&quot; typo in the function signature, an error is already<br>&gt; generated at compile time because the type doesn&#39;t conform to the stated<br>&gt; protocol. Currently, the error is very unhelpful, but IMO that&#39;s a<br></p><p>Even, if `implement` will not add safety in case there is no default <br>implementation of protocol&#39;s requirement *now*, it will add safety if you <br>decide to add such default implementation at some point of time or in some <br>other point of your project. And this `implement` will save us in this <br>case, as you expresses your intention explicitly and compiler will check this.<br></p><p>&gt; straight-up bug; improving the diagnostics for that error can be done<br>&gt; without evolution.<br>&gt;<br>&gt; On the other hand, if we require `implement`, the simplest use case of<br>&gt; conforming a type to a protocol with no default implementations would take<br>&gt; more effort but provide no benefit to justify that additional effort.<br></p><p>I don&#39;t believe the requirement to add just one word `implement` on the <br>same line with method/prop declaration would take more effort to conform to <br>protocol. I don&#39;t see see real big difference in these lines:<br></p><p>class Foo : Bar {<br>	func foo() {...}<br>}<br></p><p>class Foo : Bar {<br>	implement func foo() {...}<br>}<br></p><p>But I see that foo is a protocol requirement and compiler will help me with <br>this. Also this add clarity when you read some one&#39;s code.<br></p><p>&gt; Moreover (I think a core team member has expressed this more elegantly in<br>&gt; the past), there&#39;s the philosophical point that POP represents the<br>&gt; theoretical process by which we discover and express our discovery that<br>&gt; certain types happen to share common semantic characteristics. In that<br>&gt; conception of POP, it would be backwards to declare a certain member as<br>&gt; fulfilling certain protocol requirements.<br></p><p>Well.. I do believe we need some golden middle between &quot;theoretical <br>process&quot; and C++ ;-) I.e. we are discussing a real-word programming <br>language, which we use to build low-level utils, web backend applications, <br>macOS apps, iOS apps etc. IMO we need a balance between a shiny theory and <br>ugly bugs we *will* have because this theory don&#39;t allow our compiler to <br>help us.<br></p><p>Probably there is another perfect way to solve the initial problem, <br>probably core team already invented something cool and we just don&#39;t know <br>about this yet. But for now I think its worth to add the `implement` <br>keyword to Swift.<br></p><p>&gt;<br>&gt; So, if such a source breaking change were to be in scope for Swift, I would<br>&gt; suggest modifying Vladimir&#39;s proposal to use `override` instead and<br></p><p>If the community and core team will accept the idea to mark method defined <br>in type as protocol&#39;s requirement (without any relation to existence of <br>default implementation) only with `override` - I think this also will be a <br>good solution. I.e. when we see `override` in type definition, we <br>understand that this type implements something that exists in its &quot;super&quot; <br>type in wide sense i.e. in its super class or in one of its protocols.<br></p><p>So, personally I don&#39;t insist on `implement` word, but propose some <br>&#39;marker&#39; to mark methods in type implemented exactly as implementation for <br>some requirement.<br></p><p>Probably this really could be `override` - as Swift propose itself as POP <br>language, there should be no big difference if we override a method of <br>super class or &#39;override&#39; a method of one of protocols. Just like <br>`override` for super class method, `override` for protocol implementation <br>method is here just because this method *depend* on what is defined in <br>conformed protocol.<br></p><p>But again, `override` IMO should not depend on if there is a default <br>implementation in protocol.<br></p><p>&gt; requiring the keyword only when a default implementation is being<br>&gt; overridden. To accommodate retroactive conformance, we could either propose<br>&gt; that `extension Foo : Bar` is automatically understood to contain members<br>&gt; that override default implementations (as Vladimir has essentially<br>&gt; suggested), or stipulate that we must write `extension Foo : override Bar`.<br>&gt; This has the advantage of not introducing an additional keyword and avoids<br>&gt; the seemingly reduplicative spelling `extension Foo : implement Bar` (for<br>&gt; what else would an `extension Foo : Bar` reasonably do but implement the<br>&gt; requirements of Bar?).<br>&gt;<br>&gt;<br>&gt; On Mon, Sep 19, 2016 at 3:10 PM, Goffredo Marocchi via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     If Swift 4 will make it impossible to tackle this again, I do not think<br>&gt;     discussing this can be avoided for Swift 3.1... I am afraid we are<br>&gt;     rushing into Swift 4 a bit too quickly, but perhaps it is just silly<br>&gt;     old me :).<br>&gt;<br>&gt;     Sent from my iPhone<br>&gt;<br>&gt;     On 19 Sep 2016, at 19:18, Charles Srstka via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;     On Sep 19, 2016, at 12:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Let me give a concrete example of how retroactively modeling is used.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Karl is suggesting interesting but complex and IMO too much<br>&gt;&gt;&gt;     code-breaking idea that I don&#39;t believe can be implemented at all in<br>&gt;&gt;&gt;     a reasonable amount of time to be a part of Swift as soon as<br>&gt;&gt;&gt;     possible, to address the discussed issue with protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I wonder what objections could be made on the solution proposed<br>&gt;&gt;&gt;     below, which should solve a major(IMO) number of issues with<br>&gt;&gt;&gt;     protocol conformance and introduce only 1 keyword. Such solution<br>&gt;&gt;&gt;     will make Swift better as Protocol-Oriented language and later we<br>&gt;&gt;&gt;     can even improve it, but it can already solve a big number of issues:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     1. As soon as possible we add &#39;implement&#39; keyword which is required<br>&gt;&gt;&gt;     to mark method/property that was defined in type or extension<br>&gt;&gt;&gt;     exactly to conform to some protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     2. The &#39;implement&#39; required only at a moment of &#39;direct&#39;<br>&gt;&gt;&gt;     conformance, i.e. when you declare methods/props of the<br>&gt;&gt;&gt;     type/extension that explicitly conformed to protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     3. Retrospective conformance will not require this keyword and will<br>&gt;&gt;&gt;     work for now just like it is working today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     4. Later, if this will be possible at all, we can extend this model<br>&gt;&gt;&gt;     to support separate implementation of protocols with same<br>&gt;&gt;&gt;     requirements in the same type, explicit protocol name in implemented<br>&gt;&gt;&gt;     methods/props and improvements for retrospective conformance. For<br>&gt;&gt;&gt;     example some variants for *future* improvements:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     4.1 Different implementation for different protocols<br>&gt;&gt;&gt;     class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;&gt;      implement(ProtocolA) func foo() {...}<br>&gt;&gt;&gt;      implement(ProtocolB) func foo() {...}<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     class Foo : ProtocolA, ProtocolB {<br>&gt;&gt;&gt;      implement ProtocolA {<br>&gt;&gt;&gt;     func foo() {...}<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;      implement ProtocolB {<br>&gt;&gt;&gt;     func foo() {...}<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     etc<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     4.2 Retrospective conformance: What is the main problem with<br>&gt;&gt;&gt;     retrospective conformance? As I see it now(correct me, if I missing<br>&gt;&gt;&gt;     something), the problem arises in such situation:<br>&gt;&gt;&gt;     * we *expect* that some method(s) in type will play the role of<br>&gt;&gt;&gt;     implementation of protocol&#39;s requirements, so we retrospectively<br>&gt;&gt;&gt;     conform that type to the protocol.<br>&gt;&gt;&gt;     * but protocol has default implementation for its requirements<br>&gt;&gt;&gt;     * and type&#39;s methods, that we *expect* to play roles for protocol<br>&gt;&gt;&gt;     implementation, has different parameters or slightly different<br>&gt;&gt;&gt;     method name at all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I.e. when we have this set of code logic:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     type T {<br>&gt;&gt;&gt;      func foo()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     protocol P {<br>&gt;&gt;&gt;      func foo(x: Int)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     extension P {<br>&gt;&gt;&gt;      func foo(x: Int) {...}<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     extension T : P { // expect foo in T will play role of P.foo<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I support the opinion that it is not an option to require to<br>&gt;&gt;&gt;     explicitly list conformed methods/props in type extension for<br>&gt;&gt;&gt;     retrospective conformance.<br>&gt;&gt;&gt;     But I do believe we need a way to *express our intention* regarding<br>&gt;&gt;&gt;     the retrospective conformance: do we expect that type already<br>&gt;&gt;&gt;     contains implementation for some protocol&#39;s requirements OR we are<br>&gt;&gt;&gt;     aware that protocol can have defaults for some methods and our type<br>&gt;&gt;&gt;     does not contains some implementations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     So, the solution here IMO is some syntax to express that intention.<br>&gt;&gt;&gt;     Right now I think that we can use current syntax &quot;extension T : P&quot;<br>&gt;&gt;&gt;     to keep it working as it now works: &quot;I&#39;m aware of all the names,<br>&gt;&gt;&gt;     defaults etc. Treat this as usually you did&quot;. But for example<br>&gt;&gt;&gt;     something like &quot;extension T: implement P {..}&quot; or &quot;extension T:<br>&gt;&gt;&gt;     P(implement *) {..}&quot; will say that we *expect* that all requirements<br>&gt;&gt;&gt;     of P protocol should be implemented inside T type. Or some syntax<br>&gt;&gt;&gt;     inside extension to specify the list of methods/props we expect to<br>&gt;&gt;&gt;     be implemented in T. Or &quot;extension T : P(implement foo, bar(x:y:))<br>&gt;&gt;&gt;     {..}&quot;.. Should be discussed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     But again, IMO this could be discussed later, after we&#39;ll have<br>&gt;&gt;&gt;     &#39;implement&#39; for most important place - in type definition for<br>&gt;&gt;&gt;     method/prop that we created exactly for the conformed protocol.<br>&gt;&gt;<br>&gt;&gt;     I would be completely +1 on this.<br>&gt;&gt;<br>&gt;&gt;     Charles<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>September 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt; <br>&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt; <br>&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default implementation for protocol requirement. But, *at the moment of compilation* such default implementation could appear.<br>&gt; <br>&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt; <br>&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or changes are not allowed. Content:<br>&gt; <br>&gt; public protocol SomeProtocol {<br>&gt; 	func foo()<br>&gt; }<br>&gt; <br>&gt; public class SomeClass : SomeProtocol {<br>&gt; 	func foo() {...} // no default implementation *at the moment of writing*, no need in `overload`<br>&gt; }<br>&gt; <br>&gt; Now, you adds SomeClass.swift file to your project and in some *other* file you write:<br>&gt; <br>&gt; extension SomeProtocol {<br>&gt; 	func foo() {...}<br>&gt; }<br>&gt; <br>&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this case SomeClass.foo() should be defined with `override`.<br>&gt; <br>&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save us if protocol&#39;s requirement PLUS default implementation changed.<br></p><p>Requiring the ‘implement’ keyword can help us even if no default implementation is involved. Consider:<br></p><p>protocol P {<br>	func foo() -&gt; [String : Any]<br>}<br></p><p>struct S : P {<br>	func foo() -&gt; [String : String] { return [:] }<br>}<br></p><p>We will get an error here that S does not conform to P. However, this is not the correct error, since S in fact *tries* to conform to P, but it has a mistake in a method signature. This misleads us as to the true nature of the problem, and if S has enough members in it that we fail to spot the existing foo(), we might solve the problem by reimplementing foo(), and leaving the original foo() as dangling dead code. Having an ‘implement’ keyword on the existing foo() function would change the compiler error to let us know that we have an existing foo() that is incorrectly declared.<br></p><p>In addition, ‘implement’ can help us when the declaration in question *is* the default implementation:<br></p><p>protocol P {<br>	func foo() -&gt; [String : Any]<br>}<br></p><p>extension P {<br>	implement func foo() -&gt; [String : String] { return [:] }<br>}<br></p><p>Here we will get an error with the proposed ‘implement’ keyword, because foo() does not have a signature matching anything in the protocol, whereas without ‘implement’ we would happily and silently generate a useless dangling function that would never be used, and then pass the buck to the concrete type that implements P:<br></p><p>protocol P {<br>	func foo() -&gt; [String : Any]<br>}<br></p><p>extension P {<br>	func foo() -&gt; [String : String] { return [:] } // The error is here:<br>}<br></p><p>struct S : P {} // But it gets reported here.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/536c332e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; extension P {<br> &gt; implement func foo() -&gt; [String : String] { return [:] }<br> &gt; }<br></p><p>Yes, it seems like we need `implement` (or `override` as another <br>suggestion) in protocol extension also just for the same reasons - be clear <br>about our intention regarding implementing the requirement, to show that <br>this func *depends* on the previous definition of P protocol and to avoid <br>possible mistakes related to protocol conformance.<br></p><p>On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt;<br>&gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;<br>&gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;<br>&gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt; changes are not allowed. Content:<br>&gt;&gt;<br>&gt;&gt; public protocol SomeProtocol {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt; no need in `overload`<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt; file you write:<br>&gt;&gt;<br>&gt;&gt; extension SomeProtocol {<br>&gt;&gt; func foo() {...}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;<br>&gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;<br>&gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt; implementation is involved. Consider:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo() -&gt; [String : Any]<br>&gt; }<br>&gt;<br>&gt; struct S : P {<br>&gt; func foo() -&gt; [String : String] { return [:] }<br>&gt; }<br>&gt;<br>&gt; We will get an error here that S does not conform to P. However, this is<br>&gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt; keyword on the existing foo() function would change the compiler error to<br>&gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;<br>&gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt; the default implementation:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo() -&gt; [String : Any]<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt; }<br>&gt;<br>&gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt; without ‘implement’ we would happily and silently generate a useless<br>&gt; dangling function that would never be used, and then pass the buck to the<br>&gt; concrete type that implements P:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo() -&gt; [String : Any]<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt; }<br>&gt;<br>&gt; struct S : P {} // But it gets reported here.<br>&gt;<br>&gt; Charles<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 20, 2016 at 03:00:00pm</p></header><div class="content"><p>As I mentioned above, I agree that better diagnostics for near-misses are<br>necessary, but they are possible without new syntax. There is no win in<br>avoiding unintentional behavior because, without a default implementation,<br>these issues are caught at compile time already.<br>On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;  &gt; extension P {<br>&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;  &gt; }<br>&gt;<br>&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt; about our intention regarding implementing the requirement, to show that<br>&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt; possible mistakes related to protocol conformance.<br>&gt;<br>&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point,<br>&gt; IMO.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt; `implement`<br>&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt; because, if<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no<br>&gt; default<br>&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt; &gt;&gt; changes are not allowed. Content:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt; &gt;&gt; func foo()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt; writing*,<br>&gt; &gt;&gt; no need in `overload`<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt; &gt;&gt; file you write:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension SomeProtocol {<br>&gt; &gt;&gt; func foo() {...}<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in<br>&gt; this<br>&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt; &gt;<br>&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt; &gt; implementation is involved. Consider:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt; func foo() -&gt; [String : Any]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; struct S : P {<br>&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it<br>&gt; has<br>&gt; &gt; a mistake in a method signature. This misleads us as to the true nature<br>&gt; of<br>&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt; &gt;<br>&gt; &gt; In addition, ‘implement’ can help us when the declaration in question<br>&gt; *is*<br>&gt; &gt; the default implementation:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt; func foo() -&gt; [String : Any]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension P {<br>&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt; &gt; foo() does not have a signature matching anything in the protocol,<br>&gt; whereas<br>&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt; &gt; concrete type that implements P:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt; func foo() -&gt; [String : Any]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension P {<br>&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/d340b42b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I have been following this discussion (as well as similar threads earlier<br>this year) and listening to the ideas put forth by all sides.<br></p><p>It seems to me that the fundamental difference between classes and<br>protocols is that classes inherit implementation whereas protocol<br>conformance is a promise about interface.<br></p><p>When a class or struct or enum declares itself as conforming to a protocol,<br>that means it has all the members specified in the protocol. The protocol<br>conformance simply codifies a fact about the type itself: namely that all<br>those members are present.<br></p><p>In this model, any keyword such as `implements` on each conforming member<br>would introduce substantial boilerplate for negligible gain. The purpose of<br>a protocol is to communicate that certain members are available, not to<br>make declaring those members more onerous.<br></p><p>However, default implementations for protocols blur the line. Now there is<br>actual implementation being inherited. A conforming type may choose to roll<br>its own version of a method, or to utilize the default provided by the<br>protocol. This is closer to the situation with subclassing.<br></p><p>Moreover, a protocol which conforms to another protocol may itself define<br>(or redefine!) default implementations for members of that other protocol.<br>This can create “inheritance chains” of protocol default implementations. I<br>think there is value in being able to refer to (and call) the inherited<br>default implementation through some sort of `super` functionality.<br></p><p>On the other hand, the existence of a default implementation in a protocol<br>is in large part merely a convenience: a courtesy so that each conforming<br>type need not rewrite the same boilerplate code.<br></p><p>A type which conforms to a protocol may accept the default or it may<br>provide its own implementation, but it is not “overriding” anything. The<br>default implementation was offered as a convenience, to be taken or left as<br>needed. Thus I do not think any keyword (neither `override` nor<br>`implements`) should be required in that case either.<br></p><p>The frequently-raised point regarding near-miss member names deserves some<br>attention. Several people have expressed a desire for the compiler to<br>assist them in determining whether a given member does or does not meet a<br>protocol requirement. Specifically, when a type conforms to a protocol with<br>a default implementation, and the type defines a member with a similar<br>signature, it is not obvious at glance if that member matches the protocol.<br></p><p>I think this is a job for linters and IDEs. For example, syntax<br>highlighting could distinguish members which satisfy a protocol<br>requirement, thereby providing immediate visual confirmation of success.<br></p><p>Having followed the lengthy discussion and weighed the numerous ideas put<br>forth, I come down firmly on the side of no keyword for protocol<br>conformance.<br></p><p>A protocol describes an interface and provides a set of customization<br>points. It may also, as a convenience, offer default implementations. The<br>protocol simply describes the capabilities of its conforming types, and any<br>default implementations are there to make things easier for them.<br></p><p>Conforming types should not be afflicted with extraneous keywords: that<br>would run contrary to the purpose of having protocols in the first place.<br></p><p>Nevin<br></p><p><br>On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As I mentioned above, I agree that better diagnostics for near-misses are<br>&gt; necessary, but they are possible without new syntax. There is no win in<br>&gt; avoiding unintentional behavior because, without a default implementation,<br>&gt; these issues are caught at compile time already.<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;  &gt; extension P {<br>&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;  &gt; }<br>&gt;&gt;<br>&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt; suggestion) in protocol extension also just for the same reasons - be<br>&gt;&gt; clear<br>&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;<br>&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point,<br>&gt;&gt; IMO.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where<br>&gt;&gt; previous<br>&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;&gt; `implement`<br>&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt;&gt; because, if<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no<br>&gt;&gt; default<br>&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change<br>&gt;&gt; or<br>&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt;&gt; writing*,<br>&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in<br>&gt;&gt; this<br>&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct S : P {<br>&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it<br>&gt;&gt; has<br>&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature<br>&gt;&gt; of<br>&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error<br>&gt;&gt; to<br>&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question<br>&gt;&gt; *is*<br>&gt;&gt; &gt; the default implementation:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension P {<br>&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol,<br>&gt;&gt; whereas<br>&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to<br>&gt;&gt; the<br>&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension P {<br>&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Charles<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/b9920af7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 20, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt; <br>&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt; <br>&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt; <br>&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt; <br>&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt; <br>&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt; <br>&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt; <br>&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt; <br>&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt; <br>&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt; <br>&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt; <br>&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt; <br>&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt; <br>&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;  &gt; extension P {<br>&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;  &gt; }<br>&gt; <br>&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt; about our intention regarding implementing the requirement, to show that<br>&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt; possible mistakes related to protocol conformance.<br>&gt; <br>&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt; &gt;&gt; changes are not allowed. Content:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt; &gt;&gt; func foo()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt; &gt;&gt; no need in `overload`<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt; &gt;&gt; file you write:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension SomeProtocol {<br>&gt; &gt;&gt; func foo() {...}<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt; &gt;<br>&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt; &gt; implementation is involved. Consider:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt; func foo() -&gt; [String : Any]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; struct S : P {<br>&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt; &gt;<br>&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt; &gt; the default implementation:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt; func foo() -&gt; [String : Any]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension P {<br>&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt; &gt; concrete type that implements P:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt; func foo() -&gt; [String : Any]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension P {<br>&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p><br>I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br></p><p>I think the best way is to prefix the member name with the protocol, e.g:<br></p><p>protocol MyProto {<br>    var aVariable : Int<br>    func aFunction()<br>}<br>class MyClass : MyProto {<br>    var MyProto.aVariable : Int<br>    func MyProto.aFunction() { … }<br>}<br></p><p>This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br></p><p>The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br></p><p>I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br></p><p>We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br></p><p>I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br></p><p>Karl<br></p><p><br>CC-ing Dave A, to understand better if this fits with the vision of protocols<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/2fd71d76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 20, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt; <br>&gt;&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt;&gt; <br>&gt;&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt;&gt; <br>&gt;&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt;&gt; <br>&gt;&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt;&gt; <br>&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt;&gt; <br>&gt;&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt;&gt; <br>&gt;&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt;&gt; <br>&gt;&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt; <br>&gt;&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt; <br>&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt; <br>&gt;&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt;&gt; <br>&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt; <br>&gt;&gt; Nevin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt;&gt; <br>&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;  &gt; extension P {<br>&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;  &gt; }<br>&gt;&gt; <br>&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt; <br>&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct S : P {<br>&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt;&gt; &gt; the default implementation:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension P {<br>&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension P {<br>&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Charles<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br>&gt; <br>&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt; <br>&gt; protocol MyProto {<br>&gt;     var aVariable : Int<br>&gt;     func aFunction()<br>&gt; }<br>&gt; class MyClass : MyProto {<br>&gt;     var MyProto.aVariable : Int<br>&gt;     func MyProto.aFunction() { … }<br>&gt; }<br>&gt; <br>&gt; This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>&gt; As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br>&gt; <br>&gt; The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt; <br>&gt; I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br>&gt; <br>&gt; We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br></p><p>Also to add here: you’re basically implementing what I’m proposing manually if you do this; only you don’t get language/compiler support.<br>String basically does this - it shares StringCore with UTF8View and defines some internal functions to support it.<br></p><p>The String views could then be made in to protocols on String, turning “UTF8View” in to “UTF8Representable”, and opening up algorithms which can work on generic sequences of UTF8 bytes. I think that’s pretty cool, and could open up better integration with other types which are (for example) UTF8Representable — for example a stream of UTF8 bytes (depending on how flexible implementation allows us to make the protocol).<br></p><p>&gt; <br>&gt; I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; <br>&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/bdbb4af9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 20, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m not sure I understand. What compiler or language support is missing for<br>StringCore?<br>On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have been following this discussion (as well as similar threads earlier<br>&gt; this year) and listening to the ideas put forth by all sides.<br>&gt;<br>&gt; It seems to me that the fundamental difference between classes and<br>&gt; protocols is that classes inherit implementation whereas protocol<br>&gt; conformance is a promise about interface.<br>&gt;<br>&gt; When a class or struct or enum declares itself as conforming to a<br>&gt; protocol, that means it has all the members specified in the protocol. The<br>&gt; protocol conformance simply codifies a fact about the type itself: namely<br>&gt; that all those members are present.<br>&gt;<br>&gt; In this model, any keyword such as `implements` on each conforming member<br>&gt; would introduce substantial boilerplate for negligible gain. The purpose of<br>&gt; a protocol is to communicate that certain members are available, not to<br>&gt; make declaring those members more onerous.<br>&gt;<br>&gt; However, default implementations for protocols blur the line. Now there is<br>&gt; actual implementation being inherited. A conforming type may choose to roll<br>&gt; its own version of a method, or to utilize the default provided by the<br>&gt; protocol. This is closer to the situation with subclassing.<br>&gt;<br>&gt; Moreover, a protocol which conforms to another protocol may itself define<br>&gt; (or redefine!) default implementations for members of that other protocol.<br>&gt; This can create “inheritance chains” of protocol default implementations. I<br>&gt; think there is value in being able to refer to (and call) the inherited<br>&gt; default implementation through some sort of `super` functionality.<br>&gt;<br>&gt; On the other hand, the existence of a default implementation in a protocol<br>&gt; is in large part merely a convenience: a courtesy so that each conforming<br>&gt; type need not rewrite the same boilerplate code.<br>&gt;<br>&gt; A type which conforms to a protocol may accept the default or it may<br>&gt; provide its own implementation, but it is not “overriding” anything. The<br>&gt; default implementation was offered as a convenience, to be taken or left as<br>&gt; needed. Thus I do not think any keyword (neither `override` nor<br>&gt; `implements`) should be required in that case either.<br>&gt;<br>&gt; The frequently-raised point regarding near-miss member names deserves some<br>&gt; attention. Several people have expressed a desire for the compiler to<br>&gt; assist them in determining whether a given member does or does not meet a<br>&gt; protocol requirement. Specifically, when a type conforms to a protocol with<br>&gt; a default implementation, and the type defines a member with a similar<br>&gt; signature, it is not obvious at glance if that member matches the protocol.<br>&gt;<br>&gt; I think this is a job for linters and IDEs. For example, syntax<br>&gt; highlighting could distinguish members which satisfy a protocol<br>&gt; requirement, thereby providing immediate visual confirmation of success.<br>&gt;<br>&gt; Having followed the lengthy discussion and weighed the numerous ideas put<br>&gt; forth, I come down firmly on the side of no keyword for protocol<br>&gt; conformance.<br>&gt;<br>&gt; A protocol describes an interface and provides a set of customization<br>&gt; points. It may also, as a convenience, offer default implementations. The<br>&gt; protocol simply describes the capabilities of its conforming types, and any<br>&gt; default implementations are there to make things easier for them.<br>&gt;<br>&gt; Conforming types should not be afflicted with extraneous keywords: that<br>&gt; would run contrary to the purpose of having protocols in the first place.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are<br>&gt;&gt; necessary, but they are possible without new syntax. There is no win in<br>&gt;&gt; avoiding unintentional behavior because, without a default implementation,<br>&gt;&gt; these issues are caught at compile time already.<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be<br>&gt;&gt;&gt; clear<br>&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point,<br>&gt;&gt;&gt; IMO.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where<br>&gt;&gt;&gt; previous<br>&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;&gt;&gt; `implement`<br>&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt;&gt;&gt; because, if<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no<br>&gt;&gt;&gt; default<br>&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt;&gt;&gt; writing*,<br>&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in<br>&gt;&gt;&gt; this<br>&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will<br>&gt;&gt;&gt; save<br>&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it<br>&gt;&gt;&gt; has<br>&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true<br>&gt;&gt;&gt; nature of<br>&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly<br>&gt;&gt;&gt; declared.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question<br>&gt;&gt;&gt; *is*<br>&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword,<br>&gt;&gt;&gt; because<br>&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol,<br>&gt;&gt;&gt; whereas<br>&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a<br>&gt; common thing, so you want it to be easy to remember.<br>&gt;<br>&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;     var aVariable : Int<br>&gt;     func aFunction()<br>&gt; }<br>&gt; class MyClass : MyProto {<br>&gt;     var MyProto.aVariable : Int<br>&gt;     func MyProto.aFunction() { … }<br>&gt; }<br>&gt;<br>&gt; This is consistent with how we refer to other members of types (e.g.<br>&gt; “extension MyClass.MyInternalClass”). It will be easy for autocompletion to<br>&gt; provide good suggestions, too.<br>&gt; As I see it, the only problem is what if `MyClass` wants its own function<br>&gt; called `aFunction()`? What if the same name satisfies 2 protocols, which do<br>&gt; you write?<br>&gt;<br>&gt; The way to solve all of the problems in a consistent way is to make the<br>&gt; function actually called “MyProto.aFunction”, and for it to be a separate<br>&gt; function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;<br>&gt; I believe it is crucial to protocols that we can do this. Maybe I have<br>&gt; some complex data structure and it has its own API, but I want people to be<br>&gt; able to view it as a Collection. By conforming to Collection, I reserve<br>&gt; lots of keywords and indexing operations which I now can’t use in my own<br>&gt; API. Maybe I’m just providing Collection as a convenience to work with<br>&gt; generic algorithms, but my own API has more efficient semantics for some<br>&gt; operations. We’re relegated to using less-obvious and legible names in<br>&gt; order to avoid conflicts.<br>&gt;<br>&gt; We have a way to work around this, which String uses - create a struct<br>&gt; which references your object and calls internal methods such as<br>&gt; “_collection_count” so you can have separate interfaces. This adds up to<br>&gt; quite a lot of boilerplate and maintenance overhead.<br>&gt;<br>&gt;<br>&gt; Also to add here: you’re basically implementing what I’m proposing<br>&gt; manually if you do this; only you don’t get language/compiler support.<br>&gt; String basically does this - it shares StringCore with UTF8View and<br>&gt; defines some internal functions to support it.<br>&gt;<br>&gt; The String views could then be made in to protocols on String, turning<br>&gt; “UTF8View” in to “UTF8Representable”, and opening up algorithms which can<br>&gt; work on generic sequences of UTF8 bytes. I think that’s pretty cool, and<br>&gt; could open up better integration with other types which are (for example)<br>&gt; UTF8Representable — for example a stream of UTF8 bytes (depending on how<br>&gt; flexible implementation allows us to make the protocol).<br>&gt;<br>&gt;<br>&gt; I don’t agree that Protocol conformances are kind-of incidental, as others<br>&gt; here have written. This isn’t like Objective-C where anything that has the<br>&gt; correctly-named methods conforms. Protocol conformances are completely<br>&gt; explicit, and in fact we have empty protocols (“marker protocols”) for<br>&gt; exactly that purpose. I think it is consistent that we make every member of<br>&gt; a conformance specify which protocol it belongs to, and to have its name<br>&gt; scoped to that protocol.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;<br>&gt; CC-ing Dave A, to understand better if this fits with the vision of<br>&gt; protocols<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/d9c57ea6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 21, 2016 at 12:00:00am</p></header><div class="content"><p>I’m not saying vital support is missing, just that it is more awkward. String doesn’t conform to collection, String.UTF8View does; so if you change some implementation detail (in StringCore, because that’s where they live for String), you get the error popping up somewhere other than the place you just changed. That’s what I mean when I say “language support”. If you do what StringCore does, and you’re changing stuff which is ultimately going to be used to conform to, say, Collection, you have to build distance between the implementation and the (only) conformance it is used for, and it’s less optimal.<br></p><p>Let’s say I have an object MyComplexDataType, it implements “InternalStructureView” and “Collection”:<br></p><p>```<br>protocol InternalStructureView {<br>    associatedtype Index<br>    var count : Int { get } // whatever, just some stuff that will cause a name conflict<br>    func doInternalMagic(at: Index)<br>}<br></p><p>struct MyComplexDataType {<br>    var __collection_count : Int {<br>        // This is quite a complex operation which we’d rather leave inside the type, otherwise we’d need to expose a bunch of implementation details internally<br>    }<br>   var __internal_count : Int {<br>       // Again, best left here<br>   }<br></p><p>   struct CollectionView  : Collection {<br>       init(parent: MyComplexDataType) { … }<br>        var count { return parent.__collection_count }<br>        // ...etc<br>   }<br></p><p>  struct InternalStructure : InternalStructureView {<br>      init(parent: MyComplexDataType) { … }<br>      var count { return parent.__internal_count }<br>      // ...etc<br>  }<br></p><p>  var collection : CollectionView { return CollectionView(self) }<br>  var internalStructure : InternalStructure { return InternalStructure(self) }<br>}<br>```<br></p><p>This is basically what String does (except that it wants to conform to Collection multiple times with different indexes and results). It’s a lot of work to maintain, especially if you have evolving protocols that are conformed to in several places.<br>We should have a better solution. We should be able to define:<br></p><p>“protocol UTF8Collection : Collection {}<br> protocol UTF16Collection : Collection {}”<br></p><p>and have String conform to both of them at the same time. At the same time, since we’re now being explicit about which protocol requirement is satisfied where - we should also be able to delegate our conformance, telling the compiler to dispatch any unimplemented methods to another object. For example, lets say you want to wrap a Collection and observe mutations to it; you might override replaceSubrange(), but every other method (such as count, index(after:)… all the rest) is just a forwarding function.<br></p><p>Interestingly, we could do this safely (from a code legibility perspective) if we say that every scope which adds a conformance must completely satisfy its requirements, which we would more reasonably be able to require if we made this change (so your internal functions can still be wherever you like, but they won’t automatically satisfy a protocol requirement if they happen to have the same name). Then we could reasonably say that if you add an extension which adds a conformance to, say, Collection, you have to tell us where to find every one of its requirements. That’s where we could put the forwarding syntax for retroactive modelling. Stored properties can’t be defined in extensions, so if you want to back an implementation with one, you’ll need to make its conformance explicit in the main body (or we loosen that to at least extensions in the same file).<br></p><p>```<br>// generates thunks to members of this extension in the base type; <br>// so MyComplexDataType.count —&gt; MyComplexDataType.InternalStructure.count,<br>// to account for conformance being added in later version. Can also be used for renamed protocols, and be tagged on individual members.<br></p><p>@makeAvailable(as: _)<br>extension MyComplexDataType : InternalStructure {<br></p><p>   typealias Index = InternalIndexType<br>    var count : Int {<br>        // We have access to all of the private members because we’re inside MyComplexDataType<br>        // No need to pollute internal API with conformance implementation details.<br>        // Also, we get errors about non-conformance where we want them — where the implementation is.<br>    }<br>    func doInternalMagic(at: Index) {<br>       ...<br>    }<br>}<br>```<br></p><p>&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure I understand. What compiler or language support is missing for StringCore?<br>&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br>&gt;&gt; <br>&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt; <br>&gt;&gt; protocol MyProto {<br>&gt;&gt;     var aVariable : Int<br>&gt;&gt;     func aFunction()<br>&gt;&gt; }<br>&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br>&gt;&gt; <br>&gt;&gt; The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt; <br>&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br>&gt;&gt; <br>&gt;&gt; We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br>&gt; <br>&gt; Also to add here: you’re basically implementing what I’m proposing manually if you do this; only you don’t get language/compiler support.<br>&gt; String basically does this - it shares StringCore with UTF8View and defines some internal functions to support it.<br>&gt; <br>&gt; The String views could then be made in to protocols on String, turning “UTF8View” in to “UTF8Representable”, and opening up algorithms which can work on generic sequences of UTF8 bytes. I think that’s pretty cool, and could open up better integration with other types which are (for example) UTF8Representable — for example a stream of UTF8 bytes (depending on how flexible implementation allows us to make the protocol).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/8353e444/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 20, 2016 at 10:00:00pm</p></header><div class="content"><p>Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this.<br>How would String conforming to Collection multiple times simplify or<br>improve the implementation of String? Or are you arguing it would be better<br>for users of String? If so, how?<br></p><p>On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; I’m not saying vital support is missing, just that it is more awkward.<br>&gt; String doesn’t conform to collection, String.UTF8View does; so if you<br>&gt; change some implementation detail (in StringCore, because that’s where they<br>&gt; live for String), you get the error popping up somewhere other than the<br>&gt; place you just changed. That’s what I mean when I say “language support”.<br>&gt; If you do what StringCore does, and you’re changing stuff which is<br>&gt; ultimately going to be used to conform to, say, Collection, you have to<br>&gt; build distance between the implementation and the (only) conformance it is<br>&gt; used for, and it’s less optimal.<br>&gt;<br>&gt; Let’s say I have an object MyComplexDataType, it implements<br>&gt; “InternalStructureView” and “Collection”:<br>&gt;<br>&gt; ```<br>&gt; protocol InternalStructureView {<br>&gt;     associatedtype Index<br>&gt;     var count : Int { get } // whatever, just some stuff that will cause a<br>&gt; name conflict<br>&gt;     func doInternalMagic(at: Index)<br>&gt; }<br>&gt;<br>&gt; struct MyComplexDataType {<br>&gt;     var __collection_count : Int {<br>&gt;         // This is quite a complex operation which we’d rather leave<br>&gt; inside the type, otherwise we’d need to expose a bunch of implementation<br>&gt; details internally<br>&gt;     }<br>&gt;    var __internal_count : Int {<br>&gt;        // Again, best left here<br>&gt;    }<br>&gt;<br>&gt;    struct CollectionView  : Collection {<br>&gt;        init(parent: MyComplexDataType) { … }<br>&gt;         var count { return parent.__collection_count }<br>&gt;         // ...etc<br>&gt;    }<br>&gt;<br>&gt;   struct InternalStructure : InternalStructureView {<br>&gt;       init(parent: MyComplexDataType) { … }<br>&gt;       var count { return parent.__internal_count }<br>&gt;       // ...etc<br>&gt;   }<br>&gt;<br>&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;   var internalStructure : InternalStructure { return<br>&gt; InternalStructure(self) }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; This is basically what String does (except that it wants to conform to<br>&gt; Collection multiple times with different indexes and results). It’s a lot<br>&gt; of work to maintain, especially if you have evolving protocols that are<br>&gt; conformed to in several places.<br>&gt; We should have a better solution. We should be able to define:<br>&gt;<br>&gt; “protocol UTF8Collection : Collection {}<br>&gt;  protocol UTF16Collection : Collection {}”<br>&gt;<br>&gt; and have String conform to both of them at the same time. At the same<br>&gt; time, since we’re now being explicit about which protocol requirement is<br>&gt; satisfied where - we should also be able to delegate our conformance,<br>&gt; telling the compiler to dispatch any unimplemented methods to another<br>&gt; object. For example, lets say you want to wrap a Collection and observe<br>&gt; mutations to it; you might override replaceSubrange(), but every other<br>&gt; method (such as count, index(after:)… all the rest) is just a forwarding<br>&gt; function.<br>&gt;<br>&gt; Interestingly, we could do this safely (from a code legibility<br>&gt; perspective) if we say that every scope which adds a conformance must<br>&gt; completely satisfy its requirements, which we would more reasonably be able<br>&gt; to require if we made this change (so your internal functions can still be<br>&gt; wherever you like, but they won’t automatically satisfy a protocol<br>&gt; requirement if they happen to have the same name). Then we could reasonably<br>&gt; say that if you add an extension which adds a conformance to, say,<br>&gt; Collection, you have to tell us where to find every one of its<br>&gt; requirements. That’s where we could put the forwarding syntax for<br>&gt; retroactive modelling. Stored properties can’t be defined in extensions, so<br>&gt; if you want to back an implementation with one, you’ll need to make its<br>&gt; conformance explicit in the main body (or we loosen that to at least<br>&gt; extensions in the same file).<br>&gt;<br>&gt; ```<br>&gt; // generates thunks to members of this extension in the base type;<br>&gt; // so MyComplexDataType.count —&gt; MyComplexDataType.InternalStructure.count,<br>&gt; // to account for conformance being added in later version. Can also be<br>&gt; used for renamed protocols, and be tagged on individual members.<br>&gt;<br>&gt; @makeAvailable(as: _)<br>&gt; extension MyComplexDataType : InternalStructure {<br>&gt;<br>&gt;    typealias Index = InternalIndexType<br>&gt;     var count : Int {<br>&gt;         // We have access to all of the private members because we’re<br>&gt; inside MyComplexDataType<br>&gt;         // No need to pollute internal API with conformance implementation<br>&gt; details.<br>&gt;         // Also, we get errors about non-conformance where we want them —<br>&gt; where the implementation is.<br>&gt;     }<br>&gt;     func doInternalMagic(at: Index) {<br>&gt;        ...<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;m not sure I understand. What compiler or language support is missing<br>&gt; for StringCore?<br>&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I have been following this discussion (as well as similar threads earlier<br>&gt;&gt; this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;<br>&gt;&gt; It seems to me that the fundamental difference between classes and<br>&gt;&gt; protocols is that classes inherit implementation whereas protocol<br>&gt;&gt; conformance is a promise about interface.<br>&gt;&gt;<br>&gt;&gt; When a class or struct or enum declares itself as conforming to a<br>&gt;&gt; protocol, that means it has all the members specified in the protocol. The<br>&gt;&gt; protocol conformance simply codifies a fact about the type itself: namely<br>&gt;&gt; that all those members are present.<br>&gt;&gt;<br>&gt;&gt; In this model, any keyword such as `implements` on each conforming member<br>&gt;&gt; would introduce substantial boilerplate for negligible gain. The purpose of<br>&gt;&gt; a protocol is to communicate that certain members are available, not to<br>&gt;&gt; make declaring those members more onerous.<br>&gt;&gt;<br>&gt;&gt; However, default implementations for protocols blur the line. Now there<br>&gt;&gt; is actual implementation being inherited. A conforming type may choose to<br>&gt;&gt; roll its own version of a method, or to utilize the default provided by the<br>&gt;&gt; protocol. This is closer to the situation with subclassing.<br>&gt;&gt;<br>&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define<br>&gt;&gt; (or redefine!) default implementations for members of that other protocol.<br>&gt;&gt; This can create “inheritance chains” of protocol default implementations. I<br>&gt;&gt; think there is value in being able to refer to (and call) the inherited<br>&gt;&gt; default implementation through some sort of `super` functionality.<br>&gt;&gt;<br>&gt;&gt; On the other hand, the existence of a default implementation in a<br>&gt;&gt; protocol is in large part merely a convenience: a courtesy so that each<br>&gt;&gt; conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;<br>&gt;&gt; A type which conforms to a protocol may accept the default or it may<br>&gt;&gt; provide its own implementation, but it is not “overriding” anything. The<br>&gt;&gt; default implementation was offered as a convenience, to be taken or left as<br>&gt;&gt; needed. Thus I do not think any keyword (neither `override` nor<br>&gt;&gt; `implements`) should be required in that case either.<br>&gt;&gt;<br>&gt;&gt; The frequently-raised point regarding near-miss member names deserves<br>&gt;&gt; some attention. Several people have expressed a desire for the compiler to<br>&gt;&gt; assist them in determining whether a given member does or does not meet a<br>&gt;&gt; protocol requirement. Specifically, when a type conforms to a protocol with<br>&gt;&gt; a default implementation, and the type defines a member with a similar<br>&gt;&gt; signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;<br>&gt;&gt; I think this is a job for linters and IDEs. For example, syntax<br>&gt;&gt; highlighting could distinguish members which satisfy a protocol<br>&gt;&gt; requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;<br>&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put<br>&gt;&gt; forth, I come down firmly on the side of no keyword for protocol<br>&gt;&gt; conformance.<br>&gt;&gt;<br>&gt;&gt; A protocol describes an interface and provides a set of customization<br>&gt;&gt; points. It may also, as a convenience, offer default implementations. The<br>&gt;&gt; protocol simply describes the capabilities of its conforming types, and any<br>&gt;&gt; default implementations are there to make things easier for them.<br>&gt;&gt;<br>&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that<br>&gt;&gt; would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;<br>&gt;&gt; Nevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses<br>&gt;&gt;&gt; are necessary, but they are possible without new syntax. There is no win in<br>&gt;&gt;&gt; avoiding unintentional behavior because, without a default implementation,<br>&gt;&gt;&gt; these issues are caught at compile time already.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be<br>&gt;&gt;&gt;&gt; clear<br>&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to<br>&gt;&gt;&gt;&gt; avoid<br>&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point,<br>&gt;&gt;&gt;&gt; IMO.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where<br>&gt;&gt;&gt;&gt; previous<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;&gt;&gt;&gt; `implement`<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt;&gt;&gt;&gt; because, if<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no<br>&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to<br>&gt;&gt;&gt;&gt; change or<br>&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt;&gt;&gt;&gt; writing*,<br>&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some<br>&gt;&gt;&gt;&gt; *other*<br>&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in<br>&gt;&gt;&gt;&gt; this<br>&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will<br>&gt;&gt;&gt;&gt; save<br>&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this<br>&gt;&gt;&gt;&gt; is<br>&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but<br>&gt;&gt;&gt;&gt; it has<br>&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true<br>&gt;&gt;&gt;&gt; nature of<br>&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(),<br>&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an<br>&gt;&gt;&gt;&gt; ‘implement’<br>&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler<br>&gt;&gt;&gt;&gt; error to<br>&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly<br>&gt;&gt;&gt;&gt; declared.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question<br>&gt;&gt;&gt;&gt; *is*<br>&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword,<br>&gt;&gt;&gt;&gt; because<br>&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol,<br>&gt;&gt;&gt;&gt; whereas<br>&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite<br>&gt;&gt; a common thing, so you want it to be easy to remember.<br>&gt;&gt;<br>&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;<br>&gt;&gt; protocol MyProto {<br>&gt;&gt;     var aVariable : Int<br>&gt;&gt;     func aFunction()<br>&gt;&gt; }<br>&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This is consistent with how we refer to other members of types (e.g.<br>&gt;&gt; “extension MyClass.MyInternalClass”). It will be easy for autocompletion to<br>&gt;&gt; provide good suggestions, too.<br>&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own function<br>&gt;&gt; called `aFunction()`? What if the same name satisfies 2 protocols, which do<br>&gt;&gt; you write?<br>&gt;&gt;<br>&gt;&gt; The way to solve all of the problems in a consistent way is to make the<br>&gt;&gt; function actually called “MyProto.aFunction”, and for it to be a separate<br>&gt;&gt; function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;<br>&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have<br>&gt;&gt; some complex data structure and it has its own API, but I want people to be<br>&gt;&gt; able to view it as a Collection. By conforming to Collection, I reserve<br>&gt;&gt; lots of keywords and indexing operations which I now can’t use in my own<br>&gt;&gt; API. Maybe I’m just providing Collection as a convenience to work with<br>&gt;&gt; generic algorithms, but my own API has more efficient semantics for some<br>&gt;&gt; operations. We’re relegated to using less-obvious and legible names in<br>&gt;&gt; order to avoid conflicts.<br>&gt;&gt;<br>&gt;&gt; We have a way to work around this, which String uses - create a struct<br>&gt;&gt; which references your object and calls internal methods such as<br>&gt;&gt; “_collection_count” so you can have separate interfaces. This adds up to<br>&gt;&gt; quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Also to add here: you’re basically implementing what I’m proposing<br>&gt;&gt; manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt; String basically does this - it shares StringCore with UTF8View and<br>&gt;&gt; defines some internal functions to support it.<br>&gt;&gt;<br>&gt;&gt; The String views could then be made in to protocols on String, turning<br>&gt;&gt; “UTF8View” in to “UTF8Representable”, and opening up algorithms which can<br>&gt;&gt; work on generic sequences of UTF8 bytes. I think that’s pretty cool, and<br>&gt;&gt; could open up better integration with other types which are (for example)<br>&gt;&gt; UTF8Representable — for example a stream of UTF8 bytes (depending on how<br>&gt;&gt; flexible implementation allows us to make the protocol).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as<br>&gt;&gt; others here have written. This isn’t like Objective-C where anything that<br>&gt;&gt; has the correctly-named methods conforms. Protocol conformances are<br>&gt;&gt; completely explicit, and in fact we have empty protocols (“marker<br>&gt;&gt; protocols”) for exactly that purpose. I think it is consistent that we make<br>&gt;&gt; every member of a conformance specify which protocol it belongs to, and to<br>&gt;&gt; have its name scoped to that protocol.<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of<br>&gt;&gt; protocols<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/e267b444/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 21, 2016 at 01:00:00am</p></header><div class="content"><p>I’m using String as an example of where this issue of conformance conflicts crops up in the standard library. Ideally, String (or any data type) should be able to conform to protocols whose requirements have conflicting names.<br>Currently, in order to work around this limitation, you have to delegate the conformance to a supporting type. This is more complicated to write and maintain, and pollutes your internal API. String gives us an example of this, but it’s not the worst example.<br>It basically implements what I’m talking about anyway, but manually via a supporting type instead of directly inside the data-type (String). As an ABI consideration, we should scope all protocol members to their protocols. This would resolve all naming conflicts.<br></p><p>I can’t understand how anybody would argue for the status quo - we’re currently in-between two ideas of what protocols should be - they are explicit but their conformances are resolved by name only and can overlap without warning.<br></p><p>&gt; On 21 Sep 2016, at 00:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this. How would String conforming to Collection multiple times simplify or improve the implementation of String? Or are you arguing it would be better for users of String? If so, how?<br>&gt; <br>&gt; On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; I’m not saying vital support is missing, just that it is more awkward. String doesn’t conform to collection, String.UTF8View does; so if you change some implementation detail (in StringCore, because that’s where they live for String), you get the error popping up somewhere other than the place you just changed. That’s what I mean when I say “language support”. If you do what StringCore does, and you’re changing stuff which is ultimately going to be used to conform to, say, Collection, you have to build distance between the implementation and the (only) conformance it is used for, and it’s less optimal.<br>&gt; <br>&gt; Let’s say I have an object MyComplexDataType, it implements “InternalStructureView” and “Collection”:<br>&gt; <br>&gt; ```<br>&gt; protocol InternalStructureView {<br>&gt;     associatedtype Index<br>&gt;     var count : Int { get } // whatever, just some stuff that will cause a name conflict<br>&gt;     func doInternalMagic(at: Index)<br>&gt; }<br>&gt; <br>&gt; struct MyComplexDataType {<br>&gt;     var __collection_count : Int {<br>&gt;         // This is quite a complex operation which we’d rather leave inside the type, otherwise we’d need to expose a bunch of implementation details internally<br>&gt;     }<br>&gt;    var __internal_count : Int {<br>&gt;        // Again, best left here<br>&gt;    }<br>&gt; <br>&gt;    struct CollectionView  : Collection {<br>&gt;        init(parent: MyComplexDataType) { … }<br>&gt;         var count { return parent.__collection_count }<br>&gt;         // ...etc<br>&gt;    }<br>&gt; <br>&gt;   struct InternalStructure : InternalStructureView {<br>&gt;       init(parent: MyComplexDataType) { … }<br>&gt;       var count { return parent.__internal_count }<br>&gt;       // ...etc<br>&gt;   }<br>&gt; <br>&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;   var internalStructure : InternalStructure { return InternalStructure(self) }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This is basically what String does (except that it wants to conform to Collection multiple times with different indexes and results). It’s a lot of work to maintain, especially if you have evolving protocols that are conformed to in several places.<br>&gt; We should have a better solution. We should be able to define:<br>&gt; <br>&gt; “protocol UTF8Collection : Collection {}<br>&gt;  protocol UTF16Collection : Collection {}”<br>&gt; <br>&gt; and have String conform to both of them at the same time. At the same time, since we’re now being explicit about which protocol requirement is satisfied where - we should also be able to delegate our conformance, telling the compiler to dispatch any unimplemented methods to another object. For example, lets say you want to wrap a Collection and observe mutations to it; you might override replaceSubrange(), but every other method (such as count, index(after:)… all the rest) is just a forwarding function.<br>&gt; <br>&gt; Interestingly, we could do this safely (from a code legibility perspective) if we say that every scope which adds a conformance must completely satisfy its requirements, which we would more reasonably be able to require if we made this change (so your internal functions can still be wherever you like, but they won’t automatically satisfy a protocol requirement if they happen to have the same name). Then we could reasonably say that if you add an extension which adds a conformance to, say, Collection, you have to tell us where to find every one of its requirements. That’s where we could put the forwarding syntax for retroactive modelling. Stored properties can’t be defined in extensions, so if you want to back an implementation with one, you’ll need to make its conformance explicit in the main body (or we loosen that to at least extensions in the same file).<br>&gt; <br>&gt; ```<br>&gt; // generates thunks to members of this extension in the base type; <br>&gt; // so MyComplexDataType.count —&gt; MyComplexDataType.InternalStructure.count,<br>&gt; // to account for conformance being added in later version. Can also be used for renamed protocols, and be tagged on individual members.<br>&gt; <br>&gt; @makeAvailable(as: _)<br>&gt; extension MyComplexDataType : InternalStructure {<br>&gt; <br>&gt;    typealias Index = InternalIndexType<br>&gt;     var count : Int {<br>&gt;         // We have access to all of the private members because we’re inside MyComplexDataType<br>&gt;         // No need to pollute internal API with conformance implementation details.<br>&gt;         // Also, we get errors about non-conformance where we want them — where the implementation is.<br>&gt;     }<br>&gt;     func doInternalMagic(at: Index) {<br>&gt;        ...<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt;&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand. What compiler or language support is missing for StringCore?<br>&gt;&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;     var aVariable : Int<br>&gt;&gt;&gt;     func aFunction()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>&gt;&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt; <br>&gt;&gt; Also to add here: you’re basically implementing what I’m proposing manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt; String basically does this - it shares StringCore with UTF8View and defines some internal functions to support it.<br>&gt;&gt; <br>&gt;&gt; The String views could then be made in to protocols on String, turning “UTF8View” in to “UTF8Representable”, and opening up algorithms which can work on generic sequences of UTF8 bytes. I think that’s pretty cool, and could open up better integration with other types which are (for example) UTF8Representable — for example a stream of UTF8 bytes (depending on how flexible implementation allows us to make the protocol).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/6bf3e71c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 20, 2016 at 11:00:00pm</p></header><div class="content"><p>This was the conversation we were having in the other thread. Perhaps I&#39;m<br>still not understanding something, but I&#39;m not convinced that this feature<br>is an improvement.<br></p><p>Currently, protocols represent a declaration that you have discovered that<br>your type has certain semantics and guarantees a certain API, and you<br>declare that fulfillment &quot;by name only,&quot; just as you invoke members &quot;by<br>name only&quot;; unintentional failure to fulfill the contract is a compile-time<br>error. The status quo is precisely my idea of what protocols should be.<br>What are the two ideas you have about them?<br>On Tue, Sep 20, 2016 at 18:02 Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; I’m using String as an example of where this issue of conformance<br>&gt; conflicts crops up in the standard library. Ideally, String (or any data<br>&gt; type) should be able to conform to protocols whose requirements have<br>&gt; conflicting names.<br>&gt; Currently, in order to work around this limitation, you have to delegate<br>&gt; the conformance to a supporting type. This is more complicated to write and<br>&gt; maintain, and pollutes your internal API. String gives us an example of<br>&gt; this, but it’s not the worst example.<br>&gt; It basically implements what I’m talking about anyway, but manually via a<br>&gt; supporting type instead of directly inside the data-type (String). As an<br>&gt; ABI consideration, we should scope all protocol members to their protocols.<br>&gt; This would resolve all naming conflicts.<br>&gt;<br>&gt; I can’t understand how anybody would argue for the status quo - we’re<br>&gt; currently in-between two ideas of what protocols should be - they are<br>&gt; explicit but their conformances are resolved by name only and can overlap<br>&gt; without warning.<br>&gt;<br>&gt; On 21 Sep 2016, at 00:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this.<br>&gt; How would String conforming to Collection multiple times simplify or<br>&gt; improve the implementation of String? Or are you arguing it would be better<br>&gt; for users of String? If so, how?<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I’m not saying vital support is missing, just that it is more awkward.<br>&gt;&gt; String doesn’t conform to collection, String.UTF8View does; so if you<br>&gt;&gt; change some implementation detail (in StringCore, because that’s where they<br>&gt;&gt; live for String), you get the error popping up somewhere other than the<br>&gt;&gt; place you just changed. That’s what I mean when I say “language support”.<br>&gt;&gt; If you do what StringCore does, and you’re changing stuff which is<br>&gt;&gt; ultimately going to be used to conform to, say, Collection, you have to<br>&gt;&gt; build distance between the implementation and the (only) conformance it is<br>&gt;&gt; used for, and it’s less optimal.<br>&gt;&gt;<br>&gt;&gt; Let’s say I have an object MyComplexDataType, it implements<br>&gt;&gt; “InternalStructureView” and “Collection”:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; protocol InternalStructureView {<br>&gt;&gt;     associatedtype Index<br>&gt;&gt;     var count : Int { get } // whatever, just some stuff that will cause<br>&gt;&gt; a name conflict<br>&gt;&gt;     func doInternalMagic(at: Index)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct MyComplexDataType {<br>&gt;&gt;     var __collection_count : Int {<br>&gt;&gt;         // This is quite a complex operation which we’d rather leave<br>&gt;&gt; inside the type, otherwise we’d need to expose a bunch of implementation<br>&gt;&gt; details internally<br>&gt;&gt;     }<br>&gt;&gt;    var __internal_count : Int {<br>&gt;&gt;        // Again, best left here<br>&gt;&gt;    }<br>&gt;&gt;<br>&gt;&gt;    struct CollectionView  : Collection {<br>&gt;&gt;        init(parent: MyComplexDataType) { … }<br>&gt;&gt;         var count { return parent.__collection_count }<br>&gt;&gt;         // ...etc<br>&gt;&gt;    }<br>&gt;&gt;<br>&gt;&gt;   struct InternalStructure : InternalStructureView {<br>&gt;&gt;       init(parent: MyComplexDataType) { … }<br>&gt;&gt;       var count { return parent.__internal_count }<br>&gt;&gt;       // ...etc<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;&gt;   var internalStructure : InternalStructure { return<br>&gt;&gt; InternalStructure(self) }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; This is basically what String does (except that it wants to conform to<br>&gt;&gt; Collection multiple times with different indexes and results). It’s a lot<br>&gt;&gt; of work to maintain, especially if you have evolving protocols that are<br>&gt;&gt; conformed to in several places.<br>&gt;&gt; We should have a better solution. We should be able to define:<br>&gt;&gt;<br>&gt;&gt; “protocol UTF8Collection : Collection {}<br>&gt;&gt;  protocol UTF16Collection : Collection {}”<br>&gt;&gt;<br>&gt;&gt; and have String conform to both of them at the same time. At the same<br>&gt;&gt; time, since we’re now being explicit about which protocol requirement is<br>&gt;&gt; satisfied where - we should also be able to delegate our conformance,<br>&gt;&gt; telling the compiler to dispatch any unimplemented methods to another<br>&gt;&gt; object. For example, lets say you want to wrap a Collection and observe<br>&gt;&gt; mutations to it; you might override replaceSubrange(), but every other<br>&gt;&gt; method (such as count, index(after:)… all the rest) is just a forwarding<br>&gt;&gt; function.<br>&gt;&gt;<br>&gt;&gt; Interestingly, we could do this safely (from a code legibility<br>&gt;&gt; perspective) if we say that every scope which adds a conformance must<br>&gt;&gt; completely satisfy its requirements, which we would more reasonably be able<br>&gt;&gt; to require if we made this change (so your internal functions can still be<br>&gt;&gt; wherever you like, but they won’t automatically satisfy a protocol<br>&gt;&gt; requirement if they happen to have the same name). Then we could reasonably<br>&gt;&gt; say that if you add an extension which adds a conformance to, say,<br>&gt;&gt; Collection, you have to tell us where to find every one of its<br>&gt;&gt; requirements. That’s where we could put the forwarding syntax for<br>&gt;&gt; retroactive modelling. Stored properties can’t be defined in extensions, so<br>&gt;&gt; if you want to back an implementation with one, you’ll need to make its<br>&gt;&gt; conformance explicit in the main body (or we loosen that to at least<br>&gt;&gt; extensions in the same file).<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; // generates thunks to members of this extension in the base type;<br>&gt;&gt; // so MyComplexDataType.count —&gt;<br>&gt;&gt; MyComplexDataType.InternalStructure.count,<br>&gt;&gt; // to account for conformance being added in later version. Can also be<br>&gt;&gt; used for renamed protocols, and be tagged on individual members.<br>&gt;&gt;<br>&gt;&gt; @makeAvailable(as: _)<br>&gt;&gt; extension MyComplexDataType : InternalStructure {<br>&gt;&gt;<br>&gt;&gt;    typealias Index = InternalIndexType<br>&gt;&gt;     var count : Int {<br>&gt;&gt;         // We have access to all of the private members because we’re<br>&gt;&gt; inside MyComplexDataType<br>&gt;&gt;         // No need to pollute internal API with conformance<br>&gt;&gt; implementation details.<br>&gt;&gt;         // Also, we get errors about non-conformance where we want them —<br>&gt;&gt; where the implementation is.<br>&gt;&gt;     }<br>&gt;&gt;     func doInternalMagic(at: Index) {<br>&gt;&gt;        ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure I understand. What compiler or language support is missing<br>&gt;&gt; for StringCore?<br>&gt;&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have been following this discussion (as well as similar threads<br>&gt;&gt;&gt; earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It seems to me that the fundamental difference between classes and<br>&gt;&gt;&gt; protocols is that classes inherit implementation whereas protocol<br>&gt;&gt;&gt; conformance is a promise about interface.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a<br>&gt;&gt;&gt; protocol, that means it has all the members specified in the protocol. The<br>&gt;&gt;&gt; protocol conformance simply codifies a fact about the type itself: namely<br>&gt;&gt;&gt; that all those members are present.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming<br>&gt;&gt;&gt; member would introduce substantial boilerplate for negligible gain. The<br>&gt;&gt;&gt; purpose of a protocol is to communicate that certain members are available,<br>&gt;&gt;&gt; not to make declaring those members more onerous.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there<br>&gt;&gt;&gt; is actual implementation being inherited. A conforming type may choose to<br>&gt;&gt;&gt; roll its own version of a method, or to utilize the default provided by the<br>&gt;&gt;&gt; protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself<br>&gt;&gt;&gt; define (or redefine!) default implementations for members of that other<br>&gt;&gt;&gt; protocol. This can create “inheritance chains” of protocol default<br>&gt;&gt;&gt; implementations. I think there is value in being able to refer to (and<br>&gt;&gt;&gt; call) the inherited default implementation through some sort of `super`<br>&gt;&gt;&gt; functionality.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, the existence of a default implementation in a<br>&gt;&gt;&gt; protocol is in large part merely a convenience: a courtesy so that each<br>&gt;&gt;&gt; conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may<br>&gt;&gt;&gt; provide its own implementation, but it is not “overriding” anything. The<br>&gt;&gt;&gt; default implementation was offered as a convenience, to be taken or left as<br>&gt;&gt;&gt; needed. Thus I do not think any keyword (neither `override` nor<br>&gt;&gt;&gt; `implements`) should be required in that case either.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves<br>&gt;&gt;&gt; some attention. Several people have expressed a desire for the compiler to<br>&gt;&gt;&gt; assist them in determining whether a given member does or does not meet a<br>&gt;&gt;&gt; protocol requirement. Specifically, when a type conforms to a protocol with<br>&gt;&gt;&gt; a default implementation, and the type defines a member with a similar<br>&gt;&gt;&gt; signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax<br>&gt;&gt;&gt; highlighting could distinguish members which satisfy a protocol<br>&gt;&gt;&gt; requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas<br>&gt;&gt;&gt; put forth, I come down firmly on the side of no keyword for protocol<br>&gt;&gt;&gt; conformance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A protocol describes an interface and provides a set of customization<br>&gt;&gt;&gt; points. It may also, as a convenience, offer default implementations. The<br>&gt;&gt;&gt; protocol simply describes the capabilities of its conforming types, and any<br>&gt;&gt;&gt; default implementations are there to make things easier for them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that<br>&gt;&gt;&gt; would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses<br>&gt;&gt;&gt;&gt; are necessary, but they are possible without new syntax. There is no win in<br>&gt;&gt;&gt;&gt; avoiding unintentional behavior because, without a default implementation,<br>&gt;&gt;&gt;&gt; these issues are caught at compile time already.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be<br>&gt;&gt;&gt;&gt;&gt; clear<br>&gt;&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to<br>&gt;&gt;&gt;&gt;&gt; avoid<br>&gt;&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting<br>&gt;&gt;&gt;&gt;&gt; point, IMO.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where<br>&gt;&gt;&gt;&gt;&gt; previous<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;&gt;&gt;&gt;&gt; `implement`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt;&gt;&gt;&gt;&gt; because, if<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no<br>&gt;&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to<br>&gt;&gt;&gt;&gt;&gt; change or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt;&gt;&gt;&gt;&gt; writing*,<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some<br>&gt;&gt;&gt;&gt;&gt; *other*<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest<br>&gt;&gt;&gt;&gt;&gt; in this<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will<br>&gt;&gt;&gt;&gt;&gt; save<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However,<br>&gt;&gt;&gt;&gt;&gt; this is<br>&gt;&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but<br>&gt;&gt;&gt;&gt;&gt; it has<br>&gt;&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true<br>&gt;&gt;&gt;&gt;&gt; nature of<br>&gt;&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot<br>&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(),<br>&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an<br>&gt;&gt;&gt;&gt;&gt; ‘implement’<br>&gt;&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler<br>&gt;&gt;&gt;&gt;&gt; error to<br>&gt;&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly<br>&gt;&gt;&gt;&gt;&gt; declared.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in<br>&gt;&gt;&gt;&gt;&gt; question *is*<br>&gt;&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword,<br>&gt;&gt;&gt;&gt;&gt; because<br>&gt;&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol,<br>&gt;&gt;&gt;&gt;&gt; whereas<br>&gt;&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck<br>&gt;&gt;&gt;&gt;&gt; to the<br>&gt;&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite<br>&gt;&gt;&gt; a common thing, so you want it to be easy to remember.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;     var aVariable : Int<br>&gt;&gt;&gt;     func aFunction()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is consistent with how we refer to other members of types (e.g.<br>&gt;&gt;&gt; “extension MyClass.MyInternalClass”). It will be easy for autocompletion to<br>&gt;&gt;&gt; provide good suggestions, too.<br>&gt;&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own<br>&gt;&gt;&gt; function called `aFunction()`? What if the same name satisfies 2 protocols,<br>&gt;&gt;&gt; which do you write?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The way to solve all of the problems in a consistent way is to make the<br>&gt;&gt;&gt; function actually called “MyProto.aFunction”, and for it to be a separate<br>&gt;&gt;&gt; function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have<br>&gt;&gt;&gt; some complex data structure and it has its own API, but I want people to be<br>&gt;&gt;&gt; able to view it as a Collection. By conforming to Collection, I reserve<br>&gt;&gt;&gt; lots of keywords and indexing operations which I now can’t use in my own<br>&gt;&gt;&gt; API. Maybe I’m just providing Collection as a convenience to work with<br>&gt;&gt;&gt; generic algorithms, but my own API has more efficient semantics for some<br>&gt;&gt;&gt; operations. We’re relegated to using less-obvious and legible names in<br>&gt;&gt;&gt; order to avoid conflicts.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We have a way to work around this, which String uses - create a struct<br>&gt;&gt;&gt; which references your object and calls internal methods such as<br>&gt;&gt;&gt; “_collection_count” so you can have separate interfaces. This adds up to<br>&gt;&gt;&gt; quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also to add here: you’re basically implementing what I’m proposing<br>&gt;&gt;&gt; manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt;&gt; String basically does this - it shares StringCore with UTF8View and<br>&gt;&gt;&gt; defines some internal functions to support it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The String views could then be made in to protocols on String, turning<br>&gt;&gt;&gt; “UTF8View” in to “UTF8Representable”, and opening up algorithms which can<br>&gt;&gt;&gt; work on generic sequences of UTF8 bytes. I think that’s pretty cool, and<br>&gt;&gt;&gt; could open up better integration with other types which are (for example)<br>&gt;&gt;&gt; UTF8Representable — for example a stream of UTF8 bytes (depending on how<br>&gt;&gt;&gt; flexible implementation allows us to make the protocol).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as<br>&gt;&gt;&gt; others here have written. This isn’t like Objective-C where anything that<br>&gt;&gt;&gt; has the correctly-named methods conforms. Protocol conformances are<br>&gt;&gt;&gt; completely explicit, and in fact we have empty protocols (“marker<br>&gt;&gt;&gt; protocols”) for exactly that purpose. I think it is consistent that we make<br>&gt;&gt;&gt; every member of a conformance specify which protocol it belongs to, and to<br>&gt;&gt;&gt; have its name scoped to that protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of<br>&gt;&gt;&gt; protocols<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/97264b2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 21, 2016 at 01:00:00am</p></header><div class="content"><p>I’ve explained it so many times, do you really not understand it?<br></p><p>Basically, protocols are explicit things. They are **not** things that you just “discover” about types at all. We have protocols with no members (“marker protocols”) which are basically used to tag certain types with no other guarantees. That is the important difference between protocols in Swift and in Objective-C. Even if you have implementations for every requirement, if you never explicitly declared conformance you don’t conform. Period.<br></p><p>However, the requirements themselves don’t need to be explicitly marked-up. They just get automatically assigned by the compiler; maybe my property named “count” doesn’t mean the same thing as Collection’s “count”?<br></p><p>I’ve written a lot trying to explain this; please tell me what you don’t understand. To summarise (again):<br></p><p>- Members which satisfy a protocol requirement will have to be explicit about which protocol they belong to<br>——&gt; They will no longer be automatically assigned as the witness for a protocol requirement<br></p><p>- Members which satisfy a protocol requirement will have the protocol name in their symbolic names (e.g. MyType.someFunction() —&gt; MyType.AProtocol.someFunction())<br>——&gt; this will allow the same type to conform to protocols with overlapping names, free protocol designers from naming constraints, and reduce the need for “helper structs” to represent alternate views of the same data.<br>——&gt; Extensions which declare conformance have to satisfy all of their requirements explicitly - by implementing, forwarding to other functions, stored properties or other objects. We can have a shorthand to make this easy.<br></p><p>IMO, we definitely need to solve the overlapping naming problem. If we explicitly assign protocol methods to protocols (as the thread was originally about), this falls out of it.<br></p><p><br>&gt; On 21 Sep 2016, at 01:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; This was the conversation we were having in the other thread. Perhaps I&#39;m still not understanding something, but I&#39;m not convinced that this feature is an improvement.<br>&gt; <br>&gt; Currently, protocols represent a declaration that you have discovered that your type has certain semantics and guarantees a certain API, and you declare that fulfillment &quot;by name only,&quot; just as you invoke members &quot;by name only&quot;; unintentional failure to fulfill the contract is a compile-time error. The status quo is precisely my idea of what protocols should be. What are the two ideas you have about them?<br>&gt; On Tue, Sep 20, 2016 at 18:02 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; I’m using String as an example of where this issue of conformance conflicts crops up in the standard library. Ideally, String (or any data type) should be able to conform to protocols whose requirements have conflicting names.<br>&gt; Currently, in order to work around this limitation, you have to delegate the conformance to a supporting type. This is more complicated to write and maintain, and pollutes your internal API. String gives us an example of this, but it’s not the worst example.<br>&gt; It basically implements what I’m talking about anyway, but manually via a supporting type instead of directly inside the data-type (String). As an ABI consideration, we should scope all protocol members to their protocols. This would resolve all naming conflicts.<br>&gt; <br>&gt; I can’t understand how anybody would argue for the status quo - we’re currently in-between two ideas of what protocols should be - they are explicit but their conformances are resolved by name only and can overlap without warning.<br>&gt; <br>&gt;&gt; On 21 Sep 2016, at 00:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this. How would String conforming to Collection multiple times simplify or improve the implementation of String? Or are you arguing it would be better for users of String? If so, how?<br>&gt;&gt; <br>&gt;&gt; On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I’m not saying vital support is missing, just that it is more awkward. String doesn’t conform to collection, String.UTF8View does; so if you change some implementation detail (in StringCore, because that’s where they live for String), you get the error popping up somewhere other than the place you just changed. That’s what I mean when I say “language support”. If you do what StringCore does, and you’re changing stuff which is ultimately going to be used to conform to, say, Collection, you have to build distance between the implementation and the (only) conformance it is used for, and it’s less optimal.<br>&gt;&gt; <br>&gt;&gt; Let’s say I have an object MyComplexDataType, it implements “InternalStructureView” and “Collection”:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; protocol InternalStructureView {<br>&gt;&gt;     associatedtype Index<br>&gt;&gt;     var count : Int { get } // whatever, just some stuff that will cause a name conflict<br>&gt;&gt;     func doInternalMagic(at: Index)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct MyComplexDataType {<br>&gt;&gt;     var __collection_count : Int {<br>&gt;&gt;         // This is quite a complex operation which we’d rather leave inside the type, otherwise we’d need to expose a bunch of implementation details internally<br>&gt;&gt;     }<br>&gt;&gt;    var __internal_count : Int {<br>&gt;&gt;        // Again, best left here<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    struct CollectionView  : Collection {<br>&gt;&gt;        init(parent: MyComplexDataType) { … }<br>&gt;&gt;         var count { return parent.__collection_count }<br>&gt;&gt;         // ...etc<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;   struct InternalStructure : InternalStructureView {<br>&gt;&gt;       init(parent: MyComplexDataType) { … }<br>&gt;&gt;       var count { return parent.__internal_count }<br>&gt;&gt;       // ...etc<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;&gt;   var internalStructure : InternalStructure { return InternalStructure(self) }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This is basically what String does (except that it wants to conform to Collection multiple times with different indexes and results). It’s a lot of work to maintain, especially if you have evolving protocols that are conformed to in several places.<br>&gt;&gt; We should have a better solution. We should be able to define:<br>&gt;&gt; <br>&gt;&gt; “protocol UTF8Collection : Collection {}<br>&gt;&gt;  protocol UTF16Collection : Collection {}”<br>&gt;&gt; <br>&gt;&gt; and have String conform to both of them at the same time. At the same time, since we’re now being explicit about which protocol requirement is satisfied where - we should also be able to delegate our conformance, telling the compiler to dispatch any unimplemented methods to another object. For example, lets say you want to wrap a Collection and observe mutations to it; you might override replaceSubrange(), but every other method (such as count, index(after:)… all the rest) is just a forwarding function.<br>&gt;&gt; <br>&gt;&gt; Interestingly, we could do this safely (from a code legibility perspective) if we say that every scope which adds a conformance must completely satisfy its requirements, which we would more reasonably be able to require if we made this change (so your internal functions can still be wherever you like, but they won’t automatically satisfy a protocol requirement if they happen to have the same name). Then we could reasonably say that if you add an extension which adds a conformance to, say, Collection, you have to tell us where to find every one of its requirements. That’s where we could put the forwarding syntax for retroactive modelling. Stored properties can’t be defined in extensions, so if you want to back an implementation with one, you’ll need to make its conformance explicit in the main body (or we loosen that to at least extensions in the same file).<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; // generates thunks to members of this extension in the base type; <br>&gt;&gt; // so MyComplexDataType.count —&gt; MyComplexDataType.InternalStructure.count,<br>&gt;&gt; // to account for conformance being added in later version. Can also be used for renamed protocols, and be tagged on individual members.<br>&gt;&gt; <br>&gt;&gt; @makeAvailable(as: _)<br>&gt;&gt; extension MyComplexDataType : InternalStructure {<br>&gt;&gt; <br>&gt;&gt;    typealias Index = InternalIndexType<br>&gt;&gt;     var count : Int {<br>&gt;&gt;         // We have access to all of the private members because we’re inside MyComplexDataType<br>&gt;&gt;         // No need to pollute internal API with conformance implementation details.<br>&gt;&gt;         // Also, we get errors about non-conformance where we want them — where the implementation is.<br>&gt;&gt;     }<br>&gt;&gt;     func doInternalMagic(at: Index) {<br>&gt;&gt;        ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt;&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure I understand. What compiler or language support is missing for StringCore?<br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt;&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt;&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt;&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt;&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt;&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt;&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt;&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;&gt;     var aVariable : Int<br>&gt;&gt;&gt;&gt;     func aFunction()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>&gt;&gt;&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also to add here: you’re basically implementing what I’m proposing manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt;&gt; String basically does this - it shares StringCore with UTF8View and defines some internal functions to support it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The String views could then be made in to protocols on String, turning “UTF8View” in to “UTF8Representable”, and opening up algorithms which can work on generic sequences of UTF8 bytes. I think that’s pretty cool, and could open up better integration with other types which are (for example) UTF8Representable — for example a stream of UTF8 bytes (depending on how flexible implementation allows us to make the protocol).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/fa11c2d5/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 21, 2016 at 02:00:00am</p></header><div class="content"><p>Sorry if that sounds a little bit rude, I’ve been switching between English and German a lot and the way you speak in one language can come across wrong in another!<br></p><p>&gt; On 21 Sep 2016, at 01:58, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; I’ve explained it so many times, do you really not understand it?<br>&gt; <br>&gt; Basically, protocols are explicit things. They are **not** things that you just “discover” about types at all. We have protocols with no members (“marker protocols”) which are basically used to tag certain types with no other guarantees. That is the important difference between protocols in Swift and in Objective-C. Even if you have implementations for every requirement, if you never explicitly declared conformance you don’t conform. Period.<br>&gt; <br>&gt; However, the requirements themselves don’t need to be explicitly marked-up. They just get automatically assigned by the compiler; maybe my property named “count” doesn’t mean the same thing as Collection’s “count”?<br>&gt; <br>&gt; I’ve written a lot trying to explain this; please tell me what you don’t understand. To summarise (again):<br>&gt; <br>&gt; - Members which satisfy a protocol requirement will have to be explicit about which protocol they belong to<br>&gt; ——&gt; They will no longer be automatically assigned as the witness for a protocol requirement<br>&gt; <br>&gt; - Members which satisfy a protocol requirement will have the protocol name in their symbolic names (e.g. MyType.someFunction() —&gt; MyType.AProtocol.someFunction())<br>&gt; ——&gt; this will allow the same type to conform to protocols with overlapping names, free protocol designers from naming constraints, and reduce the need for “helper structs” to represent alternate views of the same data.<br>&gt; ——&gt; Extensions which declare conformance have to satisfy all of their requirements explicitly - by implementing, forwarding to other functions, stored properties or other objects. We can have a shorthand to make this easy.<br>&gt; <br>&gt; IMO, we definitely need to solve the overlapping naming problem. If we explicitly assign protocol methods to protocols (as the thread was originally about), this falls out of it.<br>&gt; <br>&gt; <br>&gt;&gt; On 21 Sep 2016, at 01:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was the conversation we were having in the other thread. Perhaps I&#39;m still not understanding something, but I&#39;m not convinced that this feature is an improvement.<br>&gt;&gt; <br>&gt;&gt; Currently, protocols represent a declaration that you have discovered that your type has certain semantics and guarantees a certain API, and you declare that fulfillment &quot;by name only,&quot; just as you invoke members &quot;by name only&quot;; unintentional failure to fulfill the contract is a compile-time error. The status quo is precisely my idea of what protocols should be. What are the two ideas you have about them?<br>&gt;&gt; On Tue, Sep 20, 2016 at 18:02 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I’m using String as an example of where this issue of conformance conflicts crops up in the standard library. Ideally, String (or any data type) should be able to conform to protocols whose requirements have conflicting names.<br>&gt;&gt; Currently, in order to work around this limitation, you have to delegate the conformance to a supporting type. This is more complicated to write and maintain, and pollutes your internal API. String gives us an example of this, but it’s not the worst example.<br>&gt;&gt; It basically implements what I’m talking about anyway, but manually via a supporting type instead of directly inside the data-type (String). As an ABI consideration, we should scope all protocol members to their protocols. This would resolve all naming conflicts.<br>&gt;&gt; <br>&gt;&gt; I can’t understand how anybody would argue for the status quo - we’re currently in-between two ideas of what protocols should be - they are explicit but their conformances are resolved by name only and can overlap without warning.<br>&gt;&gt; <br>&gt;&gt;&gt; On 21 Sep 2016, at 00:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this. How would String conforming to Collection multiple times simplify or improve the implementation of String? Or are you arguing it would be better for users of String? If so, how?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I’m not saying vital support is missing, just that it is more awkward. String doesn’t conform to collection, String.UTF8View does; so if you change some implementation detail (in StringCore, because that’s where they live for String), you get the error popping up somewhere other than the place you just changed. That’s what I mean when I say “language support”. If you do what StringCore does, and you’re changing stuff which is ultimately going to be used to conform to, say, Collection, you have to build distance between the implementation and the (only) conformance it is used for, and it’s less optimal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say I have an object MyComplexDataType, it implements “InternalStructureView” and “Collection”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; protocol InternalStructureView {<br>&gt;&gt;&gt;     associatedtype Index<br>&gt;&gt;&gt;     var count : Int { get } // whatever, just some stuff that will cause a name conflict<br>&gt;&gt;&gt;     func doInternalMagic(at: Index)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MyComplexDataType {<br>&gt;&gt;&gt;     var __collection_count : Int {<br>&gt;&gt;&gt;         // This is quite a complex operation which we’d rather leave inside the type, otherwise we’d need to expose a bunch of implementation details internally<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    var __internal_count : Int {<br>&gt;&gt;&gt;        // Again, best left here<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct CollectionView  : Collection {<br>&gt;&gt;&gt;        init(parent: MyComplexDataType) { … }<br>&gt;&gt;&gt;         var count { return parent.__collection_count }<br>&gt;&gt;&gt;         // ...etc<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   struct InternalStructure : InternalStructureView {<br>&gt;&gt;&gt;       init(parent: MyComplexDataType) { … }<br>&gt;&gt;&gt;       var count { return parent.__internal_count }<br>&gt;&gt;&gt;       // ...etc<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;&gt;&gt;   var internalStructure : InternalStructure { return InternalStructure(self) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is basically what String does (except that it wants to conform to Collection multiple times with different indexes and results). It’s a lot of work to maintain, especially if you have evolving protocols that are conformed to in several places.<br>&gt;&gt;&gt; We should have a better solution. We should be able to define:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “protocol UTF8Collection : Collection {}<br>&gt;&gt;&gt;  protocol UTF16Collection : Collection {}”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and have String conform to both of them at the same time. At the same time, since we’re now being explicit about which protocol requirement is satisfied where - we should also be able to delegate our conformance, telling the compiler to dispatch any unimplemented methods to another object. For example, lets say you want to wrap a Collection and observe mutations to it; you might override replaceSubrange(), but every other method (such as count, index(after:)… all the rest) is just a forwarding function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interestingly, we could do this safely (from a code legibility perspective) if we say that every scope which adds a conformance must completely satisfy its requirements, which we would more reasonably be able to require if we made this change (so your internal functions can still be wherever you like, but they won’t automatically satisfy a protocol requirement if they happen to have the same name). Then we could reasonably say that if you add an extension which adds a conformance to, say, Collection, you have to tell us where to find every one of its requirements. That’s where we could put the forwarding syntax for retroactive modelling. Stored properties can’t be defined in extensions, so if you want to back an implementation with one, you’ll need to make its conformance explicit in the main body (or we loosen that to at least extensions in the same file).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; // generates thunks to members of this extension in the base type; <br>&gt;&gt;&gt; // so MyComplexDataType.count —&gt; MyComplexDataType.InternalStructure.count,<br>&gt;&gt;&gt; // to account for conformance being added in later version. Can also be used for renamed protocols, and be tagged on individual members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @makeAvailable(as: _)<br>&gt;&gt;&gt; extension MyComplexDataType : InternalStructure {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    typealias Index = InternalIndexType<br>&gt;&gt;&gt;     var count : Int {<br>&gt;&gt;&gt;         // We have access to all of the private members because we’re inside MyComplexDataType<br>&gt;&gt;&gt;         // No need to pollute internal API with conformance implementation details.<br>&gt;&gt;&gt;         // Also, we get errors about non-conformance where we want them — where the implementation is.<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     func doInternalMagic(at: Index) {<br>&gt;&gt;&gt;        ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure I understand. What compiler or language support is missing for StringCore?<br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt;&gt;&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt;&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;&gt;&gt;     var aVariable : Int<br>&gt;&gt;&gt;&gt;&gt;     func aFunction()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;&gt;&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>&gt;&gt;&gt;&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also to add here: you’re basically implementing what I’m proposing manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt;&gt;&gt; String basically does this - it shares StringCore with UTF8View and defines some internal functions to support it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The String views could then be made in to protocols on String, turning “UTF8View” in to “UTF8Representable”, and opening up algorithms which can work on generic sequences of UTF8 bytes. I think that’s pretty cool, and could open up better integration with other types which are (for example) UTF8Representable — for example a stream of UTF8 bytes (depending on how flexible implementation allows us to make the protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/e14b23dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 21, 2016 at 12:00:00am</p></header><div class="content"><p>No problem! I understand *what* your proposal is. I don&#39;t understand what<br>benefit it has over the status quo.<br></p><p>Currently, when you say that your type T conforms to Collection, you are<br>not only guaranteeing that T has a member named count, you are also making<br>the guarantee that T.count meets the semantic requirements of<br>Collection.count. That is why protocol conformance is explicit. If count is<br>a member of T but does not meet the semantic guarantees of<br>Collection.count, then you should not conform T to Collection. So yes, a<br>protocol conformance *is* a fact you discover about a type.<br></p><p>I&#39;m not yet convinced we &quot;need&quot; to solve the overlapping problem, as still<br>no one has demonstrated a real-world use case. If there is one, I think<br>there are far more surgical and additive approaches. But that is not the<br>topic of this thread.<br></p><p>On Tue, Sep 20, 2016 at 7:01 PM Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; Sorry if that sounds a little bit rude, I’ve been switching between<br>&gt; English and German a lot and the way you speak in one language can come<br>&gt; across wrong in another!<br>&gt;<br>&gt; On 21 Sep 2016, at 01:58, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt;<br>&gt; I’ve explained it so many times, do you really not understand it?<br>&gt;<br>&gt; Basically, protocols are explicit things. They are **not** things that you<br>&gt; just “discover” about types at all. We have protocols with no members<br>&gt; (“marker protocols”) which are basically used to tag certain types with no<br>&gt; other guarantees. That is the important difference between protocols in<br>&gt; Swift and in Objective-C. Even if you have implementations for every<br>&gt; requirement, if you never explicitly declared conformance you don’t<br>&gt; conform. Period.<br>&gt;<br>&gt; However, the requirements themselves don’t need to be explicitly<br>&gt; marked-up. They just get automatically assigned by the compiler; maybe my<br>&gt; property named “count” doesn’t mean the same thing as Collection’s “count”?<br>&gt;<br>&gt; I’ve written a lot trying to explain this; please tell me what you don’t<br>&gt; understand. To summarise (again):<br>&gt;<br>&gt; - Members which satisfy a protocol requirement will have to be explicit<br>&gt; about which protocol they belong to<br>&gt; ——&gt; They will no longer be automatically assigned as the witness for a<br>&gt; protocol requirement<br>&gt;<br>&gt; - Members which satisfy a protocol requirement will have the protocol name<br>&gt; in their symbolic names (e.g. MyType.someFunction() —&gt;<br>&gt; MyType.AProtocol.someFunction())<br>&gt; ——&gt; this will allow the same type to conform to protocols with overlapping<br>&gt; names, free protocol designers from naming constraints, and reduce the need<br>&gt; for “helper structs” to represent alternate views of the same data.<br>&gt; ——&gt; Extensions which declare conformance have to satisfy all of their<br>&gt; requirements explicitly - by implementing, forwarding to other functions,<br>&gt; stored properties or other objects. We can have a shorthand to make this<br>&gt; easy.<br>&gt;<br>&gt; IMO, we definitely need to solve the overlapping naming problem. If we<br>&gt; explicitly assign protocol methods to protocols (as the thread was<br>&gt; originally about), this falls out of it.<br>&gt;<br>&gt;<br>&gt; On 21 Sep 2016, at 01:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This was the conversation we were having in the other thread. Perhaps I&#39;m<br>&gt; still not understanding something, but I&#39;m not convinced that this feature<br>&gt; is an improvement.<br>&gt;<br>&gt; Currently, protocols represent a declaration that you have discovered that<br>&gt; your type has certain semantics and guarantees a certain API, and you<br>&gt; declare that fulfillment &quot;by name only,&quot; just as you invoke members &quot;by<br>&gt; name only&quot;; unintentional failure to fulfill the contract is a compile-time<br>&gt; error. The status quo is precisely my idea of what protocols should be.<br>&gt; What are the two ideas you have about them?<br>&gt; On Tue, Sep 20, 2016 at 18:02 Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I’m using String as an example of where this issue of conformance<br>&gt;&gt; conflicts crops up in the standard library. Ideally, String (or any data<br>&gt;&gt; type) should be able to conform to protocols whose requirements have<br>&gt;&gt; conflicting names.<br>&gt;&gt; Currently, in order to work around this limitation, you have to delegate<br>&gt;&gt; the conformance to a supporting type. This is more complicated to write and<br>&gt;&gt; maintain, and pollutes your internal API. String gives us an example of<br>&gt;&gt; this, but it’s not the worst example.<br>&gt;&gt; It basically implements what I’m talking about anyway, but manually via a<br>&gt;&gt; supporting type instead of directly inside the data-type (String). As an<br>&gt;&gt; ABI consideration, we should scope all protocol members to their protocols.<br>&gt;&gt; This would resolve all naming conflicts.<br>&gt;&gt;<br>&gt;&gt; I can’t understand how anybody would argue for the status quo - we’re<br>&gt;&gt; currently in-between two ideas of what protocols should be - they are<br>&gt;&gt; explicit but their conformances are resolved by name only and can overlap<br>&gt;&gt; without warning.<br>&gt;&gt;<br>&gt;&gt; On 21 Sep 2016, at 00:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this.<br>&gt;&gt; How would String conforming to Collection multiple times simplify or<br>&gt;&gt; improve the implementation of String? Or are you arguing it would be better<br>&gt;&gt; for users of String? If so, how?<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I’m not saying vital support is missing, just that it is more awkward.<br>&gt;&gt;&gt; String doesn’t conform to collection, String.UTF8View does; so if you<br>&gt;&gt;&gt; change some implementation detail (in StringCore, because that’s where they<br>&gt;&gt;&gt; live for String), you get the error popping up somewhere other than the<br>&gt;&gt;&gt; place you just changed. That’s what I mean when I say “language support”.<br>&gt;&gt;&gt; If you do what StringCore does, and you’re changing stuff which is<br>&gt;&gt;&gt; ultimately going to be used to conform to, say, Collection, you have to<br>&gt;&gt;&gt; build distance between the implementation and the (only) conformance it is<br>&gt;&gt;&gt; used for, and it’s less optimal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let’s say I have an object MyComplexDataType, it implements<br>&gt;&gt;&gt; “InternalStructureView” and “Collection”:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; protocol InternalStructureView {<br>&gt;&gt;&gt;     associatedtype Index<br>&gt;&gt;&gt;     var count : Int { get } // whatever, just some stuff that will cause<br>&gt;&gt;&gt; a name conflict<br>&gt;&gt;&gt;     func doInternalMagic(at: Index)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct MyComplexDataType {<br>&gt;&gt;&gt;     var __collection_count : Int {<br>&gt;&gt;&gt;         // This is quite a complex operation which we’d rather leave<br>&gt;&gt;&gt; inside the type, otherwise we’d need to expose a bunch of implementation<br>&gt;&gt;&gt; details internally<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    var __internal_count : Int {<br>&gt;&gt;&gt;        // Again, best left here<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    struct CollectionView  : Collection {<br>&gt;&gt;&gt;        init(parent: MyComplexDataType) { … }<br>&gt;&gt;&gt;         var count { return parent.__collection_count }<br>&gt;&gt;&gt;         // ...etc<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   struct InternalStructure : InternalStructureView {<br>&gt;&gt;&gt;       init(parent: MyComplexDataType) { … }<br>&gt;&gt;&gt;       var count { return parent.__internal_count }<br>&gt;&gt;&gt;       // ...etc<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;&gt;&gt;   var internalStructure : InternalStructure { return<br>&gt;&gt;&gt; InternalStructure(self) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is basically what String does (except that it wants to conform to<br>&gt;&gt;&gt; Collection multiple times with different indexes and results). It’s a lot<br>&gt;&gt;&gt; of work to maintain, especially if you have evolving protocols that are<br>&gt;&gt;&gt; conformed to in several places.<br>&gt;&gt;&gt; We should have a better solution. We should be able to define:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; “protocol UTF8Collection : Collection {}<br>&gt;&gt;&gt;  protocol UTF16Collection : Collection {}”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; and have String conform to both of them at the same time. At the same<br>&gt;&gt;&gt; time, since we’re now being explicit about which protocol requirement is<br>&gt;&gt;&gt; satisfied where - we should also be able to delegate our conformance,<br>&gt;&gt;&gt; telling the compiler to dispatch any unimplemented methods to another<br>&gt;&gt;&gt; object. For example, lets say you want to wrap a Collection and observe<br>&gt;&gt;&gt; mutations to it; you might override replaceSubrange(), but every other<br>&gt;&gt;&gt; method (such as count, index(after:)… all the rest) is just a forwarding<br>&gt;&gt;&gt; function.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Interestingly, we could do this safely (from a code legibility<br>&gt;&gt;&gt; perspective) if we say that every scope which adds a conformance must<br>&gt;&gt;&gt; completely satisfy its requirements, which we would more reasonably be able<br>&gt;&gt;&gt; to require if we made this change (so your internal functions can still be<br>&gt;&gt;&gt; wherever you like, but they won’t automatically satisfy a protocol<br>&gt;&gt;&gt; requirement if they happen to have the same name). Then we could reasonably<br>&gt;&gt;&gt; say that if you add an extension which adds a conformance to, say,<br>&gt;&gt;&gt; Collection, you have to tell us where to find every one of its<br>&gt;&gt;&gt; requirements. That’s where we could put the forwarding syntax for<br>&gt;&gt;&gt; retroactive modelling. Stored properties can’t be defined in extensions, so<br>&gt;&gt;&gt; if you want to back an implementation with one, you’ll need to make its<br>&gt;&gt;&gt; conformance explicit in the main body (or we loosen that to at least<br>&gt;&gt;&gt; extensions in the same file).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; // generates thunks to members of this extension in the base type;<br>&gt;&gt;&gt; // so MyComplexDataType.count —&gt;<br>&gt;&gt;&gt; MyComplexDataType.InternalStructure.count,<br>&gt;&gt;&gt; // to account for conformance being added in later version. Can also be<br>&gt;&gt;&gt; used for renamed protocols, and be tagged on individual members.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @makeAvailable(as: _)<br>&gt;&gt;&gt; extension MyComplexDataType : InternalStructure {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    typealias Index = InternalIndexType<br>&gt;&gt;&gt;     var count : Int {<br>&gt;&gt;&gt;         // We have access to all of the private members because we’re<br>&gt;&gt;&gt; inside MyComplexDataType<br>&gt;&gt;&gt;         // No need to pollute internal API with conformance<br>&gt;&gt;&gt; implementation details.<br>&gt;&gt;&gt;         // Also, we get errors about non-conformance where we want them<br>&gt;&gt;&gt; — where the implementation is.<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     func doInternalMagic(at: Index) {<br>&gt;&gt;&gt;        ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure I understand. What compiler or language support is missing<br>&gt;&gt;&gt; for StringCore?<br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I have been following this discussion (as well as similar threads<br>&gt;&gt;&gt;&gt; earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It seems to me that the fundamental difference between classes and<br>&gt;&gt;&gt;&gt; protocols is that classes inherit implementation whereas protocol<br>&gt;&gt;&gt;&gt; conformance is a promise about interface.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a<br>&gt;&gt;&gt;&gt; protocol, that means it has all the members specified in the protocol. The<br>&gt;&gt;&gt;&gt; protocol conformance simply codifies a fact about the type itself: namely<br>&gt;&gt;&gt;&gt; that all those members are present.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming<br>&gt;&gt;&gt;&gt; member would introduce substantial boilerplate for negligible gain. The<br>&gt;&gt;&gt;&gt; purpose of a protocol is to communicate that certain members are available,<br>&gt;&gt;&gt;&gt; not to make declaring those members more onerous.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there<br>&gt;&gt;&gt;&gt; is actual implementation being inherited. A conforming type may choose to<br>&gt;&gt;&gt;&gt; roll its own version of a method, or to utilize the default provided by the<br>&gt;&gt;&gt;&gt; protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself<br>&gt;&gt;&gt;&gt; define (or redefine!) default implementations for members of that other<br>&gt;&gt;&gt;&gt; protocol. This can create “inheritance chains” of protocol default<br>&gt;&gt;&gt;&gt; implementations. I think there is value in being able to refer to (and<br>&gt;&gt;&gt;&gt; call) the inherited default implementation through some sort of `super`<br>&gt;&gt;&gt;&gt; functionality.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On the other hand, the existence of a default implementation in a<br>&gt;&gt;&gt;&gt; protocol is in large part merely a convenience: a courtesy so that each<br>&gt;&gt;&gt;&gt; conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may<br>&gt;&gt;&gt;&gt; provide its own implementation, but it is not “overriding” anything. The<br>&gt;&gt;&gt;&gt; default implementation was offered as a convenience, to be taken or left as<br>&gt;&gt;&gt;&gt; needed. Thus I do not think any keyword (neither `override` nor<br>&gt;&gt;&gt;&gt; `implements`) should be required in that case either.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves<br>&gt;&gt;&gt;&gt; some attention. Several people have expressed a desire for the compiler to<br>&gt;&gt;&gt;&gt; assist them in determining whether a given member does or does not meet a<br>&gt;&gt;&gt;&gt; protocol requirement. Specifically, when a type conforms to a protocol with<br>&gt;&gt;&gt;&gt; a default implementation, and the type defines a member with a similar<br>&gt;&gt;&gt;&gt; signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax<br>&gt;&gt;&gt;&gt; highlighting could distinguish members which satisfy a protocol<br>&gt;&gt;&gt;&gt; requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas<br>&gt;&gt;&gt;&gt; put forth, I come down firmly on the side of no keyword for protocol<br>&gt;&gt;&gt;&gt; conformance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A protocol describes an interface and provides a set of customization<br>&gt;&gt;&gt;&gt; points. It may also, as a convenience, offer default implementations. The<br>&gt;&gt;&gt;&gt; protocol simply describes the capabilities of its conforming types, and any<br>&gt;&gt;&gt;&gt; default implementations are there to make things easier for them.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that<br>&gt;&gt;&gt;&gt; would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses<br>&gt;&gt;&gt;&gt;&gt; are necessary, but they are possible without new syntax. There is no win in<br>&gt;&gt;&gt;&gt;&gt; avoiding unintentional behavior because, without a default implementation,<br>&gt;&gt;&gt;&gt;&gt; these issues are caught at compile time already.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be<br>&gt;&gt;&gt;&gt;&gt;&gt; clear<br>&gt;&gt;&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show<br>&gt;&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to<br>&gt;&gt;&gt;&gt;&gt;&gt; avoid<br>&gt;&gt;&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting<br>&gt;&gt;&gt;&gt;&gt;&gt; point, IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where<br>&gt;&gt;&gt;&gt;&gt;&gt; previous<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;&gt;&gt;&gt;&gt;&gt; `implement`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt;&gt;&gt;&gt;&gt;&gt; because, if<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no<br>&gt;&gt;&gt;&gt;&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to<br>&gt;&gt;&gt;&gt;&gt;&gt; change or<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt;&gt;&gt;&gt;&gt;&gt; writing*,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some<br>&gt;&gt;&gt;&gt;&gt;&gt; *other*<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest<br>&gt;&gt;&gt;&gt;&gt;&gt; in this<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will<br>&gt;&gt;&gt;&gt;&gt;&gt; save<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However,<br>&gt;&gt;&gt;&gt;&gt;&gt; this is<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but<br>&gt;&gt;&gt;&gt;&gt;&gt; it has<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true<br>&gt;&gt;&gt;&gt;&gt;&gt; nature of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot<br>&gt;&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(),<br>&gt;&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an<br>&gt;&gt;&gt;&gt;&gt;&gt; ‘implement’<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler<br>&gt;&gt;&gt;&gt;&gt;&gt; error to<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly<br>&gt;&gt;&gt;&gt;&gt;&gt; declared.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in<br>&gt;&gt;&gt;&gt;&gt;&gt; question *is*<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword,<br>&gt;&gt;&gt;&gt;&gt;&gt; because<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol,<br>&gt;&gt;&gt;&gt;&gt;&gt; whereas<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck<br>&gt;&gt;&gt;&gt;&gt;&gt; to the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is<br>&gt;&gt;&gt;&gt; quite a common thing, so you want it to be easy to remember.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol,<br>&gt;&gt;&gt;&gt; e.g:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;&gt;     var aVariable : Int<br>&gt;&gt;&gt;&gt;     func aFunction()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is consistent with how we refer to other members of types (e.g.<br>&gt;&gt;&gt;&gt; “extension MyClass.MyInternalClass”). It will be easy for autocompletion to<br>&gt;&gt;&gt;&gt; provide good suggestions, too.<br>&gt;&gt;&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own<br>&gt;&gt;&gt;&gt; function called `aFunction()`? What if the same name satisfies 2 protocols,<br>&gt;&gt;&gt;&gt; which do you write?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The way to solve all of the problems in a consistent way is to make the<br>&gt;&gt;&gt;&gt; function actually called “MyProto.aFunction”, and for it to be a separate<br>&gt;&gt;&gt;&gt; function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have<br>&gt;&gt;&gt;&gt; some complex data structure and it has its own API, but I want people to be<br>&gt;&gt;&gt;&gt; able to view it as a Collection. By conforming to Collection, I reserve<br>&gt;&gt;&gt;&gt; lots of keywords and indexing operations which I now can’t use in my own<br>&gt;&gt;&gt;&gt; API. Maybe I’m just providing Collection as a convenience to work with<br>&gt;&gt;&gt;&gt; generic algorithms, but my own API has more efficient semantics for some<br>&gt;&gt;&gt;&gt; operations. We’re relegated to using less-obvious and legible names in<br>&gt;&gt;&gt;&gt; order to avoid conflicts.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We have a way to work around this, which String uses - create a struct<br>&gt;&gt;&gt;&gt; which references your object and calls internal methods such as<br>&gt;&gt;&gt;&gt; “_collection_count” so you can have separate interfaces. This adds up to<br>&gt;&gt;&gt;&gt; quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Also to add here: you’re basically implementing what I’m proposing<br>&gt;&gt;&gt;&gt; manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt;&gt;&gt; String basically does this - it shares StringCore with UTF8View and<br>&gt;&gt;&gt;&gt; defines some internal functions to support it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The String views could then be made in to protocols on String, turning<br>&gt;&gt;&gt;&gt; “UTF8View” in to “UTF8Representable”, and opening up algorithms which can<br>&gt;&gt;&gt;&gt; work on generic sequences of UTF8 bytes. I think that’s pretty cool, and<br>&gt;&gt;&gt;&gt; could open up better integration with other types which are (for example)<br>&gt;&gt;&gt;&gt; UTF8Representable — for example a stream of UTF8 bytes (depending on how<br>&gt;&gt;&gt;&gt; flexible implementation allows us to make the protocol).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as<br>&gt;&gt;&gt;&gt; others here have written. This isn’t like Objective-C where anything that<br>&gt;&gt;&gt;&gt; has the correctly-named methods conforms. Protocol conformances are<br>&gt;&gt;&gt;&gt; completely explicit, and in fact we have empty protocols (“marker<br>&gt;&gt;&gt;&gt; protocols”) for exactly that purpose. I think it is consistent that we make<br>&gt;&gt;&gt;&gt; every member of a conformance specify which protocol it belongs to, and to<br>&gt;&gt;&gt;&gt; have its name scoped to that protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of<br>&gt;&gt;&gt;&gt; protocols<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/828bb7b7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 21.09.2016 um 01:58 schrieb Karl via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I’ve explained it so many times, do you really not understand it?<br>&gt; <br>&gt; Basically, protocols are explicit things. They are **not** things that you just “discover” about types at all. We have protocols with no members (“marker protocols”) which are basically used to tag certain types with no other guarantees. That is the important difference between protocols in Swift and in Objective-C. Even if you have implementations for every requirement, if you never explicitly declared conformance you don’t conform. Period.<br>&gt; <br>&gt; However, the requirements themselves don’t need to be explicitly marked-up. They just get automatically assigned by the compiler; maybe my property named “count” doesn’t mean the same thing as Collection’s “count”?<br>&gt; <br>&gt; I’ve written a lot trying to explain this; please tell me what you don’t understand. To summarise (again):<br>&gt; <br>&gt; - Members which satisfy a protocol requirement will have to be explicit about which protocol they belong to<br>&gt; ——&gt; They will no longer be automatically assigned as the witness for a protocol requirement<br>&gt; <br>&gt; - Members which satisfy a protocol requirement will have the protocol name in their symbolic names (e.g. MyType.someFunction() —&gt; MyType.AProtocol.someFunction())<br>&gt; ——&gt; this will allow the same type to conform to protocols with overlapping names, free protocol designers from naming constraints, and reduce the need for “helper structs” to represent alternate views of the same data.<br></p><p>While this solves the problem of overlapping names with different semantics, how would you express the case where the names actually have the same semantics, so that you only want to have one implementor?<br></p><p>protocol A {<br>	func specficSemantics()<br>	func sameSemantics()<br>}<br></p><p>protocol B {<br>	func specficSemantics()<br>	func sameSemantics()<br>}<br></p><p>struct C : A, B {<br>	// these implementations have to be specific for A and B so Karl’s approach allows to differentiate them <br>	func A.specficSemantics() { … }<br>	func B.specficSemantics() { … }<br></p><p>	// this implementation should be shared by A and B because both share the same semantic here<br>	func sameSemantics() { … } // ??<br></p><p>	// would I have to write it like that (manual delegation to the shared implementation)?<br>	func sameSemantics() { … }<br>	func A.sameSemantics() { sameSemantics() }<br>	func B.sameSemantics() { sameSemantics() }<br>}<br></p><p>-Thorsten<br></p><p>&gt; ——&gt; Extensions which declare conformance have to satisfy all of their requirements explicitly - by implementing, forwarding to other functions, stored properties or other objects. We can have a shorthand to make this easy.<br>&gt; <br>&gt; IMO, we definitely need to solve the overlapping naming problem. If we explicitly assign protocol methods to protocols (as the thread was originally about), this falls out of it.<br>&gt; <br>&gt; <br>&gt;&gt; On 21 Sep 2016, at 01:25, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was the conversation we were having in the other thread. Perhaps I&#39;m still not understanding something, but I&#39;m not convinced that this feature is an improvement.<br>&gt;&gt; <br>&gt;&gt; Currently, protocols represent a declaration that you have discovered that your type has certain semantics and guarantees a certain API, and you declare that fulfillment &quot;by name only,&quot; just as you invoke members &quot;by name only&quot;; unintentional failure to fulfill the contract is a compile-time error. The status quo is precisely my idea of what protocols should be. What are the two ideas you have about them?<br>&gt;&gt; On Tue, Sep 20, 2016 at 18:02 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I’m using String as an example of where this issue of conformance conflicts crops up in the standard library. Ideally, String (or any data type) should be able to conform to protocols whose requirements have conflicting names.<br>&gt;&gt; Currently, in order to work around this limitation, you have to delegate the conformance to a supporting type. This is more complicated to write and maintain, and pollutes your internal API. String gives us an example of this, but it’s not the worst example.<br>&gt;&gt; It basically implements what I’m talking about anyway, but manually via a supporting type instead of directly inside the data-type (String). As an ABI consideration, we should scope all protocol members to their protocols. This would resolve all naming conflicts.<br>&gt;&gt; <br>&gt;&gt; I can’t understand how anybody would argue for the status quo - we’re currently in-between two ideas of what protocols should be - they are explicit but their conformances are resolved by name only and can overlap without warning.<br>&gt;&gt; <br>&gt;&gt;&gt; On 21 Sep 2016, at 00:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I&#39;m still not sure I understand what you&#39;re getting at about this. How would String conforming to Collection multiple times simplify or improve the implementation of String? Or are you arguing it would be better for users of String? If so, how?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 17:26 Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I’m not saying vital support is missing, just that it is more awkward. String doesn’t conform to collection, String.UTF8View does; so if you change some implementation detail (in StringCore, because that’s where they live for String), you get the error popping up somewhere other than the place you just changed. That’s what I mean when I say “language support”. If you do what StringCore does, and you’re changing stuff which is ultimately going to be used to conform to, say, Collection, you have to build distance between the implementation and the (only) conformance it is used for, and it’s less optimal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say I have an object MyComplexDataType, it implements “InternalStructureView” and “Collection”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; protocol InternalStructureView {<br>&gt;&gt;&gt;     associatedtype Index<br>&gt;&gt;&gt;     var count : Int { get } // whatever, just some stuff that will cause a name conflict<br>&gt;&gt;&gt;     func doInternalMagic(at: Index)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MyComplexDataType {<br>&gt;&gt;&gt;     var __collection_count : Int {<br>&gt;&gt;&gt;         // This is quite a complex operation which we’d rather leave inside the type, otherwise we’d need to expose a bunch of implementation details internally<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;    var __internal_count : Int {<br>&gt;&gt;&gt;        // Again, best left here<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct CollectionView  : Collection {<br>&gt;&gt;&gt;        init(parent: MyComplexDataType) { … }<br>&gt;&gt;&gt;         var count { return parent.__collection_count }<br>&gt;&gt;&gt;         // ...etc<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   struct InternalStructure : InternalStructureView {<br>&gt;&gt;&gt;       init(parent: MyComplexDataType) { … }<br>&gt;&gt;&gt;       var count { return parent.__internal_count }<br>&gt;&gt;&gt;       // ...etc<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var collection : CollectionView { return CollectionView(self) }<br>&gt;&gt;&gt;   var internalStructure : InternalStructure { return InternalStructure(self) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is basically what String does (except that it wants to conform to Collection multiple times with different indexes and results). It’s a lot of work to maintain, especially if you have evolving protocols that are conformed to in several places.<br>&gt;&gt;&gt; We should have a better solution. We should be able to define:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “protocol UTF8Collection : Collection {}<br>&gt;&gt;&gt;  protocol UTF16Collection : Collection {}”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and have String conform to both of them at the same time. At the same time, since we’re now being explicit about which protocol requirement is satisfied where - we should also be able to delegate our conformance, telling the compiler to dispatch any unimplemented methods to another object. For example, lets say you want to wrap a Collection and observe mutations to it; you might override replaceSubrange(), but every other method (such as count, index(after:)… all the rest) is just a forwarding function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interestingly, we could do this safely (from a code legibility perspective) if we say that every scope which adds a conformance must completely satisfy its requirements, which we would more reasonably be able to require if we made this change (so your internal functions can still be wherever you like, but they won’t automatically satisfy a protocol requirement if they happen to have the same name). Then we could reasonably say that if you add an extension which adds a conformance to, say, Collection, you have to tell us where to find every one of its requirements. That’s where we could put the forwarding syntax for retroactive modelling. Stored properties can’t be defined in extensions, so if you want to back an implementation with one, you’ll need to make its conformance explicit in the main body (or we loosen that to at least extensions in the same file).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; // generates thunks to members of this extension in the base type; <br>&gt;&gt;&gt; // so MyComplexDataType.count —&gt; MyComplexDataType.InternalStructure.count,<br>&gt;&gt;&gt; // to account for conformance being added in later version. Can also be used for renamed protocols, and be tagged on individual members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @makeAvailable(as: _)<br>&gt;&gt;&gt; extension MyComplexDataType : InternalStructure {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    typealias Index = InternalIndexType<br>&gt;&gt;&gt;     var count : Int {<br>&gt;&gt;&gt;         // We have access to all of the private members because we’re inside MyComplexDataType<br>&gt;&gt;&gt;         // No need to pollute internal API with conformance implementation details.<br>&gt;&gt;&gt;         // Also, we get errors about non-conformance where we want them — where the implementation is.<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     func doInternalMagic(at: Index) {<br>&gt;&gt;&gt;        ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20 Sep 2016, at 23:46, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure I understand. What compiler or language support is missing for StringCore?<br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 16:42 Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On 20 Sep 2016, at 23:28, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have been following this discussion (as well as similar threads earlier this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It seems to me that the fundamental difference between classes and protocols is that classes inherit implementation whereas protocol conformance is a promise about interface.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When a class or struct or enum declares itself as conforming to a protocol, that means it has all the members specified in the protocol. The protocol conformance simply codifies a fact about the type itself: namely that all those members are present.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this model, any keyword such as `implements` on each conforming member would introduce substantial boilerplate for negligible gain. The purpose of a protocol is to communicate that certain members are available, not to make declaring those members more onerous.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, default implementations for protocols blur the line. Now there is actual implementation being inherited. A conforming type may choose to roll its own version of a method, or to utilize the default provided by the protocol. This is closer to the situation with subclassing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define (or redefine!) default implementations for members of that other protocol. This can create “inheritance chains” of protocol default implementations. I think there is value in being able to refer to (and call) the inherited default implementation through some sort of `super` functionality.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, the existence of a default implementation in a protocol is in large part merely a convenience: a courtesy so that each conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A type which conforms to a protocol may accept the default or it may provide its own implementation, but it is not “overriding” anything. The default implementation was offered as a convenience, to be taken or left as needed. Thus I do not think any keyword (neither `override` nor `implements`) should be required in that case either.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The frequently-raised point regarding near-miss member names deserves some attention. Several people have expressed a desire for the compiler to assist them in determining whether a given member does or does not meet a protocol requirement. Specifically, when a type conforms to a protocol with a default implementation, and the type defines a member with a similar signature, it is not obvious at glance if that member matches the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this is a job for linters and IDEs. For example, syntax highlighting could distinguish members which satisfy a protocol requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A protocol describes an interface and provides a set of customization points. It may also, as a convenience, offer default implementations. The protocol simply describes the capabilities of its conforming types, and any default implementations are there to make things easier for them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; As I mentioned above, I agree that better diagnostics for near-misses are necessary, but they are possible without new syntax. There is no win in avoiding unintentional behavior because, without a default implementation, these issues are caught at compile time already.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;&gt;&gt;&gt;&gt; suggestion) in protocol extension also just for the same reasons - be clear<br>&gt;&gt;&gt;&gt;&gt;&gt; about our intention regarding implementing the requirement, to show that<br>&gt;&gt;&gt;&gt;&gt;&gt; this func *depends* on the previous definition of P protocol and to avoid<br>&gt;&gt;&gt;&gt;&gt;&gt; possible mistakes related to protocol conformance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting point, IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; However, I think it could be improved in one key respect where previous<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed `implement`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is because, if<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be no default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to change or<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...} // no default implementation *at the moment of writing*,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; no need in `overload`<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Now, you adds SomeClass.swift file to your project and in some *other*<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; file you write:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; extension SomeProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func foo() {...}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you suggest in this<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and will save<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; implementation is involved. Consider:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; We will get an error here that S does not conform to P. However, this is<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; not the correct error, since S in fact *tries* to conform to P, but it has<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; a mistake in a method signature. This misleads us as to the true nature of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; the problem, and if S has enough members in it that we fail to spot the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; existing foo(), we might solve the problem by reimplementing foo(), and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; leaving the original foo() as dangling dead code. Having an ‘implement’<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; keyword on the existing foo() function would change the compiler error to<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; let us know that we have an existing foo() that is incorrectly declared.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; In addition, ‘implement’ can help us when the declaration in question *is*<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; the default implementation:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Here we will get an error with the proposed ‘implement’ keyword, because<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; foo() does not have a signature matching anything in the protocol, whereas<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; dangling function that would never be used, and then pass the buck to the<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; concrete type that implements P:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension P {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a common thing, so you want it to be easy to remember.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;&gt;&gt;     var aVariable : Int<br>&gt;&gt;&gt;&gt;&gt;     func aFunction()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;&gt;&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is consistent with how we refer to other members of types (e.g. “extension MyClass.MyInternalClass”). It will be easy for autocompletion to provide good suggestions, too.<br>&gt;&gt;&gt;&gt;&gt; As I see it, the only problem is what if `MyClass` wants its own function called `aFunction()`? What if the same name satisfies 2 protocols, which do you write?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The way to solve all of the problems in a consistent way is to make the function actually called “MyProto.aFunction”, and for it to be a separate function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe it is crucial to protocols that we can do this. Maybe I have some complex data structure and it has its own API, but I want people to be able to view it as a Collection. By conforming to Collection, I reserve lots of keywords and indexing operations which I now can’t use in my own API. Maybe I’m just providing Collection as a convenience to work with generic algorithms, but my own API has more efficient semantics for some operations. We’re relegated to using less-obvious and legible names in order to avoid conflicts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have a way to work around this, which String uses - create a struct which references your object and calls internal methods such as “_collection_count” so you can have separate interfaces. This adds up to quite a lot of boilerplate and maintenance overhead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also to add here: you’re basically implementing what I’m proposing manually if you do this; only you don’t get language/compiler support.<br>&gt;&gt;&gt;&gt; String basically does this - it shares StringCore with UTF8View and defines some internal functions to support it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The String views could then be made in to protocols on String, turning “UTF8View” in to “UTF8Representable”, and opening up algorithms which can work on generic sequences of UTF8 bytes. I think that’s pretty cool, and could open up better integration with other types which are (for example) UTF8Representable — for example a stream of UTF8 bytes (depending on how flexible implementation allows us to make the protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t agree that Protocol conformances are kind-of incidental, as others here have written. This isn’t like Objective-C where anything that has the correctly-named methods conforms. Protocol conformances are completely explicit, and in fact we have empty protocols (“marker protocols”) for exactly that purpose. I think it is consistent that we make every member of a conformance specify which protocol it belongs to, and to have its name scoped to that protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/09690231/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 27, 2016 at 07:00:00am</p></header><div class="content"><p>on Tue Sep 27 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br></p><p>&gt; While this solves the problem of overlapping names with different<br>&gt; semantics, how would you express the case where the names actually<br>&gt; have the same semantics, so that you only want to have one<br>&gt; implementor?<br>&gt;<br>&gt; protocol A {<br>&gt; 	func specficSemantics()<br>&gt; 	func sameSemantics()<br>&gt; }<br>&gt;<br>&gt; protocol B {<br>&gt; 	func specficSemantics()<br>&gt; 	func sameSemantics()<br>&gt; }<br>&gt;<br>&gt; struct C : A, B {<br>&gt; 	// these implementations have to be specific for A and B so Karl’s approach allows to differentiate them <br>&gt; 	func A.specficSemantics() { … }<br>&gt; 	func B.specficSemantics() { … }<br>&gt;<br>&gt; 	// this implementation should be shared by A and B because both share the same semantic here<br>&gt; 	func sameSemantics() { … } // ??<br>&gt;<br>&gt; 	// would I have to write it like that (manual delegation to the shared implementation)?<br>&gt; 	func sameSemantics() { … }<br>&gt; 	func A.sameSemantics() { sameSemantics() }<br>&gt; 	func B.sameSemantics() { sameSemantics() }<br>&gt; }<br>&gt;<br>&gt; -Thorsten<br></p><p>The cases where you find these kinds of exact collisions are so rare (never in my<br>career) that it&#39;s fine if some manual work is needed.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September 27, 2016 at 02:00:00pm</p></header><div class="content"><p>I agree with that. I believe I have more often run into name collisions for<br>protocols with differing semantics then matching semantics. Actually far<br>more often then both I have purposely used somewhat contrived naming in<br>protocols to avoid collisions, if that can be avoided by leveraging the<br>implicit namespacing that exists in the protocol&#39;s name; it would be nice<br>language feature IMHO.<br>On Tue, Sep 27, 2016 at 7:51 AM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Sep 27 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;<br>&gt; &gt; While this solves the problem of overlapping names with different<br>&gt; &gt; semantics, how would you express the case where the names actually<br>&gt; &gt; have the same semantics, so that you only want to have one<br>&gt; &gt; implementor?<br>&gt; &gt;<br>&gt; &gt; protocol A {<br>&gt; &gt;       func specficSemantics()<br>&gt; &gt;       func sameSemantics()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; protocol B {<br>&gt; &gt;       func specficSemantics()<br>&gt; &gt;       func sameSemantics()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; struct C : A, B {<br>&gt; &gt;       // these implementations have to be specific for A and B so Karl’s<br>&gt; approach allows to differentiate them<br>&gt; &gt;       func A.specficSemantics() { … }<br>&gt; &gt;       func B.specficSemantics() { … }<br>&gt; &gt;<br>&gt; &gt;       // this implementation should be shared by A and B because both<br>&gt; share the same semantic here<br>&gt; &gt;       func sameSemantics() { … } // ??<br>&gt; &gt;<br>&gt; &gt;       // would I have to write it like that (manual delegation to the<br>&gt; shared implementation)?<br>&gt; &gt;       func sameSemantics() { … }<br>&gt; &gt;       func A.sameSemantics() { sameSemantics() }<br>&gt; &gt;       func B.sameSemantics() { sameSemantics() }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -Thorsten<br>&gt;<br>&gt; The cases where you find these kinds of exact collisions are so rare<br>&gt; (never in my<br>&gt; career) that it&#39;s fine if some manual work is needed.<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/88af576b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>September 27, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Am 2016-09-27 16:51, schrieb Dave Abrahams via swift-evolution:<br>&gt; The cases where you find these kinds of exact collisions are so rare<br>&gt; (never in my career) that it&#39;s fine if some manual work is needed.<br></p><p>I agree that such accidental collisions are quite rare (especially with <br>the Swift way of naming methods which makes it quite easy to describe <br>the semantics of the function).<br></p><p>However, I draw some other conclusion from it: I don&#39;t see why I should <br>have to explicitly name the protocol in my methods. The method name is <br>enough already to match it to the protocol.<br></p><p>We shouldn&#39;t complicate our language just for obscure cases where <br>protocols accidentally collide.<br></p><p>-- <br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>September 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Well it just doesn&#39;t help with collisions it helps with signature changes<br>in a protocol going missed in conformers in a much more reliable way.<br></p><p>On Tue, Sep 27, 2016 at 8:11 AM Martin Waitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; Am 2016-09-27 16:51, schrieb Dave Abrahams via swift-evolution:<br>&gt; &gt; The cases where you find these kinds of exact collisions are so rare<br>&gt; &gt; (never in my career) that it&#39;s fine if some manual work is needed.<br>&gt;<br>&gt; I agree that such accidental collisions are quite rare (especially with<br>&gt; the Swift way of naming methods which makes it quite easy to describe<br>&gt; the semantics of the function).<br>&gt;<br>&gt; However, I draw some other conclusion from it: I don&#39;t see why I should<br>&gt; have to explicitly name the protocol in my methods. The method name is<br>&gt; enough already to match it to the protocol.<br>&gt;<br>&gt; We shouldn&#39;t complicate our language just for obscure cases where<br>&gt; protocols accidentally collide.<br>&gt;<br>&gt; --<br>&gt; Martin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/216b5eca/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>September 27, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi again,<br></p><p>&gt; Am 2016-09-27 16:51, schrieb Dave Abrahams via swift-evolution:<br>&gt;&gt; The cases where you find these kinds of exact collisions are so rare<br>&gt;&gt; (never in my career) that it&#39;s fine if some manual work is needed.<br>&gt; <br>&gt; I agree that such accidental collisions are quite rare (especially<br>&gt; with the Swift way of naming methods which makes it quite easy to<br>&gt; describe the semantics of the function).<br></p><p>oh, sorry, I misread your statement.<br></p><p>-- <br>Martin<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Tue Sep 27 2016, Martin Waitz &lt;tali-AT-admingilde.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; Am 2016-09-27 16:51, schrieb Dave Abrahams via swift-evolution:<br>&gt;&gt; The cases where you find these kinds of exact collisions are so rare<br>&gt;&gt; (never in my career) that it&#39;s fine if some manual work is needed.<br>&gt;<br>&gt; I agree that such accidental collisions are quite rare (especially<br>&gt; with the Swift way of naming methods which makes it quite easy to<br>&gt; describe the semantics of the function).<br>&gt;<br>&gt; However, I draw some other conclusion from it: I don&#39;t see why I<br>&gt; should have to explicitly name the protocol in my methods. The method<br>&gt; name is enough already to match it to the protocol.<br></p><p>I draw the same conclusion.  It should maybe be available as a backdoor<br>mechanism for handling those rare cases, but not a requirement.<br></p><p>&gt; We shouldn&#39;t complicate our language just for obscure cases where<br>&gt; protocols accidentally collide.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 21, 2016 at 01:00:00am</p></header><div class="content"><p>On 21.09.2016 0:28, Karl via swift-evolution wrote:<br>&gt;<br></p><p>I don&#39;t understand. Do you feel that this:<br></p><p>class MyClass : MyProto {<br>     var MyProto.aVariable : Int<br>     func MyProto.aFunction() { … }<br>}<br></p><p>better than this:<br></p><p>class MyClass : MyProto {<br>     implement var aVariable : Int<br>     implement func aFunction() { … }<br>}<br></p><p>?<br></p><p>&gt;&gt; On 20 Sep 2016, at 18:43, Nevin Brackett-Rozinsky via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I have been following this discussion (as well as similar threads earlier<br>&gt;&gt; this year) and listening to the ideas put forth by all sides.<br>&gt;&gt;<br>&gt;&gt; It seems to me that the fundamental difference between classes and<br>&gt;&gt; protocols is that classes inherit implementation whereas protocol<br>&gt;&gt; conformance is a promise about interface.<br>&gt;&gt;<br>&gt;&gt; When a class or struct or enum declares itself as conforming to a<br>&gt;&gt; protocol, that means it has all the members specified in the protocol.<br>&gt;&gt; The protocol conformance simply codifies a fact about the type itself:<br>&gt;&gt; namely that all those members are present.<br>&gt;&gt;<br>&gt;&gt; In this model, any keyword such as `implements` on each conforming member<br>&gt;&gt; would introduce substantial boilerplate for negligible gain. The purpose<br>&gt;&gt; of a protocol is to communicate that certain members are available, not<br>&gt;&gt; to make declaring those members more onerous.<br>&gt;&gt;<br>&gt;&gt; However, default implementations for protocols blur the line. Now there<br>&gt;&gt; is actual implementation being inherited. A conforming type may choose to<br>&gt;&gt; roll its own version of a method, or to utilize the default provided by<br>&gt;&gt; the protocol. This is closer to the situation with subclassing.<br>&gt;&gt;<br>&gt;&gt; Moreover, a protocol which conforms to another protocol may itself define<br>&gt;&gt; (or redefine!) default implementations for members of that other<br>&gt;&gt; protocol. This can create “inheritance chains” of protocol default<br>&gt;&gt; implementations. I think there is value in being able to refer to (and<br>&gt;&gt; call) the inherited default implementation through some sort of `super`<br>&gt;&gt; functionality.<br>&gt;&gt;<br>&gt;&gt; On the other hand, the existence of a default implementation in a<br>&gt;&gt; protocol is in large part merely a convenience: a courtesy so that each<br>&gt;&gt; conforming type need not rewrite the same boilerplate code.<br>&gt;&gt;<br>&gt;&gt; A type which conforms to a protocol may accept the default or it may<br>&gt;&gt; provide its own implementation, but it is not “overriding” anything. The<br>&gt;&gt; default implementation was offered as a convenience, to be taken or left<br>&gt;&gt; as needed. Thus I do not think any keyword (neither `override` nor<br>&gt;&gt; `implements`) should be required in that case either.<br>&gt;&gt;<br>&gt;&gt; The frequently-raised point regarding near-miss member names deserves<br>&gt;&gt; some attention. Several people have expressed a desire for the compiler<br>&gt;&gt; to assist them in determining whether a given member does or does not<br>&gt;&gt; meet a protocol requirement. Specifically, when a type conforms to a<br>&gt;&gt; protocol with a default implementation, and the type defines a member<br>&gt;&gt; with a similar signature, it is not obvious at glance if that member<br>&gt;&gt; matches the protocol.<br>&gt;&gt;<br>&gt;&gt; I think this is a job for linters and IDEs. For example, syntax<br>&gt;&gt; highlighting could distinguish members which satisfy a protocol<br>&gt;&gt; requirement, thereby providing immediate visual confirmation of success.<br>&gt;&gt;<br>&gt;&gt; Having followed the lengthy discussion and weighed the numerous ideas put<br>&gt;&gt; forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;&gt;<br>&gt;&gt; A protocol describes an interface and provides a set of customization<br>&gt;&gt; points. It may also, as a convenience, offer default implementations. The<br>&gt;&gt; protocol simply describes the capabilities of its conforming types, and<br>&gt;&gt; any default implementations are there to make things easier for them.<br>&gt;&gt;<br>&gt;&gt; Conforming types should not be afflicted with extraneous keywords: that<br>&gt;&gt; would run contrary to the purpose of having protocols in the first place.<br>&gt;&gt;<br>&gt;&gt; Nevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     As I mentioned above, I agree that better diagnostics for near-misses<br>&gt;&gt;     are necessary, but they are possible without new syntax. There is no<br>&gt;&gt;     win in avoiding unintentional behavior because, without a default<br>&gt;&gt;     implementation, these issues are caught at compile time already.<br>&gt;&gt;<br>&gt;&gt;     On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;          &gt; extension P {<br>&gt;&gt;          &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;          &gt; }<br>&gt;&gt;<br>&gt;&gt;         Yes, it seems like we need `implement` (or `override` as another<br>&gt;&gt;         suggestion) in protocol extension also just for the same reasons<br>&gt;&gt;         - be clear<br>&gt;&gt;         about our intention regarding implementing the requirement, to<br>&gt;&gt;         show that<br>&gt;&gt;         this func *depends* on the previous definition of P protocol and<br>&gt;&gt;         to avoid<br>&gt;&gt;         possible mistakes related to protocol conformance.<br>&gt;&gt;<br>&gt;&gt;         On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;&gt;         &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;&gt;         &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;         &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting<br>&gt;&gt;         point, IMO.<br>&gt;&gt;         &gt;&gt;&gt;<br>&gt;&gt;         &gt;&gt;&gt; However, I think it could be improved in one key respect<br>&gt;&gt;         where previous<br>&gt;&gt;         &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;&gt;         `implement`<br>&gt;&gt;         &gt;&gt;&gt; keyword adds no additional safety when a type implements a<br>&gt;&gt;         protocol<br>&gt;&gt;         &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This<br>&gt;&gt;         is because, if<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be<br>&gt;&gt;         no default<br>&gt;&gt;         &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;&gt;         &gt;&gt; compilation* such default implementation could appear.<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to<br>&gt;&gt;         change or<br>&gt;&gt;         &gt;&gt; changes are not allowed. Content:<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; public protocol SomeProtocol {<br>&gt;&gt;         &gt;&gt; func foo()<br>&gt;&gt;         &gt;&gt; }<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;&gt;         &gt;&gt; func foo() {...} // no default implementation *at the moment<br>&gt;&gt;         of writing*,<br>&gt;&gt;         &gt;&gt; no need in `overload`<br>&gt;&gt;         &gt;&gt; }<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; Now, you adds SomeClass.swift file to your project and in some<br>&gt;&gt;         *other*<br>&gt;&gt;         &gt;&gt; file you write:<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; extension SomeProtocol {<br>&gt;&gt;         &gt;&gt; func foo() {...}<br>&gt;&gt;         &gt;&gt; }<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you<br>&gt;&gt;         suggest in this<br>&gt;&gt;         &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;&gt;         &gt;&gt;<br>&gt;&gt;         &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and<br>&gt;&gt;         will save<br>&gt;&gt;         &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;&gt;         &gt; implementation is involved. Consider:<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; protocol P {<br>&gt;&gt;         &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;         &gt; }<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; struct S : P {<br>&gt;&gt;         &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;         &gt; }<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; We will get an error here that S does not conform to P.<br>&gt;&gt;         However, this is<br>&gt;&gt;         &gt; not the correct error, since S in fact *tries* to conform to P,<br>&gt;&gt;         but it has<br>&gt;&gt;         &gt; a mistake in a method signature. This misleads us as to the<br>&gt;&gt;         true nature of<br>&gt;&gt;         &gt; the problem, and if S has enough members in it that we fail to<br>&gt;&gt;         spot the<br>&gt;&gt;         &gt; existing foo(), we might solve the problem by reimplementing<br>&gt;&gt;         foo(), and<br>&gt;&gt;         &gt; leaving the original foo() as dangling dead code. Having an<br>&gt;&gt;         ‘implement’<br>&gt;&gt;         &gt; keyword on the existing foo() function would change the<br>&gt;&gt;         compiler error to<br>&gt;&gt;         &gt; let us know that we have an existing foo() that is incorrectly<br>&gt;&gt;         declared.<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; In addition, ‘implement’ can help us when the declaration in<br>&gt;&gt;         question *is*<br>&gt;&gt;         &gt; the default implementation:<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; protocol P {<br>&gt;&gt;         &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;         &gt; }<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; extension P {<br>&gt;&gt;         &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;&gt;         &gt; }<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; Here we will get an error with the proposed ‘implement’<br>&gt;&gt;         keyword, because<br>&gt;&gt;         &gt; foo() does not have a signature matching anything in the<br>&gt;&gt;         protocol, whereas<br>&gt;&gt;         &gt; without ‘implement’ we would happily and silently generate a<br>&gt;&gt;         useless<br>&gt;&gt;         &gt; dangling function that would never be used, and then pass the<br>&gt;&gt;         buck to the<br>&gt;&gt;         &gt; concrete type that implements P:<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; protocol P {<br>&gt;&gt;         &gt; func foo() -&gt; [String : Any]<br>&gt;&gt;         &gt; }<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; extension P {<br>&gt;&gt;         &gt; func foo() -&gt; [String : String] { return [:] } // The error is<br>&gt;&gt;         here:<br>&gt;&gt;         &gt; }<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; struct S : P {} // But it gets reported here.<br>&gt;&gt;         &gt;<br>&gt;&gt;         &gt; Charles<br>&gt;&gt;         &gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I agree that a new keyword is unwanted. Conforming to protocols is quite a<br>&gt; common thing, so you want it to be easy to remember.<br>&gt;<br>&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;     var aVariable : Int<br>&gt;     func aFunction()<br>&gt; }<br>&gt; class MyClass : MyProto {<br>&gt;     var MyProto.aVariable : Int<br>&gt;     func MyProto.aFunction() { … }<br>&gt; }<br>&gt;<br>&gt; This is consistent with how we refer to other members of types (e.g.<br>&gt; “extension MyClass.MyInternalClass”). It will be easy for autocompletion to<br>&gt; provide good suggestions, too.<br>&gt; As I see it, the only problem is what if `MyClass` wants its own function<br>&gt; called `aFunction()`? What if the same name satisfies 2 protocols, which do<br>&gt; you write?<br>&gt;<br>&gt; The way to solve all of the problems in a consistent way is to make the<br>&gt; function actually called “MyProto.aFunction”, and for it to be a separate<br>&gt; function from plain “aFunction()” or from “SomeotherProto.aFunction”.<br>&gt;<br>&gt; I believe it is crucial to protocols that we can do this. Maybe I have some<br>&gt; complex data structure and it has its own API, but I want people to be able<br>&gt; to view it as a Collection. By conforming to Collection, I reserve lots of<br>&gt; keywords and indexing operations which I now can’t use in my own API. Maybe<br>&gt; I’m just providing Collection as a convenience to work with generic<br>&gt; algorithms, but my own API has more efficient semantics for some<br>&gt; operations. We’re relegated to using less-obvious and legible names in<br>&gt; order to avoid conflicts.<br>&gt;<br>&gt; We have a way to work around this, which String uses - create a struct<br>&gt; which references your object and calls internal methods such as<br>&gt; “_collection_count” so you can have separate interfaces. This adds up to<br>&gt; quite a lot of boilerplate and maintenance overhead.<br>&gt;<br>&gt; I don’t agree that Protocol conformances are kind-of incidental, as others<br>&gt; here have written. This isn’t like Objective-C where anything that has the<br>&gt; correctly-named methods conforms. Protocol conformances are completely<br>&gt; explicit, and in fact we have empty protocols (“marker protocols”) for<br>&gt; exactly that purpose. I think it is consistent that we make every member of<br>&gt; a conformance specify which protocol it belongs to, and to have its name<br>&gt; scoped to that protocol.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;<br>&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 21, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 21 Sep 2016, at 00:08, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 21.09.2016 0:28, Karl via swift-evolution wrote:<br>&gt;&gt; <br>&gt; <br>&gt; I don&#39;t understand. Do you feel that this:<br>&gt; <br>&gt; class MyClass : MyProto {<br>&gt;    var MyProto.aVariable : Int<br>&gt;    func MyProto.aFunction() { … }<br>&gt; }<br>&gt; <br>&gt; better than this:<br>&gt; <br>&gt; class MyClass : MyProto {<br>&gt;    implement var aVariable : Int<br>&gt;    implement func aFunction() { … }<br>&gt; }<br>&gt; <br>&gt; ?<br></p><p>Yes, because “implement” doesn’t say anything. It would need to be “implements &lt;ProtocolName&gt;” to be useful to a person or to the type-checker. <br></p><p>At that point, why not just say MyProtocol.aVariable? It feels more natural IMO.<br></p><p>And then the rest kind of snowballs from there...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/0dcc6edf/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 20, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br></p><p>&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;     var aVariable : Int<br>&gt;     func aFunction()<br>&gt; }<br>&gt; class MyClass : MyProto {<br>&gt;     var MyProto.aVariable : Int<br>&gt;     func MyProto.aFunction() { … }<br>&gt; }<br>...<br>&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br></p><p>I generally agree with Doug.  The canonical way to indicate “this<br>method/property/type implements a requirement of protocol P” should be<br>to define the entity in an extension that also adds conformance to P.<br>If that&#39;s inadequate indication in some way we should find a way to<br>enhance it.  I wouldn&#39;t mind the notation above, but only as a fallback,<br>not a reuquirement.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 21, 2016 at 02:00:00pm</p></header><div class="content"><p>On 21.09.2016 2:34, Dave Abrahams via swift-evolution wrote:<br>&gt;<br>&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;<br>&gt;&gt; protocol MyProto {<br>&gt;&gt;     var aVariable : Int<br>&gt;&gt;     func aFunction()<br>&gt;&gt; }<br>&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;     var MyProto.aVariable : Int<br>&gt;&gt;     func MyProto.aFunction() { … }<br>&gt;&gt; }<br>&gt; ...<br>&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;<br>&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt; method/property/type implements a requirement of protocol P” should be<br>&gt; to define the entity in an extension that also adds conformance to P.<br></p><p>Could you clarify, how do you see a solution in case extension can&#39;t have <br>stored properties? So, if protocol has such requirement(i.e. we want to <br>implement the protocol requirement as stored property) we can&#39;t move it to <br>extension.<br>Do you expect we&#39;ll have stored props in extension in near future?<br></p><p>Also, what about protocol extensions? What do you suggest to mark default <br>implementation method here to express intention and to separate default <br>implementation (that depends on protocol definition and so, IMO compiler <br>should help us if protocol definition changed) from just helper methods in <br>protocol extension? Like here:<br></p><p>protocol A {<br>     func foov()<br>}<br></p><p>protocol B : A {<br>}<br></p><p>extension A {<br>     func foov() {}<br>}<br></p><p>extension B {<br>     // I was expecting this is a default implementation of foov() for B<br>     // but in reality this is a helper method<br>     // who knows when this error will be detected<br>     func foow() {}<br>}<br></p><p>&gt; If that&#39;s inadequate indication in some way we should find a way to<br>&gt; enhance it.  I wouldn&#39;t mind the notation above, but only as a fallback,<br>&gt; not a reuquirement.<br>&gt;<br></p><p>Could you share your opinion (and probably some common opinion of the core <br>team) regarding `implement`(or `override`) keyword requirement for <br>methods/props in type declared exactly to implement protocol&#39;s requirements?<br></p><p>Don&#39;t you feel that if Swift will not *require* this, we&#39;ll have fragile <br>code base as, even if *I* can use linter for this, 3rd party source code <br>that will be in my project probably will not use the &quot;safe&quot; method of <br>protocol conformance?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>September 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt; <br>&gt;&gt; protocol MyProto {<br>&gt;&gt;    var aVariable : Int<br>&gt;&gt;    func aFunction()<br>&gt;&gt; }<br>&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;    var MyProto.aVariable : Int<br>&gt;&gt;    func MyProto.aFunction() { … }<br>&gt;&gt; }<br>&gt; ...<br>&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt; <br>&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt; method/property/type implements a requirement of protocol P” should be<br>&gt; to define the entity in an extension that also adds conformance to P.<br>&gt; If that&#39;s inadequate indication in some way we should find a way to<br>&gt; enhance it.  I wouldn&#39;t mind the notation above, but only as a fallback,<br>&gt; not a reuquirement.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br></p><p>Indeed this is exactly how C# handles Interfaces (protocols). The default is the exact same way Swift works - by matching names. If there is a collision you specify Protocol.memberName. Its simple and in the years I was writing C# code it was flexible enough to cover most reasonable scenarios, without adding a bunch of boilerplate.<br></p><p>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 22, 2016 at 07:00:00am</p></header><div class="content"><p>I would like to make it a requirement if not inside a protocol extension which declares a conformance, and actually build the protocol name in to the member in an ABI-breaking way. We could make it additive by generating forwarding thunks from the old symbols to the new ones, but it would be better if we could just solve the overlapping-members problem before then.<br></p><p>That would mean you never get collisions between protocol members. There’s loads of amazing stuff we can do with that ability, and ways we can extend it to reduce a lot of boilerplate that occurs when you want to have multiple representations of the same data (String is just an example).<br></p><p>I don’t really care about the syntax we need to make it liveable. We could automatically insert the protocol names for unambiguous members at call-site, or something else.<br></p><p>This thread was originally about making the *syntax* a requirement; I agree with that, and I would actually take it one (or several) steps further, solving other problems along the way.<br></p><p>&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;   var aVariable : Int<br>&gt;&gt;&gt;   func aFunction()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;   var MyProto.aVariable : Int<br>&gt;&gt;&gt;   func MyProto.aFunction() { … }<br>&gt;&gt;&gt; }<br>&gt;&gt; ...<br>&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt; <br>&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt; method/property/type implements a requirement of protocol P” should be<br>&gt;&gt; to define the entity in an extension that also adds conformance to P.<br>&gt;&gt; If that&#39;s inadequate indication in some way we should find a way to<br>&gt;&gt; enhance it.  I wouldn&#39;t mind the notation above, but only as a fallback,<br>&gt;&gt; not a reuquirement.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt; <br>&gt; Indeed this is exactly how C# handles Interfaces (protocols). The default is the exact same way Swift works - by matching names. If there is a collision you specify Protocol.memberName. Its simple and in the years I was writing C# code it was flexible enough to cover most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt; <br>&gt; Russ<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>September 22, 2016 at 10:00:00am</p></header><div class="content"><p>I watched this thread with a lot of attention, starting neutral. You must say that Karl won me over. His proposal would make Swift more expressive, and less error prone in cases of protocol conformance with name collisions. I am at this point +1<br></p><p>Jean-Denis<br></p><p>Sent from my iPhone<br></p><p>&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like to make it a requirement if not inside a protocol extension which declares a conformance, and actually build the protocol name in to the member in an ABI-breaking way. We could make it additive by generating forwarding thunks from the old symbols to the new ones, but it would be better if we could just solve the overlapping-members problem before then.<br>&gt; <br>&gt; That would mean you never get collisions between protocol members. There’s loads of amazing stuff we can do with that ability, and ways we can extend it to reduce a lot of boilerplate that occurs when you want to have multiple representations of the same data (String is just an example).<br>&gt; <br>&gt; I don’t really care about the syntax we need to make it liveable. We could automatically insert the protocol names for unambiguous members at call-site, or something else.<br>&gt; <br>&gt; This thread was originally about making the *syntax* a requirement; I agree with that, and I would actually take it one (or several) steps further, solving other problems along the way.<br>&gt; <br>&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol, e.g:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;&gt;  var aVariable : Int<br>&gt;&gt;&gt;&gt;  func aFunction()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; class MyClass : MyProto {<br>&gt;&gt;&gt;&gt;  var MyProto.aVariable : Int<br>&gt;&gt;&gt;&gt;  func MyProto.aFunction() { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of protocols<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt; method/property/type implements a requirement of protocol P” should be<br>&gt;&gt;&gt; to define the entity in an extension that also adds conformance to P.<br>&gt;&gt;&gt; If that&#39;s inadequate indication in some way we should find a way to<br>&gt;&gt;&gt; enhance it.  I wouldn&#39;t mind the notation above, but only as a fallback,<br>&gt;&gt;&gt; not a reuquirement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; <br>&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The default is the exact same way Swift works - by matching names. If there is a collision you specify Protocol.memberName. Its simple and in the years I was writing C# code it was flexible enough to cover most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt; name collisions. I am at this point +1<br></p><p>Actually I also support Karl&#39;s suggestion in general. It is trying to solve <br>IMO important problems and make Swift&#39;s protocol programming safer and less <br>fragile. Also it adds new interested features for working with protocols.<br></p><p>But in reality, I don&#39;t feel like his suggestion could be accepted by core <br>team and community and even if it could be supported, it seems for me that <br>*implementation* of his proposal requires a huge amount of time and big <br>changes in how Swift is working currently. (Probably some one who knows <br>Swift internals could comment regarding this)<br>So, theoretically we&#39;d have these improvements not in near future and I <br>think the problem discussed is very important to be addressed in Swift as <br>soon as possible.<br>I base my opinion also on previous discussions regarding similar subjects.<br></p><p>My suggestion regarding a marker for protocol implementation method/prop in <br>type - solves most of the addressed problems with protocol conformance and <br>with fragile of such conformance, and adds one new keyword (or even zero - <br>right now I think the `override` is better choice for such &quot;marker&quot;). I <br>believe this proposal could be implemented with much less amount of work <br>and with less changes to current internals of Swift and to current code <br>base, and so we can have such a big improvement in Swift soon. So my <br>intention was to suggest solution that can dramatically improve Swift&#39;s <br>protocol programming with &quot;small&quot; amount of changes for compiler(internals) <br>and for existed sources.<br></p><p>But it seems like the direction chosen by the core team and supported by <br>many in community - is just a warning if extension conforming type to <br>protocol contains unrelated to that protocol methods/props. I see that this <br>solution can improve protocol programming in some areas, but does not <br>address some IMO important issues we discussed in the thread :<br></p><p>* Currently extension can not have stored properties. So, if we want to <br>implement protocol&#39;s props as stored properties - we can&#39;t move them to <br>extension. So to implement this soulution - we need stored properties in <br>extensions. It is not clear if and when they are expected.<br></p><p>* This solution will not require the safety(regarding protocol conformance) <br>from a developer, it will only inform and only if protocol conformance <br>defined in extension. So, when you use 3rd party source code - your project <br>will not be protected for the discussed problems.<br></p><p>* To write safe code I can&#39;t group methods/props as I want, I have to <br>declare a number of extensions per-protocol (in case my type conforms to a <br>number of protocols)<br></p><p>* This solution does not solve problem of near-miss signature of method <br>definition in protocol extension like here:<br>protocol A { func foo() }<br>protocol B : A {}<br>extension A { func foo() }<br>extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&quot;my&quot; suggestion:<br>extension A { override func foo() }<br>extension B { override func foo() }<br></p><p>* Not clear how to write safe code with that approach if we implement <br>protocol requirement in derived class, but conformance was declared in base <br>(but not implemented) :<br>protocol P { func foo() }<br>extension P { func foo() }<br>class A : P {}<br>class B { func foo() } // we can&#39;t move this to extension, B already <br>conforms to P<br>, and in opposite to &quot;my&quot; `override` requirement for implementation, if `A` <br>will add its own foo() implementation - we&#39;ll have to change B&#39;s <br>definition(need to add `override` for B.foo )<br>&quot;my&quot; suggestion:<br>class B { override func foo() }<br></p><p><br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;<br>&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt; an example).<br>&gt;&gt;<br>&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt; at call-site, or something else.<br>&gt;&gt;<br>&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;<br>&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>September 23, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;d also say that one or two keywords are superior than the protocol naming approach in terms of implementation simplicity (for the core team).<br></p><p>My suggestions:<br></p><p>Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all properties/functions which implement a protocol (also in protocol extensions)<br></p><p>&quot;override&quot; should be used if a default implementation or a member of a superclass is overridden.<br></p><p>If you are overriding a default implementation of a protocol &quot;conform&quot; / &quot;implement&quot; is also required.<br></p><p>// Retroactive conformance (old behavior) but only in extensions<br>extension Foo: @retroactive Baz {<br>    // only some members of Baz are implemented here (they need the keywords)<br>    // the other members outside the extension don&#39;t need any additional keywords<br>    // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>}<br></p><p><br>Future directions:<br>&quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to disambiguate.<br></p><p>// reducing boilerplate<br>extension Foo: conform Bar {<br>    // These declarations can only implement Bar and don&#39;t need the &quot;conform&quot; keyword<br>}<br></p><p>Final question:<br>Should we also require a marker for implemented protocol members in the interface?:<br></p><p>protocol Foo {<br>    defaulted func foo()<br>}<br>extension Foo {<br>    implement func foo()<br>}<br></p><p><br>Best regards<br>Maximilian<br></p><p>&gt;&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt; name collisions. I am at this point +1<br>&gt; <br>&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to solve IMO important problems and make Swift&#39;s protocol programming safer and less fragile. Also it adds new interested features for working with protocols.<br>&gt; <br>&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by core team and community and even if it could be supported, it seems for me that *implementation* of his proposal requires a huge amount of time and big changes in how Swift is working currently. (Probably some one who knows Swift internals could comment regarding this)<br>&gt; So, theoretically we&#39;d have these improvements not in near future and I think the problem discussed is very important to be addressed in Swift as soon as possible.<br>&gt; I base my opinion also on previous discussions regarding similar subjects.<br>&gt; <br>&gt; My suggestion regarding a marker for protocol implementation method/prop in type - solves most of the addressed problems with protocol conformance and with fragile of such conformance, and adds one new keyword (or even zero - right now I think the `override` is better choice for such &quot;marker&quot;). I believe this proposal could be implemented with much less amount of work and with less changes to current internals of Swift and to current code base, and so we can have such a big improvement in Swift soon. So my intention was to suggest solution that can dramatically improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for compiler(internals) and for existed sources.<br>&gt; <br>&gt; But it seems like the direction chosen by the core team and supported by many in community - is just a warning if extension conforming type to protocol contains unrelated to that protocol methods/props. I see that this solution can improve protocol programming in some areas, but does not address some IMO important issues we discussed in the thread :<br>&gt; <br>&gt; * Currently extension can not have stored properties. So, if we want to implement protocol&#39;s props as stored properties - we can&#39;t move them to extension. So to implement this soulution - we need stored properties in extensions. It is not clear if and when they are expected.<br>&gt; <br>&gt; * This solution will not require the safety(regarding protocol conformance) from a developer, it will only inform and only if protocol conformance defined in extension. So, when you use 3rd party source code - your project will not be protected for the discussed problems.<br>&gt; <br>&gt; * To write safe code I can&#39;t group methods/props as I want, I have to declare a number of extensions per-protocol (in case my type conforms to a number of protocols)<br>&gt; <br>&gt; * This solution does not solve problem of near-miss signature of method definition in protocol extension like here:<br>&gt; protocol A { func foo() }<br>&gt; protocol B : A {}<br>&gt; extension A { func foo() }<br>&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt; &quot;my&quot; suggestion:<br>&gt; extension A { override func foo() }<br>&gt; extension B { override func foo() }<br>&gt; <br>&gt; * Not clear how to write safe code with that approach if we implement protocol requirement in derived class, but conformance was declared in base (but not implemented) :<br>&gt; protocol P { func foo() }<br>&gt; extension P { func foo() }<br>&gt; class A : P {}<br>&gt; class B { func foo() } // we can&#39;t move this to extension, B already conforms to P<br>&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s definition(need to add `override` for B.foo )<br>&gt; &quot;my&quot; suggestion:<br>&gt; class B { override func foo() }<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jean-Denis<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt; an example).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt; list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/2a70dae8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 23, 2016 at 01:00:00pm</p></header><div class="content"><p>On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt; I&#39;d also say that one or two keywords are superior than the protocol naming<br>&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;<br>&gt; My suggestions:<br>&gt;<br>&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt; properties/functions which implement a protocol (also in protocol extensions)<br>&gt;<br></p><p>&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt; superclass is overridden.<br></p><p>Maximilian, again, you *do not know* if the conformed protocol, that has no <br>default implementations *at the moment of your code writing* will or will <br>not have default implementations at the *moment of compilation*.<br>Consider this scenario:<br></p><p>Step 1. You got 3rd party source file for your project, and you don&#39;t <br>want/have no rights to change it, probably it is shared source used also in <br>other projects, that code contains:<br></p><p>protocol A { func foo() }<br></p><p>class B : A {<br>	conform func foo() {...}<br>}<br></p><p>all is OK with this code, no default implementation, B.foo marked with <br>`conform`.<br></p><p>Step 2. In your project in some of your files you decided to add default <br>implementation of protocol A:<br></p><p>extension A {<br>	implement func foo() {...}<br>}<br></p><p>Now, your project will not compile - B.foo() must me marked with &#39;override&#39; <br>as protocol `A` has default implementation of foo().<br>If you change `conform` to `override` in 3rd party source file, it will not <br>compile in some other project where no default implementation defined for <br>`A` protocol.<br></p><p>That is *why* I believe the `override` as requirement as marker for <br>protocol implementation method/prop is the best solution. See, in case <br>`override` will be required, the initial source file will be like this:<br></p><p>protocol A { func foo() }<br></p><p>class B : A {<br>	override func foo() {...} // implementation<br>}<br></p><p>and it will compile ok : if A has default implementation and if A has no <br>default implementation.<br></p><p>So, after you added default implementation in your project - no changes <br>should be made to that 3rd party source file.<br></p><p><br>&gt;<br>&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt; &quot;implement&quot; is also required.<br>&gt;<br>&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt; extension Foo: @retroactive Baz {<br>&gt;     // only some members of Baz are implemented here (they need the keywords)<br>&gt;     // the other members outside the extension don&#39;t need any additional<br>&gt; keywords<br>&gt;     // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt; }<br>&gt;<br>&gt;<br>&gt; *Future directions:*<br>&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to disambiguate.<br>&gt;<br>&gt; // reducing boilerplate<br>&gt; extension Foo: conform Bar {<br>&gt;     // These declarations can only implement Bar and don&#39;t need the<br>&gt; &quot;conform&quot; keyword<br>&gt; }<br>&gt;<br>&gt; *Final question:*<br>&gt; Should we also require a marker for implemented protocol members in the<br>&gt; interface?:<br>&gt;<br>&gt; protocol Foo {<br>&gt;     defaulted func foo()<br>&gt; }<br>&gt; extension Foo {<br>&gt;     implement func foo()<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Best regards<br>&gt; Maximilian<br>&gt;<br>&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt;&gt; name collisions. I am at this point +1<br>&gt;&gt;<br>&gt;&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to<br>&gt;&gt; solve IMO important problems and make Swift&#39;s protocol programming safer<br>&gt;&gt; and less fragile. Also it adds new interested features for working with<br>&gt;&gt; protocols.<br>&gt;&gt;<br>&gt;&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by<br>&gt;&gt; core team and community and even if it could be supported, it seems for<br>&gt;&gt; me that *implementation* of his proposal requires a huge amount of time<br>&gt;&gt; and big changes in how Swift is working currently. (Probably some one who<br>&gt;&gt; knows Swift internals could comment regarding this)<br>&gt;&gt; So, theoretically we&#39;d have these improvements not in near future and I<br>&gt;&gt; think the problem discussed is very important to be addressed in Swift as<br>&gt;&gt; soon as possible.<br>&gt;&gt; I base my opinion also on previous discussions regarding similar subjects.<br>&gt;&gt;<br>&gt;&gt; My suggestion regarding a marker for protocol implementation method/prop<br>&gt;&gt; in type - solves most of the addressed problems with protocol conformance<br>&gt;&gt; and with fragile of such conformance, and adds one new keyword (or even<br>&gt;&gt; zero - right now I think the `override` is better choice for such<br>&gt;&gt; &quot;marker&quot;). I believe this proposal could be implemented with much less<br>&gt;&gt; amount of work and with less changes to current internals of Swift and to<br>&gt;&gt; current code base, and so we can have such a big improvement in Swift<br>&gt;&gt; soon. So my intention was to suggest solution that can dramatically<br>&gt;&gt; improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for<br>&gt;&gt; compiler(internals) and for existed sources.<br>&gt;&gt;<br>&gt;&gt; But it seems like the direction chosen by the core team and supported by<br>&gt;&gt; many in community - is just a warning if extension conforming type to<br>&gt;&gt; protocol contains unrelated to that protocol methods/props. I see that<br>&gt;&gt; this solution can improve protocol programming in some areas, but does<br>&gt;&gt; not address some IMO important issues we discussed in the thread :<br>&gt;&gt;<br>&gt;&gt; * Currently extension can not have stored properties. So, if we want to<br>&gt;&gt; implement protocol&#39;s props as stored properties - we can&#39;t move them to<br>&gt;&gt; extension. So to implement this soulution - we need stored properties in<br>&gt;&gt; extensions. It is not clear if and when they are expected.<br>&gt;&gt;<br>&gt;&gt; * This solution will not require the safety(regarding protocol<br>&gt;&gt; conformance) from a developer, it will only inform and only if protocol<br>&gt;&gt; conformance defined in extension. So, when you use 3rd party source code<br>&gt;&gt; - your project will not be protected for the discussed problems.<br>&gt;&gt;<br>&gt;&gt; * To write safe code I can&#39;t group methods/props as I want, I have to<br>&gt;&gt; declare a number of extensions per-protocol (in case my type conforms to<br>&gt;&gt; a number of protocols)<br>&gt;&gt;<br>&gt;&gt; * This solution does not solve problem of near-miss signature of method<br>&gt;&gt; definition in protocol extension like here:<br>&gt;&gt; protocol A { func foo() }<br>&gt;&gt; protocol B : A {}<br>&gt;&gt; extension A { func foo() }<br>&gt;&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt; extension A { override func foo() }<br>&gt;&gt; extension B { override func foo() }<br>&gt;&gt;<br>&gt;&gt; * Not clear how to write safe code with that approach if we implement<br>&gt;&gt; protocol requirement in derived class, but conformance was declared in<br>&gt;&gt; base (but not implemented) :<br>&gt;&gt; protocol P { func foo() }<br>&gt;&gt; extension P { func foo() }<br>&gt;&gt; class A : P {}<br>&gt;&gt; class B { func foo() } // we can&#39;t move this to extension, B already<br>&gt;&gt; conforms to P<br>&gt;&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if<br>&gt;&gt; `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s<br>&gt;&gt; definition(need to add `override` for B.foo )<br>&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt; class B { override func foo() }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt;&gt; an example).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-AT-gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt; list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Note: Second attempt, first mail was rejected ?<br></p><p>That is correct Vladimir, at the point of writing an API you never know who will end up using it in which way.<br>Hence the decision which flavour (of a function) to call should not be made by the coder writing the API but by the coder using the API.<br>And that coder cannot claim not to know which flavour he wants.<br>Hence including the ‘override’ keyword is unnecessary. However having the ability to specifying which flavour must be called is necessary. And this ability is easy to accommodate within the current language rules. (casting or possibly having a dot-notation for this purpose)<br></p><p>Regards,<br>Rien.<br></p><p>&gt; On 23 Sep 2016, at 12:47, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt;&gt; I&#39;d also say that one or two keywords are superior than the protocol naming<br>&gt;&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;&gt; <br>&gt;&gt; My suggestions:<br>&gt;&gt; <br>&gt;&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt;&gt; properties/functions which implement a protocol (also in protocol extensions)<br>&gt;&gt; <br>&gt; <br>&gt;&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt;&gt; superclass is overridden.<br>&gt; <br>&gt; Maximilian, again, you *do not know* if the conformed protocol, that has no default implementations *at the moment of your code writing* will or will not have default implementations at the *moment of compilation*.<br>&gt; Consider this scenario:<br>&gt; <br>&gt; Step 1. You got 3rd party source file for your project, and you don&#39;t want/have no rights to change it, probably it is shared source used also in other projects, that code contains:<br>&gt; <br>&gt; protocol A { func foo() }<br>&gt; <br>&gt; class B : A {<br>&gt; 	conform func foo() {...}<br>&gt; }<br>&gt; <br>&gt; all is OK with this code, no default implementation, B.foo marked with `conform`.<br>&gt; <br>&gt; Step 2. In your project in some of your files you decided to add default implementation of protocol A:<br>&gt; <br>&gt; extension A {<br>&gt; 	implement func foo() {...}<br>&gt; }<br>&gt; <br>&gt; Now, your project will not compile - B.foo() must me marked with &#39;override&#39; as protocol `A` has default implementation of foo().<br>&gt; If you change `conform` to `override` in 3rd party source file, it will not compile in some other project where no default implementation defined for `A` protocol.<br>&gt; <br>&gt; That is *why* I believe the `override` as requirement as marker for protocol implementation method/prop is the best solution. See, in case `override` will be required, the initial source file will be like this:<br>&gt; <br>&gt; protocol A { func foo() }<br>&gt; <br>&gt; class B : A {<br>&gt; 	override func foo() {...} // implementation<br>&gt; }<br>&gt; <br>&gt; and it will compile ok : if A has default implementation and if A has no default implementation.<br>&gt; <br>&gt; So, after you added default implementation in your project - no changes should be made to that 3rd party source file.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt;&gt; &quot;implement&quot; is also required.<br>&gt;&gt; <br>&gt;&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt;&gt; extension Foo: @retroactive Baz {<br>&gt;&gt;    // only some members of Baz are implemented here (they need the keywords)<br>&gt;&gt;    // the other members outside the extension don&#39;t need any additional<br>&gt;&gt; keywords<br>&gt;&gt;    // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Future directions:*<br>&gt;&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to disambiguate.<br>&gt;&gt; <br>&gt;&gt; // reducing boilerplate<br>&gt;&gt; extension Foo: conform Bar {<br>&gt;&gt;    // These declarations can only implement Bar and don&#39;t need the<br>&gt;&gt; &quot;conform&quot; keyword<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; *Final question:*<br>&gt;&gt; Should we also require a marker for implemented protocol members in the<br>&gt;&gt; interface?:<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt;    defaulted func foo()<br>&gt;&gt; }<br>&gt;&gt; extension Foo {<br>&gt;&gt;    implement func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt;&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt;&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt;&gt;&gt; name collisions. I am at this point +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to<br>&gt;&gt;&gt; solve IMO important problems and make Swift&#39;s protocol programming safer<br>&gt;&gt;&gt; and less fragile. Also it adds new interested features for working with<br>&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by<br>&gt;&gt;&gt; core team and community and even if it could be supported, it seems for<br>&gt;&gt;&gt; me that *implementation* of his proposal requires a huge amount of time<br>&gt;&gt;&gt; and big changes in how Swift is working currently. (Probably some one who<br>&gt;&gt;&gt; knows Swift internals could comment regarding this)<br>&gt;&gt;&gt; So, theoretically we&#39;d have these improvements not in near future and I<br>&gt;&gt;&gt; think the problem discussed is very important to be addressed in Swift as<br>&gt;&gt;&gt; soon as possible.<br>&gt;&gt;&gt; I base my opinion also on previous discussions regarding similar subjects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My suggestion regarding a marker for protocol implementation method/prop<br>&gt;&gt;&gt; in type - solves most of the addressed problems with protocol conformance<br>&gt;&gt;&gt; and with fragile of such conformance, and adds one new keyword (or even<br>&gt;&gt;&gt; zero - right now I think the `override` is better choice for such<br>&gt;&gt;&gt; &quot;marker&quot;). I believe this proposal could be implemented with much less<br>&gt;&gt;&gt; amount of work and with less changes to current internals of Swift and to<br>&gt;&gt;&gt; current code base, and so we can have such a big improvement in Swift<br>&gt;&gt;&gt; soon. So my intention was to suggest solution that can dramatically<br>&gt;&gt;&gt; improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for<br>&gt;&gt;&gt; compiler(internals) and for existed sources.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it seems like the direction chosen by the core team and supported by<br>&gt;&gt;&gt; many in community - is just a warning if extension conforming type to<br>&gt;&gt;&gt; protocol contains unrelated to that protocol methods/props. I see that<br>&gt;&gt;&gt; this solution can improve protocol programming in some areas, but does<br>&gt;&gt;&gt; not address some IMO important issues we discussed in the thread :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Currently extension can not have stored properties. So, if we want to<br>&gt;&gt;&gt; implement protocol&#39;s props as stored properties - we can&#39;t move them to<br>&gt;&gt;&gt; extension. So to implement this soulution - we need stored properties in<br>&gt;&gt;&gt; extensions. It is not clear if and when they are expected.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * This solution will not require the safety(regarding protocol<br>&gt;&gt;&gt; conformance) from a developer, it will only inform and only if protocol<br>&gt;&gt;&gt; conformance defined in extension. So, when you use 3rd party source code<br>&gt;&gt;&gt; - your project will not be protected for the discussed problems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * To write safe code I can&#39;t group methods/props as I want, I have to<br>&gt;&gt;&gt; declare a number of extensions per-protocol (in case my type conforms to<br>&gt;&gt;&gt; a number of protocols)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * This solution does not solve problem of near-miss signature of method<br>&gt;&gt;&gt; definition in protocol extension like here:<br>&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt; protocol B : A {}<br>&gt;&gt;&gt; extension A { func foo() }<br>&gt;&gt;&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt; extension A { override func foo() }<br>&gt;&gt;&gt; extension B { override func foo() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Not clear how to write safe code with that approach if we implement<br>&gt;&gt;&gt; protocol requirement in derived class, but conformance was declared in<br>&gt;&gt;&gt; base (but not implemented) :<br>&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt; extension P { func foo() }<br>&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt; class B { func foo() } // we can&#39;t move this to extension, B already<br>&gt;&gt;&gt; conforms to P<br>&gt;&gt;&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if<br>&gt;&gt;&gt; `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s<br>&gt;&gt;&gt; definition(need to add `override` for B.foo )<br>&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt; class B { override func foo() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt;&gt;&gt; an example).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-AT-gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt;&gt; list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 23, 2016 at 04:00:00pm</p></header><div class="content"><p>On 23.09.2016 15:10, Rien wrote:<br>&gt; Note: Second attempt, first mail was rejected ?<br>&gt;<br>&gt; That is correct Vladimir, at the point of writing an API you never know who will end up using it in which way.<br>&gt; Hence the decision which flavour (of a function) to call should not be made by the coder writing the API but by the coder using the API.<br>&gt; And that coder cannot claim not to know which flavour he wants.<br>&gt; Hence including the ‘override’ keyword is unnecessary. However having the ability to specifying which flavour must be called is necessary. And this ability is easy to accommodate within the current language rules. (casting or possibly having a dot-notation for this purpose)<br></p><p>Sorry, I&#39;m not sure I fully understand.. I replied to Maximilian&#39;s <br>suggestion to use `conform` keyword if there is no default implementation <br>for implemented protocol requirement and use `override` if there is such <br>default implementation for the requirement. So, I show that we can&#39;t accept <br>such solution as it leads to such kind of dependency when some other&#39;s code <br>depends on your local code. I.e. if you add default implementations for <br>protocol defined in 3rd party code - you can break compilation of that code <br>and this should not happen(see my example in previous message).<br></p><p>As for requirement for any keyword to mark protocol implementation <br>method/prop in type - there were a lot of description in the thread why we <br>need this and what kind of problem this could solve and prevent <br>hard-to-find bugs. Also please look into initial problem of this thread.<br></p><p>&gt;<br>&gt; Regards,<br>&gt; Rien.<br>&gt;<br>&gt;&gt; On 23 Sep 2016, at 12:47, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt;&gt;&gt; I&#39;d also say that one or two keywords are superior than the protocol naming<br>&gt;&gt;&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My suggestions:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt;&gt;&gt; properties/functions which implement a protocol (also in protocol extensions)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt;&gt;&gt; superclass is overridden.<br>&gt;&gt;<br>&gt;&gt; Maximilian, again, you *do not know* if the conformed protocol, that has no default implementations *at the moment of your code writing* will or will not have default implementations at the *moment of compilation*.<br>&gt;&gt; Consider this scenario:<br>&gt;&gt;<br>&gt;&gt; Step 1. You got 3rd party source file for your project, and you don&#39;t want/have no rights to change it, probably it is shared source used also in other projects, that code contains:<br>&gt;&gt;<br>&gt;&gt; protocol A { func foo() }<br>&gt;&gt;<br>&gt;&gt; class B : A {<br>&gt;&gt; 	conform func foo() {...}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; all is OK with this code, no default implementation, B.foo marked with `conform`.<br>&gt;&gt;<br>&gt;&gt; Step 2. In your project in some of your files you decided to add default implementation of protocol A:<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt; 	implement func foo() {...}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Now, your project will not compile - B.foo() must me marked with &#39;override&#39; as protocol `A` has default implementation of foo().<br>&gt;&gt; If you change `conform` to `override` in 3rd party source file, it will not compile in some other project where no default implementation defined for `A` protocol.<br>&gt;&gt;<br>&gt;&gt; That is *why* I believe the `override` as requirement as marker for protocol implementation method/prop is the best solution. See, in case `override` will be required, the initial source file will be like this:<br>&gt;&gt;<br>&gt;&gt; protocol A { func foo() }<br>&gt;&gt;<br>&gt;&gt; class B : A {<br>&gt;&gt; 	override func foo() {...} // implementation<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; and it will compile ok : if A has default implementation and if A has no default implementation.<br>&gt;&gt;<br>&gt;&gt; So, after you added default implementation in your project - no changes should be made to that 3rd party source file.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt;&gt;&gt; &quot;implement&quot; is also required.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt;&gt;&gt; extension Foo: @retroactive Baz {<br>&gt;&gt;&gt;    // only some members of Baz are implemented here (they need the keywords)<br>&gt;&gt;&gt;    // the other members outside the extension don&#39;t need any additional<br>&gt;&gt;&gt; keywords<br>&gt;&gt;&gt;    // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Future directions:*<br>&gt;&gt;&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to disambiguate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // reducing boilerplate<br>&gt;&gt;&gt; extension Foo: conform Bar {<br>&gt;&gt;&gt;    // These declarations can only implement Bar and don&#39;t need the<br>&gt;&gt;&gt; &quot;conform&quot; keyword<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Final question:*<br>&gt;&gt;&gt; Should we also require a marker for implemented protocol members in the<br>&gt;&gt;&gt; interface?:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;    defaulted func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;    implement func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt;&gt;&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt;&gt;&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt;&gt;&gt;&gt; name collisions. I am at this point +1<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to<br>&gt;&gt;&gt;&gt; solve IMO important problems and make Swift&#39;s protocol programming safer<br>&gt;&gt;&gt;&gt; and less fragile. Also it adds new interested features for working with<br>&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by<br>&gt;&gt;&gt;&gt; core team and community and even if it could be supported, it seems for<br>&gt;&gt;&gt;&gt; me that *implementation* of his proposal requires a huge amount of time<br>&gt;&gt;&gt;&gt; and big changes in how Swift is working currently. (Probably some one who<br>&gt;&gt;&gt;&gt; knows Swift internals could comment regarding this)<br>&gt;&gt;&gt;&gt; So, theoretically we&#39;d have these improvements not in near future and I<br>&gt;&gt;&gt;&gt; think the problem discussed is very important to be addressed in Swift as<br>&gt;&gt;&gt;&gt; soon as possible.<br>&gt;&gt;&gt;&gt; I base my opinion also on previous discussions regarding similar subjects.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My suggestion regarding a marker for protocol implementation method/prop<br>&gt;&gt;&gt;&gt; in type - solves most of the addressed problems with protocol conformance<br>&gt;&gt;&gt;&gt; and with fragile of such conformance, and adds one new keyword (or even<br>&gt;&gt;&gt;&gt; zero - right now I think the `override` is better choice for such<br>&gt;&gt;&gt;&gt; &quot;marker&quot;). I believe this proposal could be implemented with much less<br>&gt;&gt;&gt;&gt; amount of work and with less changes to current internals of Swift and to<br>&gt;&gt;&gt;&gt; current code base, and so we can have such a big improvement in Swift<br>&gt;&gt;&gt;&gt; soon. So my intention was to suggest solution that can dramatically<br>&gt;&gt;&gt;&gt; improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for<br>&gt;&gt;&gt;&gt; compiler(internals) and for existed sources.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But it seems like the direction chosen by the core team and supported by<br>&gt;&gt;&gt;&gt; many in community - is just a warning if extension conforming type to<br>&gt;&gt;&gt;&gt; protocol contains unrelated to that protocol methods/props. I see that<br>&gt;&gt;&gt;&gt; this solution can improve protocol programming in some areas, but does<br>&gt;&gt;&gt;&gt; not address some IMO important issues we discussed in the thread :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Currently extension can not have stored properties. So, if we want to<br>&gt;&gt;&gt;&gt; implement protocol&#39;s props as stored properties - we can&#39;t move them to<br>&gt;&gt;&gt;&gt; extension. So to implement this soulution - we need stored properties in<br>&gt;&gt;&gt;&gt; extensions. It is not clear if and when they are expected.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * This solution will not require the safety(regarding protocol<br>&gt;&gt;&gt;&gt; conformance) from a developer, it will only inform and only if protocol<br>&gt;&gt;&gt;&gt; conformance defined in extension. So, when you use 3rd party source code<br>&gt;&gt;&gt;&gt; - your project will not be protected for the discussed problems.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * To write safe code I can&#39;t group methods/props as I want, I have to<br>&gt;&gt;&gt;&gt; declare a number of extensions per-protocol (in case my type conforms to<br>&gt;&gt;&gt;&gt; a number of protocols)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * This solution does not solve problem of near-miss signature of method<br>&gt;&gt;&gt;&gt; definition in protocol extension like here:<br>&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt; protocol B : A {}<br>&gt;&gt;&gt;&gt; extension A { func foo() }<br>&gt;&gt;&gt;&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt; extension A { override func foo() }<br>&gt;&gt;&gt;&gt; extension B { override func foo() }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Not clear how to write safe code with that approach if we implement<br>&gt;&gt;&gt;&gt; protocol requirement in derived class, but conformance was declared in<br>&gt;&gt;&gt;&gt; base (but not implemented) :<br>&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt; extension P { func foo() }<br>&gt;&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt;&gt; class B { func foo() } // we can&#39;t move this to extension, B already<br>&gt;&gt;&gt;&gt; conforms to P<br>&gt;&gt;&gt;&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if<br>&gt;&gt;&gt;&gt; `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s<br>&gt;&gt;&gt;&gt; definition(need to add `override` for B.foo )<br>&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt; class B { override func foo() }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt;&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt;&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt;&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt;&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt;&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt;&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt;&gt;&gt;&gt; an example).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt;&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt;&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt;&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt;&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-AT-gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt;&gt;&gt; list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 23, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Vladimir,<br></p><p>Going back to the original suggestion:<br></p><p>4.1 Different implementation for different protocols<br>class Foo : ProtocolA, ProtocolB {<br>   implement(ProtocolA) func foo() {...}<br>   implement(ProtocolB) func foo() {...}<br>}<br>class Foo : ProtocolA, ProtocolB {<br>   implement ProtocolA {<br>  	func foo() {...}<br>   }<br>   implement ProtocolB {<br>  	func foo() {...}<br>   }<br>}<br></p><p>I would rather solve this by implementing the conformance of Foo to either protocol in its own extension:<br></p><p>class Foo {}<br></p><p>extension Foo: ProtocolA {<br> func foo()<br>}<br></p><p>extension Foo: ProtocolB {<br> func foo()<br>}<br></p><p>This way the extra keyword is not necessary.<br>However it does make it necessary to be able to select the exact foo() an API user would want.<br>The API user has that knowledge and can select if via: (Foo as! ProtocolA).foo()<br></p><p>Or via a convenience dot-contruction: Foo.ProtocolA.foo()<br></p><p>I think that my suggestion may be more work, but it feels to me as if it is more in line with the general swift-phylosophy. <br></p><p>Regards,<br>Rien.<br></p><p><br></p><p><br>&gt; On 23 Sep 2016, at 15:08, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 23.09.2016 15:10, Rien wrote:<br>&gt;&gt; Note: Second attempt, first mail was rejected ?<br>&gt;&gt; <br>&gt;&gt; That is correct Vladimir, at the point of writing an API you never know who will end up using it in which way.<br>&gt;&gt; Hence the decision which flavour (of a function) to call should not be made by the coder writing the API but by the coder using the API.<br>&gt;&gt; And that coder cannot claim not to know which flavour he wants.<br>&gt;&gt; Hence including the ‘override’ keyword is unnecessary. However having the ability to specifying which flavour must be called is necessary. And this ability is easy to accommodate within the current language rules. (casting or possibly having a dot-notation for this purpose)<br>&gt; <br>&gt; Sorry, I&#39;m not sure I fully understand.. I replied to Maximilian&#39;s suggestion to use `conform` keyword if there is no default implementation for implemented protocol requirement and use `override` if there is such default implementation for the requirement. So, I show that we can&#39;t accept such solution as it leads to such kind of dependency when some other&#39;s code depends on your local code. I.e. if you add default implementations for protocol defined in 3rd party code - you can break compilation of that code and this should not happen(see my example in previous message).<br>&gt; <br>&gt; As for requirement for any keyword to mark protocol implementation method/prop in type - there were a lot of description in the thread why we need this and what kind of problem this could solve and prevent hard-to-find bugs. Also please look into initial problem of this thread.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Rien.<br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Sep 2016, at 12:47, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt;&gt;&gt;&gt; I&#39;d also say that one or two keywords are superior than the protocol naming<br>&gt;&gt;&gt;&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My suggestions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt;&gt;&gt;&gt; properties/functions which implement a protocol (also in protocol extensions)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt;&gt;&gt;&gt; superclass is overridden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maximilian, again, you *do not know* if the conformed protocol, that has no default implementations *at the moment of your code writing* will or will not have default implementations at the *moment of compilation*.<br>&gt;&gt;&gt; Consider this scenario:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Step 1. You got 3rd party source file for your project, and you don&#39;t want/have no rights to change it, probably it is shared source used also in other projects, that code contains:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt; 	conform func foo() {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; all is OK with this code, no default implementation, B.foo marked with `conform`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Step 2. In your project in some of your files you decided to add default implementation of protocol A:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt; 	implement func foo() {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, your project will not compile - B.foo() must me marked with &#39;override&#39; as protocol `A` has default implementation of foo().<br>&gt;&gt;&gt; If you change `conform` to `override` in 3rd party source file, it will not compile in some other project where no default implementation defined for `A` protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is *why* I believe the `override` as requirement as marker for protocol implementation method/prop is the best solution. See, in case `override` will be required, the initial source file will be like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt; 	override func foo() {...} // implementation<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and it will compile ok : if A has default implementation and if A has no default implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, after you added default implementation in your project - no changes should be made to that 3rd party source file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt;&gt;&gt;&gt; &quot;implement&quot; is also required.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt;&gt;&gt;&gt; extension Foo: @retroactive Baz {<br>&gt;&gt;&gt;&gt;   // only some members of Baz are implemented here (they need the keywords)<br>&gt;&gt;&gt;&gt;   // the other members outside the extension don&#39;t need any additional<br>&gt;&gt;&gt;&gt; keywords<br>&gt;&gt;&gt;&gt;   // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Future directions:*<br>&gt;&gt;&gt;&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to disambiguate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // reducing boilerplate<br>&gt;&gt;&gt;&gt; extension Foo: conform Bar {<br>&gt;&gt;&gt;&gt;   // These declarations can only implement Bar and don&#39;t need the<br>&gt;&gt;&gt;&gt; &quot;conform&quot; keyword<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Final question:*<br>&gt;&gt;&gt;&gt; Should we also require a marker for implemented protocol members in the<br>&gt;&gt;&gt;&gt; interface?:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;   defaulted func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;&gt;   implement func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt;&gt;&gt;&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt;&gt;&gt;&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt;&gt;&gt;&gt;&gt; name collisions. I am at this point +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to<br>&gt;&gt;&gt;&gt;&gt; solve IMO important problems and make Swift&#39;s protocol programming safer<br>&gt;&gt;&gt;&gt;&gt; and less fragile. Also it adds new interested features for working with<br>&gt;&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by<br>&gt;&gt;&gt;&gt;&gt; core team and community and even if it could be supported, it seems for<br>&gt;&gt;&gt;&gt;&gt; me that *implementation* of his proposal requires a huge amount of time<br>&gt;&gt;&gt;&gt;&gt; and big changes in how Swift is working currently. (Probably some one who<br>&gt;&gt;&gt;&gt;&gt; knows Swift internals could comment regarding this)<br>&gt;&gt;&gt;&gt;&gt; So, theoretically we&#39;d have these improvements not in near future and I<br>&gt;&gt;&gt;&gt;&gt; think the problem discussed is very important to be addressed in Swift as<br>&gt;&gt;&gt;&gt;&gt; soon as possible.<br>&gt;&gt;&gt;&gt;&gt; I base my opinion also on previous discussions regarding similar subjects.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My suggestion regarding a marker for protocol implementation method/prop<br>&gt;&gt;&gt;&gt;&gt; in type - solves most of the addressed problems with protocol conformance<br>&gt;&gt;&gt;&gt;&gt; and with fragile of such conformance, and adds one new keyword (or even<br>&gt;&gt;&gt;&gt;&gt; zero - right now I think the `override` is better choice for such<br>&gt;&gt;&gt;&gt;&gt; &quot;marker&quot;). I believe this proposal could be implemented with much less<br>&gt;&gt;&gt;&gt;&gt; amount of work and with less changes to current internals of Swift and to<br>&gt;&gt;&gt;&gt;&gt; current code base, and so we can have such a big improvement in Swift<br>&gt;&gt;&gt;&gt;&gt; soon. So my intention was to suggest solution that can dramatically<br>&gt;&gt;&gt;&gt;&gt; improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for<br>&gt;&gt;&gt;&gt;&gt; compiler(internals) and for existed sources.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But it seems like the direction chosen by the core team and supported by<br>&gt;&gt;&gt;&gt;&gt; many in community - is just a warning if extension conforming type to<br>&gt;&gt;&gt;&gt;&gt; protocol contains unrelated to that protocol methods/props. I see that<br>&gt;&gt;&gt;&gt;&gt; this solution can improve protocol programming in some areas, but does<br>&gt;&gt;&gt;&gt;&gt; not address some IMO important issues we discussed in the thread :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Currently extension can not have stored properties. So, if we want to<br>&gt;&gt;&gt;&gt;&gt; implement protocol&#39;s props as stored properties - we can&#39;t move them to<br>&gt;&gt;&gt;&gt;&gt; extension. So to implement this soulution - we need stored properties in<br>&gt;&gt;&gt;&gt;&gt; extensions. It is not clear if and when they are expected.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * This solution will not require the safety(regarding protocol<br>&gt;&gt;&gt;&gt;&gt; conformance) from a developer, it will only inform and only if protocol<br>&gt;&gt;&gt;&gt;&gt; conformance defined in extension. So, when you use 3rd party source code<br>&gt;&gt;&gt;&gt;&gt; - your project will not be protected for the discussed problems.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * To write safe code I can&#39;t group methods/props as I want, I have to<br>&gt;&gt;&gt;&gt;&gt; declare a number of extensions per-protocol (in case my type conforms to<br>&gt;&gt;&gt;&gt;&gt; a number of protocols)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * This solution does not solve problem of near-miss signature of method<br>&gt;&gt;&gt;&gt;&gt; definition in protocol extension like here:<br>&gt;&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;&gt; protocol B : A {}<br>&gt;&gt;&gt;&gt;&gt; extension A { func foo() }<br>&gt;&gt;&gt;&gt;&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt;&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt;&gt; extension A { override func foo() }<br>&gt;&gt;&gt;&gt;&gt; extension B { override func foo() }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Not clear how to write safe code with that approach if we implement<br>&gt;&gt;&gt;&gt;&gt; protocol requirement in derived class, but conformance was declared in<br>&gt;&gt;&gt;&gt;&gt; base (but not implemented) :<br>&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt; extension P { func foo() }<br>&gt;&gt;&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt;&gt;&gt; class B { func foo() } // we can&#39;t move this to extension, B already<br>&gt;&gt;&gt;&gt;&gt; conforms to P<br>&gt;&gt;&gt;&gt;&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if<br>&gt;&gt;&gt;&gt;&gt; `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s<br>&gt;&gt;&gt;&gt;&gt; definition(need to add `override` for B.foo )<br>&gt;&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt;&gt; class B { override func foo() }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-AT-gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt;&gt;&gt;&gt; list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/ebaa0154/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 23, 2016 at 07:00:00pm</p></header><div class="content"><p>On 23.09.2016 17:41, Rien wrote:<br>&gt; Hello Vladimir,<br>&gt;<br>&gt; Going back to the original suggestion:<br>&gt;<br>&gt; /4.1 Different implementation for different protocols/<br>&gt; /class Foo : ProtocolA, ProtocolB {/<br>&gt; /   implement(ProtocolA) func foo() {...}/<br>&gt; /   implement(ProtocolB) func foo() {...}/<br>&gt; /}/<br>&gt; /class Foo : ProtocolA, ProtocolB {/<br>&gt; /   implement ProtocolA {/<br>&gt; /  func foo() {...}/<br>&gt; /   }/<br>&gt; /   implement ProtocolB {/<br>&gt; /  func foo() {...}/<br>&gt; /   }/<br>&gt; /}/<br>&gt;<br>&gt; I would rather solve this by implementing the conformance of Foo to either<br>&gt; protocol in its own extension:<br></p><p>Yes, this solution also was discussed in one of last emails. More <br>specifically, the solution where only warning will be raised and only if <br>you conform to protocol in extension(if you conform &quot;in-place&quot; - no any <br>additional feature to express your intention) was discussed.<br></p><p>Will repeat myself:<br></p><p>* Currently extension can not have stored properties. So, if we want to <br>implement protocol&#39;s props as stored properties - we can&#39;t move them to <br>extension. So to implement this soulution - we need stored properties in <br>extensions. It is not clear if and when they are expected.<br></p><p>* This solution will not require the safety(regarding protocol conformance) <br>from a developer, it will only inform and only if protocol conformance <br>defined in extension. So, when you use 3rd party source code - your project <br>will not be protected for the discussed problems.<br></p><p>* To write safe code I can&#39;t group methods/props as I want, I have to <br>declare a number of extensions per-protocol (in case my type conforms to a <br>number of protocols)<br></p><p>* This solution does not solve problem of near-miss signature of method <br>definition in protocol extension like here:<br>protocol A { func foo() }<br>protocol B : A {}<br>extension A { func foo() }<br>extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br></p><p>* Not clear how to write safe code with that approach if we implement <br>protocol requirement in derived class, but conformance was declared in base <br>(but not implemented) :<br>protocol P { func foo() }<br>extension P { func foo() }<br>class A : P {}<br>class B { func foo() } // we can&#39;t move this to extension, B already <br>conforms to P<br>, and in opposite to &quot;my&quot; `override` requirement for implementation, if `A` <br>will add its own foo() implementation - we&#39;ll have to change B&#39;s <br>definition(need to add `override` for B.foo )<br></p><p>If these questions could be addressed by the &quot;conformance in extension&quot; <br>solution - then I also most likely will think it is the best solution. But <br>right now I see that this solution will not help in many places where we <br>need help from compiler to prevent hard-to-find bugs.<br></p><p>&gt;<br>&gt; class Foo {}<br>&gt;<br>&gt; extension Foo: ProtocolA {<br>&gt;  func foo()<br>&gt; }<br>&gt;<br>&gt; extension Foo: ProtocolB {<br>&gt;  func foo()<br>&gt; }<br>&gt;<br>&gt; This way the extra keyword is not necessary.<br>&gt; However it does make it necessary to be able to select the exact foo() an<br>&gt; API user would want.<br>&gt; The API user has that knowledge and can select if via: (Foo as!<br>&gt; ProtocolA).foo()<br>&gt;<br>&gt; Or via a convenience dot-contruction: Foo.ProtocolA.foo()<br>&gt;<br>&gt; I think that my suggestion may be more work, but it feels to me as if it is<br>&gt; more in line with the general swift-phylosophy.<br>&gt;<br>&gt; Regards,<br>&gt; Rien.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; On 23 Sep 2016, at 15:08, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 23.09.2016 15:10, Rien wrote:<br>&gt;&gt;&gt; Note: Second attempt, first mail was rejected ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That is correct Vladimir, at the point of writing an API you never know<br>&gt;&gt;&gt; who will end up using it in which way.<br>&gt;&gt;&gt; Hence the decision which flavour (of a function) to call should not be<br>&gt;&gt;&gt; made by the coder writing the API but by the coder using the API.<br>&gt;&gt;&gt; And that coder cannot claim not to know which flavour he wants.<br>&gt;&gt;&gt; Hence including the ‘override’ keyword is unnecessary. However having<br>&gt;&gt;&gt; the ability to specifying which flavour must be called is necessary. And<br>&gt;&gt;&gt; this ability is easy to accommodate within the current language rules.<br>&gt;&gt;&gt; (casting or possibly having a dot-notation for this purpose)<br>&gt;&gt;<br>&gt;&gt; Sorry, I&#39;m not sure I fully understand.. I replied to Maximilian&#39;s<br>&gt;&gt; suggestion to use `conform` keyword if there is no default implementation<br>&gt;&gt; for implemented protocol requirement and use `override` if there is such<br>&gt;&gt; default implementation for the requirement. So, I show that we can&#39;t<br>&gt;&gt; accept such solution as it leads to such kind of dependency when some<br>&gt;&gt; other&#39;s code depends on your local code. I.e. if you add default<br>&gt;&gt; implementations for protocol defined in 3rd party code - you can break<br>&gt;&gt; compilation of that code and this should not happen(see my example in<br>&gt;&gt; previous message).<br>&gt;&gt;<br>&gt;&gt; As for requirement for any keyword to mark protocol implementation<br>&gt;&gt; method/prop in type - there were a lot of description in the thread why<br>&gt;&gt; we need this and what kind of problem this could solve and prevent<br>&gt;&gt; hard-to-find bugs. Also please look into initial problem of this thread.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 23 Sep 2016, at 12:47, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt;&gt;&gt;&gt;&gt; I&#39;d also say that one or two keywords are superior than the protocol<br>&gt;&gt;&gt;&gt;&gt; naming<br>&gt;&gt;&gt;&gt;&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My suggestions:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt;&gt;&gt;&gt;&gt; properties/functions which implement a protocol (also in protocol<br>&gt;&gt;&gt;&gt;&gt; extensions)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt;&gt;&gt;&gt;&gt; superclass is overridden.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Maximilian, again, you *do not know* if the conformed protocol, that<br>&gt;&gt;&gt;&gt; has no default implementations *at the moment of your code writing*<br>&gt;&gt;&gt;&gt; will or will not have default implementations at the *moment of<br>&gt;&gt;&gt;&gt; compilation*.<br>&gt;&gt;&gt;&gt; Consider this scenario:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Step 1. You got 3rd party source file for your project, and you don&#39;t<br>&gt;&gt;&gt;&gt; want/have no rights to change it, probably it is shared source used<br>&gt;&gt;&gt;&gt; also in other projects, that code contains:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;&gt; conform func foo() {...}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; all is OK with this code, no default implementation, B.foo marked with<br>&gt;&gt;&gt;&gt; `conform`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Step 2. In your project in some of your files you decided to add<br>&gt;&gt;&gt;&gt; default implementation of protocol A:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt; implement func foo() {...}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Now, your project will not compile - B.foo() must me marked with<br>&gt;&gt;&gt;&gt; &#39;override&#39; as protocol `A` has default implementation of foo().<br>&gt;&gt;&gt;&gt; If you change `conform` to `override` in 3rd party source file, it will<br>&gt;&gt;&gt;&gt; not compile in some other project where no default implementation<br>&gt;&gt;&gt;&gt; defined for `A` protocol.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That is *why* I believe the `override` as requirement as marker for<br>&gt;&gt;&gt;&gt; protocol implementation method/prop is the best solution. See, in case<br>&gt;&gt;&gt;&gt; `override` will be required, the initial source file will be like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;&gt; override func foo() {...} // implementation<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; and it will compile ok : if A has default implementation and if A has<br>&gt;&gt;&gt;&gt; no default implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So, after you added default implementation in your project - no changes<br>&gt;&gt;&gt;&gt; should be made to that 3rd party source file.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt;&gt;&gt;&gt;&gt; &quot;implement&quot; is also required.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt;&gt;&gt;&gt;&gt; extension Foo: @retroactive Baz {<br>&gt;&gt;&gt;&gt;&gt;   // only some members of Baz are implemented here (they need the<br>&gt;&gt;&gt;&gt;&gt; keywords)<br>&gt;&gt;&gt;&gt;&gt;   // the other members outside the extension don&#39;t need any additional<br>&gt;&gt;&gt;&gt;&gt; keywords<br>&gt;&gt;&gt;&gt;&gt;   // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Future directions:*<br>&gt;&gt;&gt;&gt;&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to<br>&gt;&gt;&gt;&gt;&gt; disambiguate.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // reducing boilerplate<br>&gt;&gt;&gt;&gt;&gt; extension Foo: conform Bar {<br>&gt;&gt;&gt;&gt;&gt;   // These declarations can only implement Bar and don&#39;t need the<br>&gt;&gt;&gt;&gt;&gt; &quot;conform&quot; keyword<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Final question:*<br>&gt;&gt;&gt;&gt;&gt; Should we also require a marker for implemented protocol members in the<br>&gt;&gt;&gt;&gt;&gt; interface?:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;   defaulted func foo()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;&gt;&gt;   implement func foo()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; name collisions. I am at this point +1<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to<br>&gt;&gt;&gt;&gt;&gt;&gt; solve IMO important problems and make Swift&#39;s protocol programming safer<br>&gt;&gt;&gt;&gt;&gt;&gt; and less fragile. Also it adds new interested features for working with<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by<br>&gt;&gt;&gt;&gt;&gt;&gt; core team and community and even if it could be supported, it seems for<br>&gt;&gt;&gt;&gt;&gt;&gt; me that *implementation* of his proposal requires a huge amount of time<br>&gt;&gt;&gt;&gt;&gt;&gt; and big changes in how Swift is working currently. (Probably some one who<br>&gt;&gt;&gt;&gt;&gt;&gt; knows Swift internals could comment regarding this)<br>&gt;&gt;&gt;&gt;&gt;&gt; So, theoretically we&#39;d have these improvements not in near future and I<br>&gt;&gt;&gt;&gt;&gt;&gt; think the problem discussed is very important to be addressed in Swift as<br>&gt;&gt;&gt;&gt;&gt;&gt; soon as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; I base my opinion also on previous discussions regarding similar<br>&gt;&gt;&gt;&gt;&gt;&gt; subjects.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; My suggestion regarding a marker for protocol implementation method/prop<br>&gt;&gt;&gt;&gt;&gt;&gt; in type - solves most of the addressed problems with protocol conformance<br>&gt;&gt;&gt;&gt;&gt;&gt; and with fragile of such conformance, and adds one new keyword (or even<br>&gt;&gt;&gt;&gt;&gt;&gt; zero - right now I think the `override` is better choice for such<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;marker&quot;). I believe this proposal could be implemented with much less<br>&gt;&gt;&gt;&gt;&gt;&gt; amount of work and with less changes to current internals of Swift and to<br>&gt;&gt;&gt;&gt;&gt;&gt; current code base, and so we can have such a big improvement in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; soon. So my intention was to suggest solution that can dramatically<br>&gt;&gt;&gt;&gt;&gt;&gt; improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for<br>&gt;&gt;&gt;&gt;&gt;&gt; compiler(internals) and for existed sources.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; But it seems like the direction chosen by the core team and supported by<br>&gt;&gt;&gt;&gt;&gt;&gt; many in community - is just a warning if extension conforming type to<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol contains unrelated to that protocol methods/props. I see that<br>&gt;&gt;&gt;&gt;&gt;&gt; this solution can improve protocol programming in some areas, but does<br>&gt;&gt;&gt;&gt;&gt;&gt; not address some IMO important issues we discussed in the thread :<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Currently extension can not have stored properties. So, if we want to<br>&gt;&gt;&gt;&gt;&gt;&gt; implement protocol&#39;s props as stored properties - we can&#39;t move them to<br>&gt;&gt;&gt;&gt;&gt;&gt; extension. So to implement this soulution - we need stored properties in<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions. It is not clear if and when they are expected.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * This solution will not require the safety(regarding protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; conformance) from a developer, it will only inform and only if protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; conformance defined in extension. So, when you use 3rd party source code<br>&gt;&gt;&gt;&gt;&gt;&gt; - your project will not be protected for the discussed problems.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * To write safe code I can&#39;t group methods/props as I want, I have to<br>&gt;&gt;&gt;&gt;&gt;&gt; declare a number of extensions per-protocol (in case my type conforms to<br>&gt;&gt;&gt;&gt;&gt;&gt; a number of protocols)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * This solution does not solve problem of near-miss signature of method<br>&gt;&gt;&gt;&gt;&gt;&gt; definition in protocol extension like here:<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol B : A {}<br>&gt;&gt;&gt;&gt;&gt;&gt; extension A { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt; extension A { override func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension B { override func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * Not clear how to write safe code with that approach if we implement<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol requirement in derived class, but conformance was declared in<br>&gt;&gt;&gt;&gt;&gt;&gt; base (but not implemented) :<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt;&gt;&gt;&gt; class B { func foo() } // we can&#39;t move this to extension, B already<br>&gt;&gt;&gt;&gt;&gt;&gt; conforms to P<br>&gt;&gt;&gt;&gt;&gt;&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if<br>&gt;&gt;&gt;&gt;&gt;&gt; `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; definition(need to add `override` for B.foo )<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt; class B { override func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-at-gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-AT-gmail.com &lt;http://razielim-at-gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 23 Sep 2016, at 18:25, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 23.09.2016 17:41, Rien wrote:<br>&gt;&gt; Hello Vladimir,<br>&gt;&gt; <br>&gt;&gt; Going back to the original suggestion:<br>&gt;&gt; <br>&gt;&gt; /4.1 Different implementation for different protocols/<br>&gt;&gt; /class Foo : ProtocolA, ProtocolB {/<br>&gt;&gt; /   implement(ProtocolA) func foo() {...}/<br>&gt;&gt; /   implement(ProtocolB) func foo() {...}/<br>&gt;&gt; /}/<br>&gt;&gt; /class Foo : ProtocolA, ProtocolB {/<br>&gt;&gt; /   implement ProtocolA {/<br>&gt;&gt; /  func foo() {...}/<br>&gt;&gt; /   }/<br>&gt;&gt; /   implement ProtocolB {/<br>&gt;&gt; /  func foo() {...}/<br>&gt;&gt; /   }/<br>&gt;&gt; /}/<br>&gt;&gt; <br>&gt;&gt; I would rather solve this by implementing the conformance of Foo to either<br>&gt;&gt; protocol in its own extension:<br>&gt; <br>&gt; Yes, this solution also was discussed in one of last emails. More specifically, the solution where only warning will be raised and only if you conform to protocol in extension(if you conform &quot;in-place&quot; - no any additional feature to express your intention) was discussed.<br>&gt; <br>&gt; Will repeat myself:<br>&gt; <br>&gt; * Currently extension can not have stored properties. So, if we want to implement protocol&#39;s props as stored properties - we can&#39;t move them to extension. So to implement this soulution - we need stored properties in extensions. It is not clear if and when they are expected.<br></p><p>Personally, this tastes too much like “multiple base classes”. While I sometimes wish for this myself, I have to come down on the side of “don’t do this”. <br></p><p><br>&gt; * This solution will not require the safety(regarding protocol conformance) from a developer, it will only inform and only if protocol conformance defined in extension. So, when you use 3rd party source code - your project will not be protected for the discussed problems.<br></p><p>True, but it’s better still to avoid introducing keywords that are too specific and address situations that could be solved by “better” (cough), I mean.. different design. ;-)<br></p><p><br>&gt; * To write safe code I can&#39;t group methods/props as I want, I have to declare a number of extensions per-protocol (in case my type conforms to a number of protocols)<br></p><p>Introducing new keywords for this purpose does not appeal to me.<br></p><p><br>&gt; * This solution does not solve problem of near-miss signature of method definition in protocol extension like here:<br>&gt; protocol A { func foo() }<br>&gt; protocol B : A {}<br>&gt; extension A { func foo() }<br>&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br></p><p>It is IMO not the task of the compiler to catch this type of programming errors.<br>To me this is a classic case that makes the point for unit tests.<br></p><p><br>&gt; * Not clear how to write safe code with that approach if we implement protocol requirement in derived class, but conformance was declared in base (but not implemented) :<br>&gt; protocol P { func foo() }<br>&gt; extension P { func foo() }<br>&gt; class A : P {}<br>&gt; class B { func foo() } // we can&#39;t move this to extension, B already conforms to P<br>&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s definition(need to add `override` for B.foo )<br></p><p>While this can happen in “mid-design” I do not think that there should be API’s that require this.<br>Seems to me that this could be used to implement some kind of abstract classes, but IMO that is a mis-use of protocols. Better to provide useful default implementations or raise the fatal error.<br></p><p><br>&gt; If these questions could be addressed by the &quot;conformance in extension&quot; solution - then I also most likely will think it is the best solution. But right now I see that this solution will not help in many places where we need help from compiler to prevent hard-to-find bugs.<br></p><p>I realize that my objections fall mostly in the category of “IMO”.<br>But I also think that changes to a language should aim at making the language easier and more consistent to use, not more complex. All too often I have to catch myself at wishing for some feature or other, only to realise that it would complicate matters in general, even if in isolation the wished-for feature would make life easier.<br></p><p>Have a nice WE.<br>Best,<br>Rien.<br></p><p>&gt;&gt; <br>&gt;&gt; class Foo {}<br>&gt;&gt; <br>&gt;&gt; extension Foo: ProtocolA {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Foo: ProtocolB {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This way the extra keyword is not necessary.<br>&gt;&gt; However it does make it necessary to be able to select the exact foo() an<br>&gt;&gt; API user would want.<br>&gt;&gt; The API user has that knowledge and can select if via: (Foo as!<br>&gt;&gt; ProtocolA).foo()<br>&gt;&gt; <br>&gt;&gt; Or via a convenience dot-contruction: Foo.ProtocolA.foo()<br>&gt;&gt; <br>&gt;&gt; I think that my suggestion may be more work, but it feels to me as if it is<br>&gt;&gt; more in line with the general swift-phylosophy.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Rien.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Sep 2016, at 15:08, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 23.09.2016 15:10, Rien wrote:<br>&gt;&gt;&gt;&gt; Note: Second attempt, first mail was rejected ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is correct Vladimir, at the point of writing an API you never know<br>&gt;&gt;&gt;&gt; who will end up using it in which way.<br>&gt;&gt;&gt;&gt; Hence the decision which flavour (of a function) to call should not be<br>&gt;&gt;&gt;&gt; made by the coder writing the API but by the coder using the API.<br>&gt;&gt;&gt;&gt; And that coder cannot claim not to know which flavour he wants.<br>&gt;&gt;&gt;&gt; Hence including the ‘override’ keyword is unnecessary. However having<br>&gt;&gt;&gt;&gt; the ability to specifying which flavour must be called is necessary. And<br>&gt;&gt;&gt;&gt; this ability is easy to accommodate within the current language rules.<br>&gt;&gt;&gt;&gt; (casting or possibly having a dot-notation for this purpose)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I&#39;m not sure I fully understand.. I replied to Maximilian&#39;s<br>&gt;&gt;&gt; suggestion to use `conform` keyword if there is no default implementation<br>&gt;&gt;&gt; for implemented protocol requirement and use `override` if there is such<br>&gt;&gt;&gt; default implementation for the requirement. So, I show that we can&#39;t<br>&gt;&gt;&gt; accept such solution as it leads to such kind of dependency when some<br>&gt;&gt;&gt; other&#39;s code depends on your local code. I.e. if you add default<br>&gt;&gt;&gt; implementations for protocol defined in 3rd party code - you can break<br>&gt;&gt;&gt; compilation of that code and this should not happen(see my example in<br>&gt;&gt;&gt; previous message).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for requirement for any keyword to mark protocol implementation<br>&gt;&gt;&gt; method/prop in type - there were a lot of description in the thread why<br>&gt;&gt;&gt; we need this and what kind of problem this could solve and prevent<br>&gt;&gt;&gt; hard-to-find bugs. Also please look into initial problem of this thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 23 Sep 2016, at 12:47, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d also say that one or two keywords are superior than the protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; naming<br>&gt;&gt;&gt;&gt;&gt;&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My suggestions:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt;&gt;&gt;&gt;&gt;&gt; properties/functions which implement a protocol (also in protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt;&gt;&gt;&gt;&gt;&gt; superclass is overridden.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maximilian, again, you *do not know* if the conformed protocol, that<br>&gt;&gt;&gt;&gt;&gt; has no default implementations *at the moment of your code writing*<br>&gt;&gt;&gt;&gt;&gt; will or will not have default implementations at the *moment of<br>&gt;&gt;&gt;&gt;&gt; compilation*.<br>&gt;&gt;&gt;&gt;&gt; Consider this scenario:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Step 1. You got 3rd party source file for your project, and you don&#39;t<br>&gt;&gt;&gt;&gt;&gt; want/have no rights to change it, probably it is shared source used<br>&gt;&gt;&gt;&gt;&gt; also in other projects, that code contains:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;&gt;&gt; conform func foo() {...}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; all is OK with this code, no default implementation, B.foo marked with<br>&gt;&gt;&gt;&gt;&gt; `conform`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Step 2. In your project in some of your files you decided to add<br>&gt;&gt;&gt;&gt;&gt; default implementation of protocol A:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;&gt; implement func foo() {...}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now, your project will not compile - B.foo() must me marked with<br>&gt;&gt;&gt;&gt;&gt; &#39;override&#39; as protocol `A` has default implementation of foo().<br>&gt;&gt;&gt;&gt;&gt; If you change `conform` to `override` in 3rd party source file, it will<br>&gt;&gt;&gt;&gt;&gt; not compile in some other project where no default implementation<br>&gt;&gt;&gt;&gt;&gt; defined for `A` protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is *why* I believe the `override` as requirement as marker for<br>&gt;&gt;&gt;&gt;&gt; protocol implementation method/prop is the best solution. See, in case<br>&gt;&gt;&gt;&gt;&gt; `override` will be required, the initial source file will be like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;&gt;&gt; override func foo() {...} // implementation<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and it will compile ok : if A has default implementation and if A has<br>&gt;&gt;&gt;&gt;&gt; no default implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, after you added default implementation in your project - no changes<br>&gt;&gt;&gt;&gt;&gt; should be made to that 3rd party source file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;implement&quot; is also required.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Foo: @retroactive Baz {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // only some members of Baz are implemented here (they need the<br>&gt;&gt;&gt;&gt;&gt;&gt; keywords)<br>&gt;&gt;&gt;&gt;&gt;&gt;  // the other members outside the extension don&#39;t need any additional<br>&gt;&gt;&gt;&gt;&gt;&gt; keywords<br>&gt;&gt;&gt;&gt;&gt;&gt;  // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; *Future directions:*<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to<br>&gt;&gt;&gt;&gt;&gt;&gt; disambiguate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // reducing boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Foo: conform Bar {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // These declarations can only implement Bar and don&#39;t need the<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;conform&quot; keyword<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; *Final question:*<br>&gt;&gt;&gt;&gt;&gt;&gt; Should we also require a marker for implemented protocol members in the<br>&gt;&gt;&gt;&gt;&gt;&gt; interface?:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;  defaulted func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;  implement func foo()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 22.09.2016 um 16:44 schrieb Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22.09.2016 11:10, Jean-Denis Muys via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I watched this thread with a lot of attention, starting neutral. You<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; must say that Karl won me over. His proposal would make Swift more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressive, and less error prone in cases of protocol conformance with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; name collisions. I am at this point +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually I also support Karl&#39;s suggestion in general. It is trying to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; solve IMO important problems and make Swift&#39;s protocol programming safer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and less fragile. Also it adds new interested features for working with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But in reality, I don&#39;t feel like his suggestion could be accepted by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; core team and community and even if it could be supported, it seems for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; me that *implementation* of his proposal requires a huge amount of time<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and big changes in how Swift is working currently. (Probably some one who<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; knows Swift internals could comment regarding this)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, theoretically we&#39;d have these improvements not in near future and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; think the problem discussed is very important to be addressed in Swift as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; soon as possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I base my opinion also on previous discussions regarding similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; subjects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My suggestion regarding a marker for protocol implementation method/prop<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in type - solves most of the addressed problems with protocol conformance<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and with fragile of such conformance, and adds one new keyword (or even<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; zero - right now I think the `override` is better choice for such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;marker&quot;). I believe this proposal could be implemented with much less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; amount of work and with less changes to current internals of Swift and to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; current code base, and so we can have such a big improvement in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; soon. So my intention was to suggest solution that can dramatically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; improve Swift&#39;s protocol programming with &quot;small&quot; amount of changes for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler(internals) and for existed sources.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it seems like the direction chosen by the core team and supported by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; many in community - is just a warning if extension conforming type to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol contains unrelated to that protocol methods/props. I see that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this solution can improve protocol programming in some areas, but does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not address some IMO important issues we discussed in the thread :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Currently extension can not have stored properties. So, if we want to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implement protocol&#39;s props as stored properties - we can&#39;t move them to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension. So to implement this soulution - we need stored properties in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensions. It is not clear if and when they are expected.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * This solution will not require the safety(regarding protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance) from a developer, it will only inform and only if protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance defined in extension. So, when you use 3rd party source code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - your project will not be protected for the discussed problems.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * To write safe code I can&#39;t group methods/props as I want, I have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; declare a number of extensions per-protocol (in case my type conforms to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a number of protocols)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * This solution does not solve problem of near-miss signature of method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; definition in protocol extension like here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol A { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol B : A {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension A { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension B { func voo() } // typo. how to &quot;mark&quot; this should be impl?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension A { override func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension B { override func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Not clear how to write safe code with that approach if we implement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol requirement in derived class, but conformance was declared in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; base (but not implemented) :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension P { func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class B { func foo() } // we can&#39;t move this to extension, B already<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conforms to P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; , and in opposite to &quot;my&quot; `override` requirement for implementation, if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `A` will add its own foo() implementation - we&#39;ll have to change B&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; definition(need to add `override` for B.foo )<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;my&quot; suggestion:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class B { override func foo() }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean-Denis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 07:15, Karl via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol name in to the member in an ABI-breaking way. We could make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it additive by generating forwarding thunks from the old symbols to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the new ones, but it would be better if we could just solve the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; overlapping-members problem before then.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That would mean you never get collisions between protocol members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s loads of amazing stuff we can do with that ability, and ways<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we can extend it to reduce a lot of boilerplate that occurs when you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; want to have multiple representations of the same data (String is just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t really care about the syntax we need to make it liveable. We<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could automatically insert the protocol names for unambiguous members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; at call-site, or something else.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This thread was originally about making the *syntax* a requirement; I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; agree with that, and I would actually take it one (or several) steps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; further, solving other problems along the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Sep 2016, at 06:46, Russ Bishop &lt;xenadu at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-at-gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://razielim-AT-gmail.com &lt;http://razielim-at-gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the best way is to prefix the member name with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol, e.g:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; method/property/type implements a requirement of protocol P”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be to define the entity in an extension that also adds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to P. If that&#39;s inadequate indication in some way we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should find a way to enhance it.  I wouldn&#39;t mind the notation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above, but only as a fallback, not a reuquirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- -Dave _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default is the exact same way Swift works - by matching names. If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; there is a collision you specify Protocol.memberName. Its simple and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the years I was writing C# code it was flexible enough to cover<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; most reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Russ<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>September 26, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 23.09.2016 um 12:47 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt; <br>&gt;&gt; On 23.09.2016 11:05, Maximilian Hünenberger wrote:<br>&gt;&gt; I&#39;d also say that one or two keywords are superior than the protocol naming<br>&gt;&gt; approach in terms of implementation simplicity (for the core team).<br>&gt;&gt; <br>&gt;&gt; My suggestions:<br>&gt;&gt; <br>&gt;&gt; Either &quot;conform&quot; or &quot;implement&quot; should be a required keyword for all<br>&gt;&gt; properties/functions which implement a protocol (also in protocol extensions)<br>&gt;&gt; <br>&gt; <br>&gt;&gt; &quot;override&quot; should be used if a default implementation or a member of a<br>&gt;&gt; superclass is overridden.<br>&gt; <br>&gt; Maximilian, again, you *do not know* if the conformed protocol, that has no default implementations *at the moment of your code writing* will or will not have default implementations at the *moment of compilation*.<br>&gt; Consider this scenario:<br>&gt; <br>&gt; Step 1. You got 3rd party source file for your project, and you don&#39;t want/have no rights to change it, probably it is shared source used also in other projects, that code contains:<br>&gt; <br>&gt; protocol A { func foo() }<br>&gt; <br>&gt; class B : A {<br>&gt;    conform func foo() {...}<br>&gt; }<br>&gt; <br>&gt; all is OK with this code, no default implementation, B.foo marked with `conform`.<br>&gt; <br>&gt; Step 2. In your project in some of your files you decided to add default implementation of protocol A:<br>&gt; <br>&gt; extension A {<br>&gt;    implement func foo() {...}<br>&gt; }<br>&gt; <br>&gt; Now, your project will not compile - B.foo() must me marked with &#39;override&#39; as protocol `A` has default implementation of foo().<br>&gt; If you change `conform` to `override` in 3rd party source file, it will not compile in some other project where no default implementation defined for `A` protocol.<br>&gt; <br>&gt; That is *why* I believe the `override` as requirement as marker for protocol implementation method/prop is the best solution. See, in case `override` will be required, the initial source file will be like this:<br>&gt; <br>&gt; protocol A { func foo() }<br>&gt; <br>&gt; class B : A {<br>&gt;    override func foo() {...} // implementation<br>&gt; }<br>&gt; <br>&gt; and it will compile ok : if A has default implementation and if A has no default implementation.<br>&gt; <br>&gt; So, after you added default implementation in your project - no changes should be made to that 3rd party source file.<br>&gt; <br>&gt; <br></p><p>In case of my suggestion this is an easy fix: `override` is not required if it overrides a member of an extension in another module.<br></p><p>My basic idea is to distinguish between implementation and (true) overriding (of other members. Do you agree?<br></p><p>Consider this:<br></p><p>protocol A1 {<br>    func foo()<br>}<br></p><p>extension A1 {<br>    implement func foo() {}<br>}<br></p><p>protocol A2: A1 {<br>    override func foo() {}<br>}<br></p><p>In this case you know that `foo` in extension A1 does not override any other method.<br></p><p>Best regards<br>Maximilian<br></p><p>&gt;&gt; <br>&gt;&gt; If you are overriding a default implementation of a protocol &quot;conform&quot; /<br>&gt;&gt; &quot;implement&quot; is also required.<br>&gt;&gt; <br>&gt;&gt; // Retroactive conformance (old behavior) but only in extensions<br>&gt;&gt; extension Foo: @retroactive Baz {<br>&gt;&gt;    // only some members of Baz are implemented here (they need the keywords)<br>&gt;&gt;    // the other members outside the extension don&#39;t need any additional<br>&gt;&gt; keywords<br>&gt;&gt;    // note: you can use &quot;@retroactive&quot; and &quot;conform&quot; in conjunction<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; *Future directions:*<br>&gt;&gt; &quot;conform(ProtocolName)&quot; / &quot;override(ProtocolName)&quot; can be used to disambiguate.<br>&gt;&gt; <br>&gt;&gt; // reducing boilerplate<br>&gt;&gt; extension Foo: conform Bar {<br>&gt;&gt;    // These declarations can only implement Bar and don&#39;t need the<br>&gt;&gt; &quot;conform&quot; keyword<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; *Final question:*<br>&gt;&gt; Should we also require a marker for implemented protocol members in the<br>&gt;&gt; interface?:<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt;    defaulted func foo()<br>&gt;&gt; }<br>&gt;&gt; extension Foo {<br>&gt;&gt;    implement func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/6492b045/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>September 22, 2016 at 11:00:00am</p></header><div class="content"><p>Hi,<br></p><p>isn&#39;t it perfectly fine to conform to multiple unrelated protocols which <br>both require the same member?<br>Or to declare protocol conformance in some unrelated module?<br></p><p>Am 2016-09-22 07:15, schrieb Karl via swift-evolution:<br>&gt; I would like to make it a requirement if not inside a protocol<br>&gt; extension which declares a conformance, and actually build the<br>&gt; protocol name in to the member in an ABI-breaking way.<br></p><p>IMO, this is much too restrictive.<br>When we force the protocol name into the member, we make it impossible <br>to conform to multiple protocols.<br>Well ok, we could create alias names for all protocols.<br>But often you don&#39;t know which protocols to conform to when you compile <br>your module!<br></p><p>What about:<br></p><p>  -- module A --<br>  class A {<br>    func foo() {}<br>  }<br></p><p>  -- module B --<br>  protocol Foo {<br>    func foo()<br>  }<br>  extension A: Foo {}<br></p><p>What is your ABI name for A.foo()?<br></p><p>Let&#39;s keep it simple!<br>If a simple warning about unrelated methods in a protocol conformance <br>extension solves 95% of our problem,<br>then we shouldn&#39;t overengineer and throw away all our flexibility just <br>to be 100% explicit about which protocol uses which members.<br></p><p>-- <br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c906b43e6e16ae5540d8f40b95e29091?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Marinus van der Lugt</string> &lt;rien at starbase55.com&gt;<p>September 22, 2016 at 06:00:00pm</p></header><div class="content"><p>That does not seem right to me. A does not implement any protocol.<br>The extension of A implements a protocol thus foo() should not be seen as part of the protocol at all.<br></p><p>So far, I have always extended a class when adding protocol compliance. I.e. it is always clear<br></p><p>I.e.<br></p><p>protocol P {<br>func foo()<br>}<br></p><p>class A {<br> fun foo() {} // Should not be regarded as implementation of P<br>}<br></p><p>extension A: P {<br> func foo() {} // This is the implementation of P<br>}<br></p><p>&gt; <br>&gt; On 22 Sep 2016, at 11:28, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; isn&#39;t it perfectly fine to conform to multiple unrelated protocols which both require the same member?<br>&gt; Or to declare protocol conformance in some unrelated module?<br>&gt; <br>&gt; Am 2016-09-22 07:15, schrieb Karl via swift-evolution:<br>&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt; protocol name in to the member in an ABI-breaking way.<br>&gt; <br>&gt; IMO, this is much too restrictive.<br>&gt; When we force the protocol name into the member, we make it impossible to conform to multiple protocols.<br>&gt; Well ok, we could create alias names for all protocols.<br>&gt; But often you don&#39;t know which protocols to conform to when you compile your module!<br>&gt; <br>&gt; What about:<br>&gt; <br>&gt; -- module A --<br>&gt; class A {<br>&gt;   func foo() {}<br>&gt; }<br>&gt; <br>&gt; -- module B --<br>&gt; protocol Foo {<br>&gt;   func foo()<br>&gt; }<br>&gt; extension A: Foo {}<br>&gt; <br>&gt; What is your ABI name for A.foo()?<br>&gt; <br>&gt; Let&#39;s keep it simple!<br>&gt; If a simple warning about unrelated methods in a protocol conformance extension solves 95% of our problem,<br>&gt; then we shouldn&#39;t overengineer and throw away all our flexibility just to be 100% explicit about which protocol uses which members.<br>&gt; <br>&gt; -- <br>&gt; Martin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 22, 2016 at 04:00:00pm</p></header><div class="content"><p>Extensions in Swift aren&#39;t a first-class entity; they have no name and no<br>representation in the type system. If an extension to A does something,<br>then A does something. If A conforms to P, then A.foo is the implementation<br>of P.foo.<br>On Thu, Sep 22, 2016 at 11:06 Marinus van der Lugt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That does not seem right to me. A does not implement any protocol.<br>&gt; The extension of A implements a protocol thus foo() should not be seen as<br>&gt; part of the protocol at all.<br>&gt;<br>&gt; So far, I have always extended a class when adding protocol compliance.<br>&gt; I.e. it is always clear<br>&gt;<br>&gt; I.e.<br>&gt;<br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; class A {<br>&gt;  fun foo() {} // Should not be regarded as implementation of P<br>&gt; }<br>&gt;<br>&gt; extension A: P {<br>&gt;  func foo() {} // This is the implementation of P<br>&gt; }<br>&gt;<br>&gt; &gt;<br>&gt; &gt; On 22 Sep 2016, at 11:28, Martin Waitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; isn&#39;t it perfectly fine to conform to multiple unrelated protocols which<br>&gt; both require the same member?<br>&gt; &gt; Or to declare protocol conformance in some unrelated module?<br>&gt; &gt;<br>&gt; &gt; Am 2016-09-22 07:15, schrieb Karl via swift-evolution:<br>&gt; &gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt; &gt;&gt; extension which declares a conformance, and actually build the<br>&gt; &gt;&gt; protocol name in to the member in an ABI-breaking way.<br>&gt; &gt;<br>&gt; &gt; IMO, this is much too restrictive.<br>&gt; &gt; When we force the protocol name into the member, we make it impossible<br>&gt; to conform to multiple protocols.<br>&gt; &gt; Well ok, we could create alias names for all protocols.<br>&gt; &gt; But often you don&#39;t know which protocols to conform to when you compile<br>&gt; your module!<br>&gt; &gt;<br>&gt; &gt; What about:<br>&gt; &gt;<br>&gt; &gt; -- module A --<br>&gt; &gt; class A {<br>&gt; &gt;   func foo() {}<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -- module B --<br>&gt; &gt; protocol Foo {<br>&gt; &gt;   func foo()<br>&gt; &gt; }<br>&gt; &gt; extension A: Foo {}<br>&gt; &gt;<br>&gt; &gt; What is your ABI name for A.foo()?<br>&gt; &gt;<br>&gt; &gt; Let&#39;s keep it simple!<br>&gt; &gt; If a simple warning about unrelated methods in a protocol conformance<br>&gt; extension solves 95% of our problem,<br>&gt; &gt; then we shouldn&#39;t overengineer and throw away all our flexibility just<br>&gt; to be 100% explicit about which protocol uses which members.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Martin<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/5ea36418/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 23, 2016 at 08:00:00am</p></header><div class="content"><p>It took another good night’s sleep to be able to realise what I really wanted to express yesterday. It comes down to three points:<br></p><p>1) Protocol marking is not really a proposal, but a bug report.<br>2) I do not think it needs new syntax<br>3) There is probably a lot of code out there that “uses” this bug. Cause us to think that this is a source breaking change. It is not, but that existing code is “wrong” and needs to be redesigned.<br></p><p>I am not sure this covers all the cases discussed in this thread, I simply do not have to time to follow all discussions in full detail.<br></p><p>&gt; &gt; -- module A --<br>&gt; &gt; class A {<br>&gt; &gt;   func foo() {}<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -- module B --<br>&gt; &gt; protocol Foo {<br>&gt; &gt;   func foo()<br>&gt; &gt; }<br>&gt; &gt; extension A: Foo {}<br></p><p><br>let C = A()<br></p><p><br>I’d say that you have two functions here:<br>A.foo() and A.Foo.foo()<br></p><p>To call the first, write C.foo()<br>To call the second, write (C as! Foo).foo()<br></p><p>No ambiguity.<br></p><p>Note that A.foo() was never intended to be used as an implementation for protocol Foo, thus why should you be able to see it as such? That imo is a bug in the language. Its not flexibility, it’s dangerous.<br></p><p>Rien.<br></p><p><br>&gt; On 22 Sep 2016, at 18:27, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Extensions in Swift aren&#39;t a first-class entity; they have no name and no representation in the type system. If an extension to A does something, then A does something. If A conforms to P, then A.foo is the implementation of P.foo.<br>&gt; On Thu, Sep 22, 2016 at 11:06 Marinus van der Lugt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; That does not seem right to me. A does not implement any protocol.<br>&gt; The extension of A implements a protocol thus foo() should not be seen as part of the protocol at all.<br>&gt; <br>&gt; So far, I have always extended a class when adding protocol compliance. I.e. it is always clear<br>&gt; <br>&gt; I.e.<br>&gt; <br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt; <br>&gt; class A {<br>&gt;  fun foo() {} // Should not be regarded as implementation of P<br>&gt; }<br>&gt; <br>&gt; extension A: P {<br>&gt;  func foo() {} // This is the implementation of P<br>&gt; }<br>&gt; <br>&gt; &gt;<br>&gt; &gt; On 22 Sep 2016, at 11:28, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; isn&#39;t it perfectly fine to conform to multiple unrelated protocols which both require the same member?<br>&gt; &gt; Or to declare protocol conformance in some unrelated module?<br>&gt; &gt;<br>&gt; &gt; Am 2016-09-22 07:15, schrieb Karl via swift-evolution:<br>&gt; &gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt; &gt;&gt; extension which declares a conformance, and actually build the<br>&gt; &gt;&gt; protocol name in to the member in an ABI-breaking way.<br>&gt; &gt;<br>&gt; &gt; IMO, this is much too restrictive.<br>&gt; &gt; When we force the protocol name into the member, we make it impossible to conform to multiple protocols.<br>&gt; &gt; Well ok, we could create alias names for all protocols.<br>&gt; &gt; But often you don&#39;t know which protocols to conform to when you compile your module!<br>&gt; &gt;<br>&gt; &gt; What about:<br>&gt; &gt;<br>&gt; &gt; -- module A --<br>&gt; &gt; class A {<br>&gt; &gt;   func foo() {}<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -- module B --<br>&gt; &gt; protocol Foo {<br>&gt; &gt;   func foo()<br>&gt; &gt; }<br>&gt; &gt; extension A: Foo {}<br>&gt; &gt;<br>&gt; &gt; What is your ABI name for A.foo()?<br>&gt; &gt;<br>&gt; &gt; Let&#39;s keep it simple!<br>&gt; &gt; If a simple warning about unrelated methods in a protocol conformance extension solves 95% of our problem,<br>&gt; &gt; then we shouldn&#39;t overengineer and throw away all our flexibility just to be 100% explicit about which protocol uses which members.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Martin<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>September 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello :)<br></p><p>Am 2016-09-23 08:50, schrieb Rien:<br>&gt; <br>&gt; &gt; -- module A --<br>&gt; &gt; class A {<br>&gt; &gt;   func foo() {}<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -- module B --<br>&gt; &gt; protocol Foo {<br>&gt; &gt;   func foo()<br>&gt; &gt; }<br>&gt; &gt; extension A: Foo {}<br>&gt; <br>&gt; let c = A()<br>&gt; <br>&gt; I’d say that you have two functions here:<br>&gt; A.foo() and A.Foo.foo()<br></p><p>No. Now (i.e. within module B) A conforms to Foo, using the already <br>existing function.<br></p><p>&gt; Note that A.foo() was never intended to be used as an implementation<br>&gt; for protocol Foo, thus why should you be able to see it as such? That<br>&gt; imo is a bug in the language. Its not flexibility, it’s dangerous.<br></p><p>I disagree, this is the great thing about Swift.<br>It&#39;s exactly in the middle between Go&#39;s &quot;everything is considered to <br>implement a protocol if it happens to provide the right methods&quot; and <br>C++/younameit&#39;s &quot;you have to know everything in advance and people are <br>screwed if the library does not use the right protocols&quot; style.<br></p><p>You can add protocol conformance to classes you don&#39;t control, but you <br>have to explicitly declare this conformance.<br>I think this is exactly the right approach.<br></p><p>-- <br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 23, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Martin,<br></p><p>Adding protocol conformance via existing functions can be had in different ways, first it could be done via mapping rules.<br>I.e. if the API user requests a function A.Foo.foo() and there is only a function A.foo() present, the language rules could allow this to be accepted as the default. This is probably the best option if the impact on existing code should be minimized.<br></p><p>Another way would be to use a little boilerplate and provide a new A.Foo.foo() that calls A.foo(). Not very nice, but it does make the intent very clear.<br></p><p>A third way would be to write something like:<br></p><p>extension A: Foo {<br> func foo() use A.foo()<br>}<br></p><p>but that is adding an extra keyword, which I think needs to be very carefully considered. I would not suggest it right now.<br></p><p><br>MfG,<br>Rien.<br></p><p>&gt; On 23 Sep 2016, at 14:58, Martin Waitz &lt;tali at admingilde.org&gt; wrote:<br>&gt; <br>&gt; Hello :)<br>&gt; <br>&gt; Am 2016-09-23 08:50, schrieb Rien:<br>&gt;&gt; &gt; -- module A --<br>&gt;&gt; &gt; class A {<br>&gt;&gt; &gt;   func foo() {}<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- module B --<br>&gt;&gt; &gt; protocol Foo {<br>&gt;&gt; &gt;   func foo()<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; extension A: Foo {}<br>&gt;&gt; let c = A()<br>&gt;&gt; I’d say that you have two functions here:<br>&gt;&gt; A.foo() and A.Foo.foo()<br>&gt; <br>&gt; No. Now (i.e. within module B) A conforms to Foo, using the already existing function.<br>&gt; <br>&gt;&gt; Note that A.foo() was never intended to be used as an implementation<br>&gt;&gt; for protocol Foo, thus why should you be able to see it as such? That<br>&gt;&gt; imo is a bug in the language. Its not flexibility, it’s dangerous.<br>&gt; <br>&gt; I disagree, this is the great thing about Swift.<br>&gt; It&#39;s exactly in the middle between Go&#39;s &quot;everything is considered to implement a protocol if it happens to provide the right methods&quot; and C++/younameit&#39;s &quot;you have to know everything in advance and people are screwed if the library does not use the right protocols&quot; style.<br>&gt; <br>&gt; You can add protocol conformance to classes you don&#39;t control, but you have to explicitly declare this conformance.<br>&gt; I think this is exactly the right approach.<br>&gt; <br>&gt; -- <br>&gt; Martin<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 22, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Sep 22 2016, Martin Waitz &lt;tali-AT-admingilde.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; isn&#39;t it perfectly fine to conform to multiple unrelated protocols<br>&gt; which both require the same member?<br></p><p>Yeah, but in practice it *basically* never happens, to the point where<br>I&#39;d be fine requiring boilerplate repetition if you wanted to satisfy<br>requirements of two protocols unrelated by refinement with the same<br>declaration.<br></p><p>&gt; Or to declare protocol conformance in some unrelated module?<br>&gt;<br>&gt; Am 2016-09-22 07:15, schrieb Karl via swift-evolution:<br>&gt;&gt; I would like to make it a requirement if not inside a protocol<br>&gt;&gt; extension which declares a conformance, and actually build the<br>&gt;&gt; protocol name in to the member in an ABI-breaking way.<br>&gt;<br>&gt; IMO, this is much too restrictive.<br>&gt; When we force the protocol name into the member, we make it impossible<br>&gt; to conform to multiple protocols.<br>&gt; Well ok, we could create alias names for all protocols.<br>&gt; But often you don&#39;t know which protocols to conform to when you<br>&gt; compile your module!<br>&gt;<br>&gt; What about:<br>&gt;<br>&gt;  -- module A --<br>&gt;  class A {<br>&gt;    func foo() {}<br>&gt;  }<br>&gt;<br>&gt;  -- module B --<br>&gt;  protocol Foo {<br>&gt;    func foo()<br>&gt;  }<br>&gt;  extension A: Foo {}<br>&gt;<br>&gt; What is your ABI name for A.foo()?<br>&gt;<br>&gt; Let&#39;s keep it simple!<br>&gt; If a simple warning about unrelated methods in a protocol conformance<br>&gt; extension solves 95% of our problem,<br>&gt; then we shouldn&#39;t overengineer and throw away all our flexibility just<br>&gt; to be 100% explicit about which protocol uses which members.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 22, 2016 at 01:00:00pm</p></header><div class="content"><p>On 22.09.2016 7:46, Russ Bishop via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Sep 20, 2016, at 4:34 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Sep 20 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I think the best way is to prefix the member name with the protocol,<br>&gt;&gt;&gt; e.g:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol MyProto { var aVariable : Int func aFunction() } class<br>&gt;&gt;&gt; MyClass : MyProto { var MyProto.aVariable : Int func<br>&gt;&gt;&gt; MyProto.aFunction() { … } }<br>&gt;&gt; ...<br>&gt;&gt;&gt; CC-ing Dave A, to understand better if this fits with the vision of<br>&gt;&gt;&gt; protocols<br>&gt;&gt;<br>&gt;&gt; I generally agree with Doug.  The canonical way to indicate “this<br>&gt;&gt; method/property/type implements a requirement of protocol P” should<br>&gt;&gt; be to define the entity in an extension that also adds conformance to<br>&gt;&gt; P. If that&#39;s inadequate indication in some way we should find a way<br>&gt;&gt; to enhance it.  I wouldn&#39;t mind the notation above, but only as a<br>&gt;&gt; fallback, not a reuquirement.<br>&gt;&gt;<br>&gt;&gt; -- -Dave _______________________________________________<br>&gt;<br>&gt; Indeed this is exactly how C# handles Interfaces (protocols). The<br></p><p><br>Can C#&#39;s interface(protocol) have default implementations for its <br>requirements like in Swift?<br></p><p><br>&gt; default is the exact same way Swift works - by matching names. If there<br>&gt; is a collision you specify Protocol.memberName. Its simple and in the<br>&gt; years I was writing C# code it was flexible enough to cover most<br>&gt; reasonable scenarios, without adding a bunch of boilerplate.<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 21, 2016 at 01:00:00am</p></header><div class="content"><p>On 20.09.2016 19:43, Nevin Brackett-Rozinsky via swift-evolution wrote:<br>&gt; I have been following this discussion (as well as similar threads earlier<br>&gt; this year) and listening to the ideas put forth by all sides.<br>&gt;<br></p><p>Yes, to do nothing and to have fragile protocol oriented programming is an <br>another alternative. I can understand your opinion but can&#39;t agree.<br></p><p>About IDEs - I believe you know what I want to say ;-) In short - we are <br>discussing Swift *language* and there is not only one IDE in this word and <br>even with it nobody knows how long you will wait for such feature and *if* <br>it will be implemented. So, IMO not an option.<br></p><p>About linters. Imagine you added complex 3rd party source code to your <br>project. You use your own linter with your own rules. You see a number of <br>warnings from your linter in that 3rd party code. Of course, the developer <br>of that code was not using your linter with your settings, so there are a <br>lot of warning. You see some warning regarding &quot;near-miss&quot; <br>methods/properties in different places of that code. So, what next?<br></p><p>How linter will protect your project in this case from the discussed <br>problem? In case developer of that 3rd party sources will have to express <br>intentions  - your project will be in safe, or theirs sources will not <br>compile at all.<br></p><p><br>&gt; It seems to me that the fundamental difference between classes and<br>&gt; protocols is that classes inherit implementation whereas protocol<br>&gt; conformance is a promise about interface.<br>&gt;<br>&gt; When a class or struct or enum declares itself as conforming to a protocol,<br>&gt; that means it has all the members specified in the protocol. The protocol<br>&gt; conformance simply codifies a fact about the type itself: namely that all<br>&gt; those members are present.<br>&gt;<br>&gt; In this model, any keyword such as `implements` on each conforming member<br>&gt; would introduce substantial boilerplate for negligible gain. The purpose of<br>&gt; a protocol is to communicate that certain members are available, not to<br>&gt; make declaring those members more onerous.<br>&gt;<br>&gt; However, default implementations for protocols blur the line. Now there is<br>&gt; actual implementation being inherited. A conforming type may choose to roll<br>&gt; its own version of a method, or to utilize the default provided by the<br>&gt; protocol. This is closer to the situation with subclassing.<br>&gt;<br>&gt; Moreover, a protocol which conforms to another protocol may itself define<br>&gt; (or redefine!) default implementations for members of that other protocol.<br>&gt; This can create “inheritance chains” of protocol default implementations. I<br>&gt; think there is value in being able to refer to (and call) the inherited<br>&gt; default implementation through some sort of `super` functionality.<br>&gt;<br>&gt; On the other hand, the existence of a default implementation in a protocol<br>&gt; is in large part merely a convenience: a courtesy so that each conforming<br>&gt; type need not rewrite the same boilerplate code.<br>&gt;<br>&gt; A type which conforms to a protocol may accept the default or it may<br>&gt; provide its own implementation, but it is not “overriding” anything. The<br>&gt; default implementation was offered as a convenience, to be taken or left as<br>&gt; needed. Thus I do not think any keyword (neither `override` nor<br>&gt; `implements`) should be required in that case either.<br>&gt;<br>&gt; The frequently-raised point regarding near-miss member names deserves some<br>&gt; attention. Several people have expressed a desire for the compiler to<br>&gt; assist them in determining whether a given member does or does not meet a<br>&gt; protocol requirement. Specifically, when a type conforms to a protocol with<br>&gt; a default implementation, and the type defines a member with a similar<br>&gt; signature, it is not obvious at glance if that member matches the protocol.<br>&gt;<br>&gt; I think this is a job for linters and IDEs. For example, syntax<br>&gt; highlighting could distinguish members which satisfy a protocol<br>&gt; requirement, thereby providing immediate visual confirmation of success.<br>&gt;<br>&gt; Having followed the lengthy discussion and weighed the numerous ideas put<br>&gt; forth, I come down firmly on the side of no keyword for protocol conformance.<br>&gt;<br>&gt; A protocol describes an interface and provides a set of customization<br>&gt; points. It may also, as a convenience, offer default implementations. The<br>&gt; protocol simply describes the capabilities of its conforming types, and any<br>&gt; default implementations are there to make things easier for them.<br>&gt;<br>&gt; Conforming types should not be afflicted with extraneous keywords: that<br>&gt; would run contrary to the purpose of having protocols in the first place.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 11:16 AM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     As I mentioned above, I agree that better diagnostics for near-misses<br>&gt;     are necessary, but they are possible without new syntax. There is no<br>&gt;     win in avoiding unintentional behavior because, without a default<br>&gt;     implementation, these issues are caught at compile time already.<br>&gt;<br>&gt;     On Tue, Sep 20, 2016 at 10:14 Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;          &gt; extension P {<br>&gt;          &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;          &gt; }<br>&gt;<br>&gt;         Yes, it seems like we need `implement` (or `override` as another<br>&gt;         suggestion) in protocol extension also just for the same reasons -<br>&gt;         be clear<br>&gt;         about our intention regarding implementing the requirement, to show<br>&gt;         that<br>&gt;         this func *depends* on the previous definition of P protocol and to<br>&gt;         avoid<br>&gt;         possible mistakes related to protocol conformance.<br>&gt;<br>&gt;         On 20.09.2016 17:38, Charles Srstka wrote:<br>&gt;         &gt;&gt; On Sep 20, 2016, at 8:17 AM, Vladimir.S via swift-evolution<br>&gt;         &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         &lt;mailto:swift-evolution at swift.org<br>&gt;         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; On 20.09.2016 3:03, Xiaodi Wu via swift-evolution wrote:<br>&gt;         &gt;&gt;&gt; I definitely think Vladimir&#39;s suggestion is a great starting<br>&gt;         point, IMO.<br>&gt;         &gt;&gt;&gt;<br>&gt;         &gt;&gt;&gt; However, I think it could be improved in one key respect where<br>&gt;         previous<br>&gt;         &gt;&gt;&gt; proposals using `override` are superior. Namely, the proposed<br>&gt;         `implement`<br>&gt;         &gt;&gt;&gt; keyword adds no additional safety when a type implements a protocol<br>&gt;         &gt;&gt;&gt; requirement that doesn&#39;t have a default implementation. This is<br>&gt;         because, if<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; Yes, *at the moment of writing* the type&#39;s code there could be<br>&gt;         no default<br>&gt;         &gt;&gt; implementation for protocol requirement. But, *at the moment of<br>&gt;         &gt;&gt; compilation* such default implementation could appear.<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; Let&#39;s discuss such scenario in case we&#39;ll take your suggestion:<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; You got SomeClass.swift file, 3rd party file you don&#39;t want to<br>&gt;         change or<br>&gt;         &gt;&gt; changes are not allowed. Content:<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; public protocol SomeProtocol {<br>&gt;         &gt;&gt; func foo()<br>&gt;         &gt;&gt; }<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; public class SomeClass : SomeProtocol {<br>&gt;         &gt;&gt; func foo() {...} // no default implementation *at the moment of<br>&gt;         writing*,<br>&gt;         &gt;&gt; no need in `overload`<br>&gt;         &gt;&gt; }<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; Now, you adds SomeClass.swift file to your project and in some<br>&gt;         *other*<br>&gt;         &gt;&gt; file you write:<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; extension SomeProtocol {<br>&gt;         &gt;&gt; func foo() {...}<br>&gt;         &gt;&gt; }<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; As you see, you don&#39;t control the SomeClass.swift but you<br>&gt;         suggest in this<br>&gt;         &gt;&gt; case SomeClass.foo() should be defined with `override`.<br>&gt;         &gt;&gt;<br>&gt;         &gt;&gt; With &#39;implement&#39; SomeClass.foo() will be marked initially and<br>&gt;         will save<br>&gt;         &gt;&gt; us if protocol&#39;s requirement PLUS default implementation changed.<br>&gt;         &gt;<br>&gt;         &gt; Requiring the ‘implement’ keyword can help us even if no default<br>&gt;         &gt; implementation is involved. Consider:<br>&gt;         &gt;<br>&gt;         &gt; protocol P {<br>&gt;         &gt; func foo() -&gt; [String : Any]<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt; struct S : P {<br>&gt;         &gt; func foo() -&gt; [String : String] { return [:] }<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt; We will get an error here that S does not conform to P. However,<br>&gt;         this is<br>&gt;         &gt; not the correct error, since S in fact *tries* to conform to P,<br>&gt;         but it has<br>&gt;         &gt; a mistake in a method signature. This misleads us as to the true<br>&gt;         nature of<br>&gt;         &gt; the problem, and if S has enough members in it that we fail to<br>&gt;         spot the<br>&gt;         &gt; existing foo(), we might solve the problem by reimplementing<br>&gt;         foo(), and<br>&gt;         &gt; leaving the original foo() as dangling dead code. Having an<br>&gt;         ‘implement’<br>&gt;         &gt; keyword on the existing foo() function would change the compiler<br>&gt;         error to<br>&gt;         &gt; let us know that we have an existing foo() that is incorrectly<br>&gt;         declared.<br>&gt;         &gt;<br>&gt;         &gt; In addition, ‘implement’ can help us when the declaration in<br>&gt;         question *is*<br>&gt;         &gt; the default implementation:<br>&gt;         &gt;<br>&gt;         &gt; protocol P {<br>&gt;         &gt; func foo() -&gt; [String : Any]<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt; extension P {<br>&gt;         &gt; implement func foo() -&gt; [String : String] { return [:] }<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt; Here we will get an error with the proposed ‘implement’ keyword,<br>&gt;         because<br>&gt;         &gt; foo() does not have a signature matching anything in the<br>&gt;         protocol, whereas<br>&gt;         &gt; without ‘implement’ we would happily and silently generate a useless<br>&gt;         &gt; dangling function that would never be used, and then pass the<br>&gt;         buck to the<br>&gt;         &gt; concrete type that implements P:<br>&gt;         &gt;<br>&gt;         &gt; protocol P {<br>&gt;         &gt; func foo() -&gt; [String : Any]<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt; extension P {<br>&gt;         &gt; func foo() -&gt; [String : String] { return [:] } // The error is here:<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt; struct S : P {} // But it gets reported here.<br>&gt;         &gt;<br>&gt;         &gt; Charles<br>&gt;         &gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>September 20, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello everybody,<br></p><p>Several suggestions are floating around about explicitly marking a <br>method to implement a protocol requirement.<br></p><p>E.g.:<br></p><p>&gt; class Foo : Bar {<br>&gt; 	implement func foo() {...}<br>&gt; }<br></p><p>However, with extensions we can already do something very similar:<br></p><p>   class Foo {<br>       ....<br>   }<br>   extension Foo: Bar {<br>       func foo() {...}<br>   }<br></p><p>Maybe simply adding a new warning would already help.<br>Extensions which introduce new protocol conformances could be reserved <br>for those methods which are already defined within the protocol. <br>Whenever such an extension contains an unrecognized method, we could <br>issue a warning.<br>Or maybe even an error, but we should allow private methods as an <br>exception (for helper functions which are clearly not related to the <br>protocol).<br></p><p>This way, when the programmer wants to make sure that her new method is <br>used by a protocol then she can simply put that method in an extension.<br></p><p>-- <br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 20, 2016 at 03:00:00pm</p></header><div class="content"><p>I think that&#39;s a simple and elegant solution. The private member exception<br>can be extended so that any member with less visibility than the minimum of<br>the type and protocol visibility would be allowed.<br>On Tue, Sep 20, 2016 at 09:48 Martin Waitz &lt;tali at admingilde.org&gt; wrote:<br></p><p>&gt; Hello everybody,<br>&gt;<br>&gt; Several suggestions are floating around about explicitly marking a<br>&gt; method to implement a protocol requirement.<br>&gt;<br>&gt; E.g.:<br>&gt;<br>&gt; &gt; class Foo : Bar {<br>&gt; &gt;       implement func foo() {...}<br>&gt; &gt; }<br>&gt;<br>&gt; However, with extensions we can already do something very similar:<br>&gt;<br>&gt;    class Foo {<br>&gt;        ....<br>&gt;    }<br>&gt;    extension Foo: Bar {<br>&gt;        func foo() {...}<br>&gt;    }<br>&gt;<br>&gt; Maybe simply adding a new warning would already help.<br>&gt; Extensions which introduce new protocol conformances could be reserved<br>&gt; for those methods which are already defined within the protocol.<br>&gt; Whenever such an extension contains an unrecognized method, we could<br>&gt; issue a warning.<br>&gt; Or maybe even an error, but we should allow private methods as an<br>&gt; exception (for helper functions which are clearly not related to the<br>&gt; protocol).<br>&gt;<br>&gt; This way, when the programmer wants to make sure that her new method is<br>&gt; used by a protocol then she can simply put that method in an extension.<br>&gt;<br>&gt; --<br>&gt; Martin<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/16792afb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>September 20, 2016 at 03:00:00pm</p></header><div class="content"><p>+1. This is the cleanest proposed solution I&#39;ve seen to this problem. Like<br>many people, I&#39;ve started breaking up a lot of my large classes like view<br>controllers that have multiple protocol conformances into separate<br>extensions, and this would let many of those diagnostics fall out naturally.<br></p><p><br>On Tue, Sep 20, 2016 at 7:50 AM Martin Waitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello everybody,<br>&gt;<br>&gt; Several suggestions are floating around about explicitly marking a<br>&gt; method to implement a protocol requirement.<br>&gt;<br>&gt; E.g.:<br>&gt;<br>&gt; &gt; class Foo : Bar {<br>&gt; &gt;       implement func foo() {...}<br>&gt; &gt; }<br>&gt;<br>&gt; However, with extensions we can already do something very similar:<br>&gt;<br>&gt;    class Foo {<br>&gt;        ....<br>&gt;    }<br>&gt;    extension Foo: Bar {<br>&gt;        func foo() {...}<br>&gt;    }<br>&gt;<br>&gt; Maybe simply adding a new warning would already help.<br>&gt; Extensions which introduce new protocol conformances could be reserved<br>&gt; for those methods which are already defined within the protocol.<br>&gt; Whenever such an extension contains an unrecognized method, we could<br>&gt; issue a warning.<br>&gt; Or maybe even an error, but we should allow private methods as an<br>&gt; exception (for helper functions which are clearly not related to the<br>&gt; protocol).<br>&gt;<br>&gt; This way, when the programmer wants to make sure that her new method is<br>&gt; used by a protocol then she can simply put that method in an extension.<br>&gt;<br>&gt; --<br>&gt; Martin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/6d520df8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 20, 2016 at 06:00:00pm</p></header><div class="content"><p>On 20.09.2016 17:48, Martin Waitz wrote:<br>&gt; Hello everybody,<br>&gt;<br>&gt; Several suggestions are floating around about explicitly marking a method<br>&gt; to implement a protocol requirement.<br>&gt;<br>&gt; E.g.:<br>&gt;<br>&gt;&gt; class Foo : Bar {<br>&gt;&gt;     implement func foo() {...}<br>&gt;&gt; }<br>&gt;<br>&gt; However, with extensions we can already do something very similar:<br></p><p>Yes, I also mentioned it in one of the message. Personally I don&#39;t like <br>this solution but I do remember that someone from core team mentioned it.<br></p><p>It allows you to have &#39;safe&#39; code and &#39;unsafe&#39; - i.e. where you can be lazy <br>and don&#39;t provide more info for compiler and got later the problem with <br>protocol conformance we are discussing here; and you can have &#39;safe&#39; code <br>in extension - where compiler will help you.<br></p><p>Then, shouldn&#39;t we disallow protocol conformance &#39;in-place&#39; in type&#39;s <br>definition? So, if you need to conform to protocol - only extension is the <br>syntax for this. In this case I can understand the idea. Otherwise - can&#39;t.<br></p><p>So, if I want safe code this suggestion forces me to break my type&#39;s <br>definition to a number of extension blocks.<br>Right now there is a lot of code was written using &#39;in-place&#39; conformance <br>and not related to protocol methods in extensions. I believe there will be <br>a lot of work to apply for new rules.<br></p><p>And if I have public methods/props *logically* related to implemented <br>methods of protocol - I&#39;ll have to keep them in &#39;main&#39; definition or in <br>another extension.<br></p><p>Also what about marking default implementation methods in *protocol* <br>extension as was mentioned by Charles Srstka? I.e. in &quot;extension P {...}&quot;<br></p><p><br>&gt;<br>&gt;   class Foo {<br>&gt;       ....<br>&gt;   }<br>&gt;   extension Foo: Bar {<br>&gt;       func foo() {...}<br>&gt;   }<br>&gt;<br>&gt; Maybe simply adding a new warning would already help.<br>&gt; Extensions which introduce new protocol conformances could be reserved for<br>&gt; those methods which are already defined within the protocol. Whenever such<br>&gt; an extension contains an unrecognized method, we could issue a warning.<br>&gt; Or maybe even an error, but we should allow private methods as an exception<br>&gt; (for helper functions which are clearly not related to the protocol).<br>&gt;<br></p><p>&gt; This way, when the programmer wants to make sure that her new method is<br>&gt; used by a protocol then she can simply put that method in an extension.<br>&gt;<br></p><p>I wonder if *any* developer don&#39;t want to be sure the method she defined <br>exactly to implement protocol&#39;s requirement will be &quot;used by a protocol&quot;.<br></p><p>Something like &quot;I implemented this particular protocol&#39;s requirement in my <br>type... but.. you know, if something is changed in that protocol and <br>because of this the method will not play a role of implementation... not a <br>big problem, this is not very important code at all&quot;.  :-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>September 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 20, 2016, at 10:56 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Then, shouldn&#39;t we disallow protocol conformance &#39;in-place&#39; in type&#39;s definition? So, if you need to conform to protocol - only extension is the syntax for this. In this case I can understand the idea. Otherwise - can&#39;t.<br></p><p>You can’t completely restrict protocol conformance to extensions, because extensions can’t contained stored properties. Thus, to satisfy a protocol requirement with a stored property, it must be placed in the type’s definition.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/0d0c52da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 21, 2016 at 12:00:00am</p></header><div class="content"><p>On 20.09.2016 19:03, Charles Srstka wrote:<br>&gt;&gt; On Sep 20, 2016, at 10:56 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Then, shouldn&#39;t we disallow protocol conformance &#39;in-place&#39; in type&#39;s<br>&gt;&gt; definition? So, if you need to conform to protocol - only extension is<br>&gt;&gt; the syntax for this. In this case I can understand the idea. Otherwise -<br>&gt;&gt; can&#39;t.<br>&gt;<br>&gt; You can’t completely restrict protocol conformance to extensions, because<br>&gt; extensions can’t contained stored properties. Thus, to satisfy a protocol<br>&gt; requirement with a stored property, it must be placed in the type’s definition.<br></p><p>Oh, yes, of course.. And as soon as we can have default implementations for <br>props also - this solution can&#39;t help compiler to notify us if our property <br>defined as implementation for protocol requirement is not playing this role <br>any more.<br>Or we we need stored properties in extensions for this idea. As I <br>understand, there were some discussions regarding this.<br></p><p>In any case the solution &quot;protocol conformance in extensions&quot; does not help <br>when we deal with protocol default implementations - we can&#39;t say to <br>compiler that this method/prop here exactly as implementation for protocol, <br>not helper method. I.e. in this situation:<br></p><p>protocol A {<br>     func foov()<br>}<br></p><p>protocol B : A {<br>}<br></p><p>extension A {<br>     func foov() {}<br>}<br></p><p>extension B {<br>     // I was expecting this is a default implementation of foov() for B<br>     // but in reality this is a helper method<br>     // who knows when this error will be detected<br>     func foow() {}<br>}<br></p><p>I think protocol programming should not be so fragile as it is now and so <br>compiler should help in any place where it can help. For now I don&#39;t see <br>any better idea than require here some keyword like `override` or `implement`.<br></p><p>&gt;<br>&gt; Charles<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 19, 2016 at 09:00:00pm</p></header><div class="content"><p>+1<br></p><p>Sent from my iPhone<br></p><p>&gt; On 19 Sep 2016, at 18:10, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt; <br>&gt; Karl is suggesting interesting but complex and IMO too much code-breaking idea that I don&#39;t believe can be implemented at all in a reasonable amount of time to be a part of Swift as soon as possible, to address the discussed issue with protocols.<br>&gt; <br>&gt; I wonder what objections could be made on the solution proposed below, which should solve a major(IMO) number of issues with protocol conformance and introduce only 1 keyword. Such solution will make Swift better as Protocol-Oriented language and later we can even improve it, but it can already solve a big number of issues:<br>&gt; <br>&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to mark method/property that was defined in type or extension exactly to conform to some protocol.<br>&gt; <br>&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance, i.e. when you declare methods/props of the type/extension that explicitly conformed to protocol.<br>&gt; <br>&gt; 3. Retrospective conformance will not require this keyword and will work for now just like it is working today.<br>&gt; <br>&gt; 4. Later, if this will be possible at all, we can extend this model to support separate implementation of protocols with same requirements in the same type, explicit protocol name in implemented methods/props and improvements for retrospective conformance. For example some variants for *future* improvements:<br>&gt; <br>&gt; 4.1 Different implementation for different protocols<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement(ProtocolA) func foo() {...}<br>&gt;  implement(ProtocolB) func foo() {...}<br>&gt; }<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement ProtocolA {<br>&gt;    func foo() {...}<br>&gt;  }<br>&gt;  implement ProtocolB {<br>&gt;    func foo() {...}<br>&gt;  }<br>&gt; }<br>&gt; etc<br>&gt; <br>&gt; 4.2 Retrospective conformance: What is the main problem with retrospective conformance? As I see it now(correct me, if I missing something), the problem arises in such situation:<br>&gt; * we *expect* that some method(s) in type will play the role of implementation of protocol&#39;s requirements, so we retrospectively conform that type to the protocol.<br>&gt; * but protocol has default implementation for its requirements<br>&gt; * and type&#39;s methods, that we *expect* to play roles for protocol implementation, has different parameters or slightly different method name at all.<br>&gt; <br>&gt; I.e. when we have this set of code logic:<br>&gt; <br>&gt; type T {<br>&gt;  func foo()<br>&gt; }<br>&gt; <br>&gt; protocol P {<br>&gt;  func foo(x: Int)<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;  func foo(x: Int) {...}<br>&gt; }<br>&gt; <br>&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt; }<br>&gt; <br>&gt; I support the opinion that it is not an option to require to explicitly list conformed methods/props in type extension for retrospective conformance.<br>&gt; But I do believe we need a way to *express our intention* regarding the retrospective conformance: do we expect that type already contains implementation for some protocol&#39;s requirements OR we are aware that protocol can have defaults for some methods and our type does not contains some implementations.<br>&gt; <br>&gt; So, the solution here IMO is some syntax to express that intention. Right now I think that we can use current syntax &quot;extension T : P&quot; to keep it working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat this as usually you did&quot;. But for example something like &quot;extension T: implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we *expect* that all requirements of P protocol should be implemented inside T type. Or some syntax inside extension to specify the list of methods/props we expect to be implemented in T. Or &quot;extension T : P(implement foo, bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt; <br>&gt; But again, IMO this could be discussed later, after we&#39;ll have &#39;implement&#39; for most important place - in type definition for method/prop that we created exactly for the conformed protocol.<br>&gt; <br>&gt; Opinions?<br>&gt; <br>&gt;&gt; Currently, there is a JIRA bug that Set does not conform to SetAlgebra. To<br>&gt;&gt; fix this issue, someone simply needs to write `extension Set : SetAlgebra {<br>&gt;&gt; }` and some tests. That&#39;s literally what the bug (filed by a core team<br>&gt;&gt; member) tells you to do. It&#39;s a starter bug, and if someone hasn&#39;t taken it<br>&gt;&gt; yet, you the reader could have a go at it. What&#39;s neat about Swift is that<br>&gt;&gt; it&#39;s super easy to provide the same functionality in your own project<br>&gt;&gt; without waiting on that bug to be fixed in Swift itself. You can simply<br>&gt;&gt; write a single line of code. By contrast, if your proposal were to be<br>&gt;&gt; implemented, this would become much more difficult.<br>&gt;&gt; <br>&gt;&gt; This is actively used in Swift today. For example, in the Swift<br>&gt;&gt; implementation of NSScanner, you&#39;ll find the following lines:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; internal protocol _BitShiftable {<br>&gt;&gt;    static func &gt;&gt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;    static func &lt;&lt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal protocol _IntegerLike : Integer, _BitShiftable {<br>&gt;&gt;    init(_ value: Int)<br>&gt;&gt;    static var max: Self { get }<br>&gt;&gt;    static var min: Self { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int : _IntegerLike { }<br>&gt;&gt; extension Int32 : _IntegerLike { }<br>&gt;&gt; extension Int64 : _IntegerLike { }<br>&gt;&gt; extension UInt32 : _IntegerLike { }<br>&gt;&gt; extension UInt64 : _IntegerLike { }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; If we adopted your proposed syntax below, it would take considerably more<br>&gt;&gt; lines of boilerplate code to express the same thing. The burden increases<br>&gt;&gt; significantly with the complexity of the retroactive modeling. For<br>&gt;&gt; instance, if the retroactively modeled protocol had 20 requirements and you<br>&gt;&gt; were retroactively conforming 20 types, that&#39;d be at least 400 lines of<br>&gt;&gt; boilerplate.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Basically, the way I see it, if my class MyClass implements MyProtocol,<br>&gt;&gt;    providing someRequiredFunc(), there’s an “ownership” chain there<br>&gt;&gt;    (reading it backwards).<br>&gt;&gt; <br>&gt;&gt;    Now what happens if MyClass implements MyOtherProtocol, which also has<br>&gt;&gt;    someRequiredFunc()? In that case, I want to MyClass as a<br>&gt;&gt;    MyOtherProtocol and get another function pointer, which just happens to<br>&gt;&gt;    have the same human-readable name as some other property. Just because<br>&gt;&gt;    they have the same function signature, absolutely doesn’t mean they’re<br>&gt;&gt;    the same thing.<br>&gt;&gt; <br>&gt;&gt;    Now, if we strongly bind all protocol conformances to the protocol they<br>&gt;&gt;    implement, what happens to instance methods? They don’t belong to any<br>&gt;&gt;    protocol, their parent is the class itself. If you have an instance<br>&gt;&gt;    method called someRequiredFunc(), and you later add a conformance to<br>&gt;&gt;    MyProtocol, you would need to declare that it belongs to MyProtocol. If<br>&gt;&gt;    you don’t want it to be an API-breaking change, you have to provide a<br>&gt;&gt;    thunk (or we could provide a shorthand syntax which emits thunks for<br>&gt;&gt;    you) to let us know that MyClass::someRequiredFunc() is the same thing<br>&gt;&gt;    as MyClass::MyProtocol::someRequiredFunc().<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Your argument is that two methods with the same name should not in any way<br>&gt;&gt; conflict with each other. This is a fundamental change from the status quo.<br>&gt;&gt; If we were to take your argument to its logical conclusion, any member A of<br>&gt;&gt; a type T should be capable of being designated as the implementation of a<br>&gt;&gt; requirement B of protocol P. In the most general case, two functions A and<br>&gt;&gt; B shouldn&#39;t even need to take the same number of arguments, or arguments of<br>&gt;&gt; the same type; you should be able to supply default arguments, or even<br>&gt;&gt; write custom code that takes arguments for A and computes suitable<br>&gt;&gt; arguments for B in order to forward A to B, and the language should allow<br>&gt;&gt; you to designate A as an implementation of B. But that is simply not how<br>&gt;&gt; Swift protocols are designed.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    Let’s take an example where retroactive modelling could go wrong.<br>&gt;&gt;    You’ve got different teams working on different parts of an App, and<br>&gt;&gt;    they’ve all got their own convention for “copy()”. Sometimes it’s a<br>&gt;&gt;    deep-copy, sometimes a shallow-copy, sometimes it’s used in a fragile<br>&gt;&gt;    way for a specific case, whatever. Now you want to go and clean that up<br>&gt;&gt;    by creating a “Copyable” protocol with codified guarantees. Some<br>&gt;&gt;    objects may already conform, others may need tweaks, and some may want<br>&gt;&gt;    both behaviours simultaneously (preserving the old,<br>&gt;&gt;    non-Copytable-compliant behaviour until the next API break), depending<br>&gt;&gt;    on how you look at the object. A system like this allows all of those<br>&gt;&gt;    different ways of looking at the object live together. You could have<br>&gt;&gt;    the old, non-comforming API as an extension with a FIXME to delete it<br>&gt;&gt;    for version 2.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Even if you design a protocol called Copyable, you still need to explicitly<br>&gt;&gt; extend concrete types in order to conform to Copyable. Swift does not<br>&gt;&gt; automagically make anything conform to your protocol. If you choose<br>&gt;&gt; *explicitly* to conform different types that don&#39;t guarantee the same<br>&gt;&gt; semantics, and then you erroneously assume that they all have the same<br>&gt;&gt; semantics even though you *explicitly* chose types that don&#39;t have the same<br>&gt;&gt; semantics, you&#39;re the one who shot yourself in the foot, so to speak. It&#39;s<br>&gt;&gt; not the fault of Swift at all.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    I think it’s pretty arcane that members of a type are resolved only by<br>&gt;&gt;    their names. If you want to provide types which allow flexible views of<br>&gt;&gt;    data, each view of that data needs to be completely free in its<br>&gt;&gt;    expressivity.<br>&gt;&gt; <br>&gt;&gt;    I would actually like to see a syntax like:<br>&gt;&gt; <br>&gt;&gt;    ```<br>&gt;&gt;    let testObject = MyClass()<br>&gt;&gt;    let testMyProto = testObject.MyProtocol // the protocol-witness table<br>&gt;&gt;    for testObject as a MyProtocol.<br>&gt;&gt; <br>&gt;&gt;    testObject.MyProtocol.someRequiredFunc() // that’s one function<br>&gt;&gt;    testObject.someRequiredFunc() // is a different function. May happen to<br>&gt;&gt;    have the same implementation as above if MyProtocol was retroactively<br>&gt;&gt;    modelled.<br>&gt;&gt;    ```<br>&gt;&gt; <br>&gt;&gt;    I think it would fit well with the dispatch system for protocol<br>&gt;&gt;    extensions, too. I sometimes have code like the following:<br>&gt;&gt; <br>&gt;&gt;    ```<br>&gt;&gt;    protocol Base {}<br>&gt;&gt;    protocol Derived : Base {}<br>&gt;&gt; <br>&gt;&gt;    extension Base {<br>&gt;&gt;      func doSomething() { … }<br>&gt;&gt;    }<br>&gt;&gt;    extension Derived {<br>&gt;&gt;      func doSomething() {<br>&gt;&gt;       …<br>&gt;&gt;       (self as Base).doSomething() // Would be better if we could say<br>&gt;&gt;    “self.Base.doSomething()” to disambiguate instead of casting.<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt;    ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a complete redesign of protocols in Swift. With the emphasis on<br>&gt;&gt; minimizing source-breaking changes, I doubt such a change would be in scope<br>&gt;&gt; for any phase of Swift unless you could show an overwhelming benefit.<br>&gt;&gt; <br>&gt;&gt;    So yeah, a big +1 to marking protocol methods with their protocol<br>&gt;&gt;    (whatever the syntax ends up looking like), and actually I’d take it<br>&gt;&gt;    further and bake them in to the ABI. That also makes it relevant for<br>&gt;&gt;    Swift 4 phase 1.<br>&gt;&gt; <br>&gt;&gt;    Karl<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/01a9bff9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>Mark protocol methods with their protocol</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>September 20, 2016 at 12:00:00am</p></header><div class="content"><p>swift mixed implemention of protocol method and other method，this triggered<br>the problem.<br></p><p>Compiler can&#39;t judge mis-spelled method. It think it&#39;s a new method.<br></p><p>Rust has no this problem:<br></p><p>Impl protocolName for className {<br>.....<br>}<br></p><p>linter can&#39;t check for mis-spelled methods, on the condition that there&#39;s<br>no explicit override syntax in<br>Swift.<br></p><p><br>Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年9月20日<br>周二04:12写道：<br></p><p>&gt; +1<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 19 Sep 2016, at 18:10, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On 17.09.2016 6:32, Xiaodi Wu via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; Let me give a concrete example of how retroactively modeling is used.<br>&gt;<br>&gt;<br>&gt; Karl is suggesting interesting but complex and IMO too much code-breaking<br>&gt; idea that I don&#39;t believe can be implemented at all in a reasonable amount<br>&gt; of time to be a part of Swift as soon as possible, to address the discussed<br>&gt; issue with protocols.<br>&gt;<br>&gt; I wonder what objections could be made on the solution proposed below,<br>&gt; which should solve a major(IMO) number of issues with protocol conformance<br>&gt; and introduce only 1 keyword. Such solution will make Swift better as<br>&gt; Protocol-Oriented language and later we can even improve it, but it can<br>&gt; already solve a big number of issues:<br>&gt;<br>&gt; 1. As soon as possible we add &#39;implement&#39; keyword which is required to<br>&gt; mark method/property that was defined in type or extension exactly to<br>&gt; conform to some protocol.<br>&gt;<br>&gt; 2. The &#39;implement&#39; required only at a moment of &#39;direct&#39; conformance, i.e.<br>&gt; when you declare methods/props of the type/extension that explicitly<br>&gt; conformed to protocol.<br>&gt;<br>&gt; 3. Retrospective conformance will not require this keyword and will work<br>&gt; for now just like it is working today.<br>&gt;<br>&gt; 4. Later, if this will be possible at all, we can extend this model to<br>&gt; support separate implementation of protocols with same requirements in the<br>&gt; same type, explicit protocol name in implemented methods/props and<br>&gt; improvements for retrospective conformance. For example some variants for<br>&gt; *future* improvements:<br>&gt;<br>&gt; 4.1 Different implementation for different protocols<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement(ProtocolA) func foo() {...}<br>&gt;  implement(ProtocolB) func foo() {...}<br>&gt; }<br>&gt; class Foo : ProtocolA, ProtocolB {<br>&gt;  implement ProtocolA {<br>&gt;    func foo() {...}<br>&gt;  }<br>&gt;  implement ProtocolB {<br>&gt;    func foo() {...}<br>&gt;  }<br>&gt; }<br>&gt; etc<br>&gt;<br>&gt; 4.2 Retrospective conformance: What is the main problem with retrospective<br>&gt; conformance? As I see it now(correct me, if I missing something), the<br>&gt; problem arises in such situation:<br>&gt; * we *expect* that some method(s) in type will play the role of<br>&gt; implementation of protocol&#39;s requirements, so we retrospectively conform<br>&gt; that type to the protocol.<br>&gt; * but protocol has default implementation for its requirements<br>&gt; * and type&#39;s methods, that we *expect* to play roles for protocol<br>&gt; implementation, has different parameters or slightly different method name<br>&gt; at all.<br>&gt;<br>&gt; I.e. when we have this set of code logic:<br>&gt;<br>&gt; type T {<br>&gt;  func foo()<br>&gt; }<br>&gt;<br>&gt; protocol P {<br>&gt;  func foo(x: Int)<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;  func foo(x: Int) {...}<br>&gt; }<br>&gt;<br>&gt; extension T : P { // expect foo in T will play role of P.foo<br>&gt; }<br>&gt;<br>&gt; I support the opinion that it is not an option to require to explicitly<br>&gt; list conformed methods/props in type extension for retrospective<br>&gt; conformance.<br>&gt; But I do believe we need a way to *express our intention* regarding the<br>&gt; retrospective conformance: do we expect that type already contains<br>&gt; implementation for some protocol&#39;s requirements OR we are aware that<br>&gt; protocol can have defaults for some methods and our type does not contains<br>&gt; some implementations.<br>&gt;<br>&gt; So, the solution here IMO is some syntax to express that intention. Right<br>&gt; now I think that we can use current syntax &quot;extension T : P&quot; to keep it<br>&gt; working as it now works: &quot;I&#39;m aware of all the names, defaults etc. Treat<br>&gt; this as usually you did&quot;. But for example something like &quot;extension T:<br>&gt; implement P {..}&quot; or &quot;extension T: P(implement *) {..}&quot; will say that we<br>&gt; *expect* that all requirements of P protocol should be implemented inside T<br>&gt; type. Or some syntax inside extension to specify the list of methods/props<br>&gt; we expect to be implemented in T. Or &quot;extension T : P(implement foo,<br>&gt; bar(x:y:)) {..}&quot;.. Should be discussed.<br>&gt;<br>&gt; But again, IMO this could be discussed later, after we&#39;ll have &#39;implement&#39;<br>&gt; for most important place - in type definition for method/prop that we<br>&gt; created exactly for the conformed protocol.<br>&gt;<br>&gt; Opinions?<br>&gt;<br>&gt; Currently, there is a JIRA bug that Set does not conform to SetAlgebra. To<br>&gt;<br>&gt; fix this issue, someone simply needs to write `extension Set : SetAlgebra {<br>&gt;<br>&gt; }` and some tests. That&#39;s literally what the bug (filed by a core team<br>&gt;<br>&gt; member) tells you to do. It&#39;s a starter bug, and if someone hasn&#39;t taken it<br>&gt;<br>&gt; yet, you the reader could have a go at it. What&#39;s neat about Swift is that<br>&gt;<br>&gt; it&#39;s super easy to provide the same functionality in your own project<br>&gt;<br>&gt; without waiting on that bug to be fixed in Swift itself. You can simply<br>&gt;<br>&gt; write a single line of code. By contrast, if your proposal were to be<br>&gt;<br>&gt; implemented, this would become much more difficult.<br>&gt;<br>&gt;<br>&gt; This is actively used in Swift today. For example, in the Swift<br>&gt;<br>&gt; implementation of NSScanner, you&#39;ll find the following lines:<br>&gt;<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; internal protocol _BitShiftable {<br>&gt;<br>&gt;    static func &gt;&gt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;<br>&gt;    static func &lt;&lt;(lhs: Self, rhs: Self) -&gt; Self<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; internal protocol _IntegerLike : Integer, _BitShiftable {<br>&gt;<br>&gt;    init(_ value: Int)<br>&gt;<br>&gt;    static var max: Self { get }<br>&gt;<br>&gt;    static var min: Self { get }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension Int : _IntegerLike { }<br>&gt;<br>&gt; extension Int32 : _IntegerLike { }<br>&gt;<br>&gt; extension Int64 : _IntegerLike { }<br>&gt;<br>&gt; extension UInt32 : _IntegerLike { }<br>&gt;<br>&gt; extension UInt64 : _IntegerLike { }<br>&gt;<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; If we adopted your proposed syntax below, it would take considerably more<br>&gt;<br>&gt; lines of boilerplate code to express the same thing. The burden increases<br>&gt;<br>&gt; significantly with the complexity of the retroactive modeling. For<br>&gt;<br>&gt; instance, if the retroactively modeled protocol had 20 requirements and you<br>&gt;<br>&gt; were retroactively conforming 20 types, that&#39;d be at least 400 lines of<br>&gt;<br>&gt; boilerplate.<br>&gt;<br>&gt;<br>&gt;<br>&gt;    Basically, the way I see it, if my class MyClass implements MyProtocol,<br>&gt;<br>&gt;    providing someRequiredFunc(), there’s an “ownership” chain there<br>&gt;<br>&gt;    (reading it backwards).<br>&gt;<br>&gt;<br>&gt;    Now what happens if MyClass implements MyOtherProtocol, which also has<br>&gt;<br>&gt;    someRequiredFunc()? In that case, I want to MyClass as a<br>&gt;<br>&gt;    MyOtherProtocol and get another function pointer, which just happens to<br>&gt;<br>&gt;    have the same human-readable name as some other property. Just because<br>&gt;<br>&gt;    they have the same function signature, absolutely doesn’t mean they’re<br>&gt;<br>&gt;    the same thing.<br>&gt;<br>&gt;<br>&gt;    Now, if we strongly bind all protocol conformances to the protocol they<br>&gt;<br>&gt;    implement, what happens to instance methods? They don’t belong to any<br>&gt;<br>&gt;    protocol, their parent is the class itself. If you have an instance<br>&gt;<br>&gt;    method called someRequiredFunc(), and you later add a conformance to<br>&gt;<br>&gt;    MyProtocol, you would need to declare that it belongs to MyProtocol. If<br>&gt;<br>&gt;    you don’t want it to be an API-breaking change, you have to provide a<br>&gt;<br>&gt;    thunk (or we could provide a shorthand syntax which emits thunks for<br>&gt;<br>&gt;    you) to let us know that MyClass::someRequiredFunc() is the same thing<br>&gt;<br>&gt;    as MyClass::MyProtocol::someRequiredFunc().<br>&gt;<br>&gt;<br>&gt;<br>&gt; Your argument is that two methods with the same name should not in any way<br>&gt;<br>&gt; conflict with each other. This is a fundamental change from the status quo.<br>&gt;<br>&gt; If we were to take your argument to its logical conclusion, any member A of<br>&gt;<br>&gt; a type T should be capable of being designated as the implementation of a<br>&gt;<br>&gt; requirement B of protocol P. In the most general case, two functions A and<br>&gt;<br>&gt; B shouldn&#39;t even need to take the same number of arguments, or arguments of<br>&gt;<br>&gt; the same type; you should be able to supply default arguments, or even<br>&gt;<br>&gt; write custom code that takes arguments for A and computes suitable<br>&gt;<br>&gt; arguments for B in order to forward A to B, and the language should allow<br>&gt;<br>&gt; you to designate A as an implementation of B. But that is simply not how<br>&gt;<br>&gt; Swift protocols are designed.<br>&gt;<br>&gt;<br>&gt;<br>&gt;    Let’s take an example where retroactive modelling could go wrong.<br>&gt;<br>&gt;    You’ve got different teams working on different parts of an App, and<br>&gt;<br>&gt;    they’ve all got their own convention for “copy()”. Sometimes it’s a<br>&gt;<br>&gt;    deep-copy, sometimes a shallow-copy, sometimes it’s used in a fragile<br>&gt;<br>&gt;    way for a specific case, whatever. Now you want to go and clean that up<br>&gt;<br>&gt;    by creating a “Copyable” protocol with codified guarantees. Some<br>&gt;<br>&gt;    objects may already conform, others may need tweaks, and some may want<br>&gt;<br>&gt;    both behaviours simultaneously (preserving the old,<br>&gt;<br>&gt;    non-Copytable-compliant behaviour until the next API break), depending<br>&gt;<br>&gt;    on how you look at the object. A system like this allows all of those<br>&gt;<br>&gt;    different ways of looking at the object live together. You could have<br>&gt;<br>&gt;    the old, non-comforming API as an extension with a FIXME to delete it<br>&gt;<br>&gt;    for version 2.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Even if you design a protocol called Copyable, you still need to explicitly<br>&gt;<br>&gt; extend concrete types in order to conform to Copyable. Swift does not<br>&gt;<br>&gt; automagically make anything conform to your protocol. If you choose<br>&gt;<br>&gt; *explicitly* to conform different types that don&#39;t guarantee the same<br>&gt;<br>&gt; semantics, and then you erroneously assume that they all have the same<br>&gt;<br>&gt; semantics even though you *explicitly* chose types that don&#39;t have the same<br>&gt;<br>&gt; semantics, you&#39;re the one who shot yourself in the foot, so to speak. It&#39;s<br>&gt;<br>&gt; not the fault of Swift at all.<br>&gt;<br>&gt;<br>&gt;<br>&gt;    I think it’s pretty arcane that members of a type are resolved only by<br>&gt;<br>&gt;    their names. If you want to provide types which allow flexible views of<br>&gt;<br>&gt;    data, each view of that data needs to be completely free in its<br>&gt;<br>&gt;    expressivity.<br>&gt;<br>&gt;<br>&gt;    I would actually like to see a syntax like:<br>&gt;<br>&gt;<br>&gt;    ```<br>&gt;<br>&gt;    let testObject = MyClass()<br>&gt;<br>&gt;    let testMyProto = testObject.MyProtocol // the protocol-witness table<br>&gt;<br>&gt;    for testObject as a MyProtocol.<br>&gt;<br>&gt;<br>&gt;    testObject.MyProtocol.someRequiredFunc() // that’s one function<br>&gt;<br>&gt;    testObject.someRequiredFunc() // is a different function. May happen to<br>&gt;<br>&gt;    have the same implementation as above if MyProtocol was retroactively<br>&gt;<br>&gt;    modelled.<br>&gt;<br>&gt;    ```<br>&gt;<br>&gt;<br>&gt;    I think it would fit well with the dispatch system for protocol<br>&gt;<br>&gt;    extensions, too. I sometimes have code like the following:<br>&gt;<br>&gt;<br>&gt;    ```<br>&gt;<br>&gt;    protocol Base {}<br>&gt;<br>&gt;    protocol Derived : Base {}<br>&gt;<br>&gt;<br>&gt;    extension Base {<br>&gt;<br>&gt;      func doSomething() { … }<br>&gt;<br>&gt;    }<br>&gt;<br>&gt;    extension Derived {<br>&gt;<br>&gt;      func doSomething() {<br>&gt;<br>&gt;       …<br>&gt;<br>&gt;       (self as Base).doSomething() // Would be better if we could say<br>&gt;<br>&gt;    “self.Base.doSomething()” to disambiguate instead of casting.<br>&gt;<br>&gt;      }<br>&gt;<br>&gt;    }<br>&gt;<br>&gt;    ```<br>&gt;<br>&gt;<br>&gt;<br>&gt; This is a complete redesign of protocols in Swift. With the emphasis on<br>&gt;<br>&gt; minimizing source-breaking changes, I doubt such a change would be in scope<br>&gt;<br>&gt; for any phase of Swift unless you could show an overwhelming benefit.<br>&gt;<br>&gt;<br>&gt;    So yeah, a big +1 to marking protocol methods with their protocol<br>&gt;<br>&gt;    (whatever the syntax ends up looking like), and actually I’d take it<br>&gt;<br>&gt;    further and bake them in to the ABI. That also makes it relevant for<br>&gt;<br>&gt;    Swift 4 phase 1.<br>&gt;<br>&gt;<br>&gt;    Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/df72d1a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
