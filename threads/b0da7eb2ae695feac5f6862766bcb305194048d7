<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;<br></p><p>Rejection: &quot;The feedback on the proposal was generally positive about the idea of renaming these protocols, but the specific names in the proposal are not well received, and there is no apparent confluence in the community on better names.  The core team prefers discussion to continue -- if/when there is a strong proposal for a better naming approach, we can reconsider renaming these.&quot;<br></p><p>John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag the conversation into the muck again. :)  It&#39;s the design of the requirements that I&#39;m pretty opposed to revisiting.&quot;<br></p><p>The Problem: This is really the last chance to rationalize this across the language and to evaluate whether other protocol groups should have a core scheme for naming.<br></p><p>Categories:<br>Type I: A protocol for types that can be initialized from specific types or protocols, e.g. created/initialized with strings (a specific type) or created/initialized with floating point numbers (conforming to a protocol). Current examples include &quot;IntegerLiteralConvertible&quot;.<br>Type II: A protocol for types that can form a representation which may or may not provide a complete projection (the original may not be recoverable from that representation), e.g. &quot;CustomStringConvertible&quot; and &quot;CustomPlaygroundQuickLookable&quot; both fall into this. <br>Type III: A protocol for isomorphism: can be converted to and from a type, e.g. &quot;RawRepresentable&quot;<br></p><p>Existing Protocols:<br></p><p>AbsoluteValuable, AnyCollectionProtocol, AnyObject, ArrayLiteralConvertible, BidirectionalCollection, Collection, BidirectionalIndexable, BinaryFloatingPoint, FloatLiteralConvertible, BitwiseOperations, Boolean, BooleanLiteralConvertible, CVarArg, Collection, Sequence, Comparable, CustomDebugStringConvertible, CustomLeafReflectable, CustomPlaygroundQuickLookable, CustomReflectable, CustomStringConvertible, DictionaryLiteralConvertible, Equatable, ErrorProtocol, ExtendedGraphemeClusterLiteralConvertible, FloatLiteralConvertible, FloatingPoint, IntegerLiteralConvertible, SignedNumber, AbsoluteValuable, Strideable, Hashable, Indexable, IndexableBase, Integer : _Integer, Strideable, IntegerArithmetic : _IntegerArithmetic, Comparable, IntegerLiteralConvertible, IteratorProtocol, LazyCollectionProtocol, LazySequenceProtocol, LazySequenceProtocol, MirrorPath, MutableCollection, Collection, MutableIndexable, NilLiteralConvertible, OptionSet, RawRepresentable, OutputStream, RandomAccessCollection, BidirectionalCollection, RandomAccessIndexable, RangeReplaceableCollection, Collection, RangeReplaceableIndexable, RawRepresentable, Sequence, SetAlgebra, ArrayLiteralConvertible, SignedInteger : _SignedInteger, Integer, SignedNumber, IntegerLiteralConvertible, Streamable, Strideable, StringInterpolationConvertible, StringLiteralConvertible, UnicodeCodec, UnicodeScalarLiteralConvertible, UnsignedInteger : _DisallowMixedSignArithmetic, Integer, _DisallowMixedSignArithmetic : _Integer, _Incrementable, _Integer, CustomStringConvertible, Hashable, IntegerArithmetic, BitwiseOperations, _Incrementable, _IntegerArithmetic, _SequenceWrapper, _SignedInteger : _Integer, SignedNumber<br></p><p><br>Names (see: https://pbs.twimg.com/media/Ck8TUt0UkAAX1Im.jpg &lt;https://pbs.twimg.com/media/Ck8TUt0UkAAX1Im.jpg&gt;)<br></p><p>Type I: Initializing<br>Type II: Representable<br>Type III: Isomorphic<br></p><p>Here&#39;s a paint brush. Have at it. And keep in mind the API-isms like &quot;use nouns&quot; (e.g. Sequence vs SequenceType) and &quot;ing&quot; (e.g. Initializing vs Initializable)<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/b0da48d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 22, 2016 at 06:00:00pm</p></header><div class="content"><p>Quick thoughts:<br></p><p>Isomorphic is a delightful word.<br></p><p>Initializing has the wrong meaning, I think. If A conforms to<br>BInitializing, that reads to me like you can do B(A), not necessarily A(B).<br>By contrast, BInitializable conveys more clearly the sense that A can be<br>initialized with an argument of type B.<br>On Wed, Jun 22, 2016 at 13:04 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; *Proposal*:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;<br>&gt; *Rejection*: &quot;The feedback on the proposal was generally positive about<br>&gt; the idea of renaming these protocols, but the specific names in the<br>&gt; proposal are not well received, and there is no apparent confluence in the<br>&gt; community on better names.  The core team prefers discussion to continue --<br>&gt; if/when there is a strong proposal for a better naming approach, we can<br>&gt; reconsider renaming these.&quot;<br>&gt;<br>&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t<br>&gt; drag the conversation into the muck again. :)  It&#39;s the design of the<br>&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;<br>&gt; *The Problem: *This is really the last chance to rationalize this across<br>&gt; the language and to evaluate whether other protocol groups should have a<br>&gt; core scheme for naming.<br>&gt;<br>&gt; *Categories:*<br>&gt;<br>&gt;    - Type I: A protocol for types that can be initialized from specific<br>&gt;    types or protocols, e.g. created/initialized with strings (a specific type)<br>&gt;    or created/initialized with floating point numbers (conforming to a<br>&gt;    protocol). Current examples include &quot;IntegerLiteralConvertible&quot;.<br>&gt;    - Type II: A protocol for types that can form a representation which<br>&gt;    may or may not provide a complete projection (the original may not be<br>&gt;    recoverable from that representation), e.g. &quot;CustomStringConvertible&quot; and<br>&gt;    &quot;CustomPlaygroundQuickLookable&quot; both fall into this.<br>&gt;    - Type III: A protocol for isomorphism: can be converted to and from a<br>&gt;    type, e.g. &quot;RawRepresentable&quot;<br>&gt;<br>&gt;<br>&gt; *Existing Protocols:*<br>&gt;<br>&gt; AbsoluteValuable, AnyCollectionProtocol, AnyObject,<br>&gt; ArrayLiteralConvertible, BidirectionalCollection, Collection,<br>&gt; BidirectionalIndexable, BinaryFloatingPoint, FloatLiteralConvertible,<br>&gt; BitwiseOperations, Boolean, BooleanLiteralConvertible, CVarArg, Collection,<br>&gt; Sequence, Comparable, CustomDebugStringConvertible, CustomLeafReflectable,<br>&gt; CustomPlaygroundQuickLookable, CustomReflectable, CustomStringConvertible,<br>&gt; DictionaryLiteralConvertible, Equatable, ErrorProtocol,<br>&gt; ExtendedGraphemeClusterLiteralConvertible, FloatLiteralConvertible,<br>&gt; FloatingPoint, IntegerLiteralConvertible, SignedNumber, AbsoluteValuable,<br>&gt; Strideable, Hashable, Indexable, IndexableBase, Integer : _Integer,<br>&gt; Strideable, IntegerArithmetic : _IntegerArithmetic, Comparable,<br>&gt; IntegerLiteralConvertible, IteratorProtocol, LazyCollectionProtocol,<br>&gt; LazySequenceProtocol, LazySequenceProtocol, MirrorPath, MutableCollection,<br>&gt; Collection, MutableIndexable, NilLiteralConvertible, OptionSet,<br>&gt; RawRepresentable, OutputStream, RandomAccessCollection,<br>&gt; BidirectionalCollection, RandomAccessIndexable, RangeReplaceableCollection,<br>&gt; Collection, RangeReplaceableIndexable, RawRepresentable, Sequence,<br>&gt; SetAlgebra, ArrayLiteralConvertible, SignedInteger : _SignedInteger,<br>&gt; Integer, SignedNumber, IntegerLiteralConvertible, Streamable, Strideable,<br>&gt; StringInterpolationConvertible, StringLiteralConvertible, UnicodeCodec,<br>&gt; UnicodeScalarLiteralConvertible, UnsignedInteger :<br>&gt; _DisallowMixedSignArithmetic, Integer, _DisallowMixedSignArithmetic :<br>&gt; _Integer, _Incrementable, _Integer, CustomStringConvertible, Hashable,<br>&gt; IntegerArithmetic, BitwiseOperations, _Incrementable, _IntegerArithmetic,<br>&gt; _SequenceWrapper, _SignedInteger : _Integer, SignedNumber<br>&gt;<br>&gt;<br>&gt; *Names (see: https://pbs.twimg.com/media/Ck8TUt0UkAAX1Im.jpg<br>&gt; &lt;https://pbs.twimg.com/media/Ck8TUt0UkAAX1Im.jpg&gt;)*<br>&gt;<br>&gt; Type I: Initializing<br>&gt; Type II: Representable<br>&gt; Type III: Isomorphic<br>&gt;<br>&gt; Here&#39;s a paint brush. Have at it. And keep in mind the API-isms like &quot;use<br>&gt; nouns&quot; (e.g. Sequence vs SequenceType) and &quot;ing&quot; (e.g. Initializing vs<br>&gt; Initializable)<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/aa91ae59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 1:40 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Quick thoughts:<br>&gt; <br>&gt; Isomorphic is a delightful word.<br>&gt; <br>&gt; Initializing has the wrong meaning, I think. If A conforms to BInitializing, that reads to me like you can do B(A), not necessarily A(B). By contrast, BInitializable conveys more clearly the sense that A can be initialized with an argument of type B.<br></p><p>Yeah, I’d be inclined to name it “InitableFromB” rather than “BInitializing”.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 22, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;<br>&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt; not well received, and there is no apparent confluence in the community on<br>&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt; renaming these.&quot;<br>&gt;<br>&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;<br>&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt; language and to evaluate whether other protocol groups should have a core<br>&gt; scheme for naming.<br></p><p>Hi Erica,<br></p><p>I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>and me from the last time this was discussed.  Unfortunately I can&#39;t<br>find the exact email, so I can&#39;t provide a link.<br></p><p>- The &quot;literal&quot; protocols are not about conversion, they are about<br>adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>the name is a red herring: a type can&#39;t be convertible from an integer<br>literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>system.  The literal *becomes* typed as the corresponding literal type<br>(e.g., Int or String), and as far as the user at the call site is<br>concerned, there is no visible conversion (even if one is happening<br>behind the scenes).<br></p><p>Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>suggested moving the &quot;literal convertible&quot; protocols into a<br>pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br></p><p>protocol _IntegerLiteralSyntax {}<br>enum Syntax {<br>  typealias IntegerLiteral = _IntegerLiteralSyntax<br>}<br></p><p>And used like this:<br></p><p>struct Int : Syntax.IntegerLiteral {}<br></p><p>- For protocols that are representing conversions between types that<br>actually exist in the library, there is not enough precedent yet to<br>make a general conclusion and standardize a pattern.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt; find the exact email, so I can&#39;t provide a link.<br>&gt; <br>&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt; concerned, there is no visible conversion (even if one is happening<br>&gt; behind the scenes).<br>&gt; <br>&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt; <br>&gt; protocol _IntegerLiteralSyntax {}<br>&gt; enum Syntax {<br>&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt; }<br>&gt; <br>&gt; And used like this:<br>&gt; <br>&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt; <br>&gt; - For protocols that are representing conversions between types that<br>&gt; actually exist in the library, there is not enough precedent yet to<br>&gt; make a general conclusion and standardize a pattern.<br></p><p>I’m not sure I understand… In this example, has “IntegerLiteralConvertible” been renamed to “_IntegerLiteralSyntax”? If not, what’s it’s definition?<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 22, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 12:57 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Erica,<br>&gt;&gt;<br>&gt;&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt;&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt;&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;&gt;<br>&gt;&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt;&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt;&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt;&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt;&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt;&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt;&gt; concerned, there is no visible conversion (even if one is happening<br>&gt;&gt; behind the scenes).<br>&gt;&gt;<br>&gt;&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt;&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt;&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;&gt;<br>&gt;&gt; protocol _IntegerLiteralSyntax {}<br>&gt;&gt; enum Syntax {<br>&gt;&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; And used like this:<br>&gt;&gt;<br>&gt;&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;&gt;<br>&gt;&gt; - For protocols that are representing conversions between types that<br>&gt;&gt; actually exist in the library, there is not enough precedent yet to<br>&gt;&gt; make a general conclusion and standardize a pattern.<br>&gt;<br>&gt; I’m not sure I understand… In this example, has “IntegerLiteralConvertible” been renamed to “_IntegerLiteralSyntax”?<br></p><p>That&#39;s right.  But we want users to refer to the protocol as<br>&#39;Syntax.IntegerLiteral&#39;.  If/once we get either submodules or<br>protocols nested in enums, we can move the actual definition to be<br>nested.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 22, 2016 at 07:00:00pm</p></header><div class="content"><p>That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that the intended name? Also, why an enum? Especially one without any cases...<br></p><p>Was all this already discussed in a thread that I missed (or have otherwise forgotten about)?<br></p><p>- Dave Sweeris<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 22, 2016, at 15:54, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Wed, Jun 22, 2016 at 12:57 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt;&gt;&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt;&gt;&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt;&gt;&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt;&gt;&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt;&gt;&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt;&gt;&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt;&gt;&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt;&gt;&gt; concerned, there is no visible conversion (even if one is happening<br>&gt;&gt;&gt; behind the scenes).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt;&gt;&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt;&gt;&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol _IntegerLiteralSyntax {}<br>&gt;&gt;&gt; enum Syntax {<br>&gt;&gt;&gt; typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And used like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For protocols that are representing conversions between types that<br>&gt;&gt;&gt; actually exist in the library, there is not enough precedent yet to<br>&gt;&gt;&gt; make a general conclusion and standardize a pattern.<br>&gt;&gt; <br>&gt;&gt; I’m not sure I understand… In this example, has “IntegerLiteralConvertible” been renamed to “_IntegerLiteralSyntax”?<br>&gt; <br>&gt; That&#39;s right.  But we want users to refer to the protocol as<br>&gt; &#39;Syntax.IntegerLiteral&#39;.  If/once we get either submodules or<br>&gt; protocols nested in enums, we can move the actual definition to be<br>&gt; nested.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that the intended name?<br></p><p>It is the best name we could come up with, we are open to better suggestions.<br></p><p>&gt; Also, why an enum? Especially one without any cases...<br></p><p>It is not possible to create an instance of an enum that does not have<br>cases.  It becomes essentially a namespace.<br></p><p>&gt; Was all this already discussed in a thread that I missed (or have otherwise forgotten about)?<br></p><p>This feedback was provided in one of the threads about SE-0041, but I<br>can&#39;t find the link.  It did not get much discussion at that time.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 23, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that the intended name?<br>&gt; <br>&gt; It is the best name we could come up with, we are open to better suggestions.<br></p><p>I guess it depends on the intended semantics of the &quot;namespace&quot;. If the purpose is to be a container for the various LiteralConvertible protocols, then maybe something like `AcceptsLiteralType.Integer` might be better? It&#39;s a bit wordy, though.<br></p><p><br>&gt;&gt; Also, why an enum? Especially one without any cases...<br>&gt; <br>&gt; It is not possible to create an instance of an enum that does not have<br>&gt; cases.  It becomes essentially a namespace.<br></p><p>Oh that&#39;s a clever work-around. I like it :-)<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 04:00:00am</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 1:26 AM, David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that<br>&gt; the intended name?<br>&gt; &gt;<br>&gt; &gt; It is the best name we could come up with, we are open to better<br>&gt; suggestions.<br>&gt;<br>&gt; I guess it depends on the intended semantics of the &quot;namespace&quot;. If the<br>&gt; purpose is to be a container for the various LiteralConvertible protocols,<br>&gt; then maybe something like `AcceptsLiteralType.Integer` might be better?<br>&gt; It&#39;s a bit wordy, though.<br>&gt;<br></p><p>I get what&#39;s being aimed at here, but I think the meaning of `Syntax` in<br>this context is indecipherable. IIUC, the point to be conveyed by the term<br>is that a literal has no type until it is supplied as an argument to the<br>initializer and becomes typed. Maybe we could say that the type gives form<br>to the literal or embodies the literal? Thus maybe a name like<br>`IntegerLiteralEmbodiment` or `IntegerLiteralManifestation`, maybe even<br>`IntegerLiteralModeling`.<br></p><p><br>&gt;<br>&gt;<br>&gt; &gt;&gt; Also, why an enum? Especially one without any cases...<br>&gt; &gt;<br>&gt; &gt; It is not possible to create an instance of an enum that does not have<br>&gt; &gt; cases.  It becomes essentially a namespace.<br>&gt;<br>&gt; Oh that&#39;s a clever work-around. I like it :-)<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ef5782e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 23, 2016 at 02:00:00am</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 2:00 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Jun 23, 2016 at 1:26 AM, David Sweeris via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that<br>&gt;&gt; &gt;&gt; the intended name?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It is the best name we could come up with, we are open to better<br>&gt;&gt; &gt; suggestions.<br>&gt;&gt;<br>&gt;&gt; I guess it depends on the intended semantics of the &quot;namespace&quot;. If the<br>&gt;&gt; purpose is to be a container for the various LiteralConvertible protocols,<br>&gt;&gt; then maybe something like `AcceptsLiteralType.Integer` might be better? It&#39;s<br>&gt;&gt; a bit wordy, though.<br>&gt;<br>&gt;<br>&gt; I get what&#39;s being aimed at here, but I think the meaning of `Syntax` in<br>&gt; this context is indecipherable. IIUC, the point to be conveyed by the term<br>&gt; is that a literal has no type until it is supplied as an argument to the<br>&gt; initializer and becomes typed.<br></p><p>The point of using &quot;Syntax&quot; is to emphasize that this protocol is for<br>integration with the language syntax.  The &quot;Syntax&quot; pseudo-namespace<br>groups protocols that provide a special kind of a capability --<br>changing the meaning of builtin language syntax.  This protocol is not<br>meant to be coded against, used in other APIs or handled by the code<br>in any other way except by being adopted (except maybe in the standard<br>library code itself).<br></p><p>Should we add any other compiler interfaces that affect how builtin<br>syntax works, they would also go into the &quot;Syntax&quot; namespace.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 05:00:00am</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 4:34 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Thu, Jun 23, 2016 at 2:00 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt; On Thu, Jun 23, 2016 at 1:26 AM, David Sweeris via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; &gt;&gt; &gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is<br>&gt; that<br>&gt; &gt;&gt; &gt;&gt; the intended name?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; It is the best name we could come up with, we are open to better<br>&gt; &gt;&gt; &gt; suggestions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I guess it depends on the intended semantics of the &quot;namespace&quot;. If the<br>&gt; &gt;&gt; purpose is to be a container for the various LiteralConvertible<br>&gt; protocols,<br>&gt; &gt;&gt; then maybe something like `AcceptsLiteralType.Integer` might be better?<br>&gt; It&#39;s<br>&gt; &gt;&gt; a bit wordy, though.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I get what&#39;s being aimed at here, but I think the meaning of `Syntax` in<br>&gt; &gt; this context is indecipherable. IIUC, the point to be conveyed by the<br>&gt; term<br>&gt; &gt; is that a literal has no type until it is supplied as an argument to the<br>&gt; &gt; initializer and becomes typed.<br>&gt;<br>&gt; The point of using &quot;Syntax&quot; is to emphasize that this protocol is for<br>&gt; integration with the language syntax.  The &quot;Syntax&quot; pseudo-namespace<br>&gt; groups protocols that provide a special kind of a capability --<br>&gt; changing the meaning of builtin language syntax.  This protocol is not<br>&gt; meant to be coded against, used in other APIs or handled by the code<br>&gt; in any other way except by being adopted (except maybe in the standard<br>&gt; library code itself).<br>&gt;<br></p><p>This makes a lot of sense now after your expanded explanation. I still<br>think, though, that the name reads rather absurdly. Most charitably, your<br>types would conform to &quot;integer literal syntax,&quot; whatever that means.<br>Visually, it looks like your types &quot;conform to Syntax.&quot; Could I suggest<br>maybe `SyntacticIntegration` or `SyntaxIntegrating`? Something along those<br>lines.<br></p><p>Should we add any other compiler interfaces that affect how builtin<br>&gt; syntax works, they would also go into the &quot;Syntax&quot; namespace.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/9d5c13be/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>I like how your suggestion reads. It will namespace all literal<br>convertibles while also reading more clearly on what conforming to the<br>protocol implies. I now understand the intent of the Syntax namespace<br>however I think you suggested naming would be better.<br></p><p>-Shawn<br></p><p>On Wed, Jun 22, 2016 at 11:26 PM David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 22, 2016, at 19:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Wed, Jun 22, 2016 at 5:15 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; That&#39;s a really interesting idea. Is &quot;Syntax&quot; a placeholder, or is that<br>&gt; the intended name?<br>&gt; &gt;<br>&gt; &gt; It is the best name we could come up with, we are open to better<br>&gt; suggestions.<br>&gt;<br>&gt; I guess it depends on the intended semantics of the &quot;namespace&quot;. If the<br>&gt; purpose is to be a container for the various LiteralConvertible protocols,<br>&gt; then maybe something like `AcceptsLiteralType.Integer` might be better?<br>&gt; It&#39;s a bit wordy, though.<br>&gt;<br>&gt;<br>&gt; &gt;&gt; Also, why an enum? Especially one without any cases...<br>&gt; &gt;<br>&gt; &gt; It is not possible to create an instance of an enum that does not have<br>&gt; &gt; cases.  It becomes essentially a namespace.<br>&gt;<br>&gt; Oh that&#39;s a clever work-around. I like it :-)<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/f8db779f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Proposal:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt; <br>&gt;&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt;&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt;&gt; not well received, and there is no apparent confluence in the community on<br>&gt;&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt;&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt;&gt; renaming these.&quot;<br>&gt;&gt; <br>&gt;&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt;&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt;&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt;&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;&gt; <br>&gt;&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt;&gt; language and to evaluate whether other protocol groups should have a core<br>&gt;&gt; scheme for naming.<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt; find the exact email, so I can&#39;t provide a link.<br>&gt; <br>&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt; concerned, there is no visible conversion (even if one is happening<br>&gt; behind the scenes).<br>&gt; <br>&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt; <br>&gt; protocol _IntegerLiteralSyntax {}<br>&gt; enum Syntax {<br>&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt; }<br>&gt; <br>&gt; And used like this:<br>&gt; <br>&gt; struct Int : Syntax.IntegerLiteral {}<br></p><p>Is anyone on the core team planning to write up a proposal for this change?  If not, I will be happy to do it.  It solves the biggest issue I have with the current state (two different meanings for “Convertible”).  I will be happy to see this solved while we’re making breaking changes. :)<br></p><p>&gt; <br>&gt; - For protocols that are representing conversions between types that<br>&gt; actually exist in the library, there is not enough precedent yet to<br>&gt; make a general conclusion and standardize a pattern.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/34636060/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 4:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; protocol _IntegerLiteralSyntax {}<br>&gt; enum Syntax {<br>&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt; }<br>&gt;<br>&gt; And used like this:<br>&gt;<br>&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;<br>&gt;<br>&gt; Is anyone on the core team planning to write up a proposal for this change?<br></p><p>Your help would be most appreciated!<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Proposal:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt; <br>&gt;&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt;&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt;&gt; not well received, and there is no apparent confluence in the community on<br>&gt;&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt;&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt;&gt; renaming these.&quot;<br>&gt;&gt; <br>&gt;&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt;&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt;&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt;&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;&gt; <br>&gt;&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt;&gt; language and to evaluate whether other protocol groups should have a core<br>&gt;&gt; scheme for naming.<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt; find the exact email, so I can&#39;t provide a link.<br>&gt; <br>&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt; concerned, there is no visible conversion (even if one is happening<br>&gt; behind the scenes).<br>&gt; <br>&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt; <br>&gt; protocol _IntegerLiteralSyntax {}<br>&gt; enum Syntax {<br>&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt; }<br>&gt; <br>&gt; And used like this:<br>&gt; <br>&gt; struct Int : Syntax.IntegerLiteral {}<br></p><p>I’m working on a draft of this proposal right now.  I have a couple questions.  <br></p><p>First, I’d like to list the standard library team as co-authors if you desire because this is really your idea.  Let me know what you would prefer.<br></p><p>Second, I wonder if it might make more sense to name the protocols `Syntax.IntegerLiteralInitializable`.  Dave has opposed `Initializable` as a general convention because it implies pure syntax and doesn’t carry any semantics.  But in this case the semantics *are* essentially the syntax.  Erica pointed out to me off list that at the usage site the  `Syntax.IntegerLiteral` names could confuse somebody into thinking in terms of *isa* rather than *can do* (i.e. Int is an IntegerLiteral rather than Int can be *initialized* with an IntegerLiteral).  <br></p><p>Please let me know if this name change would be acceptable to the standard library team or may be met with resistance.  I want this proposal to be acceptable to the team from the start.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; - For protocols that are representing conversions between types that<br>&gt; actually exist in the library, there is not enough precedent yet to<br>&gt; make a general conclusion and standardize a pattern.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/0c13523d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Revisiting SE-0041 Names</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 22, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 7:42 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt; On Jun 22, 2016, at 1:55 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 22, 2016 at 11:04 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;<br>&gt; Rejection: &quot;The feedback on the proposal was generally positive about the<br>&gt; idea of renaming these protocols, but the specific names in the proposal are<br>&gt; not well received, and there is no apparent confluence in the community on<br>&gt; better names.  The core team prefers discussion to continue -- if/when there<br>&gt; is a strong proposal for a better naming approach, we can reconsider<br>&gt; renaming these.&quot;<br>&gt;<br>&gt; John McCall: &quot;To be clear, I don&#39;t care about the name.  If you want to<br>&gt; rename IntegerLiteralConvertible to IntegerLiteral or whatever, I won&#39;t drag<br>&gt; the conversation into the muck again. :)  It&#39;s the design of the<br>&gt; requirements that I&#39;m pretty opposed to revisiting.&quot;<br>&gt;<br>&gt; The Problem: This is really the last chance to rationalize this across the<br>&gt; language and to evaluate whether other protocol groups should have a core<br>&gt; scheme for naming.<br>&gt;<br>&gt;<br>&gt; Hi Erica,<br>&gt;<br>&gt; I would like to re-state the feedback from Dave Abrahams, Max Moiseev<br>&gt; and me from the last time this was discussed.  Unfortunately I can&#39;t<br>&gt; find the exact email, so I can&#39;t provide a link.<br>&gt;<br>&gt; - The &quot;literal&quot; protocols are not about conversion, they are about<br>&gt; adopting a certain syntax provided by the language.  &quot;Convertible&quot; in<br>&gt; the name is a red herring: a type can&#39;t be convertible from an integer<br>&gt; literal because there is no &quot;IntegerLiteral&quot; entity in the type<br>&gt; system.  The literal *becomes* typed as the corresponding literal type<br>&gt; (e.g., Int or String), and as far as the user at the call site is<br>&gt; concerned, there is no visible conversion (even if one is happening<br>&gt; behind the scenes).<br>&gt;<br>&gt; Our suggestion was to focus on the &quot;adopting the syntax&quot; part.  We<br>&gt; suggested moving the &quot;literal convertible&quot; protocols into a<br>&gt; pseudo-namespace &quot;Syntax&quot;.  It could be implemented like this:<br>&gt;<br>&gt; protocol _IntegerLiteralSyntax {}<br>&gt; enum Syntax {<br>&gt;  typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt; }<br>&gt;<br>&gt; And used like this:<br>&gt;<br>&gt; struct Int : Syntax.IntegerLiteral {}<br>&gt;<br>&gt;<br>&gt; I’m working on a draft of this proposal right now.  I have a couple<br>&gt; questions.<br>&gt;<br>&gt; First, I’d like to list the standard library team as co-authors if you<br>&gt; desire because this is really your idea.  Let me know what you would prefer.<br></p><p>Thank you.  I don&#39;t mind either way.<br></p><p>&gt; Second, I wonder if it might make more sense to name the protocols<br>&gt; `Syntax.IntegerLiteralInitializable`.  Dave has opposed `Initializable` as a<br>&gt; general convention because it implies pure syntax and doesn’t carry any<br>&gt; semantics.  But in this case the semantics *are* essentially the syntax.<br>&gt; Erica pointed out to me off list that at the usage site the<br>&gt; `Syntax.IntegerLiteral` names could confuse somebody into thinking in terms<br>&gt; of *isa* rather than *can do* (i.e. Int is an IntegerLiteral rather than Int<br>&gt; can be *initialized* with an IntegerLiteral).<br>&gt;<br>&gt; Please let me know if this name change would be acceptable to the standard<br>&gt; library team or may be met with resistance.  I want this proposal to be<br>&gt; acceptable to the team from the start.<br></p><p>IIRC the consensus that Dave, Max and I reached was<br>`Syntax.IntegerLiteral`, but this does not represent the opinion of<br>the core team.  (We did not talk to the whole team, just the three of<br>us.)<br></p><p>I think the possibility of confusion is very small because users will<br>not refer to the protocol as &#39;IntegerLiteral&#39;, it will be qualified as<br>&#39;Syntax.IntegerLiteral&#39;.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
