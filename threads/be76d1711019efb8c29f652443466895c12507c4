<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Completing Generics] Variadic generics</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>March 10, 2016 at 12:00:00am</p></header><div class="content"><p>On Wed, Mar 2, 2016 at 5:22 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; *Variadic generics*<br>&gt;<br>&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt; parameters. If one has a type that could generalize to any number of<br>&gt; generic parameters, the only real way to deal with it today involves<br>&gt; creating a set of types. For example, consider the standard library’s “zip”<br>&gt; function. It returns one of these when provided with two arguments to zip<br>&gt; together:<br>&gt;<br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;<br>&gt;<br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;<br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                            Sequence2 : Sequence,<br>&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>&gt; Sequence&gt;(<br>&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3:<br>&gt; sequence3)<br>&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;<br>&gt;<br>&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt; parameters. The syntax below is hopelessly influenced by C++11 variadic<br>&gt; templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry),<br>&gt; where putting an ellipsis (“…”) to the left of a declaration makes it a<br>&gt; “parameter pack” containing zero or more parameters and putting an ellipsis<br>&gt; to the right of a type/expression/etc. expands the parameter packs within<br>&gt; that type/expression into separate arguments. The important part is that we<br>&gt; be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;<br>&gt; public struct ZipIterator&lt;... *Iterators* : IteratorProtocol&gt; : Iterator<br>&gt; {  *// zero or more type parameters, each of which conforms to<br>&gt; IteratorProtocol*<br>&gt;   public typealias Element = (*Iterators.Element...*)<br>&gt;   *// a tuple containing the element types of each iterator in Iterators*<br>&gt;<br>&gt;   var (*...iterators*): (*Iterators...*)    *// zero or more stored<br>&gt; properties, one for each type in Iterators*<br>&gt;   var reachedEnd: Bool = false<br>&gt;<br>&gt;<br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;<br>&gt;     if reachedEnd { return nil }<br>&gt;<br>&gt;<br>&gt;     guard let values = (*iterators.next()...*) {   *// call “next” on<br>&gt; each of the iterators, put the results into a tuple named “values&quot;*<br>&gt;<br>&gt;       reachedEnd = true<br>&gt;<br>&gt;       return nil<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     return values<br>&gt;<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; public struct ZipSequence&lt;*...Sequences* : Sequence&gt; : Sequence {<br>&gt;   public typealias Iterator = ZipIterator&lt;*Sequences.Iterator...*&gt;   *//<br>&gt; get the zip iterator with the iterator types of our Sequences*<br>&gt;<br>&gt;   var (...*sequences*): (*Sequences**...*)    *// zero or more stored<br>&gt; properties, one for each type in Sequences*<br>&gt;<br>&gt;   *// details ...*<br>&gt; }<br>&gt;<br>&gt; Such a design could also work for function parameters, so we can pack<br>&gt; together multiple function arguments with different types, e.g.,<br>&gt;<br>&gt; public func zip&lt;*... Sequences : SequenceType*&gt;(*... sequences:<br>&gt; Sequences...*)<br>&gt;             -&gt; ZipSequence&lt;*Sequences...*&gt; {<br>&gt;   return ZipSequence(*sequences...*)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt; operator. For example:<br>&gt;<br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    *// function<br>&gt; taking some number of arguments and producing Result*<br>&gt;                            args: (Args...)) -&gt; Result {  *// tuple of<br>&gt; arguments*<br>&gt;   return fn(*args...*)                                     // expand the<br>&gt; arguments in the tuple “args” into separate arguments<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>The application of this to function types is most interesting to me.  Right<br>now, when I need client code to register callbacks of potentially different<br>arities, I make the function signature take an Args structure with a method<br>to unpack it by position:<br></p><p>struct Args {<br>  func arg&lt;T&gt;(i: Int) -&gt; T {<br>    // Bounds-checking and dynamic typecasting/marshalling<br>    guard let result = myValue as? T else {<br>      throw TypeConversionError()<br>    }<br>    return result<br>  }<br>}<br></p><p>func addHandler(name: String, handler: Args throws -&gt; AnyObject) {<br>  ....<br>}<br></p><p>func foo(x: String) { ... }<br>func bar(y: Int, z: String) { ... }<br></p><p>addHandler(&quot;foo&quot;, { args in try foo(args.arg(0)) })<br>addHandler(&quot;bar&quot;, { args in try bar(args.arg(0), args.arg(1)) })<br></p><p>If variadics could let the client just do<br></p><p>addHandler(&quot;foo&quot;, foo)<br>addHandler(&quot;bar&quot;, bar)<br></p><p>and then preserve the type signature of foo &amp; bar as they&#39;re stored in a<br>dictionary, that&#39;d be great for my library&#39;s users.  Repeated across the<br>whole library ecosystem, it&#39;d make it much easier for one library&#39;s<br>functions to play nice with another library&#39;s callbacks, because you<br>wouldn&#39;t need proprietary adapter classes that force a dependency on<br>another library just so that client code can use the two together easily.<br></p><p>But this only works if the type is not erased, i.e. if I can define a<br>dictionary of type [String : (...ParameterType throws -&gt; AnyObject)] and<br>then call a function with apply(handlers[&quot;foo&quot;], [&quot;myParam&quot;]).  This<br>requires at least three features:<br></p><p>1. Variadic generics - and not just in function signatures, but also as<br>part of the function *type*, and as structure members, and as associated<br>Element types for Dictionary etc.<br>2. An array-splat operator which lets me apply these functions to a data<br>structure, checking the types dynamically as it converts them, *or*<br>3. A tuple-splat operator to apply functions to a tuple, *plus* an<br>array-to-tuple conversion.<br></p><p>The actual data that gets passed to the functions is dynamic and subject to<br>error-checking, so it doesn&#39;t help if it only works with tuples and not<br>arrays etc.<br></p><p>Not sure how likely the combination of these happening is, but I think it&#39;d<br>be a big win for Swift&#39;s library ecosystem.  It&#39;s hard to pass callbacks<br>across third-party libraries otherwise, because the type signatures depend<br>upon proprietary types that won&#39;t be in the receiving library.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/be7607c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Completing Generics] Variadic generics</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>March 10, 2016 at 12:00:00am</p></header><div class="content"><p>On Thu, Mar 10, 2016 at 12:43 AM, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Wed, Mar 2, 2016 at 5:22 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; *Variadic generics*<br>&gt;&gt;<br>&gt;&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt;&gt; parameters. If one has a type that could generalize to any number of<br>&gt;&gt; generic parameters, the only real way to deal with it today involves<br>&gt;&gt; creating a set of types. For example, consider the standard library’s “zip”<br>&gt;&gt; function. It returns one of these when provided with two arguments to zip<br>&gt;&gt; together:<br>&gt;&gt;<br>&gt;&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;&gt;<br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;&gt;             -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;&gt;<br>&gt;&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;&gt;                            Sequence2 : Sequence,<br>&gt;&gt;                            Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;&gt;<br>&gt;&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>&gt;&gt; Sequence&gt;(<br>&gt;&gt;               sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3:<br>&gt;&gt; sequence3)<br>&gt;&gt;             -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt;&gt; parameters. The syntax below is hopelessly influenced by C++11 variadic<br>&gt;&gt; templates &lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt; (sorry),<br>&gt;&gt; where putting an ellipsis (“…”) to the left of a declaration makes it a<br>&gt;&gt; “parameter pack” containing zero or more parameters and putting an ellipsis<br>&gt;&gt; to the right of a type/expression/etc. expands the parameter packs within<br>&gt;&gt; that type/expression into separate arguments. The important part is that we<br>&gt;&gt; be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;&gt;<br>&gt;&gt; public struct ZipIterator&lt;... *Iterators* : IteratorProtocol&gt; : Iterator<br>&gt;&gt; {  *// zero or more type parameters, each of which conforms to<br>&gt;&gt; IteratorProtocol*<br>&gt;&gt;   public typealias Element = (*Iterators.Element...*)<br>&gt;&gt;     *// a tuple containing the element types of each iterator in<br>&gt;&gt; Iterators*<br>&gt;&gt;<br>&gt;&gt;   var (*...iterators*): (*Iterators...*)    *// zero or more stored<br>&gt;&gt; properties, one for each type in Iterators*<br>&gt;&gt;   var reachedEnd: Bool = false<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   public mutating func next() -&gt; Element? {<br>&gt;&gt;<br>&gt;&gt;     if reachedEnd { return nil }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     guard let values = (*iterators.next()...*) {   *// call “next” on<br>&gt;&gt; each of the iterators, put the results into a tuple named “values&quot;*<br>&gt;&gt;<br>&gt;&gt;       reachedEnd = true<br>&gt;&gt;<br>&gt;&gt;       return nil<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     return values<br>&gt;&gt;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public struct ZipSequence&lt;*...Sequences* : Sequence&gt; : Sequence {<br>&gt;&gt;   public typealias Iterator = ZipIterator&lt;*Sequences.Iterator...*&gt;   *//<br>&gt;&gt; get the zip iterator with the iterator types of our Sequences*<br>&gt;&gt;<br>&gt;&gt;   var (...*sequences*): (*Sequences**...*)    *// zero or more stored<br>&gt;&gt; properties, one for each type in Sequences*<br>&gt;&gt;<br>&gt;&gt;   *// details ...*<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Such a design could also work for function parameters, so we can pack<br>&gt;&gt; together multiple function arguments with different types, e.g.,<br>&gt;&gt;<br>&gt;&gt; public func zip&lt;*... Sequences : SequenceType*&gt;(*... sequences:<br>&gt;&gt; Sequences...*)<br>&gt;&gt;             -&gt; ZipSequence&lt;*Sequences...*&gt; {<br>&gt;&gt;   return ZipSequence(*sequences...*)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt;&gt; operator. For example:<br>&gt;&gt;<br>&gt;&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    *// function<br>&gt;&gt; taking some number of arguments and producing Result*<br>&gt;&gt;                            args: (Args...)) -&gt; Result {  *// tuple of<br>&gt;&gt; arguments*<br>&gt;&gt;   return fn(*args...*)                                     // expand the<br>&gt;&gt; arguments in the tuple “args” into separate arguments<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; The application of this to function types is most interesting to me.<br>&gt; Right now, when I need client code to register callbacks of potentially<br>&gt; different arities, I make the function signature take an Args structure<br>&gt; with a method to unpack it by position:<br>&gt;<br>&gt; struct Args {<br>&gt;   func arg&lt;T&gt;(i: Int) -&gt; T {<br>&gt;     // Bounds-checking and dynamic typecasting/marshalling<br>&gt;     guard let result = myValue as? T else {<br>&gt;       throw TypeConversionError()<br>&gt;     }<br>&gt;     return result<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; func addHandler(name: String, handler: Args throws -&gt; AnyObject) {<br>&gt;   ....<br>&gt; }<br>&gt;<br>&gt; func foo(x: String) { ... }<br>&gt; func bar(y: Int, z: String) { ... }<br>&gt;<br>&gt; addHandler(&quot;foo&quot;, { args in try foo(args.arg(0)) })<br>&gt; addHandler(&quot;bar&quot;, { args in try bar(args.arg(0), args.arg(1)) })<br>&gt;<br>&gt; If variadics could let the client just do<br>&gt;<br>&gt; addHandler(&quot;foo&quot;, foo)<br>&gt; addHandler(&quot;bar&quot;, bar)<br>&gt;<br>&gt; and then preserve the type signature of foo &amp; bar as they&#39;re stored in a<br>&gt; dictionary, that&#39;d be great for my library&#39;s users.  Repeated across the<br>&gt; whole library ecosystem, it&#39;d make it much easier for one library&#39;s<br>&gt; functions to play nice with another library&#39;s callbacks, because you<br>&gt; wouldn&#39;t need proprietary adapter classes that force a dependency on<br>&gt; another library just so that client code can use the two together easily.<br>&gt;<br>&gt; But this only works if the type is not erased, i.e. if I can define a<br>&gt; dictionary of type [String : (...ParameterType throws -&gt; AnyObject)] and<br>&gt; then call a function with apply(handlers[&quot;foo&quot;], [&quot;myParam&quot;]).  This<br>&gt; requires at least three features:<br>&gt;<br>&gt; 1. Variadic generics - and not just in function signatures, but also as<br>&gt; part of the function *type*, and as structure members, and as associated<br>&gt; Element types for Dictionary etc.<br>&gt; 2. An array-splat operator which lets me apply these functions to a data<br>&gt; structure, checking the types dynamically as it converts them, *or*<br>&gt; 3. A tuple-splat operator to apply functions to a tuple, *plus* an<br>&gt; array-to-tuple conversion.<br>&gt;<br></p><p>4. Probably &quot;Opening existentials&quot; too, to make the array-to-tuple or<br>array-to-function conversion work.  The data in the array is heterogenous,<br>as are the variadic generic parameters.  It could work if you could loop<br>over variadic parameters in a type and attempt to unwrap the existential in<br>the array as that type, reporting an error if not.<br></p><p><br>&gt; The actual data that gets passed to the functions is dynamic and subject<br>&gt; to error-checking, so it doesn&#39;t help if it only works with tuples and not<br>&gt; arrays etc.<br>&gt;<br>&gt; Not sure how likely the combination of these happening is, but I think<br>&gt; it&#39;d be a big win for Swift&#39;s library ecosystem.  It&#39;s hard to pass<br>&gt; callbacks across third-party libraries otherwise, because the type<br>&gt; signatures depend upon proprietary types that won&#39;t be in the receiving<br>&gt; library.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/ebe7787f/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
