<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 22, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On May 16, 2016, at 1:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;    On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                  On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                      2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;                      contains a<br>&gt;&gt;&gt;                      reference whose type does not have value semantics. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                  Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;                  Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;                  *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;                  it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;                impossible to define PureValue. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            Not on purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;                semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;            boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;            a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;            == is equivalent to ===.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;            ValueSemantics, then<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;            presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;                implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;                element values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;                buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            I don&#39;t know what you mean here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;                PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;            the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;            of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;            procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        We look at the observable parts.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;&gt;    features that are considered by equality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt;        use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt;        implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;&gt;    you *can* observe, but what you *do* observe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Can you share your definition of value semantics?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;&gt;    some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;&gt;    semantics and he has a really detailed explanation in<br>&gt;&gt;&gt;    https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;&gt;    https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;&gt;    but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;&gt;    as well to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Super interesting talk! <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt;&gt; ethereal types?<br>&gt;&gt; <br>&gt;&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt;&gt; type? In the talk John says that<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. the size is<br>&gt;&gt;&gt; 2. the values in the vector are<br>&gt;&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt; <br>&gt;&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt;&gt; capacity.<br>&gt;&gt; <br>&gt;&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt;&gt; unwittingly approximates that type too! In this case someone,<br>&gt;&gt;&gt; unfamiliar with the implementation might use it under the assumption<br>&gt;&gt;&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt;&gt;&gt; equality of std::vector.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt;&gt; documentation.<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt;&gt; <br>&gt;&gt; No, you just need documentation.<br>&gt;&gt; <br>&gt;&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt;&gt; documentation or the implementation.<br>&gt;&gt; <br>&gt;&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt;&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt;&gt; expect to fully understand semantics without documentation.<br>&gt;&gt; <br>&gt;&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt;&gt; this is a useful distinction amongst value types.<br>&gt;&gt; <br>&gt;&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt;&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt;&gt; semantics.<br>&gt;&gt; <br>&gt;&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt;&gt; <br>&gt;&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt;&gt; reference types properly.<br>&gt;&gt; <br>&gt;&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt;&gt; interested in this problem.<br>&gt;&gt; <br>&gt;&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt;&gt; semantics at a deep level.<br>&gt;&gt; <br>&gt;&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt;&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt;&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt;&gt; written by using a Value constraint.<br>&gt;<br>&gt; Looking forward to hearing your thoughts on the code I just posted.<br>&gt;<br>&gt; In addition to that, I think it is also important to note that<br>&gt; contained within the notion of PureValue is thread safety.  For<br>&gt; example, in CSP PureValues would can be sent as messages on a channel.<br>&gt; Clearly sending Array&lt;MutableReferenceType&gt; over a channel is<br>&gt; something you would not do in CSP.  <br></p><p>Not if you were interested in anything other than the identities of the<br>elements.  But I can easily imagine representing a selection as a Set&lt;T&gt;<br>and passing that across threads, where T might be a mutable reference<br>type (using my default definition of == and hashValue for all<br>references).<br></p><p>&gt; You can also freely share a ImmutableBox&lt;MyPureValue&gt; and read from it<br>&gt; in any thread you wish without any trouble.  You cannot do that with<br>&gt; ImmutableBox&lt;Array&lt;MutableReferenceType&gt;&gt;.  In the latter, you cannot<br>&gt; mutate the array, but you can still mutate the objects it contains<br>&gt; references to.<br></p><p>Again, it depends on what you look at.  We could create a value type<br>that distinguishes object identities, e.g.<br></p><p>     struct Identity&lt;SomeClass : AnyObject&gt; : Hashable, Comparable  {<br>       <br>       let subject: SomeClass<br>       init(subject: SomeClass) { self.subject = subject }<br>       ...         <br>     }<br></p><p>     func == &lt;X&gt;(lhs: Identity&lt;X&gt;, rhs: Identity&lt;X&gt;) -&gt; Bool {<br>       return lhs === rhs<br>     }<br></p><p>then you could write:<br></p><p>     ImmutableBox&lt;Array&lt;Identity&lt;MutableReferenceType&gt;&gt;&gt;<br></p><p>But would you really make it *impossible* to observe the subject of an<br>Identity?  We could, but I&#39;m not sure I would.  It would come at a cost<br>to efficiency in those places where you have a collection of Identity&#39;s<br>and you happen to know they&#39;re not shared across threads, which I think<br>is probably an important use-case.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        It may be helpful<br>&gt;&gt;&gt;        if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt;        types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In the meantime I’ll take another shot:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        1. Scalars are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;          observable parts of the aggregate are pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    -- <br>&gt;&gt;&gt;    -Dave<br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 1:10 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 16, 2016, at 1:39 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt; &lt;http://cloutiertyler-at-aol.com/ &lt;http://cloutiertyler-at-aol.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;   On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;                     contains a<br>&gt;&gt;&gt;&gt;                     reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;                 Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;                 *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;                 it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;               impossible to define PureValue. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Not on purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;               semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt;           boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt;           a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt;           == is equivalent to ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt;           ValueSemantics, then<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt;           presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;               implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;               element values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;               buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;               PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;           You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt;           the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt;           of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt;           procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       We look at the observable parts.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;&gt;&gt;   features that are considered by equality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt;&gt;       use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt;&gt;       implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;&gt;&gt;   you *can* observe, but what you *do* observe.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       Can you share your definition of value semantics?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;&gt;&gt;   some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;&gt;&gt;   semantics and he has a really detailed explanation in<br>&gt;&gt;&gt;&gt;   https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;&gt;&gt;   https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;&gt;&gt;   but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;&gt;&gt;   as well to Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Super interesting talk! <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt;&gt;&gt; ethereal types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt;&gt;&gt; type? In the talk John says that<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. the size is<br>&gt;&gt;&gt;&gt; 2. the values in the vector are<br>&gt;&gt;&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt;&gt;&gt; capacity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt;&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt;&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt;&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt;&gt;&gt; unwittingly approximates that type too! In this case someone,<br>&gt;&gt;&gt;&gt; unfamiliar with the implementation might use it under the assumption<br>&gt;&gt;&gt;&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt;&gt;&gt;&gt; equality of std::vector.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt;&gt;&gt; documentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt;&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt;&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, you just need documentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt;&gt;&gt; documentation or the implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt;&gt;&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt;&gt;&gt; expect to fully understand semantics without documentation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt;&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt;&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt;&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt;&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt;&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt;&gt;&gt; this is a useful distinction amongst value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt;&gt;&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt;&gt;&gt; semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt;&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt;&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt;&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt;&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt;&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt;&gt;&gt; reference types properly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt;&gt;&gt; interested in this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt;&gt;&gt; semantics at a deep level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt;&gt;&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt;&gt;&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt;&gt;&gt; written by using a Value constraint.<br>&gt;&gt; <br>&gt;&gt; Looking forward to hearing your thoughts on the code I just posted.<br>&gt;&gt; <br>&gt;&gt; In addition to that, I think it is also important to note that<br>&gt;&gt; contained within the notion of PureValue is thread safety.  For<br>&gt;&gt; example, in CSP PureValues would can be sent as messages on a channel.<br>&gt;&gt; Clearly sending Array&lt;MutableReferenceType&gt; over a channel is<br>&gt;&gt; something you would not do in CSP.  <br>&gt; <br>&gt; Not if you were interested in anything other than the identities of the<br>&gt; elements.  But I can easily imagine representing a selection as a Set&lt;T&gt;<br>&gt; and passing that across threads, where T might be a mutable reference<br>&gt; type (using my default definition of == and hashValue for all<br>&gt; references).<br></p><p>Hmmm.  My understanding of CSP is that it is intended to prevent mutable state from being visible in more than one “process” at the same time.  Synchronization happens by sending values across channels, not with the usual thread-oriented synchronization mechanisms like locks and semaphores, etc.<br></p><p>I realized I overstated the case a bit here.  There are certainly cases where you might want to transfer ownership of a reference through a channel.  It’s a shame that Swift doesn’t yet have the ability to talk about owned references and transfer of ownership.  I’m happy that Chris is supportive of eventually introducing an ownership system of some kind.<br></p><p>&gt; <br>&gt;&gt; You can also freely share a ImmutableBox&lt;MyPureValue&gt; and read from it<br>&gt;&gt; in any thread you wish without any trouble.  You cannot do that with<br>&gt;&gt; ImmutableBox&lt;Array&lt;MutableReferenceType&gt;&gt;.  In the latter, you cannot<br>&gt;&gt; mutate the array, but you can still mutate the objects it contains<br>&gt;&gt; references to.<br>&gt; <br>&gt; Again, it depends on what you look at.  We could create a value type<br>&gt; that distinguishes object identities, e.g.<br>&gt; <br>&gt;     struct Identity&lt;SomeClass : AnyObject&gt; : Hashable, Comparable  {<br>&gt; <br>&gt;       let subject: SomeClass<br>&gt;       init(subject: SomeClass) { self.subject = subject }<br>&gt;       ...         <br>&gt;     }<br>&gt; <br>&gt;     func == &lt;X&gt;(lhs: Identity&lt;X&gt;, rhs: Identity&lt;X&gt;) -&gt; Bool {<br>&gt;       return lhs === rhs<br>&gt;     }<br>&gt; <br>&gt; then you could write:<br>&gt; <br>&gt;     ImmutableBox&lt;Array&lt;Identity&lt;MutableReferenceType&gt;&gt;&gt;<br>&gt; <br>&gt; But would you really make it *impossible* to observe the subject of an<br>&gt; Identity?  We could, but I&#39;m not sure I would.<br>&gt;  It would come at a cost<br>&gt; to efficiency in those places where you have a collection of Identity&#39;s<br>&gt; and you happen to know they&#39;re not shared across threads, which I think<br>&gt; is probably an important use-case.<br></p><p>I’m not trying to argue that you shouldn’t be able to do things like this if you want to.  <br></p><p>What I am arguing for is the ability to distinguish aggregates which are logically isolated from aggregates which contain salient references to shared mutable state.  To be honest, I am really struggling to understand why this distinction seems unimportant to you.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       It may be helpful<br>&gt;&gt;&gt;&gt;       if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt;&gt;       types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       In the meantime I’ll take another shot:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       1. Scalars are pure values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;&gt;         observable parts of the aggregate are pure values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   -- <br>&gt;&gt;&gt;&gt;   -Dave<br>&gt;&gt;&gt;&gt;   _______________________________________________<br>&gt;&gt;&gt;&gt;   swift-evolution mailing list<br>&gt;&gt;&gt;&gt;   swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/7cb88524/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 01:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 22, 2016, at 9:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 22, 2016, at 1:10 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 16, 2016, at 1:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun May 15 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   On May 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           On May 8, 2016, at 1:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           on Sat May 07 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;                 On May 7, 2016, at 2:04 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;                     2. Value types are not &quot;pure&quot; values if any part of the aggregate<br>&gt;&gt;&gt;&gt;&gt;                     contains a<br>&gt;&gt;&gt;&gt;&gt;                     reference whose type does not have value semantics. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;                 Then Array&lt;Int&gt; is not a “pure” value (the buffer contained in an<br>&gt;&gt;&gt;&gt;&gt;                 Array&lt;Int&gt; is a mutable reference type that on its own, definitely does<br>&gt;&gt;&gt;&gt;&gt;                 *not* have value semantics). I don&#39;t think this is what you intend, and<br>&gt;&gt;&gt;&gt;&gt;                 it indicates that you need to keep working on your definition.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               It sounds like you’re changing the definition of value semantics to make it<br>&gt;&gt;&gt;&gt;&gt;               impossible to define PureValue. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           Not on purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               Does Array&lt;T&gt; have value semantics then only if T also has value<br>&gt;&gt;&gt;&gt;&gt;               semantics?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           This is a great question; I had to rewrite my response four times.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           In my world, an Array&lt;T&gt; always has value semantics if you respect the<br>&gt;&gt;&gt;&gt;&gt;           boundaries of element values as defined by ==.  That means that if T is<br>&gt;&gt;&gt;&gt;&gt;           a mutable reference type, you&#39;re not looking through references, because<br>&gt;&gt;&gt;&gt;&gt;           == is equivalent to ===.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           Therefore, for almost any interesting SomeConstraint that doesn&#39;t refine<br>&gt;&gt;&gt;&gt;&gt;           ValueSemantics, then<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           Array&lt;T: SomeConstraint&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           only has value semantics if T has value semantics, since SomeConstraint<br>&gt;&gt;&gt;&gt;&gt;           presumably uses aspects of T other than reference identity.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               The claim has been made that Array always has value semantics,<br>&gt;&gt;&gt;&gt;&gt;               implying that the array value’s boundary ends at the boundary of it’s<br>&gt;&gt;&gt;&gt;&gt;               element values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           Yes, an array value ends at the boundary of its elements&#39; values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               That fact is what allows the compiler to ignore mutation of the<br>&gt;&gt;&gt;&gt;&gt;               buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           I don&#39;t know what you mean here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               It&#39;s perfectly clear that Array&lt;T&gt; is a PureValue iff T is a PureValue.<br>&gt;&gt;&gt;&gt;&gt;               PureValue is nothing more than transitive value semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;           You&#39;re almost there.  “Transitive” implies that you are going to look at<br>&gt;&gt;&gt;&gt;&gt;           the parts of a type to see if they are also PureValue&#39;s.  So which parts<br>&gt;&gt;&gt;&gt;&gt;           of the Array struct does one look at, and why?  Just tell me the<br>&gt;&gt;&gt;&gt;&gt;           procedure for determining whether a type is a PureValue.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       We look at the observable parts.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   That begs the question.  The “parts” of an Array are the observable<br>&gt;&gt;&gt;&gt;&gt;   features that are considered by equality.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       We do not look at unobservable parts because we want flexibility to<br>&gt;&gt;&gt;&gt;&gt;       use things like CoW, shared immutable references, etc in our<br>&gt;&gt;&gt;&gt;&gt;       implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   IMO the important thing when it comes to functional purity is not what<br>&gt;&gt;&gt;&gt;&gt;   you *can* observe, but what you *do* observe.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       Can you share your definition of value semantics?  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   Explaining it well and in sufficient detail for this discussion takes<br>&gt;&gt;&gt;&gt;&gt;   some doing, but I think John Lakos and I share an understanding of value<br>&gt;&gt;&gt;&gt;&gt;   semantics and he has a really detailed explanation in<br>&gt;&gt;&gt;&gt;&gt;   https://www.youtube.com/watch?v=W3xI1HJUy7Q and<br>&gt;&gt;&gt;&gt;&gt;   https://www.youtube.com/watch?v=0EvSxHxFknM.  He uses C++ in places,<br>&gt;&gt;&gt;&gt;&gt;   but it&#39;s not particularly advanced, and the fundamental ideas apply just<br>&gt;&gt;&gt;&gt;&gt;   as well to Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Super interesting talk! <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But consider: isn&#39;t a single value type able to represent *multiple*<br>&gt;&gt;&gt;&gt;&gt; ethereal types?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “ethereal?”  Does he really use that term?  I don&#39;t know what it means.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; std::vector is a good example. What are the salient attributes of this<br>&gt;&gt;&gt;&gt;&gt; type? In the talk John says that<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. the size is<br>&gt;&gt;&gt;&gt;&gt; 2. the values in the vector are<br>&gt;&gt;&gt;&gt;&gt; 3. the capacity, however *is not*<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yup, just like Array.  Thus the equality test for arrays ignores<br>&gt;&gt;&gt;&gt; capacity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; in which case std::vector would be an approximation of an ethereal<br>&gt;&gt;&gt;&gt;&gt; type which has a list of values, and the capacity is just an artifact<br>&gt;&gt;&gt;&gt;&gt; of the approximation. But you could also imagine an ethereal type<br>&gt;&gt;&gt;&gt;&gt; which *does* depend of the capacity of the object, and std::vector<br>&gt;&gt;&gt;&gt;&gt; unwittingly approximates that type too! In this case someone,<br>&gt;&gt;&gt;&gt;&gt; unfamiliar with the implementation might use it under the assumption<br>&gt;&gt;&gt;&gt;&gt; that capacity *is* part of the ethereal type and by extension the<br>&gt;&gt;&gt;&gt;&gt; equality of std::vector.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John avoids the problem by saying that this must specified in the<br>&gt;&gt;&gt;&gt;&gt; documentation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I tend to see this as breaking encapsulation since you need to know<br>&gt;&gt;&gt;&gt;&gt; the implementation of the equality operator to be able to determine if<br>&gt;&gt;&gt;&gt;&gt; a public property, the capacity, is part of the ethereal type. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, you just need documentation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s not always the case that you have access to either the<br>&gt;&gt;&gt;&gt;&gt; documentation or the implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Without the documentation, you&#39;re lost.  We go a lot further with naming<br>&gt;&gt;&gt;&gt; conventions in Swift than typical C++ does, but even in Swift you can&#39;t<br>&gt;&gt;&gt;&gt; expect to fully understand semantics without documentation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This implies, therefore, that if salient attributes *define* the<br>&gt;&gt;&gt;&gt;&gt; immutability of the value type, then the public interface is not<br>&gt;&gt;&gt;&gt;&gt; guaranteed to be immutable, since it is allowed to include non-salient<br>&gt;&gt;&gt;&gt;&gt; attributes. For example, a vector’s capacity could change at any time,<br>&gt;&gt;&gt;&gt;&gt; by virtue of it being stored via a reference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I am saying is that a PureValue is a value type whose public<br>&gt;&gt;&gt;&gt;&gt; interface comprises *only* salient attributes. And I also claim that<br>&gt;&gt;&gt;&gt;&gt; this is a useful distinction amongst value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then Array&lt;Int&gt; is not a PureValue because it exposes capacity?!  That<br>&gt;&gt;&gt;&gt; sounds crazy to me, since the Array&#39;s capacity in no sense has reference<br>&gt;&gt;&gt;&gt; semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John also says that a salient attribute must derive *only* from the<br>&gt;&gt;&gt;&gt;&gt; state of a particular instance of a type. This by extension implies<br>&gt;&gt;&gt;&gt;&gt; that a salient attribute must derive exclusively from pure<br>&gt;&gt;&gt;&gt;&gt; values. However, this also means that without some “indirect” keyword,<br>&gt;&gt;&gt;&gt;&gt; PureValues are restricted to acyclic and non-recursive structures.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also claim that equality can be automatically generated for<br>&gt;&gt;&gt;&gt;&gt; PureValues by equating each of there salient attributes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s true for almost any value, provided we define equality for<br>&gt;&gt;&gt;&gt; reference types properly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I really apologize if this seems like rambling again, but I am very<br>&gt;&gt;&gt;&gt;&gt; interested in this problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m glad you are! Few programmers dig far enough to understand value<br>&gt;&gt;&gt;&gt; semantics at a deep level.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All that said, I still think PureValue is a red herring.  Unless I&#39;m<br>&gt;&gt;&gt;&gt; forgetting something that happened in the thread two weeks ago, nobody<br>&gt;&gt;&gt;&gt; has shown me code that relies on PureValue but could not equally well be<br>&gt;&gt;&gt;&gt; written by using a Value constraint.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking forward to hearing your thoughts on the code I just posted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to that, I think it is also important to note that<br>&gt;&gt;&gt; contained within the notion of PureValue is thread safety.  For<br>&gt;&gt;&gt; example, in CSP PureValues would can be sent as messages on a channel.<br>&gt;&gt;&gt; Clearly sending Array&lt;MutableReferenceType&gt; over a channel is<br>&gt;&gt;&gt; something you would not do in CSP.  <br>&gt;&gt; <br>&gt;&gt; Not if you were interested in anything other than the identities of the<br>&gt;&gt; elements.  But I can easily imagine representing a selection as a Set&lt;T&gt;<br>&gt;&gt; and passing that across threads, where T might be a mutable reference<br>&gt;&gt; type (using my default definition of == and hashValue for all<br>&gt;&gt; references).<br>&gt; <br>&gt; Hmmm.  My understanding of CSP is that it is intended to prevent mutable state from being visible in more than one “process” at the same time.  Synchronization happens by sending values across channels, not with the usual thread-oriented synchronization mechanisms like locks and semaphores, etc.<br>&gt; <br>&gt; I realized I overstated the case a bit here.  There are certainly cases where you might want to transfer ownership of a reference through a channel.  It’s a shame that Swift doesn’t yet have the ability to talk about owned references and transfer of ownership.  I’m happy that Chris is supportive of eventually introducing an ownership system of some kind.<br>&gt; <br></p><p>There was a recent talk about some changes to the structure of the ISA pointer and brief mention about where some thread info could be added<br></p><p><br>&gt;&gt; <br>&gt;&gt;&gt; You can also freely share a ImmutableBox&lt;MyPureValue&gt; and read from it<br>&gt;&gt;&gt; in any thread you wish without any trouble.  You cannot do that with<br>&gt;&gt;&gt; ImmutableBox&lt;Array&lt;MutableReferenceType&gt;&gt;.  In the latter, you cannot<br>&gt;&gt;&gt; mutate the array, but you can still mutate the objects it contains<br>&gt;&gt;&gt; references to.<br>&gt;&gt; <br>&gt;&gt; Again, it depends on what you look at.  We could create a value type<br>&gt;&gt; that distinguishes object identities, e.g.<br>&gt;&gt; <br>&gt;&gt;     struct Identity&lt;SomeClass : AnyObject&gt; : Hashable, Comparable  {<br>&gt;&gt; <br>&gt;&gt;       let subject: SomeClass<br>&gt;&gt;       init(subject: SomeClass) { self.subject = subject }<br>&gt;&gt;       ...         <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func == &lt;X&gt;(lhs: Identity&lt;X&gt;, rhs: Identity&lt;X&gt;) -&gt; Bool {<br>&gt;&gt;       return lhs === rhs<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; then you could write:<br>&gt;&gt; <br>&gt;&gt;     ImmutableBox&lt;Array&lt;Identity&lt;MutableReferenceType&gt;&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; But would you really make it *impossible* to observe the subject of an<br>&gt;&gt; Identity?  We could, but I&#39;m not sure I would.<br>&gt;&gt;  It would come at a cost<br>&gt;&gt; to efficiency in those places where you have a collection of Identity&#39;s<br>&gt;&gt; and you happen to know they&#39;re not shared across threads, which I think<br>&gt;&gt; is probably an important use-case.<br>&gt; <br>&gt; I’m not trying to argue that you shouldn’t be able to do things like this if you want to.  <br>&gt; <br>&gt; What I am arguing for is the ability to distinguish aggregates which are logically isolated from aggregates which contain salient references to shared mutable state.  To be honest, I am really struggling to understand why this distinction seems unimportant to you.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       It may be helpful<br>&gt;&gt;&gt;&gt;&gt;       if we start there and refine your definition to exclude impure value<br>&gt;&gt;&gt;&gt;&gt;       types like Array&lt;UIView&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       In the meantime I’ll take another shot:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       1. Scalars are pure values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       2. Any aggregate type with value semantics is a pure value iff all<br>&gt;&gt;&gt;&gt;&gt;         observable parts of the aggregate are pure values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   -- <br>&gt;&gt;&gt;&gt;&gt;   -Dave<br>&gt;&gt;&gt;&gt;&gt;   _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/28b7b94b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
