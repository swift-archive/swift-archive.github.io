<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Proposal: Bridging for Swift Structs in Objective-C</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.<br></p><p>@objc struct Letter {<br>	var address : String?<br></p><p>	init(withAddress address : String? ) {<br>		self.address = address<br>	}<br>}<br></p><p>At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.<br></p><p>Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’<br></p><p>With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.<br></p><p>@objc(US) struct Letter {<br>	var address : String?<br></p><p>	init(withAddress address : String? ) {<br>		self.address = address<br>	}<br>}<br></p><p>-------<br></p><p>USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br></p><p>Nested types would also be represented via this proposal:<br></p><p>@objc(US) class PostalService {<br>	struct Letter {<br>		var address : String?<br></p><p>		init(withAddress address : String? ) {<br>			self.address = address<br>		}<br>	}<br>}<br></p><p>-------<br></p><p>USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’<br>USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br></p><p>Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2c2e488b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Proposal: Bridging for Swift Structs in Objective-C</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>December  5, 2015 at 12:00:00am</p></header><div class="content"><p>How do you deal with the fact that structs have value semantic, while your generated class have reference semantic ?<br></p><p>&gt; Le 4 déc. 2015 à 23:06, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.<br>&gt; <br>&gt; @objc struct Letter {<br>&gt; 	var address : String?<br>&gt; <br>&gt; 	init(withAddress address : String? ) {<br>&gt; 		self.address = address<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.<br>&gt; <br>&gt; Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>&gt; MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’<br>&gt; <br>&gt; With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.<br>&gt; <br>&gt; @objc(US) struct Letter {<br>&gt; 	var address : String?<br>&gt; <br>&gt; 	init(withAddress address : String? ) {<br>&gt; 		self.address = address<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; -------<br>&gt; <br>&gt; USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>&gt; USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br>&gt; <br>&gt; Nested types would also be represented via this proposal:<br>&gt; <br>&gt; @objc(US) class PostalService {<br>&gt; 	struct Letter {<br>&gt; 		var address : String?<br>&gt; <br>&gt; 		init(withAddress address : String? ) {<br>&gt; 			self.address = address<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; -------<br>&gt; <br>&gt; USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’<br>&gt; USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br>&gt; <br>&gt; Dan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/b49e4e0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Proposal: Bridging for Swift Structs in Objective-C</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>That’s expected, and there’s not much that can be done about that.  Effectively, much like how Swift’s String value type bridges to the NSString class, this proposal would enable a custom arbitrary struct to have an equivalent Obj-C bridge class with a mutable subclass ala NSMutableString.  The overall goal here is to be able to use Swift structs in some way from Objective-C.<br></p><p>Dan<br></p><p>&gt; On Dec 4, 2015, at 3:54 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; How do you deal with the fact that structs have value semantic, while your generated class have reference semantic ?<br>&gt; <br>&gt;&gt; Le 4 déc. 2015 à 23:06, Dan Stenmark &lt;daniel.j.stenmark at gmail.com &lt;mailto:daniel.j.stenmark at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.<br>&gt;&gt; <br>&gt;&gt; @objc struct Letter {<br>&gt;&gt; 	var address : String?<br>&gt;&gt; <br>&gt;&gt; 	init(withAddress address : String? ) {<br>&gt;&gt; 		self.address = address<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.<br>&gt;&gt; <br>&gt;&gt; Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>&gt;&gt; MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’<br>&gt;&gt; <br>&gt;&gt; With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.<br>&gt;&gt; <br>&gt;&gt; @objc(US) struct Letter {<br>&gt;&gt; 	var address : String?<br>&gt;&gt; <br>&gt;&gt; 	init(withAddress address : String? ) {<br>&gt;&gt; 		self.address = address<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -------<br>&gt;&gt; <br>&gt;&gt; USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>&gt;&gt; USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br>&gt;&gt; <br>&gt;&gt; Nested types would also be represented via this proposal:<br>&gt;&gt; <br>&gt;&gt; @objc(US) class PostalService {<br>&gt;&gt; 	struct Letter {<br>&gt;&gt; 		var address : String?<br>&gt;&gt; <br>&gt;&gt; 		init(withAddress address : String? ) {<br>&gt;&gt; 			self.address = address<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -------<br>&gt;&gt; <br>&gt;&gt; USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’<br>&gt;&gt; USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br>&gt;&gt; <br>&gt;&gt; Dan<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8d26424d/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Bridging for Swift Structs in Objective-C</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:06 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt; <br>&gt; Swift’s Struct type is one of the most praised features of the language, but is currently unavailable in Objective-C.  This poses problems for large legacy codebases that can’t be ported to Swift as quickly but still want to begin using some of the mutability semantics it introduces.  As such, I’d like to propose syntax for creating bridged classes that can utilized in Objective-C.<br>&gt; <br>&gt; @objc struct Letter {<br>&gt; 	var address : String?<br>&gt; <br>&gt; 	init(withAddress address : String? ) {<br>&gt; 		self.address = address<br>&gt; 	}<br>&gt; }<br></p><p>I’m generally a fan of anything that can make Swift get exposed back to Objective-C better, but such things generally need implementation work on Clang as well as on Swift (and thus, need Clang community buy-in as well).  Further, as other folks have pointed out, as proposed, this has some challenges in terms of design and implementation.  Are you planning to lead the implementation effort?<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; At compile-time, this would create two bridge classes: Letter and MutableLetter, both conforming to the NSMutableCopying protocol.<br>&gt; <br>&gt; Letter *letter = [[Letter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>&gt; MutableLetter *mutableLetter = letter.mutableCopy;  // equivalent to ‘var mutableLetter = letter’<br>&gt; <br>&gt; With Objective-C’s lack of namespacing, the @objc decorator would likely need to accept an optional class prefix parameter to help guard against class name collisions.<br>&gt; <br>&gt; @objc(US) struct Letter {<br>&gt; 	var address : String?<br>&gt; <br>&gt; 	init(withAddress address : String? ) {<br>&gt; 		self.address = address<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; -------<br>&gt; <br>&gt; USLetter *letter = [[USLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = Letter(address: address)’<br>&gt; USMutableLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br>&gt; <br>&gt; Nested types would also be represented via this proposal:<br>&gt; <br>&gt; @objc(US) class PostalService {<br>&gt; 	struct Letter {<br>&gt; 		var address : String?<br>&gt; <br>&gt; 		init(withAddress address : String? ) {<br>&gt; 			self.address = address<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; -------<br>&gt; <br>&gt; USPostalServiceLetter *letter = [[USPostalServiceLetter alloc] initWithAddress:address];  // equivalent to ‘let letter = PostalService.Letter(address: address)’<br>&gt; USMutablePostalServiceLetter *mutableLetter = letter.mutableCopy; // equivalent to ‘var mutableLetter = letter’<br>&gt; <br>&gt; Dan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f641c11a/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
