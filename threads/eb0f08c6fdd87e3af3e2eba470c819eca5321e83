<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Fix the Collection Partition API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>on Tue Jul 05 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; This is a crack at a proposal to revise the API of the collection<br>&gt; partition method, called out as an open issue in the standard<br>&gt; library. What&#39;s below is a much shorter revision of a prior proposal,<br>&gt; focused only on the partition method. I welcome any feedback you might<br>&gt; have!<br>&gt;<br>&gt; Thanks,<br>&gt; Nate<br></p><p>Overall, a big +1.  Please submit a PR for the proposal to the evolution<br>repo!<br></p><p>Notes below.<br></p><p>&gt; ––––<br>&gt; This proposal revises the signature for the collection partition<br>&gt; algorithm. Partitioning is a foundational API for sorting and for<br>&gt; searching through sorted collections.<br>&gt;<br>&gt; Swift-evolution thread: Feedback from standard library team<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016729.html&gt;<br>&gt; Swift Bug: SR-1965 &lt;https://bugs.swift.org/browse/SR-1965&gt;<br>&gt; Motivation<br>&gt; Based on feedback during the review of proposal SE-0074,<br>&gt; Implementation of Binary Search Functions<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0074-binary-search.md&gt;<br>&gt; and the list of open issues affecting standard library API stability<br>&gt; &lt;https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d&gt;,<br>&gt; this is a revised proposal focused only on the existing collection<br>&gt; partition method.<br>&gt;<br>&gt; The standard library&#39;s current partition methods, which partition a<br>&gt; mutable collection using a binary predicate based on the value of the<br>&gt; first element of a collection, are used by the standard library&#39;s<br>&gt; sorting algorithm but don&#39;t offer more general partitioning<br>&gt; functionality. A more general partition algorithm using a unary<br>&gt; (single-argument) predicate would be more flexible and generally<br>&gt; useful.<br>&gt;<br>&gt; Proposed solution<br>&gt; The standard library should replace the existing partition methods<br>&gt; with a single method taking a unary predicate. This new method,<br>&gt; partition(where:), is a mutating method that accepts a unary<br>&gt; predicate. The elements of the collection are rearranged according to<br>&gt; the predicate, so that there is a pivot index p where no element<br>&gt; before p satisfies the predicate and every element at and after p does<br>&gt; satisfy the predicate.<br>&gt;<br>&gt; var n = [30, 40, 20, 30, 30, 60, 10]<br>&gt; let p = n.partition(where: { $0 &gt; 30 })<br>&gt; // n == [30, 10, 20, 30, 30, 60, 40]<br>&gt; // p == 5<br>&gt; After partitioning, the predicate returns false for every element in<br>&gt; n.prefix(upTo: p)and true for every element in n.suffix(from: p).<br>&gt;<br>&gt; Detailed design<br>&gt; partition(where:) should be added as a MutableCollection requirement<br>&gt; with default implementations for mutable and bidirectional mutable<br>&gt; collections. Any mutable collection can be partitioned, but the<br>&gt; bidirectional algorithm generally performs far fewer copies. The other<br>&gt; two methods can be provided in an extension of the Collection<br>&gt; protocol.<br>&gt;<br>&gt; The proposed APIs are collected here:<br>&gt;<br>&gt; protocol MutableCollection {<br>&gt;     // existing requirements<br>&gt;<br>&gt;     /// Reorders the elements of the collection such that all the<br>&gt;     /// elements that match the predicate are ordered after all the<br>&gt;     /// elements that do not match the predicate.<br>&gt;     ///<br>&gt;     /// - Returns: The index of the first element in the reordered<br>&gt;     ///   collection that matches the predicate.<br>&gt;     /// - Complexity: O(n)<br>&gt;     @discardableResult<br>&gt;     mutating func partition(<br>&gt;         where predicate: @noescape (Iterator.Element) throws-&gt; Bool<br>&gt;     ) rethrows -&gt; Index<br>&gt; }<br>&gt;<br>&gt; extension MutableCollection {<br>&gt;     @discardableResult<br>&gt;     mutating func partition(<br>&gt;         where predicate: @noescape (Iterator.Element) throws-&gt; Bool<br>&gt;     ) rethrows -&gt; Index<br>&gt; }<br>&gt;<br>&gt; extension MutableCollection where Self: BidirectionalCollection {<br>&gt;     @discardableResult<br>&gt;     mutating func partition(<br>&gt;         where predicate: @noescape (Iterator.Element) throws-&gt; Bool<br>&gt;     ) rethrows -&gt; Index<br>&gt; }<br>&gt; A full implementation of the two default implementations can be found<br>&gt; in this gist<br>&gt; &lt;https://gist.github.com/natecook1000/70f36608ecd6236552ce0e9f79b98cff&gt;.<br></p><p>IMO we should choose a better parameter name for predicate, such as<br>`belongsInSecondPartition` or `moveToUpperPartition`.  That will help<br>guide people to correct usage.<br></p><p>&gt; Impact on existing code<br>&gt; The current sorting algorithms would need to be modified to use the<br>&gt; new partition(where:) method. <br></p><p>Not really; that&#39;s an implementation detail.  A super cheap fix would<br>just underscore the existing APIs.  The “Impact on existing code”<br>section is really about the impact on clients of the standard library,<br>not its internals.<br></p><p>&gt; Other uses of the existing partition methods could be flagged or in<br>&gt; theory could be replaced programmatically. The replacement code, on a<br>&gt; mutable collection c:<br>&gt;<br>&gt; // old<br>&gt; c.partition()<br>&gt;<br>&gt; // new<br>&gt; if let first = c.first {<br>&gt;     c.partition(where: { $0 &gt;= first })<br>&gt; }<br>&gt; A thorough, though not exhaustive, search of GitHub for the existing<br>&gt; partition method found no real evidence of its use. The evident uses<br>&gt; of a partition method were mainly either tests from the Swift project<br>&gt; or third-party implementations similar to the one proposed.<br>&gt;<br>&gt; Alternatives considered<br>&gt; To more closely match the existing API, the partition(where:) method<br>&gt; could be added only as a default implementation for mutable<br>&gt; bidirectional collections. This would unnecessarily limit access to<br>&gt; the algorithm for mutable forward collections.<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
