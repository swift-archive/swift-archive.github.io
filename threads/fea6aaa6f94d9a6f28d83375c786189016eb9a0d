<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0c6689d6389b72de39ed485a92217101?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Nur Ismail</string> &lt;nur at estalea.com&gt;<p>August 22, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I&#39;m new to the list, but have an idea for Typed Numerics.<br>Basically numeric values (such as Double, Int, etc.) that are strongly<br>typed to a specific use case, for example Distance, Weight, etc. and cannot<br>be intermixed with untyped values.<br></p><p>So if I have (the syntax is made up, but perhaps something like this):<br>=====<br>//Distance<br>struct fixedtype Distance : Double {<br>var km: …<br>var m: …<br>typealias meters: m<br>var feet: ...<br>...<br>}<br></p><p>//Weight<br>struct fixedtype Weight : Double {<br>var kg: …<br>var g: …<br>typealias grams : g<br>var pound: ...<br>}<br></p><p>…<br>var weight : Weight = 5.kg + 5.g + 7.m<br>………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>var distance: Distance = 7.km + 12.5.m + 5.0 + 3<br>………………………………………………...^ Compiler Error: can’t add untyped number to<br>Distance...<br>===<br></p><p>The main restriction this syntax should do is disallow intermixing of<br>numeric types (even if they all descend from Double, Int, etc.) and not<br>allow adding untyped numerics (i.e. those without a type suffix), unless<br>explicitly asked for in the code.<br></p><p>Any of these can be converted to it&#39;s raw untyped value, for example:<br>=====<br>let number : Double = distance.rawValue + 5.0   //This is allowed<br>distance += number.m   //number is converted to m (meters)<br>=====<br></p><p>&gt;From the Swift 3 Language guide, we are for example given the following<br>example:<br>=====<br>extension Double {<br>  var km: Double { return self * 1_000.0 }<br>  var m: Double { return self }<br>  var cm: Double { return self / 100.0 }<br>  var mm: Double { return self / 1_000.0 }<br>  var ft: Double { return self / 3.28084 }<br>}<br></p><p>let aMarathon = 42.km + 195.m<br>print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>// Prints &quot;A marathon is 42195.0 meters long&quot;<br>=====<br></p><p>This is quite nice to suffix a conversion method after the value, but if I<br>had another extension that converts the values to pounds and kilograms,<br>then one can illegally do this:<br>     let aValue = 42.km + 195.m + 17.pounds + 5.0<br>and then the code would still compile and run, but not work as intended.<br></p><p>Extra reading, and inspiration for a feature like the above:<br>Mars Probe Lost Due to Simple Math Error<br>http://articles.latimes.com/1999/oct/01/news/mn-17288<br></p><p>&quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft<br>engineers failed to convert from English to metric measurements when<br>exchanging vital data before the craft was launched, space agency officials<br>said Thursday.<br></p><p>A navigation team at the Jet Propulsion Laboratory used the metric system<br>of millimeters and meters in its calculations, while Lockheed Martin<br>Astronautics in Denver, which designed and built the spacecraft, provided<br>crucial acceleration data in the English system of inches, feet and pounds.<br></p><p>As a result, JPL engineers mistook acceleration readings measured in<br>English units of pound-seconds for a metric measure of force called<br>newton-seconds.&quot;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/fea69a0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>August 22, 2016 at 04:00:00pm</p></header><div class="content"><p>This has definitely come up in the list before, maybe somebody else can provide some links to the conversations. <br>What I would love to see is a generic way of doing newtype, basically just defining a “typealias” but with the difference that the type checker treats it differently. <br>I’m not sure if it’s the right time to discuss this tough, unless if affects the ABI in a deep way.<br></p><p>Cheers<br></p><p><br>&gt; On 22 Aug 2016, at 15:54, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt; Basically numeric values (such as Double, Int, etc.) that are strongly typed to a specific use case, for example Distance, Weight, etc. and cannot be intermixed with untyped values.<br>&gt; <br>&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt; =====<br>&gt; //Distance<br>&gt; struct fixedtype Distance : Double {<br>&gt; var km: …<br>&gt; var m: …<br>&gt; typealias meters: m<br>&gt; var feet: ...<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; //Weight<br>&gt; struct fixedtype Weight : Double {<br>&gt; var kg: …<br>&gt; var g: …<br>&gt; typealias grams : g<br>&gt; var pound: ...<br>&gt; }<br>&gt; <br>&gt; …<br>&gt; var weight : Weight = 5.kg &lt;http://5.kg/&gt; + 5.g + 7.m<br>&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt; var distance: Distance = 7.km &lt;http://7.km/&gt; + 12.5.m + 5.0 + 3<br>&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>&gt; ===<br>&gt; <br>&gt; The main restriction this syntax should do is disallow intermixing of numeric types (even if they all descend from Double, Int, etc.) and not allow adding untyped numerics (i.e. those without a type suffix), unless explicitly asked for in the code.<br>&gt; <br>&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt; =====<br>&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt; distance += number.m   //number is converted to m (meters)<br>&gt; =====<br>&gt; <br>&gt; From the Swift 3 Language guide, we are for example given the following example:<br>&gt; =====<br>&gt; extension Double {<br>&gt;   var km: Double { return self * 1_000.0 }<br>&gt;   var m: Double { return self }<br>&gt;   var cm: Double { return self / 100.0 }<br>&gt;   var mm: Double { return self / 1_000.0 }<br>&gt;   var ft: Double { return self / 3.28084 }<br>&gt; }<br>&gt; <br>&gt; let aMarathon = 42.km &lt;http://42.km/&gt; + 195.m<br>&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt; =====<br>&gt; <br>&gt; This is quite nice to suffix a conversion method after the value, but if I had another extension that converts the values to pounds and kilograms, then one can illegally do this:<br>&gt;      let aValue = 42.km &lt;http://42.km/&gt; + 195.m + 17.pounds + 5.0<br>&gt; and then the code would still compile and run, but not work as intended.<br>&gt; <br>&gt; Extra reading, and inspiration for a feature like the above:<br>&gt; Mars Probe Lost Due to Simple Math Error<br>&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288 &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt; <br>&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft engineers failed to convert from English to metric measurements when exchanging vital data before the craft was launched, space agency officials said Thursday.<br>&gt; <br>&gt; A navigation team at the Jet Propulsion Laboratory used the metric system of millimeters and meters in its calculations, while Lockheed Martin Astronautics in Denver, which designed and built the spacecraft, provided crucial acceleration data in the English system of inches, feet and pounds.<br>&gt; <br>&gt; As a result, JPL engineers mistook acceleration readings measured in English units of pound-seconds for a metric measure of force called newton-seconds.&quot;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/07272d9a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 22, 2016 at 08:00:00am</p></header><div class="content"><p>Hello,<br></p><p>The idea has been explored a number of times before. In some languages that already implement it, it&#39;s called &quot;newtype&quot;. You can see previous discussions by googling &quot;site:lists.swift.org newtype&quot;. There have also been other ideas going around for type-safe unit calculations (there&#39;s one long thread called &quot;Epic: typesafe calculations&quot; that ran for a while).<br></p><p>I remember that the conclusion for type-safe unit calculations was that we didn&#39;t want to implement it as a compiler feature, but rather implement compiler features that would make it possible (as it is in C++ &lt;https://github.com/zneak/units-cxx14&gt;, for instance). I don&#39;t remember what happened with the newtype debate.<br></p><p>Félix<br></p><p>&gt; Le 22 août 2016 à 07:54:59, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt; Basically numeric values (such as Double, Int, etc.) that are strongly typed to a specific use case, for example Distance, Weight, etc. and cannot be intermixed with untyped values.<br>&gt; <br>&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt; =====<br>&gt; //Distance<br>&gt; struct fixedtype Distance : Double {<br>&gt; var km: …<br>&gt; var m: …<br>&gt; typealias meters: m<br>&gt; var feet: ...<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; //Weight<br>&gt; struct fixedtype Weight : Double {<br>&gt; var kg: …<br>&gt; var g: …<br>&gt; typealias grams : g<br>&gt; var pound: ...<br>&gt; }<br>&gt; <br>&gt; …<br>&gt; var weight : Weight = 5.kg &lt;http://5.kg/&gt; + 5.g + 7.m<br>&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt; var distance: Distance = 7.km &lt;http://7.km/&gt; + 12.5.m + 5.0 + 3<br>&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>&gt; ===<br>&gt; <br>&gt; The main restriction this syntax should do is disallow intermixing of numeric types (even if they all descend from Double, Int, etc.) and not allow adding untyped numerics (i.e. those without a type suffix), unless explicitly asked for in the code.<br>&gt; <br>&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt; =====<br>&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt; distance += number.m   //number is converted to m (meters)<br>&gt; =====<br>&gt; <br>&gt; From the Swift 3 Language guide, we are for example given the following example:<br>&gt; =====<br>&gt; extension Double {<br>&gt;   var km: Double { return self * 1_000.0 }<br>&gt;   var m: Double { return self }<br>&gt;   var cm: Double { return self / 100.0 }<br>&gt;   var mm: Double { return self / 1_000.0 }<br>&gt;   var ft: Double { return self / 3.28084 }<br>&gt; }<br>&gt; <br>&gt; let aMarathon = 42.km &lt;http://42.km/&gt; + 195.m<br>&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt; =====<br>&gt; <br>&gt; This is quite nice to suffix a conversion method after the value, but if I had another extension that converts the values to pounds and kilograms, then one can illegally do this:<br>&gt;      let aValue = 42.km &lt;http://42.km/&gt; + 195.m + 17.pounds + 5.0<br>&gt; and then the code would still compile and run, but not work as intended.<br>&gt; <br>&gt; Extra reading, and inspiration for a feature like the above:<br>&gt; Mars Probe Lost Due to Simple Math Error<br>&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288 &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt; <br>&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft engineers failed to convert from English to metric measurements when exchanging vital data before the craft was launched, space agency officials said Thursday.<br>&gt; <br>&gt; A navigation team at the Jet Propulsion Laboratory used the metric system of millimeters and meters in its calculations, while Lockheed Martin Astronautics in Denver, which designed and built the spacecraft, provided crucial acceleration data in the English system of inches, feet and pounds.<br>&gt; <br>&gt; As a result, JPL engineers mistook acceleration readings measured in English units of pound-seconds for a metric measure of force called newton-seconds.&quot;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/ad538053/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 22, 2016 at 07:00:00pm</p></header><div class="content"><p>The first question is what the meaning of , for example, a multiplication <br>of Distance ? I.e.<br>let x1 : Distance = 10.m<br>let x2 : Distance = 10.km<br>let x3 = x1 * x2  // ???<br></p><p>I.e. as soon as your Distance is Double, you allows all kind of floating <br>point operations on instances of this type. And some such operations has no <br>meaning for Distance. So, in your proposal, you need to somehow control <br>allowed operations.<br></p><p>And I believe you can get what you want right now with enums(If I&#39;m not <br>missing something):<br></p><p>enum Distance  {<br>     case km(Double)<br>     case m(Double)<br>     case mm(Double)<br></p><p>     func inKilometers() -&gt; Double {<br>         return inMeters() / 1000.0<br>     }<br></p><p>     func inMeters() -&gt; Double {<br>         switch self {<br>             case .km(let value) : return value * 1000.0<br>             case .m(let value) : return value<br>             case .mm(let value) : return value / 1000.0<br>         }<br>     }<br></p><p>     func inMillimeters() -&gt; Double {<br>         return inMeters() * 1000.0<br>     }<br></p><p>     static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>         return .m(lhs.inMeters() + rhs.inMeters())<br>     }<br></p><p>     static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>         return .m(lhs.inMeters() - rhs.inMeters())<br>     }<br></p><p>     // implement needed operations here..<br>}<br></p><p>extension Double {<br>     var km : Distance { return Distance.km(self) }<br>     var m : Distance { return Distance.m(self) }<br>     var mm : Distance { return Distance.mm(self) }<br>}<br></p><p>let dist : Distance = 10.km + 5.m + 5.mm<br></p><p>print(dist.inMeters()) // 10005.005<br>print(dist.inKilometers()) // 10.005005<br></p><p>More verbose, but more control. From other point of view, currently you&#39;ll <br>need a lot of code for each such type(like Distance).<br></p><p>But I do think that such ability to create custom domain-specific types <br>based on standard value types is a useful feature which can improve a <br>quality of code and can reduce the number of bugs.<br></p><p>The syntax to declare such type should be simple and clear, to be able to <br>declare a number of such types without a lot of boilerplate code. Something <br>like this:<br></p><p>typealias Distance : Double {<br>     var km : Distance { return self * 1000.0 }<br>     var m : Distance { return self  }<br>     var mm : Distance { return self / 1000.0 }<br>     inherit [+,-,/]<br>}<br></p><p>IMO such type is more a type alias than new structure<br></p><p>On 22.08.2016 17:54, Nur Ismail via swift-evolution wrote:<br>&gt; Hi,<br>&gt;<br>&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt; Basically numeric values (such as Double, Int, etc.) that are strongly<br>&gt; typed to a specific use case, for example Distance, Weight, etc. and cannot<br>&gt; be intermixed with untyped values.<br>&gt;<br>&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt; =====<br>&gt; //Distance<br>&gt; struct fixedtype Distance : Double {<br>&gt; var km: …<br>&gt; var m: …<br>&gt; typealias meters: m<br>&gt; var feet: ...<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; //Weight<br>&gt; struct fixedtype Weight : Double {<br>&gt; var kg: …<br>&gt; var g: …<br>&gt; typealias grams : g<br>&gt; var pound: ...<br>&gt; }<br>&gt;<br>&gt; …<br>&gt; var weight : Weight = 5.kg &lt;http://5.kg/&gt; + 5.g + 7.m<br>&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt; var distance: Distance = 7.km &lt;http://7.km/&gt; + 12.5.m + 5.0 + 3<br>&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>&gt; ===<br>&gt;<br>&gt; The main restriction this syntax should do is disallow intermixing of<br>&gt; numeric types (even if they all descend from Double, Int, etc.) and not<br>&gt; allow adding untyped numerics (i.e. those without a type suffix), unless<br>&gt; explicitly asked for in the code.<br>&gt;<br>&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt; =====<br>&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt; distance += number.m   //number is converted to m (meters)<br>&gt; =====<br>&gt;<br>&gt; From the Swift 3 Language guide, we are for example given the following<br>&gt; example:<br>&gt; =====<br>&gt; extension Double {<br>&gt;   var km: Double { return self * 1_000.0 }<br>&gt;   var m: Double { return self }<br>&gt;   var cm: Double { return self / 100.0 }<br>&gt;   var mm: Double { return self / 1_000.0 }<br>&gt;   var ft: Double { return self / 3.28084 }<br>&gt; }<br>&gt;<br>&gt; let aMarathon = 42.km &lt;http://42.km/&gt; + 195.m<br>&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt; =====<br>&gt;<br>&gt; This is quite nice to suffix a conversion method after the value, but if I<br>&gt; had another extension that converts the values to pounds and kilograms,<br>&gt; then one can illegally do this:<br>&gt;      let aValue = 42.km &lt;http://42.km/&gt; + 195.m + 17.pounds + 5.0<br>&gt; and then the code would still compile and run, but not work as intended.<br>&gt;<br>&gt; Extra reading, and inspiration for a feature like the above:<br>&gt; Mars Probe Lost Due to Simple Math Error<br>&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt; &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt;<br>&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft<br>&gt; engineers failed to convert from English to metric measurements when<br>&gt; exchanging vital data before the craft was launched, space agency officials<br>&gt; said Thursday.<br>&gt;<br>&gt; A navigation team at the Jet Propulsion Laboratory used the metric system<br>&gt; of millimeters and meters in its calculations, while Lockheed Martin<br>&gt; Astronautics in Denver, which designed and built the spacecraft, provided<br>&gt; crucial acceleration data in the English system of inches, feet and pounds.<br>&gt;<br>&gt; As a result, JPL engineers mistook acceleration readings measured in<br>&gt; English units of pound-seconds for a metric measure of force called<br>&gt; newton-seconds.&quot;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 22, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;ve personally come across something like Nur suggested. In particular, this is with NSTimeInterval, which is a typedef for Double.<br></p><p>What I wanted to do is to make<br></p><p>extension NSTimeInterval {<br>	static let minute: NSTimeInterval = 60.0<br>	static let hour: NSTimeInterval = 3600.0<br>	/// ... day, ...<br>}<br></p><p>and you can then use it NSTimeInterval.minute.<br></p><p>The issue now is that is polutes the Double type as well, so currently, it&#39;s valid to write Double.minute with the code above - which is not disirable behavior IMHO.<br></p><p>Sure, you can work around by introducing e.g. enum or an empty struct TimeIntervals with static members, but I personally think that making specialized subtypes of numeric types is a good way to introduce some constants while not poluting the entire namespace.<br></p><p>Or maybe it&#39;s me still thinking too much in C-style and the proper way would be to represent NSTimeInterval as a different type...<br></p><p>&gt; On Aug 22, 2016, at 6:07 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The first question is what the meaning of , for example, a multiplication of Distance ? I.e.<br>&gt; let x1 : Distance = 10.m<br>&gt; let x2 : Distance = 10.km<br>&gt; let x3 = x1 * x2  // ???<br>&gt; <br>&gt; I.e. as soon as your Distance is Double, you allows all kind of floating point operations on instances of this type. And some such operations has no meaning for Distance. So, in your proposal, you need to somehow control allowed operations.<br>&gt; <br>&gt; And I believe you can get what you want right now with enums(If I&#39;m not missing something):<br>&gt; <br>&gt; enum Distance  {<br>&gt;    case km(Double)<br>&gt;    case m(Double)<br>&gt;    case mm(Double)<br>&gt; <br>&gt;    func inKilometers() -&gt; Double {<br>&gt;        return inMeters() / 1000.0<br>&gt;    }<br>&gt; <br>&gt;    func inMeters() -&gt; Double {<br>&gt;        switch self {<br>&gt;            case .km(let value) : return value * 1000.0<br>&gt;            case .m(let value) : return value<br>&gt;            case .mm(let value) : return value / 1000.0<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    func inMillimeters() -&gt; Double {<br>&gt;        return inMeters() * 1000.0<br>&gt;    }<br>&gt; <br>&gt;    static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;        return .m(lhs.inMeters() + rhs.inMeters())<br>&gt;    }<br>&gt; <br>&gt;    static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;        return .m(lhs.inMeters() - rhs.inMeters())<br>&gt;    }<br>&gt; <br>&gt;    // implement needed operations here..<br>&gt; }<br>&gt; <br>&gt; extension Double {<br>&gt;    var km : Distance { return Distance.km(self) }<br>&gt;    var m : Distance { return Distance.m(self) }<br>&gt;    var mm : Distance { return Distance.mm(self) }<br>&gt; }<br>&gt; <br>&gt; let dist : Distance = 10.km + 5.m + 5.mm<br>&gt; <br>&gt; print(dist.inMeters()) // 10005.005<br>&gt; print(dist.inKilometers()) // 10.005005<br>&gt; <br>&gt; More verbose, but more control. From other point of view, currently you&#39;ll need a lot of code for each such type(like Distance).<br>&gt; <br>&gt; But I do think that such ability to create custom domain-specific types based on standard value types is a useful feature which can improve a quality of code and can reduce the number of bugs.<br>&gt; <br>&gt; The syntax to declare such type should be simple and clear, to be able to declare a number of such types without a lot of boilerplate code. Something like this:<br>&gt; <br>&gt; typealias Distance : Double {<br>&gt;    var km : Distance { return self * 1000.0 }<br>&gt;    var m : Distance { return self  }<br>&gt;    var mm : Distance { return self / 1000.0 }<br>&gt;    inherit [+,-,/]<br>&gt; }<br>&gt; <br>&gt; IMO such type is more a type alias than new structure<br>&gt; <br>&gt; On 22.08.2016 17:54, Nur Ismail via swift-evolution wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt;&gt; Basically numeric values (such as Double, Int, etc.) that are strongly<br>&gt;&gt; typed to a specific use case, for example Distance, Weight, etc. and cannot<br>&gt;&gt; be intermixed with untyped values.<br>&gt;&gt; <br>&gt;&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt;&gt; =====<br>&gt;&gt; //Distance<br>&gt;&gt; struct fixedtype Distance : Double {<br>&gt;&gt; var km: …<br>&gt;&gt; var m: …<br>&gt;&gt; typealias meters: m<br>&gt;&gt; var feet: ...<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //Weight<br>&gt;&gt; struct fixedtype Weight : Double {<br>&gt;&gt; var kg: …<br>&gt;&gt; var g: …<br>&gt;&gt; typealias grams : g<br>&gt;&gt; var pound: ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …<br>&gt;&gt; var weight : Weight = 5.kg &lt;http://5.kg/&gt; + 5.g + 7.m<br>&gt;&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt;&gt; var distance: Distance = 7.km &lt;http://7.km/&gt; + 12.5.m + 5.0 + 3<br>&gt;&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>&gt;&gt; ===<br>&gt;&gt; <br>&gt;&gt; The main restriction this syntax should do is disallow intermixing of<br>&gt;&gt; numeric types (even if they all descend from Double, Int, etc.) and not<br>&gt;&gt; allow adding untyped numerics (i.e. those without a type suffix), unless<br>&gt;&gt; explicitly asked for in the code.<br>&gt;&gt; <br>&gt;&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt;&gt; =====<br>&gt;&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt;&gt; distance += number.m   //number is converted to m (meters)<br>&gt;&gt; =====<br>&gt;&gt; <br>&gt;&gt; From the Swift 3 Language guide, we are for example given the following<br>&gt;&gt; example:<br>&gt;&gt; =====<br>&gt;&gt; extension Double {<br>&gt;&gt;  var km: Double { return self * 1_000.0 }<br>&gt;&gt;  var m: Double { return self }<br>&gt;&gt;  var cm: Double { return self / 100.0 }<br>&gt;&gt;  var mm: Double { return self / 1_000.0 }<br>&gt;&gt;  var ft: Double { return self / 3.28084 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let aMarathon = 42.km &lt;http://42.km/&gt; + 195.m<br>&gt;&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt;&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt;&gt; =====<br>&gt;&gt; <br>&gt;&gt; This is quite nice to suffix a conversion method after the value, but if I<br>&gt;&gt; had another extension that converts the values to pounds and kilograms,<br>&gt;&gt; then one can illegally do this:<br>&gt;&gt;     let aValue = 42.km &lt;http://42.km/&gt; + 195.m + 17.pounds + 5.0<br>&gt;&gt; and then the code would still compile and run, but not work as intended.<br>&gt;&gt; <br>&gt;&gt; Extra reading, and inspiration for a feature like the above:<br>&gt;&gt; Mars Probe Lost Due to Simple Math Error<br>&gt;&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;&gt; &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt;&gt; <br>&gt;&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft<br>&gt;&gt; engineers failed to convert from English to metric measurements when<br>&gt;&gt; exchanging vital data before the craft was launched, space agency officials<br>&gt;&gt; said Thursday.<br>&gt;&gt; <br>&gt;&gt; A navigation team at the Jet Propulsion Laboratory used the metric system<br>&gt;&gt; of millimeters and meters in its calculations, while Lockheed Martin<br>&gt;&gt; Astronautics in Denver, which designed and built the spacecraft, provided<br>&gt;&gt; crucial acceleration data in the English system of inches, feet and pounds.<br>&gt;&gt; <br>&gt;&gt; As a result, JPL engineers mistook acceleration readings measured in<br>&gt;&gt; English units of pound-seconds for a metric measure of force called<br>&gt;&gt; newton-seconds.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 22 Aug 2016, at 18:17, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve personally come across something like Nur suggested. In particular, this is with NSTimeInterval, which is a typedef for Double.<br>&gt; <br>&gt; What I wanted to do is to make<br>&gt; <br>&gt; extension NSTimeInterval {<br>&gt; 	static let minute: NSTimeInterval = 60.0<br>&gt; 	static let hour: NSTimeInterval = 3600.0<br>&gt; 	/// ... day, ...<br>&gt; }<br>&gt; <br>&gt; and you can then use it NSTimeInterval.minute.<br>&gt; <br>&gt; The issue now is that is polutes the Double type as well, so currently, it&#39;s valid to write Double.minute with the code above - which is not disirable behavior IMHO.<br>&gt; <br>&gt; Sure, you can work around by introducing e.g. enum or an empty struct TimeIntervals with static members, but I personally think that making specialized subtypes of numeric types is a good way to introduce some constants while not poluting the entire namespace.<br>&gt; <br>&gt; Or maybe it&#39;s me still thinking too much in C-style and the proper way would be to represent NSTimeInterval as a different type...<br></p><p>In that particular case I would say NSTimeInterval should be a struct with convenient initialisers. Similarly to DispatchTime(Interval).<br></p><p>Have you seen the new Foundation Measurement API? http://oleb.net/blog/2016/07/measurements-and-units/<br></p><p>Karl<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0c6689d6389b72de39ed485a92217101?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Nur Ismail</string> &lt;nur at estalea.com&gt;<p>August 23, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Vladimir,<br></p><p>Thanks for your code, it&#39;s actually quite close to what I want :)<br></p><p>Some comments:<br>1) The main downside is that to read back the value, one can&#39;t re-use &quot;.m&quot;,<br>&quot;.km&quot;, etc. and have to use &quot;.inMeters()&quot;, etc. Would have been nice to be<br>able read and write using the same suffixes.<br></p><p>2) Works quite well on assigning values, and works as expected with a lot<br>of control of allowed operations, etc. However can make things verbose as<br>you also mentioned when needing to define many different types, but that&#39;s<br>a limitation of Swift not supporting this &quot;Typed Numerics&quot; natively rather<br>than your code :)<br></p><p>3) Requires an extra byte to store the enumeration value internally, so<br>whereas Double is 8 bytes, Distance would be 9 bytes. Sometimes it might be<br>desirable to store the original type the value was assigned with, for<br>example .km, and only convert to appropriate type when reading, whereas<br>other times it&#39;s best to convert immediately to the preferred type on<br>assignment which would be .m (or meters) in this case, perhaps use the<br>&quot;default&quot; keyword next to the type?. Also compiler support would be<br>advantageous here also, so that constant expressions can be evaluated at<br>compile time with no overhead, so that if I put... let dist : Distance =<br>125.km, dist is converted at compile time to 125000.m.<br></p><p>4) Agree that this &quot;feature&quot; should rather be a type alias, as we dealing<br>with types rather than a structure.<br></p><p>5) If Swift could support the shortened typed numeric syntax natively, and<br>with the efficiency that can only happen in the compiler itself so that it<br>works as fast and efficiently as normal untyped numbers that would be<br>awesome :)<br></p><p>6) I think a feature like this could make Swift even more useful in<br>scientific and other critical applications where they deal with many<br>different types of numbers, such as velocity, acceleration, gravity, power,<br>watts, distance, etc. etc.<br></p><p>Also normal everyday code, for example,<br>    func circle(radius: Double) ... //Is that radius in pixels, meters,<br>millimetres or something else? But if radius was defined as our fancy<br>Distance (assuming we add pixels (px) too :), then they could call it with:<br>    circle(radius: 150.px) //or<br>    circle(radius: 100.mm) //or<br>    circle(radius: 10.cm)<br>    //etc.<br></p><p>This would help make the code clearer, and lead to better quality code and<br>hopefully less bugs.<br></p><p>Regards,<br>Nur<br></p><p>On Mon, Aug 22, 2016 at 6:07 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; The first question is what the meaning of , for example, a multiplication<br>&gt; of Distance ? I.e.<br>&gt; let x1 : Distance = 10.m<br>&gt; let x2 : Distance = 10.km<br>&gt; let x3 = x1 * x2  // ???<br>&gt;<br>&gt; I.e. as soon as your Distance is Double, you allows all kind of floating<br>&gt; point operations on instances of this type. And some such operations has no<br>&gt; meaning for Distance. So, in your proposal, you need to somehow control<br>&gt; allowed operations.<br>&gt;<br>&gt; And I believe you can get what you want right now with enums(If I&#39;m not<br>&gt; missing something):<br>&gt;<br>&gt; enum Distance  {<br>&gt;     case km(Double)<br>&gt;     case m(Double)<br>&gt;     case mm(Double)<br>&gt;<br>&gt;     func inKilometers() -&gt; Double {<br>&gt;         return inMeters() / 1000.0<br>&gt;     }<br>&gt;<br>&gt;     func inMeters() -&gt; Double {<br>&gt;         switch self {<br>&gt;             case .km(let value) : return value * 1000.0<br>&gt;             case .m(let value) : return value<br>&gt;             case .mm(let value) : return value / 1000.0<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func inMillimeters() -&gt; Double {<br>&gt;         return inMeters() * 1000.0<br>&gt;     }<br>&gt;<br>&gt;     static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;         return .m(lhs.inMeters() + rhs.inMeters())<br>&gt;     }<br>&gt;<br>&gt;     static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;         return .m(lhs.inMeters() - rhs.inMeters())<br>&gt;     }<br>&gt;<br>&gt;     // implement needed operations here..<br>&gt; }<br>&gt;<br>&gt; extension Double {<br>&gt;     var km : Distance { return Distance.km(self) }<br>&gt;     var m : Distance { return Distance.m(self) }<br>&gt;     var mm : Distance { return Distance.mm(self) }<br>&gt; }<br>&gt;<br>&gt; let dist : Distance = 10.km + 5.m + 5.mm<br>&gt;<br>&gt; print(dist.inMeters()) // 10005.005<br>&gt; print(dist.inKilometers()) // 10.005005<br>&gt;<br>&gt; More verbose, but more control. From other point of view, currently you&#39;ll<br>&gt; need a lot of code for each such type(like Distance).<br>&gt;<br>&gt; But I do think that such ability to create custom domain-specific types<br>&gt; based on standard value types is a useful feature which can improve a<br>&gt; quality of code and can reduce the number of bugs.<br>&gt;<br>&gt; The syntax to declare such type should be simple and clear, to be able to<br>&gt; declare a number of such types without a lot of boilerplate code. Something<br>&gt; like this:<br>&gt;<br>&gt; typealias Distance : Double {<br>&gt;     var km : Distance { return self * 1000.0 }<br>&gt;     var m : Distance { return self  }<br>&gt;     var mm : Distance { return self / 1000.0 }<br>&gt;     inherit [+,-,/]<br>&gt; }<br>&gt;<br>&gt; IMO such type is more a type alias than new structure<br>&gt;<br>&gt; On 22.08.2016 17:54, Nur Ismail via swift-evolution wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt;&gt; Basically numeric values (such as Double, Int, etc.) that are strongly<br>&gt;&gt; typed to a specific use case, for example Distance, Weight, etc. and<br>&gt;&gt; cannot<br>&gt;&gt; be intermixed with untyped values.<br>&gt;&gt;<br>&gt;&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt;&gt; =====<br>&gt;&gt; //Distance<br>&gt;&gt; struct fixedtype Distance : Double {<br>&gt;&gt; var km: …<br>&gt;&gt; var m: …<br>&gt;&gt; typealias meters: m<br>&gt;&gt; var feet: ...<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; //Weight<br>&gt;&gt; struct fixedtype Weight : Double {<br>&gt;&gt; var kg: …<br>&gt;&gt; var g: …<br>&gt;&gt; typealias grams : g<br>&gt;&gt; var pound: ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …<br>&gt;&gt; var weight : Weight = 5.kg &lt;http://5.kg/&gt; + 5.g + 7.m<br>&gt;&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt;&gt; var distance: Distance = 7.km &lt;http://7.km/&gt; + 12.5.m + 5.0 + 3<br>&gt;&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to<br>&gt;&gt; Distance...<br>&gt;&gt; ===<br>&gt;&gt;<br>&gt;&gt; The main restriction this syntax should do is disallow intermixing of<br>&gt;&gt; numeric types (even if they all descend from Double, Int, etc.) and not<br>&gt;&gt; allow adding untyped numerics (i.e. those without a type suffix), unless<br>&gt;&gt; explicitly asked for in the code.<br>&gt;&gt;<br>&gt;&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt;&gt; =====<br>&gt;&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt;&gt; distance += number.m   //number is converted to m (meters)<br>&gt;&gt; =====<br>&gt;&gt;<br>&gt;&gt; From the Swift 3 Language guide, we are for example given the following<br>&gt;&gt; example:<br>&gt;&gt; =====<br>&gt;&gt; extension Double {<br>&gt;&gt;   var km: Double { return self * 1_000.0 }<br>&gt;&gt;   var m: Double { return self }<br>&gt;&gt;   var cm: Double { return self / 100.0 }<br>&gt;&gt;   var mm: Double { return self / 1_000.0 }<br>&gt;&gt;   var ft: Double { return self / 3.28084 }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let aMarathon = 42.km &lt;http://42.km/&gt; + 195.m<br>&gt;&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt;&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt;&gt; =====<br>&gt;&gt;<br>&gt;&gt; This is quite nice to suffix a conversion method after the value, but if I<br>&gt;&gt; had another extension that converts the values to pounds and kilograms,<br>&gt;&gt; then one can illegally do this:<br>&gt;&gt;      let aValue = 42.km &lt;http://42.km/&gt; + 195.m + 17.pounds + 5.0<br>&gt;&gt; and then the code would still compile and run, but not work as intended.<br>&gt;&gt;<br>&gt;&gt; Extra reading, and inspiration for a feature like the above:<br>&gt;&gt; Mars Probe Lost Due to Simple Math Error<br>&gt;&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;&gt; &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt;&gt;<br>&gt;&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft<br>&gt;&gt; engineers failed to convert from English to metric measurements when<br>&gt;&gt; exchanging vital data before the craft was launched, space agency<br>&gt;&gt; officials<br>&gt;&gt; said Thursday.<br>&gt;&gt;<br>&gt;&gt; A navigation team at the Jet Propulsion Laboratory used the metric system<br>&gt;&gt; of millimeters and meters in its calculations, while Lockheed Martin<br>&gt;&gt; Astronautics in Denver, which designed and built the spacecraft, provided<br>&gt;&gt; crucial acceleration data in the English system of inches, feet and<br>&gt;&gt; pounds.<br>&gt;&gt;<br>&gt;&gt; As a result, JPL engineers mistook acceleration readings measured in<br>&gt;&gt; English units of pound-seconds for a metric measure of force called<br>&gt;&gt; newton-seconds.&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/167401ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 23, 2016 at 07:00:00pm</p></header><div class="content"><p>On 23.08.2016 12:42, Nur Ismail wrote:<br>&gt; Hi Vladimir,<br>&gt;<br>&gt; Thanks for your code, it&#39;s actually quite close to what I want :)<br>&gt;<br>&gt; Some comments:<br>&gt; 1) The main downside is that to read back the value, one can&#39;t re-use &quot;.m&quot;,<br>&gt; &quot;.km&quot;, etc. and have to use &quot;.inMeters()&quot;, etc. Would have been nice to be<br>&gt; able read and write using the same suffixes.<br></p><p>I agree with all of your points. And about this first.. Yes, I think this <br>variant is better:<br></p><p>struct Distance  {<br></p><p>     var km : Double { return self.m / 1000.0 }<br>     var m: Double<br>     var mm : Double { return self.m * 1000.0 }<br></p><p>     init(m: Double) {<br>         self.m = m<br>     }<br></p><p>     init(km: Double) {<br>         self.m = km * 1000.0<br>     }<br></p><p>     init(mm: Double) {<br>         self.m = mm / 1000.0<br>     }<br></p><p>     static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>         return Distance(m: lhs.m + rhs.m)<br>     }<br></p><p>     static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>         return Distance(m: lhs.m - rhs.m)<br>     }<br>}<br></p><p>extension Double {<br>     var km : Distance { return Distance(km: self) }<br>     var m : Distance { return Distance(m: self) }<br>     var mm : Distance { return Distance(mm: self) }<br>}<br></p><p><br>let dist : Distance = 10.km + 5.m + 5.mm<br></p><p>print(dist.m) // 10005.005<br>print(dist.km) // 10.005005<br>print(MemoryLayout&lt;Distance&gt;.size) // 8<br></p><p>&gt;<br>&gt; 2) Works quite well on assigning values, and works as expected with a lot<br>&gt; of control of allowed operations, etc. However can make things verbose as<br>&gt; you also mentioned when needing to define many different types, but that&#39;s<br>&gt; a limitation of Swift not supporting this &quot;Typed Numerics&quot; natively rather<br>&gt; than your code :)<br>&gt;<br>&gt; 3) Requires an extra byte to store the enumeration value internally, so<br>&gt; whereas Double is 8 bytes, Distance would be 9 bytes. Sometimes it might be<br>&gt; desirable to store the original type the value was assigned with, for<br>&gt; example .km, and only convert to appropriate type when reading, whereas<br>&gt; other times it&#39;s best to convert immediately to the preferred type on<br>&gt; assignment which would be .m (or meters) in this case, perhaps use the<br>&gt; &quot;default&quot; keyword next to the type?. Also compiler support would be<br>&gt; advantageous here also, so that constant expressions can be evaluated at<br>&gt; compile time with no overhead, so that if I put... let dist : Distance =<br>&gt; 125.km &lt;http://125.km&gt;, dist is converted at compile time to 125000.m.<br>&gt;<br>&gt; 4) Agree that this &quot;feature&quot; should rather be a type alias, as we dealing<br>&gt; with types rather than a structure.<br>&gt;<br>&gt; 5) If Swift could support the shortened typed numeric syntax natively, and<br>&gt; with the efficiency that can only happen in the compiler itself so that it<br>&gt; works as fast and efficiently as normal untyped numbers that would be<br>&gt; awesome :)<br>&gt;<br>&gt; 6) I think a feature like this could make Swift even more useful in<br>&gt; scientific and other critical applications where they deal with many<br>&gt; different types of numbers, such as velocity, acceleration, gravity, power,<br>&gt; watts, distance, etc. etc.<br>&gt;<br>&gt; Also normal everyday code, for example,<br>&gt;     func circle(radius: Double) ... //Is that radius in pixels, meters,<br>&gt; millimetres or something else? But if radius was defined as our fancy<br>&gt; Distance (assuming we add pixels (px) too :), then they could call it with:<br>&gt;     circle(radius: 150.px) //or<br>&gt;     circle(radius: 100.mm &lt;http://100.mm&gt;) //or<br>&gt;     circle(radius: 10.cm &lt;http://10.cm&gt;)<br>&gt;     //etc.<br>&gt;<br>&gt; This would help make the code clearer, and lead to better quality code and<br>&gt; hopefully less bugs.<br>&gt;<br>&gt; Regards,<br>&gt; Nur<br>&gt;<br>&gt; On Mon, Aug 22, 2016 at 6:07 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;     The first question is what the meaning of , for example, a<br>&gt;     multiplication of Distance ? I.e.<br>&gt;     let x1 : Distance = 10.m<br>&gt;     let x2 : Distance = 10.km &lt;http://10.km&gt;<br>&gt;     let x3 = x1 * x2  // ???<br>&gt;<br>&gt;     I.e. as soon as your Distance is Double, you allows all kind of<br>&gt;     floating point operations on instances of this type. And some such<br>&gt;     operations has no meaning for Distance. So, in your proposal, you need<br>&gt;     to somehow control allowed operations.<br>&gt;<br>&gt;     And I believe you can get what you want right now with enums(If I&#39;m not<br>&gt;     missing something):<br>&gt;<br>&gt;     enum Distance  {<br>&gt;         case km(Double)<br>&gt;         case m(Double)<br>&gt;         case mm(Double)<br>&gt;<br>&gt;         func inKilometers() -&gt; Double {<br>&gt;             return inMeters() / 1000.0<br>&gt;         }<br>&gt;<br>&gt;         func inMeters() -&gt; Double {<br>&gt;             switch self {<br>&gt;                 case .km(let value) : return value * 1000.0<br>&gt;                 case .m(let value) : return value<br>&gt;                 case .mm(let value) : return value / 1000.0<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         func inMillimeters() -&gt; Double {<br>&gt;             return inMeters() * 1000.0<br>&gt;         }<br>&gt;<br>&gt;         static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;             return .m(lhs.inMeters() + rhs.inMeters())<br>&gt;         }<br>&gt;<br>&gt;         static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;             return .m(lhs.inMeters() - rhs.inMeters())<br>&gt;         }<br>&gt;<br>&gt;         // implement needed operations here..<br>&gt;     }<br>&gt;<br>&gt;     extension Double {<br>&gt;         var km : Distance { return Distance.km(self) }<br>&gt;         var m : Distance { return Distance.m(self) }<br>&gt;         var mm : Distance { return Distance.mm(self) }<br>&gt;     }<br>&gt;<br>&gt;     let dist : Distance = 10.km &lt;http://10.km&gt; + 5.m + 5.mm &lt;http://5.mm&gt;<br>&gt;<br>&gt;     print(dist.inMeters()) // 10005.005<br>&gt;     print(dist.inKilometers()) // 10.005005<br>&gt;<br>&gt;     More verbose, but more control. From other point of view, currently<br>&gt;     you&#39;ll need a lot of code for each such type(like Distance).<br>&gt;<br>&gt;     But I do think that such ability to create custom domain-specific types<br>&gt;     based on standard value types is a useful feature which can improve a<br>&gt;     quality of code and can reduce the number of bugs.<br>&gt;<br>&gt;     The syntax to declare such type should be simple and clear, to be able<br>&gt;     to declare a number of such types without a lot of boilerplate code.<br>&gt;     Something like this:<br>&gt;<br>&gt;     typealias Distance : Double {<br>&gt;         var km : Distance { return self * 1000.0 }<br>&gt;         var m : Distance { return self  }<br>&gt;         var mm : Distance { return self / 1000.0 }<br>&gt;         inherit [+,-,/]<br>&gt;     }<br>&gt;<br>&gt;     IMO such type is more a type alias than new structure<br>&gt;<br>&gt;     On 22.08.2016 17 &lt;tel:22.08.2016%2017&gt;:54, Nur Ismail via<br>&gt;     swift-evolution wrote:<br>&gt;<br>&gt;         Hi,<br>&gt;<br>&gt;         I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt;         Basically numeric values (such as Double, Int, etc.) that are strongly<br>&gt;         typed to a specific use case, for example Distance, Weight, etc.<br>&gt;         and cannot<br>&gt;         be intermixed with untyped values.<br>&gt;<br>&gt;         So if I have (the syntax is made up, but perhaps something like this):<br>&gt;         =====<br>&gt;         //Distance<br>&gt;         struct fixedtype Distance : Double {<br>&gt;         var km: …<br>&gt;         var m: …<br>&gt;         typealias meters: m<br>&gt;         var feet: ...<br>&gt;         ...<br>&gt;         }<br>&gt;<br>&gt;         //Weight<br>&gt;         struct fixedtype Weight : Double {<br>&gt;         var kg: …<br>&gt;         var g: …<br>&gt;         typealias grams : g<br>&gt;         var pound: ...<br>&gt;         }<br>&gt;<br>&gt;         …<br>&gt;         var weight : Weight = 5.kg &lt;http://5.kg&gt; &lt;http://5.kg/&gt; + 5.g + 7.m<br>&gt;         ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt;         var distance: Distance = 7.km &lt;http://7.km&gt; &lt;http://7.km/&gt; + 12.5.m<br>&gt;         + 5.0 + 3<br>&gt;         ………………………………………………...^ Compiler Error: can’t add untyped number to<br>&gt;         Distance...<br>&gt;         ===<br>&gt;<br>&gt;         The main restriction this syntax should do is disallow intermixing of<br>&gt;         numeric types (even if they all descend from Double, Int, etc.) and not<br>&gt;         allow adding untyped numerics (i.e. those without a type suffix),<br>&gt;         unless<br>&gt;         explicitly asked for in the code.<br>&gt;<br>&gt;         Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt;         =====<br>&gt;         let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt;         distance += number.m   //number is converted to m (meters)<br>&gt;         =====<br>&gt;<br>&gt;         &gt;From the Swift 3 Language guide, we are for example given the following<br>&gt;         example:<br>&gt;         =====<br>&gt;         extension Double {<br>&gt;           var km: Double { return self * 1_000.0 }<br>&gt;           var m: Double { return self }<br>&gt;           var cm: Double { return self / 100.0 }<br>&gt;           var mm: Double { return self / 1_000.0 }<br>&gt;           var ft: Double { return self / 3.28084 }<br>&gt;         }<br>&gt;<br>&gt;         let aMarathon = 42.km &lt;http://42.km&gt; &lt;http://42.km/&gt; + 195.m<br>&gt;         print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt;         // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt;         =====<br>&gt;<br>&gt;         This is quite nice to suffix a conversion method after the value,<br>&gt;         but if I<br>&gt;         had another extension that converts the values to pounds and kilograms,<br>&gt;         then one can illegally do this:<br>&gt;              let aValue = 42.km &lt;http://42.km&gt; &lt;http://42.km/&gt; + 195.m +<br>&gt;         17.pounds + 5.0<br>&gt;         and then the code would still compile and run, but not work as<br>&gt;         intended.<br>&gt;<br>&gt;         Extra reading, and inspiration for a feature like the above:<br>&gt;         Mars Probe Lost Due to Simple Math Error<br>&gt;         http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;         &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt;         &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;         &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;&gt;<br>&gt;<br>&gt;         &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft<br>&gt;         engineers failed to convert from English to metric measurements when<br>&gt;         exchanging vital data before the craft was launched, space agency<br>&gt;         officials<br>&gt;         said Thursday.<br>&gt;<br>&gt;         A navigation team at the Jet Propulsion Laboratory used the metric<br>&gt;         system<br>&gt;         of millimeters and meters in its calculations, while Lockheed Martin<br>&gt;         Astronautics in Denver, which designed and built the spacecraft,<br>&gt;         provided<br>&gt;         crucial acceleration data in the English system of inches, feet and<br>&gt;         pounds.<br>&gt;<br>&gt;         As a result, JPL engineers mistook acceleration readings measured in<br>&gt;         English units of pound-seconds for a metric measure of force called<br>&gt;         newton-seconds.&quot;<br>&gt;<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0c6689d6389b72de39ed485a92217101?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Nur Ismail</string> &lt;nur at estalea.com&gt;<p>August 24, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Vladimir,<br></p><p>Your latest code is even nicer :) and works for most part, however found<br>the following issues below:<br></p><p><br>let dist : Distance = 10.km + 5.m + 5.mm<br></p><p>let dist2 : Distance = 100.km + 5.m<br></p><p>let weight : Weight = 10.pounds + 5.kg + 5.g  // Assume we have Weight type<br>defined also<br></p><p>//let num = 100.km + 10.pounds  // Not allowed, as different types.<br>Compiler error as expected!<br></p><p>let distSum = dist + dist2  // Okay<br></p><p><br>print(dist.m) // Okay<br></p><p><br>print(dist.km + 10.km) // Doesn&#39;t work, although it should. Compiler Error:<br>Binary operator &#39;+&#39; cannot be applied to operands of type &#39;Double&#39; and<br>&#39;Distance&#39;<br></p><p>print(dist.km + 10)   // 20.005005 // This works although it shouldn&#39;t!<br></p><p>print(dist.km * 200)  // 2001.001  // This works although it shouldn&#39;t!<br></p><p><br>print(dist.km + weight.kg) // 18.9470128740157  // This also works although<br>it shouldn&#39;t!<br></p><p>Also just still issue of Double space polluted with both Distance and<br>Weight extensions, but don&#39;t think we can get around that, unless we get<br>some compiler support :)<br></p><p>Regards,<br></p><p>On Tue, Aug 23, 2016 at 6:00 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; On 23.08.2016 12:42, Nur Ismail wrote:<br>&gt;<br>&gt;&gt; Hi Vladimir,<br>&gt;&gt;<br>&gt;&gt; Thanks for your code, it&#39;s actually quite close to what I want :)<br>&gt;&gt;<br>&gt;&gt; Some comments:<br>&gt;&gt; 1) The main downside is that to read back the value, one can&#39;t re-use<br>&gt;&gt; &quot;.m&quot;,<br>&gt;&gt; &quot;.km&quot;, etc. and have to use &quot;.inMeters()&quot;, etc. Would have been nice to be<br>&gt;&gt; able read and write using the same suffixes.<br>&gt;&gt;<br>&gt;<br>&gt; I agree with all of your points. And about this first.. Yes, I think this<br>&gt; variant is better:<br>&gt;<br>&gt; struct Distance  {<br>&gt;<br>&gt;     var km : Double { return self.m / 1000.0 }<br>&gt;     var m: Double<br>&gt;     var mm : Double { return self.m * 1000.0 }<br>&gt;<br>&gt;     init(m: Double) {<br>&gt;         self.m = m<br>&gt;     }<br>&gt;<br>&gt;     init(km: Double) {<br>&gt;         self.m = km * 1000.0<br>&gt;     }<br>&gt;<br>&gt;     init(mm: Double) {<br>&gt;         self.m = mm / 1000.0<br>&gt;     }<br>&gt;<br>&gt;     static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;         return Distance(m: lhs.m + rhs.m)<br>&gt;     }<br>&gt;<br>&gt;     static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;         return Distance(m: lhs.m - rhs.m)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension Double {<br>&gt;     var km : Distance { return Distance(km: self) }<br>&gt;     var m : Distance { return Distance(m: self) }<br>&gt;     var mm : Distance { return Distance(mm: self) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; let dist : Distance = 10.km + 5.m + 5.mm<br>&gt;<br>&gt; print(dist.m) // 10005.005<br>&gt; print(dist.km) // 10.005005<br>&gt; print(MemoryLayout&lt;Distance&gt;.size) // 8<br>&gt;<br>&gt;<br>&gt;&gt; 2) Works quite well on assigning values, and works as expected with a lot<br>&gt;&gt; of control of allowed operations, etc. However can make things verbose as<br>&gt;&gt; you also mentioned when needing to define many different types, but that&#39;s<br>&gt;&gt; a limitation of Swift not supporting this &quot;Typed Numerics&quot; natively rather<br>&gt;&gt; than your code :)<br>&gt;&gt;<br>&gt;&gt; 3) Requires an extra byte to store the enumeration value internally, so<br>&gt;&gt; whereas Double is 8 bytes, Distance would be 9 bytes. Sometimes it might<br>&gt;&gt; be<br>&gt;&gt; desirable to store the original type the value was assigned with, for<br>&gt;&gt; example .km, and only convert to appropriate type when reading, whereas<br>&gt;&gt; other times it&#39;s best to convert immediately to the preferred type on<br>&gt;&gt; assignment which would be .m (or meters) in this case, perhaps use the<br>&gt;&gt; &quot;default&quot; keyword next to the type?. Also compiler support would be<br>&gt;&gt; advantageous here also, so that constant expressions can be evaluated at<br>&gt;&gt; compile time with no overhead, so that if I put... let dist : Distance =<br>&gt;&gt; 125.km &lt;http://125.km&gt;, dist is converted at compile time to 125000.m.<br>&gt;&gt;<br>&gt;&gt; 4) Agree that this &quot;feature&quot; should rather be a type alias, as we dealing<br>&gt;&gt; with types rather than a structure.<br>&gt;&gt;<br>&gt;&gt; 5) If Swift could support the shortened typed numeric syntax natively, and<br>&gt;&gt; with the efficiency that can only happen in the compiler itself so that it<br>&gt;&gt; works as fast and efficiently as normal untyped numbers that would be<br>&gt;&gt; awesome :)<br>&gt;&gt;<br>&gt;&gt; 6) I think a feature like this could make Swift even more useful in<br>&gt;&gt; scientific and other critical applications where they deal with many<br>&gt;&gt; different types of numbers, such as velocity, acceleration, gravity,<br>&gt;&gt; power,<br>&gt;&gt; watts, distance, etc. etc.<br>&gt;&gt;<br>&gt;&gt; Also normal everyday code, for example,<br>&gt;&gt;     func circle(radius: Double) ... //Is that radius in pixels, meters,<br>&gt;&gt; millimetres or something else? But if radius was defined as our fancy<br>&gt;&gt; Distance (assuming we add pixels (px) too :), then they could call it<br>&gt;&gt; with:<br>&gt;&gt;     circle(radius: 150.px) //or<br>&gt;&gt;     circle(radius: 100.mm &lt;http://100.mm&gt;) //or<br>&gt;&gt;     circle(radius: 10.cm &lt;http://10.cm&gt;)<br>&gt;&gt;     //etc.<br>&gt;&gt;<br>&gt;&gt; This would help make the code clearer, and lead to better quality code and<br>&gt;&gt; hopefully less bugs.<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; Nur<br>&gt;&gt;<br>&gt;&gt; On Mon, Aug 22, 2016 at 6:07 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     The first question is what the meaning of , for example, a<br>&gt;&gt;     multiplication of Distance ? I.e.<br>&gt;&gt;     let x1 : Distance = 10.m<br>&gt;&gt;     let x2 : Distance = 10.km &lt;http://10.km&gt;<br>&gt;&gt;<br>&gt;&gt;     let x3 = x1 * x2  // ???<br>&gt;&gt;<br>&gt;&gt;     I.e. as soon as your Distance is Double, you allows all kind of<br>&gt;&gt;     floating point operations on instances of this type. And some such<br>&gt;&gt;     operations has no meaning for Distance. So, in your proposal, you need<br>&gt;&gt;     to somehow control allowed operations.<br>&gt;&gt;<br>&gt;&gt;     And I believe you can get what you want right now with enums(If I&#39;m<br>&gt;&gt; not<br>&gt;&gt;     missing something):<br>&gt;&gt;<br>&gt;&gt;     enum Distance  {<br>&gt;&gt;         case km(Double)<br>&gt;&gt;         case m(Double)<br>&gt;&gt;         case mm(Double)<br>&gt;&gt;<br>&gt;&gt;         func inKilometers() -&gt; Double {<br>&gt;&gt;             return inMeters() / 1000.0<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         func inMeters() -&gt; Double {<br>&gt;&gt;             switch self {<br>&gt;&gt;                 case .km(let value) : return value * 1000.0<br>&gt;&gt;                 case .m(let value) : return value<br>&gt;&gt;                 case .mm(let value) : return value / 1000.0<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         func inMillimeters() -&gt; Double {<br>&gt;&gt;             return inMeters() * 1000.0<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         static func +(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;&gt;             return .m(lhs.inMeters() + rhs.inMeters())<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         static func -(lhs: Distance, rhs: Distance) -&gt; Distance {<br>&gt;&gt;             return .m(lhs.inMeters() - rhs.inMeters())<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         // implement needed operations here..<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     extension Double {<br>&gt;&gt;         var km : Distance { return Distance.km(self) }<br>&gt;&gt;         var m : Distance { return Distance.m(self) }<br>&gt;&gt;         var mm : Distance { return Distance.mm(self) }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     let dist : Distance = 10.km &lt;http://10.km&gt; + 5.m + 5.mm &lt;http://5.mm&gt;<br>&gt;&gt;<br>&gt;&gt;     print(dist.inMeters()) // 10005.005<br>&gt;&gt;     print(dist.inKilometers()) // 10.005005<br>&gt;&gt;<br>&gt;&gt;     More verbose, but more control. From other point of view, currently<br>&gt;&gt;     you&#39;ll need a lot of code for each such type(like Distance).<br>&gt;&gt;<br>&gt;&gt;     But I do think that such ability to create custom domain-specific<br>&gt;&gt; types<br>&gt;&gt;     based on standard value types is a useful feature which can improve a<br>&gt;&gt;     quality of code and can reduce the number of bugs.<br>&gt;&gt;<br>&gt;&gt;     The syntax to declare such type should be simple and clear, to be able<br>&gt;&gt;     to declare a number of such types without a lot of boilerplate code.<br>&gt;&gt;     Something like this:<br>&gt;&gt;<br>&gt;&gt;     typealias Distance : Double {<br>&gt;&gt;         var km : Distance { return self * 1000.0 }<br>&gt;&gt;         var m : Distance { return self  }<br>&gt;&gt;         var mm : Distance { return self / 1000.0 }<br>&gt;&gt;         inherit [+,-,/]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     IMO such type is more a type alias than new structure<br>&gt;&gt;<br>&gt;&gt;     On 22.08.2016 17 &lt;tel:22.08.2016%2017&gt;:54, Nur Ismail via<br>&gt;&gt;     swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;         Hi,<br>&gt;&gt;<br>&gt;&gt;         I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt;&gt;         Basically numeric values (such as Double, Int, etc.) that are<br>&gt;&gt; strongly<br>&gt;&gt;         typed to a specific use case, for example Distance, Weight, etc.<br>&gt;&gt;         and cannot<br>&gt;&gt;         be intermixed with untyped values.<br>&gt;&gt;<br>&gt;&gt;         So if I have (the syntax is made up, but perhaps something like<br>&gt;&gt; this):<br>&gt;&gt;         =====<br>&gt;&gt;         //Distance<br>&gt;&gt;         struct fixedtype Distance : Double {<br>&gt;&gt;         var km: …<br>&gt;&gt;         var m: …<br>&gt;&gt;         typealias meters: m<br>&gt;&gt;         var feet: ...<br>&gt;&gt;         ...<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         //Weight<br>&gt;&gt;         struct fixedtype Weight : Double {<br>&gt;&gt;         var kg: …<br>&gt;&gt;         var g: …<br>&gt;&gt;         typealias grams : g<br>&gt;&gt;         var pound: ...<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         …<br>&gt;&gt;         var weight : Weight = 5.kg &lt;http://5.kg&gt; &lt;http://5.kg/&gt; + 5.g +<br>&gt;&gt; 7.m<br>&gt;&gt;         ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt;&gt;         var distance: Distance = 7.km &lt;http://7.km&gt; &lt;http://7.km/&gt; +<br>&gt;&gt; 12.5.m<br>&gt;&gt;         + 5.0 + 3<br>&gt;&gt;         ………………………………………………...^ Compiler Error: can’t add untyped number to<br>&gt;&gt;         Distance...<br>&gt;&gt;         ===<br>&gt;&gt;<br>&gt;&gt;         The main restriction this syntax should do is disallow<br>&gt;&gt; intermixing of<br>&gt;&gt;         numeric types (even if they all descend from Double, Int, etc.)<br>&gt;&gt; and not<br>&gt;&gt;         allow adding untyped numerics (i.e. those without a type suffix),<br>&gt;&gt;         unless<br>&gt;&gt;         explicitly asked for in the code.<br>&gt;&gt;<br>&gt;&gt;         Any of these can be converted to it&#39;s raw untyped value, for<br>&gt;&gt; example:<br>&gt;&gt;         =====<br>&gt;&gt;         let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt;&gt;         distance += number.m   //number is converted to m (meters)<br>&gt;&gt;         =====<br>&gt;&gt;<br>&gt;&gt;         &gt;From the Swift 3 Language guide, we are for example given the<br>&gt;&gt; following<br>&gt;&gt;         example:<br>&gt;&gt;         =====<br>&gt;&gt;         extension Double {<br>&gt;&gt;           var km: Double { return self * 1_000.0 }<br>&gt;&gt;           var m: Double { return self }<br>&gt;&gt;           var cm: Double { return self / 100.0 }<br>&gt;&gt;           var mm: Double { return self / 1_000.0 }<br>&gt;&gt;           var ft: Double { return self / 3.28084 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         let aMarathon = 42.km &lt;http://42.km&gt; &lt;http://42.km/&gt; + 195.m<br>&gt;&gt;         print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt;&gt;         // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt;&gt;         =====<br>&gt;&gt;<br>&gt;&gt;         This is quite nice to suffix a conversion method after the value,<br>&gt;&gt;         but if I<br>&gt;&gt;         had another extension that converts the values to pounds and<br>&gt;&gt; kilograms,<br>&gt;&gt;         then one can illegally do this:<br>&gt;&gt;              let aValue = 42.km &lt;http://42.km&gt; &lt;http://42.km/&gt; + 195.m +<br>&gt;&gt;<br>&gt;&gt;         17.pounds + 5.0<br>&gt;&gt;         and then the code would still compile and run, but not work as<br>&gt;&gt;         intended.<br>&gt;&gt;<br>&gt;&gt;         Extra reading, and inspiration for a feature like the above:<br>&gt;&gt;         Mars Probe Lost Due to Simple Math Error<br>&gt;&gt;         http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;&gt;         &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;<br>&gt;&gt;         &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;&gt;         &lt;http://articles.latimes.com/1999/oct/01/news/mn-17288&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         &quot;NASA lost its $125-million Mars Climate Orbiter because<br>&gt;&gt; spacecraft<br>&gt;&gt;         engineers failed to convert from English to metric measurements<br>&gt;&gt; when<br>&gt;&gt;         exchanging vital data before the craft was launched, space agency<br>&gt;&gt;         officials<br>&gt;&gt;         said Thursday.<br>&gt;&gt;<br>&gt;&gt;         A navigation team at the Jet Propulsion Laboratory used the metric<br>&gt;&gt;         system<br>&gt;&gt;         of millimeters and meters in its calculations, while Lockheed<br>&gt;&gt; Martin<br>&gt;&gt;         Astronautics in Denver, which designed and built the spacecraft,<br>&gt;&gt;         provided<br>&gt;&gt;         crucial acceleration data in the English system of inches, feet<br>&gt;&gt; and<br>&gt;&gt;         pounds.<br>&gt;&gt;<br>&gt;&gt;         As a result, JPL engineers mistook acceleration readings measured<br>&gt;&gt; in<br>&gt;&gt;         English units of pound-seconds for a metric measure of force<br>&gt;&gt; called<br>&gt;&gt;         newton-seconds.&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/1f7291d6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Wasn&#39;t there something about &quot;units&quot; announced at wwdc that does exactly this?<br></p><p>Sent from my iPhone<br></p><p>&gt; On Aug 22, 2016, at 09:54, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt; Basically numeric values (such as Double, Int, etc.) that are strongly typed to a specific use case, for example Distance, Weight, etc. and cannot be intermixed with untyped values.<br>&gt; <br>&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt; =====<br>&gt; //Distance<br>&gt; struct fixedtype Distance : Double {<br>&gt; var km: …<br>&gt; var m: …<br>&gt; typealias meters: m<br>&gt; var feet: ...<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; //Weight<br>&gt; struct fixedtype Weight : Double {<br>&gt; var kg: …<br>&gt; var g: …<br>&gt; typealias grams : g<br>&gt; var pound: ...<br>&gt; }<br>&gt; <br>&gt; …<br>&gt; var weight : Weight = 5.kg + 5.g + 7.m<br>&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt; var distance: Distance = 7.km + 12.5.m + 5.0 + 3<br>&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>&gt; ===<br>&gt; <br>&gt; The main restriction this syntax should do is disallow intermixing of numeric types (even if they all descend from Double, Int, etc.) and not allow adding untyped numerics (i.e. those without a type suffix), unless explicitly asked for in the code.<br>&gt; <br>&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt; =====<br>&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt; distance += number.m   //number is converted to m (meters)<br>&gt; =====<br>&gt; <br>&gt; From the Swift 3 Language guide, we are for example given the following example:<br>&gt; =====<br>&gt; extension Double {<br>&gt;   var km: Double { return self * 1_000.0 }<br>&gt;   var m: Double { return self }<br>&gt;   var cm: Double { return self / 100.0 }<br>&gt;   var mm: Double { return self / 1_000.0 }<br>&gt;   var ft: Double { return self / 3.28084 }<br>&gt; }<br>&gt; <br>&gt; let aMarathon = 42.km + 195.m<br>&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt; =====<br>&gt; <br>&gt; This is quite nice to suffix a conversion method after the value, but if I had another extension that converts the values to pounds and kilograms, then one can illegally do this:<br>&gt;      let aValue = 42.km + 195.m + 17.pounds + 5.0<br>&gt; and then the code would still compile and run, but not work as intended.<br>&gt; <br>&gt; Extra reading, and inspiration for a feature like the above:<br>&gt; Mars Probe Lost Due to Simple Math Error<br>&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt; <br>&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft engineers failed to convert from English to metric measurements when exchanging vital data before the craft was launched, space agency officials said Thursday.<br>&gt; <br>&gt; A navigation team at the Jet Propulsion Laboratory used the metric system of millimeters and meters in its calculations, while Lockheed Martin Astronautics in Denver, which designed and built the spacecraft, provided crucial acceleration data in the English system of inches, feet and pounds.<br>&gt; <br>&gt; As a result, JPL engineers mistook acceleration readings measured in English units of pound-seconds for a metric measure of force called newton-seconds.&quot;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/5f846150/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>August 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Reposting comment from Dave A. in a previous thread:<br></p><p><br>&quot;I&#39;m not sure how useful this is, because it&#39;s not really a comment on<br>your efforts, but... some of us think we know how this problem domain<br>*should* be addressed, and we know that Swift doesn&#39;t yet have the<br>necessary language facilities (integer generic parameters) to do the job<br>right. The technique was described back in 1994 by Barton &amp; Nackman in<br>https://www.amazon.com/Scientific-Engineering-Introduction-Advanced-Techniques/dp/0201533936<br>“<br></p><p>We would have the ability to implement dimensional analysis library like the one in Boost today: http://www.boost.org/doc/libs/1_61_0/doc/html/boost_units.html<br></p><p>-- <br>Daniel Duan<br></p><p>On August 22, 2016 at 11:54:13 AM, David Sweeris via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>Wasn&#39;t there something about &quot;units&quot; announced at wwdc that does exactly this?<br></p><p>Sent from my iPhone<br></p><p>On Aug 22, 2016, at 09:54, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hi,<br></p><p>I&#39;m new to the list, but have an idea for Typed Numerics.<br>Basically numeric values (such as Double, Int, etc.) that are strongly typed to a specific use case, for example Distance, Weight, etc. and cannot be intermixed with untyped values.<br></p><p>So if I have (the syntax is made up, but perhaps something like this):<br>=====<br>//Distance<br>struct fixedtype Distance : Double {<br>var km: …<br>var m: …<br>typealias meters: m<br>var feet: ...<br>...<br>}<br></p><p>//Weight<br>struct fixedtype Weight : Double {<br>var kg: …<br>var g: …<br>typealias grams : g<br>var pound: ...<br>}<br></p><p>…<br>var weight : Weight = 5.kg + 5.g + 7.m<br>………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>var distance: Distance = 7.km + 12.5.m + 5.0 + 3<br>………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>===<br></p><p>The main restriction this syntax should do is disallow intermixing of numeric types (even if they all descend from Double, Int, etc.) and not allow adding untyped numerics (i.e. those without a type suffix), unless explicitly asked for in the code.<br></p><p>Any of these can be converted to it&#39;s raw untyped value, for example:<br>=====<br>let number : Double = distance.rawValue + 5.0   //This is allowed<br>distance += number.m   //number is converted to m (meters)<br>=====<br></p><p>From the Swift 3 Language guide, we are for example given the following example:<br>=====<br>extension Double {<br>  var km: Double { return self * 1_000.0 }<br>  var m: Double { return self }<br>  var cm: Double { return self / 100.0 }<br>  var mm: Double { return self / 1_000.0 }<br>  var ft: Double { return self / 3.28084 }<br>}<br></p><p>let aMarathon = 42.km + 195.m<br>print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>// Prints &quot;A marathon is 42195.0 meters long&quot;<br>=====<br></p><p>This is quite nice to suffix a conversion method after the value, but if I had another extension that converts the values to pounds and kilograms, then one can illegally do this:<br>     let aValue = 42.km + 195.m + 17.pounds + 5.0<br>and then the code would still compile and run, but not work as intended.<br></p><p>Extra reading, and inspiration for a feature like the above:<br>Mars Probe Lost Due to Simple Math Error<br>http://articles.latimes.com/1999/oct/01/news/mn-17288<br></p><p>&quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft engineers failed to convert from English to metric measurements when exchanging vital data before the craft was launched, space agency officials said Thursday.<br></p><p>A navigation team at the Jet Propulsion Laboratory used the metric system of millimeters and meters in its calculations, while Lockheed Martin Astronautics in Denver, which designed and built the spacecraft, provided crucial acceleration data in the English system of inches, feet and pounds.<br></p><p>As a result, JPL engineers mistook acceleration readings measured in English units of pound-seconds for a metric measure of force called newton-seconds.&quot;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/83d0895f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Idea] Typed Numerics</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>August 23, 2016 at 09:00:00am</p></header><div class="content"><p>I programmed in Ada in about 1990 and used typed numerics all the time.<br>Missed them ever since…<br></p><p>I would suggest to take a look at Ada and steal the best features to implement typed numerics.<br></p><p>struct Distance: Double(checkedBounds: (lower: 100.0, upper: 10_000.0), delta: 0.1, digits: 10) { … }<br></p><p>Link to the Ada RM on Scalar Types: http://ada-auth.org/standards/12rm/html/RM-3-5.html<br></p><p>The above type definition would use integer calculations, not double, thanks to the ‘delta’ specification.<br></p><p>Rien.<br></p><p>&gt; On 22 Aug 2016, at 22:13, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Reposting comment from Dave A. in a previous thread:<br>&gt; <br>&gt; <br>&gt; &quot;I&#39;m not sure how useful this is, because it&#39;s not really a comment on<br>&gt; your efforts, but... some of us think we know how this problem domain<br>&gt; *should* be addressed, and we know that Swift doesn&#39;t yet have the<br>&gt; necessary language facilities (integer generic parameters) to do the job<br>&gt; right. The technique was described back in 1994 by Barton &amp; Nackman in<br>&gt; https://www.amazon.com/Scientific-Engineering-Introduction-Advanced-Techniques/dp/0201533936<br>&gt; “<br>&gt; <br>&gt; We would have the ability to implement dimensional analysis library like the one in Boost today: http://www.boost.org/doc/libs/1_61_0/doc/html/boost_units.html<br>&gt; <br>&gt; -- <br>&gt; Daniel Duan<br>&gt; <br>&gt; On August 22, 2016 at 11:54:13 AM, David Sweeris via swift-evolution (swift-evolution at swift.org) wrote:<br>&gt; <br>&gt;&gt; Wasn&#39;t there something about &quot;units&quot; announced at wwdc that does exactly this?<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Aug 22, 2016, at 09:54, Nur Ismail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m new to the list, but have an idea for Typed Numerics.<br>&gt;&gt;&gt; Basically numeric values (such as Double, Int, etc.) that are strongly typed to a specific use case, for example Distance, Weight, etc. and cannot be intermixed with untyped values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So if I have (the syntax is made up, but perhaps something like this):<br>&gt;&gt;&gt; =====<br>&gt;&gt;&gt; //Distance<br>&gt;&gt;&gt; struct fixedtype Distance : Double {<br>&gt;&gt;&gt; var km: …<br>&gt;&gt;&gt; var m: …<br>&gt;&gt;&gt; typealias meters: m<br>&gt;&gt;&gt; var feet: ...<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //Weight<br>&gt;&gt;&gt; struct fixedtype Weight : Double {<br>&gt;&gt;&gt; var kg: …<br>&gt;&gt;&gt; var g: …<br>&gt;&gt;&gt; typealias grams : g<br>&gt;&gt;&gt; var pound: ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; var weight : Weight = 5.kg + 5.g + 7.m<br>&gt;&gt;&gt; ………………………………………..^ Compiler Error: Can’t add Distance to Weight...<br>&gt;&gt;&gt; var distance: Distance = 7.km + 12.5.m + 5.0 + 3<br>&gt;&gt;&gt; ………………………………………………...^ Compiler Error: can’t add untyped number to Distance...<br>&gt;&gt;&gt; ===<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main restriction this syntax should do is disallow intermixing of numeric types (even if they all descend from Double, Int, etc.) and not allow adding untyped numerics (i.e. those without a type suffix), unless explicitly asked for in the code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any of these can be converted to it&#39;s raw untyped value, for example:<br>&gt;&gt;&gt; =====<br>&gt;&gt;&gt; let number : Double = distance.rawValue + 5.0   //This is allowed<br>&gt;&gt;&gt; distance += number.m   //number is converted to m (meters)<br>&gt;&gt;&gt; =====<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the Swift 3 Language guide, we are for example given the following example:<br>&gt;&gt;&gt; =====<br>&gt;&gt;&gt; extension Double {<br>&gt;&gt;&gt;   var km: Double { return self * 1_000.0 }<br>&gt;&gt;&gt;   var m: Double { return self }<br>&gt;&gt;&gt;   var cm: Double { return self / 100.0 }<br>&gt;&gt;&gt;   var mm: Double { return self / 1_000.0 }<br>&gt;&gt;&gt;   var ft: Double { return self / 3.28084 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let aMarathon = 42.km + 195.m<br>&gt;&gt;&gt; print(&quot;A marathon is \(aMarathon) meters long&quot;)<br>&gt;&gt;&gt; // Prints &quot;A marathon is 42195.0 meters long&quot;<br>&gt;&gt;&gt; =====<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is quite nice to suffix a conversion method after the value, but if I had another extension that converts the values to pounds and kilograms, then one can illegally do this:<br>&gt;&gt;&gt;      let aValue = 42.km + 195.m + 17.pounds + 5.0<br>&gt;&gt;&gt; and then the code would still compile and run, but not work as intended.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extra reading, and inspiration for a feature like the above:<br>&gt;&gt;&gt; Mars Probe Lost Due to Simple Math Error<br>&gt;&gt;&gt; http://articles.latimes.com/1999/oct/01/news/mn-17288<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;NASA lost its $125-million Mars Climate Orbiter because spacecraft engineers failed to convert from English to metric measurements when exchanging vital data before the craft was launched, space agency officials said Thursday.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A navigation team at the Jet Propulsion Laboratory used the metric system of millimeters and meters in its calculations, while Lockheed Martin Astronautics in Denver, which designed and built the spacecraft, provided crucial acceleration data in the English system of inches, feet and pounds.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a result, JPL engineers mistook acceleration readings measured in English units of pound-seconds for a metric measure of force called newton-seconds.&quot;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
