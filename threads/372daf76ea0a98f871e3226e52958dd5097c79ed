<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove forEach?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br></p><p>    func indexOf_foreach(element: Element) -&gt; Int? {<br>        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>            return idx<br>        }<br>        return nil<br>    }<br></p><p>The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br></p><p>Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br></p><p>[1,2,3,4,5].forEach { num in<br>   print(num)<br>   if num &gt; 3 { return }<br>}<br></p><p>I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br></p><p>Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/372d79ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Remove forEach?</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>It’d probably be confusing without a new keyword or symbol, but in the case of @noescape closures, maybe “return&quot; could return from the outer scope instead of the inner one. Smalltalk has a distinction kind of like this.<br></p><p>In some ways, I think “return” should be reserved for actually returning from a *function* and “^” or something could exist for returning from a *closure* and that distinction would eliminate strange nested returns that sometimes crop up in these scenarios.<br></p><p>So as written, your example would just do the “right thing” if “return” was so defined. If you wanted to explicitly do the wrong thing, it could be written as:<br></p><p>    func indexOf_foreach(element: Element) -&gt; Int? {<br>        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>            ^ idx<br>        }<br>        return nil<br>    }<br></p><p>If you tried to use “return” in an escaping closure, then it could be an error.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 8, 2015, at 1:07 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt; <br>&gt;     func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;             return idx<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; <br>&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt; <br>&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt; <br>&gt; [1,2,3,4,5].forEach { num in<br>&gt;    print(num)<br>&gt;    if num &gt; 3 { return }<br>&gt; }<br>&gt; <br>&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt; <br>&gt; Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c673fa52f8aa5b3e9205e51230764ca?s=50"></div><header><strong>Remove forEach?</strong> from <string>Kevin Kachikian</string> &lt;kevyk at mac.com&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>I support keeping forEach in. I use it enough myself. It also makes it easier for beginning Swift programmers to understand syntactically.<br></p><p>Kevin<br></p><p><br>&gt; On Dec 8, 2015, at 12:21 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It’d probably be confusing without a new keyword or symbol, but in the case of @noescape closures, maybe “return&quot; could return from the outer scope instead of the inner one. Smalltalk has a distinction kind of like this.<br>&gt; <br>&gt; In some ways, I think “return” should be reserved for actually returning from a *function* and “^” or something could exist for returning from a *closure* and that distinction would eliminate strange nested returns that sometimes crop up in these scenarios.<br>&gt; <br>&gt; So as written, your example would just do the “right thing” if “return” was so defined. If you wanted to explicitly do the wrong thing, it could be written as:<br>&gt; <br>&gt;    func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;            ^ idx<br>&gt;        }<br>&gt;        return nil<br>&gt;    }<br>&gt; <br>&gt; If you tried to use “return” in an escaping closure, then it could be an error.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 1:07 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt; <br>&gt;&gt;    func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;            return idx<br>&gt;&gt;        }<br>&gt;&gt;        return nil<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt; <br>&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt; <br>&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;   print(num)<br>&gt;&gt;   if num &gt; 3 { return }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt; <br>&gt;&gt; Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Remove forEach?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>I&#39;d prefer retain `for-each`. I like it as a natural termination step for functional chaining. Here&#39;s what I wrote about the topic when it first appeared. There are bits of the discussion that I&#39;d refine since I first wrote this but I decided it was easier to paste this as a whole and save my afternoon.<br></p><p>-- E<br></p><p>ForEach: Just when I finally got around to implementing this generically:<br></p><p>public extension SequenceType {<br>    func mapDo(p: (Self.Generator.Element) -&gt; Void) {<br>        for x in self {p(x)}<br>    }<br>}<br>Apple introduced forEach.<br></p><p>Array(1...5).map({$0 * 2}).forEach{print($0)}<br>You use this procedurally when you don’t collect/return the results. Notice how I’ve followed the Rule-of-Kevin-Ballard &lt;http://twitter.com/Eridius&gt; above. No parens around the braces because the closure is procedural.<br></p><p>public func forEach(@noescape body: (Self.Generator.Element) -&gt; ())<br>This new language feature eliminates the awkward “for _ in” construct and provides a procedural end-point for functional chains. If you want to continue the chain (for example if you want to throw a print($0) in the middle) continue using map, which offers pass-through.<br></p><p>Apple’s pointers:<br></p><p>Unlike for-in loops, you can’t use break or continue to exit the current call of the body closure or skip subsequent calls. <br>Also unlike for-in loops, using return in the body closure will only exit from the current call to the closure, not any outer scope, and won’t skip subsequent calls. <br>Due to these limitations, the forEach member is only recommended when applied to a chained series of functional algorithms (e.g. foo.map {…}.filter {… }.forEach { …}) and when the body is small. In other cases, we recommend using the for..in statement. (18231840)<br></p><p><br>&gt; On Dec 8, 2015, at 1:28 PM, Kevin Kachikian via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I support keeping forEach in. I use it enough myself. It also makes it easier for beginning Swift programmers to understand syntactically.<br>&gt; <br>&gt; Kevin<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 12:21 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It’d probably be confusing without a new keyword or symbol, but in the case of @noescape closures, maybe “return&quot; could return from the outer scope instead of the inner one. Smalltalk has a distinction kind of like this.<br>&gt;&gt; <br>&gt;&gt; In some ways, I think “return” should be reserved for actually returning from a *function* and “^” or something could exist for returning from a *closure* and that distinction would eliminate strange nested returns that sometimes crop up in these scenarios.<br>&gt;&gt; <br>&gt;&gt; So as written, your example would just do the “right thing” if “return” was so defined. If you wanted to explicitly do the wrong thing, it could be written as:<br>&gt;&gt; <br>&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;       self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;           ^ idx<br>&gt;&gt;       }<br>&gt;&gt;       return nil<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; If you tried to use “return” in an escaping closure, then it could be an error.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 1:07 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;       self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;           return idx<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;       return nil<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;&gt;  print(num)<br>&gt;&gt;&gt;  if num &gt; 3 { return }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/e3e060c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Remove forEach?</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>+1 for keeping forEach and the rationale.<br></p><p>-Thorsten <br></p><p>&gt; Am 08.12.2015 um 22:56 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;d prefer retain `for-each`. I like it as a natural termination step for functional chaining. Here&#39;s what I wrote about the topic when it first appeared. There are bits of the discussion that I&#39;d refine since I first wrote this but I decided it was easier to paste this as a whole and save my afternoon.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; ForEach: Just when I finally got around to implementing this generically:<br>&gt; <br>&gt; public extension SequenceType {<br>&gt;     func mapDo(p: (Self.Generator.Element) -&gt; Void) {<br>&gt;         for x in self {p(x)}<br>&gt;     }<br>&gt; }<br>&gt; Apple introduced forEach.<br>&gt; <br>&gt; Array(1...5).map({$0 * 2}).forEach{print($0)}<br>&gt; You use this procedurally when you don’t collect/return the results. Notice how I’ve followed the Rule-of-Kevin-Ballard above. No parens around the braces because the closure is procedural.<br>&gt; <br>&gt; public func forEach(@noescape body: (Self.Generator.Element) -&gt; ())<br>&gt; This new language feature eliminates the awkward “for _ in” construct and provides a procedural end-point for functional chains. If you want to continue the chain (for example if you want to throw a print($0) in the middle) continue using map, which offers pass-through.<br>&gt; <br>&gt; Apple’s pointers:<br>&gt; <br>&gt; Unlike for-in loops, you can’t use break or continue to exit the current call of the body closure or skip subsequent calls. <br>&gt; Also unlike for-in loops, using return in the body closure will only exit from the current call to the closure, not any outer scope, and won’t skip subsequent calls. <br>&gt; Due to these limitations, the forEach member is only recommended when applied to a chained series of functional algorithms (e.g. foo.map {…}.filter {… }.forEach { …}) and when the body is small. In other cases, we recommend using the for..in statement. (18231840)<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 1:28 PM, Kevin Kachikian via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I support keeping forEach in. I use it enough myself. It also makes it easier for beginning Swift programmers to understand syntactically.<br>&gt;&gt; <br>&gt;&gt; Kevin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 12:21 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’d probably be confusing without a new keyword or symbol, but in the case of @noescape closures, maybe “return&quot; could return from the outer scope instead of the inner one. Smalltalk has a distinction kind of like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In some ways, I think “return” should be reserved for actually returning from a *function* and “^” or something could exist for returning from a *closure* and that distinction would eliminate strange nested returns that sometimes crop up in these scenarios.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So as written, your example would just do the “right thing” if “return” was so defined. If you wanted to explicitly do the wrong thing, it could be written as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;       self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;           ^ idx<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;       return nil<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you tried to use “return” in an escaping closure, then it could be an error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 1:07 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;&gt;       self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;&gt;           return idx<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;       return nil<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;&gt;&gt;  print(num)<br>&gt;&gt;&gt;&gt;  if num &gt; 3 { return }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/d587a381/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove forEach?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>I think having a different syntax for returning from an anonymous function would be a bad idea. They’re really the same thing.<br></p><p>&gt; On 08 Dec 2015, at 15:21, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; It’d probably be confusing without a new keyword or symbol, but in the case of @noescape closures, maybe “return&quot; could return from the outer scope instead of the inner one. Smalltalk has a distinction kind of like this.<br>&gt; <br>&gt; In some ways, I think “return” should be reserved for actually returning from a *function* and “^” or something could exist for returning from a *closure* and that distinction would eliminate strange nested returns that sometimes crop up in these scenarios.<br>&gt; <br>&gt; So as written, your example would just do the “right thing” if “return” was so defined. If you wanted to explicitly do the wrong thing, it could be written as:<br>&gt; <br>&gt;    func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;            ^ idx<br>&gt;        }<br>&gt;        return nil<br>&gt;    }<br>&gt; <br>&gt; If you tried to use “return” in an escaping closure, then it could be an error.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 1:07 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt; <br>&gt;&gt;    func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;            return idx<br>&gt;&gt;        }<br>&gt;&gt;        return nil<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt; <br>&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt; <br>&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;   print(num)<br>&gt;&gt;   if num &gt; 3 { return }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt; <br>&gt;&gt; Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove forEach?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 1:58 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think having a different syntax for returning from an anonymous function would be a bad idea. They’re really the same thing.<br></p><p>Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br></p><p>func forEach(body: (Element) breaks -&gt; ())<br></p><p>and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Remove forEach?</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  9, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 5:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt; <br>&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt; <br>&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br></p><p>This is really interesting. Ruby provides similar functionality with its lambda vs. proc, but a type annotation is much more understandable. It could also imply @noescape automatically:<br></p><p>    func forEach(@canbreak body: Element -&gt; Void)<br></p><p>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Remove forEach?</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  9, 2015 at 08:00:00am</p></header><div class="content"><p>Another language construct seems a bit much for this, right? Maybe I’m missing something, but can’t we get the same behavior with an overload?<br></p><p>extension Array {<br>    func forEach&lt;U&gt;(body: (element: Element) throws -&gt; U?) rethrows -&gt; U? {<br>        for e in self {<br>            if let result = try body(element: e) { return result }<br>        }<br>        <br>        return nil<br>    }<br>}<br></p><p>func g(e: Int) -&gt; Int? {<br>    if e == 2 { return e }<br>    return nil<br>}<br></p><p>let arr = [1, 2, 3]<br>arr.forEach { print($0) }<br>let result = arr.forEach(g)<br>result                           // has the value of 2<br></p><p><br>Now, Swift has some issues determining the types properly if you attempt to inline the g function at the forEach() callsite, but that can be fixed.<br></p><p>-David<br></p><p>&gt; On Dec 9, 2015, at 4:40 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 5:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt;&gt; <br>&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;&gt; <br>&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br>&gt; <br>&gt; This is really interesting. Ruby provides similar functionality with its lambda vs. proc, but a type annotation is much more understandable. It could also imply @noescape automatically:<br>&gt; <br>&gt;    func forEach(@canbreak body: Element -&gt; Void)<br>&gt; <br>&gt; Stephen<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/8382bfcf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove forEach?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 8:47 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Another language construct seems a bit much for this, right? Maybe I’m missing something, but can’t we get the same behavior with an overload?<br></p><p>A language construct that helps eliminate multiple other language constructs would potentially be a net win, though. If there were closures that supported nonlocal exits, then `do`, `for...in`, and possibly other constructs could become library functions, and other &quot;block-like&quot; library features like `autoreleasepool`, `withUnsafePointer` would work more naturally too.<br></p><p>-Joe<br></p><p>&gt; extension Array {<br>&gt;     func forEach&lt;U&gt;(body: (element: Element) throws -&gt; U?) rethrows -&gt; U? {<br>&gt;         for e in self {<br>&gt;             if let result = try body(element: e) { return result }<br>&gt;         }<br>&gt;         <br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func g(e: Int) -&gt; Int? {<br>&gt;     if e == 2 { return e }<br>&gt;     return nil<br>&gt; }<br>&gt; <br>&gt; let arr = [1, 2, 3]<br>&gt; arr.forEach { print($0) }<br>&gt; let result = arr.forEach(g)<br>&gt; result                           // has the value of 2<br>&gt; <br>&gt; <br>&gt; Now, Swift has some issues determining the types properly if you attempt to inline the g function at the forEach() callsite, but that can be fixed.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 4:40 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 5:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br>&gt;&gt; <br>&gt;&gt; This is really interesting. Ruby provides similar functionality with its lambda vs. proc, but a type annotation is much more understandable. It could also imply @noescape automatically:<br>&gt;&gt; <br>&gt;&gt;    func forEach(@canbreak body: Element -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; Stephen<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/62c5f86d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Remove forEach?</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>I’m obviously a big fan of this approach. :) Anything that can move what would have previously been required to be a built in language feature to the library seems like a good thing to me.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 9, 2015, at 11:01 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 9, 2015, at 8:47 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another language construct seems a bit much for this, right? Maybe I’m missing something, but can’t we get the same behavior with an overload?<br>&gt; <br>&gt; A language construct that helps eliminate multiple other language constructs would potentially be a net win, though. If there were closures that supported nonlocal exits, then `do`, `for...in`, and possibly other constructs could become library functions, and other &quot;block-like&quot; library features like `autoreleasepool`, `withUnsafePointer` would work more naturally too.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;     func forEach&lt;U&gt;(body: (element: Element) throws -&gt; U?) rethrows -&gt; U? {<br>&gt;&gt;         for e in self {<br>&gt;&gt;             if let result = try body(element: e) { return result }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func g(e: Int) -&gt; Int? {<br>&gt;&gt;     if e == 2 { return e }<br>&gt;&gt;     return nil<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let arr = [1, 2, 3]<br>&gt;&gt; arr.forEach { print($0) }<br>&gt;&gt; let result = arr.forEach(g)<br>&gt;&gt; result                           // has the value of 2<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now, Swift has some issues determining the types properly if you attempt to inline the g function at the forEach() callsite, but that can be fixed.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 4:40 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 5:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is really interesting. Ruby provides similar functionality with its lambda vs. proc, but a type annotation is much more understandable. It could also imply @noescape automatically:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func forEach(@canbreak body: Element -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stephen<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Remove forEach?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;&gt;&gt;&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br></p><p>I missed this post the first time around.  Is a really great idea and is something I hoped we might get eventually.  It allows &quot;control flow&quot; functions to behave as expected.<br></p><p>I assume a caller could pass a non-breaking closure if desired just as we can pass a non-throwing closure if desired, right?<br>,<br>How would break and continue interact with the caller of the closure?  It would need to implement the correct behavior of skipping to the next loop cycle or moving on to any post-loop logic.<br></p><p>How would this behave for a closure that is stored and called later, possibly asynchronously?  Or would it only be allowed on closures declared<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Remove forEach?</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On 9 déc. 2015, at 10:43, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How would break and continue interact with the caller of the closure?  It would need to implement the correct behavior of skipping to the next loop cycle or moving on to any post-loop logic.<br></p><p>Using logic similar to GeneratorType.next(), a `breaks` closure could effectively return an Optional&lt;Void&gt;.<br>Reaching the end or a `continue`-equivalent statement would return .Some(Void).<br>Exiting via the `break`-equivalent statement would return .None and signal the end of looping<br></p><p>Making the construct look right, however, sounds like compiler magic.<br></p><p>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Remove forEach?</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>Can’t most of this functionality be achieved with current Swift features, though? I mean, you could have the break within the type that the closure returns.<br></p><p>In the case of forEach, you could have it return a Bool, rather than Void, with true signifying break:<br></p><p>extension SequenceType {<br>  func forEachBreak(body: Generator.Element -&gt; Bool) {<br>    for element in self {<br>      if body(element) {<br>        return<br>      }<br>    }<br>  }<br>}<br></p><p>[1, 2, 3, 4, 5, 6, 7, 8].forEachBreak { n in<br>  print(n)<br>  if n &gt; 4 { return true }<br>  return false<br>}<br></p><p>For methods like map, you could have a version which takes a closure that returns an Optional: nil signifying a break. Or, You could add something like a takeWhile method to SequenceType. (which would probably be the easiest to understand)<br></p><p>I think that annotations like @noescape and throws have huge overhead in terms of added confusion, especially for beginners. If the objective is to improve the understandability of certain functions, I think that something like this:<br></p><p>sequence.takeWhile { $0 &lt; 10 }.forEach { print($0) }<br></p><p>is a better option than swelling the signature of forEach to:<br></p><p>func forEach(@noescape body: (Self.Generator.Element) throws, breaks -&gt; ()) rethrows<br></p><p>Oisin.<br></p><p>&gt; On 9 Dec 2015, at 17:43, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br>&gt; <br>&gt; I missed this post the first time around.  Is a really great idea and is something I hoped we might get eventually.  It allows &quot;control flow&quot; functions to behave as expected.<br>&gt; <br>&gt; I assume a caller could pass a non-breaking closure if desired just as we can pass a non-throwing closure if desired, right?<br>&gt; ,<br>&gt; How would break and continue interact with the caller of the closure?  It would need to implement the correct behavior of skipping to the next loop cycle or moving on to any post-loop logic.<br>&gt; <br>&gt; How would this behave for a closure that is stored and called later, possibly asynchronously?  Or would it only be allowed on closures declared<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/89efe437/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Remove forEach?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>On Wed, Dec 9, 2015, at 09:43 AM, Matthew Johnson via swift-evolution wrote:<br>&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br>&gt; <br>&gt; I missed this post the first time around.  Is a really great idea and is something I hoped we might get eventually.  It allows &quot;control flow&quot; functions to behave as expected.<br>&gt; <br>&gt; I assume a caller could pass a non-breaking closure if desired just as we can pass a non-throwing closure if desired, right?<br>&gt; ,<br>&gt; How would break and continue interact with the caller of the closure?  It would need to implement the correct behavior of skipping to the next loop cycle or moving on to any post-loop logic.<br>&gt; <br>&gt; How would this behave for a closure that is stored and called later, possibly asynchronously?  Or would it only be allowed on closures declared<br></p><p>The idea is interesting, but I share your concerns, and Guillaume&#39;s concern about labelled breaks as well.<br></p><p>I&#39;m inclined to say that making things like for-in as a library feature instead of a language feature may be more easily accomplished with macros, as that bypasses all these questions (since it will get rid of the closure). Note that a for-in loop could be easily transformed by a macro into the following:<br></p><p>Source (for let):<br></p><p>[label:] for [var] pattern in sequence [where condition] {<br>    body<br>}<br></p><p>Result (for let):<br></p><p>[label:] do { // to scope the generator<br>    var gensymmedName = sequence.generate()<br>    while letOrVar pattern = gensymmedName.next() [where condition] {<br>        body<br>    }<br>}<br></p><p>Source (for case):<br></p><p>[label:] for case pattern in sequence [where condition] {<br>    body<br>}<br></p><p>Result (for case):<br></p><p>[label:] do { // to scope the generator<br>    var gensymmedName = sequence.generate()<br>    while let gensymmedName2 = gensymmedName.next() {<br>        if case pattern = gensymmedName2 [where condition] {<br>            body<br>        }<br>    }<br>}<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Remove forEach?</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>Could such construct also allow for an if-else expression like behavior?<br></p><p>let result = if bool { 1 } else { 2 }<br></p><p> Or would this be better modeled as a non block-like expression?<br></p><p>let result = 1 if bool else 2<br></p><p>I&#39;m just curious, this maybe be out of topic/ unrelated.<br></p><p><br>On Wednesday, December 9, 2015, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 9, 2015, at 8:47 AM, David Owens II &lt;david at owensd.io<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;david at owensd.io&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Another language construct seems a bit much for this, right? Maybe I’m<br>&gt; missing something, but can’t we get the same behavior with an overload?<br>&gt;<br>&gt;<br>&gt; A language construct that helps eliminate multiple other language<br>&gt; constructs would potentially be a net win, though. If there were closures<br>&gt; that supported nonlocal exits, then `do`, `for...in`, and possibly other<br>&gt; constructs could become library functions, and other &quot;block-like&quot; library<br>&gt; features like `autoreleasepool`, `withUnsafePointer` would work more<br>&gt; naturally too.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; extension Array {<br>&gt;     func forEach&lt;U&gt;(body: (element: Element) throws -&gt; U?) rethrows -&gt; U? {<br>&gt;         for e in self {<br>&gt;             if let result = try body(element: e) { return result }<br>&gt;         }<br>&gt;<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; func g(e: Int) -&gt; Int? {<br>&gt;     if e == 2 { return e }<br>&gt;     return nil<br>&gt; }<br>&gt;<br>&gt; let arr = [1, 2, 3]<br>&gt; arr.forEach { print($0) }<br>&gt; let result = arr.forEach(g)<br>&gt; result                           // has the value of 2<br>&gt;<br>&gt;<br>&gt;<br>&gt; Now, Swift has some issues determining the types properly if you attempt<br>&gt; to inline the g function at the forEach() callsite, but that can be fixed.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 9, 2015, at 4:40 AM, Stephen Celis via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; On Dec 8, 2015, at 5:13 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Another direction you might take this is to make it a type annotation on<br>&gt; the function type, like throws, so forEach has a type like this:<br>&gt;<br>&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;<br>&gt; and a closure that `breaks` has nonlocal behavior for<br>&gt; break/continue/return (and is implied to be noescape and void-returning, I<br>&gt; guess).<br>&gt;<br>&gt;<br>&gt; This is really interesting. Ruby provides similar functionality with its<br>&gt; lambda vs. proc, but a type annotation is much more understandable. It<br>&gt; could also imply @noescape automatically:<br>&gt;<br>&gt;    func forEach(@canbreak body: Element -&gt; Void)<br>&gt;<br>&gt; Stephen<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/c9df2f80/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Remove forEach?</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On 9 déc. 2015, at 10:01, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A language construct that helps eliminate multiple other language constructs would potentially be a net win, though. If there were closures that supported nonlocal exits, then `do`, `for...in`, and possibly other constructs could become library functions, and other &quot;block-like&quot; library features like `autoreleasepool`, `withUnsafePointer` would work more naturally too.<br></p><p>If a `for` loop became a library function with special closures, what would happen to labeled break statements?<br></p><p>e.g.<br>outer: for i in 0..&lt;5 {<br>  for j in 0..&lt;5 {<br>    break outer<br>  }<br>}<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove forEach?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 10:23 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 9 déc. 2015, at 10:01, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A language construct that helps eliminate multiple other language constructs would potentially be a net win, though. If there were closures that supported nonlocal exits, then `do`, `for...in`, and possibly other constructs could become library functions, and other &quot;block-like&quot; library features like `autoreleasepool`, `withUnsafePointer` would work more naturally too.<br>&gt; <br>&gt; If a `for` loop became a library function with special closures, what would happen to labeled break statements?<br>&gt; <br>&gt; e.g.<br>&gt; outer: for i in 0..&lt;5 {<br>&gt;  for j in 0..&lt;5 {<br>&gt;    break outer<br>&gt;  }<br>&gt; }<br></p><p>Seems to me that&#39;s still supportable; it&#39;s not much different from catching specific error types. It&#39;s one of many things someone proposing this would need to account for.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove forEach?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>Would it make sense to explore this approach a bit further? Or will it be out of scope for Swift 3 anyway? This could also enable a lot of other cool stuff. To me, it feels like a big task, so not sure how to proceed on this...<br></p><p>Chris<br></p><p>&gt; On 09 Dec 2015, at 12:01, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 8:47 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another language construct seems a bit much for this, right? Maybe I’m missing something, but can’t we get the same behavior with an overload?<br>&gt; <br>&gt; A language construct that helps eliminate multiple other language constructs would potentially be a net win, though. If there were closures that supported nonlocal exits, then `do`, `for...in`, and possibly other constructs could become library functions, and other &quot;block-like&quot; library features like `autoreleasepool`, `withUnsafePointer` would work more naturally too.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;     func forEach&lt;U&gt;(body: (element: Element) throws -&gt; U?) rethrows -&gt; U? {<br>&gt;&gt;         for e in self {<br>&gt;&gt;             if let result = try body(element: e) { return result }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func g(e: Int) -&gt; Int? {<br>&gt;&gt;     if e == 2 { return e }<br>&gt;&gt;     return nil<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let arr = [1, 2, 3]<br>&gt;&gt; arr.forEach { print($0) }<br>&gt;&gt; let result = arr.forEach(g)<br>&gt;&gt; result                           // has the value of 2<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now, Swift has some issues determining the types properly if you attempt to inline the g function at the forEach() callsite, but that can be fixed.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 4:40 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 5:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another direction you might take this is to make it a type annotation on the function type, like throws, so forEach has a type like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func forEach(body: (Element) breaks -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and a closure that `breaks` has nonlocal behavior for break/continue/return (and is implied to be noescape and void-returning, I guess).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is really interesting. Ruby provides similar functionality with its lambda vs. proc, but a type annotation is much more understandable. It could also imply @noescape automatically:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func forEach(@canbreak body: Element -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stephen<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/354dc4ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove forEach?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 1:17 PM, Chris Eidhof &lt;chris at eidhof.nl&gt; wrote:<br>&gt; <br>&gt; Would it make sense to explore this approach a bit further? Or will it be out of scope for Swift 3 anyway? This could also enable a lot of other cool stuff. To me, it feels like a big task, so not sure how to proceed on this...<br></p><p>I think it&#39;s definitely an interesting direction. The questions Guillaume and Matthew raised would have to be answered, at minimum.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Remove forEach?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  9, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 1:44 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:17 PM, Chris Eidhof &lt;chris at eidhof.nl&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it make sense to explore this approach a bit further? Or will it be out of scope for Swift 3 anyway? This could also enable a lot of other cool stuff. To me, it feels like a big task, so not sure how to proceed on this...<br>&gt; <br>&gt; I think it&#39;s definitely an interesting direction. The questions Guillaume and Matthew raised would have to be answered, at minimum.<br></p><p>Another question to consider is if you or another developer can be lined up to contribute an implementation to the compiler.  I suspect we’re going to collect a number of “good and approved ideas, but which do not have someone signed up to code it up in the compiler”.  This may end up being the difference between something getting into Swift 3 or not.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Remove forEach?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Another question to consider is if you or another developer can be lined up to contribute an implementation to the compiler.  I suspect we’re going to collect a number of “good and approved ideas, but which do not have someone signed up to code it up in the compiler”.  This may end up being the difference between something getting into Swift 3 or not.<br></p><p>Will there be a distinct status for such proposals?  It might be nice to do this so prospective contributors to the compiler have a place to find “ready to go” projects if they’re interested in working on new features.<br></p><p>Matthew<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove forEach?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>I’ll have a look at it. I’ll try to do some experiments with this syntax to see what would happen. If the experiment turns out interesting, I could imagine trying to write some C++ over Christmas to cook up an implementation...<br></p><p>Chris<br></p><p>&gt; On 09 Dec 2015, at 17:44, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:44 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:17 PM, Chris Eidhof &lt;chris at eidhof.nl&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it make sense to explore this approach a bit further? Or will it be out of scope for Swift 3 anyway? This could also enable a lot of other cool stuff. To me, it feels like a big task, so not sure how to proceed on this...<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s definitely an interesting direction. The questions Guillaume and Matthew raised would have to be answered, at minimum.<br>&gt; <br>&gt; Another question to consider is if you or another developer can be lined up to contribute an implementation to the compiler.  I suspect we’re going to collect a number of “good and approved ideas, but which do not have someone signed up to code it up in the compiler”.  This may end up being the difference between something getting into Swift 3 or not.<br>&gt; <br>&gt; -Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Remove forEach?</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>I like that! I&#39;ve been missing Smalltalk&#39;s non-local return myself.<br></p><p>-Thorsten <br></p><p>&gt; Am 08.12.2015 um 21:21 schrieb Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; It’d probably be confusing without a new keyword or symbol, but in the case of @noescape closures, maybe “return&quot; could return from the outer scope instead of the inner one. Smalltalk has a distinction kind of like this.<br>&gt; <br>&gt; In some ways, I think “return” should be reserved for actually returning from a *function* and “^” or something could exist for returning from a *closure* and that distinction would eliminate strange nested returns that sometimes crop up in these scenarios.<br>&gt; <br>&gt; So as written, your example would just do the “right thing” if “return” was so defined. If you wanted to explicitly do the wrong thing, it could be written as:<br>&gt; <br>&gt;    func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;            ^ idx<br>&gt;        }<br>&gt;        return nil<br>&gt;    }<br>&gt; <br>&gt; If you tried to use “return” in an escaping closure, then it could be an error.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 1:07 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt; <br>&gt;&gt;    func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;            return idx<br>&gt;&gt;        }<br>&gt;&gt;        return nil<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt; <br>&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt; <br>&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;   print(num)<br>&gt;&gt;   if num &gt; 3 { return }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt; <br>&gt;&gt; Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/998d3d631acb87e0aa687abc0085f990?s=50"></div><header><strong>Remove forEach?</strong> from <string>André Videla</string> &lt;zephyz at me.com&gt;<p>December  8, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi, <br></p><p>As I understand it, the argument for remove forEach is that it’s easy to make confusing code that doesn’t do what it looks like it should do.<br></p><p>In this particular example:<br></p><p>  func indexOf_foreach(element: Element) -&gt; Int? {<br>        self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>            return idx<br>        }<br>        return nil<br>    }<br></p><p>I think the compiler should give us two warnings:<br>- closure returns type Int when it should return type ()<br>- function always return nil (which is a unit type just like () ) when it expects Option&lt;Int&gt;<br></p><p>In my opinion those warnings should be enough to make the programmer aware that this code doesn’t do what it looks like it does. Typically, returning a type when () is expected shouldn’t go silently.<br></p><p>As such I think keeping forEach is important as it allows for every elegant expressions and convey already the already established convention when you use forEach that “I”m only interested in side-effects with elements in this collection”<br></p><p>My proposition is then that instead of removing forEach, we should have better type check and warn when the cardinality of the expected type and the returned type don’t match.<br></p><p>-André<br></p><p>&gt; On 08 Dec 2015, at 20:07, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt; <br>&gt;     func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;             return idx<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; <br>&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt; <br>&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt; <br>&gt; [1,2,3,4,5].forEach { num in<br>&gt;    print(num)<br>&gt;    if num &gt; 3 { return }<br>&gt; }<br>&gt; <br>&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt; <br>&gt; Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/8d158719/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Remove forEach?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>Why does that function even compile? For example, the following produces the compiler error: Unexpected non-void return value in void function<br></p><p>[1,2,3,4,5].forEach { x in<br>    let y = 0<br>    return x<br>}<br></p><p>Which is what I would expect. But this compiles just fine:<br></p><p>[1,2,3,4,5].forEach { x in<br>    return x<br>}<br></p><p>Is this just a compiler bug, or am I missing something?<br></p><p>Tyler<br></p><p>&gt; On Dec 8, 2015, at 2:18 PM, André Videla via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, <br>&gt; <br>&gt; As I understand it, the argument for remove forEach is that it’s easy to make confusing code that doesn’t do what it looks like it should do.<br>&gt; <br>&gt; In this particular example:<br>&gt; <br>&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;             return idx<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; <br>&gt; I think the compiler should give us two warnings:<br>&gt; - closure returns type Int when it should return type ()<br>&gt; - function always return nil (which is a unit type just like () ) when it expects Option&lt;Int&gt;<br>&gt; <br>&gt; In my opinion those warnings should be enough to make the programmer aware that this code doesn’t do what it looks like it does. Typically, returning a type when () is expected shouldn’t go silently.<br>&gt; <br>&gt; As such I think keeping forEach is important as it allows for every elegant expressions and convey already the already established convention when you use forEach that “I”m only interested in side-effects with elements in this collection”<br>&gt; <br>&gt; My proposition is then that instead of removing forEach, we should have better type check and warn when the cardinality of the expected type and the returned type don’t match.<br>&gt; <br>&gt; -André<br>&gt; <br>&gt;&gt; On 08 Dec 2015, at 20:07, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt; <br>&gt;&gt;     func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;             return idx<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt; <br>&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt; <br>&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;    print(num)<br>&gt;&gt;    if num &gt; 3 { return }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt; <br>&gt;&gt; Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/685448fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Remove forEach?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>This falls out of the rule that single-expression closures have their types inferred, and that that inference includes coercion to a Void return type. That&#39;s because of code like this:<br></p><p>dispatch_sync(queue) {<br>  doSomeWork() // returns Bool, but I&#39;m ignoring the result<br>}<br></p><p>Normally, the closure being passed to dispatch_sync would have an inferred type of &#39;() -&gt; Bool&#39;, but dispatch_sync expects a dispatch_block_t, which is &#39;() -&gt; Void&#39;. You can &quot;fix&quot; this by explicitly ignoring the result (&quot;_ = doSomeWork()&quot;), but that&#39;s a little silly, so we added a rule that it&#39;s okay to ignore the result if the closure&#39;s supposed to return Void. That rule really shouldn&#39;t apply when the user explicitly wrote a return, though.<br></p><p>Jordan<br></p><p>&gt; On Dec 8, 2015, at 15:55, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why does that function even compile? For example, the following produces the compiler error: Unexpected non-void return value in void function<br>&gt; <br>&gt; [1,2,3,4,5].forEach { x in<br>&gt;     let y = 0<br>&gt;     return x<br>&gt; }<br>&gt; <br>&gt; Which is what I would expect. But this compiles just fine:<br>&gt; <br>&gt; [1,2,3,4,5].forEach { x in<br>&gt;     return x<br>&gt; }<br>&gt; <br>&gt; Is this just a compiler bug, or am I missing something?<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 2:18 PM, André Videla via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, <br>&gt;&gt; <br>&gt;&gt; As I understand it, the argument for remove forEach is that it’s easy to make confusing code that doesn’t do what it looks like it should do.<br>&gt;&gt; <br>&gt;&gt; In this particular example:<br>&gt;&gt; <br>&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;             return idx<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I think the compiler should give us two warnings:<br>&gt;&gt; - closure returns type Int when it should return type ()<br>&gt;&gt; - function always return nil (which is a unit type just like () ) when it expects Option&lt;Int&gt;<br>&gt;&gt; <br>&gt;&gt; In my opinion those warnings should be enough to make the programmer aware that this code doesn’t do what it looks like it does. Typically, returning a type when () is expected shouldn’t go silently.<br>&gt;&gt; <br>&gt;&gt; As such I think keeping forEach is important as it allows for every elegant expressions and convey already the already established convention when you use forEach that “I”m only interested in side-effects with elements in this collection”<br>&gt;&gt; <br>&gt;&gt; My proposition is then that instead of removing forEach, we should have better type check and warn when the cardinality of the expected type and the returned type don’t match.<br>&gt;&gt; <br>&gt;&gt; -André<br>&gt;&gt; <br>&gt;&gt;&gt; On 08 Dec 2015, at 20:07, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;             return idx<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;&gt;    print(num)<br>&gt;&gt;&gt;    if num &gt; 3 { return }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/c1afccd3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Remove forEach?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December  8, 2015 at 08:00:00pm</p></header><div class="content"><p>Ah yep that’s exactly what it is. It seems like having the rule not &quot;apply when the user explicitly wrote a return” would remove a lot of the pain here.<br></p><p>Tyler<br></p><p><br>&gt; On Dec 8, 2015, at 4:17 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; This falls out of the rule that single-expression closures have their types inferred, and that that inference includes coercion to a Void return type. That&#39;s because of code like this:<br>&gt; <br>&gt; dispatch_sync(queue) {<br>&gt;   doSomeWork() // returns Bool, but I&#39;m ignoring the result<br>&gt; }<br>&gt; <br>&gt; Normally, the closure being passed to dispatch_sync would have an inferred type of &#39;() -&gt; Bool&#39;, but dispatch_sync expects a dispatch_block_t, which is &#39;() -&gt; Void&#39;. You can &quot;fix&quot; this by explicitly ignoring the result (&quot;_ = doSomeWork()&quot;), but that&#39;s a little silly, so we added a rule that it&#39;s okay to ignore the result if the closure&#39;s supposed to return Void. That rule really shouldn&#39;t apply when the user explicitly wrote a return, though.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 15:55, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why does that function even compile? For example, the following produces the compiler error: Unexpected non-void return value in void function<br>&gt;&gt; <br>&gt;&gt; [1,2,3,4,5].forEach { x in<br>&gt;&gt;     let y = 0<br>&gt;&gt;     return x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which is what I would expect. But this compiles just fine:<br>&gt;&gt; <br>&gt;&gt; [1,2,3,4,5].forEach { x in<br>&gt;&gt;     return x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is this just a compiler bug, or am I missing something?<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 2:18 PM, André Videla via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I understand it, the argument for remove forEach is that it’s easy to make confusing code that doesn’t do what it looks like it should do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this particular example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;             return idx<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the compiler should give us two warnings:<br>&gt;&gt;&gt; - closure returns type Int when it should return type ()<br>&gt;&gt;&gt; - function always return nil (which is a unit type just like () ) when it expects Option&lt;Int&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my opinion those warnings should be enough to make the programmer aware that this code doesn’t do what it looks like it does. Typically, returning a type when () is expected shouldn’t go silently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As such I think keeping forEach is important as it allows for every elegant expressions and convey already the already established convention when you use forEach that “I”m only interested in side-effects with elements in this collection”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposition is then that instead of removing forEach, we should have better type check and warn when the cardinality of the expected type and the returned type don’t match.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -André<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 08 Dec 2015, at 20:07, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;&gt;             return idx<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;&gt;&gt;    print(num)<br>&gt;&gt;&gt;&gt;    if num &gt; 3 { return }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/7c6aee24/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Remove forEach?</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>December  8, 2015 at 06:00:00pm</p></header><div class="content"><p>The Swift compiler started skipping the &quot;non-void return value&quot; error for single-line closures a few versions ago, since it was being triggered by the auto-return feature. I think that&#39;s what you&#39;re seeing here.<br></p><p>Nate<br></p><p>&gt; On Dec 8, 2015, at 5:55 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why does that function even compile? For example, the following produces the compiler error: Unexpected non-void return value in void function<br>&gt; <br>&gt; [1,2,3,4,5].forEach { x in<br>&gt;     let y = 0<br>&gt;     return x<br>&gt; }<br>&gt; <br>&gt; Which is what I would expect. But this compiles just fine:<br>&gt; <br>&gt; [1,2,3,4,5].forEach { x in<br>&gt;     return x<br>&gt; }<br>&gt; <br>&gt; Is this just a compiler bug, or am I missing something?<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 2:18 PM, André Videla via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, <br>&gt;&gt; <br>&gt;&gt; As I understand it, the argument for remove forEach is that it’s easy to make confusing code that doesn’t do what it looks like it should do.<br>&gt;&gt; <br>&gt;&gt; In this particular example:<br>&gt;&gt; <br>&gt;&gt;   func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;             return idx<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I think the compiler should give us two warnings:<br>&gt;&gt; - closure returns type Int when it should return type ()<br>&gt;&gt; - function always return nil (which is a unit type just like () ) when it expects Option&lt;Int&gt;<br>&gt;&gt; <br>&gt;&gt; In my opinion those warnings should be enough to make the programmer aware that this code doesn’t do what it looks like it does. Typically, returning a type when () is expected shouldn’t go silently.<br>&gt;&gt; <br>&gt;&gt; As such I think keeping forEach is important as it allows for every elegant expressions and convey already the already established convention when you use forEach that “I”m only interested in side-effects with elements in this collection”<br>&gt;&gt; <br>&gt;&gt; My proposition is then that instead of removing forEach, we should have better type check and warn when the cardinality of the expected type and the returned type don’t match.<br>&gt;&gt; <br>&gt;&gt; -André<br>&gt;&gt; <br>&gt;&gt;&gt; On 08 Dec 2015, at 20:07, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`. I understand that it can read much nicer to write something like `a.map { something }.filter { somethingElse }.forEach {` rather than a `for` loop. However, I think the costs don’t outweigh the benefits. It might look like a for loop can just be replaced by a `forEach`, however, this is not true in the general case. For example, consider the following example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func indexOf_foreach(element: Element) -&gt; Int? {<br>&gt;&gt;&gt;         self.indices.filter { idx in self[idx] == element }.forEach { idx in<br>&gt;&gt;&gt;             return idx<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code above (I realise it’s quite inefficient) might look like it’s returning the first index for which the filter’s condition returned true. However, the first occurrence of return is actually returning inside the closure, not the outer function. So the result of this function is always nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another solution would be to give a good warning/error message here (you’re trying to return an Optional value where we expect a ()). However, this is also problematic when dealing with side-effects. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1,2,3,4,5].forEach { num in<br>&gt;&gt;&gt;    print(num)<br>&gt;&gt;&gt;    if num &gt; 3 { return }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s quite easy to get things wrong with forEach, so I’d propose removing it and rather having a regular for loop. (Erica-style).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/f6d38b49/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Remove forEach?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`.<br></p><p>Here’s a typical use of forEach for me:<br></p><p>	generateABunchOfSubviews().forEach(addSubview)<br></p><p>Seriously. I have one unreleased app which generates an entire software keyboard like that.<br></p><p>You could write it like:<br></p><p>	for subview in generateABunchOfSubviews() {<br>		addSubview(subview)<br>	}<br></p><p>But why use the extra lines and temporary variable when you don’t have to?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove forEach?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December  8, 2015 at 10:00:00pm</p></header><div class="content"><p>That is a great example of the usefulness, Brent! I like it a lot =).<br></p><p>It seems like I’m the only one who actively dislikes it.<br></p><p>Just to give a little bit more background: I’ve taught some workshops on Swift, and this problem has come up more than once. Before sending my original email, I showed it to a friend in the office, he knew what the return inside forEach was doing, but said it was only because he’d been bitten by the exact same thing.<br></p><p>I liked Joe’s proposal. This might even get us a step closer to writing `while` and `for` in the standard library, rather than have them as built-in constructs… <br></p><p>Chris<br></p><p>&gt; On 08 Dec 2015, at 17:47, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; As long as the `for` loop is in the language, I don’t really see the use of `forEach`.<br>&gt; <br>&gt; Here’s a typical use of forEach for me:<br>&gt; <br>&gt; 	generateABunchOfSubviews().forEach(addSubview)<br>&gt; <br>&gt; Seriously. I have one unreleased app which generates an entire software keyboard like that.<br>&gt; <br>&gt; You could write it like:<br>&gt; <br>&gt; 	for subview in generateABunchOfSubviews() {<br>&gt; 		addSubview(subview)<br>&gt; 	}<br>&gt; <br>&gt; But why use the extra lines and temporary variable when you don’t have to?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
