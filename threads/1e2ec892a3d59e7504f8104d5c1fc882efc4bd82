<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15c94a5f39218f934b7274e011d3b505?s=50"></div><header><strong>Add an implicit return nil if function reaches end before return explicitly called</strong> from <string>Logan Sease</string> &lt;lsease at gmail.com&gt;<p>June 22, 2016 at 03:00:00pm</p></header><div class="content"><p>I believe Swift should no longer require an explicit return on all functions and instead do an implicit nil return if the function reaches the end of its control flow and has an optional return type.<br></p><p>This could be useful to keep code clean and compact, by only having to write code for cases that our function handles and just returning nil otherwise automatically.<br></p><p><br>Consider:<br></p><p>func toInt(string : String?) -&gt; Int?<br>{<br>	if let s = string<br>	{<br>		return s.intValue<br>	}<br></p><p>	//Make this return implicitly happen instead of requiring it.<br>	//return nil <br>}<br></p><p><br></p><p>This also very much goes along with the implicit return within a guard statement that I have seen proposed. Here:<br></p><p>func toInt(string: String?) -&gt; Int?<br>{<br>	guard let s = string else {<br>		 //this could be implicitly returned using the same logic, since the guard means we have reached the end of our code path without returning<br>		//return nil <br>	}<br>	return s.toInt()<br>}<br></p><p><br>These methods could be re-written as so:<br></p><p>This could allow us to write the examples below much cleaner<br>func toInt(string : String?) -&gt; Int?<br>{<br>	if let s = string<br>	{<br>		return s.toInt()<br>	}<br>}<br></p><p>func toInt(string: String?) -&gt; Int?<br>{<br>	guard let s = string else {} <br>	return s.toInt()<br>}<br></p><p>// it would be even cooler if we could omit the else {} and make them not it return by default. But that’s another thing all together<br>func toInt(string: String?) -&gt; Int?<br>{<br>	guard let s = string<br>	return s.toInt()<br>}<br></p><p><br>Thanks for reading my first post to the Swift open source discussion board!<br>-Logan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>Add an implicit return nil if function reaches end before return explicitly called</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>June 22, 2016 at 04:00:00pm</p></header><div class="content"><p>I thought of this myself at one point, but I looked at a list of other languages to see if they did it and, if so, how much it actually improved anything.<br></p><p>The only language I could find that I have experience in which does this outside of closures was Bash shell scripting, and there wasn’t much to judge there because return doesn’t even mean the same thing in a shell script that it does in most programming languages. Nonetheless, it felt weird to me; lack of a return statement has always been for void functions (&quot;there’s nothing *to* return&quot;).<br></p><p>Adding this to Swift would create a lot of confusing cases - if the return type is already Optional, can I then write &quot;return&quot; instead of &quot;return nil&quot; for places in the control flow that need to return without falling off the closing brace? If it isn’t, do I have to make it Optional, or will the compiler do that for me? If it does it for me, will it add a second level of Optional to the first one? (&#39;cause while &quot;Int??&quot; (for example) might have uses, there are almost certainly better ways to express it.) Which of these options for behavior will be the least confusing? How do I tell the compiler &quot;Don’t do that, warn me/error instead&quot;, especially when returning Optionals already? If I have to annotate functions I want explicit errors for, do I have to effectively put back a different form of the very @warn_unused_result attribute we just finally got rid of needing for the common case? How does this interact with error handling, especially in the presence of closures and &quot;rethrows&quot;? How does this interact with the implicit return from closures, and do closures now get the same semantics? Does &quot;{}&quot; in function type context now implicitly mean &quot;{ ()-&gt;Void? in return nil }&quot;? And if so, how can that change be justified given that it will change the semantics of many closures (workitems for DispatchQueue.async() come to mind) to be effectively wrong? If that isn’t the effect, how do you resolve the confusion developers will experience when they try to mix the enclosing function’s implicit return with a closure’s? What defines a function’s exit point for the purposes of the implicit return? The &quot;end&quot; of a function isn’t always where it seems to be. Can this be expressed reasonably by SIL in its current form without adding considerable extra logic to the compiler? Would this save enough code (a single, fairly short line per function) to justify so massive a semantic change, especially given that it violates the expectations of almost every language Swift typically replaces (C, C++, Objective-C, C#, Java, Perl, PHP, Python, Ruby, just to name a few)?<br></p><p>Ultimately I don’t feel like this would add anything but confusion to the language; couldn’t your example be rewritten as &quot;func toInt(string: String?) -&gt; Int? { return string?.intValue }&quot;? Optional chaining would usually solve such cases more cleanly in my experience.<br></p><p>-- Gwynne Raskind<br></p><p><br></p><p>&gt; On Jun 22, 2016, at 14:44, Logan Sease via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe Swift should no longer require an explicit return on all functions and instead do an implicit nil return if the function reaches the end of its control flow and has an optional return type.<br>&gt; <br>&gt; This could be useful to keep code clean and compact, by only having to write code for cases that our function handles and just returning nil otherwise automatically.<br>&gt; <br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt; func toInt(string : String?) -&gt; Int?<br>&gt; {<br>&gt; 	if let s = string<br>&gt; 	{<br>&gt; 		return s.intValue<br>&gt; 	}<br>&gt; <br>&gt; 	//Make this return implicitly happen instead of requiring it.<br>&gt; 	//return nil <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; This also very much goes along with the implicit return within a guard statement that I have seen proposed. Here:<br>&gt; <br>&gt; func toInt(string: String?) -&gt; Int?<br>&gt; {<br>&gt; 	guard let s = string else {<br>&gt; 		 //this could be implicitly returned using the same logic, since the guard means we have reached the end of our code path without returning<br>&gt; 		//return nil <br>&gt; 	}<br>&gt; 	return s.toInt()<br>&gt; }<br>&gt; <br>&gt; <br>&gt; These methods could be re-written as so:<br>&gt; <br>&gt; This could allow us to write the examples below much cleaner<br>&gt; func toInt(string : String?) -&gt; Int?<br>&gt; {<br>&gt; 	if let s = string<br>&gt; 	{<br>&gt; 		return s.toInt()<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; func toInt(string: String?) -&gt; Int?<br>&gt; {<br>&gt; 	guard let s = string else {} <br>&gt; 	return s.toInt()<br>&gt; }<br>&gt; <br>&gt; // it would be even cooler if we could omit the else {} and make them not it return by default. But that’s another thing all together<br>&gt; func toInt(string: String?) -&gt; Int?<br>&gt; {<br>&gt; 	guard let s = string<br>&gt; 	return s.toInt()<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Thanks for reading my first post to the Swift open source discussion board!<br>&gt; -Logan<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15c94a5f39218f934b7274e011d3b505?s=50"></div><header><strong>Add an implicit return nil if function reaches end before return explicitly called</strong> from <string>Logan Sease</string> &lt;lsease at gmail.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>So this particular construct is one that comes from the ruby language. <br>In Ruby, you don’t explicitly have to return at all, but rather your last statement will always return by default. <br>I am NOT advocating this exactly for swift… I get that it could lead to errors and confusion.<br></p><p>But here is my logic:<br>If the function returns an optional, this basically means that it may not return something. So then, why require the function to call a return explicitly at the end of the function?<br>Instead, I believe if we reach the end of the function and a return has not been called, we should implicitly return nil… because logically, we are not returning anything, so requiring the function to explicitly return seems redundant.<br></p><p><br></p><p><br>&gt; On Jun 22, 2016, at 5:31 PM, Gwynne Raskind &lt;gwynne at darkrainfall.org&gt; wrote:<br>&gt; <br>&gt; I thought of this myself at one point, but I looked at a list of other languages to see if they did it and, if so, how much it actually improved anything.<br>&gt; <br>&gt; The only language I could find that I have experience in which does this outside of closures was Bash shell scripting, and there wasn’t much to judge there because return doesn’t even mean the same thing in a shell script that it does in most programming languages. Nonetheless, it felt weird to me; lack of a return statement has always been for void functions (&quot;there’s nothing *to* return&quot;).<br>&gt; <br>&gt; Adding this to Swift would create a lot of confusing cases - if the return type is already Optional, can I then write &quot;return&quot; instead of &quot;return nil&quot; for places in the control flow that need to return without falling off the closing brace? If it isn’t, do I have to make it Optional, or will the compiler do that for me? If it does it for me, will it add a second level of Optional to the first one? (&#39;cause while &quot;Int??&quot; (for example) might have uses, there are almost certainly better ways to express it.) Which of these options for behavior will be the least confusing? How do I tell the compiler &quot;Don’t do that, warn me/error instead&quot;, especially when returning Optionals already? If I have to annotate functions I want explicit errors for, do I have to effectively put back a different form of the very @warn_unused_result attribute we just finally got rid of needing for the common case? How does this interact with error handling, especially in the presence of closures and &quot;rethrows&quot;? How does this interact with the implicit return from closures, and do closures now get the same semantics? Does &quot;{}&quot; in function type context now implicitly mean &quot;{ ()-&gt;Void? in return nil }&quot;? And if so, how can that change be justified given that it will change the semantics of many closures (workitems for DispatchQueue.async() come to mind) to be effectively wrong? If that isn’t the effect, how do you resolve the confusion developers will experience when they try to mix the enclosing function’s implicit return with a closure’s? What defines a function’s exit point for the purposes of the implicit return? The &quot;end&quot; of a function isn’t always where it seems to be. Can this be expressed reasonably by SIL in its current form without adding considerable extra logic to the compiler? Would this save enough code (a single, fairly short line per function) to justify so massive a semantic change, especially given that it violates the expectations of almost every language Swift typically replaces (C, C++, Objective-C, C#, Java, Perl, PHP, Python, Ruby, just to name a few)?<br>&gt; <br>&gt; Ultimately I don’t feel like this would add anything but confusion to the language; couldn’t your example be rewritten as &quot;func toInt(string: String?) -&gt; Int? { return string?.intValue }&quot;? Optional chaining would usually solve such cases more cleanly in my experience.<br>&gt; <br>&gt; -- Gwynne Raskind<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 14:44, Logan Sease via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe Swift should no longer require an explicit return on all functions and instead do an implicit nil return if the function reaches the end of its control flow and has an optional return type.<br>&gt;&gt; <br>&gt;&gt; This could be useful to keep code clean and compact, by only having to write code for cases that our function handles and just returning nil otherwise automatically.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Consider:<br>&gt;&gt; <br>&gt;&gt; func toInt(string : String?) -&gt; Int?<br>&gt;&gt; {<br>&gt;&gt; 	if let s = string<br>&gt;&gt; 	{<br>&gt;&gt; 		return s.intValue<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	//Make this return implicitly happen instead of requiring it.<br>&gt;&gt; 	//return nil <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This also very much goes along with the implicit return within a guard statement that I have seen proposed. Here:<br>&gt;&gt; <br>&gt;&gt; func toInt(string: String?) -&gt; Int?<br>&gt;&gt; {<br>&gt;&gt; 	guard let s = string else {<br>&gt;&gt; 		 //this could be implicitly returned using the same logic, since the guard means we have reached the end of our code path without returning<br>&gt;&gt; 		//return nil <br>&gt;&gt; 	}<br>&gt;&gt; 	return s.toInt()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; These methods could be re-written as so:<br>&gt;&gt; <br>&gt;&gt; This could allow us to write the examples below much cleaner<br>&gt;&gt; func toInt(string : String?) -&gt; Int?<br>&gt;&gt; {<br>&gt;&gt; 	if let s = string<br>&gt;&gt; 	{<br>&gt;&gt; 		return s.toInt()<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func toInt(string: String?) -&gt; Int?<br>&gt;&gt; {<br>&gt;&gt; 	guard let s = string else {} <br>&gt;&gt; 	return s.toInt()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // it would be even cooler if we could omit the else {} and make them not it return by default. But that’s another thing all together<br>&gt;&gt; func toInt(string: String?) -&gt; Int?<br>&gt;&gt; {<br>&gt;&gt; 	guard let s = string<br>&gt;&gt; 	return s.toInt()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks for reading my first post to the Swift open source discussion board!<br>&gt;&gt; -Logan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Add an implicit return nil if function reaches end before return explicitly called</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 12:10 PM, Logan Sease via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So this particular construct is one that comes from the ruby language.<br>&gt; In Ruby, you don’t explicitly have to return at all, but rather your last<br>&gt; statement will always return by default.<br>&gt; I am NOT advocating this exactly for swift… I get that it could lead to<br>&gt; errors and confusion.<br>&gt;<br>&gt; But here is my logic:<br>&gt; If the function returns an optional, this basically means that it may not<br>&gt; return something.<br></p><p><br>() and nil are not the same.<br></p><p>So then, why require the function to call a return explicitly at the end of<br>&gt; the function?<br>&gt; Instead, I believe if we reach the end of the function and a return has<br>&gt; not been called, we should implicitly return nil… because logically, we are<br>&gt; not returning anything, so requiring the function to explicitly return<br>&gt; seems redundant.<br>&gt;<br></p><p>You are returning nil, which isn&#39;t &quot;not returning anything.&quot; Notice also<br>that you must write `return nil` and not just `return`.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 22, 2016, at 5:31 PM, Gwynne Raskind &lt;gwynne at darkrainfall.org&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I thought of this myself at one point, but I looked at a list of other<br>&gt; languages to see if they did it and, if so, how much it actually improved<br>&gt; anything.<br>&gt; &gt;<br>&gt; &gt; The only language I could find that I have experience in which does this<br>&gt; outside of closures was Bash shell scripting, and there wasn’t much to<br>&gt; judge there because return doesn’t even mean the same thing in a shell<br>&gt; script that it does in most programming languages. Nonetheless, it felt<br>&gt; weird to me; lack of a return statement has always been for void functions<br>&gt; (&quot;there’s nothing *to* return&quot;).<br>&gt; &gt;<br>&gt; &gt; Adding this to Swift would create a lot of confusing cases - if the<br>&gt; return type is already Optional, can I then write &quot;return&quot; instead of<br>&gt; &quot;return nil&quot; for places in the control flow that need to return without<br>&gt; falling off the closing brace? If it isn’t, do I have to make it Optional,<br>&gt; or will the compiler do that for me? If it does it for me, will it add a<br>&gt; second level of Optional to the first one? (&#39;cause while &quot;Int??&quot; (for<br>&gt; example) might have uses, there are almost certainly better ways to express<br>&gt; it.) Which of these options for behavior will be the least confusing? How<br>&gt; do I tell the compiler &quot;Don’t do that, warn me/error instead&quot;, especially<br>&gt; when returning Optionals already? If I have to annotate functions I want<br>&gt; explicit errors for, do I have to effectively put back a different form of<br>&gt; the very @warn_unused_result attribute we just finally got rid of needing<br>&gt; for the common case? How does this interact with error handling, especially<br>&gt; in the presence of closures and &quot;rethrows&quot;? How does this interact with the<br>&gt; implicit return from closures, and do closures now get the same semantics?<br>&gt; Does &quot;{}&quot; in function type context now implicitly mean &quot;{ ()-&gt;Void? in<br>&gt; return nil }&quot;? And if so, how can that change be justified given that it<br>&gt; will change the semantics of many closures (workitems for<br>&gt; DispatchQueue.async() come to mind) to be effectively wrong? If that isn’t<br>&gt; the effect, how do you resolve the confusion developers will experience<br>&gt; when they try to mix the enclosing function’s implicit return with a<br>&gt; closure’s? What defines a function’s exit point for the purposes of the<br>&gt; implicit return? The &quot;end&quot; of a function isn’t always where it seems to be.<br>&gt; Can this be expressed reasonably by SIL in its current form without adding<br>&gt; considerable extra logic to the compiler? Would this save enough code (a<br>&gt; single, fairly short line per function) to justify so massive a semantic<br>&gt; change, especially given that it violates the expectations of almost every<br>&gt; language Swift typically replaces (C, C++, Objective-C, C#, Java, Perl,<br>&gt; PHP, Python, Ruby, just to name a few)?<br>&gt; &gt;<br>&gt; &gt; Ultimately I don’t feel like this would add anything but confusion to<br>&gt; the language; couldn’t your example be rewritten as &quot;func toInt(string:<br>&gt; String?) -&gt; Int? { return string?.intValue }&quot;? Optional chaining would<br>&gt; usually solve such cases more cleanly in my experience.<br>&gt; &gt;<br>&gt; &gt; -- Gwynne Raskind<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 22, 2016, at 14:44, Logan Sease via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I believe Swift should no longer require an explicit return on all<br>&gt; functions and instead do an implicit nil return if the function reaches the<br>&gt; end of its control flow and has an optional return type.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This could be useful to keep code clean and compact, by only having to<br>&gt; write code for cases that our function handles and just returning nil<br>&gt; otherwise automatically.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Consider:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func toInt(string : String?) -&gt; Int?<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;      if let s = string<br>&gt; &gt;&gt;      {<br>&gt; &gt;&gt;              return s.intValue<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      //Make this return implicitly happen instead of requiring it.<br>&gt; &gt;&gt;      //return nil<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This also very much goes along with the implicit return within a guard<br>&gt; statement that I have seen proposed. Here:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func toInt(string: String?) -&gt; Int?<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;      guard let s = string else {<br>&gt; &gt;&gt;               //this could be implicitly returned using the same logic,<br>&gt; since the guard means we have reached the end of our code path without<br>&gt; returning<br>&gt; &gt;&gt;              //return nil<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt;      return s.toInt()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; These methods could be re-written as so:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This could allow us to write the examples below much cleaner<br>&gt; &gt;&gt; func toInt(string : String?) -&gt; Int?<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;      if let s = string<br>&gt; &gt;&gt;      {<br>&gt; &gt;&gt;              return s.toInt()<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func toInt(string: String?) -&gt; Int?<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;      guard let s = string else {}<br>&gt; &gt;&gt;      return s.toInt()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // it would be even cooler if we could omit the else {} and make them<br>&gt; not it return by default. But that’s another thing all together<br>&gt; &gt;&gt; func toInt(string: String?) -&gt; Int?<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;      guard let s = string<br>&gt; &gt;&gt;      return s.toInt()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thanks for reading my first post to the Swift open source discussion<br>&gt; board!<br>&gt; &gt;&gt; -Logan<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/e405eb7b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
