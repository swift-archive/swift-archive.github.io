<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br></p><p>- the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>- the strong and unowned reference counts,<br>- &#39;pinned&#39; and &#39;deallocating&#39; flags.<br></p><p>We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br></p><p>Dropping the unowned reference count<br></p><p>If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br></p><p>Non-pointer isa for 64-bit platforms<br></p><p>Neither x86-64 nor ARM64 populates the full 64 bits of address space—contemporary x86-64 uses only 48 bits (sign-extended, so effectively 47 bits for userspace), and Apple ARM64 platforms use fewer bits, the exact number dependent on OS version. If we were willing to drop the unowned refcount, and say that &quot;64Ki-retains ought to be enough for anyone&quot;, overflowing the retain count into the &quot;not refcounted&quot; bit to leak overly-retained objects, we could use a layout similar to this to pack the remaining information into 8 bytes:<br></p><p>bits   meaning<br>-----  -------<br>63     not refcounted<br>47…62  strong refcount<br>03…46  metadata pointer<br>02     (reserved)<br>01     deallocating<br>00     pinned<br></p><p>There are of course some costs and complications. For classes, we look up vtable entries and resilient ivar offsets through the isa pointer, and masking the isa costs an extra instruction per object, though that can at least be shared for multiple method calls on the same object since we assume objects don&#39;t change class (at least not in ways that would change Swift method implementation or ivar layout). We do already pay this cost on Apple platforms for NSObject subclasses. More interestingly, Objective-C already uses non-pointer isa on ARM64, but not on x86-64. I&#39;m not sure how flexible the ObjC implementation is here—Could Swift use non-pointer isas on platforms where ObjC doesn&#39;t? Could it ascribe different meanings to the bits from ObjC&#39;s?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/67b8777b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br>&gt; <br>&gt; - the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>&gt; - the strong and unowned reference counts,<br>&gt; - &#39;pinned&#39; and &#39;deallocating&#39; flags.<br>&gt; <br>&gt; We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br>&gt; <br>&gt; Dropping the unowned reference count<br>&gt; <br>&gt; If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br></p><p>Unless I’m misunderstanding something, the activity count implementation doesn’t actually change anything about the need to register the existence of the weak/unowned reference with the object.<br></p><p>We could compact the two reference counts into a single 32-bit header; that would help a lot on 32-bit targets.  However, doing so would shrink both reference counts to the point that leaking on overflow would become unacceptable; we would definitely need some ability to spill over into a side table.<br></p><p>John.<br></p><p>&gt; <br>&gt; Non-pointer isa for 64-bit platforms<br>&gt; <br>&gt; Neither x86-64 nor ARM64 populates the full 64 bits of address space—contemporary x86-64 uses only 48 bits (sign-extended, so effectively 47 bits for userspace), and Apple ARM64 platforms use fewer bits, the exact number dependent on OS version. If we were willing to drop the unowned refcount, and say that &quot;64Ki-retains ought to be enough for anyone&quot;, overflowing the retain count into the &quot;not refcounted&quot; bit to leak overly-retained objects, we could use a layout similar to this to pack the remaining information into 8 bytes:<br>&gt; <br>&gt; bits   meaning<br>&gt; -----  -------<br>&gt; 63     not refcounted<br>&gt; 47…62  strong refcount<br>&gt; 03…46  metadata pointer<br>&gt; 02     (reserved)<br>&gt; 01     deallocating<br>&gt; 00     pinned<br>&gt; <br>&gt; There are of course some costs and complications. For classes, we look up vtable entries and resilient ivar offsets through the isa pointer, and masking the isa costs an extra instruction per object, though that can at least be shared for multiple method calls on the same object since we assume objects don&#39;t change class (at least not in ways that would change Swift method implementation or ivar layout). We do already pay this cost on Apple platforms for NSObject subclasses. More interestingly, Objective-C already uses non-pointer isa on ARM64, but not on x86-64. I&#39;m not sure how flexible the ObjC implementation is here—Could Swift use non-pointer isas on platforms where ObjC doesn&#39;t? Could it ascribe different meanings to the bits from ObjC&#39;s?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/8b80ad4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 11:51 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br>&gt;&gt; <br>&gt;&gt; - the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>&gt;&gt; - the strong and unowned reference counts,<br>&gt;&gt; - &#39;pinned&#39; and &#39;deallocating&#39; flags.<br>&gt;&gt; <br>&gt;&gt; We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br>&gt;&gt; <br>&gt;&gt; Dropping the unowned reference count<br>&gt;&gt; <br>&gt;&gt; If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br>&gt; <br>&gt; Unless I’m misunderstanding something, the activity count implementation doesn’t actually change anything about the need to register the existence of the weak/unowned reference with the object.<br>&gt; <br>&gt; We could compact the two reference counts into a single 32-bit header; that would help a lot on 32-bit targets.  However, doing so would shrink both reference counts to the point that leaking on overflow would become unacceptable; we would definitely need some ability to spill over into a side table.<br></p><p>I probably misunderstood too. If that&#39;s the case, we could still probably allocate more bits to the strong refcount than to the unowned one, since it&#39;s probably more acceptable to spill into a side table for weak references more often than for strong ones.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/6761daf8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 1:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 15, 2016, at 11:51 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>&gt;&gt;&gt; - the strong and unowned reference counts,<br>&gt;&gt;&gt; - &#39;pinned&#39; and &#39;deallocating&#39; flags.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dropping the unowned reference count<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br>&gt;&gt; <br>&gt;&gt; Unless I’m misunderstanding something, the activity count implementation doesn’t actually change anything about the need to register the existence of the weak/unowned reference with the object.<br>&gt;&gt; <br>&gt;&gt; We could compact the two reference counts into a single 32-bit header; that would help a lot on 32-bit targets.  However, doing so would shrink both reference counts to the point that leaking on overflow would become unacceptable; we would definitely need some ability to spill over into a side table.<br>&gt; <br>&gt; I probably misunderstood too. If that&#39;s the case, we could still probably allocate more bits to the strong refcount than to the unowned one, since it&#39;s probably more acceptable to spill into a side table for weak references more often than for strong ones.<br></p><p>Agreed.  I just mean that it probably still shrinks the strong reference count down to a point (~20 bits?) that leaking isn’t obviously acceptable.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/8b41e36f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br>&gt; <br>&gt; - the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>&gt; - the strong and unowned reference counts,<br>&gt; - &#39;pinned&#39; and &#39;deallocating&#39; flags.<br>&gt; <br>&gt; We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br>&gt; <br>&gt; Dropping the unowned reference count<br>&gt; <br>&gt; If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br>&gt; <br>&gt; Non-pointer isa for 64-bit platforms<br>&gt; <br>&gt; Neither x86-64 nor ARM64 populates the full 64 bits of address space—contemporary x86-64 uses only 48 bits (sign-extended, so effectively 47 bits for userspace), and Apple ARM64 platforms use fewer bits, the exact number dependent on OS version. If we were willing to drop the unowned refcount, and say that &quot;64Ki-retains ought to be enough for anyone&quot;, overflowing the retain count into the &quot;not refcounted&quot; bit to leak overly-retained objects,<br></p><p>64K retains is not enough for everybody. NSParagraphStyle had a 19-bit inline retain count with no overflow protection (i.e. it incorrectly deallocated if you retained it too much and then called some releases). This occasionally crashed in Xcode (rdar://16008112).<br></p><p><br>&gt; we could use a layout similar to this to pack the remaining information into 8 bytes:<br>&gt; <br>&gt; bits   meaning<br>&gt; -----  -------<br>&gt; 63     not refcounted<br>&gt; 47…62  strong refcount<br>&gt; 03…46  metadata pointer<br>&gt; 02     (reserved)<br>&gt; 01     deallocating<br>&gt; 00     pinned<br></p><p>What is the difference between &quot;pinned&quot; and &quot;not refcounted&quot; ? I would expect that you only need one bit to mark objects that are constant or whose refcount has overflowed.<br></p><p>Note that the memory analysis folks really want a few bits reserved with a constant value. That improves their reliability when distinguishing real objects from non-object memory that happens to have an isa-like field in front. ObjC currently gives them 6 bits on all architectures.<br></p><p><br>&gt; There are of course some costs and complications. For classes, we look up vtable entries and resilient ivar offsets through the isa pointer, and masking the isa costs an extra instruction per object, though that can at least be shared for multiple method calls on the same object since we assume objects don&#39;t change class (at least not in ways that would change Swift method implementation or ivar layout). We do already pay this cost on Apple platforms for NSObject subclasses. More interestingly, Objective-C already uses non-pointer isa on ARM64, but not on x86-64.<br></p><p>Objective-C now uses non-pointer isa on x86_64 (as of OS X 10.11 iirc).<br></p><p><br>&gt; I&#39;m not sure how flexible the ObjC implementation is here—Could Swift use non-pointer isas on platforms where ObjC doesn&#39;t? Could it ascribe different meanings to the bits from ObjC&#39;s?<br></p><p>For backwards deployment, no. libobjc currently assumes that every isa field is either a raw class pointer or libobjc&#39;s packed representation. <br></p><p>With libobjc&#39;s cooperation, maybe. You would almost certainly need everybody to use the same mask value. If the other bits mean different things in Swift vs ObjC then you would also need to use a bit to distinguish the representations.<br></p><p><br>How does the object header size interact with resilience? If we squeeze into an 8-byte header and then regret it later, will we have any recourse?<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/08d2cdd1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 4:21 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br>&gt;&gt; <br>&gt;&gt; - the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>&gt;&gt; - the strong and unowned reference counts,<br>&gt;&gt; - &#39;pinned&#39; and &#39;deallocating&#39; flags.<br>&gt;&gt; <br>&gt;&gt; We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br>&gt;&gt; <br>&gt;&gt; Dropping the unowned reference count<br>&gt;&gt; <br>&gt;&gt; If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br>&gt;&gt; <br>&gt;&gt; Non-pointer isa for 64-bit platforms<br>&gt;&gt; <br>&gt;&gt; Neither x86-64 nor ARM64 populates the full 64 bits of address space—contemporary x86-64 uses only 48 bits (sign-extended, so effectively 47 bits for userspace), and Apple ARM64 platforms use fewer bits, the exact number dependent on OS version. If we were willing to drop the unowned refcount, and say that &quot;64Ki-retains ought to be enough for anyone&quot;, overflowing the retain count into the &quot;not refcounted&quot; bit to leak overly-retained objects,<br>&gt; <br>&gt; 64K retains is not enough for everybody. NSParagraphStyle had a 19-bit inline retain count with no overflow protection (i.e. it incorrectly deallocated if you retained it too much and then called some releases). This occasionally crashed in Xcode (rdar://16008112 &lt;rdar://16008112&gt;).<br>&gt; <br>&gt; <br>&gt;&gt; we could use a layout similar to this to pack the remaining information into 8 bytes:<br>&gt;&gt; <br>&gt;&gt; bits   meaning<br>&gt;&gt; -----  -------<br>&gt;&gt; 63     not refcounted<br>&gt;&gt; 47…62  strong refcount<br>&gt;&gt; 03…46  metadata pointer<br>&gt;&gt; 02     (reserved)<br>&gt;&gt; 01     deallocating<br>&gt;&gt; 00     pinned<br>&gt; <br>&gt; What is the difference between &quot;pinned&quot; and &quot;not refcounted&quot; ? I would expect that you only need one bit to mark objects that are constant or whose refcount has overflowed.<br></p><p>“pinned” is the “this object is undergoing mutation, you don’t need to copy it” bit and has nothing to do with refcount overflow.  I can understand the confusion, though.<br></p><p>&gt; Note that the memory analysis folks really want a few bits reserved with a constant value. That improves their reliability when distinguishing real objects from non-object memory that happens to have an isa-like field in front. ObjC currently gives them 6 bits on all architectures.<br>&gt; <br>&gt; <br>&gt;&gt; There are of course some costs and complications. For classes, we look up vtable entries and resilient ivar offsets through the isa pointer, and masking the isa costs an extra instruction per object, though that can at least be shared for multiple method calls on the same object since we assume objects don&#39;t change class (at least not in ways that would change Swift method implementation or ivar layout). We do already pay this cost on Apple platforms for NSObject subclasses. More interestingly, Objective-C already uses non-pointer isa on ARM64, but not on x86-64.<br>&gt; <br>&gt; Objective-C now uses non-pointer isa on x86_64 (as of OS X 10.11 iirc).<br>&gt; <br>&gt; <br>&gt;&gt; I&#39;m not sure how flexible the ObjC implementation is here—Could Swift use non-pointer isas on platforms where ObjC doesn&#39;t? Could it ascribe different meanings to the bits from ObjC&#39;s?<br>&gt; <br>&gt; For backwards deployment, no. libobjc currently assumes that every isa field is either a raw class pointer or libobjc&#39;s packed representation. <br>&gt; <br>&gt; With libobjc&#39;s cooperation, maybe. You would almost certainly need everybody to use the same mask value. If the other bits mean different things in Swift vs ObjC then you would also need to use a bit to distinguish the representations.<br>&gt; <br>&gt; <br>&gt; How does the object header size interact with resilience? If we squeeze into an 8-byte header and then regret it later, will we have any recourse?<br></p><p>If we want to ever be able to do static fixed offsets, that means assuming a header size.  We currently use static fixed offsets on native Swift objects all the time.<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/43ac0649/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 4:21 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; we could use a layout similar to this to pack the remaining information into 8 bytes:<br>&gt;&gt; <br>&gt;&gt; bits   meaning<br>&gt;&gt; -----  -------<br>&gt;&gt; 63     not refcounted<br>&gt;&gt; 47…62  strong refcount<br>&gt;&gt; 03…46  metadata pointer<br>&gt;&gt; 02     (reserved)<br>&gt;&gt; 01     deallocating<br>&gt;&gt; 00     pinned<br>&gt; <br>&gt; Note that the memory analysis folks really want a few bits reserved with a constant value. That improves their reliability when distinguishing real objects from non-object memory that happens to have an isa-like field in front. ObjC currently gives them 6 bits on all architectures.<br></p><p>To clarify: Analysis tools like `heap` and `leaks` need to distinguish real objects from other heap allocations. The false positive rate is tolerable if the isa field is a raw pointer. (As long as some other code like libobjc itself deliberately disguises some of its own data structures that would otherwise look like false positives.)<br></p><p>Non-pointer isa greatly increases the false positive rate. There is too much non-object data that happens to match some real class pointer when only the class bits can be examined. Adding some constant non-zero bits brings it back down again. <br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/cee494bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 4:36 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 4:21 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; we could use a layout similar to this to pack the remaining information into 8 bytes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; bits   meaning<br>&gt;&gt;&gt; -----  -------<br>&gt;&gt;&gt; 63     not refcounted<br>&gt;&gt;&gt; 47…62  strong refcount<br>&gt;&gt;&gt; 03…46  metadata pointer<br>&gt;&gt;&gt; 02     (reserved)<br>&gt;&gt;&gt; 01     deallocating<br>&gt;&gt;&gt; 00     pinned<br>&gt;&gt; <br>&gt;&gt; Note that the memory analysis folks really want a few bits reserved with a constant value. That improves their reliability when distinguishing real objects from non-object memory that happens to have an isa-like field in front. ObjC currently gives them 6 bits on all architectures.<br>&gt; <br>&gt; To clarify: Analysis tools like `heap` and `leaks` need to distinguish real objects from other heap allocations. The false positive rate is tolerable if the isa field is a raw pointer. (As long as some other code like libobjc itself deliberately disguises some of its own data structures that would otherwise look like false positives.)<br>&gt; <br>&gt; Non-pointer isa greatly increases the false positive rate. There is too much non-object data that happens to match some real class pointer when only the class bits can be examined. Adding some constant non-zero bits brings it back down again. <br></p><p>The tools team is probably going to hate us as soon as we start using non-zero address points for objects too. We might need a different approach for Swift to reliably recognize our heap object allocations.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160118/9370527f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Shrinking the heap object header</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 4:21 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 15, 2016, at 10:58 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift heap object headers are fairly large—16 bytes on 64-bit, and 12 bytes on 32-bit. Into this space we pack:<br>&gt;&gt; <br>&gt;&gt; - the &#39;isa&#39; pointer for the object, pointing to its heap metadata/class object,<br>&gt;&gt; - the strong and unowned reference counts,<br>&gt;&gt; - &#39;pinned&#39; and &#39;deallocating&#39; flags.<br>&gt;&gt; <br>&gt;&gt; We&#39;ve also discussed taking a flag bit for &#39;not refcounted&#39; objects, such as statically-allocated globals and/or stack promotions that need to be ABI compatible with heap objects, and potentially one for thread-local objects, to avoid barriers when refcounting objects we dynamically know are not referenced from multiple threads. We should consider whether we can reduce the header size. Two ideas come to mind:<br>&gt;&gt; <br>&gt;&gt; Dropping the unowned reference count<br>&gt;&gt; <br>&gt;&gt; If we adopt a sufficiently fast implementation for normal weak references, such as the activity count implementation suggested by Kevin and Mike, the unowned reference count might not be worth the expense. If we dropped it, that would be enough to bring the 32-bit object header down to 8 bytes. The tradeoff would be that unowned references become fatter, like weak references would, which might complicate our plans to eventually allow unowned to transparently become unowned(unsafe) in unchecked builds.<br>&gt;&gt; <br>&gt;&gt; Non-pointer isa for 64-bit platforms<br>&gt;&gt; <br>&gt;&gt; Neither x86-64 nor ARM64 populates the full 64 bits of address space—contemporary x86-64 uses only 48 bits (sign-extended, so effectively 47 bits for userspace), and Apple ARM64 platforms use fewer bits, the exact number dependent on OS version. If we were willing to drop the unowned refcount, and say that &quot;64Ki-retains ought to be enough for anyone&quot;, overflowing the retain count into the &quot;not refcounted&quot; bit to leak overly-retained objects, <br>&gt; <br>&gt; 64K retains is not enough for everybody. NSParagraphStyle had a 19-bit inline retain count with no overflow protection (i.e. it incorrectly deallocated if you retained it too much and then called some releases). This occasionally crashed in Xcode (rdar://16008112 &lt;rdar://16008112&gt;).<br>&gt; <br>&gt; <br>&gt;&gt; we could use a layout similar to this to pack the remaining information into 8 bytes:<br>&gt;&gt; <br>&gt;&gt; bits   meaning<br>&gt;&gt; -----  -------<br>&gt;&gt; 63     not refcounted<br>&gt;&gt; 47…62  strong refcount<br>&gt;&gt; 03…46  metadata pointer<br>&gt;&gt; 02     (reserved)<br>&gt;&gt; 01     deallocating<br>&gt;&gt; 00     pinned<br>&gt; <br>&gt; What is the difference between &quot;pinned&quot; and &quot;not refcounted&quot; ? I would expect that you only need one bit to mark objects that are constant or whose refcount has overflowed.<br></p><p>&quot;Pinned&quot; is used by copy-on-write buffers to say &quot;mutation is allowed, even if this isn&#39;t uniquely referenced&quot;, for situations like parallel array slices mutating different parts of the same array.<br></p><p>&gt; <br>&gt; Note that the memory analysis folks really want a few bits reserved with a constant value. That improves their reliability when distinguishing real objects from non-object memory that happens to have an isa-like field in front. ObjC currently gives them 6 bits on all architectures.<br>&gt; <br>&gt; <br>&gt;&gt; There are of course some costs and complications. For classes, we look up vtable entries and resilient ivar offsets through the isa pointer, and masking the isa costs an extra instruction per object, though that can at least be shared for multiple method calls on the same object since we assume objects don&#39;t change class (at least not in ways that would change Swift method implementation or ivar layout). We do already pay this cost on Apple platforms for NSObject subclasses. More interestingly, Objective-C already uses non-pointer isa on ARM64, but not on x86-64.<br>&gt; <br>&gt; Objective-C now uses non-pointer isa on x86_64 (as of OS X 10.11 iirc).<br>&gt; <br>&gt; <br>&gt;&gt; I&#39;m not sure how flexible the ObjC implementation is here—Could Swift use non-pointer isas on platforms where ObjC doesn&#39;t? Could it ascribe different meanings to the bits from ObjC&#39;s?<br>&gt; <br>&gt; For backwards deployment, no. libobjc currently assumes that every isa field is either a raw class pointer or libobjc&#39;s packed representation. <br>&gt; <br>&gt; With libobjc&#39;s cooperation, maybe. You would almost certainly need everybody to use the same mask value. If the other bits mean different things in Swift vs ObjC then you would also need to use a bit to distinguish the representations.<br>&gt; <br>&gt; <br>&gt; How does the object header size interact with resilience? If we squeeze into an 8-byte header and then regret it later, will we have any recourse?<br></p><p>It&#39;s unlikely we&#39;d be able to grow the header size after committing to an ABI, since we&#39;ll want to be able to hardcode offsets into closure contexts and root classes. If we&#39;re not confident we can fit everything we want in 8 bytes, we shouldn&#39;t try to.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/cea5c20a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
