<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>POSIX, Foundation, and layering</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>May 12, 2016 at 08:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>We have started taking some commits to swift-package-manager to incorporate Foundation. The original idea was that we would try and move a lot of our support facilities onto Foundation (https://bugs.swift.org/browse/SR-1005).<br></p><p>However, we have hit a couple issues that have made me want to take a different route:<br>1. In some cases, our needs (solved by existing code in the POSIX or Utilities modules) don&#39;t cleanly match the API Foundation provides. For example, we used the ability to pass arbitrary file descriptors to a subprocess in one place (see https://github.com/apple/swift-package-manager/pull/303) which is trivial with `posix_spawn` but difficult with `NSTask`.<br>2. In another case, we had to go to substantial effort to workaround the cross-platform bridging of Foundation. See https://github.com/apple/swift-package-manager/pull/333.<br></p><p>Based on this, I am proposing the following direction:<br></p><p>1. We keep our POSIX module. The intent of this module should be to provide &quot;Swifty&quot; APIs to access portable, POSIX facilities. &quot;Swifty&quot; here does not mean completely changing the API to work more conveniently, it just means translating the raw POSIX API into something which is easy to call from Swift and handles errors in a &quot;native&quot; fashion. Almost all APIs in this module should match the underlying POSIX name, and `man &lt;name&gt;` should describe the semantics even if the API is called differently. This module should only depend on `libc` and hopefully one day something like this module can be part of the standard library.<br></p><p>2. We always use `Foundation` when its APIs are the right tool for the job, but if not (because our behavior is in some places fairly low-level, with a neat mapping to POSIX) then we continue to build on the POSIX module. We shouldn&#39;t re-implement any significant system provided behavior, we should only be choosing between using a `POSIX` or a `Foundation` API for a task. If the `Foundation` API exists, but isn&#39;t implemented yet, then we should work to implement that API in `swift-corelibs-foundation`.<br></p><p>3. We introduce/rename a new `Basic` module out of `Utility`. This matches a convention used in Clang, Swift, and llbuild for the &quot;base support module&quot;. This module will define the &quot;convenient&quot; APIs for system services, shared ADTs, etc. and will sit on top of `libc`, `POSIX`, and `Foundation`. We should try to limit cross-platform adaption code to this layer -- if we need a `Foundation` API, but it is not yet implemented in such a way that use of that API is *syntactically* cross-platform (e.g., it needs different bridging behavior) then we should provide an abstraction in `Basic` that hides that divergence. The goal here is that any code above `Basic` can be written without fear of cross-platform incompatibility (which is a serious burden on developer productivity).<br></p><p>4. We should incrementally audit our existing API usage to fit into this conceptual model.<br></p><p>Thoughts?<br></p><p> - Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>POSIX, Foundation, and layering</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>May 12, 2016 at 09:00:00pm</p></header><div class="content"><p>3. We introduce/rename a new `Basic` module out of `Utility`. This matches<br>&gt; a convention used in Clang, Swift, and llbuild for the &quot;base support<br>&gt; module&quot;. This module will define the &quot;convenient&quot; APIs for system services,<br>&gt; shared ADTs, etc. and will sit on top of `libc`, `POSIX`, and `Foundation`.<br>&gt; We should try to limit cross-platform adaption code to this layer -- if we<br>&gt; need a `Foundation` API, but it is not yet implemented in such a way that<br>&gt; use of that API is *syntactically* cross-platform (e.g., it needs different<br>&gt; bridging behavior) then we should provide an abstraction in `Basic` that<br>&gt; hides that divergence. The goal here is that any code above `Basic` can be<br>&gt; written without fear of cross-platform incompatibility (which is a serious<br>&gt; burden on developer productivity).<br>&gt;<br></p><p>I agree with all the points. Do you think its better to create new module<br>Basic off of Utility or just rename Utility to Basic? I think it might get<br>confusing to decide where something goes if there are two such modules.<br>Though if definition of Basic is to provide cross-platform I&#39;d imagine<br>Utility contains things like handy extensions to stdlib types and Basic<br>also depends on Utility.<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160512/d6c8b5d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>POSIX, Foundation, and layering</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>May 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 9:15 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 3. We introduce/rename a new `Basic` module out of `Utility`. This matches a convention used in Clang, Swift, and llbuild for the &quot;base support module&quot;. This module will define the &quot;convenient&quot; APIs for system services, shared ADTs, etc. and will sit on top of `libc`, `POSIX`, and `Foundation`. We should try to limit cross-platform adaption code to this layer -- if we need a `Foundation` API, but it is not yet implemented in such a way that use of that API is *syntactically* cross-platform (e.g., it needs different bridging behavior) then we should provide an abstraction in `Basic` that hides that divergence. The goal here is that any code above `Basic` can be written without fear of cross-platform incompatibility (which is a serious burden on developer productivity).<br>&gt; <br>&gt; I agree with all the points. Do you think its better to create new module Basic off of Utility or just rename Utility to Basic? I think it might get confusing to decide where something goes if there are two such modules. Though if definition of Basic is to provide cross-platform I&#39;d imagine Utility contains things like handy extensions to stdlib types and Basic also depends on Utility.<br></p><p>We should basically rename Utility to Basic. How we do that rename is an open question... my inclination is to move each API individually to the &quot;right&quot; place until Utility is empty, then delete it. As part of moving each API we should decide where the right home for it is (POSIX, Basic, or other as-yet-to-be-defined modules).<br></p><p> - Daniel<br></p><p>&gt;  <br>&gt; -- <br>&gt; Ankit<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160512/20fa3357/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
