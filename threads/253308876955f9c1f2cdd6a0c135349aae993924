<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ed9a0d8cd44b62539b141f6c10405db1?s=50"></div><header><strong>LazyFilterCollection is not a Collection</strong> from <string>Rob Napier</string> &lt;robnapier at gmail.com&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>(Continuing a discussion from<br>https://twitter.com/cocoaphony/status/729712476451971073.)<br></p><p>The current recommendation for converting from lazy to strict is with an<br>Array constructor:<br></p><p>    Array(xs.lazy.&lt;chain&gt;)<br></p><p>Because the Array constructor accesses count and then iterates over the<br>sequence, this generally means that the entire chain is evaluated twice.<br>This is a surprising result. See<br>https://gist.github.com/yas375/69d8643ff7d98b137cc2f8201c3e58fc for an<br>example.<br></p><p>While it is reasonable to argue that a map/filter chain should be pure, it<br>is much more surprising to require that it be cheap (a common use for lazy<br>is to avoid calling expensive operations that might not be needed). This<br>can be a particular issue if network fetches (even idempotent ones) are<br>included in the chain.<br></p><p>As Joe Groff notes, this is fixable with Array(AnySequence(xs.lazy....)),<br>but that is very undiscoverable and dependent on knowing the implementation<br>details of Array.init.<br></p><p>I believe the root cause of this is that LazyFilterCollection is not a<br>proper Collection. It violates the performance requirements.<br>CollectionType.count requires O(1) access if Index is a<br>RandomAccessIndexType. LazyFilterCollection.count is always at least O(N).<br>LFC also breaks several other O(1) performance requirements (endIndex for<br>instance). This breaks the performance promises of anything that operates<br>on a generic collection and receives an LFC. The problem here isn&#39;t<br>Array.init. It&#39;s doing everything right. The problem is that LFC doesn&#39;t<br>uphold its side of the bargain.<br></p><p>There are many ways and reasons that lazy filter chains are constructed. I<br>don&#39;t think there&#39;s any way for the stdlib to guess the best performance<br>trade-off for all of them, and optimizing for one breaks others. Given<br>that, I think it should stick to the documented performance promises. Since<br>LazyFilterCollection cannot meet the requirements of a Collection (even in<br>simple cases), a lazy filter must return a LazySequence. This breaks<br>pre-allocation optimizations, but allows reasoning about the performance in<br>ways that is not currently possible. We should keep our promises.<br></p><p>While not beautiful, it is possible to recover pre-allocation optimization<br>in a generic way by adding an initialCapacity option to<br>Array.init&lt;SequenceType&gt;. This would allow the caller to provide the best<br>initial allocation in cases where that is externally known, or worth an<br>explicit counting.<br></p><p>-Rob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160509/25333924/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>LazyFilterCollection is not a Collection</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  9, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mon, May 9, 2016 at 11:46 AM, Rob Napier &lt;robnapier at gmail.com&gt; wrote:<br>&gt; It violates the performance requirements.<br>&gt; CollectionType.count requires O(1) access if Index is a<br>&gt; RandomAccessIndexType.<br></p><p>Hi Rob,<br></p><p>We don&#39;t have RandomAccessIndexType anymore.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ed9a0d8cd44b62539b141f6c10405db1?s=50"></div><header><strong>LazyFilterCollection is not a Collection</strong> from <string>Rob Napier</string> &lt;robnapier at gmail.com&gt;<p>May 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, May 9, 2016 at 4:16 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Mon, May 9, 2016 at 11:46 AM, Rob Napier &lt;robnapier at gmail.com&gt; wrote:<br>&gt; &gt; It violates the performance requirements.<br>&gt; &gt; CollectionType.count requires O(1) access if Index is a<br>&gt; &gt; RandomAccessIndexType.<br>&gt;<br>&gt; Hi Rob,<br>&gt;<br>&gt; We don&#39;t have RandomAccessIndexType anymore.<br>&gt;<br>&gt;<br>I don&#39;t understand how this addresses any of the original points.<br>LazyFilterIndex explicitly notes that it breaks the performance promises of<br>its protocol:<br></p><p>NOTE<br>&gt; The performance of advancing a LazyFilterIndex depends on how sparsely<br>&gt; the filtering predicate is satisfied, and may not offer the usual<br>&gt; performance given by models of ForwardIndexType.<br></p><p><br>And also LazyFilterCollection:<br></p><p>NOTE<br>&gt; The performance of advancing a LazyFilterIndex depends on how sparsely<br>&gt; the filtering predicate is satisfied, and may not offer the usual<br>&gt; performance given by models of ForwardIndexType. Be aware, therefore,<br>&gt; that general operations on LazyFilterCollection instances may not have<br>&gt; the documented complexity.<br></p><p><br></p><p>I believe there should be a very high performance bar before breaking a<br>protocol&#39;s promises. The fact that filter predicates must be both pure and<br>very fast is not obvious, and this can have a cascading effect of calling<br>filters an ever-increasing number of times. For example:<br></p><p>var c1 = 0<br></p><p>var c2 = 0<br></p><p>var c3 = 0<br></p><p><br>let xs = Array(1...1000).lazy<br></p><p>    .filter { _ in c1 += 1; return true }<br></p><p>    .filter { _ in c2 += 1; return true }<br></p><p>    .filter { _ in c3 += 1; return true }<br></p><p><br>_ = Array(xs)<br></p><p>print(c1, c2, c3, c1+c2+c3) // *7986 3996 2000 13982*<br></p><p>I don&#39;t think the caller would expect that these filters would be called a<br>total of 14k times (rather than 3k).<br></p><p>This is rough, and I just tossed in Xcode and hit &quot;Test&quot; (so it&#39;s very<br>possible that there&#39;s a mistake here due to oversimplifying), but I was<br>unable to find any combination of count or number of filters (including one<br>filter and up to 1M element arrays) where the current stdlib is faster than<br>the sequence version:<br></p><p>extension LazySequenceType {<br></p><p>    @warn_unused_result<br></p><p>    public func seqFilter(<br></p><p>        predicate: (Elements.Generator.Element) -&gt; Bool<br></p><p>        ) -&gt; LazyFilterSequence&lt;Elements&gt; {<br></p><p>        return LazyFilterSequence(<br></p><p>            self.elements, whereElementsSatisfy: predicate)<br></p><p>    }<br></p><p>}<br></p><p><br>class testperfTests: XCTestCase {<br></p><p>    func testPerformanceSeq() {<br></p><p>        self.measureBlock {<br></p><p>            let xs = Array(1...1000).lazy<br></p><p>                .seqFilter { _ in true }<br></p><p>                .seqFilter { _ in true }<br></p><p>                .seqFilter { _ in true }<br></p><p><br></p><p>            _ = Array(xs)<br></p><p>        }<br></p><p>    }<br></p><p><br>    func testPerformanceCollection() {<br></p><p>        self.measureBlock {<br></p><p>            let xs = Array(1...1000).lazy<br></p><p>                .filter { _ in true }<br></p><p>                .filter { _ in true }<br></p><p>                .filter { _ in true }<br></p><p><br>            _ = Array(xs)<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p>seqFilter was reliably over an order of magnitude faster than filter.  I<br>tested this with various filters (to demonstrate actually removing some<br>elements), on Mac and iOS, with between 1 and 3 filters, and with sizes<br>between 1000 and 1M. The non-collection was always faster in my tests.<br></p><p>I don&#39;t see this as a performance slam dunk that justifies breaking the<br>performance promises of CollectionType. Is there more to the story that I&#39;m<br>missing?<br></p><p>-Rob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160511/1ee1f8b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>LazyFilterCollection is not a Collection</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Naively (and thinking about how this works on other platforms), I would expect Array(lazyFilterSequence) to iterate only once and take the hit of reallocation.<br></p><p><br>Russ<br></p><p><br>&gt; On May 11, 2016, at 2:46 PM, Rob Napier via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Mon, May 9, 2016 at 4:16 PM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt; On Mon, May 9, 2016 at 11:46 AM, Rob Napier &lt;robnapier at gmail.com &lt;mailto:robnapier at gmail.com&gt;&gt; wrote:<br>&gt; &gt; It violates the performance requirements.<br>&gt; &gt; CollectionType.count requires O(1) access if Index is a<br>&gt; &gt; RandomAccessIndexType.<br>&gt; <br>&gt; Hi Rob,<br>&gt; <br>&gt; We don&#39;t have RandomAccessIndexType anymore.<br>&gt; <br>&gt; <br>&gt; I don&#39;t understand how this addresses any of the original points. LazyFilterIndex explicitly notes that it breaks the performance promises of its protocol:<br>&gt; <br>&gt; NOTE<br>&gt; The performance of advancing a LazyFilterIndex depends on how sparsely the filtering predicate is satisfied, and may not offer the usual performance given by models of ForwardIndexType. <br>&gt; <br>&gt; And also LazyFilterCollection:<br>&gt; <br>&gt; NOTE<br>&gt; The performance of advancing a LazyFilterIndex depends on how sparsely the filtering predicate is satisfied, and may not offer the usual performance given by models of ForwardIndexType. Be aware, therefore, that general operations on LazyFilterCollection instances may not have the documented complexity.<br>&gt; <br>&gt; <br>&gt; I believe there should be a very high performance bar before breaking a protocol&#39;s promises. The fact that filter predicates must be both pure and very fast is not obvious, and this can have a cascading effect of calling filters an ever-increasing number of times. For example:<br>&gt; <br>&gt; var c1 = 0<br>&gt; var c2 = 0<br>&gt; var c3 = 0<br>&gt; <br>&gt; let xs = Array(1...1000).lazy<br>&gt;     .filter { _ in c1 += 1; return true }<br>&gt;     .filter { _ in c2 += 1; return true }<br>&gt;     .filter { _ in c3 += 1; return true }<br>&gt; <br>&gt; _ = Array(xs)<br>&gt; print(c1, c2, c3, c1+c2+c3) // 7986 3996 2000 13982<br>&gt; <br>&gt; I don&#39;t think the caller would expect that these filters would be called a total of 14k times (rather than 3k).<br>&gt; <br>&gt; This is rough, and I just tossed in Xcode and hit &quot;Test&quot; (so it&#39;s very possible that there&#39;s a mistake here due to oversimplifying), but I was unable to find any combination of count or number of filters (including one filter and up to 1M element arrays) where the current stdlib is faster than the sequence version:<br>&gt; <br>&gt; extension LazySequenceType {<br>&gt;     @warn_unused_result<br>&gt;     public func seqFilter(<br>&gt;         predicate: (Elements.Generator.Element) -&gt; Bool<br>&gt;         ) -&gt; LazyFilterSequence&lt;Elements&gt; {<br>&gt;         return LazyFilterSequence(<br>&gt;             self.elements, whereElementsSatisfy: predicate)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class testperfTests: XCTestCase {<br>&gt;     func testPerformanceSeq() {<br>&gt;         self.measureBlock {<br>&gt;             let xs = Array(1...1000).lazy<br>&gt;                 .seqFilter { _ in true }<br>&gt;                 .seqFilter { _ in true }<br>&gt;                 .seqFilter { _ in true }<br>&gt;             <br>&gt;             _ = Array(xs)<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func testPerformanceCollection() {<br>&gt;         self.measureBlock {<br>&gt;             let xs = Array(1...1000).lazy<br>&gt;                 .filter { _ in true }<br>&gt;                 .filter { _ in true }<br>&gt;                 .filter { _ in true }<br>&gt; <br>&gt;             _ = Array(xs)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; seqFilter was reliably over an order of magnitude faster than filter.  I tested this with various filters (to demonstrate actually removing some elements), on Mac and iOS, with between 1 and 3 filters, and with sizes between 1000 and 1M. The non-collection was always faster in my tests.<br>&gt; <br>&gt; I don&#39;t see this as a performance slam dunk that justifies breaking the performance promises of CollectionType. Is there more to the story that I&#39;m missing?<br>&gt; <br>&gt; -Rob<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160511/863065c2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
