<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/573eb50ca23ada15b5761d0dd17ace3b?s=50"></div><header><strong>Factory initializers</strong> from <string>Claus Ruete</string> &lt;clausruete at icloud.com&gt;<p>January 19, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi!<br></p><p>I hope this is the right mailing list for this: I want to make a proposal for the swift language. This is not in the commonly rejected changes and i also haven&#39;t found it anywhere else, so hopefully I am doing this right.<br></p><p>What I would like to see in swift is a better way of implementing &quot;factory methods&quot; that return an instance of a class, but unlike normal initializers, may return an instance of a subclass instead of just the class itself.<br></p><p>Let me explain one important use case why i think this would be a good idea. Imagine we define a protocol requiring an initializer like this:<br></p><p>protocol StringLoadable {<br>Â Â Â init(string: String)<br>}<br></p><p>And then we want a class &quot;Car&quot;, that has a subclass &quot;BigCar&quot;, to conform to this protocol.<br></p><p>class Car: StringLoadable {<br>Â Â Â required convenience init(string: String) {<br>Â Â Â Â Â Â if string.characters.count &lt; 10 {<br>Â Â Â Â Â Â Â Â Â self.init()<br>Â Â Â Â Â Â }<br>Â Â Â Â Â Â else {<br>Â Â Â Â Â Â Â Â Â let bigCar = BigCar()<br></p><p>Â Â Â Â Â Â Â Â Â //... oops, how do i return this now?<br>Â Â Â Â Â Â }<br>Â Â Â }<br>}<br></p><p>class BigCar: Car {<br>Â Â Â //...<br>}<br></p><p>So the Car should be a BigCar in case the string contains 10 characters or more. Now the only way i could see this possibly work is to use a static fun instead of an initializer:<br></p><p>class Car: StringLoadable {<br>Â Â Â static func loadFromString(string: String) -&gt; Car {<br>Â Â Â Â Â Â if string.characters.count &lt; 10 {<br>Â Â Â Â Â Â Â Â Â return Car()<br>Â Â Â Â Â Â }<br>Â Â Â Â Â Â else {<br>Â Â Â Â Â Â Â Â Â return BigCar()<br>Â Â Â Â Â Â }<br>Â Â Â }<br>}<br></p><p>This works, but only until we try to have this as a protocol requirement:<br></p><p>protocol StringLoadable {<br>Â Â Â static func loadFromString(string: String) -&gt; Self<br>}<br></p><p>While i already dislike that the whole protocol (and thus, the API) have to change just because of an implementation detail in one class, the even bigger problem is that for non-final classes, it is impossible to implement this required static function: Having it return &quot;Car&quot; does not satisfy the protocol, because we end up in a situation where BigCar.loadFromString(_:) returns a Car instead of a BigCar.<br></p><p>Factory initializers would fix this problem:<br></p><p>protocol StringLoadable {<br>Â Â Â init(string: String)<br>}<br></p><p>class Car: StringLoadable {<br>Â Â Â required factory init(string: String) {<br>Â Â Â Â Â Â if string.characters.count &lt; 10 {<br>Â Â Â Â Â Â Â Â Â return Car()<br>Â Â Â Â Â Â }<br>Â Â Â Â Â Â else {<br>Â Â Â Â Â Â Â Â Â return BigCar(string: string)<br>Â Â Â Â Â Â }<br>Â Â Â }<br></p><p>Â Â Â init() { }<br>}<br></p><p>class BigCar: Car {<br>Â Â Â required factory init(string: String) {<br>Â Â Â Â Â Â return BigCar()<br>Â Â Â }<br></p><p>Â Â Â init() { }<br>}<br></p><p>In this case, the factory init is marked as &quot;required&quot; for protocol conformance, but in other use cases it doesn&#39;t have to be required. A factory init would act mostly like a convenience init, with the exception of being able to initialize a subclass or load an object from somewhere else, for example a cache or something like that.<br></p><p>A factory initializer would never allocate any memory itself, that work happens in the actual designated initializer. Also, like a convenience initializer, a class cannot only have a factory initializer, but needs at least one designated initializer. Because of this, factory initializers would not cause any problems in terms of being able to access uninitialized properties or something like that.<br></p><p>I hope you agree that factory initializers would be a good addition to swift. As shown in the example, they allow things to be implemented that weren&#39;t before, and they don&#39;t cause any problems with type safety or any other Swift concepts.<br></p><p>Here are some more ideas on factory initializers:<br></p><p>We could have factory initializers in protocol extensions: In some cases, this would allow to completely hide the actual implementations of that protocol â€“ by being able to &quot;construct&quot; a protocol.<br></p><p>In terms of the syntax, instead of using a &quot;return&quot; pattern, the &quot;assign to self&quot; pattern, as known from enum initializers, could be used, but i think using self in a factory initializer could cause confusion (The compiler would have to prevent &quot;self&quot; from being used before it was assigned a value), so i prefer the &quot;return&quot; pattern with no access to &quot;self&quot; at all.<br></p><p>Thank you all for reading! ðŸ˜Š<br></p><p>C.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/144e0cba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Factory initializers</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 20, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Claus,<br></p><p>It looks like you&#39;ve put a lot of thought and consideration into how this<br>could fit into Swift :)<br></p><p>There was early proposals for class clusters that turned into a discussion<br>on factory initialisers. You&#39;ll probably find a lot of shared goals and<br>ideas here:<br></p><p>http://comments.gmane.org/gmane.comp.lang.swift.evolution/17<br></p><p><br>It would be great once you&#39;ve read through that thread to contribute your<br>ideas to it!<br></p><p>Andrew<br></p><p><br>On Wed, Jan 20, 2016 at 4:47 AM, Claus Ruete via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi!<br>&gt;<br>&gt; I hope this is the right mailing list for this: I want to make a proposal<br>&gt; for the swift language. This is not in the commonly rejected changes and i<br>&gt; also haven&#39;t found it anywhere else, so hopefully I am doing this right.<br>&gt;<br>&gt; What I would like to see in swift is a better way of implementing &quot;factory<br>&gt; methods&quot; that return an instance of a class, but unlike normal<br>&gt; initializers, may return an instance of a subclass instead of just the<br>&gt; class itself.<br>&gt;<br>&gt; Let me explain one important use case why i think this would be a good<br>&gt; idea. Imagine we define a protocol requiring an initializer like this:<br>&gt;<br>&gt; protocol StringLoadable {<br>&gt;    init(string: String)<br>&gt; }<br>&gt;<br>&gt; And then we want a class &quot;Car&quot;, that has a subclass &quot;BigCar&quot;, to conform<br>&gt; to this protocol.<br>&gt;<br>&gt; class Car: StringLoadable {<br>&gt;    required convenience init(string: String) {<br>&gt;       if string.characters.count &lt; 10 {<br>&gt;          self.init()<br>&gt;       }<br>&gt;       else {<br>&gt;          let bigCar = BigCar()<br>&gt;<br>&gt;          //... oops, how do i return this now?<br>&gt;       }<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; class BigCar: Car {<br>&gt;    //...<br>&gt; }<br>&gt;<br>&gt; So the Car should be a BigCar in case the string contains 10 characters or<br>&gt; more. Now the only way i could see this possibly work is to use a static<br>&gt; fun instead of an initializer:<br>&gt;<br>&gt; class Car: StringLoadable {<br>&gt;    static func loadFromString(string: String) -&gt; Car {<br>&gt;       if string.characters.count &lt; 10 {<br>&gt;          return Car()<br>&gt;       }<br>&gt;       else {<br>&gt;          return BigCar()<br>&gt;       }<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; This works, but only until we try to have this as a protocol requirement:<br>&gt;<br>&gt; protocol StringLoadable {<br>&gt;    static func loadFromString(string: String) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; While i already dislike that the whole protocol (and thus, the API) have<br>&gt; to change just because of an implementation detail in one class, the even<br>&gt; bigger problem is that for non-final classes, it is impossible to implement<br>&gt; this required static function: Having it return &quot;Car&quot; does not satisfy the<br>&gt; protocol, because we end up in a situation where BigCar.loadFromString(_:)<br>&gt; returns a Car instead of a BigCar.<br>&gt;<br>&gt; Factory initializers would fix this problem:<br>&gt;<br>&gt; protocol StringLoadable {<br>&gt;    init(string: String)<br>&gt; }<br>&gt;<br>&gt; class Car: StringLoadable {<br>&gt;    required *factory* init(string: String) {<br>&gt;       if string.characters.count &lt; 10 {<br>&gt;          return Car()<br>&gt;       }<br>&gt;       else {<br>&gt;          return BigCar(string: string)<br>&gt;       }<br>&gt;    }<br>&gt;<br>&gt;    init() { }<br>&gt; }<br>&gt;<br>&gt; class BigCar: Car {<br>&gt;    required *factory* init(string: String) {<br>&gt;       return BigCar()<br>&gt;    }<br>&gt;<br>&gt;    init() { }<br>&gt; }<br>&gt;<br>&gt; In this case, the factory init is marked as &quot;required&quot; for protocol<br>&gt; conformance, but in other use cases it doesn&#39;t have to be required. A<br>&gt; factory init would act mostly like a convenience init, with the exception<br>&gt; of being able to initialize a subclass or load an object from somewhere<br>&gt; else, for example a cache or something like that.<br>&gt;<br>&gt; A factory initializer would never allocate any memory itself, that work<br>&gt; happens in the actual designated initializer. Also, like a convenience<br>&gt; initializer, a class cannot only have a factory initializer, but needs at<br>&gt; least one designated initializer. Because of this, factory initializers<br>&gt; would not cause any problems in terms of being able to access uninitialized<br>&gt; properties or something like that.<br>&gt;<br>&gt; I hope you agree that factory initializers would be a good addition to<br>&gt; swift. As shown in the example, they allow things to be implemented that<br>&gt; weren&#39;t before, and they don&#39;t cause any problems with type safety or any<br>&gt; other Swift concepts.<br>&gt;<br>&gt; Here are some more ideas on factory initializers:<br>&gt;<br>&gt; We could have factory initializers in protocol extensions: In some cases,<br>&gt; this would allow to completely hide the actual implementations of that<br>&gt; protocol â€“ by being able to &quot;construct&quot; a protocol.<br>&gt;<br>&gt; In terms of the syntax, instead of using a &quot;return&quot; pattern, the &quot;assign<br>&gt; to self&quot; pattern, as known from enum initializers, could be used, but i<br>&gt; think using self in a factory initializer could cause confusion (The<br>&gt; compiler would have to prevent &quot;self&quot; from being used before it was<br>&gt; assigned a value), so i prefer the &quot;return&quot; pattern with no access to<br>&gt; &quot;self&quot; at all.<br>&gt;<br>&gt; Thank you all for reading! ðŸ˜Š<br>&gt;<br>&gt; C.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/359b0cf1/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
