<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>on Thu Mar 24 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Mar 24, 2016 at 4:18 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Wed Mar 23 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; So, in other words, you&#39;d be satisfied with the following addition to<br>&gt;&gt;&gt; the standard library?<br>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; extension Range where Element: Strideable {<br>&gt;&gt;&gt;     func by(step: Element.Stride) -&gt; StrideTo&lt;Element&gt; {<br>&gt;&gt;&gt;         return startIndex.stride(to: endIndex, by: step)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /*<br>&gt;&gt;&gt; example of usage:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; for i in (1..&lt;10).by(2) {<br>&gt;&gt;&gt;     print(i)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; */<br>&gt;&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My current thinking is that:<br>&gt;&gt;<br>&gt;&gt; * `for x in 0.0..&lt;3.0 {}` should probably be an error, because 1.0 is<br>&gt;&gt;   not the obviously-right stride to use for non-integral numbers.  That<br>&gt;&gt;   would imply that floating types should not conform to Strideable,<br>&gt;&gt;   which raises the question of whether Strideable should be folded into<br>&gt;&gt;   the Integer protocol.<br>&gt;<br>&gt; Well, maybe I&#39;m missing something, but `for x in 0.0..&lt;3.0 { }`<br>&gt; doesn&#39;t work as it is, and it doesn&#39;t seem to have anything to do with<br>&gt; Strideable. Rather, HalfOpenInterval&lt;Double&gt; doesn&#39;t conform to<br>&gt; SequenceType. <br></p><p>True, but the plan is that:<br></p><p>* Interval is going away<br>* Range will only require that its Bound be Comparable<br>* Ranges with Strideable bounds will conform to Collection<br></p><p>(see the swift-3-indexing-model branch on GitHub)<br></p><p>&gt; I agree that `for x in 0.0..&lt;3.0 { }` should continue not working, but<br>&gt; maybe let&#39;s keep floating point types conforming to Strideable :)<br></p><p>Those two things are not compatible with the plan we&#39;re going to<br>propose, as described above.<br></p><p>&gt;&gt;<br>&gt;&gt; * `for x in (0.0..&lt;20.0).striding(by: 1.3) {}` should work without<br>&gt;&gt;   accumulating error<br>&gt;&gt;<br>&gt;<br>&gt; +1.<br>&gt;<br>&gt;&gt; * `for x in 0..&lt;3 {}` should work (obviously; that&#39;s the status quo)<br>&gt;&gt;<br>&gt;&gt; * `for x in (0..&lt;20).striding(by: 2)` should work<br>&gt;&gt;<br>&gt;&gt; I think this might also handle the concerns that<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0051-stride-semantics.md<br>&gt;&gt; was trying to address.<br>&gt;&gt;<br>&gt;&gt; If I thought extreme concision was important for this application, I&#39;d be<br>&gt;&gt; proposing something like<br>&gt;&gt;<br>&gt;&gt;   for x in 0.0..&lt;20.0//1.3 {}<br>&gt;&gt;<br>&gt;&gt; but personally, I don&#39;t, which is why I propose `.striding(by: x)`<br>&gt;&gt; rather than simply `.by(x)`, the latter being more open to<br>&gt;&gt; misinterpretation.<br>&gt;<br>&gt; Yeah, `.striding(by: x)` is pretty good.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Ah, I think the conceptual muddle arises in the plan then. Specifically,<br>I&#39;d argue that not all Ranges with Strideable bounds should conform to<br>Collection.<br></p><p>Conceptually, whether a type can be advanced by some distance (guaranteed<br>by Strideable) is orthogonal to whether a type has an obviously correct<br>increment when calling next() on its iterator. Thus, although *strides*<br>with Strideable bounds should obviously conform to Collection, Ranges that<br>conform to Collection should be constrained to types which imply that the<br>Range represents a countable set (as the mathematicians say) of numbers.<br></p><p>This distinction may come in handy for implementing strides that don&#39;t<br>accumulate error. Striding through a Range that represents a countable set<br>of elements shouldn&#39;t accumulate error and we can use what we already<br>have--i.e. increment the current value every iteration without inspecting<br>the value of the starting bound. Striding through a Range that represents<br>an uncountable set of elements definitely requires reckoning from the<br>starting bound every iteration.<br>On Fri, Mar 25, 2016 at 11:25 AM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Mar 24 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; On Thu, Mar 24, 2016 at 4:18 PM, Dave Abrahams via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Wed Mar 23 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; So, in other words, you&#39;d be satisfied with the following addition to<br>&gt; &gt;&gt;&gt; the standard library?<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt; extension Range where Element: Strideable {<br>&gt; &gt;&gt;&gt;     func by(step: Element.Stride) -&gt; StrideTo&lt;Element&gt; {<br>&gt; &gt;&gt;&gt;         return startIndex.stride(to: endIndex, by: step)<br>&gt; &gt;&gt;&gt;     }<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; /*<br>&gt; &gt;&gt;&gt; example of usage:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; for i in (1..&lt;10).by(2) {<br>&gt; &gt;&gt;&gt;     print(i)<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; */<br>&gt; &gt;&gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My current thinking is that:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; * `for x in 0.0..&lt;3.0 {}` should probably be an error, because 1.0 is<br>&gt; &gt;&gt;   not the obviously-right stride to use for non-integral numbers.  That<br>&gt; &gt;&gt;   would imply that floating types should not conform to Strideable,<br>&gt; &gt;&gt;   which raises the question of whether Strideable should be folded into<br>&gt; &gt;&gt;   the Integer protocol.<br>&gt; &gt;<br>&gt; &gt; Well, maybe I&#39;m missing something, but `for x in 0.0..&lt;3.0 { }`<br>&gt; &gt; doesn&#39;t work as it is, and it doesn&#39;t seem to have anything to do with<br>&gt; &gt; Strideable. Rather, HalfOpenInterval&lt;Double&gt; doesn&#39;t conform to<br>&gt; &gt; SequenceType.<br>&gt;<br>&gt; True, but the plan is that:<br>&gt;<br>&gt; * Interval is going away<br>&gt; * Range will only require that its Bound be Comparable<br>&gt; * Ranges with Strideable bounds will conform to Collection<br>&gt;<br>&gt; (see the swift-3-indexing-model branch on GitHub)<br>&gt;<br>&gt; &gt; I agree that `for x in 0.0..&lt;3.0 { }` should continue not working, but<br>&gt; &gt; maybe let&#39;s keep floating point types conforming to Strideable :)<br>&gt;<br>&gt; Those two things are not compatible with the plan we&#39;re going to<br>&gt; propose, as described above.<br>&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; * `for x in (0.0..&lt;20.0).striding(by: 1.3) {}` should work without<br>&gt; &gt;&gt;   accumulating error<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; +1.<br>&gt; &gt;<br>&gt; &gt;&gt; * `for x in 0..&lt;3 {}` should work (obviously; that&#39;s the status quo)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; * `for x in (0..&lt;20).striding(by: 2)` should work<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think this might also handle the concerns that<br>&gt; &gt;&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0051-stride-semantics.md<br>&gt; &gt;&gt; was trying to address.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If I thought extreme concision was important for this application, I&#39;d<br>&gt; be<br>&gt; &gt;&gt; proposing something like<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   for x in 0.0..&lt;20.0//1.3 {}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; but personally, I don&#39;t, which is why I propose `.striding(by: x)`<br>&gt; &gt;&gt; rather than simply `.by(x)`, the latter being more open to<br>&gt; &gt;&gt; misinterpretation.<br>&gt; &gt;<br>&gt; &gt; Yeah, `.striding(by: x)` is pretty good.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/085ccb57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 25, 2016 at 02:00:00pm</p></header><div class="content"><p>on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Ah, I think the conceptual muddle arises in the plan<br>&gt; then. Specifically, I&#39;d argue that not all Ranges with Strideable<br>&gt; bounds should conform to Collection.<br>&gt;<br>&gt; Conceptually, whether a type can be advanced by some distance<br>&gt; (guaranteed by Strideable) is orthogonal to whether a type has an<br>&gt; obviously correct increment when calling next() on its iterator. Thus,<br>&gt; although *strides* with Strideable bounds should obviously conform to<br>&gt; Collection, Ranges that conform to Collection should be constrained to<br>&gt; types which imply that the Range represents a countable set (as the<br>&gt; mathematicians say) of numbers.<br></p><p>I think any countable set should be OK, regardless of whether the<br>elements are numbers.  Ranges of UnsafePointers, for example, are<br>countable.<br></p><p>&gt; This distinction may come in handy for implementing strides that don&#39;t<br>&gt; accumulate error. Striding through a Range that represents a countable<br>&gt; set of elements shouldn&#39;t accumulate error and we can use what we<br>&gt; already have--i.e. increment the current value every iteration without<br>&gt; inspecting the value of the starting bound. Striding through a Range<br>&gt; that represents an uncountable set of elements definitely requires<br>&gt; reckoning from the starting bound every iteration.  <br></p><p>So, what does this Countable protocol look like?  It seems like it would<br>bring back the Index protocols that are otherwise obviated by this<br>plan... not a jolly prospect.<br></p><p>&gt; On Fri, Mar 25, 2016 at 11:25 AM Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Mar 24 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; On Thu, Mar 24, 2016 at 4:18 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Wed Mar 23 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; So, in other words, you&#39;d be satisfied with the following addition to<br>&gt;&gt; &gt;&gt;&gt; the standard library?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; ```<br>&gt;&gt; &gt;&gt;&gt; extension Range where Element: Strideable {<br>&gt;&gt; &gt;&gt;&gt;     func by(step: Element.Stride) -&gt; StrideTo&lt;Element&gt; {<br>&gt;&gt; &gt;&gt;&gt;         return startIndex.stride(to: endIndex, by: step)<br>&gt;&gt; &gt;&gt;&gt;     }<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; /*<br>&gt;&gt; &gt;&gt;&gt; example of usage:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; for i in (1..&lt;10).by(2) {<br>&gt;&gt; &gt;&gt;&gt;     print(i)<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; */<br>&gt;&gt; &gt;&gt;&gt; ```<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; My current thinking is that:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * `for x in 0.0..&lt;3.0 {}` should probably be an error, because 1.0 is<br>&gt;&gt; &gt;&gt;   not the obviously-right stride to use for non-integral numbers.  That<br>&gt;&gt; &gt;&gt;   would imply that floating types should not conform to Strideable,<br>&gt;&gt; &gt;&gt;   which raises the question of whether Strideable should be folded into<br>&gt;&gt; &gt;&gt;   the Integer protocol.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, maybe I&#39;m missing something, but `for x in 0.0..&lt;3.0 { }`<br>&gt;&gt; &gt; doesn&#39;t work as it is, and it doesn&#39;t seem to have anything to do with<br>&gt;&gt; &gt; Strideable. Rather, HalfOpenInterval&lt;Double&gt; doesn&#39;t conform to<br>&gt;&gt; &gt; SequenceType.<br>&gt;&gt;<br>&gt;&gt; True, but the plan is that:<br>&gt;&gt;<br>&gt;&gt; * Interval is going away<br>&gt;&gt; * Range will only require that its Bound be Comparable<br>&gt;&gt; * Ranges with Strideable bounds will conform to Collection<br>&gt;&gt;<br>&gt;&gt; (see the swift-3-indexing-model branch on GitHub)<br>&gt;&gt;<br>&gt;&gt; &gt; I agree that `for x in 0.0..&lt;3.0 { }` should continue not working, but<br>&gt;&gt; &gt; maybe let&#39;s keep floating point types conforming to Strideable :)<br>&gt;&gt;<br>&gt;&gt; Those two things are not compatible with the plan we&#39;re going to<br>&gt;&gt; propose, as described above.<br>&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * `for x in (0.0..&lt;20.0).striding(by: 1.3) {}` should work without<br>&gt;&gt; &gt;&gt;   accumulating error<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; +1.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; * `for x in 0..&lt;3 {}` should work (obviously; that&#39;s the status quo)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * `for x in (0..&lt;20).striding(by: 2)` should work<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think this might also handle the concerns that<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0051-stride-semantics.md<br>&gt;&gt; &gt;&gt; was trying to address.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If I thought extreme concision was important for this application, I&#39;d<br>&gt;&gt; be<br>&gt;&gt; &gt;&gt; proposing something like<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   for x in 0.0..&lt;20.0//1.3 {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; but personally, I don&#39;t, which is why I propose `.striding(by: x)`<br>&gt;&gt; &gt;&gt; rather than simply `.by(x)`, the latter being more open to<br>&gt;&gt; &gt;&gt; misinterpretation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yeah, `.striding(by: x)` is pretty good.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Good points!<br></p><p>-Thorsten <br></p><p>&gt; Am 25.03.2016 um 19:29 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Ah, I think the conceptual muddle arises in the plan then. Specifically, I&#39;d argue that not all Ranges with Strideable bounds should conform to Collection.<br>&gt; <br>&gt; Conceptually, whether a type can be advanced by some distance (guaranteed by Strideable) is orthogonal to whether a type has an obviously correct increment when calling next() on its iterator. Thus, although *strides* with Strideable bounds should obviously conform to Collection, Ranges that conform to Collection should be constrained to types which imply that the Range represents a countable set (as the mathematicians say) of numbers.<br>&gt; <br>&gt; This distinction may come in handy for implementing strides that don&#39;t accumulate error. Striding through a Range that represents a countable set of elements shouldn&#39;t accumulate error and we can use what we already have--i.e. increment the current value every iteration without inspecting the value of the starting bound. Striding through a Range that represents an uncountable set of elements definitely requires reckoning from the starting bound every iteration.<br>&gt;&gt; On Fri, Mar 25, 2016 at 11:25 AM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Thu Mar 24 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Thu, Mar 24, 2016 at 4:18 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Wed Mar 23 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; So, in other words, you&#39;d be satisfied with the following addition to<br>&gt;&gt; &gt;&gt;&gt; the standard library?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; ```<br>&gt;&gt; &gt;&gt;&gt; extension Range where Element: Strideable {<br>&gt;&gt; &gt;&gt;&gt;     func by(step: Element.Stride) -&gt; StrideTo&lt;Element&gt; {<br>&gt;&gt; &gt;&gt;&gt;         return startIndex.stride(to: endIndex, by: step)<br>&gt;&gt; &gt;&gt;&gt;     }<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; /*<br>&gt;&gt; &gt;&gt;&gt; example of usage:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; for i in (1..&lt;10).by(2) {<br>&gt;&gt; &gt;&gt;&gt;     print(i)<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; */<br>&gt;&gt; &gt;&gt;&gt; ```<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; My current thinking is that:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * `for x in 0.0..&lt;3.0 {}` should probably be an error, because 1.0 is<br>&gt;&gt; &gt;&gt;   not the obviously-right stride to use for non-integral numbers.  That<br>&gt;&gt; &gt;&gt;   would imply that floating types should not conform to Strideable,<br>&gt;&gt; &gt;&gt;   which raises the question of whether Strideable should be folded into<br>&gt;&gt; &gt;&gt;   the Integer protocol.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, maybe I&#39;m missing something, but `for x in 0.0..&lt;3.0 { }`<br>&gt;&gt; &gt; doesn&#39;t work as it is, and it doesn&#39;t seem to have anything to do with<br>&gt;&gt; &gt; Strideable. Rather, HalfOpenInterval&lt;Double&gt; doesn&#39;t conform to<br>&gt;&gt; &gt; SequenceType.<br>&gt;&gt; <br>&gt;&gt; True, but the plan is that:<br>&gt;&gt; <br>&gt;&gt; * Interval is going away<br>&gt;&gt; * Range will only require that its Bound be Comparable<br>&gt;&gt; * Ranges with Strideable bounds will conform to Collection<br>&gt;&gt; <br>&gt;&gt; (see the swift-3-indexing-model branch on GitHub)<br>&gt;&gt; <br>&gt;&gt; &gt; I agree that `for x in 0.0..&lt;3.0 { }` should continue not working, but<br>&gt;&gt; &gt; maybe let&#39;s keep floating point types conforming to Strideable :)<br>&gt;&gt; <br>&gt;&gt; Those two things are not compatible with the plan we&#39;re going to<br>&gt;&gt; propose, as described above.<br>&gt;&gt; <br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * `for x in (0.0..&lt;20.0).striding(by: 1.3) {}` should work without<br>&gt;&gt; &gt;&gt;   accumulating error<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; +1.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; * `for x in 0..&lt;3 {}` should work (obviously; that&#39;s the status quo)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * `for x in (0..&lt;20).striding(by: 2)` should work<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think this might also handle the concerns that<br>&gt;&gt; &gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0051-stride-semantics.md<br>&gt;&gt; &gt;&gt; was trying to address.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If I thought extreme concision was important for this application, I&#39;d be<br>&gt;&gt; &gt;&gt; proposing something like<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   for x in 0.0..&lt;20.0//1.3 {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; but personally, I don&#39;t, which is why I propose `.striding(by: x)`<br>&gt;&gt; &gt;&gt; rather than simply `.by(x)`, the latter being more open to<br>&gt;&gt; &gt;&gt; misinterpretation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yeah, `.striding(by: x)` is pretty good.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/2a9426f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
