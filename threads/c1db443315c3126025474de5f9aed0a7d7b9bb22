<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>April 20, 2016 at 01:00:00am</p></header><div class="content"><p>Maybe this has been addressed before on another topic, but why are minmax(), minIndex(), maxIndex() and minmaxIndices() functions rather than read-only properties? It seems like things would be much cleaner without the brackets, and it’s shorter to implement in some cases as you can back it with a stored property for caching. As functions, you&#39;d need to write separate getters.<br></p><p>e.g.<br></p><p>struct Blah&lt;T:Comparable&gt; : Collection<br>{<br>    var minIndex : Index?<br>    var maxIndex : Index?<br></p><p>    func insertElement(element: T)<br>    {<br>        // insert element<br>        // compare with elements at stored minIndex, maxIndex<br>        // update minIndex/maxIndex if necessary<br>    }<br>}<br></p><p>Also, I’d favour “bounds”, “boundaries” or “limits” over minmax. There are plenty of English words which better and more precisely describe what it provides.<br></p><p>Karl<br></p><p><br>&gt; Hello all,<br>&gt; <br>&gt; Attached is a draft of a proposal to expand the min and max sequence APIs to better handle collections and to support future sorted sequences/collections. The proposal is in a gist here&lt;https://gist.github.com/natecook1000/d51267a6cf9e9463b9387bced4c65b16&gt;and inlined below—would love to hear any comments or feedback before submitting the proposal.<br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt; Proposal: Expanded min/max algorithms<br>&gt; This proposal would expand on the min() and max() sequence methods to add methods that return the corresponding index for a collection, efficiently find the minimum and maximum elements or indices at the same time, and provide extension points for sorted collections to provide all these results more efficiently.<br>&gt; <br>&gt; Related Bugs: SR-889&lt;https://bugs.swift.org/browse/SR-889&gt;and SR-890&lt;https://bugs.swift.org/browse/SR-890&gt;<br>&gt; Motivation<br>&gt; The Sequence protocol currently offers min() and max() methods that return the minimum and maximum elements of a sequence or collection. Unfortunately, there are applications where these methods do not provide enough flexibility to be useful.<br>&gt; <br>&gt; First, if the user of a collection wants not just to get the minimum value but also to operate on it in some way (e.g., mutation or just accessing it multiple times), she would need the index of the minimum element. The current APIs don&#39;t support that, so she would need to write her own.<br>&gt; <br>&gt; Second, the writer of a sorted collection is currently unable to provide efficient responses to the min() and max() methods when used in a generic context, even though these should be O(1) operations. Just like Set can respond quickly to contains(_:) even in a generic context, so too should new sorted collections be able to optimize their responses.<br>&gt; <br>&gt; Finally, getting the minimum and maximum elements (or indices) of a collection or sequence currently requires calling both min() and max(). With two calls, every element is iterated and compared twice. When you need both results, finding both the minimum and the maximum at the same time is more efficient, requiring only a single pass and 25% fewer comparisons.<br>&gt; <br>&gt; Proposed solution<br>&gt; This proposal has three parts:<br>&gt; <br>&gt; Adding minIndex() and maxIndex() methods to Collection that return the index of the minimum and maximum elements, respectively.<br>&gt; <br>&gt; let numbers = [30, 40, 10, 20, 60, 50]<br>&gt; <br>&gt; if let i = numbers.minIndex() {<br>&gt; print(&quot;\(i): \(numbers[i])&quot;) // 2: 10<br>&gt; }<br>&gt; Adding minmax() and minmaxIndices() methods to Sequence and Collection, respectively, to calculate the values (or indices) of the minimum and maximum elements simultaneously.<br>&gt; <br>&gt; if let result = numbers.minmax() {<br>&gt; // result == (minimum: 10, maximum: 60)<br>&gt; // ...<br>&gt; }<br>&gt; if let i = numbers.minmaxIndices() {<br>&gt; // i == (minimum: 2, maximum: 4)<br>&gt; print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)<br>&gt; }<br>&gt; Adding customization points for sequences and collections that can offer more efficient results: _customMinComparableElement()/_customMaxComparableElement() for Sequence and _customIndexOfMinComparableElement()/_customIndexOfMaxComparableElement()for Collection.<br>&gt; <br>&gt; Detailed design<br>&gt; The following methods would be added to the visible public APIs of Sequence and Collection as default implementations.<br>&gt; <br>&gt; extension Sequence {<br>&gt; /// Returns the minimum and maximum values of `self`, using<br>&gt; /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>&gt; /// has no elements.<br>&gt; func minmax(@noescape isOrderedBefore isOrderedBefore:<br>&gt; (Iterator.Element, Iterator.Element) throws -&gt;Bool<br>&gt; ) rethrows -&gt;(min: Iterator.Element, max: Iterator.Element)?<br>&gt; }<br>&gt; <br>&gt; extension Sequence where Iterator.Element: Comparable {<br>&gt; /// Returns the minimum and maximum values of `self`, or `nil`<br>&gt; /// if the sequence has no elements.<br>&gt; func minmax() -&gt;(min: Iterator.Element, max: Iterator.Element)?<br>&gt; }<br>&gt; <br>&gt; extension Collection {<br>&gt; /// Returns the index of the minimum element of `self`, using<br>&gt; /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt; /// collection has no elements.<br>&gt; func minIndex(@noescape isOrderedBefore isOrderedBefore:<br>&gt; (Iterator.Element, Iterator.Element) throws -&gt;Bool<br>&gt; ) rethrows -&gt;Index?<br>&gt; <br>&gt; /// Returns the index of the maximum element of `self`, using<br>&gt; /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt; /// collection has no elements.<br>&gt; func maxIndex(@noescape isOrderedBefore isOrderedBefore:<br>&gt; (Iterator.Element, Iterator.Element) throws -&gt;Bool<br>&gt; ) rethrows -&gt;Index?<br>&gt; <br>&gt; /// Returns the indices of the minimum and maximum elements of `self`,<br>&gt; /// using `isOrderedBefore` to compare elements, or `nil` if the<br>&gt; /// collection has no elements.<br>&gt; func minmaxIndices(@noescape isOrderedBefore isOrderedBefore:<br>&gt; (Iterator.Element, Iterator.Element) throws -&gt;Bool<br>&gt; ) rethrows -&gt;(minIndex: Index, maxIndex: Index)?<br>&gt; }<br>&gt; <br>&gt; extension Collection where Iterator.Element: Comparable {<br>&gt; /// Returns the index of the minimum element of `self`, or `nil`<br>&gt; /// if the collection has no elements.<br>&gt; func minIndex() -&gt;Index?<br>&gt; <br>&gt; /// Returns the index of the maximum element of `self`, or `nil`<br>&gt; /// if the collection has no elements.<br>&gt; func maxIndex() -&gt;Index?<br>&gt; <br>&gt; /// Returns the indices of the minimum and maximum elements of `self`,<br>&gt; /// or `nil` if the collection has no elements.<br>&gt; func minmaxIndices() -&gt;(minIndex: Index, maxIndex: Index)?<br>&gt; }<br>&gt; The customization points would be added to Sequence and Collection as protocol requirements, along with default implementations that return nil. The existing min()and max() methods would be updated to call the corresponding methods before iterating over the entire sequence.<br>&gt; <br>&gt; protocol Sequence {<br>&gt; // ...<br>&gt; <br>&gt; /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>&gt; /// if the sequence has no elements. The uncustomized version returns<br>&gt; /// `nil`.<br>&gt; func _customMinComparableElement() -&gt;Iterator.Element??<br>&gt; <br>&gt; /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>&gt; /// if the sequence has no elements. The uncustomized version returns<br>&gt; /// `nil`.<br>&gt; func _customMaxComparableElement() -&gt;Iterator.Element??<br>&gt; }<br>&gt; <br>&gt; protocol Collection {<br>&gt; // ...<br>&gt; <br>&gt; /// Returns the index of the minimum element as `Optional(index)` or<br>&gt; /// `Optional(nil)` if the sequence has no elements. The uncustomized<br>&gt; /// version returns `nil`.<br>&gt; func _customIndexOfMinComparableElement() -&gt;Index??<br>&gt; <br>&gt; /// Returns the index of the maximum element as `Optional(index)` or<br>&gt; /// `Optional(nil)` if the sequence has no elements. The uncustomized<br>&gt; /// version returns `nil`.<br>&gt; func _customIndexOfMaxComparableElement() -&gt;Index??<br>&gt; }<br>&gt; Minmax Algorithm<br>&gt; <br>&gt; The minmax() algorithm finds the minimum and maximum elements of a sequence in one pass more efficiently than consecutive calls to min() and max(). This optimization comes from iterating over a sequence two elements at a time.<br>&gt; <br>&gt; In each iteration, two consecutive elements are compared with each other. Only the lesser element could be a minimum for the whole sequence, so it is compared with the current minimum, while only the greater element could be a maximum, so it is compared with the current maximum. This works out to 3 comparisons for every 2 elements vs. 2 comparisons for every element when the minimum and maximum are found individually.<br>&gt; <br>&gt; Impact on existing code<br>&gt; As new APIs these should have no effect on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; None.<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 20, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Maybe this has been addressed before on another topic, but why are minmax(), minIndex(), maxIndex() and minmaxIndices() functions rather than read-only properties?<br></p><p>The API Guidelines say this:<br></p><p>&gt;&gt;&gt; Document the complexity of any computed property that is not O(1). People often assume that property access involves no significant computation, because they have stored properties as a mental model. Be sure to alert them when that assumption may be violated.<br></p><p>It&#39;s not stated outright, but that also sort of implies that you should generally prefer to make a non-O(1) operation a method, not a property. There are lots of borderline cases—`count` is O(n) for the general case of a Sequence or Collection, but it&#39;s O(1) for many of the most common types like Array, so it&#39;s made a property even though that might be confusing. Very few types would have O(1) `min/maxIndex`, so it doesn&#39;t seem appropriate to use methods.<br></p><p>Also, non-`Comparable` collections would need a form which takes a comparison function as a parameter. That means method.<br></p><p>&gt; Also, I’d favour “bounds”, “boundaries” or “limits” over minmax. There are plenty of English words which better and more precisely describe what it provides.<br></p><p>These all sound like words for the `start/endIndex`. That&#39;s a problem with this proposal more generally; I&#39;m not really in favor.<br></p><p>(I wonder if instead, there should be an operation like reduce(_:combine:) but with a function parameter which returns a Bool, and which ends up returning the last element which the function returned true for.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
