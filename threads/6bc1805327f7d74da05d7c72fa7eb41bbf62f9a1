<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  4, 2016 at 08:00:00pm</p></header><div class="content"><p>on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; If the casts are always in one direction, can you make one protocol<br>&gt; refine another?<br></p><p>Yeah, I am shocked if they don&#39;t do that already.<br></p><p>&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt; helps.<br></p><p>Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>existentials.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt; <br>&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt; foundation types.<br>&gt;&gt; <br>&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt; refactoring hazard.<br>&gt;&gt; <br>&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt; <br>&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt; refine another?<br>&gt; <br>&gt; Yeah, I am shocked if they don&#39;t do that already.<br></p><p>They do; _NSFoo: _NSFooCore<br></p><p>But the problem is that we have _NSFooCores and want _NSFoos.<br></p><p>&gt; <br>&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt; helps.<br>&gt; <br>&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt; existentials.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161107/97444c61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  7, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt; refine another?<br>&gt;&gt; <br>&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;<br>&gt; They do; _NSFoo: _NSFooCore<br>&gt;<br>&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br></p><p>Right.  Then you need type punning without any dynamic checks,<br>a.k.a. _unsafeReferenceCast<br></p><p>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt; helps.<br>&gt;&gt; <br>&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt; existentials.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November  7, 2016 at 03:00:00pm</p></header><div class="content"><p>Does _unsafeReferenceCast at least verify that the types in question could theoretically be cast into each other? That is, one is derived from the other? If so, that would probably be an acceptable improvement. (the best we could ever hope to do?)<br></p><p>&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt; <br>&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt; <br>&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt; <br>&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt; a.k.a. _unsafeReferenceCast<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  7, 2016 at 12:00:00pm</p></header><div class="content"><p>on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br></p><p>&gt; Does _unsafeReferenceCast at least verify that the types in question<br>&gt; could theoretically be cast into each other? That is, one is derived<br>&gt; from the other? <br></p><p>Not IIRC<br></p><p>&gt; If so, that would probably be an acceptable improvement. (the best we<br>&gt; could ever hope to do?)<br></p><p>It might be, if that&#39;s the only way it&#39;s being used.<br></p><p>&gt;&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;&gt; <br>&gt;&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt;&gt; a.k.a. _unsafeReferenceCast<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br></p><p>-- <br>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 12:15 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Does _unsafeReferenceCast at least verify that the types in question could theoretically be cast into each other? That is, one is derived from the other? If so, that would probably be an acceptable improvement. (the best we could ever hope to do?)<br></p><p>This is what I call lying about types. _unsafeReferenceCast does not and should not support that. It *should* actually have sanity checks to catch such incorrect usage. The checks aren’t implemented yet. Instead you may end up with a crash in the runtime.<br></p><p>unsafeBitCast is the way to lie about a type. It only works when <br>- dealing with a @objc class protocol<br>- we guarantee that the mistyped reference will never be dynamically cast or accessed in any way other than msgSend<br></p><p>Those conditions make it immune from struct aliasing based on a technicality. It does encourage bad practice, and our memory model documentation now needs to make exceptions for this special, confusing case.<br></p><p>I like JoeG’s idea of a msgSend builtin. I’m just not sure that would completely obsolete shadow protocols. Are we also using them to satisfy protocol requirements?<br></p><p>-Andy<br></p><p>&gt;&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;&gt; <br>&gt;&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt;&gt; a.k.a. _unsafeReferenceCast<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 6:22 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 7, 2016, at 12:15 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Does _unsafeReferenceCast at least verify that the types in question could theoretically be cast into each other? That is, one is derived from the other? If so, that would probably be an acceptable improvement. (the best we could ever hope to do?)<br>&gt; <br>&gt; This is what I call lying about types. _unsafeReferenceCast does not and should not support that. It *should* actually have sanity checks to catch such incorrect usage. The checks aren’t implemented yet. Instead you may end up with a crash in the runtime.<br>&gt; <br>&gt; unsafeBitCast is the way to lie about a type. It only works when <br>&gt; - dealing with a @objc class protocol<br>&gt; - we guarantee that the mistyped reference will never be dynamically cast or accessed in any way other than msgSend<br>&gt; <br>&gt; Those conditions make it immune from struct aliasing based on a technicality. It does encourage bad practice, and our memory model documentation now needs to make exceptions for this special, confusing case.<br>&gt; <br>&gt; I like JoeG’s idea of a msgSend builtin. I’m just not sure that would completely obsolete shadow protocols. Are we also using them to satisfy protocol requirements?<br></p><p>Once “inside” the realm of shadow protocols, they do provide some decent static type safety guarantees. They provide an assertion that the NSFooCore API is satisfied by all the types we expect. It also provides a nice single place for us to declare the APIs we’re interested in. What does messing up a msgSend imply? Is it type-safe? Do I just get a “no such message” crash at runtime?<br></p><p>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt;&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt;&gt;&gt; a.k.a. _unsafeReferenceCast<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  8, 2016 at 04:00:00pm</p></header><div class="content"><p>The msg send built in is worse than exploiting AnyObject magic. I&#39;d rather fall back to that<br></p><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Nov 8, 2016, at 4:34 PM, Alexis &lt;abeingessner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Nov 8, 2016, at 6:22 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 7, 2016, at 12:15 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does _unsafeReferenceCast at least verify that the types in question could theoretically be cast into each other? That is, one is derived from the other? If so, that would probably be an acceptable improvement. (the best we could ever hope to do?)<br>&gt;&gt; <br>&gt;&gt; This is what I call lying about types. _unsafeReferenceCast does not and should not support that. It *should* actually have sanity checks to catch such incorrect usage. The checks aren’t implemented yet. Instead you may end up with a crash in the runtime.<br>&gt;&gt; <br>&gt;&gt; unsafeBitCast is the way to lie about a type. It only works when <br>&gt;&gt; - dealing with a @objc class protocol<br>&gt;&gt; - we guarantee that the mistyped reference will never be dynamically cast or accessed in any way other than msgSend<br>&gt;&gt; <br>&gt;&gt; Those conditions make it immune from struct aliasing based on a technicality. It does encourage bad practice, and our memory model documentation now needs to make exceptions for this special, confusing case.<br>&gt;&gt; <br>&gt;&gt; I like JoeG’s idea of a msgSend builtin. I’m just not sure that would completely obsolete shadow protocols. Are we also using them to satisfy protocol requirements?<br>&gt; <br>&gt; Once “inside” the realm of shadow protocols, they do provide some decent static type safety guarantees. They provide an assertion that the NSFooCore API is satisfied by all the types we expect. It also provides a nice single place for us to declare the APIs we’re interested in. What does messing up a msgSend imply? Is it type-safe? Do I just get a “no such message” crash at runtime?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt;&gt;&gt;&gt; a.k.a. _unsafeReferenceCast<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt;&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 4:41 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The msg send built in is worse than exploiting AnyObject magic. I&#39;d rather fall back to that<br></p><p>As a builtin, we could probably constrain it to be type safe. The AnyObject magic implementation right now implies a bunch of optional meddling that I don&#39;t think we optimize away well, though it does have the benefit of already being readily available. Doug also still wants to kill it some day…<br></p><p>-Joe<br></p><p>&gt; Sent from my moss-covered three-handled family gradunza<br>&gt; <br>&gt;&gt; On Nov 8, 2016, at 4:34 PM, Alexis &lt;abeingessner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 8, 2016, at 6:22 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 7, 2016, at 12:15 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does _unsafeReferenceCast at least verify that the types in question could theoretically be cast into each other? That is, one is derived from the other? If so, that would probably be an acceptable improvement. (the best we could ever hope to do?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is what I call lying about types. _unsafeReferenceCast does not and should not support that. It *should* actually have sanity checks to catch such incorrect usage. The checks aren’t implemented yet. Instead you may end up with a crash in the runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; unsafeBitCast is the way to lie about a type. It only works when <br>&gt;&gt;&gt; - dealing with a @objc class protocol<br>&gt;&gt;&gt; - we guarantee that the mistyped reference will never be dynamically cast or accessed in any way other than msgSend<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those conditions make it immune from struct aliasing based on a technicality. It does encourage bad practice, and our memory model documentation now needs to make exceptions for this special, confusing case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like JoeG’s idea of a msgSend builtin. I’m just not sure that would completely obsolete shadow protocols. Are we also using them to satisfy protocol requirements?<br>&gt;&gt; <br>&gt;&gt; Once “inside” the realm of shadow protocols, they do provide some decent static type safety guarantees. They provide an assertion that the NSFooCore API is satisfied by all the types we expect. It also provides a nice single place for us to declare the APIs we’re interested in. What does messing up a msgSend imply? Is it type-safe? Do I just get a “no such message” crash at runtime?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt;&gt;&gt;&gt;&gt; a.k.a. _unsafeReferenceCast<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  8, 2016 at 10:00:00pm</p></header><div class="content"><p>on Tue Nov 08 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 8, 2016, at 6:22 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 7, 2016, at 12:15 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Does _unsafeReferenceCast at least verify that the types in<br>&gt;&gt;&gt; question could theoretically be cast into each other? That is, one<br>&gt;&gt;&gt; is derived from the other? If so, that would probably be an<br>&gt;&gt;&gt; acceptable improvement. (the best we could ever hope to do?)<br>&gt;&gt; <br>&gt;&gt; This is what I call lying about types. _unsafeReferenceCast does not<br>&gt;&gt; and should not support that. It *should* actually have sanity checks<br>&gt;&gt; to catch such incorrect usage. The checks aren’t implemented<br>&gt;&gt; yet. Instead you may end up with a crash in the runtime.<br>&gt;&gt; <br>&gt;&gt; unsafeBitCast is the way to lie about a type. It only works when <br>&gt;&gt; - dealing with a @objc class protocol<br>&gt;&gt; - we guarantee that the mistyped reference will never be dynamically cast or accessed in any way<br>&gt; other than msgSend<br>&gt;&gt; <br>&gt;&gt; Those conditions make it immune from struct aliasing based on a<br>&gt;&gt; technicality. It does encourage bad practice, and our memory model<br>&gt;&gt; documentation now needs to make exceptions for this special,<br>&gt;&gt; confusing case.<br>&gt;&gt; <br>&gt;&gt; I like JoeG’s idea of a msgSend builtin. I’m just not sure that<br>&gt;&gt; would completely obsolete shadow protocols. Are we also using them<br>&gt;&gt; to satisfy protocol requirements?<br>&gt;<br>&gt; Once “inside” the realm of shadow protocols, they do provide some<br>&gt; decent static type safety guarantees. They provide an assertion that<br>&gt; the NSFooCore API is satisfied by all the types we expect. It also<br>&gt; provides a nice single place for us to declare the APIs we’re<br>&gt; interested in. What does messing up a msgSend imply? Is it type-safe?<br></p><p>No, and if you send the same message from multiple places you have to<br>make sure you get it right in all those places.  That&#39;s why I&#39;d *much*<br>rather just declare the shadow protocols, then cast our things to<br>AnyObject and use the magic .anyDeclaredObjCThing accessor from<br>AnyObject to send the right messages.  We could declare the Swift names<br>of these methods to be quite distinct (e.g. start with &quot;_swift_&quot;) and<br>give them the right objC selectors with an explicit @objc(selectorname)<br>declaration, to help ensure that we&#39;re not picking up the wrong API.<br></p><p>&gt; <br>&gt; Do I just get a “no such message” crash at runtime?<br>&gt;<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 7, 2016, at 2:30 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Nov 07 2016, Alexis &lt;abeingessner-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.  Then you need type punning without any dynamic checks,<br>&gt;&gt;&gt;&gt; a.k.a. _unsafeReferenceCast<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt;&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>November  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 11:23 AM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt; refine another?<br>&gt;&gt; <br>&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt; <br>&gt; They do; _NSFoo: _NSFooCore<br>&gt; <br>&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br></p><p>I am confused. Then why can&#39;t you just do an unconditional checked down cast to _NSFoo from _NSFooCore? That can definitely be expressed at the SIL level?<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt; helps.<br>&gt;&gt; <br>&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt; existentials.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161108/4bc00f9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  8, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Nov 08 2016, Michael Gottesman &lt;mgottesman-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 7, 2016, at 11:23 AM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 4, 2016, at 11:55 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org<br>&gt; &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Nov 04 2016, Slava Pestov &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the casts are always in one direction, can you make one protocol<br>&gt;&gt;&gt;&gt; refine another?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, I am shocked if they don&#39;t do that already.<br>&gt;&gt; <br>&gt;&gt; They do; _NSFoo: _NSFooCore<br>&gt;&gt; <br>&gt;&gt; But the problem is that we have _NSFooCores and want _NSFoos.<br>&gt;<br>&gt; I am confused. Then why can&#39;t you just do an unconditional checked down cast to _NSFoo from<br>&gt; _NSFooCore? That can definitely be expressed at the SIL level?<br></p><p>The check will fail.  There is no actual relationship between the type<br>and the protocol; we are just using the protocol to call some ObjC<br>methods without being able to see the actual type&#39;s declaration.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also note that @objc protocols are self-conforming as long as they<br>&gt;&gt;&gt;&gt; don’t contain initializers or static methods, but I’m not sure if that<br>&gt;&gt;&gt;&gt; helps.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doesn&#39;t; we&#39;re not using these in a generic context; they&#39;re just<br>&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The types in the core library want to know about several types<br>&gt;&gt;&gt;&gt;&gt; defined in foundation: NSString, NSArray, NSDictionary, etc. But<br>&gt;&gt;&gt;&gt;&gt; core is imported by Foundation, so it can’t (circular references<br>&gt;&gt;&gt;&gt;&gt; between modules). Thankfully, everything in ObjC is pretty opaquely<br>&gt;&gt;&gt;&gt;&gt; defined and uniform, and Swift knows how to hook into that uniform<br>&gt;&gt;&gt;&gt;&gt; layout. So the core library defines Shadow Protocols which provide<br>&gt;&gt;&gt;&gt;&gt; whatever subset of that type’s API is considered interesting. These<br>&gt;&gt;&gt;&gt;&gt; protocols are then used in place of the ObjC types. There’s also<br>&gt;&gt;&gt;&gt;&gt; some magic compiler hooks so core lib types can subclass those<br>&gt;&gt;&gt;&gt;&gt; foundation types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However there’s sometimes two Shadow Protocols: one that defines the<br>&gt;&gt;&gt;&gt;&gt; APIs the stdlib should provide (_NSFooCore), and one that extends<br>&gt;&gt;&gt;&gt;&gt; that with extra APIs the stdlib wants to consume (_NSFoo). This<br>&gt;&gt;&gt;&gt;&gt; leads to an awkward situation: as far as the runtime is concerned,<br>&gt;&gt;&gt;&gt;&gt; the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do<br>&gt;&gt;&gt;&gt;&gt; because it’s all just a big lie to hook into ObjC message passing<br>&gt;&gt;&gt;&gt;&gt; with a bit of type safety, but the runtime doesn’t. So if you try to<br>&gt;&gt;&gt;&gt;&gt; do a safe type cast, it will fail. This leads to a situation where<br>&gt;&gt;&gt;&gt;&gt; we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive<br>&gt;&gt;&gt;&gt;&gt; refactoring hazard.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For instance, there was a struct-containing-a-class that was being<br>&gt;&gt;&gt;&gt;&gt; cast to _NSFoo in HashedCollections. This happened to work (but was<br>&gt;&gt;&gt;&gt;&gt; probably still a violation of strict aliasing?) because the struct’s<br>&gt;&gt;&gt;&gt;&gt; only field was the class. However the struct was later changed to a<br>&gt;&gt;&gt;&gt;&gt; class, which silently made the cast completely incorrect, banishing<br>&gt;&gt;&gt;&gt;&gt; the real _NSFoo to the shadow (protocol) realm.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can we do anything better here? Note that there’s a few places where<br>&gt;&gt;&gt;&gt;&gt; we also cast an AnyObject into an _NSFoo, but there’s some chance<br>&gt;&gt;&gt;&gt;&gt; this is all legacy junk that can be updated to at least use<br>&gt;&gt;&gt;&gt;&gt; _NSFooCore, if not _NSFoo itself.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
