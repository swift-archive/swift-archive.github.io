<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>December 13, 2015 at 04:00:00pm</p></header><div class="content"><p>Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for<br>Swift&#39;s evolution. The 90% solution might be more straightforward:<br></p><p>class Example {<br>  var member: String<br></p><p>  func print() {<br>    print(self.member)<br>  }<br>}<br></p><p>var example = Example(member: &quot;Hi!&quot;)<br></p><p>var example_print_method = example.print<br>example_print_method()<br>result:<br>Hi!<br></p><p>If there were a mechanism for referring to the getter and setter methods on<br>the var member property as the same kind of self-capturing closures, it<br>could make simple cases of data binding easier to implement:<br></p><p>var serializeFields = [<br>  &quot;member&quot;: example.member#get,<br>]<br></p><p>var deserializeFields = [<br>  &quot;member&quot;: example.member#set,<br>]<br></p><p>var broadcastValueTo = [<br>  &quot;memberValues&quot;: [<br>     example.member#set,<br>     example2.member#set,<br>     example3.member#set,<br>  ]<br>]<br></p><p>viewController.textField.onValueChanged(example.member#set)<br></p><p>Etc.<br></p><p>The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided<br>upon&quot;, though it does seem to be available and using it postfix makes a<br>first-glance sense to me in terms of the semantics of expressions.<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/375ed0cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 01:00:00am</p></header><div class="content"><p>Wait, where is stated that KVO is a long-term goal for Swift? I might have<br>missed that.<br></p><p>I find that one of Objective-C&#39;s most annoying features. It makes it really<br>difficult to reason about code when things can happen unexpectedly left and<br>right. It&#39;s the same issue with aspect-oriented programming.<br></p><p>I prefer explicit integration points like closures, delegates and alike.<br>Most times I used KVO in the past was to work around bugs or annoyances on<br>iOS, like for example forcing a button stay enabled even when iOS disables<br>it.<br></p><p>Also it&#39;s unlikely that all mutable properties will support observation<br>automatically. That would require the optimizer to keep using dynamic<br>dispatch for all of them which will hurt performance.<br></p><p><br>But I&#39;m getting off-topic since your discussion is not about KVO nor about<br>KVC.<br></p><p>Being able to refer to getters and setters is a good idea and aligns with<br>being able to refer to initializers and methods.<br>I would also add subscripts to the list if possible.<br></p><p>On Mon, Dec 14, 2015 at 1:34 AM, Michael Henson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for<br>&gt; Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;<br>&gt; class Example {<br>&gt;   var member: String<br>&gt;<br>&gt;   func print() {<br>&gt;     print(self.member)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;<br>&gt; var example_print_method = example.print<br>&gt; example_print_method()<br>&gt; result:<br>&gt; Hi!<br>&gt;<br>&gt; If there were a mechanism for referring to the getter and setter methods<br>&gt; on the var member property as the same kind of self-capturing closures, it<br>&gt; could make simple cases of data binding easier to implement:<br>&gt;<br>&gt; var serializeFields = [<br>&gt;   &quot;member&quot;: example.member#get,<br>&gt; ]<br>&gt;<br>&gt; var deserializeFields = [<br>&gt;   &quot;member&quot;: example.member#set,<br>&gt; ]<br>&gt;<br>&gt; var broadcastValueTo = [<br>&gt;   &quot;memberValues&quot;: [<br>&gt;      example.member#set,<br>&gt;      example2.member#set,<br>&gt;      example3.member#set,<br>&gt;   ]<br>&gt; ]<br>&gt;<br>&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;<br>&gt; Etc.<br>&gt;<br>&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided<br>&gt; upon&quot;, though it does seem to be available and using it postfix makes a<br>&gt; first-glance sense to me in terms of the semantics of expressions.<br>&gt;<br>&gt; Mike<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/4d98b595/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 13, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; I find that (KVO) one of Objective-C&#39;s most annoying features. It makes it really difficult to reason about code when things can happen unexpectedly left and right. It&#39;s the same issue with aspect-oriented programming.<br>&gt; <br>&gt; I prefer explicit integration points like closures, delegates and alike.<br></p><p>+1.  I especially dislike system APIs that offer no alternatives to KVO when communicating with clients.  I hope we can at least avoid that mistake in Swift-native API designs.<br></p><p>&gt; <br>&gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt; I would also add subscripts to the list if possible.<br></p><p>+1 to this as well.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Being able to refer to getters and setters is a good idea and aligns with<br>being able to refer to initializers and methods.<br>&gt; I would also add subscripts to the list if possible.<br></p><p>Great idea! Let&#39;s discuss syntax<br></p><p>How about<br> - example.get.member<br> - example.set.member<br> - example.init(argument:Int, another:String)<br> - example.subscript(index:Int)<br></p><p><br>On Mon, Dec 14, 2015 at 3:49 AM, Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Wait, where is stated that KVO is a long-term goal for Swift? I might have<br>&gt; missed that.<br>&gt;<br>&gt; I find that one of Objective-C&#39;s most annoying features. It makes it<br>&gt; really difficult to reason about code when things can happen unexpectedly<br>&gt; left and right. It&#39;s the same issue with aspect-oriented programming.<br>&gt;<br>&gt; I prefer explicit integration points like closures, delegates and alike.<br>&gt; Most times I used KVO in the past was to work around bugs or annoyances on<br>&gt; iOS, like for example forcing a button stay enabled even when iOS disables<br>&gt; it.<br>&gt;<br>&gt; Also it&#39;s unlikely that all mutable properties will support observation<br>&gt; automatically. That would require the optimizer to keep using dynamic<br>&gt; dispatch for all of them which will hurt performance.<br>&gt;<br>&gt;<br>&gt; But I&#39;m getting off-topic since your discussion is not about KVO nor about<br>&gt; KVC.<br>&gt;<br>&gt; Being able to refer to getters and setters is a good idea and aligns with<br>&gt; being able to refer to initializers and methods.<br>&gt; I would also add subscripts to the list if possible.<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 1:34 AM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for<br>&gt;&gt; Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;&gt;<br>&gt;&gt; class Example {<br>&gt;&gt;   var member: String<br>&gt;&gt;<br>&gt;&gt;   func print() {<br>&gt;&gt;     print(self.member)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;&gt;<br>&gt;&gt; var example_print_method = example.print<br>&gt;&gt; example_print_method()<br>&gt;&gt; result:<br>&gt;&gt; Hi!<br>&gt;&gt;<br>&gt;&gt; If there were a mechanism for referring to the getter and setter methods<br>&gt;&gt; on the var member property as the same kind of self-capturing closures, it<br>&gt;&gt; could make simple cases of data binding easier to implement:<br>&gt;&gt;<br>&gt;&gt; var serializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#get,<br>&gt;&gt; ]<br>&gt;&gt;<br>&gt;&gt; var deserializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#set,<br>&gt;&gt; ]<br>&gt;&gt;<br>&gt;&gt; var broadcastValueTo = [<br>&gt;&gt;   &quot;memberValues&quot;: [<br>&gt;&gt;      example.member#set,<br>&gt;&gt;      example2.member#set,<br>&gt;&gt;      example3.member#set,<br>&gt;&gt;   ]<br>&gt;&gt; ]<br>&gt;&gt;<br>&gt;&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;&gt;<br>&gt;&gt; Etc.<br>&gt;&gt;<br>&gt;&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided<br>&gt;&gt; upon&quot;, though it does seem to be available and using it postfix makes a<br>&gt;&gt; first-glance sense to me in terms of the semantics of expressions.<br>&gt;&gt;<br>&gt;&gt; Mike<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/cb37a931/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>+1<br></p><p>I like the #get, #set suffixes.<br></p><p>I’m afraid the following would be a bit ambiguous<br>&gt;  - example.init(argument:Int, another:String)<br>&gt;  - example.subscript(index:Int)<br></p><p>Maybe with ‘#’ too<br> - example.init#argument:Int#another:String<br> - example.init#argument#another<br> - example.init#(argument:Int, another:String)<br> - example.subscript#index:Int<br> - example.subscript#Int<br></p><p>Pierre<br></p><p>&gt; Le 14 déc. 2015 à 08:57, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt; &gt; I would also add subscripts to the list if possible.<br>&gt; <br>&gt; Great idea! Let&#39;s discuss syntax<br>&gt; <br>&gt; How about <br>&gt;  - example.get.member<br>&gt;  - example.set.member<br>&gt;  - example.init(argument:Int, another:String)<br>&gt;  - example.subscript(index:Int)<br>&gt; <br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 3:49 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Wait, where is stated that KVO is a long-term goal for Swift? I might have missed that.<br>&gt; <br>&gt; I find that one of Objective-C&#39;s most annoying features. It makes it really difficult to reason about code when things can happen unexpectedly left and right. It&#39;s the same issue with aspect-oriented programming.<br>&gt; <br>&gt; I prefer explicit integration points like closures, delegates and alike.<br>&gt; Most times I used KVO in the past was to work around bugs or annoyances on iOS, like for example forcing a button stay enabled even when iOS disables it.<br>&gt; <br>&gt; Also it&#39;s unlikely that all mutable properties will support observation automatically. That would require the optimizer to keep using dynamic dispatch for all of them which will hurt performance.<br>&gt; <br>&gt; <br>&gt; But I&#39;m getting off-topic since your discussion is not about KVO nor about KVC.<br>&gt; <br>&gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt; I would also add subscripts to the list if possible.<br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 1:34 AM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt; <br>&gt; class Example {<br>&gt;   var member: String<br>&gt; <br>&gt;   func print() {<br>&gt;     print(self.member)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt; <br>&gt; var example_print_method = example.print<br>&gt; example_print_method()<br>&gt; result:<br>&gt; Hi!<br>&gt; <br>&gt; If there were a mechanism for referring to the getter and setter methods on the var member property as the same kind of self-capturing closures, it could make simple cases of data binding easier to implement:<br>&gt; <br>&gt; var serializeFields = [<br>&gt;   &quot;member&quot;: example.member#get,<br>&gt; ]<br>&gt; <br>&gt; var deserializeFields = [<br>&gt;   &quot;member&quot;: example.member#set,<br>&gt; ]<br>&gt; <br>&gt; var broadcastValueTo = [<br>&gt;   &quot;memberValues&quot;: [<br>&gt;      example.member#set,<br>&gt;      example2.member#set,<br>&gt;      example3.member#set,<br>&gt;   ]<br>&gt; ]<br>&gt; <br>&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt; <br>&gt; Etc.<br>&gt; <br>&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided upon&quot;, though it does seem to be available and using it postfix makes a first-glance sense to me in terms of the semantics of expressions.<br>&gt; <br>&gt; Mike<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/6e8d549c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>+1, I like this idea! I&#39;m not sure if I like `#`, though – maybe the type should be inferred, much like when using `init`s?<br></p><p>&gt; struct Foo {<br>&gt; 	init(_: Int) {}<br>&gt; 	init(_: String) {}<br>&gt; }<br>&gt; <br>&gt; // this infers the int setter<br>&gt; let intInit: (Int) -&gt; Foo = Foo.init<br>&gt; <br>&gt; // this infers the string setter<br>&gt; let stringInit: (String) -&gt; Foo = Foo.init<br></p><p>Note that you cannot explicitly refer to a specific `init`. My proposal is to use the same technique when referring to getters and setters:<br></p><p>&gt; struct Foo {<br>&gt; 	let bar: Int<br>&gt; }<br>&gt; <br>&gt; // this just reads the value<br>&gt; let value = Foo.bar<br>&gt; <br>&gt; // this infers a getter<br>&gt; let getter: () -&gt; Int = Foo().bar<br>&gt; <br>&gt; // this infers a setter<br>&gt; let setter: (Int) -&gt; Void = Foo().bar<br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 14.12.2015, o godz. 09:25:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I like the #get, #set suffixes.<br>&gt; <br>&gt; I’m afraid the following would be a bit ambiguous<br>&gt;&gt;  - example.init(argument:Int, another:String)<br>&gt;&gt;  - example.subscript(index:Int)<br>&gt; <br>&gt; Maybe with ‘#’ too<br>&gt;  - example.init#argument:Int#another:String<br>&gt;  - example.init#argument#another<br>&gt;  - example.init#(argument:Int, another:String)<br>&gt;  - example.subscript#index:Int<br>&gt;  - example.subscript#Int<br>&gt; <br>&gt; Pierre<br>&gt; <br>&gt;&gt; Le 14 déc. 2015 à 08:57, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; &gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt;&gt; &gt; I would also add subscripts to the list if possible.<br>&gt;&gt; <br>&gt;&gt; Great idea! Let&#39;s discuss syntax<br>&gt;&gt; <br>&gt;&gt; How about <br>&gt;&gt;  - example.get.member<br>&gt;&gt;  - example.set.member<br>&gt;&gt;  - example.init(argument:Int, another:String)<br>&gt;&gt;  - example.subscript(index:Int)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 3:49 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Wait, where is stated that KVO is a long-term goal for Swift? I might have missed that.<br>&gt;&gt; <br>&gt;&gt; I find that one of Objective-C&#39;s most annoying features. It makes it really difficult to reason about code when things can happen unexpectedly left and right. It&#39;s the same issue with aspect-oriented programming.<br>&gt;&gt; <br>&gt;&gt; I prefer explicit integration points like closures, delegates and alike.<br>&gt;&gt; Most times I used KVO in the past was to work around bugs or annoyances on iOS, like for example forcing a button stay enabled even when iOS disables it.<br>&gt;&gt; <br>&gt;&gt; Also it&#39;s unlikely that all mutable properties will support observation automatically. That would require the optimizer to keep using dynamic dispatch for all of them which will hurt performance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; But I&#39;m getting off-topic since your discussion is not about KVO nor about KVC.<br>&gt;&gt; <br>&gt;&gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt;&gt; I would also add subscripts to the list if possible.<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 1:34 AM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;&gt; <br>&gt;&gt; class Example {<br>&gt;&gt;   var member: String<br>&gt;&gt; <br>&gt;&gt;   func print() {<br>&gt;&gt;     print(self.member)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;&gt; <br>&gt;&gt; var example_print_method = example.print<br>&gt;&gt; example_print_method()<br>&gt;&gt; result:<br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; If there were a mechanism for referring to the getter and setter methods on the var member property as the same kind of self-capturing closures, it could make simple cases of data binding easier to implement:<br>&gt;&gt; <br>&gt;&gt; var serializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#get,<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; var deserializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#set,<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; var broadcastValueTo = [<br>&gt;&gt;   &quot;memberValues&quot;: [<br>&gt;&gt;      example.member#set,<br>&gt;&gt;      example2.member#set,<br>&gt;&gt;      example3.member#set,<br>&gt;&gt;   ]<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;&gt; <br>&gt;&gt; Etc.<br>&gt;&gt; <br>&gt;&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided upon&quot;, though it does seem to be available and using it postfix makes a first-glance sense to me in terms of the semantics of expressions.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ec8befa6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 17, 2015 at 02:00:00am</p></header><div class="content"><p>One thing to be aware of is the lifetime semantics. This is something that<br>has bit me in the past when using object.functionName and passing that to<br>another object that holds on the function: it will actually hold a strong<br>reference to object! So it&#39;s easy to see how one can create retain cycles<br>that way, and it&#39;s not obvious at all when reading the code (IMO)<br>On Wed, Dec 16, 2015 at 1:07 AM Adrian Kashivskyy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1, I like this idea! I&#39;m not sure if I like `#`, though – maybe the type<br>&gt; should be inferred, much like when using `init`s?<br>&gt;<br>&gt; struct Foo {<br>&gt; init(_: Int) {}<br>&gt; init(_: String) {}<br>&gt; }<br>&gt;<br>&gt; // this infers the int setter<br>&gt; let intInit: (Int) -&gt; Foo = Foo.init<br>&gt;<br>&gt; // this infers the string setter<br>&gt; let stringInit: (String) -&gt; Foo = Foo.init<br>&gt;<br>&gt;<br>&gt; Note that you cannot explicitly refer to a specific `init`. My proposal is<br>&gt; to use the same technique when referring to getters and setters:<br>&gt;<br>&gt; struct Foo {<br>&gt; let bar: Int<br>&gt; }<br>&gt;<br>&gt; // this just reads the value<br>&gt; let value = Foo.bar<br>&gt;<br>&gt; // this infers a getter<br>&gt; let getter: () -&gt; Int = Foo().bar<br>&gt;<br>&gt; // this infers a setter<br>&gt; let setter: (Int) -&gt; Void = Foo().bar<br>&gt;<br>&gt;<br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt;<br>&gt; Wiadomość napisana przez Pierre Monod-Broca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; w dniu 14.12.2015, o godz. 09:25:<br>&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt; I like the #get, #set suffixes.<br>&gt;<br>&gt; I’m afraid the following would be a bit ambiguous<br>&gt;<br>&gt;  - example.init(argument:Int, another:String)<br>&gt;<br>&gt;  - example.subscript(index:Int)<br>&gt;<br>&gt;<br>&gt; Maybe with ‘#’ too<br>&gt;  - example.init#argument:Int#another:String<br>&gt;  - example.init#argument#another<br>&gt;  - example.init#(argument:Int, another:String)<br>&gt;  - example.subscript#index:Int<br>&gt;  - example.subscript#Int<br>&gt;<br>&gt; Pierre<br>&gt;<br>&gt; Le 14 déc. 2015 à 08:57, ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; &gt; Being able to refer to getters and setters is a good idea and aligns<br>&gt; with being able to refer to initializers and methods.<br>&gt; &gt; I would also add subscripts to the list if possible.<br>&gt;<br>&gt; Great idea! Let&#39;s discuss syntax<br>&gt;<br>&gt; How about<br>&gt;  - example.get.member<br>&gt;  - example.set.member<br>&gt;  - example.init(argument:Int, another:String)<br>&gt;  - example.subscript(index:Int)<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 3:49 AM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Wait, where is stated that KVO is a long-term goal for Swift? I might<br>&gt;&gt; have missed that.<br>&gt;&gt;<br>&gt;&gt; I find that one of Objective-C&#39;s most annoying features. It makes it<br>&gt;&gt; really difficult to reason about code when things can happen unexpectedly<br>&gt;&gt; left and right. It&#39;s the same issue with aspect-oriented programming.<br>&gt;&gt;<br>&gt;&gt; I prefer explicit integration points like closures, delegates and alike.<br>&gt;&gt; Most times I used KVO in the past was to work around bugs or annoyances<br>&gt;&gt; on iOS, like for example forcing a button stay enabled even when iOS<br>&gt;&gt; disables it.<br>&gt;&gt;<br>&gt;&gt; Also it&#39;s unlikely that all mutable properties will support observation<br>&gt;&gt; automatically. That would require the optimizer to keep using dynamic<br>&gt;&gt; dispatch for all of them which will hurt performance.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But I&#39;m getting off-topic since your discussion is not about KVO nor<br>&gt;&gt; about KVC.<br>&gt;&gt;<br>&gt;&gt; Being able to refer to getters and setters is a good idea and aligns with<br>&gt;&gt; being able to refer to initializers and methods.<br>&gt;&gt; I would also add subscripts to the list if possible.<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 1:34 AM, Michael Henson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for<br>&gt;&gt;&gt; Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Example {<br>&gt;&gt;&gt;   var member: String<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   func print() {<br>&gt;&gt;&gt;     print(self.member)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var example_print_method = example.print<br>&gt;&gt;&gt; example_print_method()<br>&gt;&gt;&gt; result:<br>&gt;&gt;&gt; Hi!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If there were a mechanism for referring to the getter and setter methods<br>&gt;&gt;&gt; on the var member property as the same kind of self-capturing closures, it<br>&gt;&gt;&gt; could make simple cases of data binding easier to implement:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var serializeFields = [<br>&gt;&gt;&gt;   &quot;member&quot;: example.member#get,<br>&gt;&gt;&gt; ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var deserializeFields = [<br>&gt;&gt;&gt;   &quot;member&quot;: example.member#set,<br>&gt;&gt;&gt; ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var broadcastValueTo = [<br>&gt;&gt;&gt;   &quot;memberValues&quot;: [<br>&gt;&gt;&gt;      example.member#set,<br>&gt;&gt;&gt;      example2.member#set,<br>&gt;&gt;&gt;      example3.member#set,<br>&gt;&gt;&gt;   ]<br>&gt;&gt;&gt; ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is<br>&gt;&gt;&gt; decided upon&quot;, though it does seem to be available and using it postfix<br>&gt;&gt;&gt; makes a first-glance sense to me in terms of the semantics of expressions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mike<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/e1c195ee/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 26, 2015 at 11:00:00pm</p></header><div class="content"><p>FYI, I just sent a proposal draft titled “Generalized Naming for Any Function” that pulls these ideas together more formally. I went with a different syntax that I’d been kicking around for a while internally, and I’d love to hear everyone’s thoughts on this.<br></p><p>	- Doug<br></p><p>&gt; On Dec 14, 2015, at 12:25 AM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I like the #get, #set suffixes.<br>&gt; <br>&gt; I’m afraid the following would be a bit ambiguous<br>&gt;&gt;  - example.init(argument:Int, another:String)<br>&gt;&gt;  - example.subscript(index:Int)<br>&gt; <br>&gt; Maybe with ‘#’ too<br>&gt;  - example.init#argument:Int#another:String<br>&gt;  - example.init#argument#another<br>&gt;  - example.init#(argument:Int, another:String)<br>&gt;  - example.subscript#index:Int<br>&gt;  - example.subscript#Int<br>&gt; <br>&gt; Pierre<br>&gt; <br>&gt;&gt; Le 14 déc. 2015 à 08:57, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; &gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt;&gt; &gt; I would also add subscripts to the list if possible.<br>&gt;&gt; <br>&gt;&gt; Great idea! Let&#39;s discuss syntax<br>&gt;&gt; <br>&gt;&gt; How about <br>&gt;&gt;  - example.get.member<br>&gt;&gt;  - example.set.member<br>&gt;&gt;  - example.init(argument:Int, another:String)<br>&gt;&gt;  - example.subscript(index:Int)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 3:49 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Wait, where is stated that KVO is a long-term goal for Swift? I might have missed that.<br>&gt;&gt; <br>&gt;&gt; I find that one of Objective-C&#39;s most annoying features. It makes it really difficult to reason about code when things can happen unexpectedly left and right. It&#39;s the same issue with aspect-oriented programming.<br>&gt;&gt; <br>&gt;&gt; I prefer explicit integration points like closures, delegates and alike.<br>&gt;&gt; Most times I used KVO in the past was to work around bugs or annoyances on iOS, like for example forcing a button stay enabled even when iOS disables it.<br>&gt;&gt; <br>&gt;&gt; Also it&#39;s unlikely that all mutable properties will support observation automatically. That would require the optimizer to keep using dynamic dispatch for all of them which will hurt performance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; But I&#39;m getting off-topic since your discussion is not about KVO nor about KVC.<br>&gt;&gt; <br>&gt;&gt; Being able to refer to getters and setters is a good idea and aligns with being able to refer to initializers and methods.<br>&gt;&gt; I would also add subscripts to the list if possible.<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 1:34 AM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;&gt; <br>&gt;&gt; class Example {<br>&gt;&gt;   var member: String<br>&gt;&gt; <br>&gt;&gt;   func print() {<br>&gt;&gt;     print(self.member)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;&gt; <br>&gt;&gt; var example_print_method = example.print<br>&gt;&gt; example_print_method()<br>&gt;&gt; result:<br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; If there were a mechanism for referring to the getter and setter methods on the var member property as the same kind of self-capturing closures, it could make simple cases of data binding easier to implement:<br>&gt;&gt; <br>&gt;&gt; var serializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#get,<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; var deserializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#set,<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; var broadcastValueTo = [<br>&gt;&gt;   &quot;memberValues&quot;: [<br>&gt;&gt;      example.member#set,<br>&gt;&gt;      example2.member#set,<br>&gt;&gt;      example3.member#set,<br>&gt;&gt;   ]<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;&gt; <br>&gt;&gt; Etc.<br>&gt;&gt; <br>&gt;&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided upon&quot;, though it does seem to be available and using it postfix makes a first-glance sense to me in terms of the semantics of expressions.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/2d1ee67d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 27, 2015 at 03:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 6:49 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also it&#39;s unlikely that all mutable properties will support observation automatically. That would require the optimizer to keep using dynamic dispatch for all of them which will hurt performance.<br></p><p>Not really. All that’s required for Objective-C KVO to work for a stored property is for the willChangeValueForKey() and didChangeValueForKey() methods to be called before and after the value is set. If you put those calls in willSet and didSet for a Swift stored property, you can get KVO compliance with no dynamic dispatch at all. The reason Objective-C typically requires dynamic dispatch for this is because KVO is purely a framework-level feature, and is not built into the library, so the framework code has to rewrite your class to add the needed methods. If you built a KVO-like system right into the language, the notification methods could be added right at compile time, and it’d work fine. Of course, if I were redesigning KVO, I’d probably eliminate willChangeValueForKey() and just include the old value as a parameter to didChangeValueForKey(), since if there’s only one method to call, you can set the property on a secondary thread, and then just call the observation method asynchronously on the main thread, which will avoid tying up the worker thread waiting for UI updates that result from the KVO update.<br></p><p>Of course, if you’re worried about the performance costs associated with that extra method call, you might want to include a keyword, such as “observable”, and only generate the method call(s) if that keyword is on the property. This would probably be a good thing *anyway*, since one of the weaknesses of the current KVO implementation is that there’s no way to know whether a property is KVO observable or not without reading the documentation for that method, since computed properties need to state their dependencies in order to property support KVO, and whether this has been done is not reflected in the interface at all.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/ebe3d7d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 27, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; Of course, if you’re worried about the performance costs associated with that extra method call, you might want to include a keyword, such as “observable”, and only generate the method call(s) if that keyword is on the property.<br>I strongly agree that Swift should have/keep a possibility to create properties with no performance penalty — but I guess comfort is more important, so I&#39;d rather make observable the default and offer a possibility to disable it.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/adc73df4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 27, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 4:23 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Of course, if you’re worried about the performance costs associated with that extra method call, you might want to include a keyword, such as “observable”, and only generate the method call(s) if that keyword is on the property.<br>&gt; I strongly agree that Swift should have/keep a possibility to create properties with no performance penalty — but I guess comfort is more important, so I&#39;d rather make observable the default and offer a possibility to disable it.<br>&gt; <br>&gt; Tino<br></p><p>The problem, as I see it, is that KVO is not useful unless the author has specifically thought about it, and if “observable” is not the default, but something that the author of the class had to add, this demonstrates that the author *has* considered KVO compliance for the property.  Without some way to know that the property has deliberately been made KVO compliant, code that observes the property cannot be reliable. Therefore, I’d suggest *not* making observable the default, as it ultimately makes KVO a lot more useful.<br></p><p>Example:<br></p><p>class MyObject {<br>	var foo: Int { get } // This is a computed property, possibly dependent on something else. Can I safely observe it and expect it to work?<br></p><p>	var bar: Int           // This is a stored property—but do I know it won’t be changed to a computed property in the future? Can I observe this and trust my code won’t break in version 2.0?<br>}<br></p><p>vs.<br></p><p>class MyObject {<br>	observable var foo: Int { get } // YES I can safely observe this.<br></p><p>	observable var bar                 // YES I can safely observe this.<br>}<br></p><p>Observing things that aren’t observable is fraught with peril (in the current Objective-C implementation, it can often lead to crashes via exceptions being thrown). Knowing that it’s safe is valuable—I’d even say essential. Currently you have to look in the documentation, which as we all know isn’t always complete or up to date. Having the keyword there shows, right in the interface, that the author has committed to making this property compliant and keeping it that way in future releases.<br></p><p>The observable keyword could also allow one to set the KVO key string to something other than just the name of the property:<br></p><p>class MyObject {<br>	observable(somethingElse) var something: Int<br>}<br></p><p>You’d also need an annotation to tell the system which other key paths the property is dependent upon, which I’d probably do something like this:<br></p><p>class MyObject {<br>	observable var foo: Int<br>	observable var bar: Int {<br>		get { return self.foo }<br>		set(bar) { self.foo = bar }<br>		depends { return [“foo”] }<br>	}<br>}<br></p><p>The compiler could automatically add a CollectionType property to the class corresponding to each property, and then rewrite the property setter something like this (pseudocode):<br></p><p>class MyObject {<br>	private var observersOfFoo: [ObserverProtocol]?<br></p><p>	observable var foo: Int {<br>		set(newValue) {<br>			let oldValue = _foo<br></p><p>			_foo = newValue // or whatever the default setter usually does<br></p><p>			self.observersOfFoo?.forEach { $0.notifyKeyValueChanged(self, key: “foo”, oldValue: oldValue) }<br>		}<br>	}<br>}<br></p><p>I made it optional so that for the common case where there aren’t actually any observers on the property, the only performance costs are the store of the old value and checking an optional. Since optionals are basically enums, which are represented as an 8-bit integer which in this case can have the values 0 or 1, I’d expect checking an optional to have similar performance characteristics to checking a boolean, and thus I’d expect it to perform better than checking whether an array is empty, and doing some quick tests seems to back that up.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/943e587f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>This is something I&#39;m looking into. Providing the getter is valuable, but setters are not usually very useful by themselves. With value types, you need the full property interface to be able to drill further down into the value and update part of the value, since you potentially need recursive writeback. Furthermore, the get/set protocol is inefficient for copy-on-write types, since it forces a temporary copy when doing partial updates; Swift&#39;s property model provides a third implicit &quot;materializeForSet&quot; accessor that preserves in-place update when going through abstractions such as overrideable class properties, properties in generics, or properties across resilience boundaries. There are even more shenanigans we&#39;re planning to make mutations through array slices and the like efficient too. To that end, I think the two things you want of a property are:<br></p><p>- its getter, since read-only access is definitely useful for things like `map`, and<br>- what i&#39;ll call its &quot;lens&quot;, notionally a function T -&gt; inout U, which captures the full property interface. You can apply the function in mutable contexts without sacrificing efficiency or composability, and derive the getter/setter functions fairly straightforwardly.<br></p><p>-Joe<br></p><p>&gt; On Dec 13, 2015, at 4:34 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt; <br>&gt; class Example {<br>&gt;   var member: String<br>&gt; <br>&gt;   func print() {<br>&gt;     print(self.member)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt; <br>&gt; var example_print_method = example.print<br>&gt; example_print_method()<br>&gt; result:<br>&gt; Hi!<br>&gt; <br>&gt; If there were a mechanism for referring to the getter and setter methods on the var member property as the same kind of self-capturing closures, it could make simple cases of data binding easier to implement:<br>&gt; <br>&gt; var serializeFields = [<br>&gt;   &quot;member&quot;: example.member#get,<br>&gt; ]<br>&gt; <br>&gt; var deserializeFields = [<br>&gt;   &quot;member&quot;: example.member#set,<br>&gt; ]<br>&gt; <br>&gt; var broadcastValueTo = [<br>&gt;   &quot;memberValues&quot;: [<br>&gt;      example.member#set,<br>&gt;      example2.member#set,<br>&gt;      example3.member#set,<br>&gt;   ]<br>&gt; ]<br>&gt; <br>&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt; <br>&gt; Etc.<br>&gt; <br>&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided upon&quot;, though it does seem to be available and using it postfix makes a first-glance sense to me in terms of the semantics of expressions.<br>&gt; <br>&gt; Mike<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c83007cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 17, 2015 at 11:00:00am</p></header><div class="content"><p>It could be used in that kind of way too (illustrating with the ‘#&#39; syntax suggestion):<br></p><p>class Foo {<br>    var name: String<br>}<br></p><p>let getter = Foo.name#get // (Foo) -&gt; () -&gt; (String)<br>let setter = Foo.name#set // (Foo) -&gt; (String) -&gt; ()<br></p><p>let foo = Foo(name: &quot;f&quot;)<br>getter(foo)() // &quot;f&quot;<br>setter(foo)(&quot;g&quot;) // now foo.name == &quot;g&quot;<br></p><p><br>It might be the similar with struct:<br></p><p>struct Bar {<br>    var name: String<br>}<br></p><p>let getter = Bar.name#get // (Bar) -&gt; () -&gt; (String)<br>let setter = Bar.name#set // (inout Bar) -&gt; (String) -&gt; ()<br></p><p>var bar = Bar(name: &quot;f&quot;) // note bar is a var<br>getter(bar)() // &quot;f&quot;<br>setter(&amp;bar)(&quot;g&quot;) // now foo.name == &quot;g&quot;<br></p><p><br>Pierre<br></p><p>&gt; Le 17 déc. 2015 à 03:59, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This is something I&#39;m looking into. Providing the getter is valuable, but setters are not usually very useful by themselves. With value types, you need the full property interface to be able to drill further down into the value and update part of the value, since you potentially need recursive writeback. Furthermore, the get/set protocol is inefficient for copy-on-write types, since it forces a temporary copy when doing partial updates; Swift&#39;s property model provides a third implicit &quot;materializeForSet&quot; accessor that preserves in-place update when going through abstractions such as overrideable class properties, properties in generics, or properties across resilience boundaries. There are even more shenanigans we&#39;re planning to make mutations through array slices and the like efficient too. To that end, I think the two things you want of a property are:<br>&gt; <br>&gt; - its getter, since read-only access is definitely useful for things like `map`, and<br>&gt; - what i&#39;ll call its &quot;lens&quot;, notionally a function T -&gt; inout U, which captures the full property interface. You can apply the function in mutable contexts without sacrificing efficiency or composability, and derive the getter/setter functions fairly straightforwardly.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 4:34 PM, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;&gt; <br>&gt;&gt; class Example {<br>&gt;&gt;   var member: String<br>&gt;&gt; <br>&gt;&gt;   func print() {<br>&gt;&gt;     print(self.member)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;&gt; <br>&gt;&gt; var example_print_method = example.print<br>&gt;&gt; example_print_method()<br>&gt;&gt; result:<br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; If there were a mechanism for referring to the getter and setter methods on the var member property as the same kind of self-capturing closures, it could make simple cases of data binding easier to implement:<br>&gt;&gt; <br>&gt;&gt; var serializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#get,<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; var deserializeFields = [<br>&gt;&gt;   &quot;member&quot;: example.member#set,<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; var broadcastValueTo = [<br>&gt;&gt;   &quot;memberValues&quot;: [<br>&gt;&gt;      example.member#set,<br>&gt;&gt;      example2.member#set,<br>&gt;&gt;      example3.member#set,<br>&gt;&gt;   ]<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;&gt; <br>&gt;&gt; Etc.<br>&gt;&gt; <br>&gt;&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided upon&quot;, though it does seem to be available and using it postfix makes a first-glance sense to me in terms of the semantics of expressions.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/c702ffae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>Proposal: Expose getter/setters in the same way as regular methods</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>December 18, 2015 at 07:00:00pm</p></header><div class="content"><p>Another option for handling this occurred to me - an &quot;export list&quot; in the<br>lexical block that usually declares getters, setters, and will/didSet:<br></p><p>class Thing {<br>  var property: String {<br>    [get, set]<br>  }<br>}<br></p><p>It&#39;s somewhat like a &quot;capture list&quot; syntax but in the context of the<br>accessor declarations. The function is that it explicitly declares which of<br>the methods should be exposed to the outside world - much like the<br>auto-generated methods for properties in Objective-C. There would be a<br>defined naming scheme for generated methods, perhaps a way to override the<br>default name for special cases, etc. The generated/exported funcs are then<br>just like every other func declared on the type.<br></p><p>Is there a strong inclination on the internal team to add features like<br>this only if they can apply as broadly as possible, all at once?<br></p><p>Mike<br></p><p><br>&gt; This is something I&#39;m looking into. Providing the getter is valuable, but<br>&gt; setters are not usually very useful by themselves. With value types, you<br>&gt; need the full property interface to be able to drill further down into the<br>&gt; value and update part of the value, since you potentially need recursive<br>&gt; writeback. Furthermore, the get/set protocol is inefficient for<br>&gt; copy-on-write types, since it forces a temporary copy when doing partial<br>&gt; updates; Swift&#39;s property model provides a third implicit<br>&gt; &quot;materializeForSet&quot; accessor that preserves in-place update when going<br>&gt; through abstractions such as overrideable class properties, properties in<br>&gt; generics, or properties across resilience boundaries. There are even more<br>&gt; shenanigans we&#39;re planning to make mutations through array slices and the<br>&gt; like efficient too. To that end, I think the two things you want of a<br>&gt; property are:<br>&gt; - its getter, since read-only access is definitely useful for things like<br>&gt; `map`, and<br>&gt; - what i&#39;ll call its &quot;lens&quot;, notionally a function T -&gt; inout U, which<br>&gt; captures the full property interface. You can apply the function in mutable<br>&gt; contexts without sacrificing efficiency or composability, and derive the<br>&gt; getter/setter functions fairly straightforwardly.<br></p><p><br>On Wed, Dec 16, 2015 at 6:59 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; This is something I&#39;m looking into. Providing the getter is valuable, but<br>&gt; setters are not usually very useful by themselves. With value types, you<br>&gt; need the full property interface to be able to drill further down into the<br>&gt; value and update part of the value, since you potentially need recursive<br>&gt; writeback. Furthermore, the get/set protocol is inefficient for<br>&gt; copy-on-write types, since it forces a temporary copy when doing partial<br>&gt; updates; Swift&#39;s property model provides a third implicit<br>&gt; &quot;materializeForSet&quot; accessor that preserves in-place update when going<br>&gt; through abstractions such as overrideable class properties, properties in<br>&gt; generics, or properties across resilience boundaries. There are even more<br>&gt; shenanigans we&#39;re planning to make mutations through array slices and the<br>&gt; like efficient too. To that end, I think the two things you want of a<br>&gt; property are:<br>&gt;<br>&gt; - its getter, since read-only access is definitely useful for things like<br>&gt; `map`, and<br>&gt; - what i&#39;ll call its &quot;lens&quot;, notionally a function T -&gt; inout U, which<br>&gt; captures the full property interface. You can apply the function in mutable<br>&gt; contexts without sacrificing efficiency or composability, and derive the<br>&gt; getter/setter functions fairly straightforwardly.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Dec 13, 2015, at 4:34 PM, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift-like full KVO/KVC as in Objective-C is a stated long-term goal for<br>&gt; Swift&#39;s evolution. The 90% solution might be more straightforward:<br>&gt;<br>&gt; class Example {<br>&gt;   var member: String<br>&gt;<br>&gt;   func print() {<br>&gt;     print(self.member)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; var example = Example(member: &quot;Hi!&quot;)<br>&gt;<br>&gt; var example_print_method = example.print<br>&gt; example_print_method()<br>&gt; result:<br>&gt; Hi!<br>&gt;<br>&gt; If there were a mechanism for referring to the getter and setter methods<br>&gt; on the var member property as the same kind of self-capturing closures, it<br>&gt; could make simple cases of data binding easier to implement:<br>&gt;<br>&gt; var serializeFields = [<br>&gt;   &quot;member&quot;: example.member#get,<br>&gt; ]<br>&gt;<br>&gt; var deserializeFields = [<br>&gt;   &quot;member&quot;: example.member#set,<br>&gt; ]<br>&gt;<br>&gt; var broadcastValueTo = [<br>&gt;   &quot;memberValues&quot;: [<br>&gt;      example.member#set,<br>&gt;      example2.member#set,<br>&gt;      example3.member#set,<br>&gt;   ]<br>&gt; ]<br>&gt;<br>&gt; viewController.textField.onValueChanged(example.member#set)<br>&gt;<br>&gt; Etc.<br>&gt;<br>&gt; The &quot;#&quot; notation is just a placeholder for &quot;whatever mechanism is decided<br>&gt; upon&quot;, though it does seem to be available and using it postfix makes a<br>&gt; first-glance sense to me in terms of the semantics of expressions.<br>&gt;<br>&gt; Mike<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/4d467efc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
