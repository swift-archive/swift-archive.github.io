<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Is it possible to use Swift for bare-metal programming on embedded devices? These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br></p><p>But bare metal development for all of them starts with emitting code with &quot;raw&quot; packaging (no Mach or ELF headers, etc.), and the ability to read and write specific memory addresses.<br></p><p>For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br></p><p>Most such development is done in C, and there is always some form of library to take on some of the standard library tasks and stub out basic IO, as well as filling in gaps for larger variable sizes not directly supported by the hardware.<br></p><p>I imagine there&#39;s some runtime support for ARC, although maybe that&#39;s handled entirely in the compilation phase?<br></p><p>Anyway, I&#39;d appreciate someone more knowledgable letting me know if this is something I should experiment with. Thanks!<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 10, 2016 at 05:00:00am</p></header><div class="content"><p>There&#39;s definitely a runtime, but I *think* you can avoid actually using it by being very careful with your data structures. ARC means that classes obviously trigger it, and I think it *might* be involved resizing arrays and strings (they do some tricks behind the scenes, but I can&#39;t remember what).<br></p><p>So... only use structs and don&#39;t resize anything? I&#39;m not sure... I think there might be some cases where protocols or indirect enums get stored as references, and that might involve the runtime as well.<br></p><p>Maybe you should go over to the evolution list and suggest a &quot;no runtime&quot; compiler flag or source code annotation, which disallows anything which would use the runtime. I believe there could be advantages outside of running on bare-metal, since you could use it to get the compiler to yell at you for doing overhead-inducing stuff in a loop, for example. <br></p><p>Anyway, best of luck :-)<br></p><p>- Dave Sweeris<br></p><p>&gt; On Aug 9, 2016, at 15:10, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Is it possible to use Swift for bare-metal programming on embedded devices? These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br>&gt; <br>&gt; But bare metal development for all of them starts with emitting code with &quot;raw&quot; packaging (no Mach or ELF headers, etc.), and the ability to read and write specific memory addresses.<br>&gt; <br>&gt; For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br>&gt; <br>&gt; Most such development is done in C, and there is always some form of library to take on some of the standard library tasks and stub out basic IO, as well as filling in gaps for larger variable sizes not directly supported by the hardware.<br>&gt; <br>&gt; I imagine there&#39;s some runtime support for ARC, although maybe that&#39;s handled entirely in the compilation phase?<br>&gt; <br>&gt; Anyway, I&#39;d appreciate someone more knowledgable letting me know if this is something I should experiment with. Thanks!<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 11, 2016 at 09:00:00pm</p></header><div class="content"><p>Even if you take care not to create class instances, the compiler emits many calls to runtime functions to implement features such as generics, casts and existentials. It is possible to write code where a large number of runtime calls are optimized away, but I don’t think they can be eliminated completely.<br></p><p>If anyone is interested in taking this on as a community project, it would be a fair amount of work, but I think the first step could be to add compiler flags where calls to runtime functions become diagnostics. Again though, I’m not sure how much effort it would take to eliminate them completely.<br></p><p>Slava<br></p><p>&gt; On Aug 10, 2016, at 3:28 AM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s definitely a runtime, but I *think* you can avoid actually using it by being very careful with your data structures. ARC means that classes obviously trigger it, and I think it *might* be involved resizing arrays and strings (they do some tricks behind the scenes, but I can&#39;t remember what).<br>&gt; <br>&gt; So... only use structs and don&#39;t resize anything? I&#39;m not sure... I think there might be some cases where protocols or indirect enums get stored as references, and that might involve the runtime as well.<br>&gt; <br>&gt; Maybe you should go over to the evolution list and suggest a &quot;no runtime&quot; compiler flag or source code annotation, which disallows anything which would use the runtime. I believe there could be advantages outside of running on bare-metal, since you could use it to get the compiler to yell at you for doing overhead-inducing stuff in a loop, for example. <br>&gt; <br>&gt; Anyway, best of luck :-)<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Aug 9, 2016, at 15:10, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is it possible to use Swift for bare-metal programming on embedded devices? These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br>&gt;&gt; <br>&gt;&gt; But bare metal development for all of them starts with emitting code with &quot;raw&quot; packaging (no Mach or ELF headers, etc.), and the ability to read and write specific memory addresses.<br>&gt;&gt; <br>&gt;&gt; For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br>&gt;&gt; <br>&gt;&gt; Most such development is done in C, and there is always some form of library to take on some of the standard library tasks and stub out basic IO, as well as filling in gaps for larger variable sizes not directly supported by the hardware.<br>&gt;&gt; <br>&gt;&gt; I imagine there&#39;s some runtime support for ARC, although maybe that&#39;s handled entirely in the compilation phase?<br>&gt;&gt; <br>&gt;&gt; Anyway, I&#39;d appreciate someone more knowledgable letting me know if this is something I should experiment with. Thanks!<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Well, even C++ requires some amount of run time. On a larger MCU, the runtime shouldn&#39;t be a problem at all. What I want to do is minimize the amount of OS I have to implement. For example, using newlib (https://sourceware.org/newlib/), I can stub out 20-odd functions, and everything gets statically linked into a monolithic block of code that is a combination of my code, the runtime, and those 20-odd function stubs. A special chunk of code, usually containing assembly language, ensures the processor and MMU are properly set up just after boot, and you&#39;re off to the races.<br></p><p>I imagine there will be additional burden to support threading and GCD (which would be nice to have). But before that, supporting synchronization and interrupt routines.<br></p><p>Ah, interrupt routines. Is there any way to mark a function as &quot;naked&quot; in Swift? How would I request that feature?<br></p><p>&gt; On Aug 11, 2016, at 21:46 , Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; Even if you take care not to create class instances, the compiler emits many calls to runtime functions to implement features such as generics, casts and existentials. It is possible to write code where a large number of runtime calls are optimized away, but I don’t think they can be eliminated completely.<br>&gt; <br>&gt; If anyone is interested in taking this on as a community project, it would be a fair amount of work, but I think the first step could be to add compiler flags where calls to runtime functions become diagnostics. Again though, I’m not sure how much effort it would take to eliminate them completely.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; On Aug 10, 2016, at 3:28 AM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There&#39;s definitely a runtime, but I *think* you can avoid actually using it by being very careful with your data structures. ARC means that classes obviously trigger it, and I think it *might* be involved resizing arrays and strings (they do some tricks behind the scenes, but I can&#39;t remember what).<br>&gt;&gt; <br>&gt;&gt; So... only use structs and don&#39;t resize anything? I&#39;m not sure... I think there might be some cases where protocols or indirect enums get stored as references, and that might involve the runtime as well.<br>&gt;&gt; <br>&gt;&gt; Maybe you should go over to the evolution list and suggest a &quot;no runtime&quot; compiler flag or source code annotation, which disallows anything which would use the runtime. I believe there could be advantages outside of running on bare-metal, since you could use it to get the compiler to yell at you for doing overhead-inducing stuff in a loop, for example. <br>&gt;&gt; <br>&gt;&gt; Anyway, best of luck :-)<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 9, 2016, at 15:10, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it possible to use Swift for bare-metal programming on embedded devices? These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But bare metal development for all of them starts with emitting code with &quot;raw&quot; packaging (no Mach or ELF headers, etc.), and the ability to read and write specific memory addresses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most such development is done in C, and there is always some form of library to take on some of the standard library tasks and stub out basic IO, as well as filling in gaps for larger variable sizes not directly supported by the hardware.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I imagine there&#39;s some runtime support for ARC, although maybe that&#39;s handled entirely in the compilation phase?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, I&#39;d appreciate someone more knowledgable letting me know if this is something I should experiment with. Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 15, 2016 at 05:00:00pm</p></header><div class="content"><p>I don&#39;t know what you mean by &quot;naked function&quot;, but you&#39;d request it by starting a thread on swift evolution (which I would encourage you to do).<br></p><p>- Dave Sweeris<br></p><p>&gt; On Aug 15, 2016, at 17:36, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; Well, even C++ requires some amount of run time. On a larger MCU, the runtime shouldn&#39;t be a problem at all. What I want to do is minimize the amount of OS I have to implement. For example, using newlib (https://sourceware.org/newlib/), I can stub out 20-odd functions, and everything gets statically linked into a monolithic block of code that is a combination of my code, the runtime, and those 20-odd function stubs. A special chunk of code, usually containing assembly language, ensures the processor and MMU are properly set up just after boot, and you&#39;re off to the races.<br>&gt; <br>&gt; I imagine there will be additional burden to support threading and GCD (which would be nice to have). But before that, supporting synchronization and interrupt routines.<br>&gt; <br>&gt; Ah, interrupt routines. Is there any way to mark a function as &quot;naked&quot; in Swift? How would I request that feature?<br>&gt; <br>&gt;&gt; On Aug 11, 2016, at 21:46 , Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Even if you take care not to create class instances, the compiler emits many calls to runtime functions to implement features such as generics, casts and existentials. It is possible to write code where a large number of runtime calls are optimized away, but I don’t think they can be eliminated completely.<br>&gt;&gt; <br>&gt;&gt; If anyone is interested in taking this on as a community project, it would be a fair amount of work, but I think the first step could be to add compiler flags where calls to runtime functions become diagnostics. Again though, I’m not sure how much effort it would take to eliminate them completely.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 10, 2016, at 3:28 AM, David Sweeris via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s definitely a runtime, but I *think* you can avoid actually using it by being very careful with your data structures. ARC means that classes obviously trigger it, and I think it *might* be involved resizing arrays and strings (they do some tricks behind the scenes, but I can&#39;t remember what).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So... only use structs and don&#39;t resize anything? I&#39;m not sure... I think there might be some cases where protocols or indirect enums get stored as references, and that might involve the runtime as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe you should go over to the evolution list and suggest a &quot;no runtime&quot; compiler flag or source code annotation, which disallows anything which would use the runtime. I believe there could be advantages outside of running on bare-metal, since you could use it to get the compiler to yell at you for doing overhead-inducing stuff in a loop, for example. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, best of luck :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 9, 2016, at 15:10, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is it possible to use Swift for bare-metal programming on embedded devices? These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But bare metal development for all of them starts with emitting code with &quot;raw&quot; packaging (no Mach or ELF headers, etc.), and the ability to read and write specific memory addresses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Most such development is done in C, and there is always some form of library to take on some of the standard library tasks and stub out basic IO, as well as filling in gaps for larger variable sizes not directly supported by the hardware.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I imagine there&#39;s some runtime support for ARC, although maybe that&#39;s handled entirely in the compilation phase?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway, I&#39;d appreciate someone more knowledgable letting me know if this is something I should experiment with. Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Aug 15, 2016, at 3:36 PM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; Well, even C++ requires some amount of run time. On a larger MCU, the runtime shouldn&#39;t be a problem at all. What I want to do is minimize the amount of OS I have to implement. For example, using newlib (https://sourceware.org/newlib/ &lt;https://sourceware.org/newlib/&gt;), I can stub out 20-odd functions, and everything gets statically linked into a monolithic block of code that is a combination of my code, the runtime, and those 20-odd function stubs. A special chunk of code, usually containing assembly language, ensures the processor and MMU are properly set up just after boot, and you&#39;re off to the races.<br>&gt; <br>&gt; I imagine there will be additional burden to support threading and GCD (which would be nice to have). But before that, supporting synchronization and interrupt routines.<br>&gt; <br>&gt; Ah, interrupt routines. Is there any way to mark a function as &quot;naked&quot; in Swift? How would I request that feature?<br></p><p>This would require significant design work. The main problem is that the Swift runtime is not re-entrant, because typical malloc() implementations are not re-entrant, and also because of how metadata caching uses locks. So even if you could emit a function with the right calling convention, it wouldn&#39;t be safe to use as an interrupt handler.<br></p><p>Slava<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160816/4b4909be/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>August 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 1:10 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br></p><p>I have never seen the Swift source code, but I’d be surprised if Swift binaries didn’t require at least the standard C runtime library. (It’s pretty hard to get anything done without at least having malloc/free!)<br></p><p>Don’t forget that the binary will have to include the implementations of the standard Swift library classes, at least the ones used by your program. I’m sure String in particular is a significant chunk of code, since it has to do all kinds of Unicode stuff. (In fact it might have a dependency on ICU, which is a pretty hefty C library.)<br></p><p>&gt; These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br></p><p>Arduinos are probably right out, since there’s no way anyone’s going to port Swift to an 8-bit CPU!<br></p><p>If you’re going for something bigger than that, why not just use a Raspberry Pi or C.H.I.P. or one of the other tiny ARM PC boards? They all run Linux, and I believe people are already working on porting Swift to run on those. C.H.I.P. costs $9, and I saw a blurb somewhere about a competitor that’s only $5.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160810/d5bb6afa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>August 10, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Aug 10, 2016, at 08:31, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 9, 2016, at 1:10 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For the smaller devices, runtime library overhead is a concern (mostly due to code size). Is it possible to write swift code with no runtime library? I think this is possible in Rust (came up on another list).<br>&gt; <br>&gt; I have never seen the Swift source code, but I’d be surprised if Swift binaries didn’t require at least the standard C runtime library. (It’s pretty hard to get anything done without at least having malloc/free!)<br>&gt; <br>&gt; Don’t forget that the binary will have to include the implementations of the standard Swift library classes, at least the ones used by your program. I’m sure String in particular is a significant chunk of code, since it has to do all kinds of Unicode stuff. (In fact it might have a dependency on ICU, which is a pretty hefty C library.)<br>&gt; <br>&gt;&gt; These devices usually have memory-mapped registers that are read and written to affect the operation of the device. Some can be quite small (e.g. 8-bit registers, simple single physical memory address space), and others quite robust (full 32- or 64-bit machines with MMUs, etc.).<br>&gt; <br>&gt; Arduinos are probably right out, since there’s no way anyone’s going to port Swift to an 8-bit CPU!<br>&gt; <br>&gt; If you’re going for something bigger than that, why not just use a Raspberry Pi or C.H.I.P. or one of the other tiny ARM PC boards? They all run Linux, and I believe people are already working on porting Swift to run on those.<br></p><p>Minor correction: Swift already builds and runs on the Raspberry Pi :)<br></p><p>&gt; C.H.I.P. costs $9, and I saw a blurb somewhere about a competitor that’s only $5.<br>&gt; <br>&gt; —Jens<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160810/07bd0ab3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Swift in bare-metal embedded programming/Swift runtime</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 09:31 , Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; If you’re going for something bigger than that, why not just use a Raspberry Pi or C.H.I.P. or one of the other tiny ARM PC boards? They all run Linux, and I believe people are already working on porting Swift to run on those. C.H.I.P. costs $9, and I saw a blurb somewhere about a competitor that’s only $5.<br></p><p>Well, that doesn&#39;t work for custom hardware, and importantly, I don&#39;t want to run Linux. It&#39;s very hard to make a fast-booting device with Linux.<br></p><p><br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
