<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br></p><p>I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>thoughts and preferences here. Here&#39;s my take on the issue:<br></p><p>When it comes to defining the categorization, I can see a few approaches: <br> Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br> Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br> Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br></p><p>And, of course, I think that preference should be given to how people would<br>actively like to use the categories to control warnings. For example, there&#39;s<br>a handful of warnings that makes less sense in a REPL or rapid experimentation<br>environment, such as variable_never_mutated.<br></p><p>Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>personally tied to these categorizations at all, I&#39;m just interested in there<br>being something simple and basic. Below is a list of every warning in Swift with<br>an attempt to put it under a category.<br></p><p><br>Deprecated:<br>    var_not_allowed_in_pattern<br>        &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>        &quot;removed in a future version of Swift&quot;<br>    deprecated_c_style_for_stmt<br>        &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>        &quot;version of Swift&quot;<br>    deprecated_convention_attribute<br>        &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>        &quot;instead&quot;<br>    availability_deprecated<br>        &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>        &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>    availability_deprecated_msg<br>        &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>        &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>    availability_deprecated_rename<br>        &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>        &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>    parameter_curry_syntax_removed<br>        &quot;curried function declaration syntax will be removed in a future &quot;<br>        &quot;version of Swift; use a single parameter list&quot;<br></p><p><br>Unsupported:<br>    warning_parallel_execution_not_supported<br>        &quot;parallel execution not supported; falling back to serial execution&quot;<br>    unsupported_synthesize_init_variadic<br>        &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>        &quot;unsupported&quot;<br></p><p><br>Stylistic/Pedantic/Cleanliness:<br>    pbd_never_used_stmtcond<br>        &quot;value %0 was defined but never used; consider replacing &quot;<br>        &quot;with boolean test&quot;<br>    pbd_never_used<br>        &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>        &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>    capture_never_used<br>        &quot;capture %0 was never used&quot;,<br>    variable_never_used<br>        &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>        &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>    variable_never_mutated<br>        &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>        &quot;consider changing to &#39;let&#39; constant&quot;<br>    variable_never_read<br>        &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>    expression_unused_result<br>        &quot;result of call to %0 is unused&quot;<br>    expression_unused_init_result<br>        &quot;result of initializer is unused&quot;, ())<br>    expression_unused_result_message<br>        &quot;result of call to %0 is unused: %1&quot;<br>    expression_unused_result_nonmutating<br>        &quot;result of call to non-mutating function %0 is unused; &quot;<br>        &quot;use %1 to mutate in-place&quot;<br>    expression_unused_optional_try<br>        &quot;result of &#39;try?&#39; is unused&quot;<br>    non_trailing_closure_before_default_args<br>        &quot;closure parameter prior to parameters with default arguments will &quot;<br>        &quot;not be treated as a trailing closure&quot;<br>    parameter_extraneous_double_up<br>        &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>        &quot;label&quot;<br>    parameter_extraneous_empty_name<br>        &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>    escaped_parameter_name<br>        &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br></p><p><br>CodeSmell/StrongStylisticHints:<br>    guard_always_succeeds<br>        &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>    warn_unqualified_access<br>        &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>    var_pattern_didnt_bind_variables<br>        &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>    type_inferred_to_undesirable_type<br>        &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>        &quot;which may be unexpected&quot;<br>    no_throw_in_try<br>        &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>    no_throw_in_do_with_catch<br>        &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>    required_initializer_override_keyword<br>        &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>    if_always_true<br>        &quot;&#39;if&#39; condition is always true&quot;<br>    while_always_true<br>        &quot;&#39;while&#39; condition is always true&quot;<br>    warn_protocol_witness_optionality<br>        &quot;%select{type|result|parameter|parameters|&quot;<br>        &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>        &quot; different optionality than expected by protocol %2&quot;<br>    optional_req_nonobjc_near_match<br>        &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>        &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>    override_unnecessary_IUO<br>        &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>        &quot;type %2&quot;,<br>    override_unnecessary_result_IUO<br>        &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>        &quot;optional type %2&quot;,<br>    inject_forced_downcast, sema_tce, none,<br>        &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>    recursive_accessor_reference, tce_sema, none,<br>        &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>        &quot;%select{getter|setter}1&quot;,<br>    store_in_willset, tce_sema, none,<br>        &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>        &quot;about to be overwritten by the new value&quot;,<br>    isa_is_always_true<br>        &quot;&#39;%0&#39; test is always true&quot;,<br>    conditional_downcast_coercion<br>        &quot;conditional cast from %0 to %1 always succeeds&quot;<br>    downcast_to_unrelated, sema_tcc, none,<br>        &quot;cast from %0 to unrelated type %1 always fails&quot;<br>    forced_downcast_noop<br>        &quot;forced cast of %0 to same type has no effect&quot;<br>    forced_downcast_coercion<br>        &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>    extraneous_default_args_in_call<br>        &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>    unreachable_code<br>        &quot;will never be executed&quot;<br>    unreachable_code_after_stmt<br>        &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>        &quot;be executed&quot;<br>    unreachable_case<br>        &quot;%select{case|default}0 will never be executed&quot;<br>    switch_on_a_constant<br>        &quot;switch condition evaluates to a constant&quot;<br>    integer_conversion_overflow_warn<br>        &quot;integer overflows when converted from %0 to %1&quot;<br>    integer_literal_overflow_warn<br>        &quot;integer literal overflows when stored into %0&quot;<br>    trailing_closure_excess_newlines<br>        &quot;trailing closure is separated from call site by multiple newlines&quot;<br>    lex_nul_character, lexing, none<br>        &quot;nul character embedded in middle of file&quot;<br>    unindented_code_after_return<br>        &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>        &quot;the &#39;return&#39;&quot;<br>    lex_editor_placeholder_in_playground<br>        &quot;editor placeholder in source file&quot;<br></p><p><br>Attributes:<br>    attr_availability_unknown_platform<br>        &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>    attr_warn_unused_result_expected_name<br>        &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>    attr_warn_unused_result_duplicate_parameter<br>        &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>    attr_warn_unused_result_unknown_parameter<br>        &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>    attr_migration_id_expected_name<br>        &quot;expected parameter &#39;pattern&#39;&quot;<br>    attr_migration_id_unknown_parameter<br>        &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>    attr_migration_id_duplicate_parameter<br>        &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>    invalid_swift_name_method<br>        &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>        &quot;got %2)&quot;<br></p><p>Availability:<br>    availability_query_useless_min_deployment<br>        &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>        &quot;will always be true&quot;<br>    availability_query_useless_enclosing_scope<br>        &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>        &quot;will always be true&quot;<br></p><p>And the below I&#39;m either struggling to think about how to categorize them<br>(perhaps no category at first), or un-familiar with what they&#39;re targeting<br>    warning_from_clang:<br>        &quot;%0&quot;<br>    could_not_rewrite_bridging_header, none, none,<br>        &quot;failed to serialize bridging header; &quot;<br>        &quot;target may not be debuggable outside of its original project&quot;<br>    omit_needless_words<br>        &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>    unused_compiler_version_component<br>        &quot;the second version component is not used for comparison&quot;<br>    unknown_build_config<br>        &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>    sema_import_current_module<br>        &quot;this file is part of module %0; ignoring import&quot;<br>    sema_import_current_module_with_file<br>        &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>    access_control_member_more<br>        &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>        &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>    access_control_ext_member_more<br>        &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>        &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>    emit_reference_dependencies_without_primary_file<br>        &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>    warning_no_such_sdk<br>        &quot;no such SDK: &#39;%0&#39;&quot;<br>    warn_cannot_stat_input<br>        &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>    warning_unnecessary_repl_mode<br>        &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>        &quot;with no input files&quot;<br>    incremental_requires_output_file_map<br>        &quot;ignoring -incremental (currently requires an output file map)&quot;<br>    incremental_requires_build_record_entry<br>        &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>        &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br></p><p>I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/00f5cf90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 12, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, Jan 12, 2016 at 9:44 AM, Michael Ilseman via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization.<br>&gt;<br>&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;<br>&gt; When it comes to defining the categorization, I can see a few approaches:<br>&gt;<br>&gt;    1.  Categorize based on broad language-feature/compiler-area. E.g.<br>&gt;    &quot;Availability&quot; or “CommandLineArguments”<br>&gt;    2.  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or<br>&gt;     “Uninitialized&quot;<br>&gt;    3.  Categorize based on severity or specificity of warnings. E.g.<br>&gt;    &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;<br>&gt;<br>&gt; And, of course, I think that preference should be given to how people would<br>&gt; actively like to use the categories to control warnings. For example,<br>&gt; there&#39;s<br>&gt; a handful of warnings that makes less sense in a REPL or rapid<br>&gt; experimentation<br>&gt; environment, such as variable_never_mutated.<br>&gt;<br></p><p>Since we try to keep warnings on-by-default, the primary usecase will<br>probably be disabling warnings that are somehow inappropriate for the<br>project.<br></p><p>Here&#39;s a straw-man proposal of some categorization. Of course, one<br>&gt; developer&#39;s<br>&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I<br>&gt; am not<br>&gt; personally tied to these categorizations at all, I&#39;m just interested in<br>&gt; there<br>&gt; being something simple and basic. Below is a list of every warning in<br>&gt; Swift with<br>&gt; an attempt to put it under a category.<br>&gt;<br>&gt;<br>&gt; Deprecated:<br>&gt;     var_not_allowed_in_pattern<br>&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be<br>&gt; &quot;<br>&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;     deprecated_c_style_for_stmt<br>&gt;         &quot;C-style for statement is deprecated and will be removed in a<br>&gt; future &quot;<br>&gt;         &quot;version of Swift&quot;<br>&gt;     deprecated_convention_attribute<br>&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;         &quot;instead&quot;<br>&gt;     availability_deprecated<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;     availability_deprecated_msg<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;     availability_deprecated_rename<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;     parameter_curry_syntax_removed<br>&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;<br></p><p>I think there should be separate categories for deprecated language<br>features and deprecated APIs.<br></p><p><br>&gt; Unsupported:<br>&gt;     warning_parallel_execution_not_supported<br>&gt;         &quot;parallel execution not supported; falling back to serial<br>&gt; execution&quot;<br>&gt;     unsupported_synthesize_init_variadic<br>&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;         &quot;unsupported&quot;<br>&gt;<br>&gt;<br>&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;     pbd_never_used_stmtcond<br>&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;         &quot;with boolean test&quot;<br>&gt;     pbd_never_used<br>&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never<br>&gt; used&quot;<br>&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;     capture_never_used<br>&gt;         &quot;capture %0 was never used&quot;,<br>&gt;     variable_never_used<br>&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;     variable_never_mutated<br>&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;     variable_never_read<br>&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;     expression_unused_result<br>&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;     expression_unused_init_result<br>&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;     expression_unused_result_message<br>&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;     expression_unused_result_nonmutating<br>&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;     expression_unused_optional_try<br>&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;     non_trailing_closure_before_default_args<br>&gt;         &quot;closure parameter prior to parameters with default arguments will<br>&gt; &quot;<br>&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;     parameter_extraneous_double_up<br>&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;         &quot;label&quot;<br>&gt;     parameter_extraneous_empty_name<br>&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;     escaped_parameter_name<br>&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;<br>&gt;<br>&gt; CodeSmell/StrongStylisticHints:<br>&gt;     guard_always_succeeds<br>&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;     warn_unqualified_access<br>&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;     var_pattern_didnt_bind_variables<br>&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;     type_inferred_to_undesirable_type<br>&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;         &quot;which may be unexpected&quot;<br>&gt;     no_throw_in_try<br>&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;     no_throw_in_do_with_catch<br>&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39;<br>&gt; block&quot;<br>&gt;<br></p><p>It seems like some of these can be too pedantic in cross-platform code<br>bases because of #if&#39;s that are not analyzable and might need more granular<br>suppression mechanisms.   For example:<br></p><p>func foo() throws {}<br>func bar() {}<br></p><p>func baz() {<br>  do {<br>#if os(OSX)<br>    try foo()<br>#else<br>    bar()<br>#endif<br>    // common code.<br>  } catch { // on non-OS X, warning: &#39;catch&#39; block is unreachable because<br>no errors are thrown in &#39;do&#39; block<br>    // ...<br>  }<br>}<br></p><p>I definitely remember we had some similar issues in the standard library or<br>tests, but don&#39;t remember the specifics.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/de61e053/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 1:24 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Jan 12, 2016 at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt; <br>&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt; <br>&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt; <br>&gt; And, of course, I think that preference should be given to how people would<br>&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt; environment, such as variable_never_mutated.<br>&gt; <br>&gt; Since we try to keep warnings on-by-default, the primary usecase will probably be disabling warnings that are somehow inappropriate for the project.<br>&gt; <br></p><p>That makes sense.<br></p><p>&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt; an attempt to put it under a category.<br>&gt; <br>&gt; <br>&gt; Deprecated:<br>&gt;     var_not_allowed_in_pattern<br>&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;     deprecated_c_style_for_stmt<br>&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;         &quot;version of Swift&quot;<br>&gt;     deprecated_convention_attribute<br>&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;         &quot;instead&quot;<br>&gt;     availability_deprecated<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;     availability_deprecated_msg<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;     availability_deprecated_rename<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;     parameter_curry_syntax_removed<br>&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt; <br>&gt; I think there should be separate categories for deprecated language features and deprecated APIs.<br></p><p>It might also make sense for there to be a DeprecatedTooling or some such for deprecated command line flags, etc. Here’s it broken down some more:<br></p><p>DeprecatedLanguage:<br>    var_not_allowed_in_pattern<br>        &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>        &quot;removed in a future version of Swift&quot;<br>    deprecated_c_style_for_stmt<br>        &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>        &quot;version of Swift&quot;<br>    deprecated_convention_attribute<br>        &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>        “instead&quot;<br>    parameter_curry_syntax_removed<br>        &quot;curried function declaration syntax will be removed in a future &quot;<br>        &quot;version of Swift; use a single parameter list&quot;<br></p><p>DeprecatedAPI:<br>    availability_deprecated<br>        &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>        &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>    availability_deprecated_msg<br>        &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>        &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>    availability_deprecated_rename<br>        &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>        &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br></p><p>DeprecatedTooling:<br>  TBD<br></p><p>&gt;  <br>&gt; Unsupported:<br>&gt;     warning_parallel_execution_not_supported<br>&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;     unsupported_synthesize_init_variadic<br>&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;         &quot;unsupported&quot;<br>&gt; <br>&gt; <br>&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;     pbd_never_used_stmtcond<br>&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;         &quot;with boolean test&quot;<br>&gt;     pbd_never_used<br>&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;     capture_never_used<br>&gt;         &quot;capture %0 was never used&quot;,<br>&gt;     variable_never_used<br>&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;     variable_never_mutated<br>&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;     variable_never_read<br>&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;     expression_unused_result<br>&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;     expression_unused_init_result<br>&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;     expression_unused_result_message<br>&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;     expression_unused_result_nonmutating<br>&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;     expression_unused_optional_try<br>&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;     non_trailing_closure_before_default_args<br>&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;     parameter_extraneous_double_up<br>&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;         &quot;label&quot;<br>&gt;     parameter_extraneous_empty_name<br>&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;     escaped_parameter_name<br>&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt; <br>&gt; <br>&gt; CodeSmell/StrongStylisticHints:<br>&gt;     guard_always_succeeds<br>&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;     warn_unqualified_access<br>&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;     var_pattern_didnt_bind_variables<br>&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;     type_inferred_to_undesirable_type<br>&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;         &quot;which may be unexpected&quot;<br>&gt;     no_throw_in_try<br>&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;     no_throw_in_do_with_catch<br>&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt; <br>&gt; It seems like some of these can be too pedantic in cross-platform code bases because of #if&#39;s that are not analyzable and might need more granular suppression mechanisms.   For example:<br>&gt; <br>&gt; func foo() throws {}<br>&gt; func bar() {}<br>&gt; <br>&gt; func baz() {<br>&gt;   do {<br>&gt; #if os(OSX)<br>&gt;     try foo()<br>&gt; #else<br>&gt;     bar()<br>&gt; #endif<br>&gt;     // common code.<br>&gt;   } catch { // on non-OS X, warning: &#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I definitely remember we had some similar issues in the standard library or tests, but don&#39;t remember the specifics.<br>&gt; <br></p><p>Ah, I didn’t think about that. I suppose classification is even more of a gray area than I thought. Do you think that certain ones are more likely than others to come up as a result of platform differences?<br></p><p>no_throw_in_do_with_catch, no_throw_in_try seem like prime examples. How often is it that platform differences yield always-true conditions or unreachable code?<br></p><p><br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/03c680e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 1:24 PM, Dmitri Gribenko via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;         &quot;which may be unexpected&quot;<br>&gt;     no_throw_in_try<br>&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;     no_throw_in_do_with_catch<br>&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt; <br>&gt; It seems like some of these can be too pedantic in cross-platform code bases because of #if&#39;s that are not analyzable and might need more granular suppression mechanisms.   For example:<br>&gt; <br>&gt; func foo() throws {}<br>&gt; func bar() {}<br>&gt; <br>&gt; func baz() {<br>&gt;   do {<br>&gt; #if os(OSX)<br>&gt;     try foo()<br>&gt; #else<br>&gt;     bar()<br>&gt; #endif<br>&gt;     // common code.<br>&gt;   } catch { // on non-OS X, warning: &#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I definitely remember we had some similar issues in the standard library or tests, but don&#39;t remember the specifics.<br></p><p>FWIW, one of the reasons we build an AST for disabled #if regions is so we can be smart about this sort of thing.  The fact that we don’t for this warning is a bug in the warning, not something we should use warning suppression to fix. <br></p><p>To give you an example of this in action, we currently warn on this:<br></p><p>func f() -&gt; Int {<br>  var x = 42   // warning: variable &#39;x&#39; was never mutated; consider changing to &#39;let&#39; constant<br>  return x<br>}<br></p><p>but are smart enough to not warn on this:<br></p><p>func f() -&gt; Int {<br>  var x = 42<br>#if false<br>  x = 12<br>#endif<br>  return x<br>}<br></p><p><br>We should do the same for catch blocks that have a try in a disabled region.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160118/49ed8191/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 10:34 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jan 12, 2016, at 1:24 PM, Dmitri Gribenko via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;     no_throw_in_try<br>&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39;<br>&gt;&gt; block&quot;<br>&gt;<br>&gt;<br>&gt; It seems like some of these can be too pedantic in cross-platform code bases<br>&gt; because of #if&#39;s that are not analyzable and might need more granular<br>&gt; suppression mechanisms.   For example:<br>&gt;<br>&gt; func foo() throws {}<br>&gt; func bar() {}<br>&gt;<br>&gt; func baz() {<br>&gt;   do {<br>&gt; #if os(OSX)<br>&gt;     try foo()<br>&gt; #else<br>&gt;     bar()<br>&gt; #endif<br>&gt;     // common code.<br>&gt;   } catch { // on non-OS X, warning: &#39;catch&#39; block is unreachable because no<br>&gt; errors are thrown in &#39;do&#39; block<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; I definitely remember we had some similar issues in the standard library or<br>&gt; tests, but don&#39;t remember the specifics.<br>&gt;<br>&gt;<br>&gt; FWIW, one of the reasons we build an AST for disabled #if regions is so we<br>&gt; can be smart about this sort of thing.  The fact that we don’t for this<br>&gt; warning is a bug in the warning, not something we should use warning<br>&gt; suppression to fix.<br></p><p>Yes, I understand that -- the fix is very simple, we just need to find<br>a &#39;try&#39; in disabled code.  My point is though, currently we are not<br>implementing this (nor fixing other false positives), and we are<br>producing warnings that developers in<br>the field can&#39;t do anything about, even as a workaround for the broken<br>compiler.  Another point is that especially with dataflow-based<br>warnings there will be edge cases that will be impractical to fix.<br></p><p>I think it is important to give developers in the field a tool to mark<br>false positives (either on a category, or a per-warning level), to<br>work around an imperfect compiler.  I totally agree that we should try<br>to fix the compiler, but engineers working with the today&#39;s imperfect<br>compiler need a tool to be effective with what they can use.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 18, 2016 at 11:00:00pm</p></header><div class="content"><p>On Jan 18, 2016, at 10:42 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, one of the reasons we build an AST for disabled #if regions is so we<br>&gt;&gt; can be smart about this sort of thing.  The fact that we don’t for this<br>&gt;&gt; warning is a bug in the warning, not something we should use warning<br>&gt;&gt; suppression to fix.<br>&gt; <br>&gt; Yes, I understand that -- the fix is very simple, we just need to find<br>&gt; a &#39;try&#39; in disabled code.  My point is though, currently we are not<br>&gt; implementing this (nor fixing other false positives),<br></p><p>Uh, yes, we are fixing these things.  I could find zero reports complaining about this in either radar or Jira, which is why I didn’t know that this was an issue affecting people.<br></p><p>I fixed this in 2f5af05, if you know of other similar issues, please let me know.<br></p><p>&gt; and we are producing warnings that developers in<br>&gt; the field can&#39;t do anything about, even as a workaround for the broken<br>&gt; compiler.  <br></p><p>I would rather that we fix the broken compiler.  We do care about QoI in fact.<br></p><p>&gt; Another point is that especially with dataflow-based<br>&gt; warnings there will be edge cases that will be impractical to fix.<br></p><p>Please provide some specific details here.  The design of our dataflow warnings is specifically intended to make sure they are actionable and do not have false positives that cannot be solved in a reasonable way.<br></p><p>&gt; I think it is important to give developers in the field a tool to mark<br>&gt; false positives (either on a category, or a per-warning level), to<br>&gt; work around an imperfect compiler.  I totally agree that we should try<br>&gt; to fix the compiler, but engineers working with the today&#39;s imperfect<br>&gt; compiler need a tool to be effective with what they can use.<br></p><p>Despite my pushback, I agree with you that local control over warnings is a useful thing to have.  However, I don’t find the argument of “the compiler generates bogus warnings sometimes and users should silence them instead of having us fix the compiler” to be the right motivator.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt; <br>&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt; <br>&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt; <br>&gt; And, of course, I think that preference should be given to how people would<br>&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt; environment, such as variable_never_mutated.<br>&gt; <br>&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt; an attempt to put it under a category.<br>&gt; <br>&gt; <br>&gt; Deprecated:<br>&gt;     var_not_allowed_in_pattern<br>&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;     deprecated_c_style_for_stmt<br>&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;         &quot;version of Swift&quot;<br>&gt;     deprecated_convention_attribute<br>&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;         &quot;instead&quot;<br>&gt;     availability_deprecated<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;     availability_deprecated_msg<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;     availability_deprecated_rename<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;     parameter_curry_syntax_removed<br>&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt; <br>&gt; <br>&gt; Unsupported:<br>&gt;     warning_parallel_execution_not_supported<br>&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;     unsupported_synthesize_init_variadic<br>&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;         &quot;unsupported&quot;<br>&gt; <br>&gt; <br>&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;     pbd_never_used_stmtcond<br>&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;         &quot;with boolean test&quot;<br>&gt;     pbd_never_used<br>&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;     capture_never_used<br>&gt;         &quot;capture %0 was never used&quot;,<br>&gt;     variable_never_used<br>&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;     variable_never_mutated<br>&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;     variable_never_read<br>&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;     expression_unused_result<br>&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;     expression_unused_init_result<br>&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;     expression_unused_result_message<br>&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;     expression_unused_result_nonmutating<br>&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;     expression_unused_optional_try<br>&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;     non_trailing_closure_before_default_args<br>&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;     parameter_extraneous_double_up<br>&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;         &quot;label&quot;<br>&gt;     parameter_extraneous_empty_name<br>&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;     escaped_parameter_name<br>&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt; <br>&gt; <br>&gt; CodeSmell/StrongStylisticHints:<br>&gt;     guard_always_succeeds<br>&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;     warn_unqualified_access<br>&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;     var_pattern_didnt_bind_variables<br>&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;     type_inferred_to_undesirable_type<br>&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;         &quot;which may be unexpected&quot;<br>&gt;     no_throw_in_try<br>&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;     no_throw_in_do_with_catch<br>&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;     required_initializer_override_keyword<br>&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;     if_always_true<br>&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;     while_always_true<br>&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;     warn_protocol_witness_optionality<br>&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;     optional_req_nonobjc_near_match<br>&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;     override_unnecessary_IUO<br>&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;         &quot;type %2&quot;,<br>&gt;     override_unnecessary_result_IUO<br>&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;         &quot;optional type %2&quot;,<br>&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;     store_in_willset, tce_sema, none,<br>&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;     isa_is_always_true<br>&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;     conditional_downcast_coercion<br>&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;     forced_downcast_noop<br>&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;     forced_downcast_coercion<br>&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;     extraneous_default_args_in_call<br>&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;     unreachable_code<br>&gt;         &quot;will never be executed&quot;<br>&gt;     unreachable_code_after_stmt<br>&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;         &quot;be executed&quot;<br>&gt;     unreachable_case<br>&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;     switch_on_a_constant<br>&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;     integer_conversion_overflow_warn<br>&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;     integer_literal_overflow_warn<br>&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;     trailing_closure_excess_newlines<br>&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;     lex_nul_character, lexing, none<br>&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;     unindented_code_after_return<br>&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;     lex_editor_placeholder_in_playground<br>&gt;         &quot;editor placeholder in source file&quot;<br>&gt; <br>&gt; <br>&gt; Attributes:<br>&gt;     attr_availability_unknown_platform<br>&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;     attr_warn_unused_result_expected_name<br>&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;     attr_migration_id_expected_name<br>&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;     attr_migration_id_unknown_parameter<br>&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;     attr_migration_id_duplicate_parameter<br>&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;     invalid_swift_name_method<br>&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;         &quot;got %2)&quot;<br>&gt; <br>&gt; Availability:<br>&gt;     availability_query_useless_min_deployment<br>&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;         &quot;will always be true&quot;<br>&gt;     availability_query_useless_enclosing_scope<br>&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;         &quot;will always be true&quot;<br>&gt; <br>&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;     warning_from_clang:<br>&gt;         &quot;%0&quot;<br>&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;     omit_needless_words<br>&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;     unused_compiler_version_component<br>&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;     unknown_build_config<br>&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;     sema_import_current_module<br>&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;     sema_import_current_module_with_file<br>&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;     access_control_member_more<br>&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;     access_control_ext_member_more<br>&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;     emit_reference_dependencies_without_primary_file<br>&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;     warning_no_such_sdk<br>&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;     warn_cannot_stat_input<br>&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;     warning_unnecessary_repl_mode<br>&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;         &quot;with no input files&quot;<br>&gt;     incremental_requires_output_file_map<br>&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;     incremental_requires_build_record_entry<br>&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt; <br>&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br></p><p>Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br></p><p>Michael<br></p><p>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/104c2a5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>By keeping it in mind, do you mean to allow for more categories to be added in the future, or does this affect the fundamental design?<br></p><p>&gt; On Jan 12, 2016, at 5:06 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt; <br>&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt; <br>&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt; <br>&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt; an attempt to put it under a category.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Deprecated:<br>&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;     availability_deprecated<br>&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unsupported:<br>&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;     pbd_never_used<br>&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;     capture_never_used<br>&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;     variable_never_used<br>&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;     variable_never_mutated<br>&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;     variable_never_read<br>&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;     expression_unused_result<br>&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;     expression_unused_init_result<br>&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;     expression_unused_result_message<br>&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;         &quot;label&quot;<br>&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;     escaped_parameter_name<br>&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;     guard_always_succeeds<br>&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;     warn_unqualified_access<br>&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;     no_throw_in_try<br>&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;     if_always_true<br>&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;     while_always_true<br>&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;     isa_is_always_true<br>&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;     forced_downcast_noop<br>&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;     unreachable_code<br>&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;     unreachable_case<br>&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;     switch_on_a_constant<br>&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;     unindented_code_after_return<br>&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Attributes:<br>&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt; <br>&gt;&gt; Availability:<br>&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt; <br>&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;     warning_from_clang:<br>&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;     omit_needless_words<br>&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;     unknown_build_config<br>&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;     sema_import_current_module<br>&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;     access_control_member_more<br>&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt; <br>&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt; <br>&gt; Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/a48fa943/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>January 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 5:15 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; By keeping it in mind, do you mean to allow for more categories to be added in the future, or does this affect the fundamental design?<br></p><p>Not that I have much opinion here but to answer your question, the motivation for suppressing them would be unique, so they would simply go under a new category.<br></p><p>Likewise, the more arcane warnings could go uncategorized until there’s a need to suppress them as a separate group. Although at first glance it looks like several of those fall under “command line user interface”.<br></p><p>Andy <br></p><p>&gt;&gt; On Jan 12, 2016, at 5:06 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt;&gt; an attempt to put it under a category.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Deprecated:<br>&gt;&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;&gt;     availability_deprecated<br>&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unsupported:<br>&gt;&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;&gt;     pbd_never_used<br>&gt;&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;     capture_never_used<br>&gt;&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;&gt;     variable_never_used<br>&gt;&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;     variable_never_mutated<br>&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;&gt;     variable_never_read<br>&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;&gt;     expression_unused_result<br>&gt;&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;&gt;     expression_unused_init_result<br>&gt;&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;&gt;     expression_unused_result_message<br>&gt;&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;&gt;         &quot;label&quot;<br>&gt;&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;&gt;     escaped_parameter_name<br>&gt;&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;&gt;     guard_always_succeeds<br>&gt;&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;&gt;     warn_unqualified_access<br>&gt;&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;&gt;     no_throw_in_try<br>&gt;&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;&gt;     if_always_true<br>&gt;&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;&gt;     while_always_true<br>&gt;&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;&gt;     isa_is_always_true<br>&gt;&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;&gt;     forced_downcast_noop<br>&gt;&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;&gt;     unreachable_code<br>&gt;&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;&gt;     unreachable_case<br>&gt;&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;&gt;     switch_on_a_constant<br>&gt;&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;&gt;     unindented_code_after_return<br>&gt;&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Attributes:<br>&gt;&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Availability:<br>&gt;&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;&gt;     warning_from_clang:<br>&gt;&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;&gt;     omit_needless_words<br>&gt;&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;&gt;     unknown_build_config<br>&gt;&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;&gt;     sema_import_current_module<br>&gt;&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;&gt;     access_control_member_more<br>&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt;&gt; <br>&gt;&gt; Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/46d0f5c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>Michael and I spoke about this offline. The main things that I wanted to make sure was that it would be extensible and that warnings from SIL would be first class citizens in terms of API, etc. Overall, I was more just trying to give him food for thought.<br></p><p>Michael<br></p><p>&gt; On Jan 12, 2016, at 9:42 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:15 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; By keeping it in mind, do you mean to allow for more categories to be added in the future, or does this affect the fundamental design?<br>&gt; <br>&gt; Not that I have much opinion here but to answer your question, the motivation for suppressing them would be unique, so they would simply go under a new category.<br>&gt; <br>&gt; Likewise, the more arcane warnings could go uncategorized until there’s a need to suppress them as a separate group. Although at first glance it looks like several of those fall under “command line user interface”.<br>&gt; <br>&gt; Andy <br>&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 5:06 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt;&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt;&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt;&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt;&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt;&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt;&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt;&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt;&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt;&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt;&gt;&gt; an attempt to put it under a category.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Deprecated:<br>&gt;&gt;&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unsupported:<br>&gt;&gt;&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;&gt;&gt;     pbd_never_used<br>&gt;&gt;&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;&gt;     capture_never_used<br>&gt;&gt;&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;&gt;&gt;     variable_never_used<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;&gt;     variable_never_mutated<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;&gt;&gt;     variable_never_read<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_result<br>&gt;&gt;&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_init_result<br>&gt;&gt;&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;&gt;&gt;     expression_unused_result_message<br>&gt;&gt;&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;&gt;&gt;         &quot;label&quot;<br>&gt;&gt;&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;&gt;&gt;     escaped_parameter_name<br>&gt;&gt;&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;&gt;&gt;     guard_always_succeeds<br>&gt;&gt;&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;&gt;&gt;     warn_unqualified_access<br>&gt;&gt;&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;&gt;&gt;     no_throw_in_try<br>&gt;&gt;&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;&gt;&gt;     if_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;&gt;&gt;     while_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;&gt;&gt;     isa_is_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;&gt;&gt;     forced_downcast_noop<br>&gt;&gt;&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;&gt;&gt;     unreachable_code<br>&gt;&gt;&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;&gt;&gt;     unreachable_case<br>&gt;&gt;&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;&gt;&gt;     switch_on_a_constant<br>&gt;&gt;&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;&gt;&gt;     unindented_code_after_return<br>&gt;&gt;&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attributes:<br>&gt;&gt;&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Availability:<br>&gt;&gt;&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt;&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;&gt;&gt;     warning_from_clang:<br>&gt;&gt;&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;&gt;&gt;     omit_needless_words<br>&gt;&gt;&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;&gt;&gt;     unknown_build_config<br>&gt;&gt;&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;&gt;&gt;     sema_import_current_module<br>&gt;&gt;&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;&gt;&gt;     access_control_member_more<br>&gt;&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/ed7c7a4e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d631f09a3a336a15ae258e01899cb736?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Kate Stone</string> &lt;k8stone at apple.com&gt;<p>January 13, 2016 at 10:00:00am</p></header><div class="content"><p>Ideally I can see wanting to have multiple overlapping categorization schemes.  It’s pretty much axiomatic than any classification strategy involves tradeoffs, so allowing more than one is the only approach that makes sense.  I may well want to turn off all warnings introduced after Swift 2.2, or enable only warnings for which Fix-It improvements are provided, or any other orthogonal conceptual collection.<br></p><p>Not that every conceivable collection should be supported, but the general notion that there could be overlapping categories seems worth considering.<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>&gt; On Jan 12, 2016, at 5:15 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; By keeping it in mind, do you mean to allow for more categories to be added in the future, or does this affect the fundamental design?<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:06 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt;&gt; an attempt to put it under a category.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Deprecated:<br>&gt;&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;&gt;     availability_deprecated<br>&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unsupported:<br>&gt;&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;&gt;     pbd_never_used<br>&gt;&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;     capture_never_used<br>&gt;&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;&gt;     variable_never_used<br>&gt;&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;     variable_never_mutated<br>&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;&gt;     variable_never_read<br>&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;&gt;     expression_unused_result<br>&gt;&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;&gt;     expression_unused_init_result<br>&gt;&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;&gt;     expression_unused_result_message<br>&gt;&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;&gt;         &quot;label&quot;<br>&gt;&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;&gt;     escaped_parameter_name<br>&gt;&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;&gt;     guard_always_succeeds<br>&gt;&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;&gt;     warn_unqualified_access<br>&gt;&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;&gt;     no_throw_in_try<br>&gt;&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;&gt;     if_always_true<br>&gt;&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;&gt;     while_always_true<br>&gt;&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;&gt;     isa_is_always_true<br>&gt;&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;&gt;     forced_downcast_noop<br>&gt;&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;&gt;     unreachable_code<br>&gt;&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;&gt;     unreachable_case<br>&gt;&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;&gt;     switch_on_a_constant<br>&gt;&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;&gt;     unindented_code_after_return<br>&gt;&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Attributes:<br>&gt;&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Availability:<br>&gt;&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;&gt;     warning_from_clang:<br>&gt;&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;&gt;     omit_needless_words<br>&gt;&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;&gt;     unknown_build_config<br>&gt;&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;&gt;     sema_import_current_module<br>&gt;&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;&gt;     access_control_member_more<br>&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt;&gt; <br>&gt;&gt; Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/7d37caaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 10:20 AM, Kate Stone &lt;k8stone at apple.com&gt; wrote:<br>&gt; <br>&gt; Ideally I can see wanting to have multiple overlapping categorization schemes.  It’s pretty much axiomatic than any classification strategy involves tradeoffs, so allowing more than one is the only approach that makes sense.  I may well want to turn off all warnings introduced after Swift 2.2, or enable only warnings for which Fix-It improvements are provided, or any other orthogonal conceptual collection.<br>&gt; <br>&gt; Not that every conceivable collection should be supported, but the general notion that there could be overlapping categories seems worth considering.<br>&gt; <br></p><p>I had considered a tag-based mechanism rather than strict categories, but it seems to complicate both the user story and compiler maintenance. <br></p><p>With strict categories, the underlying mechanism for deciding how to present a warning can proceed as follows:<br>Honor local state (e.g. no more diagnostics after fatal), else<br>Honor specific warning specification, else<br>Honor categorical specification (e.g. ignore all pedantic language warnings), else<br>Honor global specification (e.g. all warnings are errors), else<br>Go with the default, declared handing (i.e. warn!)<br></p><p>This is easy and intuitive to communicate to the user on how to control it. If they bothered to single out a single warning, they probably care that it gets honored even if they gave a contradictory handling to its category or all warnings in general. When you talk about over-lapping categories and/or tags, step #3 become a much more complicated story to expose to the user. <br></p><p>When it comes to compiler maintenance, new warnings will need to undergo scrutiny not just about their overall category, but whether any existing tags apply to them (including tags relating to when it is introduced/modified). Given that we want to allow ourselves the ability to flexibly refine, redefine, or extend warnings, we may find ourselves in a less flexible position if we start to no longer adhere to every tag present. It seems like a recipe for over-engineering, at least at this stage in the project. The worse case is that the user has to specify at the individual level. <br></p><p>I’m not opposed to this, but after talking it over a bit it seemed hard to envision the benefits making the complexity worth it. When I implement the categories, I will try to take this potential future direction into account, and not needlessly paint us into a corner. It is certainly an interesting direction to investigate further along.<br></p><p>&gt; Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br>&gt;  Xcode Low Level Tools<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:15 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; By keeping it in mind, do you mean to allow for more categories to be added in the future, or does this affect the fundamental design?<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 5:06 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt;&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt;&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt;&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt;&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt;&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt;&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt;&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt;&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt;&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt;&gt;&gt; an attempt to put it under a category.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Deprecated:<br>&gt;&gt;&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unsupported:<br>&gt;&gt;&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;&gt;&gt;     pbd_never_used<br>&gt;&gt;&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;&gt;     capture_never_used<br>&gt;&gt;&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;&gt;&gt;     variable_never_used<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;&gt;     variable_never_mutated<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;&gt;&gt;     variable_never_read<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_result<br>&gt;&gt;&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_init_result<br>&gt;&gt;&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;&gt;&gt;     expression_unused_result_message<br>&gt;&gt;&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;&gt;&gt;         &quot;label&quot;<br>&gt;&gt;&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;&gt;&gt;     escaped_parameter_name<br>&gt;&gt;&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;&gt;&gt;     guard_always_succeeds<br>&gt;&gt;&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;&gt;&gt;     warn_unqualified_access<br>&gt;&gt;&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;&gt;&gt;     no_throw_in_try<br>&gt;&gt;&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;&gt;&gt;     if_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;&gt;&gt;     while_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;&gt;&gt;     isa_is_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;&gt;&gt;     forced_downcast_noop<br>&gt;&gt;&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;&gt;&gt;     unreachable_code<br>&gt;&gt;&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;&gt;&gt;     unreachable_case<br>&gt;&gt;&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;&gt;&gt;     switch_on_a_constant<br>&gt;&gt;&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;&gt;&gt;     unindented_code_after_return<br>&gt;&gt;&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attributes:<br>&gt;&gt;&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Availability:<br>&gt;&gt;&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt;&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;&gt;&gt;     warning_from_clang:<br>&gt;&gt;&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;&gt;&gt;     omit_needless_words<br>&gt;&gt;&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;&gt;&gt;     unknown_build_config<br>&gt;&gt;&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;&gt;&gt;     sema_import_current_module<br>&gt;&gt;&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;&gt;&gt;     access_control_member_more<br>&gt;&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/abd2701a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6520643611a05fd040d0abcee3c883c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Ted Kremenek</string> &lt;kremenek at apple.com&gt;<p>January 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 10:20 AM, Kate Stone via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Ideally I can see wanting to have multiple overlapping categorization schemes.  It’s pretty much axiomatic than any classification strategy involves tradeoffs, so allowing more than one is the only approach that makes sense.  I may well want to turn off all warnings introduced after Swift 2.2, or enable only warnings for which Fix-It improvements are provided, or any other orthogonal conceptual collection.<br>&gt; <br>&gt; Not that every conceivable collection should be supported, but the general notion that there could be overlapping categories seems worth considering.<br></p><p>I agree that this is useful.  The main concern I have is coming up with a good scheme to compose these categories.  With GCC and Clang, the order of -W and -Wno flags on the command line determine the resolution of enabled/disabled categories.  Some people think that is a good design.  Others a horrible one.  I&#39;m of mixed opinions.  It works well from the command line, as the order is clear, but a long command line can make it incomprehensible.  In an IDE, which may have a UI to control which categories are enabled, the composition of what is enabled and what isn&#39;t can become really hard to reason about if the categories can overlap.<br></p><p>&gt; <br>&gt; Kate Stone k8stone at apple.com<br>&gt;  Xcode Low Level Tools<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:15 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; By keeping it in mind, do you mean to allow for more categories to be added in the future, or does this affect the fundamental design?<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 12, 2016, at 5:06 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 12, 2016, at 9:44 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt;&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt;&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt;&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt;&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt;&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt;&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt;&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt;&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt;&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt;&gt;&gt; an attempt to put it under a category.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Deprecated:<br>&gt;&gt;&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unsupported:<br>&gt;&gt;&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;&gt;&gt;     pbd_never_used<br>&gt;&gt;&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;&gt;     capture_never_used<br>&gt;&gt;&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;&gt;&gt;     variable_never_used<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;&gt;&gt;     variable_never_mutated<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;&gt;&gt;     variable_never_read<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_result<br>&gt;&gt;&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_init_result<br>&gt;&gt;&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;&gt;&gt;     expression_unused_result_message<br>&gt;&gt;&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;&gt;&gt;         &quot;label&quot;<br>&gt;&gt;&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;&gt;&gt;     escaped_parameter_name<br>&gt;&gt;&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;&gt;&gt;     guard_always_succeeds<br>&gt;&gt;&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;&gt;&gt;     warn_unqualified_access<br>&gt;&gt;&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;&gt;&gt;     no_throw_in_try<br>&gt;&gt;&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;&gt;&gt;     if_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;&gt;&gt;     while_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;&gt;&gt;     isa_is_always_true<br>&gt;&gt;&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;&gt;&gt;     forced_downcast_noop<br>&gt;&gt;&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;&gt;&gt;     unreachable_code<br>&gt;&gt;&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;&gt;&gt;     unreachable_case<br>&gt;&gt;&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;&gt;&gt;     switch_on_a_constant<br>&gt;&gt;&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;&gt;&gt;     unindented_code_after_return<br>&gt;&gt;&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attributes:<br>&gt;&gt;&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Availability:<br>&gt;&gt;&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt;&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;&gt;&gt;     warning_from_clang:<br>&gt;&gt;&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;&gt;&gt;     omit_needless_words<br>&gt;&gt;&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;&gt;&gt;     unknown_build_config<br>&gt;&gt;&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;&gt;&gt;     sema_import_current_module<br>&gt;&gt;&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;&gt;&gt;     access_control_member_more<br>&gt;&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just an FYI: We have also talked about performance related warnings at the SIL level (that could potentially be a hard error). We do not have any such thing implemented right now, but keep it in mind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/206205a4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 13, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br></p><p>For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br></p><p>(We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br></p><p>I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br></p><p>Jordan<br></p><p>&gt; On Jan 12, 2016, at 9:44, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt; <br>&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt; <br>&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt; <br>&gt; And, of course, I think that preference should be given to how people would<br>&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt; environment, such as variable_never_mutated.<br>&gt; <br>&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt; an attempt to put it under a category.<br>&gt; <br>&gt; <br>&gt; Deprecated:<br>&gt;     var_not_allowed_in_pattern<br>&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;     deprecated_c_style_for_stmt<br>&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;         &quot;version of Swift&quot;<br>&gt;     deprecated_convention_attribute<br>&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;         &quot;instead&quot;<br>&gt;     availability_deprecated<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;     availability_deprecated_msg<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;     availability_deprecated_rename<br>&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;     parameter_curry_syntax_removed<br>&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt; <br>&gt; <br>&gt; Unsupported:<br>&gt;     warning_parallel_execution_not_supported<br>&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;     unsupported_synthesize_init_variadic<br>&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;         &quot;unsupported&quot;<br>&gt; <br>&gt; <br>&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;     pbd_never_used_stmtcond<br>&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;         &quot;with boolean test&quot;<br>&gt;     pbd_never_used<br>&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;     capture_never_used<br>&gt;         &quot;capture %0 was never used&quot;,<br>&gt;     variable_never_used<br>&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;     variable_never_mutated<br>&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;     variable_never_read<br>&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;     expression_unused_result<br>&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;     expression_unused_init_result<br>&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;     expression_unused_result_message<br>&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;     expression_unused_result_nonmutating<br>&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;     expression_unused_optional_try<br>&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;     non_trailing_closure_before_default_args<br>&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;     parameter_extraneous_double_up<br>&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;         &quot;label&quot;<br>&gt;     parameter_extraneous_empty_name<br>&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;     escaped_parameter_name<br>&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt; <br>&gt; <br>&gt; CodeSmell/StrongStylisticHints:<br>&gt;     guard_always_succeeds<br>&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;     warn_unqualified_access<br>&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;     var_pattern_didnt_bind_variables<br>&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;     type_inferred_to_undesirable_type<br>&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;         &quot;which may be unexpected&quot;<br>&gt;     no_throw_in_try<br>&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;     no_throw_in_do_with_catch<br>&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;     required_initializer_override_keyword<br>&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;     if_always_true<br>&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;     while_always_true<br>&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;     warn_protocol_witness_optionality<br>&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;     optional_req_nonobjc_near_match<br>&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;     override_unnecessary_IUO<br>&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;         &quot;type %2&quot;,<br>&gt;     override_unnecessary_result_IUO<br>&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;         &quot;optional type %2&quot;,<br>&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;     store_in_willset, tce_sema, none,<br>&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;     isa_is_always_true<br>&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;     conditional_downcast_coercion<br>&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;     forced_downcast_noop<br>&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;     forced_downcast_coercion<br>&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;     extraneous_default_args_in_call<br>&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;     unreachable_code<br>&gt;         &quot;will never be executed&quot;<br>&gt;     unreachable_code_after_stmt<br>&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;         &quot;be executed&quot;<br>&gt;     unreachable_case<br>&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;     switch_on_a_constant<br>&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;     integer_conversion_overflow_warn<br>&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;     integer_literal_overflow_warn<br>&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;     trailing_closure_excess_newlines<br>&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;     lex_nul_character, lexing, none<br>&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;     unindented_code_after_return<br>&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;     lex_editor_placeholder_in_playground<br>&gt;         &quot;editor placeholder in source file&quot;<br>&gt; <br>&gt; <br>&gt; Attributes:<br>&gt;     attr_availability_unknown_platform<br>&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;     attr_warn_unused_result_expected_name<br>&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;     attr_migration_id_expected_name<br>&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;     attr_migration_id_unknown_parameter<br>&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;     attr_migration_id_duplicate_parameter<br>&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;     invalid_swift_name_method<br>&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;         &quot;got %2)&quot;<br>&gt; <br>&gt; Availability:<br>&gt;     availability_query_useless_min_deployment<br>&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;         &quot;will always be true&quot;<br>&gt;     availability_query_useless_enclosing_scope<br>&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;         &quot;will always be true&quot;<br>&gt; <br>&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;     warning_from_clang:<br>&gt;         &quot;%0&quot;<br>&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;     omit_needless_words<br>&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;     unused_compiler_version_component<br>&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;     unknown_build_config<br>&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;     sema_import_current_module<br>&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;     sema_import_current_module_with_file<br>&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;     access_control_member_more<br>&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;     access_control_ext_member_more<br>&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;     emit_reference_dependencies_without_primary_file<br>&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;     warning_no_such_sdk<br>&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;     warn_cannot_stat_input<br>&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;     warning_unnecessary_repl_mode<br>&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;         &quot;with no input files&quot;<br>&gt;     incremental_requires_output_file_map<br>&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;     incremental_requires_build_record_entry<br>&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt; <br>&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/4f4759f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt; <br>&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt; <br>&gt; (We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br>&gt; <br></p><p>I’ll look more at REPL mode and see how to better generalize that. It’s more in line with what I’m trying to accomplish, and it may not make sense to categorize all the warnings in Swift so much as call out limited sub-sets. If that’s the case, and doing so is more so the exception than the rule, then I’m more amenable to tags and/or Kate’s suggestions.<br></p><p>&gt; I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br>&gt; <br></p><p>What about global flags, such as “-Werr” or equivalent? Do you have any thoughts about Dmitri’s point on multi-platform libraries and how they sometimes can trigger strict stylistic warnings excessively?<br></p><p>&gt; Jordan<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 9:44, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello, I&#39;m interested in enabling finer-grained control over warning/error<br>&gt;&gt; reporting ala Clang. I&#39;ve started to put in some infrastructure to<br>&gt;&gt; DiagnosticEngine, and now I&#39;m at the point of determining categorization. <br>&gt;&gt; <br>&gt;&gt; I&#39;d like some input (and maybe even some bikeshedding!) on the community&#39;s<br>&gt;&gt; thoughts and preferences here. Here&#39;s my take on the issue:<br>&gt;&gt; <br>&gt;&gt; When it comes to defining the categorization, I can see a few approaches: <br>&gt;&gt;  Categorize based on broad language-feature/compiler-area. E.g. &quot;Availability&quot; or “CommandLineArguments”<br>&gt;&gt;  Categorize based on the kind of warning. E.g. &quot;Deprecated&quot; or  “Uninitialized&quot;<br>&gt;&gt;  Categorize based on severity or specificity of warnings. E.g. &quot;Pedantic&quot; or &quot;UnusedValue&quot; or &quot;NullDereference&quot;<br>&gt;&gt; <br>&gt;&gt; And, of course, I think that preference should be given to how people would<br>&gt;&gt; actively like to use the categories to control warnings. For example, there&#39;s<br>&gt;&gt; a handful of warnings that makes less sense in a REPL or rapid experimentation<br>&gt;&gt; environment, such as variable_never_mutated.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a straw-man proposal of some categorization. Of course, one developer&#39;s<br>&gt;&gt; annoying pedantic warning is another&#39;s life-saving code-smell detector. I am not<br>&gt;&gt; personally tied to these categorizations at all, I&#39;m just interested in there<br>&gt;&gt; being something simple and basic. Below is a list of every warning in Swift with<br>&gt;&gt; an attempt to put it under a category.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Deprecated:<br>&gt;&gt;     var_not_allowed_in_pattern<br>&gt;&gt;         &quot;Use of &#39;%select{var|let}0&#39; binding here is deprecated and will be &quot;<br>&gt;&gt;         &quot;removed in a future version of Swift&quot;<br>&gt;&gt;     deprecated_c_style_for_stmt<br>&gt;&gt;         &quot;C-style for statement is deprecated and will be removed in a future &quot;<br>&gt;&gt;         &quot;version of Swift&quot;<br>&gt;&gt;     deprecated_convention_attribute<br>&gt;&gt;         &quot;&#39;@%0&#39; attribute is deprecated; &#39;@convention(%1)&#39; should be used &quot;<br>&gt;&gt;         &quot;instead&quot;<br>&gt;&gt;     availability_deprecated<br>&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1&quot;<br>&gt;&gt;     availability_deprecated_msg<br>&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: %5&quot;<br>&gt;&gt;     availability_deprecated_rename<br>&gt;&gt;         &quot;%0 %select{is|%select{is|was}3}1 deprecated&quot;<br>&gt;&gt;         &quot;%select{| %select{on|in}3 %2%select{| %4}3}1: renamed to &#39;%5&#39;&quot;<br>&gt;&gt;     parameter_curry_syntax_removed<br>&gt;&gt;         &quot;curried function declaration syntax will be removed in a future &quot;<br>&gt;&gt;         &quot;version of Swift; use a single parameter list&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Unsupported:<br>&gt;&gt;     warning_parallel_execution_not_supported<br>&gt;&gt;         &quot;parallel execution not supported; falling back to serial execution&quot;<br>&gt;&gt;     unsupported_synthesize_init_variadic<br>&gt;&gt;         &quot;synthesizing a variadic inherited initializer for subclass %0 is &quot;<br>&gt;&gt;         &quot;unsupported&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Stylistic/Pedantic/Cleanliness:<br>&gt;&gt;     pbd_never_used_stmtcond<br>&gt;&gt;         &quot;value %0 was defined but never used; consider replacing &quot;<br>&gt;&gt;         &quot;with boolean test&quot;<br>&gt;&gt;     pbd_never_used<br>&gt;&gt;         &quot;initialization of %select{variable|immutable value}1 %0 was never used&quot;<br>&gt;&gt;         &quot;; consider replacing with assignment to &#39;_&#39; or removing it&quot;<br>&gt;&gt;     capture_never_used<br>&gt;&gt;         &quot;capture %0 was never used&quot;,<br>&gt;&gt;     variable_never_used<br>&gt;&gt;         &quot;%select{variable|immutable value}1 %0 was never used; &quot;<br>&gt;&gt;         &quot;consider replacing with &#39;_&#39; or removing it&quot;<br>&gt;&gt;     variable_never_mutated<br>&gt;&gt;         &quot;%select{variable|parameter}1 %0 was never mutated; &quot;<br>&gt;&gt;         &quot;consider changing to &#39;let&#39; constant&quot;<br>&gt;&gt;     variable_never_read<br>&gt;&gt;         &quot;%select{variable|parameter}1 %0 was written to, but never read&quot;<br>&gt;&gt;     expression_unused_result<br>&gt;&gt;         &quot;result of call to %0 is unused&quot;<br>&gt;&gt;     expression_unused_init_result<br>&gt;&gt;         &quot;result of initializer is unused&quot;, ())<br>&gt;&gt;     expression_unused_result_message<br>&gt;&gt;         &quot;result of call to %0 is unused: %1&quot;<br>&gt;&gt;     expression_unused_result_nonmutating<br>&gt;&gt;         &quot;result of call to non-mutating function %0 is unused; &quot;<br>&gt;&gt;         &quot;use %1 to mutate in-place&quot;<br>&gt;&gt;     expression_unused_optional_try<br>&gt;&gt;         &quot;result of &#39;try?&#39; is unused&quot;<br>&gt;&gt;     non_trailing_closure_before_default_args<br>&gt;&gt;         &quot;closure parameter prior to parameters with default arguments will &quot;<br>&gt;&gt;         &quot;not be treated as a trailing closure&quot;<br>&gt;&gt;     parameter_extraneous_double_up<br>&gt;&gt;         &quot;extraneous duplicate parameter name; %0 already has an argument &quot;<br>&gt;&gt;         &quot;label&quot;<br>&gt;&gt;     parameter_extraneous_empty_name<br>&gt;&gt;         &quot;extraneous &#39;_&#39; in parameter: %0 has no keyword argument name&quot;<br>&gt;&gt;     escaped_parameter_name<br>&gt;&gt;         &quot;keyword &#39;%0&#39; does not need to be escaped in argument list&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; CodeSmell/StrongStylisticHints:<br>&gt;&gt;     guard_always_succeeds<br>&gt;&gt;         &quot;&#39;guard&#39; condition is always true, body is unreachable&quot;<br>&gt;&gt;     warn_unqualified_access<br>&gt;&gt;         &quot;use of %0 treated as a reference to %1 in %2 %3&quot;<br>&gt;&gt;     var_pattern_didnt_bind_variables<br>&gt;&gt;         &quot;&#39;%0&#39; pattern has no effect; sub-pattern didn&#39;t bind any variables&quot;<br>&gt;&gt;     type_inferred_to_undesirable_type<br>&gt;&gt;         &quot;%select{variable|constant}2 %0 inferred to have type %1, &quot;<br>&gt;&gt;         &quot;which may be unexpected&quot;<br>&gt;&gt;     no_throw_in_try<br>&gt;&gt;         &quot;no calls to throwing functions occur within &#39;try&#39; expression&quot;<br>&gt;&gt;     no_throw_in_do_with_catch<br>&gt;&gt;         &quot;&#39;catch&#39; block is unreachable because no errors are thrown in &#39;do&#39; block&quot;<br>&gt;&gt;     required_initializer_override_keyword<br>&gt;&gt;         &quot;&#39;override&#39; is implied when overriding a required initializer&quot;<br>&gt;&gt;     if_always_true<br>&gt;&gt;         &quot;&#39;if&#39; condition is always true&quot;<br>&gt;&gt;     while_always_true<br>&gt;&gt;         &quot;&#39;while&#39; condition is always true&quot;<br>&gt;&gt;     warn_protocol_witness_optionality<br>&gt;&gt;         &quot;%select{type|result|parameter|parameters|&quot;<br>&gt;&gt;         &quot;result and parameters}0 of %1 %select{has|has|has|have|have|}0&quot;<br>&gt;&gt;         &quot; different optionality than expected by protocol %2&quot;<br>&gt;&gt;     optional_req_nonobjc_near_match<br>&gt;&gt;         &quot;non- at objc %select{initializer %1|method %1|property %1|subscript}0 &quot;<br>&gt;&gt;         &quot;cannot satisfy optional requirement of @objc protocol %2&quot;<br>&gt;&gt;     override_unnecessary_IUO<br>&gt;&gt;         &quot;overriding %0 parameter of type %1 with implicitly unwrapped optional &quot;<br>&gt;&gt;         &quot;type %2&quot;,<br>&gt;&gt;     override_unnecessary_result_IUO<br>&gt;&gt;         &quot;overriding %0 optional result type %1 with implicitly unwrapped &quot;<br>&gt;&gt;         &quot;optional type %2&quot;,<br>&gt;&gt;     inject_forced_downcast, sema_tce, none,<br>&gt;&gt;         &quot;treating a forced downcast to %0 as optional will never produce &#39;nil&#39;&quot;<br>&gt;&gt;     recursive_accessor_reference, tce_sema, none,<br>&gt;&gt;         &quot;attempting to %select{access|modify}1 %0 within its own &quot;<br>&gt;&gt;         &quot;%select{getter|setter}1&quot;,<br>&gt;&gt;     store_in_willset, tce_sema, none,<br>&gt;&gt;         &quot;attempting to store to property %0 within its own willSet, which is &quot;<br>&gt;&gt;         &quot;about to be overwritten by the new value&quot;,<br>&gt;&gt;     isa_is_always_true<br>&gt;&gt;         &quot;&#39;%0&#39; test is always true&quot;,<br>&gt;&gt;     conditional_downcast_coercion<br>&gt;&gt;         &quot;conditional cast from %0 to %1 always succeeds&quot;<br>&gt;&gt;     downcast_to_unrelated, sema_tcc, none,<br>&gt;&gt;         &quot;cast from %0 to unrelated type %1 always fails&quot;<br>&gt;&gt;     forced_downcast_noop<br>&gt;&gt;         &quot;forced cast of %0 to same type has no effect&quot;<br>&gt;&gt;     forced_downcast_coercion<br>&gt;&gt;         &quot;forced cast from %0 to %1 always succeeds; did you mean to use &#39;as&#39;?&quot;<br>&gt;&gt;     extraneous_default_args_in_call<br>&gt;&gt;         &quot;call to %0 has extraneous arguments that could use defaults&quot;<br>&gt;&gt;     unreachable_code<br>&gt;&gt;         &quot;will never be executed&quot;<br>&gt;&gt;     unreachable_code_after_stmt<br>&gt;&gt;         &quot;code after &#39;%select{return|break|continue|throw}0&#39; will never &quot;<br>&gt;&gt;         &quot;be executed&quot;<br>&gt;&gt;     unreachable_case<br>&gt;&gt;         &quot;%select{case|default}0 will never be executed&quot;<br>&gt;&gt;     switch_on_a_constant<br>&gt;&gt;         &quot;switch condition evaluates to a constant&quot;<br>&gt;&gt;     integer_conversion_overflow_warn<br>&gt;&gt;         &quot;integer overflows when converted from %0 to %1&quot;<br>&gt;&gt;     integer_literal_overflow_warn<br>&gt;&gt;         &quot;integer literal overflows when stored into %0&quot;<br>&gt;&gt;     trailing_closure_excess_newlines<br>&gt;&gt;         &quot;trailing closure is separated from call site by multiple newlines&quot;<br>&gt;&gt;     lex_nul_character, lexing, none<br>&gt;&gt;         &quot;nul character embedded in middle of file&quot;<br>&gt;&gt;     unindented_code_after_return<br>&gt;&gt;         &quot;expression following &#39;return&#39; is treated as an argument of &quot;<br>&gt;&gt;         &quot;the &#39;return&#39;&quot;<br>&gt;&gt;     lex_editor_placeholder_in_playground<br>&gt;&gt;         &quot;editor placeholder in source file&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Attributes:<br>&gt;&gt;     attr_availability_unknown_platform<br>&gt;&gt;         &quot;unknown platform &#39;%0&#39; for attribute &#39;%1&#39;&quot;<br>&gt;&gt;     attr_warn_unused_result_expected_name<br>&gt;&gt;         &quot;expected parameter &#39;message&#39; or &#39;mutable_variant&#39;&quot;<br>&gt;&gt;     attr_warn_unused_result_duplicate_parameter<br>&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;     attr_warn_unused_result_unknown_parameter<br>&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;warn_unused_result&#39; attribute&quot;<br>&gt;&gt;     attr_migration_id_expected_name<br>&gt;&gt;         &quot;expected parameter &#39;pattern&#39;&quot;<br>&gt;&gt;     attr_migration_id_unknown_parameter<br>&gt;&gt;         &quot;unknown parameter &#39;%0&#39; in &#39;_migration_id&#39; attribute&quot;<br>&gt;&gt;     attr_migration_id_duplicate_parameter<br>&gt;&gt;         &quot;duplicate &#39;%0&#39; parameter; previous value will be ignored&quot;<br>&gt;&gt;     invalid_swift_name_method<br>&gt;&gt;         &quot;too %select{few|many}0 parameters in swift_name attribute (expected %1; &quot;<br>&gt;&gt;         &quot;got %2)&quot;<br>&gt;&gt; <br>&gt;&gt; Availability:<br>&gt;&gt;     availability_query_useless_min_deployment<br>&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; minimum deployment target ensures guard &quot;<br>&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt;     availability_query_useless_enclosing_scope<br>&gt;&gt;         &quot;unnecessary check for &#39;%0&#39;; enclosing scope ensures guard &quot;<br>&gt;&gt;         &quot;will always be true&quot;<br>&gt;&gt; <br>&gt;&gt; And the below I&#39;m either struggling to think about how to categorize them<br>&gt;&gt; (perhaps no category at first), or un-familiar with what they&#39;re targeting<br>&gt;&gt;     warning_from_clang:<br>&gt;&gt;         &quot;%0&quot;<br>&gt;&gt;     could_not_rewrite_bridging_header, none, none,<br>&gt;&gt;         &quot;failed to serialize bridging header; &quot;<br>&gt;&gt;         &quot;target may not be debuggable outside of its original project&quot;<br>&gt;&gt;     omit_needless_words<br>&gt;&gt;         &quot;%0 could be named %1 [-Womit-needless-words]&quot;<br>&gt;&gt;     unused_compiler_version_component<br>&gt;&gt;         &quot;the second version component is not used for comparison&quot;<br>&gt;&gt;     unknown_build_config<br>&gt;&gt;         &quot;unknown %0 for build configuration &#39;%1&#39;&quot;<br>&gt;&gt;     sema_import_current_module<br>&gt;&gt;         &quot;this file is part of module %0; ignoring import&quot;<br>&gt;&gt;     sema_import_current_module_with_file<br>&gt;&gt;         &quot;file &#39;%0&#39; is part of module %1; ignoring import&quot;<br>&gt;&gt;     access_control_member_more<br>&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 for &quot;<br>&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 %3&quot;<br>&gt;&gt;     access_control_ext_member_more<br>&gt;&gt;         &quot;declaring %select{PRIVATE|an internal|a public}0 %1 in &quot;<br>&gt;&gt;         &quot;%select{a private|an internal|PUBLIC}2 extension&quot;<br>&gt;&gt;     emit_reference_dependencies_without_primary_file<br>&gt;&gt;         &quot;ignoring -emit-reference-dependencies (requires -primary-file)&quot;<br>&gt;&gt;     warning_no_such_sdk<br>&gt;&gt;         &quot;no such SDK: &#39;%0&#39;&quot;<br>&gt;&gt;     warn_cannot_stat_input<br>&gt;&gt;         &quot;unable to determine when &#39;%0&#39; was last modified: %1&quot;<br>&gt;&gt;     warning_unnecessary_repl_mode<br>&gt;&gt;         &quot;unnecessary option &#39;%0&#39;; this is the default for &#39;%1&#39; &quot;<br>&gt;&gt;         &quot;with no input files&quot;<br>&gt;&gt;     incremental_requires_output_file_map<br>&gt;&gt;         &quot;ignoring -incremental (currently requires an output file map)&quot;<br>&gt;&gt;     incremental_requires_build_record_entry<br>&gt;&gt;         &quot;ignoring -incremental; output file map has no master dependencies &quot;<br>&gt;&gt;         &quot;entry (\&quot;%0\&quot; under \&quot;\&quot;)&quot;<br>&gt;&gt; <br>&gt;&gt; I haven’t gotten to how to expose this to the user, and I’ll defer to the community for suggestions in that area. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/84665f7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 13:51, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt;&gt; <br>&gt;&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt;&gt; <br>&gt;&gt; (We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br>&gt;&gt; <br>&gt; <br>&gt; I’ll look more at REPL mode and see how to better generalize that. It’s more in line with what I’m trying to accomplish, and it may not make sense to categorize all the warnings in Swift so much as call out limited sub-sets. If that’s the case, and doing so is more so the exception than the rule, then I’m more amenable to tags and/or Kate’s suggestions.<br>&gt; <br>&gt;&gt; I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br>&gt;&gt; <br>&gt; <br>&gt; What about global flags, such as “-Werr” or equivalent? Do you have any thoughts about Dmitri’s point on multi-platform libraries and how they sometimes can trigger strict stylistic warnings excessively?<br></p><p>I&#39;d rather come up with good answers to #if and/or easy, idiomatic ways to silence most warnings (like assigning to _) over flags and diagnostic regions (Clang&#39;s pragmas).<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/068f4b01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 13, 2016 at 04:00:00pm</p></header><div class="content"><p>Upon further discussion with Jordan and others offline, I’m not sure it makes sense at this point in Swift to go about doing categorization. Before wrapping up in this area, I’m going to pursue:<br></p><p>Clean up some existing code, where we have unused categories assigned to all diagnostics (and those categories are arguably useless)<br>Expose frontend options to treat all warnings as errors as well as options to ignore all warnings<br></p><p>Interesting future work could be along the lines of addressing https://bugs.swift.org/browse/SR-529 &lt;https://bugs.swift.org/browse/SR-529&gt;. After there’s unique identifiers, then we can re-explore finer grained control.<br></p><p>As far as front-end options, any preferences on the command-line switches? I don’t see a need to keep consistency with GCC/Clang here, so perhaps “-suppress-warnings” and “-warnings-as-errors”?<br></p><p>&gt; On Jan 13, 2016, at 2:28 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 13, 2016, at 13:51, Michael Ilseman &lt;milseman at apple.com &lt;mailto:milseman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’ll look more at REPL mode and see how to better generalize that. It’s more in line with what I’m trying to accomplish, and it may not make sense to categorize all the warnings in Swift so much as call out limited sub-sets. If that’s the case, and doing so is more so the exception than the rule, then I’m more amenable to tags and/or Kate’s suggestions.<br>&gt;&gt; <br>&gt;&gt;&gt; I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What about global flags, such as “-Werr” or equivalent? Do you have any thoughts about Dmitri’s point on multi-platform libraries and how they sometimes can trigger strict stylistic warnings excessively?<br>&gt; <br>&gt; I&#39;d rather come up with good answers to #if and/or easy, idiomatic ways to silence most warnings (like assigning to _) over flags and diagnostic regions (Clang&#39;s pragmas).<br>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/b2876101/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 4:51 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Upon further discussion with Jordan and others offline, I’m not sure it makes sense at this point in Swift to go about doing categorization. Before wrapping up in this area, I’m going to pursue:<br>&gt; <br>&gt; Clean up some existing code, where we have unused categories assigned to all diagnostics (and those categories are arguably useless)<br>&gt; Expose frontend options to treat all warnings as errors as well as options to ignore all warnings<br>&gt; <br></p><p>I opened PR https://github.com/apple/swift/pull/980 &lt;https://github.com/apple/swift/pull/980&gt; to perform this.<br></p><p><br></p><p>&gt; Interesting future work could be along the lines of addressing https://bugs.swift.org/browse/SR-529 &lt;https://bugs.swift.org/browse/SR-529&gt;. After there’s unique identifiers, then we can re-explore finer grained control.<br>&gt; <br>&gt; As far as front-end options, any preferences on the command-line switches? I don’t see a need to keep consistency with GCC/Clang here, so perhaps “-suppress-warnings” and “-warnings-as-errors”?<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 2:28 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 13:51, Michael Ilseman &lt;milseman at apple.com &lt;mailto:milseman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll look more at REPL mode and see how to better generalize that. It’s more in line with what I’m trying to accomplish, and it may not make sense to categorize all the warnings in Swift so much as call out limited sub-sets. If that’s the case, and doing so is more so the exception than the rule, then I’m more amenable to tags and/or Kate’s suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about global flags, such as “-Werr” or equivalent? Do you have any thoughts about Dmitri’s point on multi-platform libraries and how they sometimes can trigger strict stylistic warnings excessively?<br>&gt;&gt; <br>&gt;&gt; I&#39;d rather come up with good answers to #if and/or easy, idiomatic ways to silence most warnings (like assigning to _) over flags and diagnostic regions (Clang&#39;s pragmas).<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>&gt; <br>&gt; On Jan 14, 2016, at 8:32 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 13, 2016, at 2:28 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 13:51, Michael Ilseman &lt;milseman at apple.com &lt;mailto:milseman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll look more at REPL mode and see how to better generalize that. It’s more in line with what I’m trying to accomplish, and it may not make sense to categorize all the warnings in Swift so much as call out limited sub-sets. If that’s the case, and doing so is more so the exception than the rule, then I’m more amenable to tags and/or Kate’s suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about global flags, such as “-Werr” or equivalent? Do you have any thoughts about Dmitri’s point on multi-platform libraries and how they sometimes can trigger strict stylistic warnings excessively?<br>&gt;&gt; <br>&gt;&gt; I&#39;d rather come up with good answers to #if and/or easy, idiomatic ways to silence most warnings (like assigning to _) over flags and diagnostic regions (Clang&#39;s pragmas).<br>&gt; <br>&gt; Our crop of migration-to-Swift-3 warnings is a perfect example of a case where these approaches don’t work well. For example, it is completely reasonable to want to suppress the just-committed ‘typealias’ to ‘associatedtype&#39; warning if you want to keep your code base compiling with Swift 2.[01]. There’s no sensible idiom there, and having to use diagnostic regions would be annoying at best.<br>&gt; <br>&gt; 	- Doug<br></p><p>Doug, do you think it’s worth pursuing a strategy to handle the migration warnings right now?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160114/04d6d6e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6520643611a05fd040d0abcee3c883c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Ted Kremenek</string> &lt;kremenek at apple.com&gt;<p>January 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 4:51 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; As far as front-end options, any preferences on the command-line switches? I don’t see a need to keep consistency with GCC/Clang here, so perhaps “-suppress-warnings” and “-warnings-as-errors”?<br></p><p>There may not be a need for consistency, but there may be value in being consistent.<br></p><p>If you go with a cohesive model where there are warning categories and separate categories can be enabled, disabled, promoted to errors, etc., then there are merits to GCC/Clang&#39;s warning style that I don&#39;t think should just be dismissed out of hand.  Deviating can provide negative value because it a different scheme that is, well, just different, but conceptually similar to something many developers already know.<br></p><p>Before dismissing -Werror and -w, consider the taxonomy that they are a part of in the GCC/Clang world:<br></p><p>  -Werror-&lt;warning&gt;<br>  -Wno-error-&lt;warning&gt;<br>  -Wno-&lt;warning&gt;<br></p><p>This is a very general scheme for controlling warnings.  Perhaps &quot;-w&quot; and &quot;-Werror&quot; are a bit special case, so you could always do something like:<br></p><p>  -Wno-all<br>  -Werror-all<br></p><p>And just have a warning category for &quot;all warnings&quot;.<br></p><p>If you are going to go down the route of having any control for warnings from the command line --- which I realize is a contentious topic on this thread --- I personally believe that the flags should be simple, consistent, and generalized.  Having special case flags like &quot;-suppress-warnings&quot; and &quot;-warnings-as-errors&quot; feels more even more special case, and I just have to know what they are.<br></p><p>I&#39;m not married to the -W flags scheme, but it is something that is understood.  If we are going to have flags, I&#39;d prefer something that was equally (or more) understandable with a general and simple scheme for controlling warnings.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:21 PM, Ted kremenek &lt;kremenek at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 4:51 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As far as front-end options, any preferences on the command-line switches? I don’t see a need to keep consistency with GCC/Clang here, so perhaps “-suppress-warnings” and “-warnings-as-errors”?<br>&gt; <br>&gt; There may not be a need for consistency, but there may be value in being consistent.<br>&gt; <br>&gt; If you go with a cohesive model where there are warning categories and separate categories can be enabled, disabled, promoted to errors, etc., then there are merits to GCC/Clang&#39;s warning style that I don&#39;t think should just be dismissed out of hand.  Deviating can provide negative value because it a different scheme that is, well, just different, but conceptually similar to something many developers already know.<br>&gt; <br></p><p>That’s a very good point. If we want to offer individual or categorical control in the future, we should design something consistent.<br></p><p>&gt; Before dismissing -Werror and -w, consider the taxonomy that they are a part of in the GCC/Clang world:<br>&gt; <br>&gt;  -Werror-&lt;warning&gt;<br>&gt;  -Wno-error-&lt;warning&gt;<br>&gt;  -Wno-&lt;warning&gt;<br>&gt; <br>&gt; This is a very general scheme for controlling warnings.  Perhaps &quot;-w&quot; and &quot;-Werror&quot; are a bit special case, so you could always do something like:<br>&gt; <br>&gt;  -Wno-all<br>&gt;  -Werror-all<br>&gt; <br>&gt; And just have a warning category for &quot;all warnings&quot;.<br>&gt; <br>&gt; If you are going to go down the route of having any control for warnings from the command line --- which I realize is a contentious topic on this thread --- I personally believe that the flags should be simple, consistent, and generalized.  Having special case flags like &quot;-suppress-warnings&quot; and &quot;-warnings-as-errors&quot; feels more even more special case, and I just have to know what they are.<br>&gt; <br>&gt; I&#39;m not married to the -W flags scheme, but it is something that is understood.  If we are going to have flags, I&#39;d prefer something that was equally (or more) understandable with a general and simple scheme for controlling warnings.<br></p><p>I don’t mind any particulars, just so long as it’s something reasonable and consistent, and provides a user story that is not too confusing. The -Wno-error-&lt;warning&gt; flags does seem confusing, in that it presupposes that a prior flag ended up treating it as an error, while it might actually be off-by-default. I would think that there are 5 potential states a diagnostic/category can be in WRT user control: “unspecified”, “default”, “error”, “explicitly on”, “explicitly off”. (Perhaps “unspecified” and “default” can be folded in together, but we might want to expose explicitly setting as default to the user).<br></p><p>Rather than rely on order on command line, I’d rather have a very consistent order of precedence that fits intuition. See below for my proposed order of precedence.<br></p><p>The main things I’m trying to avoid in all this is:<br>Complicating compiler maintenance without sufficient benefit<br>Complicating the user story<br>Painting ourselves into a compatibility corner<br>Categorization merely as an exercise (taxonomy without use case)<br>&gt; <br>&gt; Perhaps I&#39;m the outlier here, but I personally think that &quot;warning flags result in style dialects&quot; is not an anathema.  There is some code where stylistic enforcements need to be stricter for a variety of reasons.  While I think we should aim for a common set of warnings that are enabled to establish good hygiene in Swift code, I do think there will be cases where more warnings/errors are desired beyond what the core language defines.<br>&gt; <br>&gt; I agree we don&#39;t need to eagerly classify warnings, but I&#39;d also like to understand your criteria for why -W flags are bad thing in general and what you&#39;d prefer to see as a better direction.  I certainly don&#39;t see it that way.  My fear is that if we are overly conservative about not having precise control over warnings is that we may hold back on adding useful warnings to the compiler because they will not be appropriate for everyone.<br>&gt; <br>&gt; I also don&#39;t see #if as a solution for warning control, as you indicated in another message, as I see legitimate cases where more aggressive warnings may be desirable to enable in certain contexts.  There is also Chris&#39;s comments about other contents, like Playgrounds, where some pedantic warnings that may be on by default provide less value.<br></p><p>I would propose the following precedence, which matches basic intuition:<br>Individual control<br>Use case control<br>Categorical control<br>Global control<br>E.g. If someone bothered to single out a warning, that should take precedence over others. If there’s a conflict at a precedence level, we error.<br></p><p>By “use case” control, for lack of a better name off the top of my head (please suggest one!), I mean situations in which diagnostics are not grouped by kind or any other logical grouping. Rather, they appear together in situations that commonly might want to be controlled. These are often diagnostics which would be cross-cutting of any hierarchical categorization by kind. Some examples:<br>Warnings about features that are currently in transition, which many users don’t want to see if they want to be able to compile warning-free on multiple compiler minor versions. <br>Opting into extra-stringent stylistic warnings that we wouldn’t normally want to thrust upon normal users (but, not style dialects, just a spectrum of stringency).<br>The kinds of diagnostics that users like Playgrounds just shouldn’t care about, e.g. unused definitions.<br>The aim being that there’s a specific user or use-case in mind when defining one, as opposed to having them as an organizational grouping. I don’t feel like these would naturally tend to have much, if any, overlap with each other and perhaps we can treat them as non-overlapping. They may, of course, crosscut categories, should we ever decide to implement categories.<br></p><p>Clang’s categories are sometimes “use case” here, e.g. “c++98-compat”, but often are categorical, e.g. &quot;duplicate-decl-specifier”. I think that for the current state of Swift and Swift for the near future, it makes sense to tackle “use case” soon and categorical later if at all. I feel like the more categorical approach is also more likely to be a source of stylistic dialect splitting and of limited value to the user. Power users can use individual control.<br></p><p>I’d prefer to tackle unique-identifiers before tackling individual control, to help with maintenance and not face a compatibility problem. If this is seems very valuable to Swift, we can also pursue automatic and hyperlinked documentation produced from the diagnostic definitions, etc.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160120/e40da443/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>January 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 11:23 AM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 10:21 PM, Ted kremenek &lt;kremenek at apple.com &lt;mailto:kremenek at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 4:51 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as front-end options, any preferences on the command-line switches? I don’t see a need to keep consistency with GCC/Clang here, so perhaps “-suppress-warnings” and “-warnings-as-errors”?<br>&gt;&gt; <br>&gt;&gt; There may not be a need for consistency, but there may be value in being consistent.<br>&gt;&gt; <br>&gt;&gt; If you go with a cohesive model where there are warning categories and separate categories can be enabled, disabled, promoted to errors, etc., then there are merits to GCC/Clang&#39;s warning style that I don&#39;t think should just be dismissed out of hand.  Deviating can provide negative value because it a different scheme that is, well, just different, but conceptually similar to something many developers already know.<br>&gt;&gt; <br>&gt; <br>&gt; That’s a very good point. If we want to offer individual or categorical control in the future, we should design something consistent.<br>&gt; <br>&gt;&gt; Before dismissing -Werror and -w, consider the taxonomy that they are a part of in the GCC/Clang world:<br>&gt;&gt; <br>&gt;&gt;  -Werror-&lt;warning&gt;<br>&gt;&gt;  -Wno-error-&lt;warning&gt;<br>&gt;&gt;  -Wno-&lt;warning&gt;<br>&gt;&gt; <br>&gt;&gt; This is a very general scheme for controlling warnings.  Perhaps &quot;-w&quot; and &quot;-Werror&quot; are a bit special case, so you could always do something like:<br>&gt;&gt; <br>&gt;&gt;  -Wno-all<br>&gt;&gt;  -Werror-all<br>&gt;&gt; <br>&gt;&gt; And just have a warning category for &quot;all warnings&quot;.<br>&gt;&gt; <br>&gt;&gt; If you are going to go down the route of having any control for warnings from the command line --- which I realize is a contentious topic on this thread --- I personally believe that the flags should be simple, consistent, and generalized.  Having special case flags like &quot;-suppress-warnings&quot; and &quot;-warnings-as-errors&quot; feels more even more special case, and I just have to know what they are.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not married to the -W flags scheme, but it is something that is understood.  If we are going to have flags, I&#39;d prefer something that was equally (or more) understandable with a general and simple scheme for controlling warnings.<br>&gt; <br>&gt; I don’t mind any particulars, just so long as it’s something reasonable and consistent, and provides a user story that is not too confusing. The -Wno-error-&lt;warning&gt; flags does seem confusing, in that it presupposes that a prior flag ended up treating it as an error, while it might actually be off-by-default. I would think that there are 5 potential states a diagnostic/category can be in WRT user control: “unspecified”, “default”, “error”, “explicitly on”, “explicitly off”. (Perhaps “unspecified” and “default” can be folded in together, but we might want to expose explicitly setting as default to the user).<br>&gt; <br></p><p>To get the ball rolling towards getting a consistent set of flags soon, here’s a proposal (the details of which I’m not particularly attached to):<br></p><p>-Werror=&lt;warning/all/category/...&gt;<br>-Wenable=&lt;warning/all/category/...&gt;<br>-Wdisable=&lt;warning/all/category/...&gt;<br>-Wdefault=&lt;warning/all/category/...&gt;<br></p><p>And, we add support for “all” while we figure out what we want to do for everything else. I could also consider “-Won=” and “-Woff=“ for brevity, though perhaps at the cost of some clarity. Similarly for any command-line aliases to ease brevity, e.g. “-W&lt;warning&gt;” expands to “-Wenable=&lt;warning&gt;”, etc.<br></p><p><br></p><p>&gt; Rather than rely on order on command line, I’d rather have a very consistent order of precedence that fits intuition. See below for my proposed order of precedence.<br>&gt; <br>&gt; The main things I’m trying to avoid in all this is:<br>&gt; Complicating compiler maintenance without sufficient benefit<br>&gt; Complicating the user story<br>&gt; Painting ourselves into a compatibility corner<br>&gt; Categorization merely as an exercise (taxonomy without use case)<br>&gt;&gt; <br>&gt;&gt; Perhaps I&#39;m the outlier here, but I personally think that &quot;warning flags result in style dialects&quot; is not an anathema.  There is some code where stylistic enforcements need to be stricter for a variety of reasons.  While I think we should aim for a common set of warnings that are enabled to establish good hygiene in Swift code, I do think there will be cases where more warnings/errors are desired beyond what the core language defines.<br>&gt;&gt; <br>&gt;&gt; I agree we don&#39;t need to eagerly classify warnings, but I&#39;d also like to understand your criteria for why -W flags are bad thing in general and what you&#39;d prefer to see as a better direction.  I certainly don&#39;t see it that way.  My fear is that if we are overly conservative about not having precise control over warnings is that we may hold back on adding useful warnings to the compiler because they will not be appropriate for everyone.<br>&gt;&gt; <br>&gt;&gt; I also don&#39;t see #if as a solution for warning control, as you indicated in another message, as I see legitimate cases where more aggressive warnings may be desirable to enable in certain contexts.  There is also Chris&#39;s comments about other contents, like Playgrounds, where some pedantic warnings that may be on by default provide less value.<br>&gt; <br>&gt; I would propose the following precedence, which matches basic intuition:<br>&gt; Individual control<br>&gt; Use case control<br>&gt; Categorical control<br>&gt; Global control<br>&gt; E.g. If someone bothered to single out a warning, that should take precedence over others. If there’s a conflict at a precedence level, we error.<br>&gt; <br>&gt; By “use case” control, for lack of a better name off the top of my head (please suggest one!), I mean situations in which diagnostics are not grouped by kind or any other logical grouping. Rather, they appear together in situations that commonly might want to be controlled. These are often diagnostics which would be cross-cutting of any hierarchical categorization by kind. Some examples:<br>&gt; Warnings about features that are currently in transition, which many users don’t want to see if they want to be able to compile warning-free on multiple compiler minor versions. <br>&gt; Opting into extra-stringent stylistic warnings that we wouldn’t normally want to thrust upon normal users (but, not style dialects, just a spectrum of stringency).<br>&gt; The kinds of diagnostics that users like Playgrounds just shouldn’t care about, e.g. unused definitions.<br>&gt; The aim being that there’s a specific user or use-case in mind when defining one, as opposed to having them as an organizational grouping. I don’t feel like these would naturally tend to have much, if any, overlap with each other and perhaps we can treat them as non-overlapping. They may, of course, crosscut categories, should we ever decide to implement categories.<br>&gt; <br>&gt; Clang’s categories are sometimes “use case” here, e.g. “c++98-compat”, but often are categorical, e.g. &quot;duplicate-decl-specifier”. I think that for the current state of Swift and Swift for the near future, it makes sense to tackle “use case” soon and categorical later if at all. I feel like the more categorical approach is also more likely to be a source of stylistic dialect splitting and of limited value to the user. Power users can use individual control.<br>&gt; <br>&gt; I’d prefer to tackle unique-identifiers before tackling individual control, to help with maintenance and not face a compatibility problem. If this is seems very valuable to Swift, we can also pursue automatic and hyperlinked documentation produced from the diagnostic definitions, etc.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160121/4095ccbd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6520643611a05fd040d0abcee3c883c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Ted Kremenek</string> &lt;kremenek at apple.com&gt;<p>January 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 11:23 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 10:21 PM, Ted kremenek &lt;kremenek at apple.com &lt;mailto:kremenek at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 4:51 PM, Michael Ilseman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as front-end options, any preferences on the command-line switches? I don’t see a need to keep consistency with GCC/Clang here, so perhaps “-suppress-warnings” and “-warnings-as-errors”?<br>&gt;&gt; <br>&gt;&gt; There may not be a need for consistency, but there may be value in being consistent.<br>&gt;&gt; <br>&gt;&gt; If you go with a cohesive model where there are warning categories and separate categories can be enabled, disabled, promoted to errors, etc., then there are merits to GCC/Clang&#39;s warning style that I don&#39;t think should just be dismissed out of hand.  Deviating can provide negative value because it a different scheme that is, well, just different, but conceptually similar to something many developers already know.<br>&gt;&gt; <br>&gt; <br>&gt; That’s a very good point. If we want to offer individual or categorical control in the future, we should design something consistent.<br>&gt; <br>&gt;&gt; Before dismissing -Werror and -w, consider the taxonomy that they are a part of in the GCC/Clang world:<br>&gt;&gt; <br>&gt;&gt;  -Werror-&lt;warning&gt;<br>&gt;&gt;  -Wno-error-&lt;warning&gt;<br>&gt;&gt;  -Wno-&lt;warning&gt;<br>&gt;&gt; <br>&gt;&gt; This is a very general scheme for controlling warnings.  Perhaps &quot;-w&quot; and &quot;-Werror&quot; are a bit special case, so you could always do something like:<br>&gt;&gt; <br>&gt;&gt;  -Wno-all<br>&gt;&gt;  -Werror-all<br>&gt;&gt; <br>&gt;&gt; And just have a warning category for &quot;all warnings&quot;.<br>&gt;&gt; <br>&gt;&gt; If you are going to go down the route of having any control for warnings from the command line --- which I realize is a contentious topic on this thread --- I personally believe that the flags should be simple, consistent, and generalized.  Having special case flags like &quot;-suppress-warnings&quot; and &quot;-warnings-as-errors&quot; feels more even more special case, and I just have to know what they are.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not married to the -W flags scheme, but it is something that is understood.  If we are going to have flags, I&#39;d prefer something that was equally (or more) understandable with a general and simple scheme for controlling warnings.<br>&gt; <br>&gt; I don’t mind any particulars, just so long as it’s something reasonable and consistent, and provides a user story that is not too confusing. The -Wno-error-&lt;warning&gt; flags does seem confusing, in that it presupposes that a prior flag ended up treating it as an error, while it might actually be off-by-default.<br></p><p>I agree with you completely.  I have nothing against deviating from them for good reason — but those reasons should be well understood and deliberate.<br></p><p>&gt; I would think that there are 5 potential states a diagnostic/category can be in WRT user control: “unspecified”, “default”, “error”, “explicitly on”, “explicitly off”. (Perhaps “unspecified” and “default” can be folded in together, but we might want to expose explicitly setting as default to the user).<br></p><p>Hmm.  I’m trying to understand what “unspecified” would mean in practice.  The diagnostic system would need to do something with an “unspecified” warning, which I assume would mean the “default”.<br></p><p>&gt; <br>&gt; Rather than rely on order on command line, I’d rather have a very consistent order of precedence that fits intuition. See below for my proposed order of precedence.<br></p><p>Seems like a great goal.  The main advantage of the command line is that it allows the ability to easily provide overrides if the default behavior is articulated in terms of a set of command line options you inherited elsewhere from the build system.<br></p><p>For example, in some cases being able to pass “additional flags” on a per-file basis has been historically a useful way for a specific file to provide overrides to the default project warning settings.<br></p><p>&gt; <br>&gt; The main things I’m trying to avoid in all this is:<br>&gt; Complicating compiler maintenance without sufficient benefit<br>&gt; Complicating the user story<br>&gt; Painting ourselves into a compatibility corner<br>&gt; Categorization merely as an exercise (taxonomy without use case)<br></p><p>These sound great, but also a bit abstract.  I’m also not so worried about the latter.  The categorization we are talking about here is about the ability to enable/disable any warning and to change the policy on each warning.  Whether or not warnings are grouped into logical (and useful) groups really comes down to whether or not you want to turn on/off groups of warnings at a time that are naturally related.<br></p><p>&gt;&gt; <br>&gt;&gt; Perhaps I&#39;m the outlier here, but I personally think that &quot;warning flags result in style dialects&quot; is not an anathema.  There is some code where stylistic enforcements need to be stricter for a variety of reasons.  While I think we should aim for a common set of warnings that are enabled to establish good hygiene in Swift code, I do think there will be cases where more warnings/errors are desired beyond what the core language defines.<br>&gt;&gt; <br>&gt;&gt; I agree we don&#39;t need to eagerly classify warnings, but I&#39;d also like to understand your criteria for why -W flags are bad thing in general and what you&#39;d prefer to see as a better direction.  I certainly don&#39;t see it that way.  My fear is that if we are overly conservative about not having precise control over warnings is that we may hold back on adding useful warnings to the compiler because they will not be appropriate for everyone.<br>&gt;&gt; <br>&gt;&gt; I also don&#39;t see #if as a solution for warning control, as you indicated in another message, as I see legitimate cases where more aggressive warnings may be desirable to enable in certain contexts.  There is also Chris&#39;s comments about other contents, like Playgrounds, where some pedantic warnings that may be on by default provide less value.<br>&gt; <br>&gt; I would propose the following precedence, which matches basic intuition:<br>&gt; Individual control<br>&gt; Use case control<br>&gt; Categorical control<br>&gt; Global control<br>&gt; E.g. If someone bothered to single out a warning, that should take precedence over others. If there’s a conflict at a precedence level, we error.<br>&gt; <br>&gt; By “use case” control, for lack of a better name off the top of my head (please suggest one!), I mean situations in which diagnostics are not grouped by kind or any other logical grouping. Rather, they appear together in situations that commonly might want to be controlled. These are often diagnostics which would be cross-cutting of any hierarchical categorization by kind. Some examples:<br>&gt; Warnings about features that are currently in transition, which many users don’t want to see if they want to be able to compile warning-free on multiple compiler minor versions. <br>&gt; Opting into extra-stringent stylistic warnings that we wouldn’t normally want to thrust upon normal users (but, not style dialects, just a spectrum of stringency).<br>&gt; The kinds of diagnostics that users like Playgrounds just shouldn’t care about, e.g. unused definitions.<br>&gt; The aim being that there’s a specific user or use-case in mind when defining one, as opposed to having them as an organizational grouping. I don’t feel like these would naturally tend to have much, if any, overlap with each other and perhaps we can treat them as non-overlapping. They may, of course, crosscut categories, should we ever decide to implement categories.<br></p><p>I hate to say it, but “use case control” naturally fits with a cross-cutting warning category.<br></p><p>&gt; <br>&gt; Clang’s categories are sometimes “use case” here, e.g. “c++98-compat”, but often are categorical, e.g. &quot;duplicate-decl-specifier”. I think that for the current state of Swift and Swift for the near future, it makes sense to tackle “use case” soon and categorical later if at all. I feel like the more categorical approach is also more likely to be a source of stylistic dialect splitting and of limited value to the user. Power users can use individual control.<br>&gt; <br>&gt; I’d prefer to tackle unique-identifiers before tackling individual control, to help with maintenance and not face a compatibility problem. If this is seems very valuable to Swift, we can also pursue automatic and hyperlinked documentation produced from the diagnostic definitions, etc.<br></p><p>One possibility is to make “use case control” and “categorical control” distinctly different in a fundamental way.  For example, perhaps all warnings can be divided up into hierarchical groups  (groups only overlap if they are a subset) based on categorical control, and those groups can have defaults that are defined in terms of the leaves.  The “use case” control has no defaults, but provides a knob to explicitly turn a group of warnings on or off, essentially overriding the other behavior.<br></p><p>What does “global control” mean in your taxonomy?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160125/799572f8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 14, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 2:28 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 13, 2016, at 13:51, Michael Ilseman &lt;milseman at apple.com &lt;mailto:milseman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (We do have some ad hoc categorization today, including &quot;REPL mode&quot; as you mentioned. I&#39;m fine with making that something more general.)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’ll look more at REPL mode and see how to better generalize that. It’s more in line with what I’m trying to accomplish, and it may not make sense to categorize all the warnings in Swift so much as call out limited sub-sets. If that’s the case, and doing so is more so the exception than the rule, then I’m more amenable to tags and/or Kate’s suggestions.<br>&gt;&gt; <br>&gt;&gt;&gt; I guess I&#39;d rather avoid eagerly classifying warnings, and I&#39;ll continue to argue against -W* and -Wno-* flags for the time being.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What about global flags, such as “-Werr” or equivalent? Do you have any thoughts about Dmitri’s point on multi-platform libraries and how they sometimes can trigger strict stylistic warnings excessively?<br>&gt; <br>&gt; I&#39;d rather come up with good answers to #if and/or easy, idiomatic ways to silence most warnings (like assigning to _) over flags and diagnostic regions (Clang&#39;s pragmas).<br></p><p>Our crop of migration-to-Swift-3 warnings is a perfect example of a case where these approaches don’t work well. For example, it is completely reasonable to want to suppress the just-committed ‘typealias’ to ‘associatedtype&#39; warning if you want to keep your code base compiling with Swift 2.[01]. There’s no sensible idiom there, and having to use diagnostic regions would be annoying at best.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160114/48292554/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt; <br>&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br></p><p>Jordan, there is a class of warnings that we want to disable in Playgrounds, simply because they don’t make sense for that use case. <br></p><p>You could argue that the IDE should just ignore certain errors in this case, but that leads to tight coupling and fragility, this is better managed by having there be a -Wno-playgrounds sort of flag, so we can manage it on the compiler side.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160118/adc685b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 22:39 , Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br>&gt;&gt; <br>&gt;&gt; For the &quot;variable never mutated&quot; warning, you mentioned that this doesn&#39;t make sense in a rapid experimentation environment. I&#39;d say more specifically that it doesn&#39;t make sense in code you&#39;re actively changing. But Live Issues should be able to know what code you&#39;re actively changing, and only suppress the warning there.<br>&gt; <br>&gt; Jordan, there is a class of warnings that we want to disable in Playgrounds, simply because they don’t make sense for that use case. <br>&gt; <br>&gt; You could argue that the IDE should just ignore certain errors in this case, but that leads to tight coupling and fragility, this is better managed by having there be a -Wno-playgrounds sort of flag, so we can manage it on the compiler side.<br></p><p>So far I haven&#39;t heard any warnings that make sense to disable globally in playgrounds. I can understand this as a stop-gap measure, but not a long-term one, and there&#39;s no real reason to expose a flag for it separate than the existing &quot;playground mode&quot;.<br></p><p>Doug&#39;s point about migration warnings makes sense, though.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/3959dd99/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6520643611a05fd040d0abcee3c883c?s=50"></div><header><strong>Categorization of warnings in Swift</strong> from <string>Ted Kremenek</string> &lt;kremenek at apple.com&gt;<p>January 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 1:43 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, Michael. As one of the people who&#39;s been a strong believer of &quot;warning flags result in style dialects&quot;, I think it&#39;s important to establish a use case here. What will people actually do with warning categories? What warnings will we allow turning off? Under what contexts?<br></p><p>Perhaps I&#39;m the outlier here, but I personally think that &quot;warning flags result in style dialects&quot; is not an anathema.  There is some code where stylistic enforcements need to be stricter for a variety of reasons.  While I think we should aim for a common set of warnings that are enabled to establish good hygiene in Swift code, I do think there will be cases where more warnings/errors are desired beyond what the core language defines.<br></p><p>I agree we don&#39;t need to eagerly classify warnings, but I&#39;d also like to understand your criteria for why -W flags are bad thing in general and what you&#39;d prefer to see as a better direction.  I certainly don&#39;t see it that way.  My fear is that if we are overly conservative about not having precise control over warnings is that we may hold back on adding useful warnings to the compiler because they will not be appropriate for everyone.<br></p><p>I also don&#39;t see #if as a solution for warning control, as you indicated in another message, as I see legitimate cases where more aggressive warnings may be desirable to enable in certain contexts.  There is also Chris&#39;s comments about other contents, like Playgrounds, where some pedantic warnings that may be on by default provide less value.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
