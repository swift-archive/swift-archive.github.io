<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pre-Review] Permit where clauses to constrain associated types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>September 21, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello mailing list,<br></p><p>Since the following proposal was discussed before the release of Swift 3 and then delayed, I’m opening it up again for a short pre-review before to get some additional feedback before it can be merged.<br></p><p>Web link: https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md<br></p><p>Permit where clauses to constrain associated types<br></p><p>Proposal: SE-NNNN &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/NNNN-associated-types-constraints.md&gt;<br>Authors: David Hart &lt;https://github.com/hartbit&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Review Manager: TBD<br>Status: Awaiting review<br> &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#introduction&gt;Introduction<br></p><p>This proposal seeks to introduce a where clause to associated type declarations and improvements to protocol constraints to bring associated types the same expressive power as generic type parameters.<br></p><p>This proposal was discussed twice on the Swift Evolution list in the following threads:<br></p><p>[Completing Generics] Arbitrary requirements in protocols &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014667.html&gt;<br>[Proposal] More Powerful Constraints for Associated Types<br>Week #1 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015625.html&gt;<br>Week #2 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015753.html&gt;<br>Week #3 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016354.html&gt;<br> &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#motivation&gt;Motivation<br></p><p>Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where clause. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol could be declared as follows if the current proposal was accepted:<br></p><p>protocol Sequence {<br>    associatedtype Iterator : IteratorProtocol<br>    associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>    ...<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#detailed-design&gt;Detailed Design<br></p><p>First of all, this proposal modifies the grammar for a protocol&#39;s associated types to the following:<br></p><p>protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt typealias-assignment­opt requirement-clauseopt<br></p><p>The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br></p><p>Secondly, the proposal also allows protocols to use the associated types of their conforming protocols in their declaration where clause as below:<br></p><p>protocol IntSequence : Sequence where Iterator.Element == Int {<br>    ...<br>}<br>Name lookup semantics in the protocol declaration where clause only looks at associated types in the parent protocols. For example, the following code would cause an error:<br></p><p>protocol SomeSequence : Sequence where Counter : SomeProtocol { // error: Use of undefined associated type &#39;Counter&#39;<br>    associatedtype Counter<br>}<br>But instead should be written on the associated type itself:<br></p><p>protocol IntSequence : Sequence {<br>    associatedtype Counter : SomeProtocol<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#effect-on-abi-stability&gt;Effect on ABI Stability<br></p><p>As mentioned previously, there are a number of places in the standard library where this feature would be adopted (such as the SubSequence.Iterator.Element == Iterator.Element example), each of which will change the mangling of any generic function/type that makes use of them.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#alternatives&gt;Alternatives<br></p><p>Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br></p><p>protocol Collection : Sequence {<br>    where SubSequence : Collection<br>}<br>But as Douglas notes himself, that syntax is ambiguous since we adopted the generic where clause at the end of declarations of the following proposal: SE-0081: Move where clause to end of declaration &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md&gt;. For those reasons, it might be wiser not to introduce the shorthand syntax.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#acknowledgements&gt;Acknowledgements<br></p><p>Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/e0ee303f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pre-Review] Permit where clauses to constrain associated types</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>September 21, 2016 at 04:00:00pm</p></header><div class="content"><p>I… like this syntax but I have to admit that I am confused about<br>```protocol IntSequence : Sequence where Iterator.Element == Int {<br>    ...<br>}<br>```<br>I think that this example needs a better subtype/subprotocol to motivate<br>the feature. This particular type seems more like a constrained typealias<br>example to me. An example that I think might work is<br></p><p>```protocol FloatingPointSignal : Sequence where Iterator.Element == Double<br>{<br>    var sampleRate: Double<br>    ...<br>}<br>```<br>because there is behavior/state to add in the subprotocol.<br></p><p><br></p><p>On Wed, Sep 21, 2016 at 2:50 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello mailing list,<br>&gt;<br>&gt; Since the following proposal was discussed before the release of Swift 3<br>&gt; and then delayed, I’m opening it up again for a short pre-review before to<br>&gt; get some additional feedback before it can be merged.<br>&gt;<br>&gt; Web link: https://github.com/hartbit/swift-evolution/blob/<br>&gt; 4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-<br>&gt; associated-types-constraints.md<br>&gt;<br>&gt; Permit where clauses to constrain associated types<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/NNNN-associated-types-constraints.md&gt;<br>&gt;    - Authors: David Hart &lt;https://github.com/hartbit&gt;, Jacob Bandes-Storch<br>&gt;    &lt;https://github.com/jtbandes&gt;, Doug Gregor<br>&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;    - Review Manager: TBD<br>&gt;    - Status: Awaiting review<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal seeks to introduce a where clause to associated type<br>&gt; declarations and improvements to protocol constraints to bring associated<br>&gt; types the same expressive power as generic type parameters.<br>&gt;<br>&gt; This proposal was discussed twice on the Swift Evolution list in the<br>&gt; following threads:<br>&gt;<br>&gt;    - [Completing Generics] Arbitrary requirements in protocols<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014667.html&gt;<br>&gt;    - [Proposal] More Powerful Constraints for Associated Types<br>&gt;       - Week #1<br>&gt;       &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015625.html&gt;<br>&gt;       - Week #2<br>&gt;       &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015753.html&gt;<br>&gt;       - Week #3<br>&gt;       &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016354.html&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently, associated type declarations can only express simple<br>&gt; inheritance constraints and not the more sophisticated constraints<br>&gt; available to generic types with the where clause. Some designs, including<br>&gt; many in the Standard Library, require more powerful constraints for<br>&gt; associated types to be truly elegant. For example, the SequenceType protocol<br>&gt; could be declared as follows if the current proposal was accepted:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; First of all, this proposal modifies the grammar for a protocol&#39;s<br>&gt; associated types to the following:<br>&gt;<br>&gt; *protocol-associated-type-declaration* → *attributesopt*<br>&gt; *access-level-modifieropt* associatedtype *typealias-name* ­<br>&gt; *type-inheritance-clause­opt* *typealias-assignment­opt*<br>&gt; *requirement-clauseopt*<br>&gt;<br>&gt; The new requirement-clause is then used by the compiler to validate the<br>&gt; associated types of conforming types.<br>&gt;<br>&gt; Secondly, the proposal also allows protocols to use the associated types<br>&gt; of their conforming protocols in their declaration where clause as below:<br>&gt;<br>&gt; protocol IntSequence : Sequence where Iterator.Element == Int {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; Name lookup semantics in the protocol declaration where clause only looks<br>&gt; at associated types in the parent protocols. For example, the following<br>&gt; code would cause an error:<br>&gt;<br>&gt; protocol SomeSequence : Sequence where Counter : SomeProtocol { // error: Use of undefined associated type &#39;Counter&#39;<br>&gt;     associatedtype Counter<br>&gt; }<br>&gt;<br>&gt; But instead should be written on the associated type itself:<br>&gt;<br>&gt; protocol IntSequence : Sequence {<br>&gt;     associatedtype Counter : SomeProtocol<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#effect-on-abi-stability&gt;Effect<br>&gt; on ABI Stability<br>&gt;<br>&gt; As mentioned previously, there are a number of places in the standard<br>&gt; library where this feature would be adopted (such as the<br>&gt; SubSequence.Iterator.Element == Iterator.Element example), each of which<br>&gt; will change the mangling of any generic function/type that makes use of<br>&gt; them.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#alternatives&gt;<br>&gt; Alternatives<br>&gt;<br>&gt; Douglas Gregor argues that the proposed syntax is redundant when adding<br>&gt; new constraints to an associated type declared in a parent protocol and<br>&gt; proposes another syntax:<br>&gt;<br>&gt; protocol Collection : Sequence {<br>&gt;     where SubSequence : Collection<br>&gt; }<br>&gt;<br>&gt; But as Douglas notes himself, that syntax is ambiguous since we adopted<br>&gt; the generic where clause at the end of declarations of the following<br>&gt; proposal: SE-0081: Move where clause to end of declaration<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md&gt;.<br>&gt; For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/4107087d82eacc35538f5af0d97ffb80dfa4f998/proposals/XXXX-associated-types-constraints.md#acknowledgements&gt;<br>&gt; Acknowledgements<br>&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me<br>&gt; through this proposal.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/48c74b91/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
