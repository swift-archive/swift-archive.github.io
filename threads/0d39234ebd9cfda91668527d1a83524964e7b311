<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 30, 2016 at 02:00:00am</p></header><div class="content"><p>&gt;&gt; 	let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 	            &quot;&lt;catalog&gt;<br>&gt;&gt; 	            &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; 	            &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 	            &quot; &lt;/book&gt;<br>&gt;&gt; 	            &quot;&lt;/catalog&gt;”_<br></p><p>If I am reading and understanding this correctly:<br>This solution is still delimiter-sensitive and<br>breaks if    “_     delimiter is found somewhere within the data,<br>because it is interpreted as end-of-string.<br></p><p>I wrote already about my solution   <br>which solves the above deficiency, <br>because it does not use delimiters at all.<br></p><p>I have thought it all over and cleaned it up. Here it is again,<br>hopefully this description is more clear and readable.<br></p><p>Data Line Operators. <br></p><p>For convenience, I call these \\ and \@ :  “data-line-operators” .<br>(of course, they are pseudo operators) <br>Other two? character combinations for these operators are also possible. <br></p><p><br>The  \@  data-line-operator:   <br>     -  takes character data &quot;as-is” without any conversion.<br>     -  respects (includes) source-file line terminators.<br>     -  all spaces in-between and up to the source line&#39;s end are included.<br>     -  comments // are not seen as comments but read as data. <br>     -  the \@ on its own (without anything else to the right) is implicitly an empty line.  <br>   <br></p><p>The  \\   data-line-operator:    <br>   -  converts escaped chars like \t \n  and \(var) substitution, as with “normal&quot; string literals.<br>   -  ignores trailing spaces and source-file line terminators.<br>   -  respects  // comments on the same line and will not include these as data. <br>   -  the  \\ on its own is interpreted as \n (line feed)  thus (optionally) eliminating the <br>      need for  \n usage. <br></p><p>Both operators allow 0…n spaces/tabs on its left side, <br>thus indentation is supported.<br></p><p>Example 1. The \@ operator: <br></p><p>	 // 1.  multi-line string literal with data lines as is. <br>         // It loads each line (part) up to and including the source-file-line- end:<br>         // you can use all available characters without problems, <br>         // even \\ and \@  thus allowing you to nest e.g. Swift statements...  <br>        <br>         let xml =                                                    <br>                     \@&lt;?xml version=&quot;1.0&quot;?&gt;<br>	             \@  &lt;catalog&gt;<br>	             \@    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>	             \@       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>	             \@    &lt;/book&gt;<br>                     \@  &lt;/catalog&gt; <br> <br></p><p>   Example 2, The \\ operator: <br>   // Multi-line string literal with data lines with \n \t etc. respected: <br></p><p>         var str =<br>                     \\This is line one.\nThis is line two, with a few \t\t\t tabs in it...<br>                     \\                                            <br>                     \\This is line three: there are \(cars)                 // this is a comment.<br>                     \\ waiting in the garage. This is still line three<br></p><p> The first \@ or \\ must be on a new line, this is an error:<br></p><p>     let str =  /@data data data data…...<br>     /@data………….<br></p><p><br>A block of \@  or \\ lines must be contiguous: with no other lines in-between.<br>An empty line or other source line implicitly ends the <br>\\ or \@ block of lines. There is no terminator. <br></p><p> \@ and \\  lines can be mixed together in the same block.<br> Should this be allowed? <br></p><p><br></p><p>Imho even easier to understand and simple.<br></p><p>I could make a proposal for this later in May.<br></p><p>@Vladimir: sorry I didn’t respond directly on your email<br>You’re right. Our ideas about this have some similarity? <br>Your point: <br>   &quot;and I believe I can prove we need some start-of-line marker)” :<br> I think so too, that’s why I suggest the \\ and \@ data-line-operators. <br>as described here.  <br></p><p>Too busy, packing things to move to www.speyer.de<br>I will read swift-evolution, but will probably not<br>respond until after the 12th of May or so.<br></p><p>Although away, some feedback would be nice, thank you.<br></p><p>Kind Regards<br>TedvG<br></p><p><br></p><p><br></p><p>Fri, 29 Apr 2016 08:20:34 -0600 Erica Sadun wrote: <br></p><p>&gt;&gt; On Apr 28, 2016, at 4:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Did you ever really use multiline string literals before?<br>&gt;&gt; <br>&gt;&gt; Yes. I used Perl in the CGI script era. Believe me, I have used every quoting syntax it supports extensively, including `&#39;` strings, `&quot;` strings, `q` strings, `qq` strings, and heredocs. This proposal is educated by knowledge of their foibles.<br>&gt;&gt; <br>&gt;&gt; As outlined in the &quot;Future directions for string literals in general&quot; section, I believe alternate delimiters (so you can embed quotes) are a separate feature and should be handled in a separate proposal. Once both features are available, they can be combined. For instance, using the `_&quot;foo&quot;_` syntax I sketch there for alternate delimiters, you could say:<br>&gt;&gt; <br>&gt;&gt; 	let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 	            &quot;&lt;catalog&gt;<br>&gt;&gt; 	            &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; 	            &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 	            &quot; &lt;/book&gt;<br>&gt;&gt; 	            &quot;&lt;/catalog&gt;&quot;_<br>&gt; <br>&gt; Other than the underscores (I&#39;m not sold on them but I could live with them), this is my favorite approach:<br>&gt; <br>&gt; * It supports indented left-hand alignment, which is an important to me for readability<br>&gt; * It avoids painful `\n&quot;+` RHS constructions<br>                                             ^ what are RHS constructions ? <br>&gt; * It&#39;s easy to scan and understand<br>&gt; * It&#39;s simple and harmonious<br>                            <br>&gt; <br>&gt; — E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/0d39b311/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 30, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Example 1. The \@ operator: <br>&gt; <br>&gt; 	 // 1.  multi-line string literal with data lines as is. <br>&gt;          // It loads each line (part) up to and including the source-file-line- end:<br>&gt;          // you can use all available characters without problems, <br>&gt;          // even \\ and \@  thus allowing you to nest e.g. Swift statements...  <br>&gt;         <br>&gt;          let xml =                                                    <br>&gt;                      \@&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	             \@  &lt;catalog&gt;<br>&gt; 	             \@    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>&gt; 	             \@       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>&gt; 	             \@    &lt;/book&gt;<br>&gt;                      \@  &lt;/catalog&gt; <br>&gt;  <br>&gt; <br>&gt;    Example 2, The \\ operator: <br>&gt;    // Multi-line string literal with data lines with \n \t etc. respected: <br>&gt; <br>&gt;          var str =<br>&gt;                      \\This is line one.\nThis is line two, with a few \t\t\t tabs in it...<br>&gt;                      \\                                            <br>&gt;                      \\This is line three: there are \(cars)                 // this is a comment.<br>&gt;                      \\ waiting in the garage. This is still line three<br></p><p>There are a lot of reasons why I don&#39;t like these.<br></p><p>The first is simply that I think they&#39;re ugly and don&#39;t look like they have anything to do with string literals, but that&#39;s solvable. For instance, we could modify my proposal so that, if you were using continuation quotes, you wouldn&#39;t have to specify an end quote:<br></p><p>         let xml =                                                    <br>                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	             &quot;  &lt;catalog&gt;<br>	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>	             &quot;    &lt;/book&gt;<br>                     &quot;  &lt;/catalog&gt; <br></p><p>So let&#39;s set the bikeshed color aside and think about the deeper problem, which is that line-oriented constructs like these are a poor fit for string literals.<br></p><p>A string literal in Swift is an expression, and the defining feature of expressions is that they can be nested within other expressions. We&#39;ve been using examples where we simply assign them to variables, but quite often you don&#39;t really want to do that—you want to pass it to a function, or use an operator, or do something else with it. With an ending delimiter, that&#39;s doable:<br></p><p>	let xmlData = <br>                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	             &quot;  &lt;catalog&gt;<br>	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>	             &quot;    &lt;/book&gt;<br>                     &quot;  &lt;/catalog&gt;&quot;.encoded(as: UTF8)<br></p><p>But what if there isn&#39;t a delimiter? You would&#39;t be able to write the rest of the expression on the same line. In a semicolon-based language, that would merely lead to ugly code:<br></p><p>	let xmlData = <br>                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	             &quot;  &lt;catalog&gt;<br>	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>	             &quot;    &lt;/book&gt;<br>                     &quot;  &lt;/catalog&gt;<br>	             .encoded(as: UTF8);<br></p><p>But Swift uses newlines as line endings, so that isn&#39;t an option:<br></p><p>	let xmlData = <br>                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	             &quot;  &lt;catalog&gt;<br>	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>	             &quot;    &lt;/book&gt;<br>                     &quot;  &lt;/catalog&gt;<br>	             .encoded(as: UTF8)		// This may be a different statement!<br></p><p>You end up having to artificially add parentheses or other constructs in order to convince Swift that, no, that really is part of the same statement. That&#39;s not a good thing.<br></p><p>(This problem of fitting in well as an expression is why I favor Perl-style heredocs over Python-style `&quot;&quot;&quot;` multiline strings. Heredoc placeholders work really well even in complicated expressions, whereas `&quot;&quot;&quot;` multiline strings split expressions in half over potentially enormous amounts of code. This might seem at odds with my support for the proposal at hand, but I imagine this proposal being aimed at strings that are a few lines long, where a heredoc would be overkill. If you&#39;re going to have two different features which do similar things, you should at least make sure they have different strengths and weaknesses.)<br></p><p>But you could argue that it&#39;s simply a matter of style that, unfortunately, you&#39;ll usually have to assign long strings to constants. Fine. There&#39;s still a deeper problem with this design.<br></p><p>You propose a pair of multi-line-only string literals. One of them supports escapes, the other doesn&#39;t; both of them avoid the need to escape quotes.<br></p><p>Fine. Now what if you need to disable escapes or avoid escaping quotes in a single-line string? What if your string is, say, a regular expression like `&quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+&quot;`—something very short, but full of backslashes and quotes?<br></p><p>The constructs you propose are very poorly suited for that—remember, because they&#39;re line-oriented, they don&#39;t work well in the middle of a more complicated expression—and they aren&#39;t built on features which generalize to act on single-line strings. So now we have to invent some separate mechanism which does the same thing to single-line strings, but works in a different and incompatible way. That means we now have five ad-hoc features, each of which works differently, with no way to transport your knowledge from one of them to another:<br></p><p>* Single-line strings<br>* Disabling escapes for single-line strings<br>* Unescaped quotes for single-line strings<br>* Multi-line-only strings with unescaped quotes<br>* Multi-line-only strings with unescaped quotes and disabled escapes<br></p><p>My proposal and the other features I sketch, on the other hand, does the same things with only three features, which you can use in any combination:<br></p><p>* Single- or multi-line strings<br>* Disabling escapes for any string<br>* Unescaped quotes for any string<br></p><p>This kind of modular design, where a particular task is done in the same way throughout the language, is part of what makes a good language good.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>May  1, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Brent,<br></p><p>@Dave - Hi Dave, please see at the end of this email. <br></p><p>Thanks for your energetic reply, Brent.<br>First of all, I think there is a place in Swift for “your” and “mine” proposing solutions <br>together. I will reply further inline -&gt; <br>&gt; On 30.04.2016, at 09:43, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Example 1. The \@ operator: <br>&gt;&gt; <br>&gt;&gt; 	 // 1.  multi-line string literal with data lines as is. <br>&gt;&gt;         // It loads each line (part) up to and including the source-file-line- end:<br>&gt;&gt;         // you can use all available characters without problems, <br>&gt;&gt;         // even \\ and \@  thus allowing you to nest e.g. Swift statements...  <br>&gt;&gt; <br>&gt;&gt;         let xml =                                                    <br>&gt;&gt;                     \@&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 	             \@  &lt;catalog&gt;<br>&gt;&gt; 	             \@    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>&gt;&gt; 	             \@       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>&gt;&gt; 	             \@    &lt;/book&gt;<br>&gt;&gt;                     \@  &lt;/catalog&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;   Example 2, The \\ operator: <br>&gt;&gt;   // Multi-line string literal with data lines with \n \t etc. respected: <br>&gt;&gt; <br>&gt;&gt;         var str =<br>&gt;&gt;                     \\This is line one.\nThis is line two, with a few \t\t\t tabs in it...<br>&gt;&gt;                     \\                                            <br>&gt;&gt;                     \\This is line three: there are \(cars)                 // this is a comment.<br>&gt;&gt;                     \\ waiting in the garage. This is still line three<br>&gt; <br>&gt; There are a lot of reasons why I don&#39;t like these.<br>&gt; <br>&gt; The first is simply that I think they&#39;re ugly<br>To me, that is not relevant: <br>If something is “ugly”  or not is tied to different and unique <br>personal reference, accumulated by experience and <br>human instinct and are thus not comparable because no two <br>beings are the same. Ergo: This voids a discussion between <br>you and me about this subjective aspect “ugliness” <br>Still, this aspect should be subordinate to functionality<br> (in this case the functionality of a programming language).<br></p><p><br>&gt; and don&#39;t look like they have anything to do with string literals,<br>You’re right about that:  they are not *string literals* but *data lines*.<br></p><p> <br>&gt; but that&#39;s solvable. For instance, we could modify my proposal so that, if you were using continuation quotes, you wouldn&#39;t have to specify an end quote:<br>&gt; <br>&gt;         let xml =                                                    <br>&gt;                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	             &quot;  &lt;catalog&gt;<br>&gt; 	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>&gt; 	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>&gt; 	             &quot;    &lt;/book&gt;<br>&gt;                     &quot;  &lt;/catalog&gt; <br></p><p>Essentially the above is similar to what I propose with “my” data line,<br>that is, starting each line with a special character/token. But that is where the<br>similarity ends: It does not offer processing for *both*:<br>- &quot;as-is&quot; character data<br>-  character data where escaped characters need to be processed.<br>   <br>&gt; <br>&gt; So let&#39;s set the bikeshed color aside and think about the deeper problem, which is that line-oriented constructs like these are a poor fit for string literals.<br></p><p>&gt; <br>&gt; A string literal in Swift is an expression, and the defining feature of expressions is that they can be nested within other expressions.<br>That is logically correct, (but desirable in all cases? (readability)) however: <br>       <br>As said before, these \@…..  and \\…..   are data lines, not string literals. <br>They are not intended to replace string literals.  A slightly different concept.<br></p><p>Data lines are just that and -apart from assignment, that is to be loaded in a String variable or constant- <br>not really intended to take further part in expressions. <br>however you can still do that, as shown further below.  <br></p><p><br>&gt; We&#39;ve been using examples where we simply assign them to variables, but quite often you don&#39;t really want to do that—you want to pass it to a function, or use an operator, or do something else with it. With an ending delimiter, that&#39;s doable:<br>&gt; <br>&gt; 	let xmlData = <br>&gt;                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	             &quot;  &lt;catalog&gt;<br>&gt; 	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>&gt; 	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>&gt; 	             &quot;    &lt;/book&gt;<br>&gt;                     &quot;  &lt;/catalog&gt;&quot;.encoded(as: UTF8)<br>    I do experience this as being “ugly”, but again, this is personal.<br>&gt; <br>&gt; But what if there isn&#39;t a delimiter? You would&#39;t be able to write the rest of the expression on the same line. In a semicolon-based language, that would merely lead to ugly code:<br>&gt; <br>&gt; 	let xmlData = <br>&gt;                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	             &quot;  &lt;catalog&gt;<br>&gt; 	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>&gt; 	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>&gt; 	             &quot;    &lt;/book&gt;<br>&gt;                     &quot;  &lt;/catalog&gt;<br>&gt; 	             .encoded(as: UTF8);<br>&gt; <br></p><p><br></p><p>In “my” case this would be:<br></p><p>   let xml =                                                    <br>                     \@&lt;?xml version=&quot;1.0&quot;?&gt;<br>	             \@  &lt;catalog&gt;<br>	             \@    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>	             \@       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>	             \@    &lt;/book&gt;<br>                     \@  &lt;/catalog&gt; <br>                          .encoded(as: UTF8)<br>  <br></p><p>&gt; But Swift uses newlines as line endings, so that isn&#39;t an option:<br>&gt; <br>&gt; 	let xmlData = <br>&gt;                     &quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	             &quot;  &lt;catalog&gt;<br>&gt; 	             &quot;    &lt;book id=&quot;bk101&quot; empty=“”&gt;      // this is not regarded as a comment.<br>&gt; 	             &quot;       &lt;author&gt;//¯\&quot;_(ツ)_//&lt;/author&gt;<br>&gt; 	             &quot;    &lt;/book&gt;<br>&gt;                     &quot;  &lt;/catalog&gt;<br>&gt; 	             .encoded(as: UTF8)		// This may be a different statement!<br>That is *not* the case with the \@ data line concept, because the<br>line ending is part of the data line and is therefore “swallowed”<br>by the compiler, generating an intermediate variable before it continues<br>with whatever might be waiting after that. <br>&gt; <br>&gt; You end up having to artificially add parentheses or other constructs in order to convince Swift that, no, that really is part of the same statement. That&#39;s not a good thing.<br>&gt; <br>I think you are wrong here, () are not necessary:  Whitespace and line ends are allowed in-between, for example<br></p><p>     let ar = [4,5,6,3,2]<br>          .sort()<br></p><p>is perfectly ok.<br></p><p>and so would even be:<br>let strArray = [ <br>    \@………………..<br>    \@…………<br>    \@………………..<br>,<br>    \\………………..<br>    \\………………..<br>    \\…………<br>    \\………………..<br>    \\………………..<br>,<br>    \@…………………<br>] .sort()<br></p><p><br></p><p><br>&gt; (This problem of fitting in well as an expression is why I favor Perl-style heredocs over Python-style `&quot;&quot;&quot;` multiline strings. Heredoc placeholders work really well even in complicated expressions, whereas `&quot;&quot;&quot;` multiline strings split expressions in half over potentially enormous amounts of code. This might seem at odds with my support for the proposal at hand, but I imagine this proposal being aimed at strings that are a few lines long, where a heredoc would be overkill. If you&#39;re going to have two different features which do similar things, you should at least make sure they have different strengths and weaknesses.)<br></p><p>&gt; <br>&gt; But you could argue that it&#39;s simply a matter of style that, unfortunately, you&#39;ll usually have to assign long strings to constants. Fine. There&#39;s still a deeper problem with this design.<br>&gt; <br>&gt; You propose a pair of multi-line-only string literals. One of them supports escapes, the other doesn&#39;t; both of them avoid the need to escape quotes.<br>Right.<br>&gt; <br>&gt; Fine. Now what if you need to disable escapes or avoid escaping quotes in a single-line string? What if your string is, say, a regular expression like `&quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+&quot;`—something very short, but full of backslashes and quotes?<br>No problem:  e.g.<br></p><p>         func foo( parm1: <br>             \@`&quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+”`—<br>            .trim(),                            // Add this If you wish to remove the trailing spaces and line end  (String extension)   <br>            parm2: 10, <br>            parm3: anotherVar)<br>    <br></p><p>( i like to use lots of vertical space) <br></p><p>&gt; <br>&gt; The constructs you propose are very poorly suited for that—remember, because they&#39;re line-oriented,<br>&gt; they don&#39;t work well in the middle of a more complicated expression—<br>As described they are not intended to be there, but still they can: see function in the following example:<br></p><p>&gt; and they aren&#39;t built on features which generalize to act on single-line strings.<br>?  You can perfectly well process a single data lines (single-line string) like so: <br>     func f() <br>     {<br>          var fooRes = foo  (<br>                                         \@`&quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+”`—<br>                                         .trim()                                   ).yetAnotherFunction() <br>    }<br></p><p><br></p><p>&gt; So now we have to invent some separate mechanism which does the same thing to single-line strings, but works in a different and incompatible way. That means we now have five ad-hoc features, each of which works differently, with no way to transport your knowledge from one of them to another:<br>&gt; <br>&gt; * Single-line strings<br>&gt; * Disabling escapes for single-line strings<br>&gt; * Unescaped quotes for single-line strings<br>&gt; * Multi-line-only strings with unescaped quotes<br>&gt; * Multi-line-only strings with unescaped quotes and disabled escapes<br>&gt; <br>&gt; My proposal and the other features I sketch, on the other hand, does the same things with only three features, which you can use in any combination:<br>&gt; <br>&gt; * Single- or multi-line strings<br>&gt; * Disabling escapes for any string<br>&gt; * Unescaped quotes for any string<br></p><p>Yes, they do, but the solution you propose is stil delimiter-sensitive. <br>and therefore prone to data errors. You can’t get around that. <br>&gt; <br>&gt; This kind of modular design, where a particular task is done in the same way throughout the language, is part of what makes a good language good.<br></p><p>In most cases, yes, but different methods e.g those preferred by FP programmers and e.g. those preferred bij OOP programmers. can and should happily co-exist<br>in Swift. In this case,  this proposal of yours is not bad all. Imho, neither is mine. <br>They both serve different purposes and programming styles. <br>they can exist together, as they are on different wave lengths, so to speak.<br>One is then free to use what fits a certain programming inclination at best. <br></p><p><br>@Dave  also<br>what do you think about this? <br>I am trying to avoid the conclusion that most Swift-evolution participants are very much FP biased.<br>is this the case? <br>(some have ventilated this before in different tunes) <br>That wouldn’t be too much of a problem where it not for the (hopefully wrong) impressions that:<br>- Functional Programmers think (like the LISP-ers did in the seventies) that they are superior and Mathematically Correct,<br>there is no other way, and therefore all else is hopelessly wrong and should be recklessly removed (from Swift in this case)<br>like removing language elements that are not in line with FP?<br></p><p>Consider for a moment that Swift-Evolution was OOP-dominated<br>and therefore happily removing closures/lambdas protocols, <br>because they have never used it or even do not understand it?<br>would you accept that?<br></p><p><br>(protocols in Swift are cool btw, as for me, <br>I take the best of both worlds whether FP and/or OOP) <br></p><p><br>Have a nice weekend!<br>TedvG<br></p><p><br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
