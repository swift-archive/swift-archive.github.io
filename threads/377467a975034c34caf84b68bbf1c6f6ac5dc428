<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>@objc and private methods</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>July 21, 2016 at 02:00:00pm</p></header><div class="content"><p>I wanted to get thoughts on the use of @objc and private methods.  Should this usage be avoided or leveraged?<br></p><p>I have seen some code where things like UIButton and Gesture recognizer handlers are defined as being private.  I would have thought this would result in a compiler error given objective-c doesn’t support private accessors.  However, it compiles and works as expected (kind of).<br></p><p>One plus for defining the handlers as private is they aren’t visible to swift outside of the file they are defined in.  The problem is you can run into some issues with inheritance if you define the same handler in a derived class.  Take the following simple example:<br></p><p>class Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 1&quot; )<br>    }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 2&quot; )<br>    }<br>}<br></p><p>This will result in the following compiler error:<br></p><p>Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C selector<br></p><p>That error makes sense in an Objective-C context as Test2 has two different methods defined with the same objective-c selector (somefunc).  Swift can tell them apart as they are private to each class, but Obj-C can’t tell them apart as they have the same selector thus the error.<br></p><p>One workaround would be to give the method a different Objective-C names such as @objc(test2_somefunc); however, that could really lead to some unexpected results depending on what selector is used to call somefunc.  Test2 would need to “register” a different selector for somefunc then Test does for whatever is calling it on the Objective-C side (yuck!).<br></p><p>This can of course be solved by not making the method private which allows Test2 to explicitly override somefunc.<br></p><p>class Test {<br>   @objc func somefunc() {<br>       print( &quot;hello 1&quot; )<br>   }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>   @objc override func somefunc() {<br>       print( &quot;hello 2&quot; )<br>   }<br>}<br></p><p>I would say that when declaring @objc methods they shouldn’t be private and should have the same (public/internal) access method as their containing class.  What’s your thoughts?  Why does swift allow a method to be declared as both @objc and private?<br></p><p>Thanks,<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>@objc and private methods</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July 21, 2016 at 11:00:00pm</p></header><div class="content"><p>I think @objc makes the function an Objective-C function, so the private is<br>no longer making the function private in Swift way, but in Objective-C way.<br>In C++,  sub-class can call super-class&#39;s private method. What you have to<br>do is to override the function.<br></p><p>class Test {<br></p><p>    @objc private func somefunc() {<br></p><p>        print( &quot;hello 1&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br>class Test2: Test {<br></p><p>    @objc override private func somefunc() {<br></p><p>        print( &quot;hello 2&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>Zhaoxin<br></p><p><br></p><p><br>On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I wanted to get thoughts on the use of @objc and private methods.  Should<br>&gt; this usage be avoided or leveraged?<br>&gt;<br>&gt; I have seen some code where things like UIButton and Gesture recognizer<br>&gt; handlers are defined as being private.  I would have thought this would<br>&gt; result in a compiler error given objective-c doesn’t support private<br>&gt; accessors.  However, it compiles and works as expected (kind of).<br>&gt;<br>&gt; One plus for defining the handlers as private is they aren’t visible to<br>&gt; swift outside of the file they are defined in.  The problem is you can run<br>&gt; into some issues with inheritance if you define the same handler in a<br>&gt; derived class.  Take the following simple example:<br>&gt;<br>&gt; class Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This will result in the following compiler error:<br>&gt;<br>&gt; Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with<br>&gt; method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C<br>&gt; selector<br>&gt;<br>&gt; That error makes sense in an Objective-C context as Test2 has two<br>&gt; different methods defined with the same objective-c selector (somefunc).<br>&gt; Swift can tell them apart as they are private to each class, but Obj-C<br>&gt; can’t tell them apart as they have the same selector thus the error.<br>&gt;<br>&gt; One workaround would be to give the method a different Objective-C names<br>&gt; such as @objc(test2_somefunc); however, that could really lead to some<br>&gt; unexpected results depending on what selector is used to call somefunc.<br>&gt; Test2 would need to “register” a different selector for somefunc then Test<br>&gt; does for whatever is calling it on the Objective-C side (yuck!).<br>&gt;<br>&gt; This can of course be solved by not making the method private which allows<br>&gt; Test2 to explicitly override somefunc.<br>&gt;<br>&gt; class Test {<br>&gt;    @objc func somefunc() {<br>&gt;        print( &quot;hello 1&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;    @objc override func somefunc() {<br>&gt;        print( &quot;hello 2&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; I would say that when declaring @objc methods they shouldn’t be private<br>&gt; and should have the same (public/internal) access method as their<br>&gt; containing class.  What’s your thoughts?  Why does swift allow a method to<br>&gt; be declared as both @objc and private?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160721/fae2c10a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>@objc and private methods</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>July 21, 2016 at 05:00:00pm</p></header><div class="content"><p>If Test and Test2 are in separate files, swift doesn’t allow you to do the override as it “can’t see” the definition of the private method in Test.<br></p><p><br>From: Zhao Xin &lt;owenzx at gmail.com&gt;<br>Date: Thursday, July 21, 2016 at 11:06 AM<br>To: Tod Cunningham &lt;tcunningham at vectorform.com&gt;<br>Cc: &quot;swift-users at swift.org&quot; &lt;swift-users at swift.org&gt;<br>Subject: Re: [swift-users] @objc and private methods<br></p><p>I think @objc makes the function an Objective-C function, so the private is no longer making the function private in Swift way, but in Objective-C way. In C++,  sub-class can call super-class&#39;s private method. What you have to do is to override the function.<br></p><p><br>class Test {<br></p><p>    @objc private func somefunc() {<br></p><p>        print( &quot;hello 1&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>class Test2: Test {<br></p><p>    @objc override private func somefunc() {<br></p><p>        print( &quot;hello 2&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>Zhaoxin<br></p><p><br></p><p><br></p><p>On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>I wanted to get thoughts on the use of @objc and private methods.  Should this usage be avoided or leveraged?<br></p><p>I have seen some code where things like UIButton and Gesture recognizer handlers are defined as being private.  I would have thought this would result in a compiler error given objective-c doesn’t support private accessors.  However, it compiles and works as expected (kind of).<br></p><p>One plus for defining the handlers as private is they aren’t visible to swift outside of the file they are defined in.  The problem is you can run into some issues with inheritance if you define the same handler in a derived class.  Take the following simple example:<br></p><p>class Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 1&quot; )<br>    }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 2&quot; )<br>    }<br>}<br></p><p>This will result in the following compiler error:<br></p><p>Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C selector<br></p><p>That error makes sense in an Objective-C context as Test2 has two different methods defined with the same objective-c selector (somefunc).  Swift can tell them apart as they are private to each class, but Obj-C can’t tell them apart as they have the same selector thus the error.<br></p><p>One workaround would be to give the method a different Objective-C names such as @objc(test2_somefunc); however, that could really lead to some unexpected results depending on what selector is used to call somefunc.  Test2 would need to “register” a different selector for somefunc then Test does for whatever is calling it on the Objective-C side (yuck!).<br></p><p>This can of course be solved by not making the method private which allows Test2 to explicitly override somefunc.<br></p><p>class Test {<br>   @objc func somefunc() {<br>       print( &quot;hello 1&quot; )<br>   }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>   @objc override func somefunc() {<br>       print( &quot;hello 2&quot; )<br>   }<br>}<br></p><p>I would say that when declaring @objc methods they shouldn’t be private and should have the same (public/internal) access method as their containing class.  What’s your thoughts?  Why does swift allow a method to be declared as both @objc and private?<br></p><p>Thanks,<br></p><p><br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>@objc and private methods</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July 22, 2016 at 01:00:00am</p></header><div class="content"><p>Then you should file a bug.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 22, 2016 at 1:03 AM, Tod Cunningham &lt;tcunningham at vectorform.com&gt;<br>wrote:<br></p><p>&gt; If Test and Test2 are in separate files, swift doesn’t allow you to do the<br>&gt; override as it “can’t see” the definition of the private method in Test.<br>&gt;<br>&gt;<br>&gt; From: Zhao Xin &lt;owenzx at gmail.com&gt;<br>&gt; Date: Thursday, July 21, 2016 at 11:06 AM<br>&gt; To: Tod Cunningham &lt;tcunningham at vectorform.com&gt;<br>&gt; Cc: &quot;swift-users at swift.org&quot; &lt;swift-users at swift.org&gt;<br>&gt; Subject: Re: [swift-users] @objc and private methods<br>&gt;<br>&gt; I think @objc makes the function an Objective-C function, so the private<br>&gt; is no longer making the function private in Swift way, but in Objective-C<br>&gt; way. In C++,  sub-class can call super-class&#39;s private method. What you<br>&gt; have to do is to override the function.<br>&gt;<br>&gt;<br>&gt; class Test {<br>&gt;<br>&gt;     @objc private func somefunc() {<br>&gt;<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; class Test2: Test {<br>&gt;<br>&gt;     @objc override private func somefunc() {<br>&gt;<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; I wanted to get thoughts on the use of @objc and private methods.  Should<br>&gt; this usage be avoided or leveraged?<br>&gt;<br>&gt; I have seen some code where things like UIButton and Gesture recognizer<br>&gt; handlers are defined as being private.  I would have thought this would<br>&gt; result in a compiler error given objective-c doesn’t support private<br>&gt; accessors.  However, it compiles and works as expected (kind of).<br>&gt;<br>&gt; One plus for defining the handlers as private is they aren’t visible to<br>&gt; swift outside of the file they are defined in.  The problem is you can run<br>&gt; into some issues with inheritance if you define the same handler in a<br>&gt; derived class.  Take the following simple example:<br>&gt;<br>&gt; class Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This will result in the following compiler error:<br>&gt;<br>&gt; Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with<br>&gt; method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C<br>&gt; selector<br>&gt;<br>&gt; That error makes sense in an Objective-C context as Test2 has two<br>&gt; different methods defined with the same objective-c selector (somefunc).<br>&gt; Swift can tell them apart as they are private to each class, but Obj-C<br>&gt; can’t tell them apart as they have the same selector thus the error.<br>&gt;<br>&gt; One workaround would be to give the method a different Objective-C names<br>&gt; such as @objc(test2_somefunc); however, that could really lead to some<br>&gt; unexpected results depending on what selector is used to call somefunc.<br>&gt; Test2 would need to “register” a different selector for somefunc then Test<br>&gt; does for whatever is calling it on the Objective-C side (yuck!).<br>&gt;<br>&gt; This can of course be solved by not making the method private which allows<br>&gt; Test2 to explicitly override somefunc.<br>&gt;<br>&gt; class Test {<br>&gt;    @objc func somefunc() {<br>&gt;        print( &quot;hello 1&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;    @objc override func somefunc() {<br>&gt;        print( &quot;hello 2&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; I would say that when declaring @objc methods they shouldn’t be private<br>&gt; and should have the same (public/internal) access method as their<br>&gt; containing class.  What’s your thoughts?  Why does swift allow a method to<br>&gt; be declared as both @objc and private?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160722/573f495b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b74cd4039f0c53145a186868ab569c0?s=50"></div><header><strong>@objc and private methods</strong> from <string>Josh Parmenter</string> &lt;jparmenter at vectorform.com&gt;<p>July 21, 2016 at 06:00:00pm</p></header><div class="content"><p>Is this a bug? I think this is more a question of what is best practice.<br>Best,<br>Josh<br></p><p>On Jul 21, 2016, at 10:48 AM, Zhao Xin via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br></p><p>Then you should file a bug.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 22, 2016 at 1:03 AM, Tod Cunningham &lt;tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&gt; wrote:<br>If Test and Test2 are in separate files, swift doesn’t allow you to do the override as it “can’t see” the definition of the private method in Test.<br></p><p><br>From: Zhao Xin &lt;owenzx at gmail.com&lt;mailto:owenzx at gmail.com&gt;&gt;<br>Date: Thursday, July 21, 2016 at 11:06 AM<br>To: Tod Cunningham &lt;tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&gt;<br>Cc: &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>Subject: Re: [swift-users] @objc and private methods<br></p><p>I think @objc makes the function an Objective-C function, so the private is no longer making the function private in Swift way, but in Objective-C way. In C++,  sub-class can call super-class&#39;s private method. What you have to do is to override the function.<br></p><p><br>class Test {<br></p><p>    @objc private func somefunc() {<br></p><p>        print( &quot;hello 1&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>class Test2: Test {<br></p><p>    @objc override private func somefunc() {<br></p><p>        print( &quot;hello 2&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>Zhaoxin<br></p><p><br></p><p><br></p><p>On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt; wrote:<br>I wanted to get thoughts on the use of @objc and private methods.  Should this usage be avoided or leveraged?<br></p><p>I have seen some code where things like UIButton and Gesture recognizer handlers are defined as being private.  I would have thought this would result in a compiler error given objective-c doesn’t support private accessors.  However, it compiles and works as expected (kind of).<br></p><p>One plus for defining the handlers as private is they aren’t visible to swift outside of the file they are defined in.  The problem is you can run into some issues with inheritance if you define the same handler in a derived class.  Take the following simple example:<br></p><p>class Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 1&quot; )<br>    }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 2&quot; )<br>    }<br>}<br></p><p>This will result in the following compiler error:<br></p><p>Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C selector<br></p><p>That error makes sense in an Objective-C context as Test2 has two different methods defined with the same objective-c selector (somefunc).  Swift can tell them apart as they are private to each class, but Obj-C can’t tell them apart as they have the same selector thus the error.<br></p><p>One workaround would be to give the method a different Objective-C names such as @objc(test2_somefunc); however, that could really lead to some unexpected results depending on what selector is used to call somefunc.  Test2 would need to “register” a different selector for somefunc then Test does for whatever is calling it on the Objective-C side (yuck!).<br></p><p>This can of course be solved by not making the method private which allows Test2 to explicitly override somefunc.<br></p><p>class Test {<br>   @objc func somefunc() {<br>       print( &quot;hello 1&quot; )<br>   }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>   @objc override func somefunc() {<br>       print( &quot;hello 2&quot; )<br>   }<br>}<br></p><p>I would say that when declaring @objc methods they shouldn’t be private and should have the same (public/internal) access method as their containing class.  What’s your thoughts?  Why does swift allow a method to be declared as both @objc and private?<br></p><p>Thanks,<br></p><p><br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>@objc and private methods</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July 22, 2016 at 10:00:00am</p></header><div class="content"><p>My previous reply was not correct.<br></p><p>&gt; I think @objc makes the function an Objective-C function, so the private<br>&gt; is no longer making the function private in Swift way, but in Objective-C<br>&gt; way. In C++,  sub-class can call super-class&#39;s private method. What you<br>&gt; have to do is to override the function.<br></p><p><br>​@objc makes the function available to Objective-C, but not only<br>Objective-C. So the function works in both Objective-C and Swift. In Swift,<br>the private is different from other languages, its scope is the surrounding<br>​file. That is why the override doesn&#39;t work if both classes are separated<br>in different files.<br></p><p>If the two classes are in the same file, below code also works.<br></p><p>class Test {<br></p><p><br></p><p>    private func somefunc() {<br></p><p><br></p><p>        print( &quot;hello 1&quot; )<br></p><p><br></p><p>    }<br></p><p><br></p><p>}<br></p><p><br></p><p><br>class Test2: Test {<br></p><p><br></p><p>    override private func somefunc() {<br></p><p><br></p><p>        print( &quot;hello 2&quot; )<br></p><p><br></p><p>    }<br></p><p><br></p><p>}<br></p><p>So the only problem is with @objc and put the two classes into different<br>files, you can&#39;t override the function as it is over-scoped in Swift.<br>However, you can&#39;t use it in the same name either, as Objective-C will find<br>the function names are conflicts.<br></p><p>So the resolution is either to use it as it is, or to file a bug to<br>eliminate using @objc and private together as there is no private access<br>level in Objective-C.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 22, 2016 at 2:22 AM, Josh Parmenter &lt;jparmenter at vectorform.com&gt;<br>wrote:<br></p><p>&gt; Is this a bug? I think this is more a question of what is best practice.<br>&gt; Best,<br>&gt; Josh<br>&gt;<br>&gt; On Jul 21, 2016, at 10:48 AM, Zhao Xin via swift-users &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt; Then you should file a bug.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 1:03 AM, Tod Cunningham &lt;<br>&gt; tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&gt; wrote:<br>&gt; If Test and Test2 are in separate files, swift doesn’t allow you to do the<br>&gt; override as it “can’t see” the definition of the private method in Test.<br>&gt;<br>&gt;<br>&gt; From: Zhao Xin &lt;owenzx at gmail.com&lt;mailto:owenzx at gmail.com&gt;&gt;<br>&gt; Date: Thursday, July 21, 2016 at 11:06 AM<br>&gt; To: Tod Cunningham &lt;tcunningham at vectorform.com&lt;mailto:<br>&gt; tcunningham at vectorform.com&gt;&gt;<br>&gt; Cc: &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&quot; &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>&gt; Subject: Re: [swift-users] @objc and private methods<br>&gt;<br>&gt; I think @objc makes the function an Objective-C function, so the private<br>&gt; is no longer making the function private in Swift way, but in Objective-C<br>&gt; way. In C++,  sub-class can call super-class&#39;s private method. What you<br>&gt; have to do is to override the function.<br>&gt;<br>&gt;<br>&gt; class Test {<br>&gt;<br>&gt;     @objc private func somefunc() {<br>&gt;<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; class Test2: Test {<br>&gt;<br>&gt;     @objc override private func somefunc() {<br>&gt;<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt; wrote:<br>&gt; I wanted to get thoughts on the use of @objc and private methods.  Should<br>&gt; this usage be avoided or leveraged?<br>&gt;<br>&gt; I have seen some code where things like UIButton and Gesture recognizer<br>&gt; handlers are defined as being private.  I would have thought this would<br>&gt; result in a compiler error given objective-c doesn’t support private<br>&gt; accessors.  However, it compiles and works as expected (kind of).<br>&gt;<br>&gt; One plus for defining the handlers as private is they aren’t visible to<br>&gt; swift outside of the file they are defined in.  The problem is you can run<br>&gt; into some issues with inheritance if you define the same handler in a<br>&gt; derived class.  Take the following simple example:<br>&gt;<br>&gt; class Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This will result in the following compiler error:<br>&gt;<br>&gt; Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with<br>&gt; method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C<br>&gt; selector<br>&gt;<br>&gt; That error makes sense in an Objective-C context as Test2 has two<br>&gt; different methods defined with the same objective-c selector (somefunc).<br>&gt; Swift can tell them apart as they are private to each class, but Obj-C<br>&gt; can’t tell them apart as they have the same selector thus the error.<br>&gt;<br>&gt; One workaround would be to give the method a different Objective-C names<br>&gt; such as @objc(test2_somefunc); however, that could really lead to some<br>&gt; unexpected results depending on what selector is used to call somefunc.<br>&gt; Test2 would need to “register” a different selector for somefunc then Test<br>&gt; does for whatever is calling it on the Objective-C side (yuck!).<br>&gt;<br>&gt; This can of course be solved by not making the method private which allows<br>&gt; Test2 to explicitly override somefunc.<br>&gt;<br>&gt; class Test {<br>&gt;    @objc func somefunc() {<br>&gt;        print( &quot;hello 1&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;    @objc override func somefunc() {<br>&gt;        print( &quot;hello 2&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; I would say that when declaring @objc methods they shouldn’t be private<br>&gt; and should have the same (public/internal) access method as their<br>&gt; containing class.  What’s your thoughts?  Why does swift allow a method to<br>&gt; be declared as both @objc and private?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160722/33ebe573/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>@objc and private methods</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>July 22, 2016 at 01:00:00pm</p></header><div class="content"><p>What’s the best practice around using @objc on private methods?  While they can be used together, should their use be avoided or embraced?<br></p><p>Thanks,<br>Tod<br></p><p>From: Zhao Xin &lt;owenzx at gmail.com&gt;<br>Date: Thursday, July 21, 2016 at 10:42 PM<br>To: Josh Parmenter &lt;jparmenter at vectorform.com&gt;<br>Cc: Tod Cunningham &lt;tcunningham at vectorform.com&gt;, &quot;swift-users at swift.org&quot; &lt;swift-users at swift.org&gt;<br>Subject: Re: [swift-users] @objc and private methods<br></p><p>My previous reply was not correct.<br>I think @objc makes the function an Objective-C function, so the private is no longer making the function private in Swift way, but in Objective-C way. In C++,  sub-class can call super-class&#39;s private method. What you have to do is to override the function.<br></p><p>​@objc makes the function available to Objective-C, but not only Objective-C. So the function works in both Objective-C and Swift. In Swift, the private is different from other languages, its scope is the surrounding ​file. That is why the override doesn&#39;t work if both classes are separated in different files.<br></p><p>If the two classes are in the same file, below code also works.<br></p><p><br>class Test {<br></p><p><br></p><p>    private func somefunc() {<br></p><p><br></p><p>        print( &quot;hello 1&quot; )<br></p><p><br></p><p>    }<br></p><p><br></p><p>}<br></p><p><br></p><p><br></p><p><br></p><p>class Test2: Test {<br></p><p><br></p><p>    override private func somefunc() {<br></p><p><br></p><p>        print( &quot;hello 2&quot; )<br></p><p><br></p><p>    }<br></p><p><br></p><p>}<br></p><p>So the only problem is with @objc and put the two classes into different files, you can&#39;t override the function as it is over-scoped in Swift. However, you can&#39;t use it in the same name either, as Objective-C will find the function names are conflicts.<br></p><p>So the resolution is either to use it as it is, or to file a bug to eliminate using @objc and private together as there is no private access level in Objective-C.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 22, 2016 at 2:22 AM, Josh Parmenter &lt;jparmenter at vectorform.com&lt;mailto:jparmenter at vectorform.com&gt;&gt; wrote:<br>Is this a bug? I think this is more a question of what is best practice.<br>Best,<br>Josh<br></p><p>On Jul 21, 2016, at 10:48 AM, Zhao Xin via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt; wrote:<br></p><p>Then you should file a bug.<br></p><p>Zhaoxin<br></p><p>On Fri, Jul 22, 2016 at 1:03 AM, Tod Cunningham &lt;tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&lt;mailto:tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&gt;&gt; wrote:<br>If Test and Test2 are in separate files, swift doesn’t allow you to do the override as it “can’t see” the definition of the private method in Test.<br></p><p><br>From: Zhao Xin &lt;owenzx at gmail.com&lt;mailto:owenzx at gmail.com&gt;&lt;mailto:owenzx at gmail.com&lt;mailto:owenzx at gmail.com&gt;&gt;&gt;<br>Date: Thursday, July 21, 2016 at 11:06 AM<br>To: Tod Cunningham &lt;tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&lt;mailto:tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&gt;&gt;<br>Cc: &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&quot; &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt;<br>Subject: Re: [swift-users] @objc and private methods<br></p><p>I think @objc makes the function an Objective-C function, so the private is no longer making the function private in Swift way, but in Objective-C way. In C++,  sub-class can call super-class&#39;s private method. What you have to do is to override the function.<br></p><p><br>class Test {<br></p><p>    @objc private func somefunc() {<br></p><p>        print( &quot;hello 1&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>class Test2: Test {<br></p><p>    @objc override private func somefunc() {<br></p><p>        print( &quot;hello 2&quot; )<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>Zhaoxin<br></p><p><br></p><p><br>On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt;&gt; wrote:<br>I wanted to get thoughts on the use of @objc and private methods.  Should this usage be avoided or leveraged?<br></p><p>I have seen some code where things like UIButton and Gesture recognizer handlers are defined as being private.  I would have thought this would result in a compiler error given objective-c doesn’t support private accessors.  However, it compiles and works as expected (kind of).<br></p><p>One plus for defining the handlers as private is they aren’t visible to swift outside of the file they are defined in.  The problem is you can run into some issues with inheritance if you define the same handler in a derived class.  Take the following simple example:<br></p><p>class Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 1&quot; )<br>    }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>    @objc private func somefunc() {<br>        print( &quot;hello 2&quot; )<br>    }<br>}<br></p><p>This will result in the following compiler error:<br></p><p>Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C selector<br></p><p>That error makes sense in an Objective-C context as Test2 has two different methods defined with the same objective-c selector (somefunc).  Swift can tell them apart as they are private to each class, but Obj-C can’t tell them apart as they have the same selector thus the error.<br></p><p>One workaround would be to give the method a different Objective-C names such as @objc(test2_somefunc); however, that could really lead to some unexpected results depending on what selector is used to call somefunc.  Test2 would need to “register” a different selector for somefunc then Test does for whatever is calling it on the Objective-C side (yuck!).<br></p><p>This can of course be solved by not making the method private which allows Test2 to explicitly override somefunc.<br></p><p>class Test {<br>   @objc func somefunc() {<br>       print( &quot;hello 1&quot; )<br>   }<br>}<br></p><p>-- in another file –<br></p><p>class Test2: Test {<br>   @objc override func somefunc() {<br>       print( &quot;hello 2&quot; )<br>   }<br>}<br></p><p>I would say that when declaring @objc methods they shouldn’t be private and should have the same (public/internal) access method as their containing class.  What’s your thoughts?  Why does swift allow a method to be declared as both @objc and private?<br></p><p>Thanks,<br></p><p><br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6cceede6579cba5bf1f48581ea904f1b?s=50"></div><header><strong>@objc and private methods</strong> from <string>Svein Halvor Halvorsen</string> &lt;svein.h at lvor.halvorsen.cc&gt;<p>July 23, 2016 at 10:00:00pm</p></header><div class="content"><p>I usually mark my target-action methods like so:<br></p><p>private dynamic func didTapNext(sender: UIButton)<br></p><p>&quot;dynamic&quot; makes the compiler generate code for dynamic dispatch, that is<br>runtime message passing, like objc. The &quot;private&quot; part doesn&#39;t change that,<br>it just reduces clutter.<br></p><p><br>2016-07-22 15:18 GMT+02:00 Tod Cunningham via swift-users &lt;<br>swift-users at swift.org&gt;:<br></p><p>&gt; What’s the best practice around using @objc on private methods?  While<br>&gt; they can be used together, should their use be avoided or embraced?<br>&gt;<br>&gt; Thanks,<br>&gt; Tod<br>&gt;<br>&gt; From: Zhao Xin &lt;owenzx at gmail.com&gt;<br>&gt; Date: Thursday, July 21, 2016 at 10:42 PM<br>&gt; To: Josh Parmenter &lt;jparmenter at vectorform.com&gt;<br>&gt; Cc: Tod Cunningham &lt;tcunningham at vectorform.com&gt;, &quot;swift-users at swift.org&quot; &lt;<br>&gt; swift-users at swift.org&gt;<br>&gt; Subject: Re: [swift-users] @objc and private methods<br>&gt;<br>&gt; My previous reply was not correct.<br>&gt; I think @objc makes the function an Objective-C function, so the private<br>&gt; is no longer making the function private in Swift way, but in Objective-C<br>&gt; way. In C++,  sub-class can call super-class&#39;s private method. What you<br>&gt; have to do is to override the function.<br>&gt;<br>&gt; ​@objc makes the function available to Objective-C, but not only<br>&gt; Objective-C. So the function works in both Objective-C and Swift. In Swift,<br>&gt; the private is different from other languages, its scope is the surrounding<br>&gt; ​file. That is why the override doesn&#39;t work if both classes are separated<br>&gt; in different files.<br>&gt;<br>&gt; If the two classes are in the same file, below code also works.<br>&gt;<br>&gt;<br>&gt; class Test {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     private func somefunc() {<br>&gt;<br>&gt;<br>&gt;<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;<br>&gt;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; class Test2: Test {<br>&gt;<br>&gt;<br>&gt;<br>&gt;     override private func somefunc() {<br>&gt;<br>&gt;<br>&gt;<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;<br>&gt;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; So the only problem is with @objc and put the two classes into different<br>&gt; files, you can&#39;t override the function as it is over-scoped in Swift.<br>&gt; However, you can&#39;t use it in the same name either, as Objective-C will find<br>&gt; the function names are conflicts.<br>&gt;<br>&gt; So the resolution is either to use it as it is, or to file a bug to<br>&gt; eliminate using @objc and private together as there is no private access<br>&gt; level in Objective-C.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 2:22 AM, Josh Parmenter &lt;jparmenter at vectorform.com<br>&gt; &lt;mailto:jparmenter at vectorform.com&gt;&gt; wrote:<br>&gt; Is this a bug? I think this is more a question of what is best practice.<br>&gt; Best,<br>&gt; Josh<br>&gt;<br>&gt; On Jul 21, 2016, at 10:48 AM, Zhao Xin via swift-users &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt; Then you should file a bug.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 1:03 AM, Tod Cunningham &lt;<br>&gt; tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&lt;mailto:<br>&gt; tcunningham at vectorform.com&lt;mailto:tcunningham at vectorform.com&gt;&gt;&gt; wrote:<br>&gt; If Test and Test2 are in separate files, swift doesn’t allow you to do the<br>&gt; override as it “can’t see” the definition of the private method in Test.<br>&gt;<br>&gt;<br>&gt; From: Zhao Xin &lt;owenzx at gmail.com&lt;mailto:owenzx at gmail.com&gt;&lt;mailto:<br>&gt; owenzx at gmail.com&lt;mailto:owenzx at gmail.com&gt;&gt;&gt;<br>&gt; Date: Thursday, July 21, 2016 at 11:06 AM<br>&gt; To: Tod Cunningham &lt;tcunningham at vectorform.com&lt;mailto:<br>&gt; tcunningham at vectorform.com&gt;&lt;mailto:tcunningham at vectorform.com&lt;mailto:<br>&gt; tcunningham at vectorform.com&gt;&gt;&gt;<br>&gt; Cc: &quot;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&quot; &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt;<br>&gt; Subject: Re: [swift-users] @objc and private methods<br>&gt;<br>&gt; I think @objc makes the function an Objective-C function, so the private<br>&gt; is no longer making the function private in Swift way, but in Objective-C<br>&gt; way. In C++,  sub-class can call super-class&#39;s private method. What you<br>&gt; have to do is to override the function.<br>&gt;<br>&gt;<br>&gt; class Test {<br>&gt;<br>&gt;     @objc private func somefunc() {<br>&gt;<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; class Test2: Test {<br>&gt;<br>&gt;     @objc override private func somefunc() {<br>&gt;<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 10:25 PM, Tod Cunningham via swift-users &lt;<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt;&gt; wrote:<br>&gt; I wanted to get thoughts on the use of @objc and private methods.  Should<br>&gt; this usage be avoided or leveraged?<br>&gt;<br>&gt; I have seen some code where things like UIButton and Gesture recognizer<br>&gt; handlers are defined as being private.  I would have thought this would<br>&gt; result in a compiler error given objective-c doesn’t support private<br>&gt; accessors.  However, it compiles and works as expected (kind of).<br>&gt;<br>&gt; One plus for defining the handlers as private is they aren’t visible to<br>&gt; swift outside of the file they are defined in.  The problem is you can run<br>&gt; into some issues with inheritance if you define the same handler in a<br>&gt; derived class.  Take the following simple example:<br>&gt;<br>&gt; class Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 1&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;     @objc private func somefunc() {<br>&gt;         print( &quot;hello 2&quot; )<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This will result in the following compiler error:<br>&gt;<br>&gt; Method &#39;somefunc()&#39; with Objective-C selector &#39;somefunc&#39; conflicts with<br>&gt; method &#39;somefunc()&#39; from superclass &#39;Test&#39; with the same Objective-C<br>&gt; selector<br>&gt;<br>&gt; That error makes sense in an Objective-C context as Test2 has two<br>&gt; different methods defined with the same objective-c selector (somefunc).<br>&gt; Swift can tell them apart as they are private to each class, but Obj-C<br>&gt; can’t tell them apart as they have the same selector thus the error.<br>&gt;<br>&gt; One workaround would be to give the method a different Objective-C names<br>&gt; such as @objc(test2_somefunc); however, that could really lead to some<br>&gt; unexpected results depending on what selector is used to call somefunc.<br>&gt; Test2 would need to “register” a different selector for somefunc then Test<br>&gt; does for whatever is calling it on the Objective-C side (yuck!).<br>&gt;<br>&gt; This can of course be solved by not making the method private which allows<br>&gt; Test2 to explicitly override somefunc.<br>&gt;<br>&gt; class Test {<br>&gt;    @objc func somefunc() {<br>&gt;        print( &quot;hello 1&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; -- in another file –<br>&gt;<br>&gt; class Test2: Test {<br>&gt;    @objc override func somefunc() {<br>&gt;        print( &quot;hello 2&quot; )<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; I would say that when declaring @objc methods they shouldn’t be private<br>&gt; and should have the same (public/internal) access method as their<br>&gt; containing class.  What’s your thoughts?  Why does swift allow a method to<br>&gt; be declared as both @objc and private?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&lt;mailto:<br>&gt; swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160723/d5d46b7c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
