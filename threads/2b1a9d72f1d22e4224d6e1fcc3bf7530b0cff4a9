<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  7, 2016 at 11:00:00pm</p></header><div class="content"><p>On swift-dev, John already sent out a great writeup on SIL SSA:<br>Representing &quot;address-only&quot; values in SIL.<br></p><p>While talking to John I also picked up a lot of insight into how<br>address types relate to SIL ownership and borrow checking. I finally<br>organized the information into these notes. This is not a<br>proposal. It&#39;s background information for those of us writing and<br>reviewing proposals. Just take it as a strawman for future<br>discussions. (There&#39;s also a good chance I&#39;m getting something<br>wrong).<br></p><p>[My commentary in brackets.]<br></p><p>** Recap of address-only.<br></p><p>Divide address-only types into two categories:<br>1. By abstraction (compiler doesn&#39;t know the size).<br>2. The type is &quot;memory-linked&quot;. i.e. the address is significant at runtime.<br>   - weak references (anything that registers its address).<br>   - C++ this.<br>   - Anything with interior pointers.<br>   - Any shared-borrowed value of a type with &quot;nonmutating&quot; properties.<br>     [&quot;nonmutating&quot; properties allow mutation of state attached to a value.<br>      Rust atomics are an example.]<br></p><p>Address-only will not be reflected in SIL types. SIL addresses should<br>only be used for formal memory (pointers, globals, class<br>properties, captures). We&#39;ll get to inout arguments later...<br></p><p>As with opaque types, when IRGen lowers a memory-linked borrowed type,<br>it needs to allocate storage.<br></p><p>Concern: SILGen has built-in tracking of managed values that automates<br>insertion of cleanups. Lowering address-only types after SILOpt would<br>require rediscovering that information based on CFG analysis. Is this<br>too heroic?<br></p><p>This was already described by John. Briefly recapping:<br></p><p>e.g. Constructung Optional&lt;Any&gt;<br></p><p>We want initialization should be in-place as such:<br></p><p>%0 = struct_element_addr .. #S.any<br>%1 = init_existential_addr %0, $*Any, $Optional&lt;X&gt;<br>%2 = inject_enum_data_addr %1, $Optional&lt;X&gt;.Some<br>apply @initX(%2)<br></p><p>SILValue initialization would look something like:<br></p><p>%0 = apply @initX()<br>%1 = enum #Optional.Some, %0 : $X<br>%2 = existential %1 : $Any<br></p><p>[I&#39;m not sure we actually want to represent an existential container<br>this way, but enum, yes.]<br></p><p>Lowering now requires discovering the storage structure, bottom-up,<br>hoisting allocation, inserting cleanups as John explained.<br></p><p>Side note: Before lowering, something like alloc_box would directly<br>take its initial value.<br></p><p>** SILFunction calling convention.<br></p><p>For ownership analysis, there&#39;s effectively no difference between the<br>value/address forms of argument ownership:<br></p><p>@owned          / @in<br>@guaranteed     / @in_guaranteed<br>return          / @out<br>@owned arg<br>+ @owned return / @inout<br></p><p>Regardless of the representation we choose for @inout, @in/@out will<br>now be scalar types. SILFunction will maintain the distinction between<br>@owned/@in etc. based on whether the type is address-only. We need<br>this for reabstraction, but it only affects the function type, not the<br>calling convention.<br></p><p>Rather than building a tuple, John prefers SIL support for anonymous<br>aggregate as &quot;exploded values&quot;.<br></p><p>[I&#39;m guessing because tuples are a distinct formal type with their own<br>convention and common ownership. This may need some discussion though.]<br></p><p>Example SIL function type:<br></p><p>$(@in P, @owned Q) -&gt; (@owned R, @owned S, @out T, @out U)<br></p><p>%p = apply f: $() -&gt; P<br>%q = apply g: $() -&gt; Q<br>%exploded = apply h(%p, %q)<br>%r = project_exploded %exploded, #0 : $R<br>%s = project_exploded %exploded, #1 : $S<br>%t = project_exploded %exploded, #2 : $T<br>%u = project_exploded %exploded, #3 : $U<br></p><p>Exploded types requires all their elements to be projected with their<br>own independent ownership.<br></p><p>** Ownership terminology.<br></p><p>Swift &quot;owned&quot;    = Rust values           = SIL @owned      = implicitly consumed<br>Swift &quot;borrowed&quot; = Rust immutable borrow = SIL @guaranteed = shared<br>Swift &quot;inout&quot;    = Rust mutable borrow   = SIL @inout      = unique<br></p><p>Swift &quot;inout&quot; syntax is already (nearly) sufficient.<br></p><p>&quot;borrowed&quot; may not need syntax on the caller side, just a way to<br>qualify parameters. Swift still needs syntax for returning a borrowed<br>value.<br></p><p>** Representation of borrowed values.<br></p><p>Borrowed values represent some shared storage location.<br></p><p>We want some borrowed value references to be passed as SIL values, not SIL addresses:<br>- Borrowed class references should not be indirected.<br>- Optimize borrowing other small non-memory linked types.<br>- Support capture promotion, and other SSA optimizations.<br>- Borrow CoW values directly.<br></p><p>[Address-only borrowed types will still be passed as SIL addresses (why not?)]<br></p><p>Borrowed types with potentially mutating properties must be passed by<br>SIL address because they are not actually immutable and their storage<br>location is significant.<br></p><p>Borrowed references have a scope and need an end-of-borrow marker.<br></p><p>[The end-of-borrow marker semantically changes the memory state, and<br>statically enforces non-overlapping memory states. It does not<br>semantically write-back a value. Borrowed values with mutating fields<br>are semantically modified in-place.]<br></p><p>[Regardless of whether borrowed references are represented as SIL<br>values or addresses, they must be associated with formal storage. That<br>storage must remain immutable at the language level (although it may<br>have mutating fields) and the value cannot be destroyed during the<br>borrowed scope].<br></p><p>[Trivial borrowed values can be demoted to copies so we can eliminate<br>their scope]<br></p><p>[Anything borrowed from global storage (and not demoted to a copy)<br>needs its scope to be dynamically enforced. Borrows from local storage<br>are sufficiently statically enforced. However, in both cases the<br>optimizer must respect the static scope of the borrow.]<br></p><p>[I think borrowed values are effectively passed @guaranteed. The<br>end-of-borrow scope marker will then always be at the top-level<br>scope. You can&#39;t borrow in a caller and end its scope in the callee.]<br></p><p>** Borrowed and inout scopes.<br></p><p>inout value references are also scoped. We&#39;ll get to their<br>representation shortly. Within an inout scope, memory is in an<br>exclusive state. No borrowed scopes may overlap with an inout state,<br>which is to say, memory is either shared or exclusive.<br></p><p>We need a flag for stored properties, even for simple trivial<br>types. That&#39;s the only way to provide a simple user model. At least we<br>don&#39;t need this to be implemented atomically, we&#39;re not detecting race<br>conditions. Optimizations will come later. We should be able to prove<br>that some stored properties are never passed as inout.<br></p><p>The stored property flag needs to be a tri-state: owned, borrowed, exclusive.<br></p><p>The memory value can only be destroyed in the owned state.<br></p><p>The user may mark some storage locations as &quot;unchecked&quot; as an<br>opt-out. That doesn&#39;t change the optimizer&#39;s constraints. It simply<br>bypasses the runtime check.<br></p><p>** Ownership of loaded values.<br></p><p>[MikeG already explained possibilities of load ownership in<br>[swift-dev] [semantic-arc][proposal] High Level ARC Memory Operations]<br></p><p>For the sake of understanding the model, it&#39;s worth realizing that we<br>only need one form of load ownership: load_borrow. We don&#39;t<br>actually need an operation that loads an owned value out of formal<br>storage. This makes canonical sense because:<br></p><p>- Semantically, a load must at least be a borrow because the storage<br>  location&#39;s non-exclusive flag needs to be dynamically checked<br>  anyway, even if the value will be copied.<br></p><p>- Code motion in the SIL optimizer has to obey the same limitations<br>  within borrow scopes regardless of whether we fuse loads and copies<br>  (retains).<br></p><p>[For the purpose of semantic ARC, the copy_value would be the RC<br>root. The load and copy_value would effectively be &quot;coupled&quot; by the<br>static scope of the borrow. e.g. we would not want to move a release<br>inside the static scope of a borrow.]<br></p><p>[Purely in the interest of concise SIL, I still think we want a load [copy].]<br></p><p>** SIL value ownership and aggregates<br></p><p>Operations on values:<br>1. copy<br>2. forward (move)<br>3. borrow (share)<br></p><p>A copy or forward produces an owned value.<br>An owned value has a single consumer.<br>A borrow has static scope.<br></p><p>For simplicity, passing a bb argument only has move semantics (it<br>forwards the value). Later that can be expanded if needed.<br></p><p>We want to allow simultaneous access to independent subelements of a<br>fragile aggregate. We should be able to borrow one field while<br>mutating another.<br></p><p>Is it possible to forward a subelement within an aggregate? No. But we<br>can fully explode an owned aggregate into individual owned elements<br>and reconstruct the aggregate. This makes use of the @exploded type<br>feature described in the calling convention.<br></p><p>[I don&#39;t think forwarding a subelement is useful anyway except for<br>modeling @inout semantics...]<br></p><p>That leads us to this question: Does an @inout value reference have<br>formal storage (thus a SIL address) or is it just a convention for<br>passing owned SSA values?<br></p><p>** World 1: SSA @inout<br></p><p>Projecting an element produces a new SILValue. Does this SILValue have<br>it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>from it&#39;s parent object by looking through projections?<br></p><p>Either way, projecting any subelement requires reconstructing the<br>entire aggregate in SIL, through all nesting levels. This will<br>generate a massive amount of SILValues. Superficially they all need<br>their own storage.<br></p><p>[We could claim that projections don&#39;t need storage, but that only<br>solves one side of the problem.]<br></p><p>[I argue that this actually obscures the producer/consumer<br>relationship, which is the opposite of the intention of moving to<br>SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>sense. It does make sense to borrow a subelement (not for<br>mutation). It also makes sense to project a mutable storage<br>location. The natural way to project a storage location is by<br>projecting an address...]<br></p><p>** World 2: @inout formal storage<br></p><p>In this world, @inout references continue to have SILType $*T with<br>guaranteed exclusive access.<br></p><p>Memory state can be:<br>- uninitialized<br>- holds an owned value<br>  - has exclusive access<br>  - has shared access<br></p><p>--- expected transitions need to be handled<br>  - must become uninitialized<br>  - must become initialized<br>  - must preserve initialization state<br></p><p>We need to mark initializers with some &quot;must initialize&quot; marker,<br>similar to how we mark deinitializers [this isn&#39;t clear to me yet].<br></p><p>We could give address types qualifiers to distinguish the memory state<br>of their pointee (uninitialized, shared, exclusive). Addresses<br>themselves could be pseudo-linear types. This would provide the same<br>use-def guarantees as the SSA @inout approach, but producing a new<br>address each type memory changes states would also be complicated and<br>cumbersome (though not as bad as SSA).<br></p><p>[[<br>We didn&#39;t talk about the alternative, but presumably exclusive<br>vs. shared scope would be delimited by pseudo memory operations as<br>such:<br></p><p>%a1 = alloc_stack<br></p><p>begin_exclusive %a<br>apply foo(%a) // must be marked an initializer?<br>end_exclusive %a<br></p><p>begin_shared %a<br>apply bar(%a) // immutable access<br>end_shared %a<br></p><p>dealloc_stack %a<br></p><p>Values loaded from shared memory also need to be scoped. They must be<br>consumed within the shared region. e.g.<br></p><p>%a2 = ref_element_addr<br></p><p>%x = load_borrow %a2<br></p><p>end_borrow %x, %a2<br></p><p>It makes sense to me that a load_borrow would implicitly transition<br>memory to shared state, and end_borrow would implicitly return memory<br>to an owned state. If the address type is already ($* @borrow T), then<br>memory would remain in the shared state.<br>]]<br></p><p>For all sorts of analysis and optimization, from borrow checking to<br>CoW to ARC, we really need aliasing guarantees. Knowing we have a<br>unique address to a location is about as good as having an owned<br>value.<br></p><p>To get this guarantee we need to structurally guarantee<br>unique addresses.<br></p><p>[Is there a way to do this with out making all the element_addr<br>operations scoped?]<br></p><p>With aliasing guaratees, verification should be able to statically<br>prove that most formal storage locations are properly initialized and<br>uninitialized (pseudo-linear type) by inspecting the memory<br>operations.<br></p><p>Likewise, we can verify the shared vs. exclusive states.<br></p><p>Representing @inout with addresses doesn&#39;t really add features to<br>SIL. In any case, SIL address types are still used for<br>formal storage. Exclusive access through any of the following<br>operations must be guaranteed dynamically:<br></p><p>- ref_element_addr<br>- global_addr<br>- pointer_to_address<br>- alloc_stack<br>- project_box<br></p><p>We end up with these basic SIL Types:<br></p><p>$T = owned value<br></p><p>$@borrowed T = shared value<br></p><p>$*T = exclusively accessed<br></p><p>$* @borrowed T = shared access<br></p><p>[I think the non-address @borrowed type is only valid for concrete<br>types that the compiler knows are not memory-linked? This can be used<br>to avoid passing borrowed values indirectly for arrays and other<br>small, free-to-copy values].<br></p><p>[We obviously need to work through concrete examples before we can<br>claim to have a real design.]<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/2b1af4a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  8, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On swift-dev, John already sent out a great writeup on SIL SSA:<br>&gt; Representing &quot;address-only&quot; values in SIL.<br>&gt; <br>&gt; While talking to John I also picked up a lot of insight into how<br>&gt; address types relate to SIL ownership and borrow checking. I finally<br>&gt; organized the information into these notes. This is not a<br>&gt; proposal. It&#39;s background information for those of us writing and<br>&gt; reviewing proposals. Just take it as a strawman for future<br>&gt; discussions. (There&#39;s also a good chance I&#39;m getting something<br>&gt; wrong).<br></p><p>Thanks for the write-up; this is great.  Commentary / clarification / speculation below.<br></p><p>&gt; [My commentary in brackets.]<br>&gt; <br>&gt; ** Recap of address-only.<br>&gt; <br>&gt; Divide address-only types into two categories:<br>&gt; 1. By abstraction (compiler doesn&#39;t know the size).<br>&gt; 2. The type is &quot;memory-linked&quot;. i.e. the address is significant at runtime.<br>&gt;    - weak references (anything that registers its address).<br>&gt;    - C++ this.<br>&gt;    - Anything with interior pointers.<br>&gt;    - Any shared-borrowed value of a type with &quot;nonmutating&quot; properties.<br>&gt;      [&quot;nonmutating&quot; properties allow mutation of state attached to a value.<br>&gt;       Rust atomics are an example.]<br></p><p>Sortof.  &quot;nonmutating&quot; on a setter in Swift today just means that the property can be<br>mutated even on a formally-immutable aggregate, i.e. either a shared borrow or<br>an r-value.  Generally this implies that the aggregate has some sort of reference-like<br>semantics, like UnsafePointer does.  Rust and C++, however, have language features<br>which allow you to declare a directly-stored field to be mutable even when the<br>aggregate is not.  If we wanted to model a feature like that in Swift, we&#39;d end up with<br>a field with a nonmutating setter, but the more directly important thing is that the field<br>itself would be &quot;mutable&quot; (in the C++ sense), and we would have to pass around<br>borrows of the aggregate as pointers to the original value in order to preserve the<br>basic semantics of mutating the field.<br></p><p>&gt; Address-only will not be reflected in SIL types. SIL addresses should<br>&gt; only be used for formal memory (pointers, globals, class<br>&gt; properties, captures). We&#39;ll get to inout arguments later...<br>&gt; <br>&gt; As with opaque types, when IRGen lowers a memory-linked borrowed type,<br>&gt; it needs to allocate storage.<br>&gt; <br>&gt; Concern: SILGen has built-in tracking of managed values that automates<br>&gt; insertion of cleanups. Lowering address-only types after SILOpt would<br>&gt; require rediscovering that information based on CFG analysis. Is this<br>&gt; too heroic?<br>&gt; <br>&gt; This was already described by John. Briefly recapping:<br>&gt; <br>&gt; e.g. Constructung Optional&lt;Any&gt;<br>&gt; <br>&gt; We want initialization should be in-place as such:<br>&gt; <br>&gt; %0 = struct_element_addr .. #S.any<br>&gt; %1 = init_existential_addr %0, $*Any, $Optional&lt;X&gt;<br>&gt; %2 = inject_enum_data_addr %1, $Optional&lt;X&gt;.Some<br>&gt; apply @initX(%2)<br>&gt; <br>&gt; SILValue initialization would look something like:<br>&gt; <br>&gt; %0 = apply @initX()<br>&gt; %1 = enum #Optional.Some, %0 : $X<br>&gt; %2 = existential %1 : $Any<br>&gt; <br>&gt; [I&#39;m not sure we actually want to represent an existential container<br>&gt; this way, but enum, yes.]<br>&gt; <br>&gt; Lowering now requires discovering the storage structure, bottom-up,<br>&gt; hoisting allocation, inserting cleanups as John explained.<br></p><p>For the most part, you wouldn&#39;t have to insert cleanups.  There are specific<br>cases where cleanup insertion would be required in order to eliminate moves<br>and get optimal code.<br></p><p>For example, if we had this code:<br></p><p>  ...<br>  let ex: Any = try createMyBigStruct()<br>  ...<br></p><p>then the natural SIL pattern might be:<br></p><p>  ...<br>  %fn = function_ref @createMyBigStruct<br>  try_apply %fn() normal %norm, unwind %abort<br>norm(%result: $MyBigStruct):<br>  %ex = existential %result as $Any<br>  ...<br>abort(%error: $Error):<br>  throw %error<br></p><p>The optimal IR pattern here is to evaluate the result of createMyBigStruct<br>directly into the allocated buffer in the existential %ex (wherever that gets<br>allocated).  That means pre-allocating that buffer, but the SIL will only<br>contain code to destroy it after we reach %ex.  So we basically need to turn<br>it into:<br></p><p>  ...<br>  %ex = alloc_stack $Any<br>  %ex_buffer = init_existential %ex_memory, $MyBigStruct<br>  %fn = function_ref @createMyBigStruct<br>  try_apply %fn(%ex_buffer) normal %norm, unwind %abort<br>norm(%result: $MyBigStruct):<br>  ...<br>abort(%error: $Error):<br>  dealloc_existential %ex, %MyBigStruct<br>  throw %error<br></p><p>&gt; Side note: Before lowering, something like alloc_box would directly<br>&gt; take its initial value.<br></p><p>It at least *could*.  I&#39;ve since become convinced that we can reason about<br>local memory initialization well enough to make that unnecessary.<br></p><p>&gt; ** SILFunction calling convention.<br>&gt; <br>&gt; For ownership analysis, there&#39;s effectively no difference between the<br>&gt; value/address forms of argument ownership:<br>&gt; <br>&gt; @owned          / @in<br>&gt; @guaranteed     / @in_guaranteed<br>&gt; return          / @out<br>&gt; @owned arg<br>&gt; + @owned return / @inout<br>&gt; <br>&gt; Regardless of the representation we choose for @inout, @in/@out will<br>&gt; now be scalar types. SILFunction will maintain the distinction between<br>&gt; @owned/@in etc. based on whether the type is address-only. We need<br>&gt; this for reabstraction, but it only affects the function type, not the<br>&gt; calling convention.<br></p><p>To be clear, it affects the *low-level* calling convention.  It just doesn&#39;t require<br>a different pattern of SIL.<br></p><p>&gt; Rather than building a tuple, John prefers SIL support for anonymous<br>&gt; aggregate as &quot;exploded values&quot;.<br>&gt; <br>&gt; [I&#39;m guessing because tuples are a distinct formal type with their own<br>&gt; convention and common ownership. This may need some discussion though.]<br></p><p>Yes.  A tuple value could potentially actually be used in the code, so it would take<br>some work to prove that it wasn&#39;t necessary to actually build that tuple.  In contrast,<br>if the components of the tuple can only be used separately, then obviously they<br>can be kept as independent values.<br></p><p>The ownership thing is more deadly.  There&#39;s no reason a function *has* to return<br>all owned values or all borrowed values, but it&#39;s not obvious that we want the<br>type system to be able to express things like &quot;a tuple of an owned and a borrowed<br>value&quot; as opposed to being able to say that tuples are merely aggregate values<br>that are either owned or borrowed in their entirety.<br></p><p>&gt; Example SIL function type:<br>&gt; <br>&gt; $(@in P, @owned Q) -&gt; (@owned R, @owned S, @out T, @out U)<br>&gt; <br>&gt; %p = apply f: $() -&gt; P<br>&gt; %q = apply g: $() -&gt; Q<br>&gt; %exploded = apply h(%p, %q)<br>&gt; %r = project_exploded %exploded, #0 : $R<br>&gt; %s = project_exploded %exploded, #1 : $S<br>&gt; %t = project_exploded %exploded, #2 : $T<br>&gt; %u = project_exploded %exploded, #3 : $U<br>&gt; <br>&gt; Exploded types requires all their elements to be projected with their<br>&gt; own independent ownership.<br>&gt; <br>&gt; ** Ownership terminology.<br>&gt; <br>&gt; Swift &quot;owned&quot;    = Rust values           = SIL @owned      = implicitly consumed<br>&gt; Swift &quot;borrowed&quot; = Rust immutable borrow = SIL @guaranteed = shared<br>&gt; Swift &quot;inout&quot;    = Rust mutable borrow   = SIL @inout      = unique<br>&gt; <br>&gt; Swift &quot;inout&quot; syntax is already (nearly) sufficient.<br>&gt; <br>&gt; &quot;borrowed&quot; may not need syntax on the caller side, just a way to<br>&gt; qualify parameters. Swift still needs syntax for returning a borrowed<br>&gt; value.<br></p><p>Right.  But these are relatively shallow language-design decisions that we<br>don&#39;t need to worry about for SIL.<br></p><p>&gt; ** Representation of borrowed values.<br>&gt; <br>&gt; Borrowed values represent some shared storage location.<br>&gt; <br>&gt; We want some borrowed value references to be passed as SIL values, not SIL addresses:<br>&gt; - Borrowed class references should not be indirected.<br>&gt; - Optimize borrowing other small non-memory linked types.<br>&gt; - Support capture promotion, and other SSA optimizations.<br>&gt; - Borrow CoW values directly.<br>&gt; <br>&gt; [Address-only borrowed types will still be passed as SIL addresses (why not?)]<br></p><p>They have to be when memory-linked, for all the reasons above and below.<br></p><p>&gt; Borrowed types with potentially mutating properties must be passed by<br>&gt; SIL address because they are not actually immutable and their storage<br>&gt; location is significant.<br>&gt; <br>&gt; Borrowed references have a scope and need an end-of-borrow marker.<br>&gt; <br>&gt; [The end-of-borrow marker semantically changes the memory state, and<br>&gt; statically enforces non-overlapping memory states. It does not<br>&gt; semantically write-back a value. Borrowed values with mutating fields<br>&gt; are semantically modified in-place.]<br></p><p>Right.  One of the language-design challenges with mutable fields is that identity<br>becomes very important — it&#39;s important to understand when you&#39;re passing<br>a copy of a value vs. a borrow of it.  For types like Rust atomics this is fine<br>because they&#39;re not copyable, but that&#39;s not necessarily true for all types.<br>And yet I really don&#39;t think we want a sigil just to say that we&#39;re passing a<br>borrowed value instead of an owned one for normal use; it&#39;s like passing<br>by const &amp; in C++, the caller almost certainly doesn&#39;t care that you&#39;re doing it,<br>especially since we&#39;ll be guaranteeing that nobody modifies the value while<br>it&#39;s borrowed.<br></p><p>&gt; [Regardless of whether borrowed references are represented as SIL<br>&gt; values or addresses, they must be associated with formal storage. That<br>&gt; storage must remain immutable at the language level (although it may<br>&gt; have mutating fields) and the value cannot be destroyed during the<br>&gt; borrowed scope].<br>&gt; <br>&gt; [Trivial borrowed values can be demoted to copies so we can eliminate<br>&gt; their scope]<br></p><p>Right.<br></p><p>&gt; [Anything borrowed from global storage (and not demoted to a copy)<br>&gt; needs its scope to be dynamically enforced. Borrows from local storage<br>&gt; are sufficiently statically enforced. However, in both cases the<br>&gt; optimizer must respect the static scope of the borrow.]<br>&gt; <br>&gt; [I think borrowed values are effectively passed @guaranteed. The<br>&gt; end-of-borrow scope marker will then always be at the top-level<br>&gt; scope. You can&#39;t borrow in a caller and end its scope in the callee.]<br></p><p>Right.  The caller has to statically guarantee for the duration, so there&#39;s<br>no reason to split any responsibility here.<br></p><p>&gt; ** Borrowed and inout scopes.<br>&gt; <br>&gt; inout value references are also scoped. We&#39;ll get to their<br>&gt; representation shortly. Within an inout scope, memory is in an<br>&gt; exclusive state. No borrowed scopes may overlap with an inout state,<br>&gt; which is to say, memory is either shared or exclusive.<br>&gt; <br>&gt; We need a flag for stored properties, even for simple trivial<br>&gt; types. That&#39;s the only way to provide a simple user model. At least we<br>&gt; don&#39;t need this to be implemented atomically, we&#39;re not detecting race<br>&gt; conditions. Optimizations will come later. We should be able to prove<br>&gt; that some stored properties are never passed as inout.<br>&gt; <br>&gt; The stored property flag needs to be a tri-state: owned, borrowed, exclusive.<br>&gt; <br>&gt; The memory value can only be destroyed in the owned state.<br>&gt; <br>&gt; The user may mark some storage locations as &quot;unchecked&quot; as an<br>&gt; opt-out. That doesn&#39;t change the optimizer&#39;s constraints. It simply<br>&gt; bypasses the runtime check.<br>&gt; <br>&gt; ** Ownership of loaded values.<br>&gt; <br>&gt; [MikeG already explained possibilities of load ownership in<br>&gt; [swift-dev] [semantic-arc][proposal] High Level ARC Memory Operations]<br>&gt; <br>&gt; For the sake of understanding the model, it&#39;s worth realizing that we<br>&gt; only need one form of load ownership: load_borrow. We don&#39;t<br>&gt; actually need an operation that loads an owned value out of formal<br>&gt; storage. This makes canonical sense because:<br>&gt; <br>&gt; - Semantically, a load must at least be a borrow because the storage<br>&gt;   location&#39;s non-exclusive flag needs to be dynamically checked<br>&gt;   anyway, even if the value will be copied.<br>&gt; <br>&gt; - Code motion in the SIL optimizer has to obey the same limitations<br>&gt;   within borrow scopes regardless of whether we fuse loads and copies<br>&gt;   (retains).<br>&gt; <br>&gt; [For the purpose of semantic ARC, the copy_value would be the RC<br>&gt; root. The load and copy_value would effectively be &quot;coupled&quot; by the<br>&gt; static scope of the borrow. e.g. we would not want to move a release<br>&gt; inside the static scope of a borrow.]<br>&gt; <br>&gt; [Purely in the interest of concise SIL, I still think we want a load [copy].]<br></p><p>Yeah, I agree.  I expect it&#39;ll be the most common form of load by far;<br>making it take three instructions would be pretty unfortunate.  And it might<br>be easier for IRGen to optimize as a single instruction, e.g. for types where<br>we bundle the &quot;is this being accessed&quot; bit directly into the storage.<br></p><p>&gt; ** SIL value ownership and aggregates<br>&gt; <br>&gt; Operations on values:<br>&gt; 1. copy<br>&gt; 2. forward (move)<br>&gt; 3. borrow (share)<br>&gt; <br>&gt; A copy or forward produces an owned value.<br>&gt; An owned value has a single consumer.<br>&gt; A borrow has static scope.<br>&gt; <br>&gt; For simplicity, passing a bb argument only has move semantics (it<br>&gt; forwards the value). Later that can be expanded if needed.<br></p><p>Reasonable.<br></p><p>&gt; We want to allow simultaneous access to independent subelements of a<br>&gt; fragile aggregate. We should be able to borrow one field while<br>&gt; mutating another.<br>&gt; <br>&gt; Is it possible to forward a subelement within an aggregate? No. But we<br>&gt; can fully explode an owned aggregate into individual owned elements<br>&gt; and reconstruct the aggregate. This makes use of the @exploded type<br>&gt; feature described in the calling convention.<br>&gt; <br>&gt; [I don&#39;t think forwarding a subelement is useful anyway except for<br>&gt; modeling @inout semantics...]<br>&gt; <br>&gt; That leads us to this question: Does an @inout value reference have<br>&gt; formal storage (thus a SIL address) or is it just a convention for<br>&gt; passing owned SSA values?<br>&gt; <br>&gt; ** World 1: SSA @inout<br>&gt; <br>&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt; from it&#39;s parent object by looking through projections?<br>&gt; <br>&gt; Either way, projecting any subelement requires reconstructing the<br>&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt; their own storage.<br>&gt; <br>&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt; solves one side of the problem.]<br>&gt; <br>&gt; [I argue that this actually obscures the producer/consumer<br>&gt; relationship, which is the opposite of the intention of moving to<br>&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt; sense. It does make sense to borrow a subelement (not for<br>&gt; mutation). It also makes sense to project a mutable storage<br>&gt; location. The natural way to project a storage location is by<br>&gt; projecting an address...]<br>&gt; <br>&gt; ** World 2: @inout formal storage<br>&gt; <br>&gt; In this world, @inout references continue to have SILType $*T with<br>&gt; guaranteed exclusive access.<br>&gt; <br>&gt; Memory state can be:<br>&gt; - uninitialized<br>&gt; - holds an owned value<br>&gt;   - has exclusive access<br>&gt;   - has shared access<br>&gt; <br>&gt; --- expected transitions need to be handled<br>&gt;   - must become uninitialized<br>&gt;   - must become initialized<br>&gt;   - must preserve initialization state<br>&gt; <br>&gt; We need to mark initializers with some &quot;must initialize&quot; marker,<br>&gt; similar to how we mark deinitializers [this isn&#39;t clear to me yet].<br>&gt; <br>&gt; We could give address types qualifiers to distinguish the memory state<br>&gt; of their pointee (uninitialized, shared, exclusive). Addresses<br>&gt; themselves could be pseudo-linear types. This would provide the same<br>&gt; use-def guarantees as the SSA @inout approach, but producing a new<br>&gt; address each type memory changes states would also be complicated and<br>&gt; cumbersome (though not as bad as SSA).<br>&gt; <br>&gt; [[<br>&gt; We didn&#39;t talk about the alternative, but presumably exclusive<br>&gt; vs. shared scope would be delimited by pseudo memory operations as<br>&gt; such:<br>&gt; <br>&gt; %a1 = alloc_stack<br>&gt; <br>&gt; begin_exclusive %a<br>&gt; apply foo(%a) // must be marked an initializer?<br>&gt; end_exclusive %a<br>&gt; <br>&gt; begin_shared %a<br>&gt; apply bar(%a) // immutable access<br>&gt; end_shared %a<br>&gt; <br>&gt; dealloc_stack %a<br></p><p>I think alloc_stack returns an owned (but uninitialized) address and there&#39;s<br>general scoped operation to turn an owned address into a borrow.  Or it could<br>be implicit in the operation that needs a borrowed value, as you suggest below.<br></p><p>John.<br></p><p>&gt; Values loaded from shared memory also need to be scoped. They must be<br>&gt; consumed within the shared region. e.g.<br>&gt; <br>&gt; %a2 = ref_element_addr<br>&gt; <br>&gt; %x = load_borrow %a2<br>&gt; <br>&gt; end_borrow %x, %a2<br>&gt; <br>&gt; It makes sense to me that a load_borrow would implicitly transition<br>&gt; memory to shared state, and end_borrow would implicitly return memory<br>&gt; to an owned state. If the address type is already ($* @borrow T), then<br>&gt; memory would remain in the shared state.<br>&gt; ]]<br>&gt; <br>&gt; For all sorts of analysis and optimization, from borrow checking to<br>&gt; CoW to ARC, we really need aliasing guarantees. Knowing we have a<br>&gt; unique address to a location is about as good as having an owned<br>&gt; value.<br>&gt; <br>&gt; To get this guarantee we need to structurally guarantee<br>&gt; unique addresses.<br>&gt; <br>&gt; [Is there a way to do this with out making all the element_addr<br>&gt; operations scoped?]<br>&gt; <br>&gt; With aliasing guaratees, verification should be able to statically<br>&gt; prove that most formal storage locations are properly initialized and<br>&gt; uninitialized (pseudo-linear type) by inspecting the memory<br>&gt; operations.<br>&gt; <br>&gt; Likewise, we can verify the shared vs. exclusive states.<br>&gt; <br>&gt; Representing @inout with addresses doesn&#39;t really add features to<br>&gt; SIL. In any case, SIL address types are still used for<br>&gt; formal storage. Exclusive access through any of the following<br>&gt; operations must be guaranteed dynamically:<br>&gt; <br>&gt; - ref_element_addr<br>&gt; - global_addr<br>&gt; - pointer_to_address<br>&gt; - alloc_stack<br>&gt; - project_box<br>&gt; <br>&gt; We end up with these basic SIL Types:<br>&gt; <br>&gt; $T = owned value<br>&gt; <br>&gt; $@borrowed T = shared value<br>&gt; <br>&gt; $*T = exclusively accessed<br>&gt; <br>&gt; $* @borrowed T = shared access<br>&gt; <br>&gt; [I think the non-address @borrowed type is only valid for concrete<br>&gt; types that the compiler knows are not memory-linked? This can be used<br>&gt; to avoid passing borrowed values indirectly for arrays and other<br>&gt; small, free-to-copy values].<br>&gt; <br>&gt; [We obviously need to work through concrete examples before we can<br>&gt; claim to have a real design.]<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161008/76829ebe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 8, 2016, at 12:39 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; %a = alloc_stack<br>&gt;&gt; <br>&gt;&gt; begin_exclusive %a<br>&gt;&gt; apply foo(%a) // must be marked an initializer?<br>&gt;&gt; end_exclusive %a<br>&gt;&gt; <br>&gt;&gt; begin_shared %a<br>&gt;&gt; apply bar(%a) // immutable access<br>&gt;&gt; end_shared %a<br>&gt;&gt; <br>&gt;&gt; dealloc_stack %a<br>&gt; <br>&gt; I think alloc_stack returns an owned (but uninitialized) address and there&#39;s<br>&gt; general scoped operation to turn an owned address into a borrow.  Or it could<br>&gt; be implicit in the operation that needs a borrowed value, as you suggest below.<br></p><p>I should have decorated the code with transitions to get the point across:<br></p><p>%a = alloc_stack   // -&gt; owned/uninitialized<br></p><p>begin_exclusive %a // -&gt; exclusive/uninitialized<br>apply foo(%a)      // -&gt; exclusive/initialized<br>end_exclusive %a   // -&gt; owned/initialized<br></p><p>begin_shared %a    // -&gt; shared (implies initialized)<br>apply bar(%a)      // immutable access<br>end_shared %a      // -&gt; owned/initialized<br></p><p>dealloc_stack %a   // -&gt; invalid<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161008/4ccd6ba0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  8, 2016 at 07:00:00pm</p></header><div class="content"><p>Could you add this (and John’s previous writeup) to the docs in the repo?<br></p><p>I was reasonably along the way to adding unowned optionals a while back but got totally lost in SILGen.<br>This info looks really valuable, but personally I find that with the mailing list format it’s hard to ever find this kind of stuff when I need it.<br></p><p>Thanks<br></p><p>Karl<br></p><p>P.S. going to pick up that unowned optional stuff soon, once I have time to read the docs about SILGen<br></p><p>&gt; On 8 Oct 2016, at 08:10, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On swift-dev, John already sent out a great writeup on SIL SSA:<br>&gt; Representing &quot;address-only&quot; values in SIL.<br>&gt; <br>&gt; While talking to John I also picked up a lot of insight into how<br>&gt; address types relate to SIL ownership and borrow checking. I finally<br>&gt; organized the information into these notes. This is not a<br>&gt; proposal. It&#39;s background information for those of us writing and<br>&gt; reviewing proposals. Just take it as a strawman for future<br>&gt; discussions. (There&#39;s also a good chance I&#39;m getting something<br>&gt; wrong).<br>&gt; <br>&gt; [My commentary in brackets.]<br>&gt; <br>&gt; ** Recap of address-only.<br>&gt; <br>&gt; Divide address-only types into two categories:<br>&gt; 1. By abstraction (compiler doesn&#39;t know the size).<br>&gt; 2. The type is &quot;memory-linked&quot;. i.e. the address is significant at runtime.<br>&gt;    - weak references (anything that registers its address).<br>&gt;    - C++ this.<br>&gt;    - Anything with interior pointers.<br>&gt;    - Any shared-borrowed value of a type with &quot;nonmutating&quot; properties.<br>&gt;      [&quot;nonmutating&quot; properties allow mutation of state attached to a value.<br>&gt;       Rust atomics are an example.]<br>&gt; <br>&gt; Address-only will not be reflected in SIL types. SIL addresses should<br>&gt; only be used for formal memory (pointers, globals, class<br>&gt; properties, captures). We&#39;ll get to inout arguments later...<br>&gt; <br>&gt; As with opaque types, when IRGen lowers a memory-linked borrowed type,<br>&gt; it needs to allocate storage.<br>&gt; <br>&gt; Concern: SILGen has built-in tracking of managed values that automates<br>&gt; insertion of cleanups. Lowering address-only types after SILOpt would<br>&gt; require rediscovering that information based on CFG analysis. Is this<br>&gt; too heroic?<br>&gt; <br>&gt; This was already described by John. Briefly recapping:<br>&gt; <br>&gt; e.g. Constructung Optional&lt;Any&gt;<br>&gt; <br>&gt; We want initialization should be in-place as such:<br>&gt; <br>&gt; %0 = struct_element_addr .. #S.any<br>&gt; %1 = init_existential_addr %0, $*Any, $Optional&lt;X&gt;<br>&gt; %2 = inject_enum_data_addr %1, $Optional&lt;X&gt;.Some<br>&gt; apply @initX(%2)<br>&gt; <br>&gt; SILValue initialization would look something like:<br>&gt; <br>&gt; %0 = apply @initX()<br>&gt; %1 = enum #Optional.Some, %0 : $X<br>&gt; %2 = existential %1 : $Any<br>&gt; <br>&gt; [I&#39;m not sure we actually want to represent an existential container<br>&gt; this way, but enum, yes.]<br>&gt; <br>&gt; Lowering now requires discovering the storage structure, bottom-up,<br>&gt; hoisting allocation, inserting cleanups as John explained.<br>&gt; <br>&gt; Side note: Before lowering, something like alloc_box would directly<br>&gt; take its initial value.<br>&gt; <br>&gt; ** SILFunction calling convention.<br>&gt; <br>&gt; For ownership analysis, there&#39;s effectively no difference between the<br>&gt; value/address forms of argument ownership:<br>&gt; <br>&gt; @owned          / @in<br>&gt; @guaranteed     / @in_guaranteed<br>&gt; return          / @out<br>&gt; @owned arg<br>&gt; + @owned return / @inout<br>&gt; <br>&gt; Regardless of the representation we choose for @inout, @in/@out will<br>&gt; now be scalar types. SILFunction will maintain the distinction between<br>&gt; @owned/@in etc. based on whether the type is address-only. We need<br>&gt; this for reabstraction, but it only affects the function type, not the<br>&gt; calling convention.<br>&gt; <br>&gt; Rather than building a tuple, John prefers SIL support for anonymous<br>&gt; aggregate as &quot;exploded values&quot;.<br>&gt; <br>&gt; [I&#39;m guessing because tuples are a distinct formal type with their own<br>&gt; convention and common ownership. This may need some discussion though.]<br>&gt; <br>&gt; Example SIL function type:<br>&gt; <br>&gt; $(@in P, @owned Q) -&gt; (@owned R, @owned S, @out T, @out U)<br>&gt; <br>&gt; %p = apply f: $() -&gt; P<br>&gt; %q = apply g: $() -&gt; Q<br>&gt; %exploded = apply h(%p, %q)<br>&gt; %r = project_exploded %exploded, #0 : $R<br>&gt; %s = project_exploded %exploded, #1 : $S<br>&gt; %t = project_exploded %exploded, #2 : $T<br>&gt; %u = project_exploded %exploded, #3 : $U<br>&gt; <br>&gt; Exploded types requires all their elements to be projected with their<br>&gt; own independent ownership.<br>&gt; <br>&gt; ** Ownership terminology.<br>&gt; <br>&gt; Swift &quot;owned&quot;    = Rust values           = SIL @owned      = implicitly consumed<br>&gt; Swift &quot;borrowed&quot; = Rust immutable borrow = SIL @guaranteed = shared<br>&gt; Swift &quot;inout&quot;    = Rust mutable borrow   = SIL @inout      = unique<br>&gt; <br>&gt; Swift &quot;inout&quot; syntax is already (nearly) sufficient.<br>&gt; <br>&gt; &quot;borrowed&quot; may not need syntax on the caller side, just a way to<br>&gt; qualify parameters. Swift still needs syntax for returning a borrowed<br>&gt; value.<br>&gt; <br>&gt; ** Representation of borrowed values.<br>&gt; <br>&gt; Borrowed values represent some shared storage location.<br>&gt; <br>&gt; We want some borrowed value references to be passed as SIL values, not SIL addresses:<br>&gt; - Borrowed class references should not be indirected.<br>&gt; - Optimize borrowing other small non-memory linked types.<br>&gt; - Support capture promotion, and other SSA optimizations.<br>&gt; - Borrow CoW values directly.<br>&gt; <br>&gt; [Address-only borrowed types will still be passed as SIL addresses (why not?)]<br>&gt; <br>&gt; Borrowed types with potentially mutating properties must be passed by<br>&gt; SIL address because they are not actually immutable and their storage<br>&gt; location is significant.<br>&gt; <br>&gt; Borrowed references have a scope and need an end-of-borrow marker.<br>&gt; <br>&gt; [The end-of-borrow marker semantically changes the memory state, and<br>&gt; statically enforces non-overlapping memory states. It does not<br>&gt; semantically write-back a value. Borrowed values with mutating fields<br>&gt; are semantically modified in-place.]<br>&gt; <br>&gt; [Regardless of whether borrowed references are represented as SIL<br>&gt; values or addresses, they must be associated with formal storage. That<br>&gt; storage must remain immutable at the language level (although it may<br>&gt; have mutating fields) and the value cannot be destroyed during the<br>&gt; borrowed scope].<br>&gt; <br>&gt; [Trivial borrowed values can be demoted to copies so we can eliminate<br>&gt; their scope]<br>&gt; <br>&gt; [Anything borrowed from global storage (and not demoted to a copy)<br>&gt; needs its scope to be dynamically enforced. Borrows from local storage<br>&gt; are sufficiently statically enforced. However, in both cases the<br>&gt; optimizer must respect the static scope of the borrow.]<br>&gt; <br>&gt; [I think borrowed values are effectively passed @guaranteed. The<br>&gt; end-of-borrow scope marker will then always be at the top-level<br>&gt; scope. You can&#39;t borrow in a caller and end its scope in the callee.]<br>&gt; <br>&gt; ** Borrowed and inout scopes.<br>&gt; <br>&gt; inout value references are also scoped. We&#39;ll get to their<br>&gt; representation shortly. Within an inout scope, memory is in an<br>&gt; exclusive state. No borrowed scopes may overlap with an inout state,<br>&gt; which is to say, memory is either shared or exclusive.<br>&gt; <br>&gt; We need a flag for stored properties, even for simple trivial<br>&gt; types. That&#39;s the only way to provide a simple user model. At least we<br>&gt; don&#39;t need this to be implemented atomically, we&#39;re not detecting race<br>&gt; conditions. Optimizations will come later. We should be able to prove<br>&gt; that some stored properties are never passed as inout.<br>&gt; <br>&gt; The stored property flag needs to be a tri-state: owned, borrowed, exclusive.<br>&gt; <br>&gt; The memory value can only be destroyed in the owned state.<br>&gt; <br>&gt; The user may mark some storage locations as &quot;unchecked&quot; as an<br>&gt; opt-out. That doesn&#39;t change the optimizer&#39;s constraints. It simply<br>&gt; bypasses the runtime check.<br>&gt; <br>&gt; ** Ownership of loaded values.<br>&gt; <br>&gt; [MikeG already explained possibilities of load ownership in<br>&gt; [swift-dev] [semantic-arc][proposal] High Level ARC Memory Operations]<br>&gt; <br>&gt; For the sake of understanding the model, it&#39;s worth realizing that we<br>&gt; only need one form of load ownership: load_borrow. We don&#39;t<br>&gt; actually need an operation that loads an owned value out of formal<br>&gt; storage. This makes canonical sense because:<br>&gt; <br>&gt; - Semantically, a load must at least be a borrow because the storage<br>&gt;   location&#39;s non-exclusive flag needs to be dynamically checked<br>&gt;   anyway, even if the value will be copied.<br>&gt; <br>&gt; - Code motion in the SIL optimizer has to obey the same limitations<br>&gt;   within borrow scopes regardless of whether we fuse loads and copies<br>&gt;   (retains).<br>&gt; <br>&gt; [For the purpose of semantic ARC, the copy_value would be the RC<br>&gt; root. The load and copy_value would effectively be &quot;coupled&quot; by the<br>&gt; static scope of the borrow. e.g. we would not want to move a release<br>&gt; inside the static scope of a borrow.]<br>&gt; <br>&gt; [Purely in the interest of concise SIL, I still think we want a load [copy].]<br>&gt; <br>&gt; ** SIL value ownership and aggregates<br>&gt; <br>&gt; Operations on values:<br>&gt; 1. copy<br>&gt; 2. forward (move)<br>&gt; 3. borrow (share)<br>&gt; <br>&gt; A copy or forward produces an owned value.<br>&gt; An owned value has a single consumer.<br>&gt; A borrow has static scope.<br>&gt; <br>&gt; For simplicity, passing a bb argument only has move semantics (it<br>&gt; forwards the value). Later that can be expanded if needed.<br>&gt; <br>&gt; We want to allow simultaneous access to independent subelements of a<br>&gt; fragile aggregate. We should be able to borrow one field while<br>&gt; mutating another.<br>&gt; <br>&gt; Is it possible to forward a subelement within an aggregate? No. But we<br>&gt; can fully explode an owned aggregate into individual owned elements<br>&gt; and reconstruct the aggregate. This makes use of the @exploded type<br>&gt; feature described in the calling convention.<br>&gt; <br>&gt; [I don&#39;t think forwarding a subelement is useful anyway except for<br>&gt; modeling @inout semantics...]<br>&gt; <br>&gt; That leads us to this question: Does an @inout value reference have<br>&gt; formal storage (thus a SIL address) or is it just a convention for<br>&gt; passing owned SSA values?<br>&gt; <br>&gt; ** World 1: SSA @inout<br>&gt; <br>&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt; from it&#39;s parent object by looking through projections?<br>&gt; <br>&gt; Either way, projecting any subelement requires reconstructing the<br>&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt; their own storage.<br>&gt; <br>&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt; solves one side of the problem.]<br>&gt; <br>&gt; [I argue that this actually obscures the producer/consumer<br>&gt; relationship, which is the opposite of the intention of moving to<br>&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt; sense. It does make sense to borrow a subelement (not for<br>&gt; mutation). It also makes sense to project a mutable storage<br>&gt; location. The natural way to project a storage location is by<br>&gt; projecting an address...]<br>&gt; <br>&gt; ** World 2: @inout formal storage<br>&gt; <br>&gt; In this world, @inout references continue to have SILType $*T with<br>&gt; guaranteed exclusive access.<br>&gt; <br>&gt; Memory state can be:<br>&gt; - uninitialized<br>&gt; - holds an owned value<br>&gt;   - has exclusive access<br>&gt;   - has shared access<br>&gt; <br>&gt; --- expected transitions need to be handled<br>&gt;   - must become uninitialized<br>&gt;   - must become initialized<br>&gt;   - must preserve initialization state<br>&gt; <br>&gt; We need to mark initializers with some &quot;must initialize&quot; marker,<br>&gt; similar to how we mark deinitializers [this isn&#39;t clear to me yet].<br>&gt; <br>&gt; We could give address types qualifiers to distinguish the memory state<br>&gt; of their pointee (uninitialized, shared, exclusive). Addresses<br>&gt; themselves could be pseudo-linear types. This would provide the same<br>&gt; use-def guarantees as the SSA @inout approach, but producing a new<br>&gt; address each type memory changes states would also be complicated and<br>&gt; cumbersome (though not as bad as SSA).<br>&gt; <br>&gt; [[<br>&gt; We didn&#39;t talk about the alternative, but presumably exclusive<br>&gt; vs. shared scope would be delimited by pseudo memory operations as<br>&gt; such:<br>&gt; <br>&gt; %a1 = alloc_stack<br>&gt; <br>&gt; begin_exclusive %a<br>&gt; apply foo(%a) // must be marked an initializer?<br>&gt; end_exclusive %a<br>&gt; <br>&gt; begin_shared %a<br>&gt; apply bar(%a) // immutable access<br>&gt; end_shared %a<br>&gt; <br>&gt; dealloc_stack %a<br>&gt; <br>&gt; Values loaded from shared memory also need to be scoped. They must be<br>&gt; consumed within the shared region. e.g.<br>&gt; <br>&gt; %a2 = ref_element_addr<br>&gt; <br>&gt; %x = load_borrow %a2<br>&gt; <br>&gt; end_borrow %x, %a2<br>&gt; <br>&gt; It makes sense to me that a load_borrow would implicitly transition<br>&gt; memory to shared state, and end_borrow would implicitly return memory<br>&gt; to an owned state. If the address type is already ($* @borrow T), then<br>&gt; memory would remain in the shared state.<br>&gt; ]]<br>&gt; <br>&gt; For all sorts of analysis and optimization, from borrow checking to<br>&gt; CoW to ARC, we really need aliasing guarantees. Knowing we have a<br>&gt; unique address to a location is about as good as having an owned<br>&gt; value.<br>&gt; <br>&gt; To get this guarantee we need to structurally guarantee<br>&gt; unique addresses.<br>&gt; <br>&gt; [Is there a way to do this with out making all the element_addr<br>&gt; operations scoped?]<br>&gt; <br>&gt; With aliasing guaratees, verification should be able to statically<br>&gt; prove that most formal storage locations are properly initialized and<br>&gt; uninitialized (pseudo-linear type) by inspecting the memory<br>&gt; operations.<br>&gt; <br>&gt; Likewise, we can verify the shared vs. exclusive states.<br>&gt; <br>&gt; Representing @inout with addresses doesn&#39;t really add features to<br>&gt; SIL. In any case, SIL address types are still used for<br>&gt; formal storage. Exclusive access through any of the following<br>&gt; operations must be guaranteed dynamically:<br>&gt; <br>&gt; - ref_element_addr<br>&gt; - global_addr<br>&gt; - pointer_to_address<br>&gt; - alloc_stack<br>&gt; - project_box<br>&gt; <br>&gt; We end up with these basic SIL Types:<br>&gt; <br>&gt; $T = owned value<br>&gt; <br>&gt; $@borrowed T = shared value<br>&gt; <br>&gt; $*T = exclusively accessed<br>&gt; <br>&gt; $* @borrowed T = shared access<br>&gt; <br>&gt; [I think the non-address @borrowed type is only valid for concrete<br>&gt; types that the compiler knows are not memory-linked? This can be used<br>&gt; to avoid passing borrowed values indirectly for arrays and other<br>&gt; small, free-to-copy values].<br>&gt; <br>&gt; [We obviously need to work through concrete examples before we can<br>&gt; claim to have a real design.]<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161008/f6cfed3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 8, 2016, at 10:09 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; Could you add this (and John’s previous writeup) to the docs in the repo?<br></p><p>Yeah, it’s unfortunate that design discussions are buried in a flood of email. On the flip side, I’ve checked in some premature design docs that are probably nonsense now. I’m currently preparing a type safe memory model design doc to checkin. After that I’ll probably work on a document for SIL SSA with address-only types, which should cover John’s writeup. I’ll have to work with Michael Gottesman and John McCall to get a SIL ownership docs checked in.<br></p><p>&gt; I was reasonably along the way to adding unowned optionals a while back but got totally lost in SILGen.<br>&gt; This info looks really valuable, but personally I find that with the mailing list format it’s hard to ever find this kind of stuff when I need it.<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; P.S. going to pick up that unowned optional stuff soon, once I have time to read the docs about SILGen<br></p><p>There are SILGen docs somewhere?<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; On 8 Oct 2016, at 08:10, Andrew Trick via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On swift-dev, John already sent out a great writeup on SIL SSA:<br>&gt;&gt; Representing &quot;address-only&quot; values in SIL.<br>&gt;&gt; <br>&gt;&gt; While talking to John I also picked up a lot of insight into how<br>&gt;&gt; address types relate to SIL ownership and borrow checking. I finally<br>&gt;&gt; organized the information into these notes. This is not a<br>&gt;&gt; proposal. It&#39;s background information for those of us writing and<br>&gt;&gt; reviewing proposals. Just take it as a strawman for future<br>&gt;&gt; discussions. (There&#39;s also a good chance I&#39;m getting something<br>&gt;&gt; wrong).<br>&gt;&gt; <br>&gt;&gt; [My commentary in brackets.]<br>&gt;&gt; <br>&gt;&gt; ** Recap of address-only.<br>&gt;&gt; <br>&gt;&gt; Divide address-only types into two categories:<br>&gt;&gt; 1. By abstraction (compiler doesn&#39;t know the size).<br>&gt;&gt; 2. The type is &quot;memory-linked&quot;. i.e. the address is significant at runtime.<br>&gt;&gt;    - weak references (anything that registers its address).<br>&gt;&gt;    - C++ this.<br>&gt;&gt;    - Anything with interior pointers.<br>&gt;&gt;    - Any shared-borrowed value of a type with &quot;nonmutating&quot; properties.<br>&gt;&gt;      [&quot;nonmutating&quot; properties allow mutation of state attached to a value.<br>&gt;&gt;       Rust atomics are an example.]<br>&gt;&gt; <br>&gt;&gt; Address-only will not be reflected in SIL types. SIL addresses should<br>&gt;&gt; only be used for formal memory (pointers, globals, class<br>&gt;&gt; properties, captures). We&#39;ll get to inout arguments later...<br>&gt;&gt; <br>&gt;&gt; As with opaque types, when IRGen lowers a memory-linked borrowed type,<br>&gt;&gt; it needs to allocate storage.<br>&gt;&gt; <br>&gt;&gt; Concern: SILGen has built-in tracking of managed values that automates<br>&gt;&gt; insertion of cleanups. Lowering address-only types after SILOpt would<br>&gt;&gt; require rediscovering that information based on CFG analysis. Is this<br>&gt;&gt; too heroic?<br>&gt;&gt; <br>&gt;&gt; This was already described by John. Briefly recapping:<br>&gt;&gt; <br>&gt;&gt; e.g. Constructung Optional&lt;Any&gt;<br>&gt;&gt; <br>&gt;&gt; We want initialization should be in-place as such:<br>&gt;&gt; <br>&gt;&gt; %0 = struct_element_addr .. #S.any<br>&gt;&gt; %1 = init_existential_addr %0, $*Any, $Optional&lt;X&gt;<br>&gt;&gt; %2 = inject_enum_data_addr %1, $Optional&lt;X&gt;.Some<br>&gt;&gt; apply @initX(%2)<br>&gt;&gt; <br>&gt;&gt; SILValue initialization would look something like:<br>&gt;&gt; <br>&gt;&gt; %0 = apply @initX()<br>&gt;&gt; %1 = enum #Optional.Some, %0 : $X<br>&gt;&gt; %2 = existential %1 : $Any<br>&gt;&gt; <br>&gt;&gt; [I&#39;m not sure we actually want to represent an existential container<br>&gt;&gt; this way, but enum, yes.]<br>&gt;&gt; <br>&gt;&gt; Lowering now requires discovering the storage structure, bottom-up,<br>&gt;&gt; hoisting allocation, inserting cleanups as John explained.<br>&gt;&gt; <br>&gt;&gt; Side note: Before lowering, something like alloc_box would directly<br>&gt;&gt; take its initial value.<br>&gt;&gt; <br>&gt;&gt; ** SILFunction calling convention.<br>&gt;&gt; <br>&gt;&gt; For ownership analysis, there&#39;s effectively no difference between the<br>&gt;&gt; value/address forms of argument ownership:<br>&gt;&gt; <br>&gt;&gt; @owned          / @in<br>&gt;&gt; @guaranteed     / @in_guaranteed<br>&gt;&gt; return          / @out<br>&gt;&gt; @owned arg<br>&gt;&gt; + @owned return / @inout<br>&gt;&gt; <br>&gt;&gt; Regardless of the representation we choose for @inout, @in/@out will<br>&gt;&gt; now be scalar types. SILFunction will maintain the distinction between<br>&gt;&gt; @owned/@in etc. based on whether the type is address-only. We need<br>&gt;&gt; this for reabstraction, but it only affects the function type, not the<br>&gt;&gt; calling convention.<br>&gt;&gt; <br>&gt;&gt; Rather than building a tuple, John prefers SIL support for anonymous<br>&gt;&gt; aggregate as &quot;exploded values&quot;.<br>&gt;&gt; <br>&gt;&gt; [I&#39;m guessing because tuples are a distinct formal type with their own<br>&gt;&gt; convention and common ownership. This may need some discussion though.]<br>&gt;&gt; <br>&gt;&gt; Example SIL function type:<br>&gt;&gt; <br>&gt;&gt; $(@in P, @owned Q) -&gt; (@owned R, @owned S, @out T, @out U)<br>&gt;&gt; <br>&gt;&gt; %p = apply f: $() -&gt; P<br>&gt;&gt; %q = apply g: $() -&gt; Q<br>&gt;&gt; %exploded = apply h(%p, %q)<br>&gt;&gt; %r = project_exploded %exploded, #0 : $R<br>&gt;&gt; %s = project_exploded %exploded, #1 : $S<br>&gt;&gt; %t = project_exploded %exploded, #2 : $T<br>&gt;&gt; %u = project_exploded %exploded, #3 : $U<br>&gt;&gt; <br>&gt;&gt; Exploded types requires all their elements to be projected with their<br>&gt;&gt; own independent ownership.<br>&gt;&gt; <br>&gt;&gt; ** Ownership terminology.<br>&gt;&gt; <br>&gt;&gt; Swift &quot;owned&quot;    = Rust values           = SIL @owned      = implicitly consumed<br>&gt;&gt; Swift &quot;borrowed&quot; = Rust immutable borrow = SIL @guaranteed = shared<br>&gt;&gt; Swift &quot;inout&quot;    = Rust mutable borrow   = SIL @inout      = unique<br>&gt;&gt; <br>&gt;&gt; Swift &quot;inout&quot; syntax is already (nearly) sufficient.<br>&gt;&gt; <br>&gt;&gt; &quot;borrowed&quot; may not need syntax on the caller side, just a way to<br>&gt;&gt; qualify parameters. Swift still needs syntax for returning a borrowed<br>&gt;&gt; value.<br>&gt;&gt; <br>&gt;&gt; ** Representation of borrowed values.<br>&gt;&gt; <br>&gt;&gt; Borrowed values represent some shared storage location.<br>&gt;&gt; <br>&gt;&gt; We want some borrowed value references to be passed as SIL values, not SIL addresses:<br>&gt;&gt; - Borrowed class references should not be indirected.<br>&gt;&gt; - Optimize borrowing other small non-memory linked types.<br>&gt;&gt; - Support capture promotion, and other SSA optimizations.<br>&gt;&gt; - Borrow CoW values directly.<br>&gt;&gt; <br>&gt;&gt; [Address-only borrowed types will still be passed as SIL addresses (why not?)]<br>&gt;&gt; <br>&gt;&gt; Borrowed types with potentially mutating properties must be passed by<br>&gt;&gt; SIL address because they are not actually immutable and their storage<br>&gt;&gt; location is significant.<br>&gt;&gt; <br>&gt;&gt; Borrowed references have a scope and need an end-of-borrow marker.<br>&gt;&gt; <br>&gt;&gt; [The end-of-borrow marker semantically changes the memory state, and<br>&gt;&gt; statically enforces non-overlapping memory states. It does not<br>&gt;&gt; semantically write-back a value. Borrowed values with mutating fields<br>&gt;&gt; are semantically modified in-place.]<br>&gt;&gt; <br>&gt;&gt; [Regardless of whether borrowed references are represented as SIL<br>&gt;&gt; values or addresses, they must be associated with formal storage. That<br>&gt;&gt; storage must remain immutable at the language level (although it may<br>&gt;&gt; have mutating fields) and the value cannot be destroyed during the<br>&gt;&gt; borrowed scope].<br>&gt;&gt; <br>&gt;&gt; [Trivial borrowed values can be demoted to copies so we can eliminate<br>&gt;&gt; their scope]<br>&gt;&gt; <br>&gt;&gt; [Anything borrowed from global storage (and not demoted to a copy)<br>&gt;&gt; needs its scope to be dynamically enforced. Borrows from local storage<br>&gt;&gt; are sufficiently statically enforced. However, in both cases the<br>&gt;&gt; optimizer must respect the static scope of the borrow.]<br>&gt;&gt; <br>&gt;&gt; [I think borrowed values are effectively passed @guaranteed. The<br>&gt;&gt; end-of-borrow scope marker will then always be at the top-level<br>&gt;&gt; scope. You can&#39;t borrow in a caller and end its scope in the callee.]<br>&gt;&gt; <br>&gt;&gt; ** Borrowed and inout scopes.<br>&gt;&gt; <br>&gt;&gt; inout value references are also scoped. We&#39;ll get to their<br>&gt;&gt; representation shortly. Within an inout scope, memory is in an<br>&gt;&gt; exclusive state. No borrowed scopes may overlap with an inout state,<br>&gt;&gt; which is to say, memory is either shared or exclusive.<br>&gt;&gt; <br>&gt;&gt; We need a flag for stored properties, even for simple trivial<br>&gt;&gt; types. That&#39;s the only way to provide a simple user model. At least we<br>&gt;&gt; don&#39;t need this to be implemented atomically, we&#39;re not detecting race<br>&gt;&gt; conditions. Optimizations will come later. We should be able to prove<br>&gt;&gt; that some stored properties are never passed as inout.<br>&gt;&gt; <br>&gt;&gt; The stored property flag needs to be a tri-state: owned, borrowed, exclusive.<br>&gt;&gt; <br>&gt;&gt; The memory value can only be destroyed in the owned state.<br>&gt;&gt; <br>&gt;&gt; The user may mark some storage locations as &quot;unchecked&quot; as an<br>&gt;&gt; opt-out. That doesn&#39;t change the optimizer&#39;s constraints. It simply<br>&gt;&gt; bypasses the runtime check.<br>&gt;&gt; <br>&gt;&gt; ** Ownership of loaded values.<br>&gt;&gt; <br>&gt;&gt; [MikeG already explained possibilities of load ownership in<br>&gt;&gt; [swift-dev] [semantic-arc][proposal] High Level ARC Memory Operations]<br>&gt;&gt; <br>&gt;&gt; For the sake of understanding the model, it&#39;s worth realizing that we<br>&gt;&gt; only need one form of load ownership: load_borrow. We don&#39;t<br>&gt;&gt; actually need an operation that loads an owned value out of formal<br>&gt;&gt; storage. This makes canonical sense because:<br>&gt;&gt; <br>&gt;&gt; - Semantically, a load must at least be a borrow because the storage<br>&gt;&gt;   location&#39;s non-exclusive flag needs to be dynamically checked<br>&gt;&gt;   anyway, even if the value will be copied.<br>&gt;&gt; <br>&gt;&gt; - Code motion in the SIL optimizer has to obey the same limitations<br>&gt;&gt;   within borrow scopes regardless of whether we fuse loads and copies<br>&gt;&gt;   (retains).<br>&gt;&gt; <br>&gt;&gt; [For the purpose of semantic ARC, the copy_value would be the RC<br>&gt;&gt; root. The load and copy_value would effectively be &quot;coupled&quot; by the<br>&gt;&gt; static scope of the borrow. e.g. we would not want to move a release<br>&gt;&gt; inside the static scope of a borrow.]<br>&gt;&gt; <br>&gt;&gt; [Purely in the interest of concise SIL, I still think we want a load [copy].]<br>&gt;&gt; <br>&gt;&gt; ** SIL value ownership and aggregates<br>&gt;&gt; <br>&gt;&gt; Operations on values:<br>&gt;&gt; 1. copy<br>&gt;&gt; 2. forward (move)<br>&gt;&gt; 3. borrow (share)<br>&gt;&gt; <br>&gt;&gt; A copy or forward produces an owned value.<br>&gt;&gt; An owned value has a single consumer.<br>&gt;&gt; A borrow has static scope.<br>&gt;&gt; <br>&gt;&gt; For simplicity, passing a bb argument only has move semantics (it<br>&gt;&gt; forwards the value). Later that can be expanded if needed.<br>&gt;&gt; <br>&gt;&gt; We want to allow simultaneous access to independent subelements of a<br>&gt;&gt; fragile aggregate. We should be able to borrow one field while<br>&gt;&gt; mutating another.<br>&gt;&gt; <br>&gt;&gt; Is it possible to forward a subelement within an aggregate? No. But we<br>&gt;&gt; can fully explode an owned aggregate into individual owned elements<br>&gt;&gt; and reconstruct the aggregate. This makes use of the @exploded type<br>&gt;&gt; feature described in the calling convention.<br>&gt;&gt; <br>&gt;&gt; [I don&#39;t think forwarding a subelement is useful anyway except for<br>&gt;&gt; modeling @inout semantics...]<br>&gt;&gt; <br>&gt;&gt; That leads us to this question: Does an @inout value reference have<br>&gt;&gt; formal storage (thus a SIL address) or is it just a convention for<br>&gt;&gt; passing owned SSA values?<br>&gt;&gt; <br>&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt; <br>&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt; <br>&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt; their own storage.<br>&gt;&gt; <br>&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt; solves one side of the problem.]<br>&gt;&gt; <br>&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt; projecting an address...]<br>&gt;&gt; <br>&gt;&gt; ** World 2: @inout formal storage<br>&gt;&gt; <br>&gt;&gt; In this world, @inout references continue to have SILType $*T with<br>&gt;&gt; guaranteed exclusive access.<br>&gt;&gt; <br>&gt;&gt; Memory state can be:<br>&gt;&gt; - uninitialized<br>&gt;&gt; - holds an owned value<br>&gt;&gt;   - has exclusive access<br>&gt;&gt;   - has shared access<br>&gt;&gt; <br>&gt;&gt; --- expected transitions need to be handled<br>&gt;&gt;   - must become uninitialized<br>&gt;&gt;   - must become initialized<br>&gt;&gt;   - must preserve initialization state<br>&gt;&gt; <br>&gt;&gt; We need to mark initializers with some &quot;must initialize&quot; marker,<br>&gt;&gt; similar to how we mark deinitializers [this isn&#39;t clear to me yet].<br>&gt;&gt; <br>&gt;&gt; We could give address types qualifiers to distinguish the memory state<br>&gt;&gt; of their pointee (uninitialized, shared, exclusive). Addresses<br>&gt;&gt; themselves could be pseudo-linear types. This would provide the same<br>&gt;&gt; use-def guarantees as the SSA @inout approach, but producing a new<br>&gt;&gt; address each type memory changes states would also be complicated and<br>&gt;&gt; cumbersome (though not as bad as SSA).<br>&gt;&gt; <br>&gt;&gt; [[<br>&gt;&gt; We didn&#39;t talk about the alternative, but presumably exclusive<br>&gt;&gt; vs. shared scope would be delimited by pseudo memory operations as<br>&gt;&gt; such:<br>&gt;&gt; <br>&gt;&gt; %a1 = alloc_stack<br>&gt;&gt; <br>&gt;&gt; begin_exclusive %a<br>&gt;&gt; apply foo(%a) // must be marked an initializer?<br>&gt;&gt; end_exclusive %a<br>&gt;&gt; <br>&gt;&gt; begin_shared %a<br>&gt;&gt; apply bar(%a) // immutable access<br>&gt;&gt; end_shared %a<br>&gt;&gt; <br>&gt;&gt; dealloc_stack %a<br>&gt;&gt; <br>&gt;&gt; Values loaded from shared memory also need to be scoped. They must be<br>&gt;&gt; consumed within the shared region. e.g.<br>&gt;&gt; <br>&gt;&gt; %a2 = ref_element_addr<br>&gt;&gt; <br>&gt;&gt; %x = load_borrow %a2<br>&gt;&gt; <br>&gt;&gt; end_borrow %x, %a2<br>&gt;&gt; <br>&gt;&gt; It makes sense to me that a load_borrow would implicitly transition<br>&gt;&gt; memory to shared state, and end_borrow would implicitly return memory<br>&gt;&gt; to an owned state. If the address type is already ($* @borrow T), then<br>&gt;&gt; memory would remain in the shared state.<br>&gt;&gt; ]]<br>&gt;&gt; <br>&gt;&gt; For all sorts of analysis and optimization, from borrow checking to<br>&gt;&gt; CoW to ARC, we really need aliasing guarantees. Knowing we have a<br>&gt;&gt; unique address to a location is about as good as having an owned<br>&gt;&gt; value.<br>&gt;&gt; <br>&gt;&gt; To get this guarantee we need to structurally guarantee<br>&gt;&gt; unique addresses.<br>&gt;&gt; <br>&gt;&gt; [Is there a way to do this with out making all the element_addr<br>&gt;&gt; operations scoped?]<br>&gt;&gt; <br>&gt;&gt; With aliasing guaratees, verification should be able to statically<br>&gt;&gt; prove that most formal storage locations are properly initialized and<br>&gt;&gt; uninitialized (pseudo-linear type) by inspecting the memory<br>&gt;&gt; operations.<br>&gt;&gt; <br>&gt;&gt; Likewise, we can verify the shared vs. exclusive states.<br>&gt;&gt; <br>&gt;&gt; Representing @inout with addresses doesn&#39;t really add features to<br>&gt;&gt; SIL. In any case, SIL address types are still used for<br>&gt;&gt; formal storage. Exclusive access through any of the following<br>&gt;&gt; operations must be guaranteed dynamically:<br>&gt;&gt; <br>&gt;&gt; - ref_element_addr<br>&gt;&gt; - global_addr<br>&gt;&gt; - pointer_to_address<br>&gt;&gt; - alloc_stack<br>&gt;&gt; - project_box<br>&gt;&gt; <br>&gt;&gt; We end up with these basic SIL Types:<br>&gt;&gt; <br>&gt;&gt; $T = owned value<br>&gt;&gt; <br>&gt;&gt; $@borrowed T = shared value<br>&gt;&gt; <br>&gt;&gt; $*T = exclusively accessed<br>&gt;&gt; <br>&gt;&gt; $* @borrowed T = shared access<br>&gt;&gt; <br>&gt;&gt; [I think the non-address @borrowed type is only valid for concrete<br>&gt;&gt; types that the compiler knows are not memory-linked? This can be used<br>&gt;&gt; to avoid passing borrowed values indirectly for arrays and other<br>&gt;&gt; small, free-to-copy values].<br>&gt;&gt; <br>&gt;&gt; [We obviously need to work through concrete examples before we can<br>&gt;&gt; claim to have a real design.]<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161008/2d178ddd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 8, 2016, at 10:09 AM, Karl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Could you add this (and John’s previous writeup) to the docs in the repo?<br>&gt; <br>&gt; I was reasonably along the way to adding unowned optionals a while back but got totally lost in SILGen.<br>&gt; This info looks really valuable, but personally I find that with the mailing list format it’s hard to ever find this kind of stuff when I need it.<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; P.S. going to pick up that unowned optional stuff soon, once I have time to read the docs about SILGen<br></p><p>I am not sure if it is appropriate to document this sort of thing in the docs directory. This is because, as Andy explicitly mentioned, this document is not an actual proposal or a plan of record. Rather, this is meant to be a record of an in person side discussion that occurred in between two individuals. In the past, when we have had these in person side conversations, notes were not provided to the wider group of developers resulting in siloed knowledge and obscured visibility into the design process.<br></p><p>Eliminating such problems is the intention behind sending out these notes, not providing finalized proposals for placement in the docs directory.<br></p><p>Michael<br></p><p>&gt; <br>&gt;&gt; On 8 Oct 2016, at 08:10, Andrew Trick via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On swift-dev, John already sent out a great writeup on SIL SSA:<br>&gt;&gt; Representing &quot;address-only&quot; values in SIL.<br>&gt;&gt; <br>&gt;&gt; While talking to John I also picked up a lot of insight into how<br>&gt;&gt; address types relate to SIL ownership and borrow checking. I finally<br>&gt;&gt; organized the information into these notes. This is not a<br>&gt;&gt; proposal. It&#39;s background information for those of us writing and<br>&gt;&gt; reviewing proposals. Just take it as a strawman for future<br>&gt;&gt; discussions. (There&#39;s also a good chance I&#39;m getting something<br>&gt;&gt; wrong).<br>&gt;&gt; <br>&gt;&gt; [My commentary in brackets.]<br>&gt;&gt; <br>&gt;&gt; ** Recap of address-only.<br>&gt;&gt; <br>&gt;&gt; Divide address-only types into two categories:<br>&gt;&gt; 1. By abstraction (compiler doesn&#39;t know the size).<br>&gt;&gt; 2. The type is &quot;memory-linked&quot;. i.e. the address is significant at runtime.<br>&gt;&gt;    - weak references (anything that registers its address).<br>&gt;&gt;    - C++ this.<br>&gt;&gt;    - Anything with interior pointers.<br>&gt;&gt;    - Any shared-borrowed value of a type with &quot;nonmutating&quot; properties.<br>&gt;&gt;      [&quot;nonmutating&quot; properties allow mutation of state attached to a value.<br>&gt;&gt;       Rust atomics are an example.]<br>&gt;&gt; <br>&gt;&gt; Address-only will not be reflected in SIL types. SIL addresses should<br>&gt;&gt; only be used for formal memory (pointers, globals, class<br>&gt;&gt; properties, captures). We&#39;ll get to inout arguments later...<br>&gt;&gt; <br>&gt;&gt; As with opaque types, when IRGen lowers a memory-linked borrowed type,<br>&gt;&gt; it needs to allocate storage.<br>&gt;&gt; <br>&gt;&gt; Concern: SILGen has built-in tracking of managed values that automates<br>&gt;&gt; insertion of cleanups. Lowering address-only types after SILOpt would<br>&gt;&gt; require rediscovering that information based on CFG analysis. Is this<br>&gt;&gt; too heroic?<br>&gt;&gt; <br>&gt;&gt; This was already described by John. Briefly recapping:<br>&gt;&gt; <br>&gt;&gt; e.g. Constructung Optional&lt;Any&gt;<br>&gt;&gt; <br>&gt;&gt; We want initialization should be in-place as such:<br>&gt;&gt; <br>&gt;&gt; %0 = struct_element_addr .. #S.any<br>&gt;&gt; %1 = init_existential_addr %0, $*Any, $Optional&lt;X&gt;<br>&gt;&gt; %2 = inject_enum_data_addr %1, $Optional&lt;X&gt;.Some<br>&gt;&gt; apply @initX(%2)<br>&gt;&gt; <br>&gt;&gt; SILValue initialization would look something like:<br>&gt;&gt; <br>&gt;&gt; %0 = apply @initX()<br>&gt;&gt; %1 = enum #Optional.Some, %0 : $X<br>&gt;&gt; %2 = existential %1 : $Any<br>&gt;&gt; <br>&gt;&gt; [I&#39;m not sure we actually want to represent an existential container<br>&gt;&gt; this way, but enum, yes.]<br>&gt;&gt; <br>&gt;&gt; Lowering now requires discovering the storage structure, bottom-up,<br>&gt;&gt; hoisting allocation, inserting cleanups as John explained.<br>&gt;&gt; <br>&gt;&gt; Side note: Before lowering, something like alloc_box would directly<br>&gt;&gt; take its initial value.<br>&gt;&gt; <br>&gt;&gt; ** SILFunction calling convention.<br>&gt;&gt; <br>&gt;&gt; For ownership analysis, there&#39;s effectively no difference between the<br>&gt;&gt; value/address forms of argument ownership:<br>&gt;&gt; <br>&gt;&gt; @owned          / @in<br>&gt;&gt; @guaranteed     / @in_guaranteed<br>&gt;&gt; return          / @out<br>&gt;&gt; @owned arg<br>&gt;&gt; + @owned return / @inout<br>&gt;&gt; <br>&gt;&gt; Regardless of the representation we choose for @inout, @in/@out will<br>&gt;&gt; now be scalar types. SILFunction will maintain the distinction between<br>&gt;&gt; @owned/@in etc. based on whether the type is address-only. We need<br>&gt;&gt; this for reabstraction, but it only affects the function type, not the<br>&gt;&gt; calling convention.<br>&gt;&gt; <br>&gt;&gt; Rather than building a tuple, John prefers SIL support for anonymous<br>&gt;&gt; aggregate as &quot;exploded values&quot;.<br>&gt;&gt; <br>&gt;&gt; [I&#39;m guessing because tuples are a distinct formal type with their own<br>&gt;&gt; convention and common ownership. This may need some discussion though.]<br>&gt;&gt; <br>&gt;&gt; Example SIL function type:<br>&gt;&gt; <br>&gt;&gt; $(@in P, @owned Q) -&gt; (@owned R, @owned S, @out T, @out U)<br>&gt;&gt; <br>&gt;&gt; %p = apply f: $() -&gt; P<br>&gt;&gt; %q = apply g: $() -&gt; Q<br>&gt;&gt; %exploded = apply h(%p, %q)<br>&gt;&gt; %r = project_exploded %exploded, #0 : $R<br>&gt;&gt; %s = project_exploded %exploded, #1 : $S<br>&gt;&gt; %t = project_exploded %exploded, #2 : $T<br>&gt;&gt; %u = project_exploded %exploded, #3 : $U<br>&gt;&gt; <br>&gt;&gt; Exploded types requires all their elements to be projected with their<br>&gt;&gt; own independent ownership.<br>&gt;&gt; <br>&gt;&gt; ** Ownership terminology.<br>&gt;&gt; <br>&gt;&gt; Swift &quot;owned&quot;    = Rust values           = SIL @owned      = implicitly consumed<br>&gt;&gt; Swift &quot;borrowed&quot; = Rust immutable borrow = SIL @guaranteed = shared<br>&gt;&gt; Swift &quot;inout&quot;    = Rust mutable borrow   = SIL @inout      = unique<br>&gt;&gt; <br>&gt;&gt; Swift &quot;inout&quot; syntax is already (nearly) sufficient.<br>&gt;&gt; <br>&gt;&gt; &quot;borrowed&quot; may not need syntax on the caller side, just a way to<br>&gt;&gt; qualify parameters. Swift still needs syntax for returning a borrowed<br>&gt;&gt; value.<br>&gt;&gt; <br>&gt;&gt; ** Representation of borrowed values.<br>&gt;&gt; <br>&gt;&gt; Borrowed values represent some shared storage location.<br>&gt;&gt; <br>&gt;&gt; We want some borrowed value references to be passed as SIL values, not SIL addresses:<br>&gt;&gt; - Borrowed class references should not be indirected.<br>&gt;&gt; - Optimize borrowing other small non-memory linked types.<br>&gt;&gt; - Support capture promotion, and other SSA optimizations.<br>&gt;&gt; - Borrow CoW values directly.<br>&gt;&gt; <br>&gt;&gt; [Address-only borrowed types will still be passed as SIL addresses (why not?)]<br>&gt;&gt; <br>&gt;&gt; Borrowed types with potentially mutating properties must be passed by<br>&gt;&gt; SIL address because they are not actually immutable and their storage<br>&gt;&gt; location is significant.<br>&gt;&gt; <br>&gt;&gt; Borrowed references have a scope and need an end-of-borrow marker.<br>&gt;&gt; <br>&gt;&gt; [The end-of-borrow marker semantically changes the memory state, and<br>&gt;&gt; statically enforces non-overlapping memory states. It does not<br>&gt;&gt; semantically write-back a value. Borrowed values with mutating fields<br>&gt;&gt; are semantically modified in-place.]<br>&gt;&gt; <br>&gt;&gt; [Regardless of whether borrowed references are represented as SIL<br>&gt;&gt; values or addresses, they must be associated with formal storage. That<br>&gt;&gt; storage must remain immutable at the language level (although it may<br>&gt;&gt; have mutating fields) and the value cannot be destroyed during the<br>&gt;&gt; borrowed scope].<br>&gt;&gt; <br>&gt;&gt; [Trivial borrowed values can be demoted to copies so we can eliminate<br>&gt;&gt; their scope]<br>&gt;&gt; <br>&gt;&gt; [Anything borrowed from global storage (and not demoted to a copy)<br>&gt;&gt; needs its scope to be dynamically enforced. Borrows from local storage<br>&gt;&gt; are sufficiently statically enforced. However, in both cases the<br>&gt;&gt; optimizer must respect the static scope of the borrow.]<br>&gt;&gt; <br>&gt;&gt; [I think borrowed values are effectively passed @guaranteed. The<br>&gt;&gt; end-of-borrow scope marker will then always be at the top-level<br>&gt;&gt; scope. You can&#39;t borrow in a caller and end its scope in the callee.]<br>&gt;&gt; <br>&gt;&gt; ** Borrowed and inout scopes.<br>&gt;&gt; <br>&gt;&gt; inout value references are also scoped. We&#39;ll get to their<br>&gt;&gt; representation shortly. Within an inout scope, memory is in an<br>&gt;&gt; exclusive state. No borrowed scopes may overlap with an inout state,<br>&gt;&gt; which is to say, memory is either shared or exclusive.<br>&gt;&gt; <br>&gt;&gt; We need a flag for stored properties, even for simple trivial<br>&gt;&gt; types. That&#39;s the only way to provide a simple user model. At least we<br>&gt;&gt; don&#39;t need this to be implemented atomically, we&#39;re not detecting race<br>&gt;&gt; conditions. Optimizations will come later. We should be able to prove<br>&gt;&gt; that some stored properties are never passed as inout.<br>&gt;&gt; <br>&gt;&gt; The stored property flag needs to be a tri-state: owned, borrowed, exclusive.<br>&gt;&gt; <br>&gt;&gt; The memory value can only be destroyed in the owned state.<br>&gt;&gt; <br>&gt;&gt; The user may mark some storage locations as &quot;unchecked&quot; as an<br>&gt;&gt; opt-out. That doesn&#39;t change the optimizer&#39;s constraints. It simply<br>&gt;&gt; bypasses the runtime check.<br>&gt;&gt; <br>&gt;&gt; ** Ownership of loaded values.<br>&gt;&gt; <br>&gt;&gt; [MikeG already explained possibilities of load ownership in<br>&gt;&gt; [swift-dev] [semantic-arc][proposal] High Level ARC Memory Operations]<br>&gt;&gt; <br>&gt;&gt; For the sake of understanding the model, it&#39;s worth realizing that we<br>&gt;&gt; only need one form of load ownership: load_borrow. We don&#39;t<br>&gt;&gt; actually need an operation that loads an owned value out of formal<br>&gt;&gt; storage. This makes canonical sense because:<br>&gt;&gt; <br>&gt;&gt; - Semantically, a load must at least be a borrow because the storage<br>&gt;&gt;   location&#39;s non-exclusive flag needs to be dynamically checked<br>&gt;&gt;   anyway, even if the value will be copied.<br>&gt;&gt; <br>&gt;&gt; - Code motion in the SIL optimizer has to obey the same limitations<br>&gt;&gt;   within borrow scopes regardless of whether we fuse loads and copies<br>&gt;&gt;   (retains).<br>&gt;&gt; <br>&gt;&gt; [For the purpose of semantic ARC, the copy_value would be the RC<br>&gt;&gt; root. The load and copy_value would effectively be &quot;coupled&quot; by the<br>&gt;&gt; static scope of the borrow. e.g. we would not want to move a release<br>&gt;&gt; inside the static scope of a borrow.]<br>&gt;&gt; <br>&gt;&gt; [Purely in the interest of concise SIL, I still think we want a load [copy].]<br>&gt;&gt; <br>&gt;&gt; ** SIL value ownership and aggregates<br>&gt;&gt; <br>&gt;&gt; Operations on values:<br>&gt;&gt; 1. copy<br>&gt;&gt; 2. forward (move)<br>&gt;&gt; 3. borrow (share)<br>&gt;&gt; <br>&gt;&gt; A copy or forward produces an owned value.<br>&gt;&gt; An owned value has a single consumer.<br>&gt;&gt; A borrow has static scope.<br>&gt;&gt; <br>&gt;&gt; For simplicity, passing a bb argument only has move semantics (it<br>&gt;&gt; forwards the value). Later that can be expanded if needed.<br>&gt;&gt; <br>&gt;&gt; We want to allow simultaneous access to independent subelements of a<br>&gt;&gt; fragile aggregate. We should be able to borrow one field while<br>&gt;&gt; mutating another.<br>&gt;&gt; <br>&gt;&gt; Is it possible to forward a subelement within an aggregate? No. But we<br>&gt;&gt; can fully explode an owned aggregate into individual owned elements<br>&gt;&gt; and reconstruct the aggregate. This makes use of the @exploded type<br>&gt;&gt; feature described in the calling convention.<br>&gt;&gt; <br>&gt;&gt; [I don&#39;t think forwarding a subelement is useful anyway except for<br>&gt;&gt; modeling @inout semantics...]<br>&gt;&gt; <br>&gt;&gt; That leads us to this question: Does an @inout value reference have<br>&gt;&gt; formal storage (thus a SIL address) or is it just a convention for<br>&gt;&gt; passing owned SSA values?<br>&gt;&gt; <br>&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt; <br>&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt; <br>&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt; their own storage.<br>&gt;&gt; <br>&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt; solves one side of the problem.]<br>&gt;&gt; <br>&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt; projecting an address...]<br>&gt;&gt; <br>&gt;&gt; ** World 2: @inout formal storage<br>&gt;&gt; <br>&gt;&gt; In this world, @inout references continue to have SILType $*T with<br>&gt;&gt; guaranteed exclusive access.<br>&gt;&gt; <br>&gt;&gt; Memory state can be:<br>&gt;&gt; - uninitialized<br>&gt;&gt; - holds an owned value<br>&gt;&gt;   - has exclusive access<br>&gt;&gt;   - has shared access<br>&gt;&gt; <br>&gt;&gt; --- expected transitions need to be handled<br>&gt;&gt;   - must become uninitialized<br>&gt;&gt;   - must become initialized<br>&gt;&gt;   - must preserve initialization state<br>&gt;&gt; <br>&gt;&gt; We need to mark initializers with some &quot;must initialize&quot; marker,<br>&gt;&gt; similar to how we mark deinitializers [this isn&#39;t clear to me yet].<br>&gt;&gt; <br>&gt;&gt; We could give address types qualifiers to distinguish the memory state<br>&gt;&gt; of their pointee (uninitialized, shared, exclusive). Addresses<br>&gt;&gt; themselves could be pseudo-linear types. This would provide the same<br>&gt;&gt; use-def guarantees as the SSA @inout approach, but producing a new<br>&gt;&gt; address each type memory changes states would also be complicated and<br>&gt;&gt; cumbersome (though not as bad as SSA).<br>&gt;&gt; <br>&gt;&gt; [[<br>&gt;&gt; We didn&#39;t talk about the alternative, but presumably exclusive<br>&gt;&gt; vs. shared scope would be delimited by pseudo memory operations as<br>&gt;&gt; such:<br>&gt;&gt; <br>&gt;&gt; %a1 = alloc_stack<br>&gt;&gt; <br>&gt;&gt; begin_exclusive %a<br>&gt;&gt; apply foo(%a) // must be marked an initializer?<br>&gt;&gt; end_exclusive %a<br>&gt;&gt; <br>&gt;&gt; begin_shared %a<br>&gt;&gt; apply bar(%a) // immutable access<br>&gt;&gt; end_shared %a<br>&gt;&gt; <br>&gt;&gt; dealloc_stack %a<br>&gt;&gt; <br>&gt;&gt; Values loaded from shared memory also need to be scoped. They must be<br>&gt;&gt; consumed within the shared region. e.g.<br>&gt;&gt; <br>&gt;&gt; %a2 = ref_element_addr<br>&gt;&gt; <br>&gt;&gt; %x = load_borrow %a2<br>&gt;&gt; <br>&gt;&gt; end_borrow %x, %a2<br>&gt;&gt; <br>&gt;&gt; It makes sense to me that a load_borrow would implicitly transition<br>&gt;&gt; memory to shared state, and end_borrow would implicitly return memory<br>&gt;&gt; to an owned state. If the address type is already ($* @borrow T), then<br>&gt;&gt; memory would remain in the shared state.<br>&gt;&gt; ]]<br>&gt;&gt; <br>&gt;&gt; For all sorts of analysis and optimization, from borrow checking to<br>&gt;&gt; CoW to ARC, we really need aliasing guarantees. Knowing we have a<br>&gt;&gt; unique address to a location is about as good as having an owned<br>&gt;&gt; value.<br>&gt;&gt; <br>&gt;&gt; To get this guarantee we need to structurally guarantee<br>&gt;&gt; unique addresses.<br>&gt;&gt; <br>&gt;&gt; [Is there a way to do this with out making all the element_addr<br>&gt;&gt; operations scoped?]<br>&gt;&gt; <br>&gt;&gt; With aliasing guaratees, verification should be able to statically<br>&gt;&gt; prove that most formal storage locations are properly initialized and<br>&gt;&gt; uninitialized (pseudo-linear type) by inspecting the memory<br>&gt;&gt; operations.<br>&gt;&gt; <br>&gt;&gt; Likewise, we can verify the shared vs. exclusive states.<br>&gt;&gt; <br>&gt;&gt; Representing @inout with addresses doesn&#39;t really add features to<br>&gt;&gt; SIL. In any case, SIL address types are still used for<br>&gt;&gt; formal storage. Exclusive access through any of the following<br>&gt;&gt; operations must be guaranteed dynamically:<br>&gt;&gt; <br>&gt;&gt; - ref_element_addr<br>&gt;&gt; - global_addr<br>&gt;&gt; - pointer_to_address<br>&gt;&gt; - alloc_stack<br>&gt;&gt; - project_box<br>&gt;&gt; <br>&gt;&gt; We end up with these basic SIL Types:<br>&gt;&gt; <br>&gt;&gt; $T = owned value<br>&gt;&gt; <br>&gt;&gt; $@borrowed T = shared value<br>&gt;&gt; <br>&gt;&gt; $*T = exclusively accessed<br>&gt;&gt; <br>&gt;&gt; $* @borrowed T = shared access<br>&gt;&gt; <br>&gt;&gt; [I think the non-address @borrowed type is only valid for concrete<br>&gt;&gt; types that the compiler knows are not memory-linked? This can be used<br>&gt;&gt; to avoid passing borrowed values indirectly for arrays and other<br>&gt;&gt; small, free-to-copy values].<br>&gt;&gt; <br>&gt;&gt; [We obviously need to work through concrete examples before we can<br>&gt;&gt; claim to have a real design.]<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161010/52ee77fd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; ** World 1: SSA @inout<br>&gt; <br>&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt; from it&#39;s parent object by looking through projections?<br>&gt; <br>&gt; Either way, projecting any subelement requires reconstructing the<br>&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt; their own storage.<br>&gt; <br>&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt; solves one side of the problem.]<br>&gt; <br>&gt; [I argue that this actually obscures the producer/consumer<br>&gt; relationship, which is the opposite of the intention of moving to<br>&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt; sense. It does make sense to borrow a subelement (not for<br>&gt; mutation). It also makes sense to project a mutable storage<br>&gt; location. The natural way to project a storage location is by<br>&gt; projecting an address...]<br></p><p>I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt; <br>&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt; <br>&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt; their own storage.<br>&gt;&gt; <br>&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt; solves one side of the problem.]<br>&gt;&gt; <br>&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt; projecting an address...]<br>&gt; <br>&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt; <br>&gt; -Joe<br></p><p>We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br></p><p>(Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt; projecting an address...]<br>&gt;&gt; <br>&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt; <br>&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br></p><p>Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt; <br>&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt; <br>&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt; <br>&gt; -Joe<br></p><p>We could have an is_unique instruction that returns a “new” reference to storage. But our model for CoW data types relies mutating methods so I don&#39;t really know what you have in mind.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 10:33 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt; <br>&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; We could have an is_unique instruction that returns a “new” reference to storage. But our model for CoW data types relies mutating methods so I don&#39;t really know what you have in mind.<br></p><p>It doesn&#39;t fundamentally have to be tied to mutating methods. After all, you ought to be able to take a value parameter you received as uniquely-referenced, and work on that in-place:<br></p><p>func appendTwoArrays(a: [Int], b: [Int]) -&gt; [Int] {<br>  var a2 = __move__ a // fake syntax to force a move of ownership<br>  if isUniquelyReferenced(&amp;a2) {<br>    a2.buffer._appendInPlace(b.buffer)<br>  } else {<br>    a2.buffer = Array(buffer: ArrayBuffer(appending: a2.buffer, and: b.buffer)<br>  }<br>  return a2<br>}<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt; <br>&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt; <br>&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br></p><p>As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br></p><p>My point is that this isn&#39;t a SIL representational problem, it&#39;s a semantic problem that&#39;s being correctly reflected in SIL.  The language tools which will allow us to fix the semantic problem will necessarily also need to be reflected correctly in SIL, and so there won&#39;t be a representational problem.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt; <br>&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt; <br>&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br></p><p>If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br></p><p>entry(%1: @owned $X):<br>  is_uniquely_referenced %1, yes, no<br>yes(%2: /*unique*/ @owned $X):<br>  // %2 is unique, until copied at least<br>no(%3: @owned %X):<br>  // %3 is not<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt; <br>&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt; <br>&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt; <br>&gt; entry(%1: @owned $X):<br>&gt;  is_uniquely_referenced %1, yes, no<br>&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;  // %2 is unique, until copied at least<br>&gt; no(%3: @owned %X):<br>&gt;  // %3 is not<br>&gt; <br>&gt; -Joe<br></p><p>You had to copy $X to make it @owned. You could check uniqueness of @borrowed $X, but then you’d need to copy to create a new array (mutation) before destroying the original that you borrowed from.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 11:19 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt;&gt; <br>&gt;&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt;&gt; <br>&gt;&gt; entry(%1: @owned $X):<br>&gt;&gt; is_uniquely_referenced %1, yes, no<br>&gt;&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;&gt; // %2 is unique, until copied at least<br>&gt;&gt; no(%3: @owned %X):<br>&gt;&gt; // %3 is not<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; You had to copy $X to make it @owned.<br></p><p>This is the part I think I&#39;m missing. It&#39;s not clear to me why this is the case, though. You could have had an Array return value that has never been stored in memory, so never needed to be copied. If you have an @inout memory location, and we enforce the single-owner property on inouts so that they act like a Rust-style mutable borrow, then you should also be able to take the value out of the memory location as long as you move a value back in before the scope of the inout expires.<br></p><p>-Joe<br></p><p>&gt; You could check uniqueness of @borrowed $X, but then you’d need to copy to create a new array (mutation) before destroying the original that you borrowed from.<br>&gt; <br>&gt; -Andy<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 11:22 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Oct 11, 2016, at 11:19 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; entry(%1: @owned $X):<br>&gt;&gt;&gt; is_uniquely_referenced %1, yes, no<br>&gt;&gt;&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;&gt;&gt; // %2 is unique, until copied at least<br>&gt;&gt;&gt; no(%3: @owned %X):<br>&gt;&gt;&gt; // %3 is not<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; You had to copy $X to make it @owned.<br>&gt; <br>&gt; This is the part I think I&#39;m missing. It&#39;s not clear to me why this is the case, though. You could have had an Array return value that has never been stored in memory, so never needed to be copied. If you have an @inout memory location, and we enforce the single-owner property on inouts so that they act like a Rust-style mutable borrow, then you should also be able to take the value out of the memory location as long as you move a value back in before the scope of the inout expires.<br></p><p>I&#39;m not sure what your goal is here vs. relying on borrowing.  Both still require actual analysis to prove uniqueness at any given point, as you note with your &quot;until copied at least&quot; comment.<br></p><p>Also, from a higher level, I&#39;m not sure why we care whether a value that was semantically an r-value was a unique reference.  CoW types are immutable even if the reference is shared, and that should structurally straightforward to take advantage of under any ownership representation.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 11:44 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 11:22 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Oct 11, 2016, at 11:19 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; entry(%1: @owned $X):<br>&gt;&gt;&gt;&gt; is_uniquely_referenced %1, yes, no<br>&gt;&gt;&gt;&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;&gt;&gt;&gt; // %2 is unique, until copied at least<br>&gt;&gt;&gt;&gt; no(%3: @owned %X):<br>&gt;&gt;&gt;&gt; // %3 is not<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You had to copy $X to make it @owned.<br>&gt;&gt; <br>&gt;&gt; This is the part I think I&#39;m missing. It&#39;s not clear to me why this is the case, though. You could have had an Array return value that has never been stored in memory, so never needed to be copied. If you have an @inout memory location, and we enforce the single-owner property on inouts so that they act like a Rust-style mutable borrow, then you should also be able to take the value out of the memory location as long as you move a value back in before the scope of the inout expires.<br>&gt; <br>&gt; I&#39;m not sure what your goal is here vs. relying on borrowing.  Both still require actual analysis to prove uniqueness at any given point, as you note with your &quot;until copied at least&quot; comment.<br>&gt; <br>&gt; Also, from a higher level, I&#39;m not sure why we care whether a value that was semantically an r-value was a unique reference.  CoW types are immutable even if the reference is shared, and that should structurally straightforward to take advantage of under any ownership representation.<br></p><p>My high-level goal was to get to a point where we could support in-place optimizations on unique buffers that belong to values that are semantically rvalues at the language level. It seems to me that we ought to be able to make &#39;stringA + B + C + D&#39; as efficient as &#39;{ var tmp = stringA; tmp += B; tmp += C; tmp += D; tmp }()&#39; by enabling uniqueness checks and in-place mutation of the unique-by-construction results of +-ing strings. If you think that works under the borrow/inout-in-memory model, then no problem; I&#39;m also trying to understand the design space a bit more.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 11:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Oct 11, 2016, at 11:44 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 11:22 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:19 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; entry(%1: @owned $X):<br>&gt;&gt;&gt;&gt;&gt; is_uniquely_referenced %1, yes, no<br>&gt;&gt;&gt;&gt;&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;&gt;&gt;&gt;&gt; // %2 is unique, until copied at least<br>&gt;&gt;&gt;&gt;&gt; no(%3: @owned %X):<br>&gt;&gt;&gt;&gt;&gt; // %3 is not<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You had to copy $X to make it @owned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the part I think I&#39;m missing. It&#39;s not clear to me why this is the case, though. You could have had an Array return value that has never been stored in memory, so never needed to be copied. If you have an @inout memory location, and we enforce the single-owner property on inouts so that they act like a Rust-style mutable borrow, then you should also be able to take the value out of the memory location as long as you move a value back in before the scope of the inout expires.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure what your goal is here vs. relying on borrowing.  Both still require actual analysis to prove uniqueness at any given point, as you note with your &quot;until copied at least&quot; comment.<br>&gt;&gt; <br>&gt;&gt; Also, from a higher level, I&#39;m not sure why we care whether a value that was semantically an r-value was a unique reference.  CoW types are immutable even if the reference is shared, and that should structurally straightforward to take advantage of under any ownership representation.<br>&gt; <br>&gt; My high-level goal was to get to a point where we could support in-place optimizations on unique buffers that belong to values that are semantically rvalues at the language level. It seems to me that we ought to be able to make &#39;stringA + B + C + D&#39; as efficient as &#39;{ var tmp = stringA; tmp += B; tmp += C; tmp += D; tmp }()&#39; by enabling uniqueness checks and in-place mutation of the unique-by-construction results of +-ing strings. If you think that works under the borrow/inout-in-memory model, then no problem; I&#39;m also trying to understand the design space a bit more.<br></p><p>Ah right, that optimization.  The problem here with using borrows is that you really want static enforcement that both (1) you&#39;ve really got ownership of a unique reference (so e.g. you aren&#39;t just forwarding a borrowed value down)  and (2) you&#39;re not accidentally copying the reference and so ruining the uniqueness check.  Those are hard guarantees to get with an implicitly-copyable type.<br></p><p>I wonder if it would make more sense to make copy-on-write buffer references a move-only type, so that as long as you were just working with the raw reference (as opposed to the CoW aggregate, which would remain copyable) it wouldn&#39;t get implicitly copied anymore.  You could have mutable and immutable buffer reference types, both move-only, and there could be a consuming checkUnique operation on the immutable one that, I dunno, returned an Either of the mutable and immutable versions.<br></p><p>For CoW aggregates, you&#39;d need some @copied attribute on the field to make sure that the CoW attribute was still copyable.  Within the implementation of the type, though, you would be projecting out the reference immediately, and thereafter you&#39;d be certain that you were borrowing / moving it around as appropriate.<br></p><p>I dunno.  It&#39;s an idea.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 2:14 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 11:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Oct 11, 2016, at 11:44 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:22 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:19 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; entry(%1: @owned $X):<br>&gt;&gt;&gt;&gt;&gt;&gt; is_uniquely_referenced %1, yes, no<br>&gt;&gt;&gt;&gt;&gt;&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;&gt;&gt;&gt;&gt;&gt; // %2 is unique, until copied at least<br>&gt;&gt;&gt;&gt;&gt;&gt; no(%3: @owned %X):<br>&gt;&gt;&gt;&gt;&gt;&gt; // %3 is not<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You had to copy $X to make it @owned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is the part I think I&#39;m missing. It&#39;s not clear to me why this is the case, though. You could have had an Array return value that has never been stored in memory, so never needed to be copied. If you have an @inout memory location, and we enforce the single-owner property on inouts so that they act like a Rust-style mutable borrow, then you should also be able to take the value out of the memory location as long as you move a value back in before the scope of the inout expires.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure what your goal is here vs. relying on borrowing.  Both still require actual analysis to prove uniqueness at any given point, as you note with your &quot;until copied at least&quot; comment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, from a higher level, I&#39;m not sure why we care whether a value that was semantically an r-value was a unique reference.  CoW types are immutable even if the reference is shared, and that should structurally straightforward to take advantage of under any ownership representation.<br>&gt;&gt; <br>&gt;&gt; My high-level goal was to get to a point where we could support in-place optimizations on unique buffers that belong to values that are semantically rvalues at the language level. It seems to me that we ought to be able to make &#39;stringA + B + C + D&#39; as efficient as &#39;{ var tmp = stringA; tmp += B; tmp += C; tmp += D; tmp }()&#39; by enabling uniqueness checks and in-place mutation of the unique-by-construction results of +-ing strings. If you think that works under the borrow/inout-in-memory model, then no problem; I&#39;m also trying to understand the design space a bit more.<br>&gt; <br>&gt; Ah right, that optimization.  The problem here with using borrows is that you really want static enforcement that both (1) you&#39;ve really got ownership of a unique reference (so e.g. you aren&#39;t just forwarding a borrowed value down)  and (2) you&#39;re not accidentally copying the reference and so ruining the uniqueness check.  Those are hard guarantees to get with an implicitly-copyable type.<br>&gt; <br>&gt; I wonder if it would make more sense to make copy-on-write buffer references a move-only type, so that as long as you were just working with the raw reference (as opposed to the CoW aggregate, which would remain copyable) it wouldn&#39;t get implicitly copied anymore.  You could have mutable and immutable buffer reference types, both move-only, and there could be a consuming checkUnique operation on the immutable one that, I dunno, returned an Either of the mutable and immutable versions.<br>&gt; <br>&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field to make sure that the CoW attribute was still copyable.  Within the implementation of the type, though, you would be projecting out the reference immediately, and thereafter you&#39;d be certain that you were borrowing / moving it around as appropriate.<br>&gt; <br>&gt; I dunno.  It&#39;s an idea.<br>&gt; <br>&gt; John.<br></p><p>So, to project a MutabableArrayStorage we would need to explode an owned Array into an owned ConstArrayStorage (forwarding its value). Then pass it to:<br>  isUniqueOwned(ConstArrayStorage) -&gt; either&lt;MutableArrayStorage, ConstArrayStorage&gt;<br></p><p>Making it move-only should give us the necessary guarantee for Erik&#39;s CoW proposal: Nothing can mutate the storage as long as ConstArrayStorage is alive.<br></p><p>Then how would we get MutabableArrayStorage from inout Array?<br>We can project the address of an inout ConstArrayStorage from the inout Array. Then we need to magically cast its address to *MutableArrayStorage, and somehow tie it to the inout ConstArrayStorage scope.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[discussion notes] SIL address types and borrowing</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 4:48 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; On Oct 11, 2016, at 2:14 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 11:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:44 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:22 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:19 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:50 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 10:10 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:58 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 10, 2016, at 6:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 11:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ** World 1: SSA @inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Projecting an element produces a new SILValue. Does this SILValue have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s own ownership associated with it&#39;s lifetime, or is it derived<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from it&#39;s parent object by looking through projections?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Either way, projecting any subelement requires reconstructing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entire aggregate in SIL, through all nesting levels. This will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generate a massive amount of SILValues. Superficially they all need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their own storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [We could claim that projections don&#39;t need storage, but that only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solves one side of the problem.]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [I argue that this actually obscures the producer/consumer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; relationship, which is the opposite of the intention of moving to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SSA. Projecting subelements for mutation fundamentally doesn&#39;t make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense. It does make sense to borrow a subelement (not for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutation). It also makes sense to project a mutable storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; location. The natural way to project a storage location is by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projecting an address...]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think there&#39;s a size threshold at which SSA @inout is manageable, and might lead to overall better register-oriented code, if the aggregates can be exploded into a small number of individual values. The cost of reconstructing the aggregate could be mitigated somewhat by introducing &#39;insert&#39; instructions for aggregates to pair with the projection instructions, similar to how LLVM has insert/extractelement. &quot;%x = project_value %y.field; %x&#39; = transform(%x); %y&#39; = insert %y.field, %x&quot; isn&#39;t too terrible compared to the address-oriented formulation. Tracking ownership state through projections and insertions might tricky; haven&#39;t thought about that aspect.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We would have to make sure SROA+mem2reg could still kick in. If that happens, I don’t think we need to worry about inout ownership semantics anymore. A struct_extract is then essentially a borrow. It’s parent’s lifetime needs to be guaranteed, but I don’t know if the subobject needs explicit scoping in SIL since there’s no inout scopes to worry about and nothing for the runtime to do when the scope ends .<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Incidentally, this would never happen to a CoW type that has a uniqueness check—to mutate a CoW type, it’s value needs to be in memory). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does a uniqueness check still need to be associated with a memory location once we associate ownership with SSA values? It seems to me like it wouldn&#39;t necessarily need to be. One thing I&#39;d like us to work toward is being able to reliably apply uniqueness checks to rvalues, so that code in a &quot;pure functional&quot; style gets the same optimization benefits as code that explicitly uses inouts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As I&#39;ve pointed out in the past, this doesn&#39;t make any semantic sense.  Projecting out a buffer reference as a true r-value creates an independent value and therefore requires bumping the reference count.  The only query that makes semantic sense is &quot;does this value hold a unique reference to its buffer&quot;, which requires some sort of language tool for talking abstractly about values without creating new, independent values.  Our only existing language tool for that is inout, which allows you to talk about the value stored in a specific mutable variable.  Ownership will give us a second and more general tool, borrowing, which allows you abstractly refer to immutable existing values.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we have @owned values, then we also have the ability to do a uniqueness check on that value, don&#39;t we? This would necessarily consume the value, but we could conditionally produce a new known-unique value on the path where the uniqueness check succeeds.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; entry(%1: @owned $X):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is_uniquely_referenced %1, yes, no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; yes(%2: /*unique*/ @owned $X):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // %2 is unique, until copied at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; no(%3: @owned %X):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // %3 is not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You had to copy $X to make it @owned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is the part I think I&#39;m missing. It&#39;s not clear to me why this is the case, though. You could have had an Array return value that has never been stored in memory, so never needed to be copied. If you have an @inout memory location, and we enforce the single-owner property on inouts so that they act like a Rust-style mutable borrow, then you should also be able to take the value out of the memory location as long as you move a value back in before the scope of the inout expires.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure what your goal is here vs. relying on borrowing.  Both still require actual analysis to prove uniqueness at any given point, as you note with your &quot;until copied at least&quot; comment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, from a higher level, I&#39;m not sure why we care whether a value that was semantically an r-value was a unique reference.  CoW types are immutable even if the reference is shared, and that should structurally straightforward to take advantage of under any ownership representation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My high-level goal was to get to a point where we could support in-place optimizations on unique buffers that belong to values that are semantically rvalues at the language level. It seems to me that we ought to be able to make &#39;stringA + B + C + D&#39; as efficient as &#39;{ var tmp = stringA; tmp += B; tmp += C; tmp += D; tmp }()&#39; by enabling uniqueness checks and in-place mutation of the unique-by-construction results of +-ing strings. If you think that works under the borrow/inout-in-memory model, then no problem; I&#39;m also trying to understand the design space a bit more.<br>&gt;&gt; <br>&gt;&gt; Ah right, that optimization.  The problem here with using borrows is that you really want static enforcement that both (1) you&#39;ve really got ownership of a unique reference (so e.g. you aren&#39;t just forwarding a borrowed value down)  and (2) you&#39;re not accidentally copying the reference and so ruining the uniqueness check.  Those are hard guarantees to get with an implicitly-copyable type.<br>&gt;&gt; <br>&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer references a move-only type, so that as long as you were just working with the raw reference (as opposed to the CoW aggregate, which would remain copyable) it wouldn&#39;t get implicitly copied anymore.  You could have mutable and immutable buffer reference types, both move-only, and there could be a consuming checkUnique operation on the immutable one that, I dunno, returned an Either of the mutable and immutable versions.<br>&gt;&gt; <br>&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field to make sure that the CoW attribute was still copyable.  Within the implementation of the type, though, you would be projecting out the reference immediately, and thereafter you&#39;d be certain that you were borrowing / moving it around as appropriate.<br>&gt;&gt; <br>&gt;&gt; I dunno.  It&#39;s an idea.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; So, to project a MutabableArrayStorage we would need to explode an owned Array into an owned ConstArrayStorage (forwarding its value). Then pass it to:<br>&gt;  isUniqueOwned(ConstArrayStorage) -&gt; either&lt;MutableArrayStorage, ConstArrayStorage&gt;<br>&gt; <br>&gt; Making it move-only should give us the necessary guarantee for Erik&#39;s CoW proposal: Nothing can mutate the storage as long as ConstArrayStorage is alive.<br>&gt; <br>&gt; Then how would we get MutabableArrayStorage from inout Array?<br>&gt; We can project the address of an inout ConstArrayStorage from the inout Array. Then we need to magically cast its address to *MutableArrayStorage, and somehow tie it to the inout ConstArrayStorage scope.<br></p><p>Well, makeUnique would be a ConstArrayStorage -&gt; MutableArrayStorage function, and when you were done, you would demote to ConstArrayStorage and write back.  It&#39;s perhaps a little ugly.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
