<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  6, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/214d1bb1587020b60ef37c85b887562e?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Alex Johnson</string> &lt;ajohnson at quickleft.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>(this is mostly a repost of a message I sent to the &quot;[draft]&quot; thread for<br>this proposal, with some light editing to better match terminology in the<br>proposal)<br></p><p>*What is your evaluation of the proposal?*<br></p><p>I like this proposal. I think it will bring some much-needed ease-of-use.<br></p><p>I have reservations about the &quot;...&quot; placeholder for the memberwise<br>initialization parameters, though. I know this was suggested by<br>Chris Lattner, so I&#39;m inclined to defer to his judgement. But, here are my<br>thoughts:<br></p><p>First, it&#39;s very close to the varags syntax (e.g. &quot;Int...&quot;) which can also<br>appear in initializer parameter lists.<br></p><p>Second, and I think more important, I&#39;m not sure that it&#39;s all that *useful*.<br>It&#39;s presence isn&#39;t necessary for triggering memberwise initialization<br>synthesis; that is already done by the &quot;memberwise&quot; keyword.<br></p><p>The primary example given in the proposal is:<br></p><p>memberwise init(anInt: Int, anotherInt: Int, ...) {<br></p><p>  /* code using anInt and anotherInt */<br></p><p>}<br></p><p><br>That is, it&#39;s used to indicate where the synthesized parameters appear in<br>the parameter list if there are also custom (non-memberwise) parameters.<br></p><p>My question is, *could the memberwise initialization parameters always be<br>last?* That would eliminate the need for the placeholder.<br></p><p>I don&#39;t think I&#39;ve seen a compelling case for embedding the &quot;...&quot; *within*<br>a list of custom arguments, like:<br></p><p>memberwise init(anInt: Int, ..., anotherInt: Int) {<br>  /* code using anInt and anotherInt */<br>}<br></p><p><br>It&#39;s been mentioned several times in the discussion of this proposal that<br>this behavior is purely optional. If it turns out that there are rare cases<br>where placing the memberwise params in the middle is useful, authors can<br>use manual initialization.<br></p><p><br>On Wed, Jan 6, 2016 at 2:47 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs<br>&gt; through January 10th. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br></p><p>*Alex Johnson | Engineering Lead*<br></p><p>*Quick Left, Inc. &lt;https://quickleft.com/&gt;*<br>*Boulder **|* *Denver* *|* *Portland** |** San Francisco*<br></p><p>1 (844) QL-NERDS<br></p><p>@nonsensery<br></p><p><br>&lt;https://github.com/quickleft&gt; &lt;https://www.facebook.com/quickleft&gt;<br>&lt;https://twitter.com/quickleft&gt; &lt;https://instagram.com/quick_left/&gt;<br>&lt;https://www.flickr.com/photos/quickleft&gt; &lt;https://vimeo.com/quickleft&gt;<br></p><p><br>*What&#39;s it like to work with us? **TrainingPeaks, iTriage, and Ping<br>Identity share their stories in this short video** A Client&#39;s View<br>&lt;https://vimeo.com/92286352&gt;*.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/87d8a775/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 5:26 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (this is mostly a repost of a message I sent to the &quot;[draft]&quot; thread for this proposal, with some light editing to better match terminology in the proposal)<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I like this proposal. I think it will bring some much-needed ease-of-use.<br>&gt; <br>&gt; I have reservations about the &quot;...&quot; placeholder for the memberwise initialization parameters, though. I know this was suggested by Chris Lattner, so I&#39;m inclined to defer to his judgement. But, here are my thoughts:<br>&gt; <br>&gt; First, it&#39;s very close to the varags syntax (e.g. &quot;Int...&quot;) which can also appear in initializer parameter lists.<br>&gt; <br>&gt; Second, and I think more important, I&#39;m not sure that it&#39;s all that useful. It&#39;s presence isn&#39;t necessary for triggering memberwise initialization synthesis; that is already done by the &quot;memberwise&quot; keyword.<br>&gt; <br>&gt; The primary example given in the proposal is:<br>&gt; <br>&gt; memberwise init(anInt: Int, anotherInt: Int, ...) {<br>&gt;   /* code using anInt and anotherInt */<br>&gt; }<br>&gt; <br>&gt; That is, it&#39;s used to indicate where the synthesized parameters appear in the parameter list if there are also custom (non-memberwise) parameters.<br>&gt; <br>&gt; My question is, could the memberwise initialization parameters always be last? That would eliminate the need for the placeholder.<br>&gt; <br>&gt; I don&#39;t think I&#39;ve seen a compelling case for embedding the &quot;...&quot; within a list of custom arguments, like:<br>&gt; <br>&gt; memberwise init(anInt: Int, ..., anotherInt: Int) {<br>&gt;   /* code using anInt and anotherInt */<br>&gt; }<br>&gt; <br>&gt; It&#39;s been mentioned several times in the discussion of this proposal that this behavior is purely optional. If it turns out that there are rare cases where placing the memberwise params in the middle is useful, authors can use manual initialization.<br></p><p>Hi Alex, thanks for your review.  <br></p><p>The initial draft of the proposal did exactly what you suggest - it did not include the placeholder and always placed the memberwise parameters last.  Personally, I believe the placeholder adds clarity and really liked the idea when Chris suggested it.  <br></p><p>Aside from personal preference, I like that this proposal introduces a “synthesized parameter placeholder” syntax.  Similar syntax will also be used in the parameter forwarding proposal mentioned in the future enhancements section of this proposal.<br></p><p>I think the `…` works really well.  That said, I don’t mind if people wish to bikeshed on it.  If that discussion starts it is worth noting that one thing I like about the `…` is that it combines with an identifier cleanly.  For example : `…memberwise`.  <br></p><p>Combining the placeholder with an identifier allows more than one placeholder to be used in the same parameter list.  For example, if you are forwarding memberwise parameters exposed by a super init you might also have `…super`.  <br></p><p>That said, I don’t want the review thread to get distracted with discussions around general parameter forwarding so please just consider this as a preview of how this syntax might scale to future applications.  For now, lets keep this thread focused on the review of the current proposal.  :)<br></p><p>Matthew<br></p><p>&gt; <br>&gt; <br>&gt; On Wed, Jan 6, 2016 at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; <br>&gt; Alex Johnson | Engineering Lead<br>&gt; <br>&gt; Quick Left, Inc. &lt;https://quickleft.com/&gt;<br>&gt; Boulder | Denver | Portland | San Francisco<br>&gt; 1 (844) QL-NERDS<br>&gt; @nonsensery<br>&gt; <br>&gt;  &lt;https://github.com/quickleft&gt; &lt;https://www.facebook.com/quickleft&gt; &lt;https://twitter.com/quickleft&gt; &lt;https://instagram.com/quick_left/&gt; &lt;https://www.flickr.com/photos/quickleft&gt; &lt;https://vimeo.com/quickleft&gt;<br>&gt; <br>&gt;  &lt;&gt;<br>&gt; What&#39;s it like to work with us? TrainingPeaks, iTriage, and Ping Identity share their stories in this short video A Client&#39;s View &lt;https://vimeo.com/92286352&gt;.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/1563d424/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/214d1bb1587020b60ef37c85b887562e?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Alex Johnson</string> &lt;ajohnson at quickleft.com&gt;<p>January  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Matthew,<br></p><p>Thanks for the explanation.<br></p><p>Before getting into a deeper discussion, I&#39;d like to try to enumerate the<br>reasons for adding the placeholder as I understand them:<br></p><p>   1. Add clarity by visually distinguishing memberwise initializers from<br>   normal initializers.<br>   2. Introduce a &quot;synthesized parameters placeholder&quot; syntax that might be<br>   useful in other places.<br>   3. Allow some control over where the synthesized memberwise parameters<br>   end up in the initializer signature.<br></p><p>Does that seem accurate?<br></p><p>~ Alex<br></p><p><br>On Wed, Jan 6, 2016 at 3:48 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 6, 2016, at 5:26 PM, Alex Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; (this is mostly a repost of a message I sent to the &quot;[draft]&quot; thread for<br>&gt; this proposal, with some light editing to better match terminology in the<br>&gt; proposal)<br>&gt;<br>&gt; *What is your evaluation of the proposal?*<br>&gt;<br>&gt; I like this proposal. I think it will bring some much-needed ease-of-use.<br>&gt;<br>&gt; I have reservations about the &quot;...&quot; placeholder for the memberwise<br>&gt; initialization parameters, though. I know this was suggested by<br>&gt; Chris Lattner, so I&#39;m inclined to defer to his judgement. But, here are my<br>&gt; thoughts:<br>&gt;<br>&gt; First, it&#39;s very close to the varags syntax (e.g. &quot;Int...&quot;) which can<br>&gt; also appear in initializer parameter lists.<br>&gt;<br>&gt;<br>&gt; Second, and I think more important, I&#39;m not sure that it&#39;s all that<br>&gt; *useful*. It&#39;s presence isn&#39;t necessary for triggering memberwise<br>&gt; initialization synthesis; that is already done by the &quot;memberwise&quot; keyword.<br>&gt;<br>&gt; The primary example given in the proposal is:<br>&gt;<br>&gt; memberwise init(anInt: Int, anotherInt: Int, ...) {<br>&gt;<br>&gt;   /* code using anInt and anotherInt */<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; That is, it&#39;s used to indicate where the synthesized parameters appear in<br>&gt; the parameter list if there are also custom (non-memberwise) parameters.<br>&gt;<br>&gt; My question is, *could the memberwise initialization parameters always be<br>&gt; last?* That would eliminate the need for the placeholder.<br>&gt;<br>&gt; I don&#39;t think I&#39;ve seen a compelling case for embedding the &quot;...&quot; *within*<br>&gt; a list of custom arguments, like:<br>&gt;<br>&gt; memberwise init(anInt: Int, ..., anotherInt: Int) {<br>&gt;   /* code using anInt and anotherInt */<br>&gt; }<br>&gt;<br>&gt;<br>&gt; It&#39;s been mentioned several times in the discussion of this proposal that<br>&gt; this behavior is purely optional. If it turns out that there are rare cases<br>&gt; where placing the memberwise params in the middle is useful, authors can<br>&gt; use manual initialization.<br>&gt;<br>&gt;<br>&gt; Hi Alex, thanks for your review.<br>&gt;<br>&gt; The initial draft of the proposal did exactly what you suggest - it did<br>&gt; not include the placeholder and always placed the memberwise parameters<br>&gt; last.  Personally, I believe the placeholder adds clarity and really liked<br>&gt; the idea when Chris suggested it.<br>&gt;<br>&gt; Aside from personal preference, I like that this proposal introduces a<br>&gt; “synthesized parameter placeholder” syntax.  Similar syntax will also be<br>&gt; used in the parameter forwarding proposal mentioned in the future<br>&gt; enhancements section of this proposal.<br>&gt;<br>&gt; I think the `…` works really well.  That said, I don’t mind if people wish<br>&gt; to bikeshed on it.  If that discussion starts it is worth noting that one<br>&gt; thing I like about the `…` is that it combines with an identifier cleanly.<br>&gt; For example : `…memberwise`.<br>&gt;<br>&gt; Combining the placeholder with an identifier allows more than one<br>&gt; placeholder to be used in the same parameter list.  For example, if you are<br>&gt; forwarding memberwise parameters exposed by a super init you might also<br>&gt; have `…super`.<br>&gt;<br>&gt; That said, I don’t want the review thread to get distracted with<br>&gt; discussions around general parameter forwarding so please just consider<br>&gt; this as a preview of how this syntax might scale to future applications.<br>&gt; For now, lets keep this thread focused on the review of the current<br>&gt; proposal.  :)<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 2:47 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs<br>&gt;&gt; through January 10th. The proposal is available here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt;<br>&gt;&gt; What goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt; answer in your review:<br>&gt;&gt;<br>&gt;&gt;         * What is your evaluation of the proposal?<br>&gt;&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt;         * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;         * If you have you used other languages or libraries with a<br>&gt;&gt; similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; *Alex Johnson | Engineering Lead*<br>&gt;<br>&gt; *Quick Left, Inc. &lt;https://quickleft.com/&gt;*<br>&gt; *Boulder **|* *Denver* *|* *Portland** |** San Francisco*<br>&gt; 1 (844) QL-NERDS<br>&gt; @nonsensery<br>&gt;<br>&gt; &lt;https://github.com/quickleft&gt; &lt;https://www.facebook.com/quickleft&gt;<br>&gt; &lt;https://twitter.com/quickleft&gt; &lt;https://instagram.com/quick_left/&gt;<br>&gt; &lt;https://www.flickr.com/photos/quickleft&gt; &lt;https://vimeo.com/quickleft&gt;<br>&gt;<br>&gt; *What&#39;s it like to work with us? **TrainingPeaks, iTriage, and Ping<br>&gt; Identity share their stories in this short video** A Client&#39;s View<br>&gt; &lt;https://vimeo.com/92286352&gt;*.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/3930321b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>I think it will greatly help out in more cases where it was not able to do so and will give you more control over it. One concern is that it may make the language more complex, now users need to know what the “memberwise” keyword means, fortunately it will be easily searched. <br></p><p>	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. <br>	* Does this proposal fit well with the feel and direction of Swift?<br>Yes<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Not Applicable. <br></p><p>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read proposal and followed some of the discussion but not all.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>It’s okay.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The proposal is more elegant than how you’d do this in Python, but on the other hand the mechanisms you’d use in Python are not single-purpose language features directed at memberwise initialization; they definitely pay their way because they can be used for much more.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A glance, admittedly.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Meta: most reviews have the review dates in the Status field of their document, this one doesn&#39;t. I was a little confused at first.<br></p><p>For the proposal itself:<br></p><p># What is your evaluation of the proposal?<br></p><p>+1<br></p><p># Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, I write a lot of code just to initialize code. This will probably make some of that code clearer.<br></p><p># Does this proposal fit well with the feel and direction of Swift?<br></p><p>Probably?<br></p><p># If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I frequently write C++ and Python and neither of them have it. This is especially annoying for short programs.<br></p><p># C# has an initializer syntax that allows you to assign properties at creation time, and it is handy:<br></p><p>&gt; Foo foo = new Foo() {<br>&gt; 	Bar = &quot;bar&quot;,<br>&gt; 	Baz = 1,<br>&gt; };<br></p><p>However, this pattern wouldn&#39;t be of much help in Swift, where most types don&#39;t have a reasonable default value.<br></p><p># How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I followed the first week and a half of the proposal.<br></p><p>With all this said, I am confused with the way the proposal is written. The Proposed Solution section talks about opt-in memberwise initialization with the memberwise modifier on properties, but it is listed as a future direction and the Detailed Design makes no mention of it. I would like to be clear that my current appreciation of the proposal only extends to the Detailed Design, and not necessarily to the future directions.<br></p><p>Félix<br></p><p>&gt; Le 6 janv. 2016 à 19:04:41, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; It’s okay.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; The proposal is more elegant than how you’d do this in Python, but on the other hand the mechanisms you’d use in Python are not single-purpose language features directed at memberwise initialization; they definitely pay their way because they can be used for much more.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A glance, admittedly.<br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/8c9a7fd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 6:39 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Meta: most reviews have the review dates in the Status field of their document, this one doesn&#39;t. I was a little confused at first.<br>&gt; <br>&gt; For the proposal itself:<br>&gt; <br>&gt; # What is your evaluation of the proposal?<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; # Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, I write a lot of code just to initialize code. This will probably make some of that code clearer.<br>&gt; <br>&gt; # Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Probably?<br>&gt; <br>&gt; # If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I frequently write C++ and Python and neither of them have it. This is especially annoying for short programs.<br>&gt; <br>&gt; # C# has an initializer syntax that allows you to assign properties at creation time, and it is handy:<br>&gt; <br>&gt;&gt; Foo foo = new Foo() {<br>&gt;&gt; 	Bar = &quot;bar&quot;,<br>&gt;&gt; 	Baz = 1,<br>&gt;&gt; };<br>&gt; <br>&gt; However, this pattern wouldn&#39;t be of much help in Swift, where most types don&#39;t have a reasonable default value.<br>&gt; <br>&gt; # How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I followed the first week and a half of the proposal.<br>&gt; <br>&gt; With all this said, I am confused with the way the proposal is written. The Proposed Solution section talks about opt-in memberwise initialization with the memberwise modifier on properties, but it is listed as a future direction and the Detailed Design makes no mention of it. I would like to be clear that my current appreciation of the proposal only extends to the Detailed Design, and not necessarily to the future directions.<br></p><p>Felix, I apologize if this was confusing.  The decision of the “automatic” vs “opt-in” model for property eligibility is one that I feel is very important.  That is why I mentioned the tradeoff in the Proposed Solution section.  <br></p><p>The opt-in model is not part of the current proposal.  The Detailed Design describes exactly how the current proposal will work.  I appreciate your support of that!<br></p><p>The future enhancements are included to give an idea of some directions in which memberwise initialization could evolve.  I feel strongly about two aspects of these enhancements:<br></p><p>1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>2. It would be really nice to have a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 6 janv. 2016 à 19:04:41, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-&gt;initialization.md	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; It’s okay.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; The proposal is more elegant than how you’d do this in Python, but on the other hand the mechanisms you’d use in Python are not single-purpose language features directed at memberwise initialization; they definitely pay their way because they can be used for much more.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; A glance, admittedly.<br>&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/6d9caf3d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; It’s okay.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br></p><p>It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br></p><p>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; The proposal is more elegant than how you’d do this in Python, but on the other hand the mechanisms you’d use in Python are not single-purpose language features directed at memberwise initialization; they definitely pay their way because they can be used for much more.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A glance, admittedly.<br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; It’s okay.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt; <br>&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br></p><p>Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br></p><p>struct Foo {<br>  var x, y: Int<br></p><p>  // Implicit members<br>  typealias Members = (x: Int, y: Int)<br>  var members: Members {<br>    get { return (x: x, y: y) }<br>    set { (x, y) = newValue }<br>  }<br>}<br></p><p>With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br></p><p>	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>	    // like &#39;**x&#39; in Python<br>init(members...: Members) {<br>  self.members = members<br>}<br></p><p>And I think all your other use cases could be covered as well.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/6d269fd9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 6, 2016, at 7:47 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt; <br>&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt; <br>&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt; <br>&gt; struct Foo {<br>&gt;   var x, y: Int<br>&gt; <br>&gt;   // Implicit members<br>&gt;   typealias Members = (x: Int, y: Int)<br>&gt;   var members: Members {<br>&gt;     get { return (x: x, y: y) }<br>&gt;     set { (x, y) = newValue }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt; <br>&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt; 	    // like &#39;**x&#39; in Python<br>&gt; init(members...: Members) {<br>&gt;   self.members = members<br>&gt; }<br>&gt; <br>&gt; And I think all your other use cases could be covered as well.<br></p><p>Thanks for posting an example.  This makes sense and is definitely an interesting approach.  <br></p><p>Would you be able to use the members property in phase 1 of initialization to initialize those members?  Is part of the magic that the compiler understands enough about that property and tuple to allow for that?<br></p><p>How would use cases involving a subset of members be handled?  This is the primary use case I have had in mind while developing this proposal.<br></p><p>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/bca9d272/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt; <br>&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt; <br>&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt; <br>&gt; struct Foo {<br>&gt;   var x, y: Int<br>&gt; <br>&gt;   // Implicit members<br>&gt;   typealias Members = (x: Int, y: Int)<br>&gt;   var members: Members {<br>&gt;     get { return (x: x, y: y) }<br>&gt;     set { (x, y) = newValue }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt; <br>&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt; 	    // like &#39;**x&#39; in Python<br>&gt; init(members...: Members) {<br>&gt;   self.members = members<br>&gt; }<br>&gt; <br>&gt; And I think all your other use cases could be covered as well.<br></p><p>That&#39;s exactly what I had in mind. Thanks, Joe!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/3f3ddf79/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 6, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my moss-covered three-handled family gradunza<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt;&gt; <br>&gt;&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   var x, y: Int<br>&gt;&gt; <br>&gt;&gt;   // Implicit members<br>&gt;&gt;   typealias Members = (x: Int, y: Int)<br>&gt;&gt;   var members: Members {<br>&gt;&gt;     get { return (x: x, y: y) }<br>&gt;&gt;     set { (x, y) = newValue }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt;&gt; <br>&gt;&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt;&gt; 	    // like &#39;**x&#39; in Python<br>&gt;&gt; init(members...: Members) {<br>&gt;&gt;   self.members = members<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And I think all your other use cases could be covered as well.<br>&gt; <br>&gt; That&#39;s exactly what I had in mind. Thanks, Joe!<br></p><p>Is there any chance of generic variadics along these lines being part of Swift 3?  Or is this down the road further?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/f5cc02af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  7, 2016 at 08:00:00am</p></header><div class="content"><p>The latter I&#39;m afraid. <br></p><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Jan 6, 2016, at 7:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md	<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;   var x, y: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Implicit members<br>&gt;&gt;&gt;   typealias Members = (x: Int, y: Int)<br>&gt;&gt;&gt;   var members: Members {<br>&gt;&gt;&gt;     get { return (x: x, y: y) }<br>&gt;&gt;&gt;     set { (x, y) = newValue }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt;&gt;&gt; 	    // like &#39;**x&#39; in Python<br>&gt;&gt;&gt; init(members...: Members) {<br>&gt;&gt;&gt;   self.members = members<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And I think all your other use cases could be covered as well.<br>&gt;&gt; <br>&gt;&gt; That&#39;s exactly what I had in mind. Thanks, Joe!<br>&gt; <br>&gt; Is there any chance of generic variadics along these lines being part of Swift 3?  Or is this down the road further?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/f50646fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; The latter I&#39;m afraid. <br></p><p>I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br></p><p>-Joe<br></p><p>&gt; Sent from my moss-covered three-handled family gradunza<br>&gt; <br>&gt; On Jan 6, 2016, at 7:12 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;   var x, y: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // Implicit members<br>&gt;&gt;&gt;&gt;   typealias Members = (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;   var members: Members {<br>&gt;&gt;&gt;&gt;     get { return (x: x, y: y) }<br>&gt;&gt;&gt;&gt;     set { (x, y) = newValue }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt;&gt;&gt;&gt; 	    // like &#39;**x&#39; in Python<br>&gt;&gt;&gt;&gt; init(members...: Members) {<br>&gt;&gt;&gt;&gt;   self.members = members<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And I think all your other use cases could be covered as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s exactly what I had in mind. Thanks, Joe!<br>&gt;&gt; <br>&gt;&gt; Is there any chance of generic variadics along these lines being part of Swift 3?  Or is this down the road further?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/75ba9dad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The latter I&#39;m afraid. <br>&gt; <br>&gt; I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br></p><p>I don’t mind discussing an alternative using this approach.  If we’re going to do that I think it must be clear how it would cover various intended use cases in detail.  Specifically, how would we address:<br></p><p>1. Default parameter values (at least for `var` properties)<br>2. `let` properties: it seems pretty magical indeed if the computed `var` property exposing the tuple could be used to initialize a `let` property.<br>3. Partial memberwise initialization exposing a subset of members following some kind of “automatic” or “opt-in” model for determining the subset.<br></p><p>Is it correct to assume that part of the magic is an understanding of the magic properties that allows them to be used to initialize the properties corresponding to the tuple members?<br></p><p>One thing I think is worth considering is that there is magic required no matter what approach we adopt.  The primary advantage of this approach seems to be that the magic / implicit properties might sometimes be useful outside of an initialization context.  There could be other advantages depending on the details of what this approach looks like but its hard to tell without more specifics.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 7:12 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   var x, y: Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // Implicit members<br>&gt;&gt;&gt;&gt;&gt;   typealias Members = (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt;   var members: Members {<br>&gt;&gt;&gt;&gt;&gt;     get { return (x: x, y: y) }<br>&gt;&gt;&gt;&gt;&gt;     set { (x, y) = newValue }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt;&gt;&gt;&gt;&gt; 	    // like &#39;**x&#39; in Python<br>&gt;&gt;&gt;&gt;&gt; init(members...: Members) {<br>&gt;&gt;&gt;&gt;&gt;   self.members = members<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And I think all your other use cases could be covered as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s exactly what I had in mind. Thanks, Joe!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any chance of generic variadics along these lines being part of Swift 3?  Or is this down the road further?<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/7deabe78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:03 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter I&#39;m afraid. <br>&gt;&gt; <br>&gt;&gt; I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br>&gt; <br>&gt; I don’t mind discussing an alternative using this approach.  If we’re going to do that I think it must be clear how it would cover various intended use cases in detail.  Specifically, how would we address:<br>&gt; <br>&gt; 1. Default parameter values (at least for `var` properties)<br>&gt; 2. `let` properties: it seems pretty magical indeed if the computed `var` property exposing the tuple could be used to initialize a `let` property.<br></p><p>Yeah, this member would need special initialization abilities, I agree.<br></p><p>&gt; 3. Partial memberwise initialization exposing a subset of members following some kind of “automatic” or “opt-in” model for determining the subset.<br></p><p>Seems to me that could be done by factoring the interesting subsets into structs, e.g.:<br></p><p>class Foo {<br>  internal struct MemberwiseProperties {<br>    var x,y,z: Int<br>  }<br>  internal var state: MemberwiseProperties<br></p><p>  init(members...: MemberwiseProperties.Members) {<br>    state.members = members<br>  }<br>}<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Is it correct to assume that part of the magic is an understanding of the magic properties that allows them to be used to initialize the properties corresponding to the tuple members?<br>&gt; <br>&gt; One thing I think is worth considering is that there is magic required no matter what approach we adopt.  The primary advantage of this approach seems to be that the magic / implicit properties might sometimes be useful outside of an initialization context.  There could be other advantages depending on the details of what this approach looks like but its hard to tell without more specifics.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 7:12 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var x, y: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   // Implicit members<br>&gt;&gt;&gt;&gt;&gt;&gt;   typealias Members = (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;   var members: Members {<br>&gt;&gt;&gt;&gt;&gt;&gt;     get { return (x: x, y: y) }<br>&gt;&gt;&gt;&gt;&gt;&gt;     set { (x, y) = newValue }<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt;&gt;&gt;&gt;&gt;&gt; 	    // like &#39;**x&#39; in Python<br>&gt;&gt;&gt;&gt;&gt;&gt; init(members...: Members) {<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.members = members<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And I think all your other use cases could be covered as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what I had in mind. Thanks, Joe!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there any chance of generic variadics along these lines being part of Swift 3?  Or is this down the road further?<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/578a1a4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The latter I&#39;m afraid. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br>&gt;&gt; <br>&gt;&gt; I don’t mind discussing an alternative using this approach.  If we’re going to do that I think it must be clear how it would cover various intended use cases in detail.  Specifically, how would we address:<br>&gt;&gt; <br>&gt;&gt; 1. Default parameter values (at least for `var` properties)<br>&gt;&gt; 2. `let` properties: it seems pretty magical indeed if the computed `var` property exposing the tuple could be used to initialize a `let` property.<br>&gt; <br>&gt; Yeah, this member would need special initialization abilities, I agree.<br></p><p>It seems odd that this would be deemed acceptable.  Would the `members` member be usable outside of an initializer?  It seems like that wouldn’t be possible if there were a `let` property.  But it also seems weird if its availability was determined by whether you have a `let` property or not.<br></p><p>&gt; <br>&gt;&gt; 3. Partial memberwise initialization exposing a subset of members following some kind of “automatic” or “opt-in” model for determining the subset.<br>&gt; <br>&gt; Seems to me that could be done by factoring the interesting subsets into structs, e.g.:<br>&gt; <br>&gt; class Foo {<br>&gt;   internal struct MemberwiseProperties {<br>&gt;     var x,y,z: Int<br>&gt;   }<br>&gt;   internal var state: MemberwiseProperties<br>&gt; <br>&gt;   init(members...: MemberwiseProperties.Members) {<br>&gt;     state.members = members<br>&gt;   }<br>&gt; }<br></p><p>Sure you could do that, but it doesn’t seem like an acceptable alternative to me.  Now the members must be prefixed with an identifier everywhere they are used.  I don’t see why this is acceptable when requiring `self` is not.<br></p><p>Are there compelling reasons to go down this road rather than the current proposal?  What use cases does it address that the current proposal does not?<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Is it correct to assume that part of the magic is an understanding of the magic properties that allows them to be used to initialize the properties corresponding to the tuple members?<br>&gt;&gt; <br>&gt;&gt; One thing I think is worth considering is that there is magic required no matter what approach we adopt.  The primary advantage of this approach seems to be that the magic / implicit properties might sometimes be useful outside of an initialization context.  There could be other advantages depending on the details of what this approach looks like but its hard to tell without more specifics.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 7:12 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 8:46 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my moss-covered three-handled family gradunza<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 6:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s okay.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m lukewarm about that.  I have never found writing out the initializers I want to be a significant burden, and I find my code is better when they’re explicit.  Every new feature increases the language&#39;s complexity and surface area, and I fear this one is not going to pay its way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but I worry that it may be too early to add it.  Other features in this space, like truly generic variadics, may well obsolete anything we do today.  I’m not sure we should be designing convenience features that are likely to overlap with more general features coming down the road unless the inconvenience is very painful… which I personally don’t find it to be.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It isn’t clear to me how generic variadics might obsolete the functionality of this proposal.  Can you elaborate on that?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not sure if this is exactly what Dave has in mind, but an idea that comes to mind: we could say that structs and classes have a magic &quot;members&quot; tuple and typealias:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var x, y: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   // Implicit members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   typealias Members = (x: Int, y: Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var members: Members {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     get { return (x: x, y: y) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     set { (x, y) = newValue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With plausible future features for forwarding tuples as arguments, then the memberwise initializer could be implemented like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    // Say that a parameter declared &#39;x...&#39; receives a tuple of arguments labeled according to its type,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    // like &#39;**x&#39; in Python<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; init(members...: Members) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   self.members = members<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And I think all your other use cases could be covered as well.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what I had in mind. Thanks, Joe!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there any chance of generic variadics along these lines being part of Swift 3?  Or is this down the road further?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/cef929e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 12:14 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 10:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The latter I&#39;m afraid. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t mind discussing an alternative using this approach.  If we’re going to do that I think it must be clear how it would cover various intended use cases in detail.  Specifically, how would we address:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Default parameter values (at least for `var` properties)<br>&gt;&gt;&gt; 2. `let` properties: it seems pretty magical indeed if the computed `var` property exposing the tuple could be used to initialize a `let` property.<br>&gt;&gt; <br>&gt;&gt; Yeah, this member would need special initialization abilities, I agree.<br>&gt; <br>&gt; It seems odd that this would be deemed acceptable.  Would the `members` member be usable outside of an initializer?  It seems like that wouldn’t be possible if there were a `let` property.  But it also seems weird if its availability was determined by whether you have a `let` property or not.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 3. Partial memberwise initialization exposing a subset of members following some kind of “automatic” or “opt-in” model for determining the subset.<br>&gt;&gt; <br>&gt;&gt; Seems to me that could be done by factoring the interesting subsets into structs, e.g.:<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt;   internal struct MemberwiseProperties {<br>&gt;&gt;     var x,y,z: Int<br>&gt;&gt;   }<br>&gt;&gt;   internal var state: MemberwiseProperties<br>&gt;&gt; <br>&gt;&gt;   init(members...: MemberwiseProperties.Members) {<br>&gt;&gt;     state.members = members<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Sure you could do that, but it doesn’t seem like an acceptable alternative to me.  Now the members must be prefixed with an identifier everywhere they are used.  I don’t see why this is acceptable when requiring `self` is not.<br></p><p>That&#39;s a tradeoff, yes.<br></p><p>&gt; Are there compelling reasons to go down this road rather than the current proposal?  What use cases does it address that the current proposal does not?<br></p><p>I find this approach interesting because it enables the easy implementation of at least most memberwise initializers, using more generally useful language features I think we are going to eventually want for argument forwarding and compile-time metaprogramming anyway. If we had already had these features, would you still have been compelled to write your proposal?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/958587c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:28 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:22 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 12:14 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The latter I&#39;m afraid. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t mind discussing an alternative using this approach.  If we’re going to do that I think it must be clear how it would cover various intended use cases in detail.  Specifically, how would we address:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Default parameter values (at least for `var` properties)<br>&gt;&gt;&gt;&gt; 2. `let` properties: it seems pretty magical indeed if the computed `var` property exposing the tuple could be used to initialize a `let` property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, this member would need special initialization abilities, I agree.<br>&gt;&gt; <br>&gt;&gt; It seems odd that this would be deemed acceptable.  Would the `members` member be usable outside of an initializer?  It seems like that wouldn’t be possible if there were a `let` property.  But it also seems weird if its availability was determined by whether you have a `let` property or not.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Partial memberwise initialization exposing a subset of members following some kind of “automatic” or “opt-in” model for determining the subset.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems to me that could be done by factoring the interesting subsets into structs, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;   internal struct MemberwiseProperties {<br>&gt;&gt;&gt;     var x,y,z: Int<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   internal var state: MemberwiseProperties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init(members...: MemberwiseProperties.Members) {<br>&gt;&gt;&gt;     state.members = members<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Sure you could do that, but it doesn’t seem like an acceptable alternative to me.  Now the members must be prefixed with an identifier everywhere they are used.  I don’t see why this is acceptable when requiring `self` is not.<br>&gt; <br>&gt; That&#39;s a tradeoff, yes.<br>&gt; <br>&gt;&gt; Are there compelling reasons to go down this road rather than the current proposal?  What use cases does it address that the current proposal does not?<br>&gt; <br>&gt; I find this approach interesting because it enables the easy implementation of at least most memberwise initializers, using more generally useful language features I think we are going to eventually want for argument forwarding and compile-time metaprogramming anyway. If we had already had these features, would you still have been compelled to write your proposal?<br></p><p>If the general features were truly able to handle this on their own maybe not.  But they don’t.  <br></p><p>This approach requires the magic property or properties with unusual behavior in order to work.  I don’t think the approach you suggested for partial memberwise initialization is sufficient and even more magic would be required if we wanted to address that.<br></p><p>I am still not sure how default parameter values would be handled so I can’t evaluate that.  Do you have an idea of how that might be handled?<br></p><p>I understand the desire to rely on more general features, but I think at least as much magic would be required and I am not convinced that the solution would be a better one.  The primary difference seems to be the fact that the magic isn’t visible in the surface syntax.  But that is somewhat illusory, the magic would still exist.<br></p><p>Matthew<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/3b655ab4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; using more generally useful language features I think we are going to eventually want for argument forwarding and compile-time metaprogramming anyway.<br>So how about just delaying everything for a while?<br>Imho there is no need to change the init-syntax overhasty, and afaics, this is a huge piece of work compared to other proposals.<br>It is much easier to use a little script that turns<br></p><p>let value: Int//=42<br>var x: Float?//!<br></p><p>into<br></p><p>let value: Int//=42<br>var x: Float?//!<br></p><p>init(value: Int = 42, x: Float) {<br>	self.value = value<br>	self.x = x<br>}<br></p><p>Nothing else can be as flexible and easy to understand at the same time, and the language itself can stay as it is until a convincing solution emerges.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/41dd90e8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:28, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Are there compelling reasons to go down this road rather than the current proposal?  What use cases does it address that the current proposal does not?<br>&gt; <br>&gt; I find this approach interesting because it enables the easy implementation of at least most memberwise initializers, using more generally useful language features I think we are going to eventually want for argument forwarding and compile-time metaprogramming anyway. If we had already had these features, would you still have been compelled to write your proposal?<br>&gt; <br>&gt; -Joe<br></p><p>I appreciate the thought that went into this memberwise-init proposal, and I’m in favor of eliminating boilerplate.  However, the possibility that this functionality maybe addressed by generics, even if it’s only 75% addressed, makes me want to revisit this topic after generics are further along.<br></p><p>Matt<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/10789fb3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:14 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 8:28 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The latter I&#39;m afraid. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was just discussing this design space with Chris Willmore, who&#39;s been working on revamping how our function type model works. If we move to a multiple-argument model for functions rather than the current every-function-takes-a-tuple-argument model, then we will likely need at least limited support for packing and unpacking tuples from and to arguments in order to avoid regressing at argument forwarding use cases. However, even that limited packing/unpacking functionality might be enough to seriously consider a more general magic &quot;members&quot; property as an alternative.<br>&gt;&gt; <br>&gt;&gt; I don’t mind discussing an alternative using this approach.  If we’re going to do that I think it must be clear how it would cover various intended use cases in detail.  Specifically, how would we address:<br>&gt;&gt; <br>&gt;&gt; 1. Default parameter values (at least for `var` properties)<br>&gt;&gt; 2. `let` properties: it seems pretty magical indeed if the computed `var` property exposing the tuple could be used to initialize a `let` property.<br>&gt; <br>&gt; Yeah, this member would need special initialization abilities, I agree.<br>&gt; <br>&gt;&gt; 3. Partial memberwise initialization exposing a subset of members following some kind of “automatic” or “opt-in” model for determining the subset.<br>&gt; <br>&gt; Seems to me that could be done by factoring the interesting subsets into structs, e.g.:<br>&gt; <br>&gt; class Foo {<br>&gt;   internal struct MemberwiseProperties {<br>&gt;     var x,y,z: Int<br>&gt;   }<br>&gt;   internal var state: MemberwiseProperties<br>&gt; <br>&gt;   init(members...: MemberwiseProperties.Members) {<br>&gt;     state.members = members<br>&gt;   }<br>&gt; }<br></p><p>And this is more clear than this?<br></p><p>class Foo {<br>  var x,y,z: Int<br>  init(x: Int, y: Int, z: Int) {<br>    self.x = x<br>    self.y = y<br>    self.z = z<br>  }<br>}<br></p><p>It seems odd to me to change the design of your type for the sole purpose of using a language feature. <br></p><p>It’s the complexity of the feature and its applicability only to initialization that lead me to vote no for the proposal. I&#39;ve wanted public, generated initializers (ask to the internal generated struct inits). However, as you dig into to see what you really need to support, the complexities become quite nuanced.<br></p><p>I keep coming back to a much simpler and more explicit desire of being able to use “self” (this is not a label, but an annotation like &quot;inout&quot;) in the parameter list. This is applicable to all members of a type.<br></p><p>class Foo {<br>  var x,y,z: Int<br>  init(self x: Int, self y: Int, self z: Int) {<br>    // the compiler auto-inserts these lines<br>    self.x = x<br>    self.y = y<br>    self.z = z<br>  }<br></p><p>  func fooey(self x: Int) {<br>    // the compiler generates<br>    self.x = x<br>  }<br>}<br></p><p>I’m not convinced that even that is worth the magic it brings to the table, but it does get rid of nearly all of the complexities, becomes more applicable than just initialization, and has only a single rule to learn that is fairly self-explanatory. The trade-off is you must be explicit about the members of the initializer. I’m OK with that because if I have a type that really has so many members that this is a burden, then I should probably refactor it. A sufficient macro system also trivially solves this issue as well.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/169f2c62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; And this is more clear than this?<br>&gt; <br>&gt; class Foo {<br>&gt;   var x,y,z: Int<br>&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;     self.x = x<br>&gt;     self.y = y<br>&gt;     self.z = z<br>&gt;   }<br>&gt; }<br></p><p>No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/dfbbff79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And this is more clear than this?<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt;   var x,y,z: Int<br>&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;     self.x = x<br>&gt;&gt;     self.y = y<br>&gt;&gt;     self.z = z<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br></p><p>Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/ec4f993a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt; <br>&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br></p><p>Do you have any concrete examples in mind?<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/995cfcbe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:51 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt;&gt; <br>&gt;&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br>&gt; <br>&gt; Do you have any concrete examples in mind?<br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>Here is an example where partial memberwise initialization would apply.  It is similar to something in a real project:<br></p><p>public class FontPicker: UIControl {<br>  public let fonts: [UIFont]<br></p><p>  public var fontSize: CGFloat = 22<br>  public var foregroundColor: UIColor = UIColor.darkGrayColor()<br>  public var backgroundColor: UIColor = UIColor.whiteColor()<br>  // A bunch of other appearance attributes here<br></p><p>  private let collectionView: UICollectionView<br>  private let layout: UICollectionViewLayout<br>  // other internal state required by the implementation<br></p><p>  public memberwise init(...) {<br>    // configure the collection view and add it as a subview<br>  }<br>}<br></p><p>A couple points are relevant here:<br></p><p>1. Memberwise initialization is very valuable for the appearance attributes, but is useless if it exposes our implementation details.<br></p><p>2. In many custom UI widgets the appearance attributes don’t really need to be mutable post-initialization.  At the same time, it is necessary to allow, but not require a value to be specified.  It would be ideal if they were `let` properties with a default value, but still able to participate in memberwise initialization.  Without that capability we are forced to choose between the advantages of using a `let` property and the advantages of memberwise initialization.<br></p><p>UI widgets are a great example.  View controllers often have a similar divide between state provided by the user and state related to internal implementation details.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/3ecd9c03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 11:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 12:51 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br>&gt;&gt; <br>&gt;&gt; Do you have any concrete examples in mind?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; Here is an example where partial memberwise initialization would apply.  It is similar to something in a real project:<br>&gt; <br>&gt; public class FontPicker: UIControl {<br>&gt;   public let fonts: [UIFont]<br>&gt; <br>&gt;   public var fontSize: CGFloat = 22<br>&gt;   public var foregroundColor: UIColor = UIColor.darkGrayColor()<br>&gt;   public var backgroundColor: UIColor = UIColor.whiteColor()<br>&gt;   // A bunch of other appearance attributes here<br>&gt; <br>&gt;   private let collectionView: UICollectionView<br>&gt;   private let layout: UICollectionViewLayout<br>&gt;   // other internal state required by the implementation<br>&gt; <br>&gt;   public memberwise init(...) {<br>&gt;     // configure the collection view and add it as a subview<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; A couple points are relevant here:<br>&gt; <br>&gt; 1. Memberwise initialization is very valuable for the appearance attributes, but is useless if it exposes our implementation details.<br>&gt; <br>&gt; 2. In many custom UI widgets the appearance attributes don’t really need to be mutable post-initialization.  At the same time, it is necessary to allow, but not require a value to be specified.  It would be ideal if they were `let` properties with a default value, but still able to participate in memberwise initialization.  Without that capability we are forced to choose between the advantages of using a `let` property and the advantages of memberwise initialization.<br>&gt; <br>&gt; UI widgets are a great example.  View controllers often have a similar divide between state provided by the user and state related to internal implementation details.<br></p><p>Access control seems like a poor tool for the kind of categorization you want here. The vast majority of code is app code, where there&#39;s no reason to use &#39;public&#39;, so &#39;internal&#39; and &#39;private&#39; are the interesting visibility layers. Using &#39;private&#39; to opt fields out of memberwise initialization is too brittle, in my opinion—You&#39;ve made it much harder to factor the class&#39;s functionality into different files in the future, since you can no longer change any of these fields to internal without also breaking all of the memberwise initializers as a second-order effect.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/659b0628/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 8:30 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 11:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 12:51 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you have any concrete examples in mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here is an example where partial memberwise initialization would apply.  It is similar to something in a real project:<br>&gt;&gt; <br>&gt;&gt; public class FontPicker: UIControl {<br>&gt;&gt;   public let fonts: [UIFont]<br>&gt;&gt; <br>&gt;&gt;   public var fontSize: CGFloat = 22<br>&gt;&gt;   public var foregroundColor: UIColor = UIColor.darkGrayColor()<br>&gt;&gt;   public var backgroundColor: UIColor = UIColor.whiteColor()<br>&gt;&gt;   // A bunch of other appearance attributes here<br>&gt;&gt; <br>&gt;&gt;   private let collectionView: UICollectionView<br>&gt;&gt;   private let layout: UICollectionViewLayout<br>&gt;&gt;   // other internal state required by the implementation<br>&gt;&gt; <br>&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;     // configure the collection view and add it as a subview<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A couple points are relevant here:<br>&gt;&gt; <br>&gt;&gt; 1. Memberwise initialization is very valuable for the appearance attributes, but is useless if it exposes our implementation details.<br>&gt;&gt; <br>&gt;&gt; 2. In many custom UI widgets the appearance attributes don’t really need to be mutable post-initialization.  At the same time, it is necessary to allow, but not require a value to be specified.  It would be ideal if they were `let` properties with a default value, but still able to participate in memberwise initialization.  Without that capability we are forced to choose between the advantages of using a `let` property and the advantages of memberwise initialization.<br>&gt;&gt; <br>&gt;&gt; UI widgets are a great example.  View controllers often have a similar divide between state provided by the user and state related to internal implementation details.<br>&gt; <br>&gt; Access control seems like a poor tool for the kind of categorization you want here. The vast majority of code is app code, where there&#39;s no reason to use &#39;public&#39;, so &#39;internal&#39; and &#39;private&#39; are the interesting visibility layers. Using &#39;private&#39; to opt fields out of memberwise initialization is too brittle, in my opinion—You&#39;ve made it much harder to factor the class&#39;s functionality into different files in the future, since you can no longer change any of these fields to internal without also breaking all of the memberwise initializers as a second-order effect.<br></p><p>That is a reasonable position.  In practice it wouldn’t be a problem for projects I’ve worked on, and I suspect others would say the same or may have commented on this already.  But I do understand why you want to avoid the possibility of increasing the visibility of a member breaking code.  <br></p><p>Nevertheless, I feel that access control rules should be applied to memberwise initializers unless we go with the opt-in model where the programmer explicitly states which properties are relevant to memberwise initialization and which are not.  I don’t think exposing more-private members in an more-public initializers without an explicit request to do so is a good idea.  And I don’t think the `memberwise` declaration modifier on the initializer itself is enough to constitute and explicit request to do this.<br></p><p>The safest, most clear, most robust way to determine the correct set of properties to use is to go with the opt-in model.  The downside of that is that it requires a declaration modifier on properties to opt-in.  I am not opposed to going down this path at all, but I believe Chris thinks it would be too verbose for a convenience feature to require that (although he seemed to be comfortable with offering it as an alternative when requested in a specific case by the programmer).<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/49f77541/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 8:30 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 11:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 12:51 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you have any concrete examples in mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here is an example where partial memberwise initialization would apply.  It is similar to something in a real project:<br>&gt;&gt; <br>&gt;&gt; public class FontPicker: UIControl {<br>&gt;&gt;   public let fonts: [UIFont]<br>&gt;&gt; <br>&gt;&gt;   public var fontSize: CGFloat = 22<br>&gt;&gt;   public var foregroundColor: UIColor = UIColor.darkGrayColor()<br>&gt;&gt;   public var backgroundColor: UIColor = UIColor.whiteColor()<br>&gt;&gt;   // A bunch of other appearance attributes here<br>&gt;&gt; <br>&gt;&gt;   private let collectionView: UICollectionView<br>&gt;&gt;   private let layout: UICollectionViewLayout<br>&gt;&gt;   // other internal state required by the implementation<br>&gt;&gt; <br>&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;     // configure the collection view and add it as a subview<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A couple points are relevant here:<br>&gt;&gt; <br>&gt;&gt; 1. Memberwise initialization is very valuable for the appearance attributes, but is useless if it exposes our implementation details.<br>&gt;&gt; <br>&gt;&gt; 2. In many custom UI widgets the appearance attributes don’t really need to be mutable post-initialization.  At the same time, it is necessary to allow, but not require a value to be specified.  It would be ideal if they were `let` properties with a default value, but still able to participate in memberwise initialization.  Without that capability we are forced to choose between the advantages of using a `let` property and the advantages of memberwise initialization.<br>&gt;&gt; <br>&gt;&gt; UI widgets are a great example.  View controllers often have a similar divide between state provided by the user and state related to internal implementation details.<br>&gt; <br>&gt; Access control seems like a poor tool for the kind of categorization you want here. The vast majority of code is app code, where there&#39;s no reason to use &#39;public&#39;, so &#39;internal&#39; and &#39;private&#39; are the interesting visibility layers. Using &#39;private&#39; to opt fields out of memberwise initialization is too brittle, in my opinion—You&#39;ve made it much harder to factor the class&#39;s functionality into different files in the future, since you can no longer change any of these fields to internal without also breaking all of the memberwise initializers as a second-order effect.<br></p><p>One thing I should have mentioned in the reply last night is that the problem of breaking the memberwise initializers when access control changes is solvable.  Several of the possible enhancements are attempts to allow the programmer to be more explicit when the rules don’t do the right thing.  The breakage you describe is an example where that would be necessary.<br></p><p>The solution I believe is the best one (assuming the automatic model) is allowing distinct access control for initialization.  Initialization is conceptually distinct from both getting and setting.  We already allow programmers to specify distinct access levels for `get` and `set` (for `var`), but we don’t for `init`.  It feels like a natural extension of the access control model to allow a distinction for initialization.  The `init` access level could also be used in phase 1 for manually written initializers, rather than the `get` visibility of a `let` property and the `set` visibility of a `var` that is used today.<br></p><p>It would solve the problem problem you mention above by allowing the access control to be specified as `internal private(init)` rather than just `internal`.  This access control change would have no impact on memberwise initializers.<br></p><p>This would also solve the problem you mentioned earlier that `let` properties more capable than `private(set) var` properties.  It would no longer be necessary to use the `set` access level because there would be a distinct access level for `init`.  In that case, the programmer could specify exactly what is desired: <br></p><p>1. `public private(set)` would allow public memberwise initializers to synthesize a parameter for the property<br>2. `private public(get)` would only allow private memberwise initializers to synthesize a parameter for the property.  Only the getter would be visible publicly.<br>3. `public private(init)` would only allow private memberwise initializers to synthesize a parameter for the property. Both the getter and setter would be visible publicly.<br></p><p>Ultimately, I think the automatic model is only a good idea if we enforce access control.  Allowing the distinction to be made solves the problems you have pointed out while also allowing the programmer to get the desired behavior out of the automatic model in most or all cases.  For those reasons I think it would be a significant improvement over the current proposal.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/a943ef32/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b22bad6d88de707d2ae9531c185ff?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;trsfoo at googlemail.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 07.01.2016 um 20:30 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Here is an example where partial memberwise initialization would apply.  It is similar to something in a real project:<br>&gt; <br>&gt; public class FontPicker: UIControl {<br>&gt;   public let fonts: [UIFont]<br>&gt; <br>&gt;   public var fontSize: CGFloat = 22<br>&gt;   public var foregroundColor: UIColor = UIColor.darkGrayColor()<br>&gt;   public var backgroundColor: UIColor = UIColor.whiteColor()<br>&gt;   // A bunch of other appearance attributes here<br>&gt; <br>&gt;   private let collectionView: UICollectionView<br>&gt;   private let layout: UICollectionViewLayout<br>&gt;   // other internal state required by the implementation<br>&gt; <br>&gt;   public memberwise init(...) {<br>&gt;     // configure the collection view and add it as a subview<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; A couple points are relevant here:<br>&gt; <br>&gt; 1. Memberwise initialization is very valuable for the appearance attributes, but is useless if it exposes our implementation details.<br></p><p>The appearance attributes probably won’t change within an app (would be strange to have the FontPicker sometimes have this font size then that, even stranger regarding the colors) but would only be different between different apps, or at least not change alone but in concert with all other UIControls.<br>So wouldn’t it be more appropriate for this example to instead use the existing UIAppearance functionality? Then the memberwise initializer would not really be needed here as configuring the appearance would not be done in the initializer.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/a4fa523e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 3:22 AM, Thorsten Seitz &lt;trsfoo at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 07.01.2016 um 20:30 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Here is an example where partial memberwise initialization would apply.  It is similar to something in a real project:<br>&gt;&gt; <br>&gt;&gt; public class FontPicker: UIControl {<br>&gt;&gt;   public let fonts: [UIFont]<br>&gt;&gt; <br>&gt;&gt;   public var fontSize: CGFloat = 22<br>&gt;&gt;   public var foregroundColor: UIColor = UIColor.darkGrayColor()<br>&gt;&gt;   public var backgroundColor: UIColor = UIColor.whiteColor()<br>&gt;&gt;   // A bunch of other appearance attributes here<br>&gt;&gt; <br>&gt;&gt;   private let collectionView: UICollectionView<br>&gt;&gt;   private let layout: UICollectionViewLayout<br>&gt;&gt;   // other internal state required by the implementation<br>&gt;&gt; <br>&gt;&gt;   public memberwise init(...) {<br>&gt;&gt;     // configure the collection view and add it as a subview<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A couple points are relevant here:<br>&gt;&gt; <br>&gt;&gt; 1. Memberwise initialization is very valuable for the appearance attributes, but is useless if it exposes our implementation details.<br>&gt; <br>&gt; The appearance attributes probably won’t change within an app (would be strange to have the FontPicker sometimes have this font size then that, even stranger regarding the colors) but would only be different between different apps, or at least not change alone but in concert with all other UIControls.<br></p><p>An example of where it would change inside the app is with light and dark appearance modes.  It may also change as the app evolves over time and the programmer might not want to hard code appearance attributes in the UI widget itself.<br></p><p>&gt; So wouldn’t it be more appropriate for this example to instead use the existing UIAppearance functionality? Then the memberwise initializer would not really be needed here as configuring the appearance would not be done in the initializer.<br></p><p>Not everyone likes UIAppearance, especially for custom widgets.  Even if you do, it may not always be the best solution.  Sometimes it is simpler and more clear to provide appearance attributes directly.<br></p><p>Aside from that, this was just an example.  Similar structure often appears in view controllers where the properties that would be memberwise initialized would include data to display, etc.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/bd0f47f2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt; <br>&gt; Maybe you would feel differently if you were an app developer.<br></p><p>And FYI, many of us are or have been app developers in the past, we aren&#39;t (all) ivory tower academic purists here.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/d12412a3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt; <br>&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br>&gt; <br>&gt; Matthew<br></p><p>It’s not a universal truth that the majority of code in an app is UI code, unless you’re specifically talking about really small apps or essentially apps that are views for a server. The UI code to non-UI code ratio in a product like Word (for Mac) is no where near “majority”.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/18df6bd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 1:23 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:49 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 12:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:32 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And this is more clear than this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;   var x,y,z: Int<br>&gt;&gt;&gt;&gt;   init(x: Int, y: Int, z: Int) {<br>&gt;&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;&gt;     self.z = z<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it isn&#39;t, but Matthew asked… I&#39;m personally not too motivated to support anything more than all-or-nothing memberwise initialization, and tend to agree that anything more specialized deserves an explicit implementation.<br>&gt;&gt; <br>&gt;&gt; Maybe you would feel differently if you were an app developer.  Different kinds of code have different needs.  The most important use cases I have in mind are related to UI code, which is often the majority of the code in an app.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt; <br>&gt; It’s not a universal truth that the majority of code in an app is UI code, unless you’re specifically talking about really small apps or essentially apps that are views for a server. The UI code to non-UI code ratio in a product like Word (for Mac) is no where near “majority”.<br></p><p>I did say “often”, not always.  I didn’t make a claim to any universal truth.<br></p><p>Also, by “app” I meant typical consumer mobile apps that make up most of the stuff on the app store aside from games.  I did not mean to refer to software in general.  I could have been more clear about that.<br></p><p>&gt; <br>&gt; -David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/c87a969c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>-1 for me.<br></p><p>&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;	<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I’m unconvinced that the value is warranted for the complexity that is being brought to the table. Couple this with the fact that it’s very easy to accidentally make breaking changes by simply re-ordering your members, adding new ones, or even assigning a default value. I just find it far too fragile.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I don’t think so. <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I suppose. However, it has a lot of impact on the resiliency of APIs, so I’d want to delay this feature until those issues are worked out first. The other concern is there is a lot of magic involved, especially when some of the future enhancements are looked at.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve used tools to do this in past, such as MACROs or snippet-like items. Those seemed to be more useful and less constrained. Also, I make use of Swift’s implicit initializers for structs for internal code. While that is nice, I’ve not been convinced that moving this functionality to public is a good thing.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve been following the iterations and partaking in some of the conversations.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/81377410/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 7:05 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 for me.<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;	<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I’m unconvinced that the value is warranted for the complexity that is being brought to the table. Couple this with the fact that it’s very easy to accidentally make breaking changes by simply re-ordering your members, adding new ones, or even assigning a default value. I just find it far too fragile.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I don’t think so. <br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I suppose. However, it has a lot of impact on the resiliency of APIs, so I’d want to delay this feature until those issues are worked out first. The other concern is there is a lot of magic involved, especially when some of the future enhancements are looked at.<br>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I’ve used tools to do this in past, such as MACROs or snippet-like items. Those seemed to be more useful and less constrained. Also, I make use of Swift’s implicit initializers for structs for internal code. While that is nice, I’ve not been convinced that moving this functionality to public is a good thing.<br></p><p>I know this won’t influence your opinion David, but I want to make it clear to any other readers: this proposal does not introduce any implicit public initializers.  It simply enhances the existing memberwise initializer functionality by allowing more control and making it available to classes as well as structs.<br></p><p>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I’ve been following the iterations and partaking in some of the conversations.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/a6a582f7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I am generally in favor. I enjoy the current memberwise initializer feature and would like to see it become useful in more cases.<br></p><p>One thing I don&#39;t like (and was intending to discuss—the review snuck up on me) is the keyword `memberwise`. This is the name of the current feature, but I don&#39;t think it&#39;s very well-chosen. &quot;Member&quot; refers to all of the things attached to a type: properties, subscripts, methods, initializers, etc. But a &quot;memberwise&quot; initializer only initializes the stored properties, not any of these other things. Perhaps instead of `memberwise`, the keyword should be `property` or `propertywise`.<br></p><p>I&#39;m not precisely sure what would be best, and keyword bikeshedding might be best left for a separate proposal. In any case, this defect is not nearly severe enough to make me want to scuttle the feature.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. The current memberwise initializers are unavailable in any situation with even the slightest complications. I think this proposal vastly improves the feature.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think it does. It makes something that was previously implicit explicit instead, reducing boilerplate while still providing plenty of flexibility.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I haven&#39;t, unless you count highly dynamic languages where you can easily build a constructor that initializes from a dictionary. This proposal is *far* more explicit than that sort of solution, which seems like an improvement to me.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve participated in discussions about this feature since before it was formally proposed; I think I may have been the first person to bring up memberwise initializers as a target for improvement on this list. I&#39;ve dug around in the Swift compiler and took a vague stab at implementing some related features, although I didn&#39;t get very far. I think my understanding of this issue is pretty in-depth.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 to the basic proposal. I&#39;m much more reserved about the &quot;Future enhancements&quot;; some I don&#39;t want at all, some sound plausible but probably need changes.<br></p><p>Also, a question and a concern about the basic proposal. The question: you state that the only impact this has on existing code is structs with private properties that have been getting an implicit internal memberwise initializer will have the initializer be private. That&#39;s fine, but assuming that the implicit memberwise initializer behaves identically to `memberwise init(...) {}`, surely this proposal also makes the implicit memberwise initializer gain defaulted arguments for any var properties with an initializer expression? Don&#39;t get me wrong, I think it&#39;s good to change that, but it should be explicitly noted.<br></p><p>As for my concern, it&#39;s with the following rule:<br></p><p>&gt; If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning. It is unlikely that overwriting the value provided by the caller is the desired behavior.<br></p><p>I understand why you put this in there, but this is a warning that cannot be suppressed and will make it impossible to use a memberwise initializer for perfectly legitimate cases where you do in fact want to mutate the property after it&#39;s been assigned to.<br></p><p>What might be a reasonable thing is a warning that occurs if you assign to the var property without ever having read from it (i.e. a dead store warning on the memberwise initialization of the property). That way if I mutate a property to contain a derived value it&#39;s fine, but if I simply write to it without ever reading it, it&#39;s a problem.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I think so. Writing initializers can be a large source of boilerplate in Swift, especially when using classes where you can&#39;t get the implicit memberwise initializer.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;m not aware of a similar feature in any language I&#39;m familiar with.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I spent a few minutes reading over the whole proposal. I did not read any of the swift-evolution thread.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 2:46 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 to the basic proposal. I&#39;m much more reserved about the &quot;Future enhancements&quot;; some I don&#39;t want at all, some sound plausible but probably need changes.<br></p><p>Thanks for your support Kevin!  <br></p><p>As I stated last night, there are two primary things that I think need improving via enhancements of some kind.  I hope you can agree with these points:<br></p><p>1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>2. We need a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.<br></p><p>Most of the enhancements listed show various ways we could address the second point.  We don’t need all of them.  <br></p><p>Under the current proposal there will be cases where memberwise initialization would be of great use, but the rules of the automatic model expose a property (probably a `let`) that shouldn’t be exposed.  We won’t be able to use memberwise initialization at all in those cases if we don’t have a way to correct that behavior.<br></p><p>There may also be cases where a property doesn’t participate in memberwsie initialization when we would like it to.  In those cases we can add an explicit parameter and manually initialize the property, continuing to use memberwise initialization for other properties.<br></p><p>Ideally we can find a simple enhancement that solves both visibility problems.  I’m definitely open to any ideas on how we can handle this.<br></p><p>&gt; <br>&gt; Also, a question and a concern about the basic proposal. The question: you state that the only impact this has on existing code is structs with private properties that have been getting an implicit internal memberwise initializer will have the initializer be private. That&#39;s fine, but assuming that the implicit memberwise initializer behaves identically to `memberwise init(...) {}`, surely this proposal also makes the implicit memberwise initializer gain defaulted arguments for any var properties with an initializer expression? Don&#39;t get me wrong, I think it&#39;s good to change that, but it should be explicitly noted.<br></p><p>That is a great point!  It won’t break any existing code, but it will change behavior slightly.  I will update the proposal and submit a PR with this change.<br></p><p>&gt; <br>&gt; As for my concern, it&#39;s with the following rule:<br>&gt; <br>&gt;&gt; If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning. It is unlikely that overwriting the value provided by the caller is the desired behavior.<br>&gt; <br>&gt; I understand why you put this in there, but this is a warning that cannot be suppressed and will make it impossible to use a memberwise initializer for perfectly legitimate cases where you do in fact want to mutate the property after it&#39;s been assigned to.<br></p><p>For normal initializers I agree with you.  However, I think it’s a reasonable for callers to assume that if you expose a property via memberwise initialization the post-initialization value will match the value they provide.  This warning is intended to alert you to the fact that you are violating that reasonable assumption.<br></p><p>Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br></p><p>&gt; <br>&gt; What might be a reasonable thing is a warning that occurs if you assign to the var property without ever having read from it (i.e. a dead store warning on the memberwise initialization of the property). That way if I mutate a property to contain a derived value it&#39;s fine, but if I simply write to it without ever reading it, it&#39;s a problem.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I think so. Writing initializers can be a large source of boilerplate in Swift, especially when using classes where you can&#39;t get the implicit memberwise initializer.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I&#39;m not aware of a similar feature in any language I&#39;m familiar with.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I spent a few minutes reading over the whole proposal. I did not read any of the swift-evolution thread.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/ca479088/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>Overall I think this is a definite improvement to the current status quo<br>and something needs to be solved. My only concern with this specific<br>proposal is that on an initial glance it&#39;s not easy to intuit what the<br>behavior is. I like the end result of this proposal, and I think since it&#39;d<br>be frequently used it&#39;d be easy to remember what it was despite being<br>unintuitive.<br></p><p>I had originally suggested this alternative:<br>```<br>struct Foo {<br>    let bar: String<br>    let bas: Int<br>    let baz: Double<br>    init(self.bar: String, self.bas: Int, bax: Int) {<br>          // self.bar = bar synthesized by the compiler<br>          // self.bas = bas synthesized by the compiler<br>        self.baz = Double(bax)<br>    }<br>}<br>```<br>The upside of this is that it&#39;s more clear what happens, downside is that<br>adding a property requires 2 changes (as opposed to current 3, but more<br>than the 1 change required in proposal).<br></p><p>Perhaps a syntax more along the lines of this would be more intuitive and<br>still eliminate the boilerplate.<br>```<br>struct Foo {<br>    let bar: String<br>    let bas: Int<br>    let baz: Double<br>    init(bax: Int, self = ...) {<br>          // self.bar = bar synthesized by the compiler<br>          // self.bas = bas synthesized by the compiler<br>        self.baz = Double(bax)<br>    }<br>}<br>```<br>`memberwise` means nothing to the uninitiated, and `...` without any other<br>operator is a little confusing. I think this solves the issue of saying<br>what the `...`  is doing.<br></p><p>On Thu, Jan 7, 2016 at 10:12 AM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 7, 2016, at 2:46 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt;<br>&gt; +1 to the basic proposal. I&#39;m much more reserved about the &quot;Future<br>&gt; enhancements&quot;; some I don&#39;t want at all, some sound plausible but probably<br>&gt; need changes.<br>&gt;<br>&gt;<br>&gt; Thanks for your support Kevin!<br>&gt;<br>&gt; As I stated last night, there are two primary things that I think need<br>&gt; improving via enhancements of some kind.  I hope you can agree with these<br>&gt; points:<br>&gt;<br>&gt; 1. We need a way to specify a default value for memberwise parameters for<br>&gt; `let` properties.<br>&gt; 2. We need a little bit more control over which properties participate in<br>&gt; memberwise initialization when the “automatic” rules don’t quite do the<br>&gt; right thing for a particular use case.<br>&gt;<br>&gt; Most of the enhancements listed show various ways we could address the<br>&gt; second point.  We don’t need all of them.<br>&gt;<br>&gt; Under the current proposal there will be cases where memberwise<br>&gt; initialization would be of great use, but the rules of the automatic model<br>&gt; expose a property (probably a `let`) that shouldn’t be exposed.  We won’t<br>&gt; be able to use memberwise initialization at all in those cases if we don’t<br>&gt; have a way to correct that behavior.<br>&gt;<br>&gt; There may also be cases where a property doesn’t participate in memberwsie<br>&gt; initialization when we would like it to.  In those cases we can add an<br>&gt; explicit parameter and manually initialize the property, continuing to use<br>&gt; memberwise initialization for other properties.<br>&gt;<br>&gt; Ideally we can find a simple enhancement that solves both visibility<br>&gt; problems.  I’m definitely open to any ideas on how we can handle this.<br>&gt;<br>&gt;<br>&gt; Also, a question and a concern about the basic proposal. The question: you<br>&gt; state that the only impact this has on existing code is structs with<br>&gt; private properties that have been getting an implicit internal memberwise<br>&gt; initializer will have the initializer be private. That&#39;s fine, but assuming<br>&gt; that the implicit memberwise initializer behaves identically to `memberwise<br>&gt; init(...) {}`, surely this proposal also makes the implicit memberwise<br>&gt; initializer gain defaulted arguments for any var properties with an<br>&gt; initializer expression? Don&#39;t get me wrong, I think it&#39;s good to change<br>&gt; that, but it should be explicitly noted.<br>&gt;<br>&gt;<br>&gt; That is a great point!  It won’t break any existing code, but it will<br>&gt; change behavior slightly.  I will update the proposal and submit a PR with<br>&gt; this change.<br>&gt;<br>&gt;<br>&gt; As for my concern, it&#39;s with the following rule:<br>&gt;<br>&gt; If the initializer body assigns to a var property that received memberwise<br>&gt; initialization synthesis report a warning. It is unlikely that overwriting<br>&gt; the value provided by the caller is the desired behavior.<br>&gt;<br>&gt;<br>&gt; I understand why you put this in there, but this is a warning that cannot<br>&gt; be suppressed and will make it impossible to use a memberwise initializer<br>&gt; for perfectly legitimate cases where you do in fact want to mutate the<br>&gt; property after it&#39;s been assigned to.<br>&gt;<br>&gt;<br>&gt; For normal initializers I agree with you.  However, I think it’s a<br>&gt; reasonable for callers to assume that if you expose a property via<br>&gt; memberwise initialization the post-initialization value will match the<br>&gt; value they provide.  This warning is intended to alert you to the fact that<br>&gt; you are violating that reasonable assumption.<br>&gt;<br>&gt; Do you have an example of where you would want a caller to initialize a<br>&gt; property, but then overwrite the value they provide *during<br>&gt; initialization*?<br>&gt;<br>&gt;<br>&gt; What might be a reasonable thing is a warning that occurs if you assign to<br>&gt; the var property without ever having read from it (i.e. a dead store<br>&gt; warning on the memberwise initialization of the property). That way if I<br>&gt; mutate a property to contain a derived value it&#39;s fine, but if I simply<br>&gt; write to it without ever reading it, it&#39;s a problem.<br>&gt;<br>&gt;<br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt;<br>&gt; I think so. Writing initializers can be a large source of boilerplate in<br>&gt; Swift, especially when using classes where you can&#39;t get the implicit<br>&gt; memberwise initializer.<br>&gt;<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt; * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt;<br>&gt; I&#39;m not aware of a similar feature in any language I&#39;m familiar with.<br>&gt;<br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt;<br>&gt; I spent a few minutes reading over the whole proposal. I did not read any<br>&gt; of the swift-evolution thread.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/c433c8f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:43 AM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; Overall I think this is a definite improvement to the current status quo and something needs to be solved. My only concern with this specific proposal is that on an initial glance it&#39;s not easy to intuit what the behavior is. I like the end result of this proposal, and I think since it&#39;d be frequently used it&#39;d be easy to remember what it was despite being unintuitive.<br>&gt; <br>&gt; I had originally suggested this alternative:<br>&gt; ```<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let bas: Int<br>&gt;     let baz: Double<br>&gt;     init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt;           // self.bar = bar synthesized by the compiler<br>&gt;           // self.bas = bas synthesized by the compiler<br>&gt;         self.baz = Double(bax)<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; The upside of this is that it&#39;s more clear what happens, downside is that adding a property requires 2 changes (as opposed to current 3, but more than the 1 change required in proposal).<br></p><p>The problem with this is that you have to duplicate information and you may often have more than one initializer.  It ends up being much more verbose.  I don’t think it adds enough value over fully manual initialization to warrant a language change.<br></p><p>&gt; <br>&gt; Perhaps a syntax more along the lines of this would be more intuitive and still eliminate the boilerplate.<br>&gt; ```<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let bas: Int<br>&gt;     let baz: Double<br>&gt;     init(bax: Int, self = ...) {<br>&gt;           // self.bar = bar synthesized by the compiler<br>&gt;           // self.bas = bas synthesized by the compiler<br>&gt;         self.baz = Double(bax)<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; `memberwise` means nothing to the uninitiated, and `...` without any other operator is a little confusing. I think this solves the issue of saying what the `...`  is doing.<br></p><p>I don’t like this.  People are going to have to learn the language regardless of the syntax.  Remember that the initializer will have the `memberwise` declaration modifier in addition to the `…` in the parameter list.  I don’t think `self = …` would be more clear than that to people who have learned about memberwise initialization.  And it feels like something that should belong in the body of the initializer if it was required.<br></p><p><br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 10:12 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Jan 7, 2016, at 2:46 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1 to the basic proposal. I&#39;m much more reserved about the &quot;Future enhancements&quot;; some I don&#39;t want at all, some sound plausible but probably need changes.<br>&gt; <br>&gt; Thanks for your support Kevin!  <br>&gt; <br>&gt; As I stated last night, there are two primary things that I think need improving via enhancements of some kind.  I hope you can agree with these points:<br>&gt; <br>&gt; 1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>&gt; 2. We need a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.<br>&gt; <br>&gt; Most of the enhancements listed show various ways we could address the second point.  We don’t need all of them.  <br>&gt; <br>&gt; Under the current proposal there will be cases where memberwise initialization would be of great use, but the rules of the automatic model expose a property (probably a `let`) that shouldn’t be exposed.  We won’t be able to use memberwise initialization at all in those cases if we don’t have a way to correct that behavior.<br>&gt; <br>&gt; There may also be cases where a property doesn’t participate in memberwsie initialization when we would like it to.  In those cases we can add an explicit parameter and manually initialize the property, continuing to use memberwise initialization for other properties.<br>&gt; <br>&gt; Ideally we can find a simple enhancement that solves both visibility problems.  I’m definitely open to any ideas on how we can handle this.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Also, a question and a concern about the basic proposal. The question: you state that the only impact this has on existing code is structs with private properties that have been getting an implicit internal memberwise initializer will have the initializer be private. That&#39;s fine, but assuming that the implicit memberwise initializer behaves identically to `memberwise init(...) {}`, surely this proposal also makes the implicit memberwise initializer gain defaulted arguments for any var properties with an initializer expression? Don&#39;t get me wrong, I think it&#39;s good to change that, but it should be explicitly noted.<br>&gt; <br>&gt; That is a great point!  It won’t break any existing code, but it will change behavior slightly.  I will update the proposal and submit a PR with this change.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; As for my concern, it&#39;s with the following rule:<br>&gt;&gt; <br>&gt;&gt;&gt; If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning. It is unlikely that overwriting the value provided by the caller is the desired behavior.<br>&gt;&gt; <br>&gt;&gt; I understand why you put this in there, but this is a warning that cannot be suppressed and will make it impossible to use a memberwise initializer for perfectly legitimate cases where you do in fact want to mutate the property after it&#39;s been assigned to.<br>&gt; <br>&gt; For normal initializers I agree with you.  However, I think it’s a reasonable for callers to assume that if you expose a property via memberwise initialization the post-initialization value will match the value they provide.  This warning is intended to alert you to the fact that you are violating that reasonable assumption.<br>&gt; <br>&gt; Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; What might be a reasonable thing is a warning that occurs if you assign to the var property without ever having read from it (i.e. a dead store warning on the memberwise initialization of the property). That way if I mutate a property to contain a derived value it&#39;s fine, but if I simply write to it without ever reading it, it&#39;s a problem.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; I think so. Writing initializers can be a large source of boilerplate in Swift, especially when using classes where you can&#39;t get the implicit memberwise initializer.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I&#39;m not aware of a similar feature in any language I&#39;m familiar with.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I spent a few minutes reading over the whole proposal. I did not read any of the swift-evolution thread.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/c24e5bfc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt; As for my concern, it&#39;s with the following rule:<br>&gt;&gt;<br>&gt;&gt;&gt; If the initializer body assigns to a var property that received<br>&gt;&gt;&gt; memberwise initialization synthesis report a warning. It is unlikely<br>&gt;&gt;&gt; that overwriting the value provided by the caller is the desired<br>&gt;&gt;&gt; behavior.<br>&gt;&gt;<br>&gt;&gt; I understand why you put this in there, but this is a warning that<br>&gt;&gt; cannot be suppressed and will make it impossible to use a memberwise<br>&gt;&gt; initializer for perfectly legitimate cases where you do in fact want<br>&gt;&gt; to mutate the property after it&#39;s been assigned to.<br>&gt;<br>&gt; For normal initializers I agree with you.  However, I think it’s a<br>&gt; reasonable for callers to assume that if you expose a property via<br>&gt; memberwise initialization the post-initialization value will match the<br>&gt; value they provide.  This warning is intended to alert you to the fact<br>&gt; that you are violating that reasonable assumption.<br></p><p>I think that&#39;s a reasonable assumption in many cases, but I don&#39;t like<br>the fact that the feature cannot be used at all in the rare case where<br>it actually makes sense to mutate the value.<br></p><p>&gt; Do you have an example of where you would want a caller to initialize<br>&gt; a property, but then overwrite the value they provide *during<br>&gt; initialization*?<br></p><p>Sure, how about something like a Rect type that always guarantees it&#39;s<br>in &quot;standard&quot; form (e.g. no negative sizes):<br></p><p>struct StandardRect {    var origin: CGPoint    var size: CGSize {<br>didSet {            // ensure standardized form here        }    }<br></p><p>memberwise init(...) {        if size.width &lt; 0 {            origin.x +=<br>size.width            size.width = -size.width        }        if<br>size.height &lt; 0 {            origin.y += size.height<br>size.height = -size.height        }    } }<br></p><p>Or how about a struct that represents a URL request complete with<br>headers, and forces the inclusion of Content-Type:<br></p><p>struct URLRequest {    var headers: [String: String] = [:]    // ...<br>other properties here ...    memberwise init(contentType: String, ...) {<br>headers[&quot;Content-Type&quot;] = contentType    } }<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/23369414/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, Jan 7, 2016, at 01:31 PM, Kevin Ballard wrote:<br>&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt; As for my concern, it&#39;s with the following rule:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If the initializer body assigns to a var property that received<br>&gt;&gt;&gt;&gt; memberwise initialization synthesis report a warning. It is<br>&gt;&gt;&gt;&gt; unlikely that overwriting the value provided by the caller is the<br>&gt;&gt;&gt;&gt; desired behavior.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand why you put this in there, but this is a warning that<br>&gt;&gt;&gt; cannot be suppressed and will make it impossible to use a memberwise<br>&gt;&gt;&gt; initializer for perfectly legitimate cases where you do in fact want<br>&gt;&gt;&gt; to mutate the property after it&#39;s been assigned to.<br>&gt;&gt;<br>&gt;&gt; For normal initializers I agree with you.  However, I think it’s a<br>&gt;&gt; reasonable for callers to assume that if you expose a property via<br>&gt;&gt; memberwise initialization the post-initialization value will match<br>&gt;&gt; the value they provide.  This warning is intended to alert you to the<br>&gt;&gt; fact that you are violating that reasonable assumption.<br>&gt;<br>&gt; I think that&#39;s a reasonable assumption in many cases, but I don&#39;t like<br>&gt; the fact that the feature cannot be used at all in the rare case where<br>&gt; it actually makes sense to mutate the value.<br>&gt;<br>&gt;&gt; Do you have an example of where you would want a caller to initialize<br>&gt;&gt; a property, but then overwrite the value they provide *during<br>&gt;&gt; initialization*?<br>&gt;<br>&gt; Sure, how about something like a Rect type that always guarantees it&#39;s<br>&gt; in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;<br>&gt; struct StandardRect {    var origin: CGPoint    var size: CGSize {<br>&gt; didSet {            // ensure standardized form here        }    }<br>&gt;<br>&gt; memberwise init(...) {        if size.width &lt; 0 {            origin.x<br>&gt; += size.width            size.width = -size.width        }        if<br>&gt; size.height &lt; 0 {            origin.y += size.height<br>&gt; size.height = -size.height        }    } }<br>&gt;<br>&gt; Or how about a struct that represents a URL request complete with<br>&gt; headers, and forces the inclusion of Content-Type:<br>&gt;<br>&gt; struct URLRequest {    var headers: [String: String] = [:]    // ...<br>&gt; other properties here ...    memberwise init(contentType: String, ...)<br>&gt; {        headers[&quot;Content-Type&quot;] = contentType    } }<br></p><p>Here&#39;s an even better example, since it matches some code I actually<br>already have in a production app. Assuming that the &quot;...&quot; placeholder<br>can go anywhere (which seems reasonable), I have extensions on CGRect<br>and friends that could use memberwise init instead to be written like<br></p><p>extension CGRect {    memberwise init(..., roundedToScale: CGFloat) }<br></p><p>This method takes the components of a rect, as well as a scale, and it<br>properly rounds the components so that the rect falls along pixel<br>boundaries if displayed on a screen with the given scale.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/8a400362/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt; As for my concern, it&#39;s with the following rule:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning. It is unlikely that overwriting the value provided by the caller is the desired behavior.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I understand why you put this in there, but this is a warning that cannot be suppressed and will make it impossible to use a memberwise initializer for perfectly legitimate cases where you do in fact want to mutate the property after it&#39;s been assigned to.<br>&gt;&gt;  <br>&gt;&gt; For normal initializers I agree with you.  However, I think it’s a reasonable for callers to assume that if you expose a property via memberwise initialization the post-initialization value will match the value they provide.  This warning is intended to alert you to the fact that you are violating that reasonable assumption.<br>&gt;  <br>&gt; I think that&#39;s a reasonable assumption in many cases, but I don&#39;t like the fact that the feature cannot be used at all in the rare case where it actually makes sense to mutate the value.<br>&gt;  <br>&gt;&gt; Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br>&gt;  <br>&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;  <br>&gt; struct StandardRect {<br>&gt;     var origin: CGPoint<br>&gt;     var size: CGSize {<br>&gt;         didSet {<br>&gt;             // ensure standardized form here<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     memberwise init(...) {<br>&gt;         if size.width &lt; 0 {<br>&gt;             origin.x += size.width<br>&gt;             size.width = -size.width<br>&gt;         }<br>&gt;         if size.height &lt; 0 {<br>&gt;             origin.y += size.height<br>&gt;             size.height = -size.height<br>&gt;         }<br>&gt;     }<br>&gt; }<br></p><p>This is a good example.  Thanks!  <br></p><p>I think cases like this will be rare so I still think a warning is a good idea.  Something like -Wno-overwrite-memberwise-init would allow it to be suppressed in cases where you actually do intend to do this.  Would that satisfy you?<br></p><p>&gt;  <br>&gt; Or how about a struct that represents a URL request complete with headers, and forces the inclusion of Content-Type:<br>&gt;  <br>&gt; struct URLRequest {<br>&gt;     var headers: [String: String] = [:]<br>&gt;     // ... other properties here ...<br>&gt;     memberwise init(contentType: String, ...) {<br>&gt;         headers[&quot;Content-Type&quot;] = contentType<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; -Kevin Ballard<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/cc1836f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;<br>&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt; As for my concern, it&#39;s with the following rule:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If the initializer body assigns to a var property that received<br>&gt;&gt;&gt;&gt;&gt; memberwise initialization synthesis report a warning. It is<br>&gt;&gt;&gt;&gt;&gt; unlikely that overwriting the value provided by the caller is the<br>&gt;&gt;&gt;&gt;&gt; desired behavior.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I understand why you put this in there, but this is a warning that<br>&gt;&gt;&gt;&gt; cannot be suppressed and will make it impossible to use a<br>&gt;&gt;&gt;&gt; memberwise initializer for perfectly legitimate cases where you do<br>&gt;&gt;&gt;&gt; in fact want to mutate the property after it&#39;s been assigned to.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For normal initializers I agree with you.  However, I think it’s a<br>&gt;&gt;&gt; reasonable for callers to assume that if you expose a property via<br>&gt;&gt;&gt; memberwise initialization the post-initialization value will match<br>&gt;&gt;&gt; the value they provide.  This warning is intended to alert you to<br>&gt;&gt;&gt; the fact that you are violating that reasonable assumption.<br>&gt;&gt;<br>&gt;&gt; I think that&#39;s a reasonable assumption in many cases, but I don&#39;t<br>&gt;&gt; like the fact that the feature cannot be used at all in the rare case<br>&gt;&gt; where it actually makes sense to mutate the value.<br>&gt;&gt;<br>&gt;&gt;&gt; Do you have an example of where you would want a caller to<br>&gt;&gt;&gt; initialize a property, but then overwrite the value they provide<br>&gt;&gt;&gt; *during initialization*?<br>&gt;&gt;<br>&gt;&gt; Sure, how about something like a Rect type that always guarantees<br>&gt;&gt; it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;<br>&gt;&gt; struct StandardRect {    var origin: CGPoint    var size: CGSize {<br>&gt;&gt; didSet {            // ensure standardized form here        }    }<br>&gt;&gt;<br>&gt;&gt; memberwise init(...) {        if size.width &lt; 0 {            origin.x<br>&gt;&gt; += size.width            size.width = -size.width        }        if<br>&gt;&gt; size.height &lt; 0 {            origin.y += size.height<br>&gt;&gt; size.height = -size.height        }    } }<br>&gt;<br>&gt; This is a good example.  Thanks!<br>&gt;<br>&gt; I think cases like this will be rare so I still think a warning is a<br>&gt; good idea.  Something like -Wno-overwrite-memberwise-init would allow<br>&gt; it to be suppressed in cases where you actually do intend to do this.<br>&gt; Would that satisfy you?<br></p><p>No. It&#39;s not appropriate to have the only way to suppress a warning<br>on perfectly legal code to be passing a flag to the swiftc<br>invocation. Especially because we have no precedent yet for even<br>having flags like that.<br></p><p>What&#39;s wrong with the suggestion to make the warning behave the same way<br>as dead store warnings (e.g. warn if the property is overwritten without<br>any prior reads)? We already have logic for doing this kind of analysis.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/14082988/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 7, 2016, at 5:41 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt;&gt; As for my concern, it&#39;s with the following rule:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning. It is unlikely that overwriting the value provided by the caller is the desired behavior.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I understand why you put this in there, but this is a warning that cannot be suppressed and will make it impossible to use a memberwise initializer for perfectly legitimate cases where you do in fact want to mutate the property after it&#39;s been assigned to.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; For normal initializers I agree with you.  However, I think it’s a reasonable for callers to assume that if you expose a property via memberwise initialization the post-initialization value will match the value they provide.  This warning is intended to alert you to the fact that you are violating that reasonable assumption.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think that&#39;s a reasonable assumption in many cases, but I don&#39;t like the fact that the feature cannot be used at all in the rare case where it actually makes sense to mutate the value.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; struct StandardRect {<br>&gt;&gt;&gt;     var origin: CGPoint<br>&gt;&gt;&gt;     var size: CGSize {<br>&gt;&gt;&gt;         didSet {<br>&gt;&gt;&gt;             // ensure standardized form here<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     memberwise init(...) {<br>&gt;&gt;&gt;         if size.width &lt; 0 {<br>&gt;&gt;&gt;             origin.x += size.width<br>&gt;&gt;&gt;             size.width = -size.width<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         if size.height &lt; 0 {<br>&gt;&gt;&gt;             origin.y += size.height<br>&gt;&gt;&gt;             size.height = -size.height<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; This is a good example.  Thanks!  <br>&gt;&gt;  <br>&gt;&gt; I think cases like this will be rare so I still think a warning is a good idea.  Something like -Wno-overwrite-memberwise-init would allow it to be suppressed in cases where you actually do intend to do this.  Would that satisfy you?<br>&gt;  <br>&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on perfectly legal code to be passing a flag to the swiftc invocation. Especially because we have no precedent yet for even having flags like that.<br></p><p>We will probably have warning flags eventually.<br>&gt;  <br>&gt; What&#39;s wrong with the suggestion to make the warning behave the same way as dead store warnings (e.g. warn if the property is overwritten without any prior reads)? We already have logic for doing this kind of analysis.<br></p><p>I missed that suggestion.  This is probably sufficient.  <br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/a8552b50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; We will probably have warning flags eventually.<br></p><p>I don&#39;t know what makes you think so. The language has so far carefully avoided this, and we&#39;ve heard some pretty strong statements from the core team against the idea of compiler flags and incompatible dialects.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 7:25 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; We will probably have warning flags eventually.<br>&gt; <br>&gt; I don&#39;t know what makes you think so. The language has so far carefully avoided this, and we&#39;ve heard some pretty strong statements from the core team against the idea of compiler flags and incompatible dialects.<br></p><p>Warning flags are much different than dialect flags.  <br></p><p>Maybe we will get by without them, but there are plenty of legitimate reasons that different people want the compiler to tell them about different things in their code.  An alternate possibility might be to put this kind of thing in an external tool that can be invoked as part of the build system.  <br></p><p>Regardless of implementation, I think we are likely to see tools of some kind that integrate with the build system and highlight different issues for different teams.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>My biggest problem is what does member wise even mean the averts person.<br>And a naked ... Is a spread operator in most languages and doesn&#39;t mean<br>anything inherently.<br></p><p>I worry about arguing about the specifics because this is way better than<br>the current state but I very much think the details of this proposal are<br>confusing to the average developer and is more restrictive to any future<br>use of the spread operator.<br></p><p>On Thu, Jan 7, 2016 at 8:25 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; We will probably have warning flags eventually.<br>&gt;<br>&gt; I don&#39;t know what makes you think so. The language has so far carefully<br>&gt; avoided this, and we&#39;ve heard some pretty strong statements from the core<br>&gt; team against the idea of compiler flags and incompatible dialects.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/1f55a611/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>It’s a common use case to have a private stored object that’s set<br>externally via the initializer, I think having a solution that doesn’t<br>support that would be a big mistake.<br></p><p>On Fri, Jan 8, 2016 at 11:08 AM Tal Atlas &lt;me at tal.by&gt; wrote:<br></p><p>&gt; My biggest problem is what does member wise even mean the averts person.<br>&gt; And a naked ... Is a spread operator in most languages and doesn&#39;t mean<br>&gt; anything inherently.<br>&gt;<br>&gt; I worry about arguing about the specifics because this is way better than<br>&gt; the current state but I very much think the details of this proposal are<br>&gt; confusing to the average developer and is more restrictive to any future<br>&gt; use of the spread operator.<br>&gt;<br>&gt; On Thu, Jan 7, 2016 at 8:25 PM Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; We will probably have warning flags eventually.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know what makes you think so. The language has so far carefully<br>&gt;&gt; avoided this, and we&#39;ve heard some pretty strong statements from the core<br>&gt;&gt; team against the idea of compiler flags and incompatible dialects.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/e30f1940/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:09 AM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; It’s a common use case to have a private stored object that’s set externally via the initializer, I think having a solution that doesn’t support that would be a big mistake.<br></p><p>IMO it would bad to expose a private property via an internal or public initializer without a specific request from the programmer to do that.  I believe the best approach to address this is to allow access control for init: `private public(init)`.  <br></p><p>Chris really wanted the initial proposal to focus on core functionality that can be enhanced later, with independent review of the enhancements, even if those enhancements make it into Swift 3.  That is what this proposal reflects.  <br></p><p>In the meantime, you can still do what you want using a memberwise initializer that manually accepts additional parameters for the private properties.  That might not be ideal, but at least you can still use memberwise initialization for other properties.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; On Fri, Jan 8, 2016 at 11:08 AM Tal Atlas &lt;me at tal.by &lt;mailto:me at tal.by&gt;&gt; wrote:<br>&gt; My biggest problem is what does member wise even mean the averts person. And a naked ... Is a spread operator in most languages and doesn&#39;t mean anything inherently. <br>&gt; <br>&gt; I worry about arguing about the specifics because this is way better than the current state but I very much think the details of this proposal are confusing to the average developer and is more restrictive to any future use of the spread operator. <br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 8:25 PM Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; We will probably have warning flags eventually.<br>&gt; <br>&gt; I don&#39;t know what makes you think so. The language has so far carefully avoided this, and we&#39;ve heard some pretty strong statements from the core team against the idea of compiler flags and incompatible dialects.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/667a2d4a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:08 AM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; My biggest problem is what does member wise even mean the averts person. And a naked ... Is a spread operator in most languages and doesn&#39;t mean anything inherently. <br></p><p>If you want to bikeshed on the placeholder we use be my guest!  I think a placeholder is necessary and `…` feels best in Swift but wouldn’t be opposed to changing it if you are able to convince most people that you have a better idea.<br></p><p>&gt; <br>&gt; I worry about arguing about the specifics because this is way better than the current state but I very much think the details of this proposal are confusing to the average developer and is more restrictive to any future use of the spread operator. <br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 8:25 PM Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; We will probably have warning flags eventually.<br>&gt; <br>&gt; I don&#39;t know what makes you think so. The language has so far carefully avoided this, and we&#39;ve heard some pretty strong statements from the core team against the idea of compiler flags and incompatible dialects.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/0e5d0d8c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b22bad6d88de707d2ae9531c185ff?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;trsfoo at googlemail.com&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt; Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; struct StandardRect {<br>&gt;&gt;&gt;     var origin: CGPoint<br>&gt;&gt;&gt;     var size: CGSize {<br>&gt;&gt;&gt;         didSet {<br>&gt;&gt;&gt;             // ensure standardized form here<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     memberwise init(...) {<br>&gt;&gt;&gt;         if size.width &lt; 0 {<br>&gt;&gt;&gt;             origin.x += size.width<br>&gt;&gt;&gt;             size.width = -size.width<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         if size.height &lt; 0 {<br>&gt;&gt;&gt;             origin.y += size.height<br>&gt;&gt;&gt;             size.height = -size.height<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; This is a good example.  Thanks!  <br></p><p>Actually I do not like this example for several reasons: (1) I would make the rectangle an immutable type with let properties, (2) the didSet already seems to do what is encoded in the memberwise init, so this seems to be redundant, (3) the memberwise init is so complex that having the automatic initialization feature is not really worth it for this example, especially as it seems to require using var properties instead of let properties to do the overwriting.<br></p><p> <br>&gt;&gt; I think cases like this will be rare so I still think a warning is a good idea.  Something like -Wno-overwrite-memberwise-init would allow it to be suppressed in cases where you actually do intend to do this.  Would that satisfy you?<br>&gt;  <br>&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on perfectly legal code to be passing a flag to the swiftc invocation. Especially because we have no precedent yet for even having flags like that.<br>&gt;  <br>&gt; What&#39;s wrong with the suggestion to make the warning behave the same way as dead store warnings (e.g. warn if the property is overwritten without any prior reads)? We already have logic for doing this kind of analysis.<br></p><p><br>I think this would not be sufficient, because this would not allow overwriting a property based on the value of another property which might be necessary as well.<br>Actually isn’t this what happens in your example? The property origin is overwritten without being read, so this would generate the warning, or did I understand something wrong?<br></p><p>-Thorsten<br></p><p><br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/7c8ac5d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>On Fri, Jan 8, 2016, at 12:56 AM, Thorsten Seitz wrote:<br>&gt;<br>&gt;&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt;&gt; Do you have an example of where you would want a caller to<br>&gt;&gt;&gt;&gt;&gt; initialize a property, but then overwrite the value they provide<br>&gt;&gt;&gt;&gt;&gt; *during initialization*?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sure, how about something like a Rect type that always guarantees<br>&gt;&gt;&gt;&gt; it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct StandardRect {    var origin: CGPoint    var size: CGSize {<br>&gt;&gt;&gt;&gt; didSet {            // ensure standardized form here        }    }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; memberwise init(...) {        if size.width &lt; 0 {<br>&gt;&gt;&gt;&gt; origin.x += size.width            size.width = -size.width        }<br>&gt;&gt;&gt;&gt; if size.height &lt; 0 {            origin.y += size.height<br>&gt;&gt;&gt;&gt; size.height = -size.height        }    } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a good example.  Thanks!<br>&gt;<br>&gt; Actually I do not like this example for several reasons: (1) I would<br>&gt; make the rectangle an immutable type with let properties, (2) the<br>&gt; didSet already seems to do what is encoded in the memberwise init, so<br>&gt; this seems to be redundant, (3) the memberwise init is so complex that<br>&gt; having the automatic initialization feature is not really worth it for<br>&gt; this example, especially as it seems to require using var properties<br>&gt; instead of let properties to do the overwriting.<br></p><p>1) Why would you make it immutable? That helps nothing and only serves<br>   to make the type harder to use. Structs should _rarely_ be immutable,<br>   you should always default to mutable and only make things immutable<br>   if there&#39;s a good reason for it. If the struct itself is in an<br>   immutable position then it inherits the immutability, which handles<br>   all of the reasons why you might otherwise default to immutable.<br></p><p>2) didSet isn&#39;t triggered in init. There&#39;s no redundancy.<br></p><p>3) You really really want var properties anyway, it&#39;s pointless to use<br>   let properties.<br></p><p>&gt;&gt;&gt; I think cases like this will be rare so I still think a warning is a<br>&gt;&gt;&gt; good idea.  Something like -Wno-overwrite-memberwise-init would<br>&gt;&gt;&gt; allow it to be suppressed in cases where you actually do intend to<br>&gt;&gt;&gt; do this.  Would that satisfy you?<br>&gt;&gt;<br>&gt;&gt; No. It&#39;s not appropriate to have the only way to suppress a warning<br>&gt;&gt; on perfectly legal code to be passing a flag to the swiftc<br>&gt;&gt; invocation. Especially because we have no precedent yet for even<br>&gt;&gt; having flags like that.<br>&gt;&gt;<br>&gt;&gt; What&#39;s wrong with the suggestion to make the warning behave the same<br>&gt;&gt; way as dead store warnings (e.g. warn if the property is overwritten<br>&gt;&gt; without any prior reads)? We already have logic for doing this kind<br>&gt;&gt; of analysis.<br>&gt;<br>&gt;<br>&gt; I think this would not be sufficient, because this would not allow<br>&gt; overwriting a property based on the value of another property which<br>&gt; might be necessary as well.<br></p><p>That seems much less likely to be necessary, because if you&#39;re doing<br>that, then you&#39;re completely ignoring one of your parameters.<br></p><p>&gt; Actually isn’t this what happens in your example? The property origin<br>&gt; is overwritten without being read, so this would generate the warning,<br>&gt; or did I understand something wrong?<br></p><p>Origin is being modified. Modification reads it first. `x += 2` reads<br>`x` before writing to it.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/5346a075/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b22bad6d88de707d2ae9531c185ff?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;trsfoo at googlemail.com&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 08.01.2016 um 19:58 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Fri, Jan 8, 2016, at 12:56 AM, Thorsten Seitz wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; struct StandardRect {<br>&gt;&gt;&gt;&gt;&gt;     var origin: CGPoint<br>&gt;&gt;&gt;&gt;&gt;     var size: CGSize {<br>&gt;&gt;&gt;&gt;&gt;         didSet {<br>&gt;&gt;&gt;&gt;&gt;             // ensure standardized form here<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;     memberwise init(...) {<br>&gt;&gt;&gt;&gt;&gt;         if size.width &lt; 0 {<br>&gt;&gt;&gt;&gt;&gt;             origin.x += size.width<br>&gt;&gt;&gt;&gt;&gt;             size.width = -size.width<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         if size.height &lt; 0 {<br>&gt;&gt;&gt;&gt;&gt;             origin.y += size.height<br>&gt;&gt;&gt;&gt;&gt;             size.height = -size.height<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; This is a good example.  Thanks!  <br>&gt;&gt;  <br>&gt;&gt; Actually I do not like this example for several reasons: (1) I would make the rectangle an immutable type with let properties, (2) the didSet already seems to do what is encoded in the memberwise init, so this seems to be redundant, (3) the memberwise init is so complex that having the automatic initialization feature is not really worth it for this example, especially as it seems to require using var properties instead of let properties to do the overwriting.<br>&gt;  <br>&gt; 1) Why would you make it immutable? That helps nothing and only serves to make the type harder to use. Structs should _rarely_ be immutable, you should always default to mutable and only make things immutable if there&#39;s a good reason for it. If the struct itself is in an immutable position then it inherits the immutability, which handles all of the reasons why you might otherwise default to immutable.<br></p><p>Hmm, food for thought… guess I still haven’t completely understood Swift’s handling of immutability… thanks for pointing that out!<br></p><p>&gt; 2) didSet isn&#39;t triggered in init. There&#39;s no redundancy.<br></p><p>You are right, of course. I forgot that when I wrote the mail.<br></p><p>&gt; 3) You really really want var properties anyway, it&#39;s pointless to use let properties.<br>&gt;&gt;&gt;&gt; I think cases like this will be rare so I still think a warning is a good idea.  Something like -Wno-overwrite-memberwise-init would allow it to be suppressed in cases where you actually do intend to do this.  Would that satisfy you?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on perfectly legal code to be passing a flag to the swiftc invocation. Especially because we have no precedent yet for even having flags like that.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What&#39;s wrong with the suggestion to make the warning behave the same way as dead store warnings (e.g. warn if the property is overwritten without any prior reads)? We already have logic for doing this kind of analysis.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; I think this would not be sufficient, because this would not allow overwriting a property based on the value of another property which might be necessary as well.<br>&gt;  <br>&gt; That seems much less likely to be necessary, because if you&#39;re doing that, then you&#39;re completely ignoring one of your parameters.<br>&gt;  <br>&gt;&gt; Actually isn’t this what happens in your example? The property origin is overwritten without being read, so this would generate the warning, or did I understand something wrong?<br>&gt;  <br>&gt; Origin is being modified. Modification reads it first. `x += 2` reads `x` before writing to it.<br></p><p>I stand corrected.<br></p><p>-Thorsten<br></p><p><br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/78ab58ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January  8, 2016 at 08:00:00pm</p></header><div class="content"><p>I like the idea of the proposal (not 100%) but i really dislike the &quot;Future<br>enhancements&quot; part:<br></p><p>*@default* is unnecessary in my opinion, i think just write the &quot;future&quot;<br>variable declaration (&quot;memberwised&quot;) and put the default value is enough:<br></p><p>struct S {<br>    let s: String<br>    let i: Int<br></p><p>    // user declares:<br>    memberwise init(s: String = &quot;hello&quot;,...) {}<br></p><p>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int) { // because s: String matches<br>the sintaxe, so the compiler will not (re)synthesize.<br>        /* synthesized */ self.s = s<br>        /* synthesized */ self.i = i<br>    }<br>}<br></p><p><br></p><p>*memberwise properties* and *@nomemberwise* are too much trouble for little<br>gain.  Hand write the init by itself will be more easy and clear.<br></p><p>The fist part when the proposal focuses only on the automation of (maybe<br>only undeclared) variables on init using &quot;...&quot; placeholder as insertion<br>point, I believe that can be a nice feature.<br></p><p><br>Em sex, 8 de jan de 2016 às 18:13, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Am 08.01.2016 um 19:58 schrieb Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; On Fri, Jan 8, 2016, at 12:56 AM, Thorsten Seitz wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;<br>&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;<br>&gt; Do you have an example of where you would want a caller to initialize a<br>&gt; property, but then overwrite the value they provide *during<br>&gt; initialization*?<br>&gt;<br>&gt;<br>&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in<br>&gt; &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;<br>&gt; struct StandardRect {<br>&gt;     var origin: CGPoint<br>&gt;     var size: CGSize {<br>&gt;         didSet {<br>&gt;             // ensure standardized form here<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     memberwise init(...) {<br>&gt;         if size.width &lt; 0 {<br>&gt;             origin.x += size.width<br>&gt;             size.width = -size.width<br>&gt;         }<br>&gt;         if size.height &lt; 0 {<br>&gt;             origin.y += size.height<br>&gt;             size.height = -size.height<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is a good example.  Thanks!<br>&gt;<br>&gt;<br>&gt; Actually I do not like this example for several reasons: (1) I would make<br>&gt; the rectangle an immutable type with let properties, (2) the didSet already<br>&gt; seems to do what is encoded in the memberwise init, so this seems to be<br>&gt; redundant, (3) the memberwise init is so complex that having the automatic<br>&gt; initialization feature is not really worth it for this example, especially<br>&gt; as it seems to require using var properties instead of let properties to do<br>&gt; the overwriting.<br>&gt;<br>&gt;<br>&gt; 1) Why would you make it immutable? That helps nothing and only serves to<br>&gt; make the type harder to use. Structs should _rarely_ be immutable, you<br>&gt; should always default to mutable and only make things immutable if there&#39;s<br>&gt; a good reason for it. If the struct itself is in an immutable position then<br>&gt; it inherits the immutability, which handles all of the reasons why you<br>&gt; might otherwise default to immutable.<br>&gt;<br>&gt;<br>&gt; Hmm, food for thought… guess I still haven’t completely understood Swift’s<br>&gt; handling of immutability… thanks for pointing that out!<br>&gt;<br>&gt; 2) didSet isn&#39;t triggered in init. There&#39;s no redundancy.<br>&gt;<br>&gt;<br>&gt; You are right, of course. I forgot that when I wrote the mail.<br>&gt;<br>&gt; 3) You really really want var properties anyway, it&#39;s pointless to use let<br>&gt; properties.<br>&gt;<br>&gt; I think cases like this will be rare so I still think a warning is a good<br>&gt; idea.  Something like -Wno-overwrite-memberwise-init would allow it to be<br>&gt; suppressed in cases where you actually do intend to do this.  Would that<br>&gt; satisfy you?<br>&gt;<br>&gt;<br>&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on<br>&gt; perfectly legal code to be passing a flag to the swiftc invocation.<br>&gt; Especially because we have no precedent yet for even having flags like that.<br>&gt;<br>&gt; What&#39;s wrong with the suggestion to make the warning behave the same way<br>&gt; as dead store warnings (e.g. warn if the property is overwritten without<br>&gt; any prior reads)? We already have logic for doing this kind of analysis.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I think this would not be sufficient, because this would not allow<br>&gt; overwriting a property based on the value of another property which might<br>&gt; be necessary as well.<br>&gt;<br>&gt;<br>&gt; That seems much less likely to be necessary, because if you&#39;re doing that,<br>&gt; then you&#39;re completely ignoring one of your parameters.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Actually isn’t this what happens in your example? The property origin is<br>&gt; overwritten without being read, so this would generate the warning, or did<br>&gt; I understand something wrong?<br>&gt;<br>&gt;<br>&gt; Origin is being modified. Modification reads it first. `x += 2` reads `x`<br>&gt; before writing to it.<br>&gt;<br>&gt;<br>&gt; I stand corrected.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/a9807f46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 2:40 PM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea of the proposal (not 100%) but i really dislike the &quot;Future enhancements&quot; part:<br>&gt; <br>&gt; @default is unnecessary in my opinion, i think just write the &quot;future&quot; variable declaration (&quot;memberwised&quot;) and put the default value is enough:<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(s: String = &quot;hello&quot;,...) {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int) { // because s: String matches the sintaxe, so the compiler will not (re)synthesize.<br>&gt;         /* synthesized */ self.s = s<br>&gt;         /* synthesized */ self.i = i<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br></p><p>This is not allowed under the proposal.  If you declare a parameter with an external label matching a synthesized parameter an error will result.  Allowing it would be one way to solve the default for `let` problem but it would require duplicating the parameter declaration and default value in every memberwise init.<br></p><p>&gt; memberwise properties and @nomemberwise are too much trouble for little gain.  Hand write the init by itself will be more easy and clear.<br>&gt; <br>&gt; The fist part when the proposal focuses only on the automation of (maybe only undeclared) variables on init using &quot;...&quot; placeholder as insertion point, I believe that can be a nice feature.<br>&gt; <br>&gt; <br>&gt; Em sex, 8 de jan de 2016 às 18:13, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt;&gt; Am 08.01.2016 um 19:58 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 8, 2016, at 12:56 AM, Thorsten Seitz wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you have an example of where you would want a caller to initialize a property, but then overwrite the value they provide during initialization?<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; struct StandardRect {<br>&gt;&gt;&gt;&gt;&gt;&gt;     var origin: CGPoint<br>&gt;&gt;&gt;&gt;&gt;&gt;     var size: CGSize {<br>&gt;&gt;&gt;&gt;&gt;&gt;         didSet {<br>&gt;&gt;&gt;&gt;&gt;&gt;             // ensure standardized form here<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;     memberwise init(...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         if size.width &lt; 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;             origin.x += size.width<br>&gt;&gt;&gt;&gt;&gt;&gt;             size.width = -size.width<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         if size.height &lt; 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;             origin.y += size.height<br>&gt;&gt;&gt;&gt;&gt;&gt;             size.height = -size.height<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; This is a good example.  Thanks!  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Actually I do not like this example for several reasons: (1) I would make the rectangle an immutable type with let properties, (2) the didSet already seems to do what is encoded in the memberwise init, so this seems to be redundant, (3) the memberwise init is so complex that having the automatic initialization feature is not really worth it for this example, especially as it seems to require using var properties instead of let properties to do the overwriting.<br>&gt;&gt;  <br>&gt;&gt; 1) Why would you make it immutable? That helps nothing and only serves to make the type harder to use. Structs should _rarely_ be immutable, you should always default to mutable and only make things immutable if there&#39;s a good reason for it. If the struct itself is in an immutable position then it inherits the immutability, which handles all of the reasons why you might otherwise default to immutable.<br>&gt; <br>&gt; Hmm, food for thought… guess I still haven’t completely understood Swift’s handling of immutability… thanks for pointing that out!<br>&gt; <br>&gt;&gt; 2) didSet isn&#39;t triggered in init. There&#39;s no redundancy.<br>&gt; <br>&gt; You are right, of course. I forgot that when I wrote the mail.<br>&gt; <br>&gt;&gt; 3) You really really want var properties anyway, it&#39;s pointless to use let properties.<br>&gt;&gt;&gt;&gt;&gt; I think cases like this will be rare so I still think a warning is a good idea.  Something like -Wno-overwrite-memberwise-init would allow it to be suppressed in cases where you actually do intend to do this.  Would that satisfy you?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on perfectly legal code to be passing a flag to the swiftc invocation. Especially because we have no precedent yet for even having flags like that.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; What&#39;s wrong with the suggestion to make the warning behave the same way as dead store warnings (e.g. warn if the property is overwritten without any prior reads)? We already have logic for doing this kind of analysis.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think this would not be sufficient, because this would not allow overwriting a property based on the value of another property which might be necessary as well.<br>&gt;&gt;  <br>&gt;&gt; That seems much less likely to be necessary, because if you&#39;re doing that, then you&#39;re completely ignoring one of your parameters.<br>&gt;&gt;  <br>&gt;&gt;&gt; Actually isn’t this what happens in your example? The property origin is overwritten without being read, so this would generate the warning, or did I understand something wrong?<br>&gt;&gt;  <br>&gt;&gt; Origin is being modified. Modification reads it first. `x += 2` reads `x` before writing to it.<br>&gt; <br>&gt; I stand corrected.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/7d8c5ff9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January  9, 2016 at 03:00:00am</p></header><div class="content"><p>&quot;<br>This is not allowed under the proposal.  If you declare a parameter with an<br>external label matching a synthesized parameter an error will result.<br>Allowing it would be one way to solve the default for `let` problem but it<br>would require duplicating the parameter declaration and default value in<br>every memberwise init.<br>&quot;<br></p><p>Possibly you can then rethink this issue. Is more simpler than a new<br>operator. Also I see no reason to duplicate the parameter declaration in<br>other memberwise init. Less is more.<br></p><p><br>Em sex, 8 de jan de 2016 às 21:09, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>escreveu:<br></p><p>&gt; On Jan 8, 2016, at 2:40 PM, Wallacy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like the idea of the proposal (not 100%) but i really dislike the<br>&gt; &quot;Future enhancements&quot; part:<br>&gt;<br>&gt; *@default* is unnecessary in my opinion, i think just write the &quot;future&quot;<br>&gt; variable declaration (&quot;memberwised&quot;) and put the default value is enough:<br>&gt;<br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int<br>&gt;<br>&gt;     // user declares:<br>&gt;     memberwise init(s: String = &quot;hello&quot;,...) {}<br>&gt;<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int) { // because s: String matches the sintaxe, so the compiler will not (re)synthesize.<br>&gt;         /* synthesized */ self.s = s<br>&gt;         /* synthesized */ self.i = i<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; This is not allowed under the proposal.  If you declare a parameter with<br>&gt; an external label matching a synthesized parameter an error will result.<br>&gt; Allowing it would be one way to solve the default for `let` problem but it<br>&gt; would require duplicating the parameter declaration and default value in<br>&gt; every memberwise init.<br>&gt;<br>&gt; *memberwise properties* and *@nomemberwise* are too much trouble for<br>&gt; little gain.  Hand write the init by itself will be more easy and clear.<br>&gt;<br>&gt; The fist part when the proposal focuses only on the automation of (maybe<br>&gt; only undeclared) variables on init using &quot;...&quot; placeholder as insertion<br>&gt; point, I believe that can be a nice feature.<br>&gt;<br>&gt;<br>&gt; Em sex, 8 de jan de 2016 às 18:13, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; escreveu:<br>&gt;<br>&gt;&gt; Am 08.01.2016 um 19:58 schrieb Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 8, 2016, at 12:56 AM, Thorsten Seitz wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;<br>&gt;&gt; Do you have an example of where you would want a caller to initialize a<br>&gt;&gt; property, but then overwrite the value they provide *during<br>&gt;&gt; initialization*?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, how about something like a Rect type that always guarantees it&#39;s in<br>&gt;&gt; &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;<br>&gt;&gt; struct StandardRect {<br>&gt;&gt;     var origin: CGPoint<br>&gt;&gt;     var size: CGSize {<br>&gt;&gt;         didSet {<br>&gt;&gt;             // ensure standardized form here<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     memberwise init(...) {<br>&gt;&gt;         if size.width &lt; 0 {<br>&gt;&gt;             origin.x += size.width<br>&gt;&gt;             size.width = -size.width<br>&gt;&gt;         }<br>&gt;&gt;         if size.height &lt; 0 {<br>&gt;&gt;             origin.y += size.height<br>&gt;&gt;             size.height = -size.height<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is a good example.  Thanks!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually I do not like this example for several reasons: (1) I would make<br>&gt;&gt; the rectangle an immutable type with let properties, (2) the didSet already<br>&gt;&gt; seems to do what is encoded in the memberwise init, so this seems to be<br>&gt;&gt; redundant, (3) the memberwise init is so complex that having the automatic<br>&gt;&gt; initialization feature is not really worth it for this example, especially<br>&gt;&gt; as it seems to require using var properties instead of let properties to do<br>&gt;&gt; the overwriting.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 1) Why would you make it immutable? That helps nothing and only serves to<br>&gt;&gt; make the type harder to use. Structs should _rarely_ be immutable, you<br>&gt;&gt; should always default to mutable and only make things immutable if there&#39;s<br>&gt;&gt; a good reason for it. If the struct itself is in an immutable position then<br>&gt;&gt; it inherits the immutability, which handles all of the reasons why you<br>&gt;&gt; might otherwise default to immutable.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hmm, food for thought… guess I still haven’t completely understood<br>&gt;&gt; Swift’s handling of immutability… thanks for pointing that out!<br>&gt;&gt;<br>&gt;&gt; 2) didSet isn&#39;t triggered in init. There&#39;s no redundancy.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You are right, of course. I forgot that when I wrote the mail.<br>&gt;&gt;<br>&gt;&gt; 3) You really really want var properties anyway, it&#39;s pointless to use<br>&gt;&gt; let properties.<br>&gt;&gt;<br>&gt;&gt; I think cases like this will be rare so I still think a warning is a good<br>&gt;&gt; idea.  Something like -Wno-overwrite-memberwise-init would allow it to be<br>&gt;&gt; suppressed in cases where you actually do intend to do this.  Would that<br>&gt;&gt; satisfy you?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on<br>&gt;&gt; perfectly legal code to be passing a flag to the swiftc invocation.<br>&gt;&gt; Especially because we have no precedent yet for even having flags like that.<br>&gt;&gt;<br>&gt;&gt; What&#39;s wrong with the suggestion to make the warning behave the same way<br>&gt;&gt; as dead store warnings (e.g. warn if the property is overwritten without<br>&gt;&gt; any prior reads)? We already have logic for doing this kind of analysis.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this would not be sufficient, because this would not allow<br>&gt;&gt; overwriting a property based on the value of another property which might<br>&gt;&gt; be necessary as well.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That seems much less likely to be necessary, because if you&#39;re doing<br>&gt;&gt; that, then you&#39;re completely ignoring one of your parameters.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually isn’t this what happens in your example? The property origin is<br>&gt;&gt; overwritten without being read, so this would generate the warning, or did<br>&gt;&gt; I understand something wrong?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Origin is being modified. Modification reads it first. `x += 2` reads `x`<br>&gt;&gt; before writing to it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I stand corrected.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/64072862/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>This proposal recalls me some Java memory. How about to borrow the instance<br>fields init-expo and initializer rule and save one keyword.<br></p><p>Java language has class initializer and instance initializer:<br>class MyClass {<br>  private static String classField = &quot;foo&quot;;<br>  private String instanceField = &quot;bar&quot;;<br>  static { ... } // class initalizer<br>  { ... }<br>  MyClass() { } // constructor<br>}<br></p><p>init expr of class fields will be combined with class initializer, it will<br>be called when class is loading.<br></p><p>init expr of instance fields will be combined with instance initializer and<br>be called by every constructor.<br></p><p><br>On Sat, Jan 9, 2016 at 11:00 AM, Wallacy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &quot;<br>&gt; This is not allowed under the proposal.  If you declare a parameter with<br>&gt; an external label matching a synthesized parameter an error will result.<br>&gt; Allowing it would be one way to solve the default for `let` problem but it<br>&gt; would require duplicating the parameter declaration and default value in<br>&gt; every memberwise init.<br>&gt; &quot;<br>&gt;<br>&gt; Possibly you can then rethink this issue. Is more simpler than a new<br>&gt; operator. Also I see no reason to duplicate the parameter declaration in<br>&gt; other memberwise init. Less is more.<br>&gt;<br>&gt;<br>&gt; Em sex, 8 de jan de 2016 às 21:09, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; escreveu:<br>&gt;<br>&gt;&gt; On Jan 8, 2016, at 2:40 PM, Wallacy via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like the idea of the proposal (not 100%) but i really dislike the<br>&gt;&gt; &quot;Future enhancements&quot; part:<br>&gt;&gt;<br>&gt;&gt; *@default* is unnecessary in my opinion, i think just write the &quot;future&quot;<br>&gt;&gt; variable declaration (&quot;memberwised&quot;) and put the default value is enough:<br>&gt;&gt;<br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt;<br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(s: String = &quot;hello&quot;,...) {}<br>&gt;&gt;<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int) { // because s: String matches the sintaxe, so the compiler will not (re)synthesize.<br>&gt;&gt;         /* synthesized */ self.s = s<br>&gt;&gt;         /* synthesized */ self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is not allowed under the proposal.  If you declare a parameter with<br>&gt;&gt; an external label matching a synthesized parameter an error will result.<br>&gt;&gt; Allowing it would be one way to solve the default for `let` problem but it<br>&gt;&gt; would require duplicating the parameter declaration and default value in<br>&gt;&gt; every memberwise init.<br>&gt;&gt;<br>&gt;&gt; *memberwise properties* and *@nomemberwise* are too much trouble for<br>&gt;&gt; little gain.  Hand write the init by itself will be more easy and clear.<br>&gt;&gt;<br>&gt;&gt; The fist part when the proposal focuses only on the automation of (maybe<br>&gt;&gt; only undeclared) variables on init using &quot;...&quot; placeholder as insertion<br>&gt;&gt; point, I believe that can be a nice feature.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Em sex, 8 de jan de 2016 às 18:13, Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt;<br>&gt;&gt;&gt; Am 08.01.2016 um 19:58 schrieb Kevin Ballard via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Jan 8, 2016, at 12:56 AM, Thorsten Seitz wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 08.01.2016 um 00:41 schrieb Kevin Ballard via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jan 7, 2016, at 03:11 PM, Matthew Johnson wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 7, 2016, at 3:31 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jan 7, 2016, at 07:12 AM, Matthew Johnson wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do you have an example of where you would want a caller to initialize a<br>&gt;&gt;&gt; property, but then overwrite the value they provide *during<br>&gt;&gt;&gt; initialization*?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sure, how about something like a Rect type that always guarantees it&#39;s<br>&gt;&gt;&gt; in &quot;standard&quot; form (e.g. no negative sizes):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct StandardRect {<br>&gt;&gt;&gt;     var origin: CGPoint<br>&gt;&gt;&gt;     var size: CGSize {<br>&gt;&gt;&gt;         didSet {<br>&gt;&gt;&gt;             // ensure standardized form here<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     memberwise init(...) {<br>&gt;&gt;&gt;         if size.width &lt; 0 {<br>&gt;&gt;&gt;             origin.x += size.width<br>&gt;&gt;&gt;             size.width = -size.width<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         if size.height &lt; 0 {<br>&gt;&gt;&gt;             origin.y += size.height<br>&gt;&gt;&gt;             size.height = -size.height<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a good example.  Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually I do not like this example for several reasons: (1) I would<br>&gt;&gt;&gt; make the rectangle an immutable type with let properties, (2) the didSet<br>&gt;&gt;&gt; already seems to do what is encoded in the memberwise init, so this seems<br>&gt;&gt;&gt; to be redundant, (3) the memberwise init is so complex that having the<br>&gt;&gt;&gt; automatic initialization feature is not really worth it for this example,<br>&gt;&gt;&gt; especially as it seems to require using var properties instead of let<br>&gt;&gt;&gt; properties to do the overwriting.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) Why would you make it immutable? That helps nothing and only serves<br>&gt;&gt;&gt; to make the type harder to use. Structs should _rarely_ be immutable, you<br>&gt;&gt;&gt; should always default to mutable and only make things immutable if there&#39;s<br>&gt;&gt;&gt; a good reason for it. If the struct itself is in an immutable position then<br>&gt;&gt;&gt; it inherits the immutability, which handles all of the reasons why you<br>&gt;&gt;&gt; might otherwise default to immutable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hmm, food for thought… guess I still haven’t completely understood<br>&gt;&gt;&gt; Swift’s handling of immutability… thanks for pointing that out!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) didSet isn&#39;t triggered in init. There&#39;s no redundancy.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You are right, of course. I forgot that when I wrote the mail.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) You really really want var properties anyway, it&#39;s pointless to use<br>&gt;&gt;&gt; let properties.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think cases like this will be rare so I still think a warning is a<br>&gt;&gt;&gt; good idea.  Something like -Wno-overwrite-memberwise-init would allow it to<br>&gt;&gt;&gt; be suppressed in cases where you actually do intend to do this.  Would that<br>&gt;&gt;&gt; satisfy you?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No. It&#39;s not appropriate to have the only way to suppress a warning on<br>&gt;&gt;&gt; perfectly legal code to be passing a flag to the swiftc invocation.<br>&gt;&gt;&gt; Especially because we have no precedent yet for even having flags like that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s wrong with the suggestion to make the warning behave the same way<br>&gt;&gt;&gt; as dead store warnings (e.g. warn if the property is overwritten without<br>&gt;&gt;&gt; any prior reads)? We already have logic for doing this kind of analysis.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this would not be sufficient, because this would not allow<br>&gt;&gt;&gt; overwriting a property based on the value of another property which might<br>&gt;&gt;&gt; be necessary as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That seems much less likely to be necessary, because if you&#39;re doing<br>&gt;&gt;&gt; that, then you&#39;re completely ignoring one of your parameters.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually isn’t this what happens in your example? The property origin is<br>&gt;&gt;&gt; overwritten without being read, so this would generate the warning, or did<br>&gt;&gt;&gt; I understand something wrong?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Origin is being modified. Modification reads it first. `x += 2` reads<br>&gt;&gt;&gt; `x` before writing to it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I stand corrected.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/b6707c07/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>I like the general notion of something along these lines but admittedly haven’t had time to dig into the proposal specifics yet.<br></p><p>I have some concerns about cross-interactions with other features that are either also under discussion or are at least very anticipatable.<br></p><p>First, I know there has already been some discussion of allowing definition of stored fields in (some) extensions (e.g., something like allowing definition of stored fields in extensions within the module that defines the type).<br></p><p>E.G., something like this may become possible (assume all files are compiled together):<br></p><p>    // in `ComplicatedClass.swift`<br>    class ComplicatedClass {<br>      let text: String<br>      <br>      // how will this get expanded,<br>      // given the extensions below?<br>      memberwise init(...)<br>    }<br>    <br>    // in `ComplicatedClass+Foo.swift`<br>    extension ComplicatedClass {<br>      var fooData: Foo? = nil<br>      // presumably stuff-involving-`fooData`<br>    }<br>    <br>    // in `ComplicatedClass+Bar.swift`<br>    extension ComplicatedClass {<br>      var barData: Bar = Bar.standardBar<br>      // presumably stuff-involving-`barData`<br>    }<br></p><p>It doesn&#39;t seem impossible to specify how the memberwise-initialization would interact with constructs like the above, but I&#39;d worry a bit about it making a feature that&#39;s already looking *rather* complicated even more so.<br></p><p>Especially since, if I had to pick just one, I&#39;d think the ability to define stored properties outside the initial definition is a bigger win than a nice memberwise-initialization construct, even though both seem handy.<br></p><p>Secondly, I’m a bit unsure how this will interact with e.g. the property-behavior proposal if both wind up ratified. For `lazy`, the interaction with `memberwise` is easy — it is omitted from the list — but when you get into e.g. something like a hypothetical `logged` or `synchronized` or `atomic` — wherein there is custom behavior, but the field would still need initialization — you’d want them to be included in the `memberwise` init.<br></p><p>It’s a bit unfair to bring up another proposal, but this proposal and something like the property-behavior proposal *would* need to work well together (if both are approved).<br></p><p>Thirdly, I’m not sure what the current plans are (if any) for users to be able to specify the precise memory-layout of a struct; apologies if this is already a feature, I simply haven’t looked into it.<br></p><p>**Today**: I order stored-field declarations for ease-of-reading (e.g. grouped into logical groups, and organized for ease-of-reading).<br></p><p>**Under Proposal**: I sometimes will get to choose between the “ease-of-reading” declaration ordering and the “cleanest-reading memberwise init” declaration ordering. These may not always be identical.<br></p><p>**Future?**: I may have to choose between the “ease-of-reading” declaration ordering, the “cleanest-reading member wise init” declaration ordering, and (perhaps?) the “intended memory-layout” declaration ordering.<br></p><p>I don’t want to make this proposal more-complicated than it already is, but I worry a bit about having too many things impacting the choice of how to order declarations in source files; it may be better to include a way to explicitly declare the ordering-for-memberwise:<br></p><p>E.G., some way of explicitly indicating the memberwise ordering, perhaps like this:<br></p><p>    // syntax example re-using `ComplicatedClass`<br>    class ComplicatedClass  {<br>      @memberwise($parameterList)<br>      // ^ can use just @memberwise to get default ordering + the defaults from<br>      //   the property declarations, but perhaps require the explicit listing<br>      //   whenver the ordering is not well-defined (e.g. if you have properties<br>      //   declared in extensions…then you need to order it yourself)<br>      // <br>      //   @memberwise(text=&quot;Example&quot;,barData=,fooData)<br>      //   - `text=&quot;Example&quot;` =&gt; memberwise init has text=&quot;Example&quot;<br>      //   - `barData=` =&gt; memberwise init has `barData` w/out default<br>      //   - `fooData` =&gt; memberwise init has `fooData` w/default if it has one<br>      //<br>      //   …and e.g. the above would make:<br>      //<br>      //   memberwise init(...)<br>      //<br>      //   ...expand-to:<br>      // <br>      //   init(text:String = &quot;Example&quot;, barData: Bar, fooData:Foo?=nil)<br>      //<br>      //   ...and with the @memberwise declaration supporting a `...` for `super`<br>      //   placement, like so:<br>      //<br>      //   // superclass members come before:<br>      //   @memberwise(...,)<br>      //   @memberwise(...,$parameterList)<br>      //<br>      //   // superclass members come after      <br>      //   @memberwise(,...)<br>      //   @memberwise($parameterList,...)<br>      //<br>      //   ...perhaps with tweaked syntax (`@memberwise(...,$)` or `@memberwise(...,self)`)<br>      //   to be bit easier to read when you don&#39;t have an explicit parameter list?<br>    }<br></p><p>...which of course potentially only-further complicates the feature in some ways, but avoids having this use of this feature *necessarily* impact how one might choose to order declarations?<br></p><p>&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:02 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the general notion of something along these lines but admittedly haven’t had time to dig into the proposal specifics yet.<br>&gt; <br>&gt; I have some concerns about cross-interactions with other features that are either also under discussion or are at least very anticipatable.<br>&gt; <br>&gt; First, I know there has already been some discussion of allowing definition of stored fields in (some) extensions (e.g., something like allowing definition of stored fields in extensions within the module that defines the type).<br>&gt; <br>&gt; E.G., something like this may become possible (assume all files are compiled together):<br>&gt; <br>&gt;    // in `ComplicatedClass.swift`<br>&gt;    class ComplicatedClass {<br>&gt;      let text: String<br>&gt; <br>&gt;      // how will this get expanded,<br>&gt;      // given the extensions below?<br>&gt;      memberwise init(...)<br>&gt;    }<br>&gt; <br>&gt;    // in `ComplicatedClass+Foo.swift`<br>&gt;    extension ComplicatedClass {<br>&gt;      var fooData: Foo? = nil<br>&gt;      // presumably stuff-involving-`fooData`<br>&gt;    }<br>&gt; <br>&gt;    // in `ComplicatedClass+Bar.swift`<br>&gt;    extension ComplicatedClass {<br>&gt;      var barData: Bar = Bar.standardBar<br>&gt;      // presumably stuff-involving-`barData`<br>&gt;    }<br>&gt; <br>&gt; It doesn&#39;t seem impossible to specify how the memberwise-initialization would interact with constructs like the above, but I&#39;d worry a bit about it making a feature that&#39;s already looking *rather* complicated even more so.<br>&gt; <br>&gt; Especially since, if I had to pick just one, I&#39;d think the ability to define stored properties outside the initial definition is a bigger win than a nice memberwise-initialization construct, even though both seem handy.<br></p><p>I followed the stored-properties-in-extensions discussion reasonably closely.  My understanding is that the extension will need to initialize its own properties, either with an initial value or with a `partial init`.  Designated initializers would be required to call the `partial init` for any extension that defines one.<br></p><p>This being the case, memberwise initialization would not directly interact with this feature at all.  Memberwise initializers declared in the main body of type itself would only expose stored properties defined in the type itself.  <br></p><p>It would also be possible to support `partial memberwise init` in extensions which would expose the stored properties declared in the extension as part of a partial initializer.<br></p><p>I don’t think there are difficult complications here.<br></p><p>&gt; <br>&gt; Secondly, I’m a bit unsure how this will interact with e.g. the property-behavior proposal if both wind up ratified. For `lazy`, the interaction with `memberwise` is easy — it is omitted from the list — but when you get into e.g. something like a hypothetical `logged` or `synchronized` or `atomic` — wherein there is custom behavior, but the field would still need initialization — you’d want them to be included in the<br>&gt; `memberwise` init.<br></p><p>My thought here is that a behavior would define whether a property allows and / or requires initialization in phase 1 or not.  This is probably necessary independent of memberwise initialization.  Properties that allow or require phase 1 initialization would be eligible for memberwise initialization.  Properties that don’t allow phase 1 initialization would not be eligible for memberwise initialization.<br></p><p>&gt; <br>&gt; It’s a bit unfair to bring up another proposal, but this proposal and something like the property-behavior proposal *would* need to work well together (if both are approved).<br></p><p>Agreed.  That is why there is a rule that references property behaviors in the proposal.<br></p><p>&gt; <br>&gt; Thirdly, I’m not sure what the current plans are (if any) for users to be able to specify the precise memory-layout of a struct; apologies if this is already a feature, I simply haven’t looked into it.<br>&gt; <br>&gt; **Today**: I order stored-field declarations for ease-of-reading (e.g. grouped into logical groups, and organized for ease-of-reading).<br>&gt; <br>&gt; **Under Proposal**: I sometimes will get to choose between the “ease-of-reading” declaration ordering and the “cleanest-reading memberwise init” declaration ordering. These may not always be identical.<br></p><p>Agree.  This is something that could be addressed in a future enhancement if necessary.  This proposal is focused on the basic mechanism.<br></p><p>Also, nothing in the proposal prevents you from continuing to write a manual initializer when the synthesized initializer will not do what you require.  If you are already explicitly restating the property identifiers to specify parameter order you are already half way to a manual initializer implementation.  <br></p><p>Granted, if you need more than one memberwise initializer you would have to duplicate that effort.  But re-ordering is going to have a hard time providing enough value if the basic feature does what we need in the majority of cases.<br></p><p><br>&gt; <br>&gt; **Future?**: I may have to choose between the “ease-of-reading” declaration ordering, the “cleanest-reading member wise init” declaration ordering, and (perhaps?) the “intended memory-layout” declaration ordering.<br>&gt; <br>&gt; I don’t want to make this proposal more-complicated than it already is, but I worry a bit about having too many things impacting the choice of how to order declarations in source files; it may be better to include a way to explicitly declare the ordering-for-memberwise:<br>&gt; <br>&gt; E.G., some way of explicitly indicating the memberwise ordering, perhaps like this:<br>&gt; <br>&gt;    // syntax example re-using `ComplicatedClass`<br>&gt;    class ComplicatedClass  {<br>&gt;      @memberwise($parameterList)<br>&gt;      // ^ can use just @memberwise to get default ordering + the defaults from<br>&gt;      //   the property declarations, but perhaps require the explicit listing<br>&gt;      //   whenver the ordering is not well-defined (e.g. if you have properties<br>&gt;      //   declared in extensions…then you need to order it yourself)<br>&gt;      // <br>&gt;      //   @memberwise(text=&quot;Example&quot;,barData=,fooData)<br>&gt;      //   - `text=&quot;Example&quot;` =&gt; memberwise init has text=&quot;Example&quot;<br>&gt;      //   - `barData=` =&gt; memberwise init has `barData` w/out default<br>&gt;      //   - `fooData` =&gt; memberwise init has `fooData` w/default if it has one<br>&gt;      //<br>&gt;      //   …and e.g. the above would make:<br>&gt;      //<br>&gt;      //   memberwise init(...)<br>&gt;      //<br>&gt;      //   ...expand-to:<br>&gt;      // <br>&gt;      //   init(text:String = &quot;Example&quot;, barData: Bar, fooData:Foo?=nil)<br>&gt;      //<br>&gt;      //   ...and with the @memberwise declaration supporting a `...` for `super`<br>&gt;      //   placement, like so:<br>&gt;      //<br>&gt;      //   // superclass members come before:<br>&gt;      //   @memberwise(...,)<br>&gt;      //   @memberwise(...,$parameterList)<br>&gt;      //<br>&gt;      //   // superclass members come after      <br>&gt;      //   @memberwise(,...)<br>&gt;      //   @memberwise($parameterList,...)<br>&gt;      //<br>&gt;      //   ...perhaps with tweaked syntax (`@memberwise(...,$)` or `@memberwise(...,self)`)<br>&gt;      //   to be bit easier to read when you don&#39;t have an explicit parameter list?<br>&gt;    }<br>&gt; <br>&gt; ...which of course potentially only-further complicates the feature in some ways, but avoids having this use of this feature *necessarily* impact how one might choose to order declarations?<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>After reading both your response below and also the proposal rather carefully, I agree that the possible issues I raised are all either not real issues or already addressed; thanks again for crafting the proposal and also for taking the time to reply to so much feedback.<br></p><p>That being said, I can’t shake a feeling that, overall, although I am definitely in favor of something along the lines of this proposal, in its concrete details at present this proposal isn’t really sitting anywhere near even a local-optimum on the `(flexibility,complexity) -&gt; functionality` surface, as it were; it seems like both of these are possible:<br></p><p>- (a) make it a bit more flexible, for a high gain in functionality at a low incremental cost in complexity<br>- (b) make it a bit less flexible, for a modest loss in functionality and a large drop in complexity<br></p><p>…but for (b) it’s just a feeling and I don’t have a specific proposal (this may well be close to a minimum-viable-proposal for such a feature).<br></p><p>For (a) my sense is that although I can understand why you don’t want to even provide the option of specifying an explicit memberwise-parameter list, it really does seem that supporting at least an optional list makes it possible to get a lot more functionality for not much more *actual* complexity; this isn’t incompatible with also supporting an “automatic” option that uses the logic from the proposal where possible.<br></p><p>Here’s a concrete example to illustrate why I’m harping on this point; I apologize for the length, but I think “small-n” examples can often give false intuition into how things will behave in real life:<br></p><p>class FancyCollectionViewDriver : NSObject, UICollectionViewDataSource, UICollectionViewDelegate /*, etc... */ {<br>  <br>  let collectionView: UICollectionView<br>  let contentPresentation: ContentPresentation  <br>  let modelBroker: ModelBroker<br>  let imageBroker: ImageBroker<br>  let analyticsSink: AnalyticsSink<br>  private(set) var currentData: ModelData<br>  private(set) weak var interactionDelegate: DriverDelegateProtocol?<br>  // ^ can&#39;t be non-optional `unowned let` for reasons,<br>  //   but we expect a non-nil argument in init<br>  // NOTE: numerous private state-tracking variables omitted since we are only focusing on initialization<br></p><p>  // Present-day initializer, full of boilerplate:<br>  required init(<br>    collectionView: UICollectionView, <br>    contentPresentation: ContentPresentation,<br>    modelBroker: ModelBroker,<br>    imageBroker: ImageBroker,<br>    analyticsSink: AnalyticsSink,<br>    // note use of different argument name:<br>    initialData: ModelData,<br>    // note use of non-optional:<br>    interactionDelegate: DriverDelegateProtocol) {<br>      // oh boy here we go again:<br>      self.collectionView = collectionView<br>      self.contentPresentation = contentPresentation<br>      self.modelBroker = modelBroker<br>      self.imageBroker = imageBroker<br>      self.analyticsSink = analyticsSink<br>      self.currentData = initialData<br>      self.interactionDelegate = interactionDelegate<br>      super.init()<br>      // only non-assignment logic in the entire init:<br>      self.collectionView.dataSource = self<br>      self.collectionView.delegate = self<br>    }<br>    <br>    // best we can do under proposal w/out modifying <br>    // class design:<br>    required memberwise init(<br>    // lots of boilerplate gone:<br>    ..., <br>    // this isn&#39;t changed:<br>    initialData: ModelData,<br>    // this isn&#39;t changed:<br>    interactionDelegate: DriverDelegateProtocol) {<br>      // synthesized stuff is effectively here<br>      self.currentData = initialData<br>      self.interactionDelegate = interactionDelegate<br>      super.init()<br>      // only non-assignment logic in the entire init:<br>      self.collectionView.dataSource = self<br>      self.collectionView.delegate = self<br>    }<br>  <br>}<br></p><p>…which I do think is already a huge improvement. <br></p><p>Now suppose that stored-properties-in-extensions hits (as the &quot;partial-init&quot; flavor); in that case I’d ideally be able to move some of the parts into their own files like so:<br></p><p>// in `FancyCollectionViewDriver+Analytics.swift`<br>extension FancyCollectionViewDriver  {<br>  // ^ depending on advances in the protocol system, at some point may <br>  //   evolve into a protocol-adoption to get useful default implementations<br>  <br>  let analyticsReporter: AnalyticsReporter <br>  // ^ moved here, not in main declaration<br>  //   assume also a bunch of private state-tracking stuff...<br>  <br>  // a bunch of things like this:<br>  func reportEventTypeA(eventAInfo: EventAInfo)<br>  func reportEventTypeB(eventBInfo: BventAInfo)<br>  <br>}<br></p><p>// in `FancyCollectionViewDriver+Interaction.swift`<br>extension FancyCollectionViewDriver {<br>  <br>  private(set) var interactionDelegate: DriverDelegateProtocol?<br>  // ^ moved here, not in main declaration<br>  //   assume also a bunch of private state-tracking stuff...<br>  <br>  // a bunch of things like this:<br>  func handleInteractionA(interactionAInfo: InteractionAInfo)<br>  func handleInteractionB(interactionBInfo: InteractionBInfo)<br>  <br>}<br></p><p>…(and so on for e.g. the `imageBroker` also), but under the current proposal this would put them outside the scope of a memberwise init (this isn’t news to you, I’m just making it concrete).<br></p><p>So in this scenario, we’re either reapproaching the MxN problem memberwise-init is meant to avoid:<br></p><p>init(<br>  // still save some boilerplate:<br>  …, <br>  imageBroker: ImageBroker,<br>  analyticsReporter: AnalyticsReporter, <br>  initialData: ModelData, <br>  interactionDelegate: DriverDelegateProtocol) {<br>  // some boilerplate synththesized here...<br>  // ...but getting closer to where we started:<br>  self.partial_init(imageBroker: imageBroker)<br>  self.partial_init(analyticsReporter: analyticsReporter)<br>  self.currentData = modelData<br>  self.partial_init(interactionDelegate: interactionDelegate)  <br>  super.init()<br>  self.collectionView.dataSource = self<br>  self.collectionView.delegate = self<br>}<br></p><p>…or we’re making choices between taking full-advantage of properties-in-extensions (which IMHO would often be a *huge* readability win) versus taking full-advantage of boilerplate-reduction in our inits.<br></p><p>Which is ultimately why I suspect that the “right&quot; version of the proposed feature should cut to the chase and incorporate some way to explicitly-specify the memberwise parameter list — which, again, need not be incompatible with the ability to request automatic synthesis using logic ~ what’s in the proposal — as such an explicit list takes the pressure off of getting the default behavior as-right-as-possible while also making it simpler to support some very nice-to-have capabilities not supported by this proposal as-written.<br></p><p>That’s my 2c; thanks to anyone who’s read through all this and thanks again for drafting a concrete-enough proposal to discuss properly.<br></p><p>&gt; On Jan 7, 2016, at 9:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:02 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the general notion of something along these lines but admittedly haven’t had time to dig into the proposal specifics yet.<br>&gt;&gt; <br>&gt;&gt; I have some concerns about cross-interactions with other features that are either also under discussion or are at least very anticipatable.<br>&gt;&gt; <br>&gt;&gt; First, I know there has already been some discussion of allowing definition of stored fields in (some) extensions (e.g., something like allowing definition of stored fields in extensions within the module that defines the type).<br>&gt;&gt; <br>&gt;&gt; E.G., something like this may become possible (assume all files are compiled together):<br>&gt;&gt; <br>&gt;&gt;   // in `ComplicatedClass.swift`<br>&gt;&gt;   class ComplicatedClass {<br>&gt;&gt;     let text: String<br>&gt;&gt; <br>&gt;&gt;     // how will this get expanded,<br>&gt;&gt;     // given the extensions below?<br>&gt;&gt;     memberwise init(...)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // in `ComplicatedClass+Foo.swift`<br>&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;     var fooData: Foo? = nil<br>&gt;&gt;     // presumably stuff-involving-`fooData`<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // in `ComplicatedClass+Bar.swift`<br>&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;     var barData: Bar = Bar.standardBar<br>&gt;&gt;     // presumably stuff-involving-`barData`<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; It doesn&#39;t seem impossible to specify how the memberwise-initialization would interact with constructs like the above, but I&#39;d worry a bit about it making a feature that&#39;s already looking *rather* complicated even more so.<br>&gt;&gt; <br>&gt;&gt; Especially since, if I had to pick just one, I&#39;d think the ability to define stored properties outside the initial definition is a bigger win than a nice memberwise-initialization construct, even though both seem handy.<br>&gt; <br>&gt; I followed the stored-properties-in-extensions discussion reasonably closely.  My understanding is that the extension will need to initialize its own properties, either with an initial value or with a `partial init`.  Designated initializers would be required to call the `partial init` for any extension that defines one.<br>&gt; <br>&gt; This being the case, memberwise initialization would not directly interact with this feature at all.  Memberwise initializers declared in the main body of type itself would only expose stored properties defined in the type itself.  <br>&gt; <br>&gt; It would also be possible to support `partial memberwise init` in extensions which would expose the stored properties declared in the extension as part of a partial initializer.<br>&gt; <br>&gt; I don’t think there are difficult complications here.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Secondly, I’m a bit unsure how this will interact with e.g. the property-behavior proposal if both wind up ratified. For `lazy`, the interaction with `memberwise` is easy — it is omitted from the list — but when you get into e.g. something like a hypothetical `logged` or `synchronized` or `atomic` — wherein there is custom behavior, but the field would still need initialization — you’d want them to be included in the<br>&gt;&gt; `memberwise` init.<br>&gt; <br>&gt; My thought here is that a behavior would define whether a property allows and / or requires initialization in phase 1 or not.  This is probably necessary independent of memberwise initialization.  Properties that allow or require phase 1 initialization would be eligible for memberwise initialization. Properties that don’t allow phase 1 initialization would not be eligible for memberwise initialization.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It’s a bit unfair to bring up another proposal, but this proposal and something like the property-behavior proposal *would* need to work well together (if both are approved).<br>&gt; <br>&gt; Agreed.  That is why there is a rule that references property behaviors in the proposal.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thirdly, I’m not sure what the current plans are (if any) for users to be able to specify the precise memory-layout of a struct; apologies if this is already a feature, I simply haven’t looked into it.<br>&gt;&gt; <br>&gt;&gt; **Today**: I order stored-field declarations for ease-of-reading (e.g. grouped into logical groups, and organized for ease-of-reading).<br>&gt;&gt; <br>&gt;&gt; **Under Proposal**: I sometimes will get to choose between the “ease-of-reading” declaration ordering and the “cleanest-reading memberwise init” declaration ordering. These may not always be identical.<br>&gt; <br>&gt; Agree.  This is something that could be addressed in a future enhancement if necessary.  This proposal is focused on the basic mechanism.<br>&gt; <br>&gt; Also, nothing in the proposal prevents you from continuing to write a manual initializer when the synthesized initializer will not do what you require.  If you are already explicitly restating the property identifiers to specify parameter order you are already half way to a manual initializer implementation.  <br>&gt; <br>&gt; Granted, if you need more than one memberwise initializer you would have to duplicate that effort.  But re-ordering is going to have a hard time providing enough value if the basic feature does what we need in the majority of cases.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; **Future?**: I may have to choose between the “ease-of-reading” declaration ordering, the “cleanest-reading member wise init” declaration ordering, and (perhaps?) the “intended memory-layout” declaration ordering.<br>&gt;&gt; <br>&gt;&gt; I don’t want to make this proposal more-complicated than it already is, but I worry a bit about having too many things impacting the choice of how to order declarations in source files; it may be better to include a way to explicitly declare the ordering-for-memberwise:<br>&gt;&gt; <br>&gt;&gt; E.G., some way of explicitly indicating the memberwise ordering, perhaps like this:<br>&gt;&gt; <br>&gt;&gt;   // syntax example re-using `ComplicatedClass`<br>&gt;&gt;   class ComplicatedClass  {<br>&gt;&gt;     @memberwise($parameterList)<br>&gt;&gt;     // ^ can use just @memberwise to get default ordering + the defaults from<br>&gt;&gt;     //   the property declarations, but perhaps require the explicit listing<br>&gt;&gt;     //   whenver the ordering is not well-defined (e.g. if you have properties<br>&gt;&gt;     //   declared in extensions…then you need to order it yourself)<br>&gt;&gt;     // <br>&gt;&gt;     //   @memberwise(text=&quot;Example&quot;,barData=,fooData)<br>&gt;&gt;     //   - `text=&quot;Example&quot;` =&gt; memberwise init has text=&quot;Example&quot;<br>&gt;&gt;     //   - `barData=` =&gt; memberwise init has `barData` w/out default<br>&gt;&gt;     //   - `fooData` =&gt; memberwise init has `fooData` w/default if it has one<br>&gt;&gt;     //<br>&gt;&gt;     //   …and e.g. the above would make:<br>&gt;&gt;     //<br>&gt;&gt;     //   memberwise init(...)<br>&gt;&gt;     //<br>&gt;&gt;     //   ...expand-to:<br>&gt;&gt;     // <br>&gt;&gt;     //   init(text:String = &quot;Example&quot;, barData: Bar, fooData:Foo?=nil)<br>&gt;&gt;     //<br>&gt;&gt;     //   ...and with the @memberwise declaration supporting a `...` for `super`<br>&gt;&gt;     //   placement, like so:<br>&gt;&gt;     //<br>&gt;&gt;     //   // superclass members come before:<br>&gt;&gt;     //   @memberwise(...,)<br>&gt;&gt;     //   @memberwise(...,$parameterList)<br>&gt;&gt;     //<br>&gt;&gt;     //   // superclass members come after      <br>&gt;&gt;     //   @memberwise(,...)<br>&gt;&gt;     //   @memberwise($parameterList,...)<br>&gt;&gt;     //<br>&gt;&gt;     //   ...perhaps with tweaked syntax (`@memberwise(...,$)` or `@memberwise(...,self)`)<br>&gt;&gt;     //   to be bit easier to read when you don&#39;t have an explicit parameter list?<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; ...which of course potentially only-further complicates the feature in some ways, but avoids having this use of this feature *necessarily* impact how one might choose to order declarations?<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/ae444791/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 9:46 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After reading both your response below and also the proposal rather carefully, I agree that the possible issues I raised are all either not real issues or already addressed; thanks again for crafting the proposal and also for taking the time to reply to so much feedback.<br>&gt; <br>&gt; That being said, I can’t shake a feeling that, overall, although I am definitely in favor of something along the lines of this proposal, in its concrete details at present this proposal isn’t really sitting anywhere near even a local-optimum on the `(flexibility,complexity) -&gt; functionality` surface, as it were; it seems like both of these are possible:<br>&gt; <br>&gt; - (a) make it a bit more flexible, for a high gain in functionality at a low incremental cost in complexity<br>&gt; - (b) make it a bit less flexible, for a modest loss in functionality and a large drop in complexity<br>&gt; <br>&gt; …but for (b) it’s just a feeling and I don’t have a specific proposal (this may well be close to a minimum-viable-proposal for such a feature).<br></p><p>I agree with you.  <br></p><p>As for (b) some people have suggested alternatives with less functionality like David’s `self propName: PropType` suggestion.  So far I don’t think any of those add enough value over current state to be worth considering.<br></p><p>&gt; <br>&gt; For (a) my sense is that although I can understand why you don’t want to even provide the option of specifying an explicit memberwise-parameter list, it really does seem that supporting at least an optional list makes it possible to get a lot more functionality for not much more *actual* complexity; this isn’t incompatible with also supporting an “automatic” option that uses the logic from the proposal where possible.<br></p><p>In terms of (a), I definitely agree that it would be desirable to allow for a bit more functionality.  That is why I have suggested several enhancements.  I don’t think we want all of them, but some are definitely desirable.  <br></p><p>Chris really wanted to start with a core proposal and evaluate the enhancements independently, which is a good idea but also makes the proposal slightly less flexible than desirable.  The enhancements I feel are most important are:<br></p><p>1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>2. We need a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.  I think allowing distinct access control for `init` is the best way to handle this.<br></p><p>You mention specifying an explicit parameter list but don’t really elaborate further.  Would the opt-in model described in the proposal meet what you have in mind?  Or are you also consider with parameter order being independent of property declaration order?<br></p><p>Your example below hints at general parameter forwarding.  I’ll elaborate further down.<br></p><p>&gt; <br>&gt; Here’s a concrete example to illustrate why I’m harping on this point; I apologize for the length, but I think “small-n” examples can often give false intuition into how things will behave in real life:<br></p><p>Thank you for this!  I probably should have provided at least one more concrete example myself.  I am learning from that mistake in the second draft of my next proposal.<br></p><p>&gt; <br>&gt; class FancyCollectionViewDriver : NSObject, UICollectionViewDataSource, UICollectionViewDelegate /*, etc... */ {<br>&gt;   <br>&gt;   let collectionView: UICollectionView<br>&gt;   let contentPresentation: ContentPresentation  <br>&gt;   let modelBroker: ModelBroker<br>&gt;   let imageBroker: ImageBroker<br>&gt;   let analyticsSink: AnalyticsSink<br>&gt;   private(set) var currentData: ModelData<br>&gt;   private(set) weak var interactionDelegate: DriverDelegateProtocol?<br>&gt;   // ^ can&#39;t be non-optional `unowned let` for reasons,<br>&gt;   //   but we expect a non-nil argument in init<br>&gt;   // NOTE: numerous private state-tracking variables omitted since we are only focusing on initialization<br>&gt; <br>&gt;   // Present-day initializer, full of boilerplate:<br>&gt;   required init(<br>&gt;     collectionView: UICollectionView, <br>&gt;     contentPresentation: ContentPresentation,<br>&gt;     modelBroker: ModelBroker,<br>&gt;     imageBroker: ImageBroker,<br>&gt;     analyticsSink: AnalyticsSink,<br>&gt;     // note use of different argument name:<br>&gt;     initialData: ModelData,<br>&gt;     // note use of non-optional:<br>&gt;     interactionDelegate: DriverDelegateProtocol) {<br>&gt;       // oh boy here we go again:<br>&gt;       self.collectionView = collectionView<br>&gt;       self.contentPresentation = contentPresentation<br>&gt;       self.modelBroker = modelBroker<br>&gt;       self.imageBroker = imageBroker<br>&gt;       self.analyticsSink = analyticsSink<br>&gt;       self.currentData = initialData<br>&gt;       self.interactionDelegate = interactionDelegate<br>&gt;       super.init()<br>&gt;       // only non-assignment logic in the entire init:<br>&gt;       self.collectionView.dataSource = self<br>&gt;       self.collectionView.delegate = self<br>&gt;     }<br>&gt;     <br>&gt;     // best we can do under proposal w/out modifying <br>&gt;     // class design:<br>&gt;     required memberwise init(<br>&gt;     // lots of boilerplate gone:<br>&gt;     ..., <br>&gt;     // this isn&#39;t changed:<br>&gt;     initialData: ModelData,<br>&gt;     // this isn&#39;t changed:<br>&gt;     interactionDelegate: DriverDelegateProtocol) {<br>&gt;       // synthesized stuff is effectively here<br>&gt;       self.currentData = initialData<br>&gt;       self.interactionDelegate = interactionDelegate<br>&gt;       super.init()<br>&gt;       // only non-assignment logic in the entire init:<br>&gt;       self.collectionView.dataSource = self<br>&gt;       self.collectionView.delegate = self<br>&gt;     }<br>&gt;   <br>&gt; }<br>&gt; <br>&gt; …which I do think is already a huge improvement. <br></p><p>And gets even better if we allow access control for init.  Your `private(set)` members would now become eligible for memberwise initialization in an `internal` initializer because `init` has a distinct access level which defaults to `internal`.<br>    <br>    required memberwise init(...) {<br>      // synthesized stuff is effectively here<br>      super.init()<br>      // only non-assignment logic in the entire init:<br>      self.collectionView.dataSource = self<br>      self.collectionView.delegate = self<br>    }<br></p><p>&gt; <br>&gt; Now suppose that stored-properties-in-extensions hits (as the &quot;partial-init&quot; flavor); in that case I’d ideally be able to move some of the parts into their own files like so:<br>&gt; <br>&gt; // in `FancyCollectionViewDriver+Analytics.swift`<br>&gt; extension FancyCollectionViewDriver  {<br>&gt;   // ^ depending on advances in the protocol system, at some point may <br>&gt;   //   evolve into a protocol-adoption to get useful default implementations<br>&gt;   <br>&gt;   let analyticsReporter: AnalyticsReporter <br>&gt;   // ^ moved here, not in main declaration<br>&gt;   //   assume also a bunch of private state-tracking stuff...<br>&gt;   <br>&gt;   // a bunch of things like this:<br>&gt;   func reportEventTypeA(eventAInfo: EventAInfo)<br>&gt;   func reportEventTypeB(eventBInfo: BventAInfo)<br>&gt;   <br>&gt; }<br>&gt; <br>&gt; // in `FancyCollectionViewDriver+Interaction.swift`<br>&gt; extension FancyCollectionViewDriver {<br>&gt;   <br>&gt;   private(set) var interactionDelegate: DriverDelegateProtocol?<br>&gt;   // ^ moved here, not in main declaration<br>&gt;   //   assume also a bunch of private state-tracking stuff...<br>&gt;   <br>&gt;   // a bunch of things like this:<br>&gt;   func handleInteractionA(interactionAInfo: InteractionAInfo)<br>&gt;   func handleInteractionB(interactionBInfo: InteractionBInfo)<br>&gt;   <br>&gt; }<br>&gt; <br>&gt; …(and so on for e.g. the `imageBroker` also), but under the current proposal this would put them outside the scope of a memberwise init (this isn’t news to you, I’m just making it concrete).<br>&gt; <br>&gt; So in this scenario, we’re either reapproaching the MxN problem memberwise-init is meant to avoid:<br>&gt; <br>&gt; init(<br>&gt;   // still save some boilerplate:<br>&gt;   …, <br>&gt;   imageBroker: ImageBroker,<br>&gt;   analyticsReporter: AnalyticsReporter, <br>&gt;   initialData: ModelData, <br>&gt;   interactionDelegate: DriverDelegateProtocol) {<br>&gt;   // some boilerplate synththesized here...<br>&gt;   // ...but getting closer to where we started:<br>&gt;   self.partial_init(imageBroker: imageBroker)<br>&gt;   self.partial_init(analyticsReporter: analyticsReporter)<br>&gt;   self.currentData = modelData<br>&gt;   self.partial_init(interactionDelegate: interactionDelegate)  <br>&gt;   super.init()<br>&gt;   self.collectionView.dataSource = self<br>&gt;   self.collectionView.delegate = self<br>&gt; }<br>&gt; <br>&gt; …or we’re making choices between taking full-advantage of properties-in-extensions (which IMHO would often be a *huge* readability win) versus taking full-advantage of boilerplate-reduction in our inits.<br></p><p>If extensions with stored properties are going to properly encapsulate their state (I believe this is the way to go) they are going to have to initialize state on their own and the primary initializer will have to provide arguments the initializer requires.  Allowing stored properties in extensions automatically appear in a memberwise initializer violates that encapsulation.<br></p><p>The good news is that a general parameter forwarding mechanism can help if the extension init (or super init) requires a bunch of arguments and you just want to forward them from your caller.  This is alluded to in the enhancement section of the proposal but is really a completely general and orthogonal feature.<br></p><p>It might look something like this:<br></p><p>memberwise init(…superArgs, …partial1args, …partial2args, …memberwise) {<br>	extension1.init(directArgument: 42, …partial1args)<br>	extension2.init(…partial2args)<br>	super.init(…superArgs)<br>}<br></p><p>A couple things to note about how this might work:<br></p><p>1. The initializer calls (or function / method calls in other cases) must be unambiguous from the code alone.<br>2. Any parameters for which a direct argument is not provided are “captured” by the `…identifier` placeholder. <br>3. Parameters matching those captured by the identifier are synthesized in the location specified in the parameter list.<br></p><p>Obviously this won’t help if the extensions only require a single argument.  But if you have extensions requiring several arguments that you want to pass through it would help<br></p><p>&gt; <br>&gt; Which is ultimately why I suspect that the “right&quot; version of the proposed feature should cut to the chase and incorporate some way to explicitly-specify the memberwise parameter list — which, again, need not be incompatible with the ability to request automatic synthesis using logic ~ what’s in the proposal — as such an explicit list takes the pressure off of getting the default behavior as-right-as-possible while also making it simpler to support some very nice-to-have capabilities not supported by this proposal as-written.<br></p><p>How would this be different than the opt-in model described in the proposal?  Do you have something specific in mind?<br></p><p>&gt; <br>&gt; That’s my 2c; thanks to anyone who’s read through all this and thanks again for drafting a concrete-enough proposal to discuss properly.<br></p><p>Thanks for all your feedback and your example!  I really appreciate it!<br></p><p>Matthew<br></p><p>&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:24 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 9:02 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the general notion of something along these lines but admittedly haven’t had time to dig into the proposal specifics yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have some concerns about cross-interactions with other features that are either also under discussion or are at least very anticipatable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, I know there has already been some discussion of allowing definition of stored fields in (some) extensions (e.g., something like allowing definition of stored fields in extensions within the module that defines the type).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.G., something like this may become possible (assume all files are compiled together):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // in `ComplicatedClass.swift`<br>&gt;&gt;&gt;   class ComplicatedClass {<br>&gt;&gt;&gt;     let text: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // how will this get expanded,<br>&gt;&gt;&gt;     // given the extensions below?<br>&gt;&gt;&gt;     memberwise init(...)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // in `ComplicatedClass+Foo.swift`<br>&gt;&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;&gt;     var fooData: Foo? = nil<br>&gt;&gt;&gt;     // presumably stuff-involving-`fooData`<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // in `ComplicatedClass+Bar.swift`<br>&gt;&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;&gt;     var barData: Bar = Bar.standardBar<br>&gt;&gt;&gt;     // presumably stuff-involving-`barData`<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn&#39;t seem impossible to specify how the memberwise-initialization would interact with constructs like the above, but I&#39;d worry a bit about it making a feature that&#39;s already looking *rather* complicated even more so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially since, if I had to pick just one, I&#39;d think the ability to define stored properties outside the initial definition is a bigger win than a nice memberwise-initialization construct, even though both seem handy.<br>&gt;&gt; <br>&gt;&gt; I followed the stored-properties-in-extensions discussion reasonably closely.  My understanding is that the extension will need to initialize its own properties, either with an initial value or with a `partial init`.  Designated initializers would be required to call the `partial init` for any extension that defines one.<br>&gt;&gt; <br>&gt;&gt; This being the case, memberwise initialization would not directly interact with this feature at all.  Memberwise initializers declared in the main body of type itself would only expose stored properties defined in the type itself.  <br>&gt;&gt; <br>&gt;&gt; It would also be possible to support `partial memberwise init` in extensions which would expose the stored properties declared in the extension as part of a partial initializer.<br>&gt;&gt; <br>&gt;&gt; I don’t think there are difficult complications here.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Secondly, I’m a bit unsure how this will interact with e.g. the property-behavior proposal if both wind up ratified. For `lazy`, the interaction with `memberwise` is easy — it is omitted from the list — but when you get into e.g. something like a hypothetical `logged` or `synchronized` or `atomic` — wherein there is custom behavior, but the field would still need initialization — you’d want them to be included in the<br>&gt;&gt;&gt; `memberwise` init.<br>&gt;&gt; <br>&gt;&gt; My thought here is that a behavior would define whether a property allows and / or requires initialization in phase 1 or not.  This is probably necessary independent of memberwise initialization.  Properties that allow or require phase 1 initialization would be eligible for memberwise initialization. Properties that don’t allow phase 1 initialization would not be eligible for memberwise initialization.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a bit unfair to bring up another proposal, but this proposal and something like the property-behavior proposal *would* need to work well together (if both are approved).<br>&gt;&gt; <br>&gt;&gt; Agreed.  That is why there is a rule that references property behaviors in the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thirdly, I’m not sure what the current plans are (if any) for users to be able to specify the precise memory-layout of a struct; apologies if this is already a feature, I simply haven’t looked into it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **Today**: I order stored-field declarations for ease-of-reading (e.g. grouped into logical groups, and organized for ease-of-reading).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **Under Proposal**: I sometimes will get to choose between the “ease-of-reading” declaration ordering and the “cleanest-reading memberwise init” declaration ordering. These may not always be identical.<br>&gt;&gt; <br>&gt;&gt; Agree.  This is something that could be addressed in a future enhancement if necessary.  This proposal is focused on the basic mechanism.<br>&gt;&gt; <br>&gt;&gt; Also, nothing in the proposal prevents you from continuing to write a manual initializer when the synthesized initializer will not do what you require.  If you are already explicitly restating the property identifiers to specify parameter order you are already half way to a manual initializer implementation.  <br>&gt;&gt; <br>&gt;&gt; Granted, if you need more than one memberwise initializer you would have to duplicate that effort.  But re-ordering is going to have a hard time providing enough value if the basic feature does what we need in the majority of cases.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **Future?**: I may have to choose between the “ease-of-reading” declaration ordering, the “cleanest-reading member wise init” declaration ordering, and (perhaps?) the “intended memory-layout” declaration ordering.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t want to make this proposal more-complicated than it already is, but I worry a bit about having too many things impacting the choice of how to order declarations in source files; it may be better to include a way to explicitly declare the ordering-for-memberwise:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.G., some way of explicitly indicating the memberwise ordering, perhaps like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // syntax example re-using `ComplicatedClass`<br>&gt;&gt;&gt;   class ComplicatedClass  {<br>&gt;&gt;&gt;     @memberwise($parameterList)<br>&gt;&gt;&gt;     // ^ can use just @memberwise to get default ordering + the defaults from<br>&gt;&gt;&gt;     //   the property declarations, but perhaps require the explicit listing<br>&gt;&gt;&gt;     //   whenver the ordering is not well-defined (e.g. if you have properties<br>&gt;&gt;&gt;     //   declared in extensions…then you need to order it yourself)<br>&gt;&gt;&gt;     // <br>&gt;&gt;&gt;     //   @memberwise(text=&quot;Example&quot;,barData=,fooData)<br>&gt;&gt;&gt;     //   - `text=&quot;Example&quot;` =&gt; memberwise init has text=&quot;Example&quot;<br>&gt;&gt;&gt;     //   - `barData=` =&gt; memberwise init has `barData` w/out default<br>&gt;&gt;&gt;     //   - `fooData` =&gt; memberwise init has `fooData` w/default if it has one<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   …and e.g. the above would make:<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   memberwise init(...)<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   ...expand-to:<br>&gt;&gt;&gt;     // <br>&gt;&gt;&gt;     //   init(text:String = &quot;Example&quot;, barData: Bar, fooData:Foo?=nil)<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   ...and with the @memberwise declaration supporting a `...` for `super`<br>&gt;&gt;&gt;     //   placement, like so:<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   // superclass members come before:<br>&gt;&gt;&gt;     //   @memberwise(...,)<br>&gt;&gt;&gt;     //   @memberwise(...,$parameterList)<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   // superclass members come after      <br>&gt;&gt;&gt;     //   @memberwise(,...)<br>&gt;&gt;&gt;     //   @memberwise($parameterList,...)<br>&gt;&gt;&gt;     //<br>&gt;&gt;&gt;     //   ...perhaps with tweaked syntax (`@memberwise(...,$)` or `@memberwise(...,self)`)<br>&gt;&gt;&gt;     //   to be bit easier to read when you don&#39;t have an explicit parameter list?<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...which of course potentially only-further complicates the feature in some ways, but avoids having this use of this feature *necessarily* impact how one might choose to order declarations?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/08838a4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:56 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 8, 2016, at 9:46 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; After reading both your response below and also the proposal rather carefully, I agree that the possible issues I raised are all either not real issues or already addressed; thanks again for crafting the proposal and also for taking the time to reply to so much feedback.<br>&gt;&gt; <br>&gt;&gt; That being said, I can’t shake a feeling that, overall, although I am definitely in favor of something along the lines of this proposal, in its concrete details at present this proposal isn’t really sitting anywhere near even a local-optimum on the `(flexibility,complexity) -&gt; functionality` surface, as it were; it seems like both of these are possible:<br>&gt;&gt; <br>&gt;&gt; - (a) make it a bit more flexible, for a high gain in functionality at a low incremental cost in complexity<br>&gt;&gt; - (b) make it a bit less flexible, for a modest loss in functionality and a large drop in complexity<br>&gt;&gt; <br>&gt;&gt; …but for (b) it’s just a feeling and I don’t have a specific proposal (this may well be close to a minimum-viable-proposal for such a feature).<br>&gt; <br>&gt; I agree with you.  <br>&gt; <br>&gt; As for (b) some people have suggested alternatives with less functionality like David’s `self propName: PropType` suggestion.  So far I don’t think any of those add enough value over current state to be worth considering.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; For (a) my sense is that although I can understand why you don’t want to even provide the option of specifying an explicit memberwise-parameter list, it really does seem that supporting at least an optional list makes it possible to get a lot more functionality for not much more *actual* complexity; this isn’t incompatible with also supporting an “automatic” option that uses the logic from the proposal where possible.<br>&gt; <br>&gt; In terms of (a), I definitely agree that it would be desirable to allow for a bit more functionality.  That is why I have suggested several enhancements.  I don’t think we want all of them, but some are definitely desirable.  <br>&gt; <br>&gt; Chris really wanted to start with a core proposal and evaluate the enhancements independently, which is a good idea but also makes the proposal slightly less flexible than desirable.  The enhancements I feel are most important are:<br>&gt; <br>&gt; 1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>&gt; 2. We need a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.  I think allowing distinct access control for `init` is the best way to handle this.<br>&gt; <br>&gt; You mention specifying an explicit parameter list but don’t really elaborate further.  Would the opt-in model described in the proposal meet what you have in mind?  Or are you also consider with parameter order being independent of property declaration order?<br></p><p>I included a mock syntax in my initial response but it was (a) at the end and (b) perhaps a bit too terse. I have put a restated sketch at the bottom of this response.<br></p><p>&gt; <br>&gt; Your example below hints at general parameter forwarding.  I’ll elaborate further down.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Here’s a concrete example to illustrate why I’m harping on this point; I apologize for the length, but I think “small-n” examples can often give false intuition into how things will behave in real life:<br>&gt; <br>&gt; Thank you for this!  I probably should have provided at least one more concrete example myself.  I am learning from that mistake in the second draft of my next proposal.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; class FancyCollectionViewDriver : NSObject, UICollectionViewDataSource, UICollectionViewDelegate /*, etc... */ {<br>&gt;&gt;   <br>&gt;&gt;   let collectionView: UICollectionView<br>&gt;&gt;   let contentPresentation: ContentPresentation  <br>&gt;&gt;   let modelBroker: ModelBroker<br>&gt;&gt;   let imageBroker: ImageBroker<br>&gt;&gt;   let analyticsSink: AnalyticsSink<br>&gt;&gt;   private(set) var currentData: ModelData<br>&gt;&gt;   private(set) weak var interactionDelegate: DriverDelegateProtocol?<br>&gt;&gt;   // ^ can&#39;t be non-optional `unowned let` for reasons,<br>&gt;&gt;   //   but we expect a non-nil argument in init<br>&gt;&gt;   // NOTE: numerous private state-tracking variables omitted since we are only focusing on initialization<br>&gt;&gt; <br>&gt;&gt;   // Present-day initializer, full of boilerplate:<br>&gt;&gt;   required init(<br>&gt;&gt;     collectionView: UICollectionView, <br>&gt;&gt;     contentPresentation: ContentPresentation,<br>&gt;&gt;     modelBroker: ModelBroker,<br>&gt;&gt;     imageBroker: ImageBroker,<br>&gt;&gt;     analyticsSink: AnalyticsSink,<br>&gt;&gt;     // note use of different argument name:<br>&gt;&gt;     initialData: ModelData,<br>&gt;&gt;     // note use of non-optional:<br>&gt;&gt;     interactionDelegate: DriverDelegateProtocol) {<br>&gt;&gt;       // oh boy here we go again:<br>&gt;&gt;       self.collectionView = collectionView<br>&gt;&gt;       self.contentPresentation = contentPresentation<br>&gt;&gt;       self.modelBroker = modelBroker<br>&gt;&gt;       self.imageBroker = imageBroker<br>&gt;&gt;       self.analyticsSink = analyticsSink<br>&gt;&gt;       self.currentData = initialData<br>&gt;&gt;       self.interactionDelegate = interactionDelegate<br>&gt;&gt;       super.init()<br>&gt;&gt;       // only non-assignment logic in the entire init:<br>&gt;&gt;       self.collectionView.dataSource = self<br>&gt;&gt;       self.collectionView.delegate = self<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // best we can do under proposal w/out modifying <br>&gt;&gt;     // class design:<br>&gt;&gt;     required memberwise init(<br>&gt;&gt;     // lots of boilerplate gone:<br>&gt;&gt;     ..., <br>&gt;&gt;     // this isn&#39;t changed:<br>&gt;&gt;     initialData: ModelData,<br>&gt;&gt;     // this isn&#39;t changed:<br>&gt;&gt;     interactionDelegate: DriverDelegateProtocol) {<br>&gt;&gt;       // synthesized stuff is effectively here<br>&gt;&gt;       self.currentData = initialData<br>&gt;&gt;       self.interactionDelegate = interactionDelegate<br>&gt;&gt;       super.init()<br>&gt;&gt;       // only non-assignment logic in the entire init:<br>&gt;&gt;       self.collectionView.dataSource = self<br>&gt;&gt;       self.collectionView.delegate = self<br>&gt;&gt;     }<br>&gt;&gt;   <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which I do think is already a huge improvement. <br>&gt; <br>&gt; And gets even better if we allow access control for init.  Your `private(set)` members would now become eligible for memberwise initialization in an `internal` initializer because `init` has a distinct access level which defaults to `internal`.<br></p><p>Indeed, but please do note that I’d still like:<br>- `initialData` instead of `currentData`<br>- a non-nil `interactionDelegate` at init<br></p><p>That said, I feel that e.g. for any variable declaration syntax something like  `private(set) internal(init=initialData) var currentData: ModelData` would be best avoided, even if it’d buy me the ability to customize the name in the synthesized memberwise init; it’s just too much and IMHO sets a bad precedent.<br></p><p>&gt;     <br>&gt;     required memberwise init(...) {<br>&gt;       // synthesized stuff is effectively here<br>&gt;       super.init()<br>&gt;       // only non-assignment logic in the entire init:<br>&gt;       self.collectionView.dataSource = self<br>&gt;       self.collectionView.delegate = self<br>&gt;     }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Now suppose that stored-properties-in-extensions hits (as the &quot;partial-init&quot; flavor); in that case I’d ideally be able to move some of the parts into their own files like so:<br>&gt;&gt; <br>&gt;&gt; // in `FancyCollectionViewDriver+Analytics.swift`<br>&gt;&gt; extension FancyCollectionViewDriver  {<br>&gt;&gt;   // ^ depending on advances in the protocol system, at some point may <br>&gt;&gt;   //   evolve into a protocol-adoption to get useful default implementations<br>&gt;&gt;   <br>&gt;&gt;   let analyticsReporter: AnalyticsReporter <br>&gt;&gt;   // ^ moved here, not in main declaration<br>&gt;&gt;   //   assume also a bunch of private state-tracking stuff...<br>&gt;&gt;   <br>&gt;&gt;   // a bunch of things like this:<br>&gt;&gt;   func reportEventTypeA(eventAInfo: EventAInfo)<br>&gt;&gt;   func reportEventTypeB(eventBInfo: BventAInfo)<br>&gt;&gt;   <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // in `FancyCollectionViewDriver+Interaction.swift`<br>&gt;&gt; extension FancyCollectionViewDriver {<br>&gt;&gt;   <br>&gt;&gt;   private(set) var interactionDelegate: DriverDelegateProtocol?<br>&gt;&gt;   // ^ moved here, not in main declaration<br>&gt;&gt;   //   assume also a bunch of private state-tracking stuff...<br>&gt;&gt;   <br>&gt;&gt;   // a bunch of things like this:<br>&gt;&gt;   func handleInteractionA(interactionAInfo: InteractionAInfo)<br>&gt;&gt;   func handleInteractionB(interactionBInfo: InteractionBInfo)<br>&gt;&gt;   <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …(and so on for e.g. the `imageBroker` also), but under the current proposal this would put them outside the scope of a memberwise init (this isn’t news to you, I’m just making it concrete).<br>&gt;&gt; <br>&gt;&gt; So in this scenario, we’re either reapproaching the MxN problem memberwise-init is meant to avoid:<br>&gt;&gt; <br>&gt;&gt; init(<br>&gt;&gt;   // still save some boilerplate:<br>&gt;&gt;   …, <br>&gt;&gt;   imageBroker: ImageBroker,<br>&gt;&gt;   analyticsReporter: AnalyticsReporter, <br>&gt;&gt;   initialData: ModelData, <br>&gt;&gt;   interactionDelegate: DriverDelegateProtocol) {<br>&gt;&gt;   // some boilerplate synththesized here...<br>&gt;&gt;   // ...but getting closer to where we started:<br>&gt;&gt;   self.partial_init(imageBroker: imageBroker)<br>&gt;&gt;   self.partial_init(analyticsReporter: analyticsReporter)<br>&gt;&gt;   self.currentData = modelData<br>&gt;&gt;   self.partial_init(interactionDelegate: interactionDelegate)  <br>&gt;&gt;   super.init()<br>&gt;&gt;   self.collectionView.dataSource = self<br>&gt;&gt;   self.collectionView.delegate = self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …or we’re making choices between taking full-advantage of properties-in-extensions (which IMHO would often be a *huge* readability win) versus taking full-advantage of boilerplate-reduction in our inits.<br>&gt; <br>&gt; If extensions with stored properties are going to properly encapsulate their state (I believe this is the way to go) they are going to have to initialize state on their own and the primary initializer will have to provide arguments the initializer requires.  Allowing stored properties in extensions automatically appear in a memberwise initializer violates that encapsulation.<br></p><p>&quot;Automatic appearance&quot; would definitely be bad; it’d seem like using such extensions would have to get you disqualified for automatic synthesis.<br></p><p>It’s still a tricky point though given the uncertainty about future directions; there seems to be some discussion of allowing protocols to define (instead of merely require) stored properties, which would perhaps be yet-another wrinkle to have to at least consider.<br></p><p>&gt; <br>&gt; The good news is that a general parameter forwarding mechanism can help if the extension init (or super init) requires a bunch of arguments and you just want to forward them from your caller.  This is alluded to in the enhancement section of the proposal but is really a completely general and orthogonal feature.<br>&gt; <br>&gt; It might look something like this:<br>&gt; <br>&gt; memberwise init(…superArgs, …partial1args, …partial2args, …memberwise) {<br>&gt; 	extension1.init(directArgument: 42, …partial1args)<br>&gt; 	extension2.init(…partial2args)<br>&gt; 	super.init(…superArgs)<br>&gt; }<br>&gt; <br>&gt; A couple things to note about how this might work:<br>&gt; <br>&gt; 1. The initializer calls (or function / method calls in other cases) must be unambiguous from the code alone.<br>&gt; 2. Any parameters for which a direct argument is not provided are “captured” by the `…identifier` placeholder. <br>&gt; 3. Parameters matching those captured by the identifier are synthesized in the location specified in the parameter list.<br>&gt; <br>&gt; Obviously this won’t help if the extensions only require a single argument.  But if you have extensions requiring several arguments that you want to pass through it would help<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Which is ultimately why I suspect that the “right&quot; version of the proposed feature should cut to the chase and incorporate some way to explicitly-specify the memberwise parameter list — which, again, need not be incompatible with the ability to request automatic synthesis using logic ~ what’s in the proposal — as such an explicit list takes the pressure off of getting the default behavior as-right-as-possible while also making it simpler to support some very nice-to-have capabilities not supported by this proposal as-written.<br>&gt; <br>&gt; How would this be different than the opt-in model described in the proposal?  Do you have something specific in mind?<br></p><p>This is what I had in the original. To expand what I meant a bit:<br></p><p>- you’d a type into “memberwise&quot; by including `@memberwise` somewhere in the declaration<br>- `@memberwise` can be used two ways:<br>  - “bare&quot; `@memberwise` =&gt; try to use the automatic approach (~ the logic in this proposal, or similar)<br>  - `@memberwise($parameterList)`, for explicit lists<br></p><p>…with some examples for the $parameterList in a second.<br></p><p>Assume a class like so:<br></p><p>class Example {<br>  let foo: Foo<br>  var bar: Bar = Bar.standard<br>  var baz: Baz = Baz.standard<br>}<br></p><p>Then here are some @memberwise declarations:<br></p><p>@memberwise =&gt; init(foo: Foo, bar: Bar = Bar.standard, baz: Baz = Baz.standard)<br>// ^ automatic, roughly ~ proposal<br></p><p>@memberwise(foo,bar,baz) =&gt; same as above<br>// ^ explicit, but identical<br></p><p>@memberwise(foo,baz,bar) =&gt; init(foo: Foo, baz: Baz = Baz.standard, bar: Bar = Bar.standard)<br>// ^ explicit, but reordered arguments<br></p><p>@memberwise(foo,bar=Foo.funkyAlternative,baz)  =&gt; init(foo: Foo, bar: Bar = Bar.funkyAlternative, baz: Baz = Baz.standard)<br>// ^ explicit, alternate default for `bar`<br></p><p>@memberwise(foo,bar=,baz)  =&gt; init(foo: Foo, bar: Bar, baz: Baz = Baz.standard)<br>// ^ explicit, suppress default for `bar`<br>// …”suppression&quot; syntax isn’t great but it would seemingly work...<br></p><p>@memberwise(foo=Foo.common,bar,baz)  =&gt; init(foo: Foo = Foo.common, bar: Bar = Bar.standard, baz: Baz = Baz.standard)<br>// ^ explicit, provide default for the `let`-property `foo`<br></p><p>…and perhaps even the ugly-but-serviceable renaming support like:<br></p><p>@memberwise(foo,bar,baz as initialBaz=) =&gt; init(foo: Foo, bar: Bar = Bar.standard, initialBaz: Baz)<br></p><p>…but not sure how to have a non-awful syntax for the case where you want to “promote” a property that’s internally optional to the non-optional case (or vice-versa I guess, or some more-general not-the-same type; that may be out-of-scope).<br></p><p>Note that something like the above would also offer a natural way to handle superclass initialization:<br></p><p>@memberwise(…,$parameterList) =&gt; this type’s parameters come *after* parent classes’ (memberwise) parameters<br>@memberwise($parameterList, ..) =&gt; this type’s parameters come *before* parent classes’ (memberwise) parameters<br></p><p>…although I’m not sure how often that’d come up in practice.<br></p><p>This is not a concrete proposal; it’s just a sketch of how an explicit parameter-list could be designed to still support the automatic approach when possible. I’m assuming that it’s a compiler error to have an explicit list that is either (a) incomplete or (b) has any invalid/unrecognized property names.<br></p><p>It also feels weird to have an @-style annotation *inside* a type, so there’s a lot of room to improve the proposed syntax.<br></p><p>And all the other arguments against the explicit list would also still apply, of course.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; That’s my 2c; thanks to anyone who’s read through all this and thanks again for drafting a concrete-enough proposal to discuss properly.<br>&gt; <br>&gt; Thanks for all your feedback and your example!  I really appreciate it!<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 9:24 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 9:02 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the general notion of something along these lines but admittedly haven’t had time to dig into the proposal specifics yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have some concerns about cross-interactions with other features that are either also under discussion or are at least very anticipatable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First, I know there has already been some discussion of allowing definition of stored fields in (some) extensions (e.g., something like allowing definition of stored fields in extensions within the module that defines the type).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.G., something like this may become possible (assume all files are compiled together):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // in `ComplicatedClass.swift`<br>&gt;&gt;&gt;&gt;   class ComplicatedClass {<br>&gt;&gt;&gt;&gt;     let text: String<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // how will this get expanded,<br>&gt;&gt;&gt;&gt;     // given the extensions below?<br>&gt;&gt;&gt;&gt;     memberwise init(...)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // in `ComplicatedClass+Foo.swift`<br>&gt;&gt;&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;&gt;&gt;     var fooData: Foo? = nil<br>&gt;&gt;&gt;&gt;     // presumably stuff-involving-`fooData`<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // in `ComplicatedClass+Bar.swift`<br>&gt;&gt;&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;&gt;&gt;     var barData: Bar = Bar.standardBar<br>&gt;&gt;&gt;&gt;     // presumably stuff-involving-`barData`<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It doesn&#39;t seem impossible to specify how the memberwise-initialization would interact with constructs like the above, but I&#39;d worry a bit about it making a feature that&#39;s already looking *rather* complicated even more so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Especially since, if I had to pick just one, I&#39;d think the ability to define stored properties outside the initial definition is a bigger win than a nice memberwise-initialization construct, even though both seem handy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I followed the stored-properties-in-extensions discussion reasonably closely.  My understanding is that the extension will need to initialize its own properties, either with an initial value or with a `partial init`.  Designated initializers would be required to call the `partial init` for any extension that defines one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This being the case, memberwise initialization would not directly interact with this feature at all.  Memberwise initializers declared in the main body of type itself would only expose stored properties defined in the type itself.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would also be possible to support `partial memberwise init` in extensions which would expose the stored properties declared in the extension as part of a partial initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think there are difficult complications here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Secondly, I’m a bit unsure how this will interact with e.g. the property-behavior proposal if both wind up ratified. For `lazy`, the interaction with `memberwise` is easy — it is omitted from the list — but when you get into e.g. something like a hypothetical `logged` or `synchronized` or `atomic` — wherein there is custom behavior, but the field would still need initialization — you’d want them to be included in the<br>&gt;&gt;&gt;&gt; `memberwise` init.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My thought here is that a behavior would define whether a property allows and / or requires initialization in phase 1 or not.  This is probably necessary independent of memberwise initialization.  Properties that allow or require phase 1 initialization would be eligible for memberwise initialization. Properties that don’t allow phase 1 initialization would not be eligible for memberwise initialization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a bit unfair to bring up another proposal, but this proposal and something like the property-behavior proposal *would* need to work well together (if both are approved).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed.  That is why there is a rule that references property behaviors in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thirdly, I’m not sure what the current plans are (if any) for users to be able to specify the precise memory-layout of a struct; apologies if this is already a feature, I simply haven’t looked into it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; **Today**: I order stored-field declarations for ease-of-reading (e.g. grouped into logical groups, and organized for ease-of-reading).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; **Under Proposal**: I sometimes will get to choose between the “ease-of-reading” declaration ordering and the “cleanest-reading memberwise init” declaration ordering. These may not always be identical.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agree.  This is something that could be addressed in a future enhancement if necessary.  This proposal is focused on the basic mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, nothing in the proposal prevents you from continuing to write a manual initializer when the synthesized initializer will not do what you require.  If you are already explicitly restating the property identifiers to specify parameter order you are already half way to a manual initializer implementation.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Granted, if you need more than one memberwise initializer you would have to duplicate that effort.  But re-ordering is going to have a hard time providing enough value if the basic feature does what we need in the majority of cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; **Future?**: I may have to choose between the “ease-of-reading” declaration ordering, the “cleanest-reading member wise init” declaration ordering, and (perhaps?) the “intended memory-layout” declaration ordering.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t want to make this proposal more-complicated than it already is, but I worry a bit about having too many things impacting the choice of how to order declarations in source files; it may be better to include a way to explicitly declare the ordering-for-memberwise:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.G., some way of explicitly indicating the memberwise ordering, perhaps like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // syntax example re-using `ComplicatedClass`<br>&gt;&gt;&gt;&gt;   class ComplicatedClass  {<br>&gt;&gt;&gt;&gt;     @memberwise($parameterList)<br>&gt;&gt;&gt;&gt;     // ^ can use just @memberwise to get default ordering + the defaults from<br>&gt;&gt;&gt;&gt;     //   the property declarations, but perhaps require the explicit listing<br>&gt;&gt;&gt;&gt;     //   whenver the ordering is not well-defined (e.g. if you have properties<br>&gt;&gt;&gt;&gt;     //   declared in extensions…then you need to order it yourself)<br>&gt;&gt;&gt;&gt;     // <br>&gt;&gt;&gt;&gt;     //   @memberwise(text=&quot;Example&quot;,barData=,fooData)<br>&gt;&gt;&gt;&gt;     //   - `text=&quot;Example&quot;` =&gt; memberwise init has text=&quot;Example&quot;<br>&gt;&gt;&gt;&gt;     //   - `barData=` =&gt; memberwise init has `barData` w/out default<br>&gt;&gt;&gt;&gt;     //   - `fooData` =&gt; memberwise init has `fooData` w/default if it has one<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   …and e.g. the above would make:<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   memberwise init(...)<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   ...expand-to:<br>&gt;&gt;&gt;&gt;     // <br>&gt;&gt;&gt;&gt;     //   init(text:String = &quot;Example&quot;, barData: Bar, fooData:Foo?=nil)<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   ...and with the @memberwise declaration supporting a `...` for `super`<br>&gt;&gt;&gt;&gt;     //   placement, like so:<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   // superclass members come before:<br>&gt;&gt;&gt;&gt;     //   @memberwise(...,)<br>&gt;&gt;&gt;&gt;     //   @memberwise(...,$parameterList)<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   // superclass members come after      <br>&gt;&gt;&gt;&gt;     //   @memberwise(,...)<br>&gt;&gt;&gt;&gt;     //   @memberwise($parameterList,...)<br>&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;     //   ...perhaps with tweaked syntax (`@memberwise(...,$)` or `@memberwise(...,self)`)<br>&gt;&gt;&gt;&gt;     //   to be bit easier to read when you don&#39;t have an explicit parameter list?<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...which of course potentially only-further complicates the feature in some ways, but avoids having this use of this feature *necessarily* impact how one might choose to order declarations?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/87cf8d63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 12:35 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:56 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 9:46 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After reading both your response below and also the proposal rather carefully, I agree that the possible issues I raised are all either not real issues or already addressed; thanks again for crafting the proposal and also for taking the time to reply to so much feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said, I can’t shake a feeling that, overall, although I am definitely in favor of something along the lines of this proposal, in its concrete details at present this proposal isn’t really sitting anywhere near even a local-optimum on the `(flexibility,complexity) -&gt; functionality` surface, as it were; it seems like both of these are possible:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (a) make it a bit more flexible, for a high gain in functionality at a low incremental cost in complexity<br>&gt;&gt;&gt; - (b) make it a bit less flexible, for a modest loss in functionality and a large drop in complexity<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …but for (b) it’s just a feeling and I don’t have a specific proposal (this may well be close to a minimum-viable-proposal for such a feature).<br>&gt;&gt; <br>&gt;&gt; I agree with you.  <br>&gt;&gt; <br>&gt;&gt; As for (b) some people have suggested alternatives with less functionality like David’s `self propName: PropType` suggestion.  So far I don’t think any of those add enough value over current state to be worth considering.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For (a) my sense is that although I can understand why you don’t want to even provide the option of specifying an explicit memberwise-parameter list, it really does seem that supporting at least an optional list makes it possible to get a lot more functionality for not much more *actual* complexity; this isn’t incompatible with also supporting an “automatic” option that uses the logic from the proposal where possible.<br>&gt;&gt; <br>&gt;&gt; In terms of (a), I definitely agree that it would be desirable to allow for a bit more functionality.  That is why I have suggested several enhancements.  I don’t think we want all of them, but some are definitely desirable.  <br>&gt;&gt; <br>&gt;&gt; Chris really wanted to start with a core proposal and evaluate the enhancements independently, which is a good idea but also makes the proposal slightly less flexible than desirable.  The enhancements I feel are most important are:<br>&gt;&gt; <br>&gt;&gt; 1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>&gt;&gt; 2. We need a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.  I think allowing distinct access control for `init` is the best way to handle this.<br>&gt;&gt; <br>&gt;&gt; You mention specifying an explicit parameter list but don’t really elaborate further.  Would the opt-in model described in the proposal meet what you have in mind?  Or are you also consider with parameter order being independent of property declaration order?<br>&gt; <br>&gt; I included a mock syntax in my initial response but it was (a) at the end and (b) perhaps a bit too terse. I have put a restated sketch at the bottom of this response.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Your example below hints at general parameter forwarding.  I’ll elaborate further down.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a concrete example to illustrate why I’m harping on this point; I apologize for the length, but I think “small-n” examples can often give false intuition into how things will behave in real life:<br>&gt;&gt; <br>&gt;&gt; Thank you for this!  I probably should have provided at least one more concrete example myself.  I am learning from that mistake in the second draft of my next proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class FancyCollectionViewDriver : NSObject, UICollectionViewDataSource, UICollectionViewDelegate /*, etc... */ {<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   let collectionView: UICollectionView<br>&gt;&gt;&gt;   let contentPresentation: ContentPresentation  <br>&gt;&gt;&gt;   let modelBroker: ModelBroker<br>&gt;&gt;&gt;   let imageBroker: ImageBroker<br>&gt;&gt;&gt;   let analyticsSink: AnalyticsSink<br>&gt;&gt;&gt;   private(set) var currentData: ModelData<br>&gt;&gt;&gt;   private(set) weak var interactionDelegate: DriverDelegateProtocol?<br>&gt;&gt;&gt;   // ^ can&#39;t be non-optional `unowned let` for reasons,<br>&gt;&gt;&gt;   //   but we expect a non-nil argument in init<br>&gt;&gt;&gt;   // NOTE: numerous private state-tracking variables omitted since we are only focusing on initialization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Present-day initializer, full of boilerplate:<br>&gt;&gt;&gt;   required init(<br>&gt;&gt;&gt;     collectionView: UICollectionView, <br>&gt;&gt;&gt;     contentPresentation: ContentPresentation,<br>&gt;&gt;&gt;     modelBroker: ModelBroker,<br>&gt;&gt;&gt;     imageBroker: ImageBroker,<br>&gt;&gt;&gt;     analyticsSink: AnalyticsSink,<br>&gt;&gt;&gt;     // note use of different argument name:<br>&gt;&gt;&gt;     initialData: ModelData,<br>&gt;&gt;&gt;     // note use of non-optional:<br>&gt;&gt;&gt;     interactionDelegate: DriverDelegateProtocol) {<br>&gt;&gt;&gt;       // oh boy here we go again:<br>&gt;&gt;&gt;       self.collectionView = collectionView<br>&gt;&gt;&gt;       self.contentPresentation = contentPresentation<br>&gt;&gt;&gt;       self.modelBroker = modelBroker<br>&gt;&gt;&gt;       self.imageBroker = imageBroker<br>&gt;&gt;&gt;       self.analyticsSink = analyticsSink<br>&gt;&gt;&gt;       self.currentData = initialData<br>&gt;&gt;&gt;       self.interactionDelegate = interactionDelegate<br>&gt;&gt;&gt;       super.init()<br>&gt;&gt;&gt;       // only non-assignment logic in the entire init:<br>&gt;&gt;&gt;       self.collectionView.dataSource = self<br>&gt;&gt;&gt;       self.collectionView.delegate = self<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // best we can do under proposal w/out modifying <br>&gt;&gt;&gt;     // class design:<br>&gt;&gt;&gt;     required memberwise init(<br>&gt;&gt;&gt;     // lots of boilerplate gone:<br>&gt;&gt;&gt;     ..., <br>&gt;&gt;&gt;     // this isn&#39;t changed:<br>&gt;&gt;&gt;     initialData: ModelData,<br>&gt;&gt;&gt;     // this isn&#39;t changed:<br>&gt;&gt;&gt;     interactionDelegate: DriverDelegateProtocol) {<br>&gt;&gt;&gt;       // synthesized stuff is effectively here<br>&gt;&gt;&gt;       self.currentData = initialData<br>&gt;&gt;&gt;       self.interactionDelegate = interactionDelegate<br>&gt;&gt;&gt;       super.init()<br>&gt;&gt;&gt;       // only non-assignment logic in the entire init:<br>&gt;&gt;&gt;       self.collectionView.dataSource = self<br>&gt;&gt;&gt;       self.collectionView.delegate = self<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which I do think is already a huge improvement. <br>&gt;&gt; <br>&gt;&gt; And gets even better if we allow access control for init.  Your `private(set)` members would now become eligible for memberwise initialization in an `internal` initializer because `init` has a distinct access level which defaults to `internal`.<br>&gt; <br>&gt; Indeed, but please do note that I’d still like:<br>&gt; - `initialData` instead of `currentData`<br>&gt; - a non-nil `interactionDelegate` at init<br>&gt; <br>&gt; That said, I feel that e.g. for any variable declaration syntax something like  `private(set) internal(init=initialData) var currentData: ModelData` would be best avoided, even if it’d buy me the ability to customize the name in the synthesized memberwise init; it’s just too much and IMHO sets a bad precedent.<br>&gt; <br>&gt;&gt;     <br>&gt;&gt;     required memberwise init(...) {<br>&gt;&gt;       // synthesized stuff is effectively here<br>&gt;&gt;       super.init()<br>&gt;&gt;       // only non-assignment logic in the entire init:<br>&gt;&gt;       self.collectionView.dataSource = self<br>&gt;&gt;       self.collectionView.delegate = self<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now suppose that stored-properties-in-extensions hits (as the &quot;partial-init&quot; flavor); in that case I’d ideally be able to move some of the parts into their own files like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // in `FancyCollectionViewDriver+Analytics.swift`<br>&gt;&gt;&gt; extension FancyCollectionViewDriver  {<br>&gt;&gt;&gt;   // ^ depending on advances in the protocol system, at some point may <br>&gt;&gt;&gt;   //   evolve into a protocol-adoption to get useful default implementations<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   let analyticsReporter: AnalyticsReporter <br>&gt;&gt;&gt;   // ^ moved here, not in main declaration<br>&gt;&gt;&gt;   //   assume also a bunch of private state-tracking stuff...<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // a bunch of things like this:<br>&gt;&gt;&gt;   func reportEventTypeA(eventAInfo: EventAInfo)<br>&gt;&gt;&gt;   func reportEventTypeB(eventBInfo: BventAInfo)<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // in `FancyCollectionViewDriver+Interaction.swift`<br>&gt;&gt;&gt; extension FancyCollectionViewDriver {<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   private(set) var interactionDelegate: DriverDelegateProtocol?<br>&gt;&gt;&gt;   // ^ moved here, not in main declaration<br>&gt;&gt;&gt;   //   assume also a bunch of private state-tracking stuff...<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   // a bunch of things like this:<br>&gt;&gt;&gt;   func handleInteractionA(interactionAInfo: InteractionAInfo)<br>&gt;&gt;&gt;   func handleInteractionB(interactionBInfo: InteractionBInfo)<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …(and so on for e.g. the `imageBroker` also), but under the current proposal this would put them outside the scope of a memberwise init (this isn’t news to you, I’m just making it concrete).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So in this scenario, we’re either reapproaching the MxN problem memberwise-init is meant to avoid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(<br>&gt;&gt;&gt;   // still save some boilerplate:<br>&gt;&gt;&gt;   …, <br>&gt;&gt;&gt;   imageBroker: ImageBroker,<br>&gt;&gt;&gt;   analyticsReporter: AnalyticsReporter, <br>&gt;&gt;&gt;   initialData: ModelData, <br>&gt;&gt;&gt;   interactionDelegate: DriverDelegateProtocol) {<br>&gt;&gt;&gt;   // some boilerplate synththesized here...<br>&gt;&gt;&gt;   // ...but getting closer to where we started:<br>&gt;&gt;&gt;   self.partial_init(imageBroker: imageBroker)<br>&gt;&gt;&gt;   self.partial_init(analyticsReporter: analyticsReporter)<br>&gt;&gt;&gt;   self.currentData = modelData<br>&gt;&gt;&gt;   self.partial_init(interactionDelegate: interactionDelegate)  <br>&gt;&gt;&gt;   super.init()<br>&gt;&gt;&gt;   self.collectionView.dataSource = self<br>&gt;&gt;&gt;   self.collectionView.delegate = self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …or we’re making choices between taking full-advantage of properties-in-extensions (which IMHO would often be a *huge* readability win) versus taking full-advantage of boilerplate-reduction in our inits.<br>&gt;&gt; <br>&gt;&gt; If extensions with stored properties are going to properly encapsulate their state (I believe this is the way to go) they are going to have to initialize state on their own and the primary initializer will have to provide arguments the initializer requires.  Allowing stored properties in extensions automatically appear in a memberwise initializer violates that encapsulation.<br>&gt; <br>&gt; &quot;Automatic appearance&quot; would definitely be bad; it’d seem like using such extensions would have to get you disqualified for automatic synthesis.<br>&gt; <br>&gt; It’s still a tricky point though given the uncertainty about future directions; there seems to be some discussion of allowing protocols to define (instead of merely require) stored properties, which would perhaps be yet-another wrinkle to have to at least consider.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The good news is that a general parameter forwarding mechanism can help if the extension init (or super init) requires a bunch of arguments and you just want to forward them from your caller.  This is alluded to in the enhancement section of the proposal but is really a completely general and orthogonal feature.<br>&gt;&gt; <br>&gt;&gt; It might look something like this:<br>&gt;&gt; <br>&gt;&gt; memberwise init(…superArgs, …partial1args, …partial2args, …memberwise) {<br>&gt;&gt; 	extension1.init(directArgument: 42, …partial1args)<br>&gt;&gt; 	extension2.init(…partial2args)<br>&gt;&gt; 	super.init(…superArgs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A couple things to note about how this might work:<br>&gt;&gt; <br>&gt;&gt; 1. The initializer calls (or function / method calls in other cases) must be unambiguous from the code alone.<br>&gt;&gt; 2. Any parameters for which a direct argument is not provided are “captured” by the `…identifier` placeholder. <br>&gt;&gt; 3. Parameters matching those captured by the identifier are synthesized in the location specified in the parameter list.<br>&gt;&gt; <br>&gt;&gt; Obviously this won’t help if the extensions only require a single argument.  But if you have extensions requiring several arguments that you want to pass through it would help<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which is ultimately why I suspect that the “right&quot; version of the proposed feature should cut to the chase and incorporate some way to explicitly-specify the memberwise parameter list — which, again, need not be incompatible with the ability to request automatic synthesis using logic ~ what’s in the proposal — as such an explicit list takes the pressure off of getting the default behavior as-right-as-possible while also making it simpler to support some very nice-to-have capabilities not supported by this proposal as-written.<br>&gt;&gt; <br>&gt;&gt; How would this be different than the opt-in model described in the proposal?  Do you have something specific in mind?<br>&gt; <br>&gt; This is what I had in the original. To expand what I meant a bit:<br>&gt; <br>&gt; - you’d a type into “memberwise&quot; by including `@memberwise` somewhere in the declaration<br>&gt; - `@memberwise` can be used two ways:<br>&gt;   - “bare&quot; `@memberwise` =&gt; try to use the automatic approach (~ the logic in this proposal, or similar)<br>&gt;   - `@memberwise($parameterList)`, for explicit lists<br>&gt; <br>&gt; …with some examples for the $parameterList in a second.<br>&gt; <br>&gt; Assume a class like so:<br>&gt; <br>&gt; class Example {<br>&gt;   let foo: Foo<br>&gt;   var bar: Bar = Bar.standard<br>&gt;   var baz: Baz = Baz.standard<br>&gt; }<br>&gt; <br>&gt; Then here are some @memberwise declarations:<br>&gt; <br>&gt; @memberwise =&gt; init(foo: Foo, bar: Bar = Bar.standard, baz: Baz = Baz.standard)<br>&gt; // ^ automatic, roughly ~ proposal<br>&gt; <br>&gt; @memberwise(foo,bar,baz) =&gt; same as above<br>&gt; // ^ explicit, but identical<br>&gt; <br>&gt; @memberwise(foo,baz,bar) =&gt; init(foo: Foo, baz: Baz = Baz.standard, bar: Bar = Bar.standard)<br>&gt; // ^ explicit, but reordered arguments<br>&gt; <br>&gt; @memberwise(foo,bar=Foo.funkyAlternative,baz)  =&gt; init(foo: Foo, bar: Bar = Bar.funkyAlternative, baz: Baz = Baz.standard)<br>&gt; // ^ explicit, alternate default for `bar`<br>&gt; <br>&gt; @memberwise(foo,bar=,baz)  =&gt; init(foo: Foo, bar: Bar, baz: Baz = Baz.standard)<br>&gt; // ^ explicit, suppress default for `bar`<br>&gt; // …”suppression&quot; syntax isn’t great but it would seemingly work...<br>&gt; <br>&gt; @memberwise(foo=Foo.common,bar,baz)  =&gt; init(foo: Foo = Foo.common, bar: Bar = Bar.standard, baz: Baz = Baz.standard)<br>&gt; // ^ explicit, provide default for the `let`-property `foo`<br>&gt; <br>&gt; …and perhaps even the ugly-but-serviceable renaming support like:<br>&gt; <br>&gt; @memberwise(foo,bar,baz as initialBaz=) =&gt; init(foo: Foo, bar: Bar = Bar.standard, initialBaz: Baz)<br>&gt; <br>&gt; …but not sure how to have a non-awful syntax for the case where you want to “promote” a property that’s internally optional to the non-optional case (or vice-versa I guess, or some more-general not-the-same type; that may be out-of-scope).<br>&gt; <br>&gt; Note that something like the above would also offer a natural way to handle superclass initialization:<br>&gt; <br>&gt; @memberwise(…,$parameterList) =&gt; this type’s parameters come *after* parent classes’ (memberwise) parameters<br>&gt; @memberwise($parameterList, ..) =&gt; this type’s parameters come *before* parent classes’ (memberwise) parameters<br>&gt; <br>&gt; …although I’m not sure how often that’d come up in practice.<br></p><p>I explored inheritance quite a bit early on in the proposal.  Chris convinced me that the right way to handle this is through a general parameter forwarding mechanism.<br></p><p>&gt; <br>&gt; This is not a concrete proposal; it’s just a sketch of how an explicit parameter-list could be designed to still support the automatic approach when possible. I’m assuming that it’s a compiler error to have an explicit list that is either (a) incomplete or (b) has any invalid/unrecognized property names.<br>&gt; <br>&gt; It also feels weird to have an @-style annotation *inside* a type, so there’s a lot of room to improve the proposed syntax.<br>&gt; <br>&gt; And all the other arguments against the explicit list would also still apply, of course.<br></p><p>Are you suggesting that this attribute would be applied to a specific initializer?  Or would this be shared by all memberwise initializers of the type in some way?<br></p><p>I don’t think applying this to a specific initializer gains enough over just writing the initializer manually to be worthwhile.  If we were going to do something specific to a single initializer, something along the lines of David’s suggestion makes the most sense to me.<br></p><p>On the other hand, if you are suggesting something type-wide that would be shared by all memberwise initializers, this is really an alternate way to accomplish an opt-in model.  Rather than applying an attribute to properties you would have a declaration specify which properties are included in memberwise initializers, with the ability to specify order, labels, and defaults if necessary.  <br></p><p>That might be a reasonable syntax for an opt-in model.  As noted in the proposal, an opt-in model could be added by a future enhancement and would be used in place of the automatic model if the opt-in syntax was present.<br></p><p>Matthew<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s my 2c; thanks to anyone who’s read through all this and thanks again for drafting a concrete-enough proposal to discuss properly.<br>&gt;&gt; <br>&gt;&gt; Thanks for all your feedback and your example!  I really appreciate it!<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 9:24 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 9:02 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the general notion of something along these lines but admittedly haven’t had time to dig into the proposal specifics yet.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have some concerns about cross-interactions with other features that are either also under discussion or are at least very anticipatable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; First, I know there has already been some discussion of allowing definition of stored fields in (some) extensions (e.g., something like allowing definition of stored fields in extensions within the module that defines the type).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; E.G., something like this may become possible (assume all files are compiled together):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // in `ComplicatedClass.swift`<br>&gt;&gt;&gt;&gt;&gt;   class ComplicatedClass {<br>&gt;&gt;&gt;&gt;&gt;     let text: String<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     // how will this get expanded,<br>&gt;&gt;&gt;&gt;&gt;     // given the extensions below?<br>&gt;&gt;&gt;&gt;&gt;     memberwise init(...)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // in `ComplicatedClass+Foo.swift`<br>&gt;&gt;&gt;&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;&gt;&gt;&gt;     var fooData: Foo? = nil<br>&gt;&gt;&gt;&gt;&gt;     // presumably stuff-involving-`fooData`<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // in `ComplicatedClass+Bar.swift`<br>&gt;&gt;&gt;&gt;&gt;   extension ComplicatedClass {<br>&gt;&gt;&gt;&gt;&gt;     var barData: Bar = Bar.standardBar<br>&gt;&gt;&gt;&gt;&gt;     // presumably stuff-involving-`barData`<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It doesn&#39;t seem impossible to specify how the memberwise-initialization would interact with constructs like the above, but I&#39;d worry a bit about it making a feature that&#39;s already looking *rather* complicated even more so.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Especially since, if I had to pick just one, I&#39;d think the ability to define stored properties outside the initial definition is a bigger win than a nice memberwise-initialization construct, even though both seem handy.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I followed the stored-properties-in-extensions discussion reasonably closely.  My understanding is that the extension will need to initialize its own properties, either with an initial value or with a `partial init`.  Designated initializers would be required to call the `partial init` for any extension that defines one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This being the case, memberwise initialization would not directly interact with this feature at all.  Memberwise initializers declared in the main body of type itself would only expose stored properties defined in the type itself.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would also be possible to support `partial memberwise init` in extensions which would expose the stored properties declared in the extension as part of a partial initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think there are difficult complications here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Secondly, I’m a bit unsure how this will interact with e.g. the property-behavior proposal if both wind up ratified. For `lazy`, the interaction with `memberwise` is easy — it is omitted from the list — but when you get into e.g. something like a hypothetical `logged` or `synchronized` or `atomic` — wherein there is custom behavior, but the field would still need initialization — you’d want them to be included in the<br>&gt;&gt;&gt;&gt;&gt; `memberwise` init.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My thought here is that a behavior would define whether a property allows and / or requires initialization in phase 1 or not.  This is probably necessary independent of memberwise initialization.  Properties that allow or require phase 1 initialization would be eligible for memberwise initialization. Properties that don’t allow phase 1 initialization would not be eligible for memberwise initialization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s a bit unfair to bring up another proposal, but this proposal and something like the property-behavior proposal *would* need to work well together (if both are approved).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed.  That is why there is a rule that references property behaviors in the proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thirdly, I’m not sure what the current plans are (if any) for users to be able to specify the precise memory-layout of a struct; apologies if this is already a feature, I simply haven’t looked into it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; **Today**: I order stored-field declarations for ease-of-reading (e.g. grouped into logical groups, and organized for ease-of-reading).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; **Under Proposal**: I sometimes will get to choose between the “ease-of-reading” declaration ordering and the “cleanest-reading memberwise init” declaration ordering. These may not always be identical.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agree.  This is something that could be addressed in a future enhancement if necessary.  This proposal is focused on the basic mechanism.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, nothing in the proposal prevents you from continuing to write a manual initializer when the synthesized initializer will not do what you require.  If you are already explicitly restating the property identifiers to specify parameter order you are already half way to a manual initializer implementation.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Granted, if you need more than one memberwise initializer you would have to duplicate that effort.  But re-ordering is going to have a hard time providing enough value if the basic feature does what we need in the majority of cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; **Future?**: I may have to choose between the “ease-of-reading” declaration ordering, the “cleanest-reading member wise init” declaration ordering, and (perhaps?) the “intended memory-layout” declaration ordering.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t want to make this proposal more-complicated than it already is, but I worry a bit about having too many things impacting the choice of how to order declarations in source files; it may be better to include a way to explicitly declare the ordering-for-memberwise:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; E.G., some way of explicitly indicating the memberwise ordering, perhaps like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // syntax example re-using `ComplicatedClass`<br>&gt;&gt;&gt;&gt;&gt;   class ComplicatedClass  {<br>&gt;&gt;&gt;&gt;&gt;     @memberwise($parameterList)<br>&gt;&gt;&gt;&gt;&gt;     // ^ can use just @memberwise to get default ordering + the defaults from<br>&gt;&gt;&gt;&gt;&gt;     //   the property declarations, but perhaps require the explicit listing<br>&gt;&gt;&gt;&gt;&gt;     //   whenver the ordering is not well-defined (e.g. if you have properties<br>&gt;&gt;&gt;&gt;&gt;     //   declared in extensions…then you need to order it yourself)<br>&gt;&gt;&gt;&gt;&gt;     // <br>&gt;&gt;&gt;&gt;&gt;     //   @memberwise(text=&quot;Example&quot;,barData=,fooData)<br>&gt;&gt;&gt;&gt;&gt;     //   - `text=&quot;Example&quot;` =&gt; memberwise init has text=&quot;Example&quot;<br>&gt;&gt;&gt;&gt;&gt;     //   - `barData=` =&gt; memberwise init has `barData` w/out default<br>&gt;&gt;&gt;&gt;&gt;     //   - `fooData` =&gt; memberwise init has `fooData` w/default if it has one<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   …and e.g. the above would make:<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   memberwise init(...)<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   ...expand-to:<br>&gt;&gt;&gt;&gt;&gt;     // <br>&gt;&gt;&gt;&gt;&gt;     //   init(text:String = &quot;Example&quot;, barData: Bar, fooData:Foo?=nil)<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   ...and with the @memberwise declaration supporting a `...` for `super`<br>&gt;&gt;&gt;&gt;&gt;     //   placement, like so:<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   // superclass members come before:<br>&gt;&gt;&gt;&gt;&gt;     //   @memberwise(...,)<br>&gt;&gt;&gt;&gt;&gt;     //   @memberwise(...,$parameterList)<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   // superclass members come after      <br>&gt;&gt;&gt;&gt;&gt;     //   @memberwise(,...)<br>&gt;&gt;&gt;&gt;&gt;     //   @memberwise($parameterList,...)<br>&gt;&gt;&gt;&gt;&gt;     //<br>&gt;&gt;&gt;&gt;&gt;     //   ...perhaps with tweaked syntax (`@memberwise(...,$)` or `@memberwise(...,self)`)<br>&gt;&gt;&gt;&gt;&gt;     //   to be bit easier to read when you don&#39;t have an explicit parameter list?<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...which of course potentially only-further complicates the feature in some ways, but avoids having this use of this feature *necessarily* impact how one might choose to order declarations?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/f394744d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 12:51 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Are you suggesting that this attribute would be applied to a specific initializer?  Or would this be shared by all memberwise initializers of the type in some way?<br></p><p>I meant it as a type-level declaration.<br></p><p>The mental model here is that in many cases, a type with multiple public initializers winds up (or at least should wind up) like this:<br></p><p>- there’s a common “package” comprised of:<br>  - the input parameters (e.g. init args)<br>  - the boilerplate assignments (in the init)<br>- each init has some additional parameters/logic not shared with the other<br></p><p>For another example, this is lightly-adapted from actual code:<br></p><p>class PlayerItemWrapper : NSObject {<br>  let previewInfo: PreviewInfo<br>  let itemDescriptor: ItemDescriptor<br>  let metricCollector: MetricCollector<br>  let playerItem: AVPlayerItem<br></p><p>  // assume trivial assignments followed by observation-setup logic:<br>  required init(previewInfo: PreviewInfo, itemDescriptor: ItemDescriptor, metricCollector: MetricCollector, playerItem: AVPlayerItem)<br></p><p>  // these exist for convenience only; we have them b/c we don’t want to directly use<br>  // the corresponding AVPlayerItem convenience methods, since we also want to<br>  // control some of automatically loaded keys (etc.)<br>  convenience init(previewInfo: PreviewInfo, itemDescriptor: ItemDescriptor, metricCollector: MetricCollector, asset: AVAsset)<br>  convenience init(previewInfo: PreviewInfo, itemDescriptor: ItemDescriptor, metricCollector: MetricCollector, assetURL: NSURL)<br>  convenience init(previewInfo: PreviewInfo, itemDescriptor: ItemDescriptor, metricCollector: MetricCollector, assetDescriptor: AssetDescriptor)<br>}<br></p><p>…where you can easily see these inits have the structure of a “common package” + per-init details.<br></p><p>Under the organization above, it then makes sense to me to have a type-level declaration that is able to declare that type’s “official” common package, which would let the above be condensed into something like:<br></p><p>class PlayerItemWrapper : NSObject {<br>  @memberwise(previewInfo, itemDescriptor, metricCollector)<br>  // ^ need to be explicit here to *omit* playerItem, unless we<br>  //   also plan to immediately have an @nomemberwise declaration<br>  //   we can apply to individual properties<br>  let previewInfo: PreviewInfo<br>  let itemDescriptor: ItemDescriptor<br>  let metricCollector: MetricCollector<br>  let playerItem: AVPlayerItem<br></p><p>  // assume trivial assignments followed by observation-setup logic:<br>  memberwise required init(..., playerItem: AVPlayerItem)<br></p><p>  // these exist for convenience only (and would need a way to forward the … <br>  // to the required init, e.g. `self.init(…, playerItem: _)`, which is seems to be<br>  // noted as a future direction in the current proposal<br>  memberwise convenience init(…, asset: AVAsset)<br>  memberwise convenience init(..., assetURL: NSURL)<br>  memberwise convenience init(..., assetDescriptor: AssetDescriptor)<br>}<br></p><p>…and because writing out such parameter lists explicitly is a bit of a pain, the hope is that it’d also be possible to simply write e.g. @memberwise w/out an explicit list and get some automatically-inferred list synthesized on your behalf wherever possible.<br></p><p>Hope this clears up the kind of thing I was trying to sketch earlier. It is at a different point in the flexibility/feature spectrum for sure, and not thought-through too thoroughly either.<br></p><p>I also made a significant earlier error: it shouldn’t be an error if some @memberwise’s $parameterList was *incomplete*, the only error is if it contains invalid/unrecognized names.<br></p><p>&gt; I don’t think applying this to a specific initializer gains enough over just writing the initializer manually to be worthwhile.  If we were going to do something specific to a single initializer, something along the lines of David’s suggestion makes the most sense to me.<br>&gt; <br>&gt; On the other hand, if you are suggesting something type-wide that would be shared by all memberwise initializers, this is really an alternate way to accomplish an opt-in model.  Rather than applying an attribute to properties you would have a declaration specify which properties are included in memberwise initializers, with the ability to specify order, labels, and defaults if necessary.  <br></p><p>This is what I meant, essentially. An explicit @memberwise as per the above saves minimal effort if you had to do it on a per-init basis, but in scenarios with a bunch of basic parameters + various convenience inits for the remaining parameters it could still be a net win.<br></p><p>&gt; That might be a reasonable syntax for an opt-in model.  As noted in the proposal, an opt-in model could be added by a future enhancement and would be used in place of the automatic model if the opt-in syntax was present.<br></p><p>If this goes anywhere I am hoping someone will improve the syntax, actually, what I sketched seems clunky and non-idiomatic.<br></p><p>In any case, having seen how this discussion has gone I think it’s safe that at least in hindsight starting from the purely-automatic/purely-inferred synthesis standpoint may ultimately have made this proposal than it needs to have been.<br></p><p>It’s a *really* good goal — I’d like to be able to get the memberwise init synthesized automatically where possible! — and I think within the design constraints you’ve been working under it may not be possible to do it that much better than as per your proposal…but I think the conclusion here is that “it seemed plausible to extend the memberwise-init synthesis like this, but if you work through it in enough detail to make it concrete, it has a surprising amount of intrinsic complexity/inference rules/edge-cases to worry about”.<br></p><p>That’s my overall 2c here (along with what’s in the earlier emails).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/d084f55d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br>-1<br>It adds a lot of stuff to the language that doesn&#39;t pay off enough.<br>There are already many concepts that are very specific and useful only for init, and it should be avoided to add more.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Definitely yes, but the imho most important thing (initial values for constants) will require even more additional syntax, as it isn&#39;t covered yet.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>You will know better, but hope for bigger ambitions ;-)<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>That is the source of my major objection:<br>The proposal is ok, but it makes initialization even more complicated — for me, this would destroy the last advantage Swift has over other languages (Scala, Kotlin...) in this area.<br>Other approaches are imho superior in every single aspect, and even if they are not &quot;swifty&quot; enough to get incorporated, their performance should be our reference value.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Quite a lot, as I&#39;ve been involved in the discussion.<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>The proposal says that &quot;let&quot; properties with inline initializers should be left out of the memberwise initialization, AIUI on the grounds that a manually-written initializer would not be allowed to override the inline initialization:<br></p><p>class C {<br>  let x = 1738<br>  init(x: Int = 679) {<br>    self.x = x // Error, self.x already initialized<br>  }<br>}<br></p><p>However, this is also true for vars. Semantically, if you change &#39;x&#39; to a var in the above example, you get an initialization followed by an assignment:<br></p><p>class C {<br>  let x = dump(1738)<br>  init(x: Int = dump(679)) {<br>    self.x = x<br>  }<br>}<br></p><p>	    C() // dumps 1738, then 679<br></p><p>which, if the initialization has side effects, will likely be surprising. We could say that the memberwise initializer elides the inline initialization of `var`s, on the grounds that initializations ought not to have side effects, but then we&#39;re introducing a behavior change in inline initializers for `var`s in the face of `memberwise` initializers that also cannot be replicated by a manually-written initializer. If we make that behavior change for vars, I think it&#39;s reasonable, and more orthogonal, to extend the same grace to lets as well. That also simplifies the rules for what appears in the memberwise initializer—there&#39;s now only two rules (or one, if we also remove the access control filter, as I&#39;ve suggested in another subthread).<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/5f0832a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 8:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The proposal says that &quot;let&quot; properties with inline initializers should be left out of the memberwise initialization, AIUI on the grounds that a manually-written initializer would not be allowed to override the inline initialization:<br></p><p>Yes, this is because Chris insisted that the proposal be pure sugar for something that could be manually written.  This ensures that anyone using memberwise initialization can stop using it in any case where that becomes necessary. <br></p><p>&gt; <br>&gt; class C {<br>&gt;   let x = 1738<br>&gt;   init(x: Int = 679) {<br>&gt;     self.x = x // Error, self.x already initialized<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; However, this is also true for vars. Semantically, if you change &#39;x&#39; to a var in the above example, you get an initialization followed by an assignment:<br>&gt; <br>&gt; class C {<br>&gt;   let x = dump(1738)<br>&gt;   init(x: Int = dump(679)) {<br>&gt;     self.x = x<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; 	    C() // dumps 1738, then 679<br>&gt; <br>&gt; which, if the initialization has side effects, will likely be surprising. We could say that the memberwise initializer elides the inline initialization of `var`s, on the grounds that initializations ought not to have side effects, but then we&#39;re introducing a behavior change in inline initializers for `var`s in the face of `memberwise` initializers that also cannot be replicated by a manually-written initializer. If we make that behavior change for vars, I think it&#39;s reasonable, and more orthogonal, to extend the same grace to lets as well. That also simplifies the rules for what appears in the memberwise initializer—there&#39;s now only two rules (or one, if we also remove the access control filter, as I&#39;ve suggested in another subthread).<br></p><p>I agree.  The dual assignment for `var` seems wasteful in addition to potentially surprising and the limitation for `let` is unfortunate.  Of course the same can be said for all initializers that might wish to assign a different value to a `let` or do assign a different value to a `var`.<br></p><p>What you suggest is exactly how I wanted the proposal to work.  Chris was opposed to this approach.  I would be very happy with this change if you can sell Chris on it!  I think many others would be as well. <br></p><p>In addition to this not being possible to implement manually, Chris explained to me that it is important to the optimizer to be able to assume a `let` with an inline initializer will never have any other value (especially when that inline initializer is a constant value).  Allowing an instance member to be optimized away when initialized with a constant value enables it to be referenced with convenient syntax due to implicit `self`.  It would have never occurred to me to make a true constant value an instance property, but apparently this is a common practice.  And with a guaranteed optimization is makes sense to take advantage of the implicit `self`.  <br></p><p>At the same time, IMO the inability to provide a default value for a property that is only used when it is not initialized manually is a more important issue.  I wish the “inline initializer” worked this way.  <br></p><p>I know the implementation would be a bit more complex - the compiler would have to analyze the body of non-memberwise initializers before synthesizing the inline-initialization if necessary.  But it already emits an “uninitialized member” error message so it already knows which properties are initialized and which are not.  That information may not be available in the right part of the compiler but we do not how to determine this.<br></p><p>This would solve the init / assign problem for `var` and the no overridable default problem for `let` in both existing and memberwise initializers.  It would also mean that memberwise initializers can work this way while still being pure sugar for code that can be written manually.  Unfortunately this seems like something that is not open for change.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/55e365a7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January  7, 2016 at 11:00:00pm</p></header><div class="content"><p>I cast a reluctant -1<br></p><p>I&#39;ve followed this thread since its beginning and do believe that this<br>could be a  nice feature but I agree that it doesn&#39;t pay for its own<br>complexity in this proposal. We would be better served if we could spell<br>out what needs to be implemented for the variadics and or the magic Members<br>tuple, in my opinion.<br></p><p><br></p><p>On Thu, Jan 7, 2016 at 10:37 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 7, 2016, at 8:55 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The proposal says that &quot;let&quot; properties with inline initializers should be<br>&gt; left out of the memberwise initialization, AIUI on the grounds that a<br>&gt; manually-written initializer would not be allowed to override the inline<br>&gt; initialization:<br>&gt;<br>&gt;<br>&gt; Yes, this is because Chris insisted that the proposal be pure sugar for<br>&gt; something that could be manually written.  This ensures that anyone using<br>&gt; memberwise initialization can stop using it in any case where that becomes<br>&gt; necessary.<br>&gt;<br>&gt;<br>&gt; class C {<br>&gt;   let x = 1738<br>&gt;   init(x: Int = 679) {<br>&gt;     self.x = x // Error, self.x already initialized<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; However, this is also true for vars. Semantically, if you change &#39;x&#39; to a<br>&gt; var in the above example, you get an initialization followed by an<br>&gt; assignment:<br>&gt;<br>&gt; class C {<br>&gt;   let x = dump(1738)<br>&gt;   init(x: Int = dump(679)) {<br>&gt;     self.x = x<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;     C() // dumps 1738, then 679<br>&gt;<br>&gt; which, if the initialization has side effects, will likely be surprising.<br>&gt; We could say that the memberwise initializer elides the inline<br>&gt; initialization of `var`s, on the grounds that initializations ought not to<br>&gt; have side effects, but then we&#39;re introducing a behavior change in inline<br>&gt; initializers for `var`s in the face of `memberwise` initializers that also<br>&gt; cannot be replicated by a manually-written initializer. If we make that<br>&gt; behavior change for vars, I think it&#39;s reasonable, and more orthogonal, to<br>&gt; extend the same grace to lets as well. That also simplifies the rules for<br>&gt; what appears in the memberwise initializer—there&#39;s now only two rules (or<br>&gt; one, if we also remove the access control filter, as I&#39;ve suggested in<br>&gt; another subthread).<br>&gt;<br>&gt;<br>&gt; I agree.  The dual assignment for `var` seems wasteful in addition to<br>&gt; potentially surprising and the limitation for `let` is unfortunate.  Of<br>&gt; course the same can be said for all initializers that might wish to assign<br>&gt; a different value to a `let` or do assign a different value to a `var`.<br>&gt;<br>&gt; What you suggest is exactly how I wanted the proposal to work.  Chris was<br>&gt; opposed to this approach.  I would be very happy with this change if you<br>&gt; can sell Chris on it!  I think many others would be as well.<br>&gt;<br>&gt; In addition to this not being possible to implement manually, Chris<br>&gt; explained to me that it is important to the optimizer to be able to assume<br>&gt; a `let` with an inline initializer will never have any other value<br>&gt; (especially when that inline initializer is a constant value).  Allowing an<br>&gt; instance member to be optimized away when initialized with a constant value<br>&gt; enables it to be referenced with convenient syntax due to implicit `self`.<br>&gt; It would have never occurred to me to make a true constant value an<br>&gt; instance property, but apparently this is a common practice.  And with a<br>&gt; guaranteed optimization is makes sense to take advantage of the implicit<br>&gt; `self`.<br>&gt;<br>&gt; At the same time, IMO the inability to provide a default value for a<br>&gt; property that is only used when it is not initialized manually is a more<br>&gt; important issue.  I wish the “inline initializer” worked this way.<br>&gt;<br>&gt; I know the implementation would be a bit more complex - the compiler would<br>&gt; have to analyze the body of non-memberwise initializers before synthesizing<br>&gt; the inline-initialization if necessary.  But it already emits an<br>&gt; “uninitialized member” error message so it already knows which properties<br>&gt; are initialized and which are not.  That information may not be available<br>&gt; in the right part of the compiler but we do not how to determine this.<br>&gt;<br>&gt; This would solve the init / assign problem for `var` and the no<br>&gt; overridable default problem for `let` in both existing and memberwise<br>&gt; initializers.  It would also mean that memberwise initializers can work<br>&gt; this way while still being pure sugar for code that can be written<br>&gt; manually.  Unfortunately this seems like something that is not open for<br>&gt; change.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/432d94c5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b22bad6d88de707d2ae9531c185ff?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;trsfoo at googlemail.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>AFAIU with the current proposal I would have to write the following to give a let property a default value:<br></p><p>class C {<br>	var x: Int<br>	var y: Int<br>	let c: Int<br></p><p>	memberwise init(…, c: Int = 42) {<br>		self.c = c<br>	}<br>}<br></p><p>Did I understand this right?<br></p><p>-Thorsten<br></p><p><br>&gt; Am 08.01.2016 um 04:37 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 8:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal says that &quot;let&quot; properties with inline initializers should be left out of the memberwise initialization, AIUI on the grounds that a manually-written initializer would not be allowed to override the inline initialization:<br>&gt; <br>&gt; Yes, this is because Chris insisted that the proposal be pure sugar for something that could be manually written.  This ensures that anyone using memberwise initialization can stop using it in any case where that becomes necessary. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt;   let x = 1738<br>&gt;&gt;   init(x: Int = 679) {<br>&gt;&gt;     self.x = x // Error, self.x already initialized<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, this is also true for vars. Semantically, if you change &#39;x&#39; to a var in the above example, you get an initialization followed by an assignment:<br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt;   let x = dump(1738)<br>&gt;&gt;   init(x: Int = dump(679)) {<br>&gt;&gt;     self.x = x<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 	    C() // dumps 1738, then 679<br>&gt;&gt; <br>&gt;&gt; which, if the initialization has side effects, will likely be surprising. We could say that the memberwise initializer elides the inline initialization of `var`s, on the grounds that initializations ought not to have side effects, but then we&#39;re introducing a behavior change in inline initializers for `var`s in the face of `memberwise` initializers that also cannot be replicated by a manually-written initializer. If we make that behavior change for vars, I think it&#39;s reasonable, and more orthogonal, to extend the same grace to lets as well. That also simplifies the rules for what appears in the memberwise initializer—there&#39;s now only two rules (or one, if we also remove the access control filter, as I&#39;ve suggested in another subthread).<br>&gt; <br>&gt; I agree.  The dual assignment for `var` seems wasteful in addition to potentially surprising and the limitation for `let` is unfortunate.  Of course the same can be said for all initializers that might wish to assign a different value to a `let` or do assign a different value to a `var`.<br>&gt; <br>&gt; What you suggest is exactly how I wanted the proposal to work.  Chris was opposed to this approach.  I would be very happy with this change if you can sell Chris on it!  I think many others would be as well. <br>&gt; <br>&gt; In addition to this not being possible to implement manually, Chris explained to me that it is important to the optimizer to be able to assume a `let` with an inline initializer will never have any other value (especially when that inline initializer is a constant value).  Allowing an instance member to be optimized away when initialized with a constant value enables it to be referenced with convenient syntax due to implicit `self`.  It would have never occurred to me to make a true constant value an instance property, but apparently this is a common practice.  And with a guaranteed optimization is makes sense to take advantage of the implicit `self`.  <br>&gt; <br>&gt; At the same time, IMO the inability to provide a default value for a property that is only used when it is not initialized manually is a more important issue.  I wish the “inline initializer” worked this way.  <br>&gt; <br>&gt; I know the implementation would be a bit more complex - the compiler would have to analyze the body of non-memberwise initializers before synthesizing the inline-initialization if necessary.  But it already emits an “uninitialized member” error message so it already knows which properties are initialized and which are not.  That information may not be available in the right part of the compiler but we do not how to determine this.<br>&gt; <br>&gt; This would solve the init / assign problem for `var` and the no overridable default problem for `let` in both existing and memberwise initializers.  It would also mean that memberwise initializers can work this way while still being pure sugar for code that can be written manually.  Unfortunately this seems like something that is not open for change.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/c6b5c39c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 3:33 AM, Thorsten Seitz &lt;trsfoo at googlemail.com&gt; wrote:<br>&gt; <br>&gt; AFAIU with the current proposal I would have to write the following to give a let property a default value:<br>&gt; <br>&gt; class C {<br>&gt; 	var x: Int<br>&gt; 	var y: Int<br>&gt; 	let c: Int<br>&gt; <br>&gt; 	memberwise init(…, c: Int = 42) {<br>&gt; 		self.c = c<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Did I understand this right?<br></p><p>No, this wouldn’t be possible.  The let would receive a memberwise initialization parameter with no default.  This code would declare a second parameter with the same label which would produce a compiler error.  It would also attempt a second initialization of `self.c` which would also produce a compiler error.  <br></p><p>The lack of a default for `let` properties is a very unfortunate limitation that I hope will be resolved.  I attempted to solve it but could not come up with a solution Chris considered workable.  I don’t think it is bad enough to reject the proposal altogether.  The proposal is still a significant step forward from the existing memberwise initializer and it does not prevent you from writing manual initializers when necessary.<br></p><p>One way to tweak the proposal to allow the code above would be to suppress the synthesized memberwise initialization parameter instead of producing a compiler error.  I didn’t choose that approach because it complicates both the model and the implementation further.  I think that complication is unnecessary if we are able to solve the two critical (IMO) issues remaining with this proposal:<br></p><p>1. We need a way to specify a default value for memberwise parameters for `let` properties.<br>2. We need a little bit more control over which properties participate in memberwise initialization when the “automatic” rules don’t quite do the right thing for a particular use case.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 08.01.2016 um 04:37 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 8:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal says that &quot;let&quot; properties with inline initializers should be left out of the memberwise initialization, AIUI on the grounds that a manually-written initializer would not be allowed to override the inline initialization:<br>&gt;&gt; <br>&gt;&gt; Yes, this is because Chris insisted that the proposal be pure sugar for something that could be manually written.  This ensures that anyone using memberwise initialization can stop using it in any case where that becomes necessary. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;   let x = 1738<br>&gt;&gt;&gt;   init(x: Int = 679) {<br>&gt;&gt;&gt;     self.x = x // Error, self.x already initialized<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, this is also true for vars. Semantically, if you change &#39;x&#39; to a var in the above example, you get an initialization followed by an assignment:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;   let x = dump(1738)<br>&gt;&gt;&gt;   init(x: Int = dump(679)) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	    C() // dumps 1738, then 679<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which, if the initialization has side effects, will likely be surprising. We could say that the memberwise initializer elides the inline initialization of `var`s, on the grounds that initializations ought not to have side effects, but then we&#39;re introducing a behavior change in inline initializers for `var`s in the face of `memberwise` initializers that also cannot be replicated by a manually-written initializer. If we make that behavior change for vars, I think it&#39;s reasonable, and more orthogonal, to extend the same grace to lets as well. That also simplifies the rules for what appears in the memberwise initializer—there&#39;s now only two rules (or one, if we also remove the access control filter, as I&#39;ve suggested in another subthread).<br>&gt;&gt; <br>&gt;&gt; I agree.  The dual assignment for `var` seems wasteful in addition to potentially surprising and the limitation for `let` is unfortunate.  Of course the same can be said for all initializers that might wish to assign a different value to a `let` or do assign a different value to a `var`.<br>&gt;&gt; <br>&gt;&gt; What you suggest is exactly how I wanted the proposal to work.  Chris was opposed to this approach.  I would be very happy with this change if you can sell Chris on it!  I think many others would be as well. <br>&gt;&gt; <br>&gt;&gt; In addition to this not being possible to implement manually, Chris explained to me that it is important to the optimizer to be able to assume a `let` with an inline initializer will never have any other value (especially when that inline initializer is a constant value).  Allowing an instance member to be optimized away when initialized with a constant value enables it to be referenced with convenient syntax due to implicit `self`.  It would have never occurred to me to make a true constant value an instance property, but apparently this is a common practice.  And with a guaranteed optimization is makes sense to take advantage of the implicit `self`.  <br>&gt;&gt; <br>&gt;&gt; At the same time, IMO the inability to provide a default value for a property that is only used when it is not initialized manually is a more important issue.  I wish the “inline initializer” worked this way.  <br>&gt;&gt; <br>&gt;&gt; I know the implementation would be a bit more complex - the compiler would have to analyze the body of non-memberwise initializers before synthesizing the inline-initialization if necessary.  But it already emits an “uninitialized member” error message so it already knows which properties are initialized and which are not.  That information may not be available in the right part of the compiler but we do not how to determine this.<br>&gt;&gt; <br>&gt;&gt; This would solve the init / assign problem for `var` and the no overridable default problem for `let` in both existing and memberwise initializers.  It would also mean that memberwise initializers can work this way while still being pure sugar for code that can be written manually.  Unfortunately this seems like something that is not open for change.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/3008126d/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>January  8, 2016 at 11:00:00pm</p></header><div class="content"><p>- What is your evaluation of the proposal?<br></p><p>I’m in favour of this proposal. I really like the first syntax of @default from the future enhancements.<br></p><p>- Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>- Does this proposal fit well with the feel and direction of Swift?<br></p><p>It feels like it.<br></p><p>- How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I have read the proposal and followed some of the discussions.<br></p><p>&gt; On 7Jan, 2016, at 6:47 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>I have reservations about it. I think it should be deferred in search of a more generic solution, perhaps to be resurrected if the search for generality fails.<br></p><p>I appreciate the tremendous care that has obviously gone into the proposal. The dual attention to use cases and corner cases is admirable. The proposal present a thorough understanding of the problem that includes considerations I certainly hadn’t thought of!<br></p><p>Still, I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br></p><p>On reflection, it comes down to this: the feature to functionality ratio is too high.<br></p><p>That probably requires some explanation. By “feature,” I mean a specific behavior the software implements for which users will need a mental model. By “functionality,” I mean the set of things one can do with the software, and more importantly the nature of the user’s experience doing them.<br></p><p>An example of a high feature/functionality payoff is Swift’s as-if-immutable structs. There’s a fairly large set of relevant features: the let/var distinction for declarations, the “mutating” keyword, the interaction of “let” with setters and mutating methods, and the way “let” recursively affects structs inside of structs. However, all of that folds into a mental model with a nice unifying principle: Swift structs behave semantically as if they are all always immutable and mutations create a new struct and reassign it to the variable; however, they perform better than that, because the compiler will optimize that into a direct mutation when possible. The features pay huge functionality dividends across a wide variety of situations: defensive programming, passing data across threads, isolating responsibility … it goes on.<br></p><p>(Really, “functionality” is a qualitative thing, more about the experience than just “what can I do,” and so talking about the “feature to functionality ratio” is only a metaphorical gesture. It captures the right feeling, though.)<br></p><p>In this proposal, there’s a similarly large set of new features: the “memberwise” keyword, the new use of …, multiple interacting rules about memberwise property eligibility, synthesized initialization, rules about how that interacts with manual initialization. For all that, though, the functionality gain is limited: we shed some senseless repetition — that’s good! — but only for copying of parameters to properties, only when they’re in the same order, and only in initializers.<br></p><p>The proposal reads like a set of specific use cases translated directly into specific features, without a good eye to the bigger picture.<br></p><p>It feels to me like this functionality should come from a feature set that is more general, more arbitrarily composable, and pays greater dividends in a wider variety of situations. As a simple example, what if I want to write an updateFrom(other: Self) method that does a mass copy of all properties? Why doesn’t this proposal help with that, too? Because the … placeholder and the synthesized copying are tightly coupled (1) to each other and (2) to initialization.<br></p><p>I’m not sure what the better answer is, but it’s out there. I didn’t follow the whole discussion, but I did notice Joe Groff’s proposal for a Members tuple; that seems to me to be getting much warmer. I’d much prefer something along those lines, even if it were slightly more verbose.<br></p><p>(Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br></p><p><br>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It’s certainly worth considering. Mindless parameter copying is a source of low-value verbosity, and can lead to errors.<br></p><p><br>Does this proposal fit well with the feel and direction of Swift?<br></p><p>It does in that it aims to reduce developer error and verbosity by providing an idiom to solve a common problem.<br></p><p>It does not in that the idiom is so narrow. The language is moving away from that in other realms (e.g. lazy).<br></p><p><br>If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve never heard of a language with such a high specialized tool for doing just this.<br></p><p>Ruby and Javascript allow programmatic traversal of both arguments and properties, and provide enough reflection to automate that. Developers in both languages do write ad hoc solutions to do almost exactly what this proposal does, though they’re not widely used. The most common is probably variations on this:<br></p><p>def initialize(**args)<br>  args.each do |prop, value|<br>    obj.send(&quot;#{prop}=&quot;, value)<br>  end<br>end<br></p><p>…which uses key/value pairs from an argument array to set properties.<br></p><p>Being able to convert arguments to a dictionary is something Swift certainly might investigate.<br></p><p><br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal carefully, but only lightly skimmed the discussion and other reviews.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/243df267/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br></p><p>FWIW I believe it’s meant to be interpreted as &quot;M lines of boilerplate per initializer&quot; x &quot;N initializers” =&gt; ~ MN lines of initializer-related boilerplate per type. <br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/e5ffd071/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb5a6986048ff63d65b0f34fd1ecd1a9?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Paul Cantrell</string> &lt;paul at innig.net&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:11 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt; <br>&gt; FWIW I believe it’s meant to be interpreted as &quot;M lines of boilerplate per initializer&quot; x &quot;N initializers” =&gt; ~ MN lines of initializer-related boilerplate per type. <br></p><p>Ah, right, per initializer — not per initialized variable. My bad! That makes much more sense.<br></p><p>P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/6b7dddfb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:11 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt; <br>&gt; FWIW I believe it’s meant to be interpreted as &quot;M lines of boilerplate per initializer&quot; x &quot;N initializers” =&gt; ~ MN lines of initializer-related boilerplate per type.<br></p><p>Yep.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/d6f9ea65/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I have reservations about it. I think it should be deferred in search of a more generic solution, perhaps to be resurrected if the search for generality fails.<br>&gt; <br>&gt; I appreciate the tremendous care that has obviously gone into the proposal. The dual attention to use cases and corner cases is admirable. The proposal present a thorough understanding of the problem that includes considerations I certainly hadn’t thought of!<br></p><p>Thanks Paul!<br></p><p>&gt; <br>&gt; Still, I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br>&gt; <br>&gt; On reflection, it comes down to this: the feature to functionality ratio is too high.<br></p><p>Would you propose removing the current implicit memberwise initializer for structs on the same grounds?  This proposal effectively fleshes that feature out giving it more functionality.  The only fundamental complexity it adds is the access control rules, which I feel are pretty important to enforce.<br></p><p><br>&gt; <br>&gt; That probably requires some explanation. By “feature,” I mean a specific behavior the software implements for which users will need a mental model. By “functionality,” I mean the set of things one can do with the software, and more importantly the nature of the user’s experience doing them.<br>&gt; <br>&gt; An example of a high feature/functionality payoff is Swift’s as-if-immutable structs. There’s a fairly large set of relevant features: the let/var distinction for declarations, the “mutating” keyword, the interaction of “let” with setters and mutating methods, and the way “let” recursively affects structs inside of structs. However, all of that folds into a mental model with a nice unifying principle: Swift structs behave semantically as if they are all always immutable and mutations create a new struct and reassign it to the variable; however, they perform better than that, because the compiler will optimize that into a direct mutation when possible. The features pay huge functionality dividends across a wide variety of situations: defensive programming, passing data across threads, isolating responsibility … it goes on.<br>&gt; <br>&gt; (Really, “functionality” is a qualitative thing, more about the experience than just “what can I do,” and so talking about the “feature to functionality ratio” is only a metaphorical gesture. It captures the right feeling, though.)<br>&gt; <br>&gt; In this proposal, there’s a similarly large set of new features: the “memberwise” keyword, the new use of …, multiple interacting rules about memberwise property eligibility, synthesized initialization, rules about how that interacts with manual initialization. For all that, though, the functionality gain is limited: we shed some senseless repetition — that’s good! — but only for copying of parameters to properties, only when they’re in the same order, and only in initializers.<br>&gt; <br>&gt; The proposal reads like a set of specific use cases translated directly into specific features, without a good eye to the bigger picture.<br>&gt; <br>&gt; It feels to me like this functionality should come from a feature set that is more general, more arbitrarily composable, and pays greater dividends in a wider variety of situations. As a simple example, what if I want to write an updateFrom(other: Self) method that does a mass copy of all properties? Why doesn’t this proposal help with that, too? Because the … placeholder and the synthesized copying are tightly coupled (1) to each other and (2) to initialization.<br>&gt; <br>&gt; I’m not sure what the better answer is, but it’s out there. I didn’t follow the whole discussion, but I did notice Joe Groff’s proposal for a Members tuple; that seems to me to be getting much warmer. I’d much prefer something along those lines, even if it were slightly more verbose.<br></p><p>I think the direction suggested by Joe (and Dave) is interesting.  But they haven’t explained how it would handle some important use cases this proposal addresses (default parameter values, subset of members without using a struct, etc).  If we are going to reject this proposal in hope of a more general solution I would at least like to see a path forward that might be able to address these use cases.<br></p><p>More importantly, the general features on their own would not address the problems addressed by this proposal.  There would still need to be initializer-specific magic.  Joe hinted at what that might be but has not fleshed out all the details yet.  Maybe it would be a simpler model but we would need to see more specific details.<br></p><p>I don’t believe a fully generalized solution is possible.  There are a lot of initialization-specific constraints that must be met (definitive initialization, single initialization of `let` properties, etc).<br></p><p>&gt; <br>&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br></p><p>MxN is members x initializers.<br></p><p>&gt; <br>&gt; <br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; It’s certainly worth considering. Mindless parameter copying is a source of low-value verbosity, and can lead to errors.<br>&gt; <br>&gt; <br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; It does in that it aims to reduce developer error and verbosity by providing an idiom to solve a common problem.<br>&gt; <br>&gt; It does not in that the idiom is so narrow. The language is moving away from that in other realms (e.g. lazy).<br>&gt; <br>&gt; <br>&gt; If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I’ve never heard of a language with such a high specialized tool for doing just this.<br>&gt; <br>&gt; Ruby and Javascript allow programmatic traversal of both arguments and properties, and provide enough reflection to automate that. Developers in both languages do write ad hoc solutions to do almost exactly what this proposal does, though they’re not widely used. The most common is probably variations on this:<br>&gt; <br>&gt; def initialize(**args)<br>&gt;   args.each do |prop, value|<br>&gt;     obj.send(&quot;#{prop}=&quot;, value)<br>&gt;   end<br>&gt; end<br>&gt; <br>&gt; …which uses key/value pairs from an argument array to set properties.<br>&gt; <br>&gt; Being able to convert arguments to a dictionary is something Swift certainly might investigate.<br></p><p>We should have a safe solution that allows the compiler to enforce type checking and definitive initialization rules.<br></p><p>&gt; <br>&gt; <br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read the proposal carefully, but only lightly skimmed the discussion and other reviews.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 4:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/36e4a17c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 9:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Still, I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br>&gt;&gt; <br>&gt;&gt; On reflection, it comes down to this: the feature to functionality ratio is too high.<br>&gt; <br>&gt; Would you propose removing the current implicit memberwise initializer for structs on the same grounds?  This proposal effectively fleshes that feature out giving it more functionality.  The only fundamental complexity it adds is the access control rules, which I feel are pretty important to enforce.<br></p><p>The struct memberwise behavior today is really simple and doesn’t expose a public API allowing for non-exhaustive behavior requirements and a much simpler design.<br></p><p>The struct rule is basically this:<br></p><p>A member is added to the initializer when the following conditions are true:<br>    1. The member is not declared with let and an initialization value<br>    2. The member is not a computed property<br></p><p>Also, this generated initializer is only generated when no other init() has been defined.<br></p><p>The really important observation though is that it keeps the generated initializer private, which means that there are no real API contracts to consider as it can only be used within your own code. It’s a nicety to have when simply building up some code to solve a problem.<br></p><p>The proposal essentially is doing two things:<br></p><p>    1. Create a way to generate a public API contract based on a series of fairly complicated rules, potential annotations, and member orderings within the type<br>    2. Generate the pass through of assignment for the parameters of the init() and their backing values.<br></p><p>The vast amount complexity comes from trying to solve #1.<br></p><p>As for this:<br></p><p>&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt; <br>&gt; MxN is members x initializers.<br></p><p><br>Paul, this has also bugged me too; I do not see how it is accurate. There aren’t N initializers, there is one initializer that must fully instantiate the type. Each type may have additional convenience initializers, but these are not required. Further, they cannot make use of the placeholder. There is a “futures” that talks about it, but that’s out of scope of the original proposal. <br></p><p>Your example hear illustrates the complexity (slightly modified from your proposal’s usage):<br></p><p>struct Foo {<br>  let bar: String<br>  let bas: Int<br>  let baz: Double<br></p><p>  init(self bar: String, self bas: Int, bax: Int) {<br>    // self.bar = bar synthesized by the compiler<br>    // self.bas = bas synthesized by the compiler<br>    self.baz = Double(bax)<br>  }<br>}<br></p><p>The only thing I see your proposal removing is the re-typing of all of the members in the init signature that can be configured. And in fact, the current proposal doesn&#39;t support this. You have a futures section that looks a way to make this possible kinda like this:<br></p><p>struct Foo {<br>  let bar: String<br>  let bas: Int<br>  let baz: Double<br></p><p>  @nomemberwize(baz)<br>  memberwise init(..., bax: Int) {<br>    // self.bar = bar synthesized by the compiler<br>    // self.bas = bas synthesized by the compiler<br>    self.baz = Double(bax)<br>  }<br>}<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/9f624481/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 12:51 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 9:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Still, I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On reflection, it comes down to this: the feature to functionality ratio is too high.<br>&gt;&gt; <br>&gt;&gt; Would you propose removing the current implicit memberwise initializer for structs on the same grounds?  This proposal effectively fleshes that feature out giving it more functionality.  The only fundamental complexity it adds is the access control rules, which I feel are pretty important to enforce.<br>&gt; <br>&gt; The struct memberwise behavior today is really simple and doesn’t expose a public API allowing for non-exhaustive behavior requirements and a much simpler design.<br>&gt; <br>&gt; The struct rule is basically this:<br>&gt; <br>&gt; A member is added to the initializer when the following conditions are true:<br>&gt;     1. The member is not declared with let and an initialization value<br>&gt;     2. The member is not a computed property<br>&gt; <br>&gt; Also, this generated initializer is only generated when no other init() has been defined.<br>&gt; <br>&gt; The really important observation though is that it keeps the generated initializer private, which means that there are no real API contracts to consider as it can only be used within your own code. It’s a nicety to have when simply building up some code to solve a problem.<br></p><p>Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br></p><p>&gt; <br>&gt; The proposal essentially is doing two things:<br>&gt; <br>&gt;     1. Create a way to generate a public API contract based on a series of fairly complicated rules, potential annotations, and member orderings within the type<br></p><p>Would you feel better about the proposal if it did not allow for public memberwise initializers?<br></p><p>&gt;     2. Generate the pass through of assignment for the parameters of the init() and their backing values.<br>&gt; <br>&gt; The vast amount complexity comes from trying to solve #1.<br></p><p>This is not true.  I would still want access control enforced even if memberwise initializers could not be public.<br></p><p>&gt; <br>&gt; As for this:<br>&gt; <br>&gt;&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt;&gt; <br>&gt;&gt; MxN is members x initializers.<br>&gt; <br>&gt; <br>&gt; Paul, this has also bugged me too; I do not see how it is accurate. There aren’t N initializers, there is one initializer that must fully instantiate the type. Each type may have additional convenience initializers, but these are not required. Further, they cannot make use of the placeholder. There is a “futures” that talks about it, but that’s out of scope of the original proposal. <br></p><p>Swift allows more than one designated initializer.  N never large but it more than 1 in enough cases to matter.  The point is that it results in enough boilerplate that I believe it affects how many people design their initializers.  <br>&gt; <br>&gt; Your example hear illustrates the complexity (slightly modified from your proposal’s usage):<br>&gt; <br>&gt; struct Foo {<br>&gt;   let bar: String<br>&gt;   let bas: Int<br>&gt;   let baz: Double<br>&gt; <br>&gt;   init(self bar: String, self bas: Int, bax: Int) {<br>&gt;     // self.bar = bar synthesized by the compiler<br>&gt;     // self.bas = bas synthesized by the compiler<br>&gt;     self.baz = Double(bax)<br>&gt;   }<br>&gt; }<br></p><p>This approach has been mentioned quite a few times.  It results in a lot of duplication without saving a lot.  This is especially true if you have a lot of properties and more than one designated initializer that could use memberwise initialization .  <br></p><p>IMO, if we were going to take this approach we should at least be able to omit redundant type information and default values for `var` properties where they exist.  At least then we are saving as much as we can under this approach.<br></p><p>struct Foo {<br>  let bar: String<br>  let bas: Int<br>  let baz: Double<br></p><p>  init(self bar, self bas, bax: Int) {<br>    // self.bar = bar synthesized by the compiler<br>    // self.bas = bas synthesized by the compiler<br>    self.baz = Double(bax)<br>  }<br>}<br></p><p>&gt; <br>&gt; The only thing I see your proposal removing is the re-typing of all of the members in the init signature that can be configured. And in fact, the current proposal doesn&#39;t support this. You have a futures section that looks a way to make this possible kinda like this:<br>&gt; <br>&gt; struct Foo {<br>&gt;   let bar: String<br>&gt;   let bas: Int<br>&gt;   let baz: Double<br>&gt; <br>&gt;   @nomemberwize(baz)<br>&gt;   memberwise init(..., bax: Int) {<br>&gt;     // self.bar = bar synthesized by the compiler<br>&gt;     // self.bas = bas synthesized by the compiler<br>&gt;     self.baz = Double(bax)<br>&gt;   }<br>&gt; }<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/8300bded/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br></p><p>Not for me in Xcode 7.2. Has this changed? Maybe it’s my app target? The implicit init() is only visible for me within the same file the struct is defined in.<br></p><p><br>&gt;&gt; <br>&gt;&gt; The proposal essentially is doing two things:<br>&gt;&gt; <br>&gt;&gt;     1. Create a way to generate a public API contract based on a series of fairly complicated rules, potential annotations, and member orderings within the type<br>&gt; <br>&gt; Would you feel better about the proposal if it did not allow for public memberwise initializers?<br></p><p>Marginally. My main concern is the complexity of the rules, especially when looking at the direction many of the futures take. There are all of these annotations that get put all over that litter the type definition simply to support memberwise inits.<br></p><p><br>&gt;&gt;     2. Generate the pass through of assignment for the parameters of the init() and their backing values.<br>&gt;&gt; <br>&gt;&gt; The vast amount complexity comes from trying to solve #1.<br>&gt; <br>&gt; This is not true.  I would still want access control enforced even if memberwise initializers could not be public.<br></p><p>There’s no concern with access control as it’s explicitly handled. I can expose whatever I want as the API and route it however I want in code. <br></p><p><br>&gt;&gt; <br>&gt;&gt; As for this:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; MxN is members x initializers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Paul, this has also bugged me too; I do not see how it is accurate. There aren’t N initializers, there is one initializer that must fully instantiate the type. Each type may have additional convenience initializers, but these are not required. Further, they cannot make use of the placeholder. There is a “futures” that talks about it, but that’s out of scope of the original proposal. <br>&gt; <br>&gt; Swift allows more than one designated initializer.  N never large but it more than 1 in enough cases to matter.  The point is that it results in enough boilerplate that I believe it affects how many people design their initializers.  <br></p><p>Sure, but your base proposal does not allow a way for there to be more than one memberwise designated initializer. So in the base case, your proposal doesn’t solve what you call the MxN problem. In the futures, you describe ways to annotate inits() so that members aren’t considered in the signature.<br></p><p>struct Point {<br>    let x: Int<br>    let y: Int<br>    let z: Int<br>    <br>    @nomemberwise(y, z)<br>    memberwise init(...) {<br>        y = 0<br>        z = 0<br>    }<br></p><p>    @nomemberwise(z)<br>    memberwise init(...) {<br>        z = 0<br>    }<br></p><p>    memberwise init(...) {}<br>}<br></p><p>Let’s say that for simplicity the @nomemberwise() attribute takes a list of parameters. This is one version of the code that can be written to support zero-ing out by default.<br></p><p>Or, we can do this (what Swift has today):<br></p><p>struct Point {<br>    let x: Int<br>    let y: Int<br>    let z: Int<br>    <br>    init(x: Int, y: Int = 0, z: Int = 0) {<br>        self.x = x<br>        self.y = y<br>        self.z = z<br>    }<br>}<br></p><p>Or with the below example:<br></p><p>struct Point {<br>    let x: Int<br>    let y: Int<br>    let z: Int<br>    <br>    init(self x: Int, self y: Int = 0, self z: Int = 0) {}<br>}<br></p><p>Even in all of your futures, I don’t see how you fix the &quot;MxN problem&quot; for let without bringing back the assignment in the type declaration, which was generally not well received.<br></p><p><br>&gt;&gt; <br>&gt;&gt; Your example hear illustrates the complexity (slightly modified from your proposal’s usage):<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   let bar: String<br>&gt;&gt;   let bas: Int<br>&gt;&gt;   let baz: Double<br>&gt;&gt; <br>&gt;&gt;   init(self bar: String, self bas: Int, bax: Int) {<br>&gt;&gt;     // self.bar = bar synthesized by the compiler<br>&gt;&gt;     // self.bas = bas synthesized by the compiler<br>&gt;&gt;     self.baz = Double(bax)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; This approach has been mentioned quite a few times.  It results in a lot of duplication without saving a lot.  This is especially true if you have a lot of properties and more than one designated initializer that could use memberwise initialization .  <br>&gt; <br>&gt; IMO, if we were going to take this approach we should at least be able to omit redundant type information and default values for `var` properties where they exist.  At least then we are saving as much as we can under this approach.<br>&gt; <br>&gt; struct Foo {<br>&gt;   let bar: String<br>&gt;   let bas: Int<br>&gt;   let baz: Double<br>&gt; <br>&gt;   init(self bar, self bas, bax: Int) {<br>&gt;     // self.bar = bar synthesized by the compiler<br>&gt;     // self.bas = bas synthesized by the compiler<br>&gt;     self.baz = Double(bax)<br>&gt;   }<br>&gt; }<br></p><p>I think it keeps coming up because it’s far simpler. While there is duplication in the type signature, the code is still smaller, more flexible, and more applicable than being limited to only initialization. Further, and I think this is what is far more important, I only need to look at single place to understand what is going on with initialization for any particular call. I don’t need to find out what members are annotated, or create the list of head of members and exclude certain ones if @nomemberize() is used. Each member being initialized as a configuration entity from the user is right there, no questions asked.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/aa5a8795/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 2:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br>&gt; <br>&gt; Not for me in Xcode 7.2. Has this changed? Maybe it’s my app target? The implicit init() is only visible for me within the same file the struct is defined in.<br></p><p>Wow, you’re right.  It is enforcing access control.  The implicit init is internal if there are no private properties, but private if there are private properties.  I wonder if this has changed.  If not, I’m embarrassed that I didn’t understand the current behavior in detail. <br></p><p>I thought it was always internal.  I’ve never actually used it for a struct with private properties before and I think the docs all say internal so maybe that is why.  In any case, I’m glad to see that it is enforcing access control rules.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal essentially is doing two things:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     1. Create a way to generate a public API contract based on a series of fairly complicated rules, potential annotations, and member orderings within the type<br>&gt;&gt; <br>&gt;&gt; Would you feel better about the proposal if it did not allow for public memberwise initializers?<br>&gt; <br>&gt; Marginally. My main concern is the complexity of the rules, especially when looking at the direction many of the futures take. There are all of these annotations that get put all over that litter the type<br>&gt; definition simply to support memberwise inits.<br></p><p>Maybe I wasn’t clear enough, but I never intended for all of them to be accepted.  They are intended to show different ways to allow a bit more control.<br></p><p>The proposal only changes current state in a few ways:<br></p><p>1. Allow the memberwise initializer to be used in classes<br>2. Allow default parameter values for `var` properties<br>3. Fix the problem the current memberwise initializer has with lazy properties<br>4. Use the `set` rather than `get` visibility for `var` properties<br>5. Allow you to request the memberwise initializer, including:<br>	i. Specify access level, which will result in omission of memberwise parameters for more-private properties<br>	ii. Add additional parameters<br>	iii. include an initializer body<br></p><p>Are there specific changes in this list that you dislike?<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt;     2. Generate the pass through of assignment for the parameters of the init() and their backing values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The vast amount complexity comes from trying to solve #1.<br>&gt;&gt; <br>&gt;&gt; This is not true.  I would still want access control enforced even if memberwise initializers could not be public.<br>&gt; <br>&gt; There’s no concern with access control as it’s explicitly handled. I can expose whatever I want as the API and route it however I want in code. <br></p><p>I understand that this is true with your approach.  I was responding to your statement that the source of complexity in my proposal is from trying to allow public memberwise inits (your solve #1).  It doesn’t come from wanting to allow public inits.  It mainly comes from enforcing access control.  It turns out that the current implicit init is already doing that.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; MxN is members x initializers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul, this has also bugged me too; I do not see how it is accurate. There aren’t N initializers, there is one initializer that must fully instantiate the type. Each type may have additional convenience initializers, but these are not required. Further, they cannot make use of the placeholder. There is a “futures” that talks about it, but that’s out of scope of the original proposal. <br>&gt;&gt; <br>&gt;&gt; Swift allows more than one designated initializer.  N never large but it more than 1 in enough cases to matter.  The point is that it results in enough boilerplate that I believe it affects how many people design their initializers.  <br>&gt; <br>&gt; Sure, but your base proposal does not allow a way for there to be more than one memberwise designated initializer. So in the base case, your proposal doesn’t solve what you call the MxN problem. In the futures, you describe ways to annotate inits() so that members aren’t considered in the signature.<br></p><p>My proposal does allow for more than 1 memberwise init.  The idea is that there are different ways to init the private state.  It also allows memberwise inits with different access control, which would possibly receive different memberwise parameters due to the access control rules.<br></p><p>&gt; <br>&gt; struct Point {<br>&gt;     let x: Int<br>&gt;     let y: Int<br>&gt;     let z: Int<br>&gt;     <br>&gt;     @nomemberwise(y, z)<br>&gt;     memberwise init(...) {<br>&gt;         y = 0<br>&gt;         z = 0<br>&gt;     }<br>&gt; <br>&gt;     @nomemberwise(z)<br>&gt;     memberwise init(...) {<br>&gt;         z = 0<br>&gt;     }<br>&gt; <br>&gt;     memberwise init(...) {}<br>&gt; }<br>&gt; <br>&gt; Let’s say that for simplicity the @nomemberwise() attribute takes a list of parameters. This is one version of the code that can be written to support zero-ing out by default.<br>&gt; <br>&gt; Or, we can do this (what Swift has today):<br>&gt; <br>&gt; struct Point {<br>&gt;     let x: Int<br>&gt;     let y: Int<br>&gt;     let z: Int<br>&gt;     <br>&gt;     init(x: Int, y: Int = 0, z: Int = 0) {<br>&gt;         self.x = x<br>&gt;         self.y = y<br>&gt;         self.z = z<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Or with the below example:<br>&gt; <br>&gt; struct Point {<br>&gt;     let x: Int<br>&gt;     let y: Int<br>&gt;     let z: Int<br>&gt;     <br>&gt;     init(self x: Int, self y: Int = 0, self z: Int = 0) {}<br>&gt; }<br>&gt; <br>&gt; Even in all of your futures, I don’t see how you fix the &quot;MxN problem&quot; for let without bringing back the assignment in the type declaration, which was generally not well received.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your example hear illustrates the complexity (slightly modified from your proposal’s usage):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;   let bar: String<br>&gt;&gt;&gt;   let bas: Int<br>&gt;&gt;&gt;   let baz: Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init(self bar: String, self bas: Int, bax: Int) {<br>&gt;&gt;&gt;     // self.bar = bar synthesized by the compiler<br>&gt;&gt;&gt;     // self.bas = bas synthesized by the compiler<br>&gt;&gt;&gt;     self.baz = Double(bax)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This approach has been mentioned quite a few times.  It results in a lot of duplication without saving a lot.  This is especially true if you have a lot of properties and more than one designated initializer that could use memberwise initialization .  <br>&gt;&gt; <br>&gt;&gt; IMO, if we were going to take this approach we should at least be able to omit redundant type information and default values for `var` properties where they exist.  At least then we are saving as much as we can under this approach.<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   let bar: String<br>&gt;&gt;   let bas: Int<br>&gt;&gt;   let baz: Double<br>&gt;&gt; <br>&gt;&gt;   init(self bar, self bas, bax: Int) {<br>&gt;&gt;     // self.bar = bar synthesized by the compiler<br>&gt;&gt;     // self.bas = bas synthesized by the compiler<br>&gt;&gt;     self.baz = Double(bax)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; I think it keeps coming up because it’s far simpler. While there is duplication in the type signature, the code is still smaller, more flexible, and more applicable than being limited to only initialization. Further, and I think this is what is far more important, I only need to look at single place to understand what is going on with initialization for any particular call. I don’t need to find out what members are annotated, or create the list of head of members and exclude certain ones if @nomemberize() is used. Each member being initialized as a configuration entity from the user is right there, no questions asked.<br></p><p>How is this more applicable than just for initialization?  Are you suggesting a self parameter be allowed in any method and it would result in an immediate set of that property?<br></p><p>Your critique regarding clarity is very reasonable and it is definitely the biggest drawback with the automatic model.  A number of people have commented on both the complexity / lack of clarity as well as the limitations of the automatic model.  The opt-in model described in the proposal has some of the same issues.  I have started to think more about an opt-in model that would avoid all of those issues.  <br></p><p>I really appreciate the feedback and conversation.  I am continuing to think about all of the comments and am hoping we can come out of this review with a vision for a path forward that makes most people happy whether the proposal is accepted or not.  (I think it’s clear that no solution will make everyone happy but do hope we can hit a sweet spot)<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/8059853e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 15:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 2:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br>&gt;&gt; <br>&gt;&gt; Not for me in Xcode 7.2. Has this changed? Maybe it’s my app target? The implicit init() is only visible for me within the same file the struct is defined in.<br>&gt; <br>&gt; Wow, you’re right.  It is enforcing access control.  The implicit init is internal if there are no private properties, but private if there are private properties.  I wonder if this has changed.  If not, I’m embarrassed that I didn’t understand the current behavior in detail. <br>&gt; <br>&gt; I thought it was always internal.  I’ve never actually used it for a struct with private properties before and I think the docs all say internal so maybe that is why.  In any case, I’m glad to see that it is enforcing access control rules.<br></p><p>For the record (and independent of my dissent) it has always behaved this way. Access level of an implicit memberwise initializer is private if any stored property is private, internal otherwise.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/9eb635c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 3:24 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 15:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 2:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 8, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not for me in Xcode 7.2. Has this changed? Maybe it’s my app target? The implicit init() is only visible for me within the same file the struct is defined in.<br>&gt;&gt; <br>&gt;&gt; Wow, you’re right.  It is enforcing access control.  The implicit init is internal if there are no private properties, but private if there are private properties.  I wonder if this has changed.  If not, I’m embarrassed that I didn’t understand the current behavior in detail. <br>&gt;&gt; <br>&gt;&gt; I thought it was always internal.  I’ve never actually used it for a struct with private properties before and I think the docs all say internal so maybe that is why.  In any case, I’m glad to see that it is enforcing access control rules.<br>&gt; <br>&gt; For the record (and independent of my dissent) it has always behaved this way. Access level of an implicit memberwise initializer is private if any stored property is private, internal otherwise.<br></p><p>I’m not seeing this behavior, I’m seeing private always regardless of access level of the struct’s members. Xcode 7.2.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/0676202b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 8, 2016, at 5:34 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 3:24 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 8, 2016, at 15:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 8, 2016, at 2:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 8, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not for me in Xcode 7.2. Has this changed? Maybe it’s my app target? The implicit init() is only visible for me within the same file the struct is defined in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wow, you’re right.  It is enforcing access control.  The implicit init is internal if there are no private properties, but private if there are private properties.  I wonder if this has changed.  If not, I’m embarrassed that I didn’t understand the current behavior in detail. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought it was always internal.  I’ve never actually used it for a struct with private properties before and I think the docs all say internal so maybe that is why.  In any case, I’m glad to see that it is enforcing access control rules.<br>&gt;&gt; <br>&gt;&gt; For the record (and independent of my dissent) it has always behaved this way. Access level of an implicit memberwise initializer is private if any stored property is private, internal otherwise.<br>&gt; <br>&gt; I’m not seeing this behavior, I’m seeing private always regardless of access level of the struct’s members. Xcode 7.2.<br></p><p>That&#39;s weird.  Always internal for me unless there is a private property.  Xcode 7.2 as well.<br></p><p>&gt; <br>&gt; -David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/f64a23d9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 8, 2016, at 5:24 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 15:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 8, 2016, at 2:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 8, 2016, at 11:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually it is internal, not private, and it exposes private properties via that internal initializer.  It’s only in your own code, but I don&#39;t think it should be violating access control in that way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not for me in Xcode 7.2. Has this changed? Maybe it’s my app target? The implicit init() is only visible for me within the same file the struct is defined in.<br>&gt;&gt; <br>&gt;&gt; Wow, you’re right.  It is enforcing access control.  The implicit init is internal if there are no private properties, but private if there are private properties.  I wonder if this has changed.  If not, I’m embarrassed that I didn’t understand the current behavior in detail. <br>&gt;&gt; <br>&gt;&gt; I thought it was always internal.  I’ve never actually used it for a struct with private properties before and I think the docs all say internal so maybe that is why.  In any case, I’m glad to see that it is enforcing access control rules.<br>&gt; <br>&gt; For the record (and independent of my dissent) it has always behaved this way. Access level of an implicit memberwise initializer is private if any stored property is private, internal otherwise.<br></p><p>Thanks for setting the record straight.  I don&#39;t think any of the docs mention this and I had never tried it so I didn&#39;t realize this.  It&#39;s a bit embarrassing as I feel like it is something I should have discovered while writing the proposal.<br></p><p>&gt; <br>&gt; Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/e9ef5535/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; Marginally. My main concern is the complexity of the rules, especially when looking at the direction many of the futures take. There are all of these annotations that get put all over that litter the type<br>&gt;&gt; definition simply to support memberwise inits.<br>&gt; <br>&gt; Maybe I wasn’t clear enough, but I never intended for all of them to be accepted.  They are intended to show different ways to allow a bit more control.<br>&gt; <br>&gt; The proposal only changes current state in a few ways:<br>&gt; <br>&gt; 1. Allow the memberwise initializer to be used in classes<br>&gt; 2. Allow default parameter values for `var` properties<br>&gt; 3. Fix the problem the current memberwise initializer has with lazy properties<br>&gt; 4. Use the `set` rather than `get` visibility for `var` properties<br>&gt; 5. Allow you to request the memberwise initializer, including:<br>&gt; 	i. Specify access level, which will result in omission of memberwise parameters for more-private properties<br>&gt; 	ii. Add additional parameters<br>&gt; 	iii. include an initializer body<br>&gt; <br>&gt; Are there specific changes in this list that you dislike?<br></p><p>No, I think you’re goal is reasonable and your proposal is well thought out. The problem comes down to the details on how to support it. Each point has a set of gotcha’s that require rules to handle properly. <br></p><p>It’s simply my opinion that these rules make the feature far too complicated.<br></p><p>You could go super basic and just have the proposal help address the struct scenario and have the default value for “var” members carried through to the implicitly created init(). <br></p><p>&gt;&gt; I think it keeps coming up because it’s far simpler. While there is duplication in the type signature, the code is still smaller, more flexible, and more applicable than being limited to only initialization. Further, and I think this is what is far more important, I only need to look at single place to understand what is going on with initialization for any particular call. I don’t need to find out what members are annotated, or create the list of head of members and exclude certain ones if @nomemberize() is used. Each member being initialized as a configuration entity from the user is right there, no questions asked.<br>&gt; <br>&gt; How is this more applicable than just for initialization?  Are you suggesting a self parameter be allowed in any method and it would result in an immediate set of that property?<br></p><p>Yes, I’m suggesting that “self” is a qualifier, like “inout”.<br></p><p>This code:<br></p><p>struct Point {<br>    var x, y, z: Int<br>    init(self x: Int, self y: Int = 0, self z: Int = 0) {}<br>    func foo(self x: Int) {}<br>}<br></p><p>Would be identical to this code:<br></p><p>struct Point {<br>    var x, y, z: Int<br>    init(x: Int, y: Int = 0, z: Int = 0) {<br>        self.x = x; self.y = y; self.z = z;<br>        // rest of function<br>    }<br></p><p>    func foo(x: Int) {<br>        self.x = x<br>        // rest of function<br>    }<br>}<br></p><p>That assignment happens before the function body executes.<br></p><p>This model fixes the majority of my complexity issues. However, it brings some others to the table and doesn’t solve the need to duplicate all of the members in the API.<br></p><p>I think something like this was mentioned before, but I don’t remember what happened with it. However, another way to do initialization could be like this (C# calls this field initializers):<br></p><p>	let p = Point {<br>        x = 12,<br>        y = 13,<br>        z = 14<br>    }<br></p><p>We then get out of caring about the ordering of the parameters. However, this feature is much more narrow as it only applies to public properties. There is a lot of subtly in actually implementing this in the compiler though.<br></p><p><br>&gt; I really appreciate the feedback and conversation.  I am continuing to think about all of the comments and am hoping we can come out of this review with a vision for a path forward that makes most people happy whether the proposal is accepted or not.  (I think it’s clear that no solution will make everyone happy but do hope we can hit a sweet spot)<br></p><p>Just to be clear, I think the proposal lays out the land well and has good coverage of the issues. I just find it too complicated of a ruleset to need to know.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/8a2adf17/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:31 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br>&gt;&gt; <br>&gt;&gt; On reflection, it comes down to this: the feature to functionality ratio is too high.<br>&gt; <br>&gt; Would you propose removing the current implicit memberwise initializer for structs on the same grounds?<br></p><p>No, it’s a much smaller feature surface. I would proposed promoting it from a simple, situational feature to something very generic — much like what Joe Groff is doing with “lazy.”<br></p><p>&gt; This proposal effectively fleshes that feature out giving it more functionality.  The only fundamental complexity it adds is the access control rules, which I feel are pretty important to enforce.<br></p><p>I tend to agree with others who think the additional complexity in this proposal is substantial. Perhaps it would come to seem simple if we all lived with it, though that’s not my gut reaction. It’s a lot of hidden rules.<br></p><p>&gt;&gt; It feels to me like this functionality should come from a feature set that is more general, more arbitrarily composable, and pays greater dividends in a wider variety of situations. As a simple example, what if I want to write an updateFrom(other: Self) method that does a mass copy of all properties? Why doesn’t this proposal help with that, too? Because the … placeholder and the synthesized copying are tightly coupled (1) to each other and (2) to initialization.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what the better answer is, but it’s out there. I didn’t follow the whole discussion, but I did notice Joe Groff’s proposal for a Members tuple; that seems to me to be getting much warmer. I’d much prefer something along those lines, even if it were slightly more verbose.<br>&gt; <br>&gt; I think the direction suggested by Joe (and Dave) is interesting.  But they haven’t explained how it would handle some important use cases this proposal addresses (default parameter values, subset of members without using a struct, etc).  If we are going to reject this proposal in hope of a more general solution I would at least like to see a path forward that might be able to address these use cases.<br></p><p>Agreed — I think this proposal has tremendous value at the very least as an in-depth exploration of all the cases to consider in searching for a more general solution.<br></p><p>&gt; More importantly, the general features on their own would not address the problems addressed by this proposal.  There would still need to be initializer-specific magic.  Joe hinted at what that might be but has not fleshed out all the details yet.  Maybe it would be a simpler model but we would need to see more specific details.<br>&gt; <br>&gt; I don’t believe a fully generalized solution is possible.  There are a lot of initialization-specific constraints that must be met (definitive initialization, single initialization of `let` properties, etc).<br></p><p>As I said in the original review, I’d be willing to sacrifice some concision in service of making the solution more general.<br></p><p>For example, the proposal goes to lengths to (1) automatically select a subset of members for memberwise initialization and (2) automatically insert the initialization code. I’d be willing to sacrifice both those implicit behaviors for some more generically composable mechanisms that let me turn a (sub)set of members into a tuple type, add it to arg lists, and mass assign it.<br></p><p>Here’s a sketch of that — not a proposal, total BS syntax, totally hypothetical:<br></p><p>    struct S {<br>        let s0, s1, s2: String<br>        private let i: Int<br></p><p>        init(anInt: Int, anotherInt: Int, otherArgs: Members.except(i)) {<br>            members = otherArgs  // assigned members inferred from tuple item names<br>            i = anInt &gt; anotherInt ? anInt : anotherInt<br>        }<br>    }<br></p><p>I’d be happy — happier! — with a solution like that, despite the modest additional keystrokes, because (1) members and Members would presumably have a more predictable behavior that’s easier to remember and to understand by reading, and (2) they’d be usable in other contexts:<br></p><p>    mutating func updateFrom(other: S) {<br>        self.members = other.except(i)<br>        i = anInt &gt; anotherInt ? anInt : anotherInt<br>    }<br></p><p>…or heck, even this:<br></p><p>    mutating func updateTwoStrings(s0: String, s1: String) {<br>        members = arguments<br>    }<br></p><p>    mutating func updateTwoStrings(s0: String, s1: String, message: String) {<br>        print(message)<br>        members = arguments.except(message)<br>    }<br></p><p>OK, I concede I&#39;m now brainstorming quite a feature list here:<br></p><p>members property that turns all (stored?) properties into a tuple,<br>Members property that returns the type of the above,<br>select / except operations on any tuple that create a new tuple by filtering keys,<br>assignment of a tuple to members that matches by tuple key (and the tuple can contain a subset of all properties),<br>some way of variadically expanding a tuple type in an arg list, and<br>arguments implicit variable that gives all func args as a tuple. (That last one’s not necessary to replace this proposal; just threw it in there because I’m brainstorming.)<br></p><p>That’s a lot! But all these feature are more independent, flexible, and transparent than the ones in the proposal. They (1) need not all be understood all at once, (2) have less implicit behavior and rules about corner cases, (3) thus have a simpler mental model and are easier to understand just by reading, and (4) provide more capabilities in a broader range of contexts.<br></p><p>Again, it’s only a sketch. Just making stuff up here! The obvious question is “how exactly would it all work,” and I don’t know either — but I feel like it could, and I’d really like to pursue this sort of direction before going with the more narrow proposal at hand.<br></p><p>That said, I originally wrote:<br></p><p>&gt;&gt; I think it should be deferred in search of a more generic solution, perhaps to be resurrected if the search for generality fails.<br></p><p><br>I said “deferred” instead of “rejected” because my objection is that there may be a better solution — but that’s only a gut feeling, and if we really truly establish that there isn’t, then I’d give this proposal another look.<br></p><p>&gt; <br>&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt; <br>&gt; MxN is members x initializers.<br></p><p>Yes, as others pointed out, my careless misreading! Makes much more sense now. Sorry for that.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/10769c77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 4:14 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:31 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On reflection, it comes down to this: the feature to functionality ratio is too high.<br>&gt;&gt; <br>&gt;&gt; Would you propose removing the current implicit memberwise initializer for structs on the same grounds?<br>&gt; <br>&gt; No, it’s a much smaller feature surface. I would proposed promoting it from a simple, situational feature to something very generic — much like what Joe Groff is doing with “lazy.”<br></p><p>How exactly would you do this?  I don’t understand what you think that would look like.  Making it more capable is what my proposal is attempting to do so I am confused by this statement.  This proposal changes it in the following ways:<br></p><p>1. Allow the memberwise initializer to be used in classes<br>2. Allow default parameter values for `var` properties<br>3. Fix the problem the current memberwise initializer has with lazy properties<br>4. Use the `set` rather than `get` visibility for `var` properties<br>5. Allow you to request the memberwise initializer, including:<br>	i. Specify access level, which will result in omission of memberwise parameters for more-private properties<br>	ii. Add additional parameters<br>	iii. include an initializer body<br></p><p>&gt; <br>&gt;&gt; This proposal effectively fleshes that feature out giving it more functionality.  The only fundamental complexity it adds is the access control rules, which I feel are pretty important to enforce.<br>&gt; <br>&gt; I tend to agree with others who think the additional complexity in this proposal is substantial. Perhaps it would come to seem simple if we all lived with it, though that’s not my gut reaction. It’s a lot of hidden rules.<br></p><p>See the list above.  I don’t think the behavior changes beyond the implicit memberwise init as they are perceived.<br></p><p>&gt; <br>&gt;&gt;&gt; It feels to me like this functionality should come from a feature set that is more general, more arbitrarily composable, and pays greater dividends in a wider variety of situations. As a simple example, what if I want to write an updateFrom(other: Self) method that does a mass copy of all properties? Why doesn’t this proposal help with that, too? Because the … placeholder and the synthesized copying are tightly coupled (1) to each other and (2) to initialization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure what the better answer is, but it’s out there. I didn’t follow the whole discussion, but I did notice Joe Groff’s proposal for a Members tuple; that seems to me to be getting much warmer. I’d much prefer something along those lines, even if it were slightly more verbose.<br>&gt;&gt; <br>&gt;&gt; I think the direction suggested by Joe (and Dave) is interesting.  But they haven’t explained how it would handle some important use cases this proposal addresses (default parameter values, subset of members without using a struct, etc).  If we are going to reject this proposal in hope of a more general solution I would at least like to see a path forward that might be able to address these use cases.<br>&gt; <br>&gt; Agreed — I think this proposal has tremendous value at the very least as an in-depth exploration of all the cases to consider in searching for a more general solution.<br></p><p>I do have some new ideas in the direction they discussed.  I’m going to work on fleshing those out tonight.<br></p><p>&gt; <br>&gt;&gt; More importantly, the general features on their own would not address the problems addressed by this proposal.  There would still need to be initializer-specific magic.  Joe hinted at what that might be but has not fleshed out all the details yet.  Maybe it would be a simpler model but we would need to see more specific details.<br>&gt;&gt; <br>&gt;&gt; I don’t believe a fully generalized solution is possible.  There are a lot of initialization-specific constraints that must be met (definitive initialization, single initialization of `let` properties, etc).<br>&gt; <br>&gt; As I said in the original review, I’d be willing to sacrifice some concision in service of making the solution more general.<br>&gt; <br>&gt; For example, the proposal goes to lengths to (1) automatically select a subset of members for memberwise initialization and (2) automatically insert the initialization code. I’d be willing to sacrifice both those implicit behaviors for some more generically composable mechanisms that let me turn a (sub)set of members into a tuple type, add it to arg lists, and mass assign it.<br>&gt; <br>&gt; Here’s a sketch of that — not a proposal, total BS syntax, totally hypothetical:<br>&gt; <br>&gt;     struct S {<br>&gt;         let s0, s1, s2: String<br>&gt;         private let i: Int<br>&gt; <br>&gt;         init(anInt: Int, anotherInt: Int, otherArgs: Members.except(i)) {<br>&gt;             members = otherArgs  // assigned members inferred from tuple item names<br>&gt;             i = anInt &gt; anotherInt ? anInt : anotherInt<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; I’d be happy — happier! — with a solution like that, despite the modest additional keystrokes, because (1) members and Members would presumably have a more predictable behavior that’s easier to remember and to understand by reading, and (2) they’d be usable in other contexts:<br>&gt; <br>&gt;     mutating func updateFrom(other: S) {<br>&gt;         self.members = other.except(i)<br>&gt;         i = anInt &gt; anotherInt ? anInt : anotherInt<br>&gt;     }<br>&gt; <br>&gt; …or heck, even this:<br>&gt; <br>&gt;     mutating func updateTwoStrings(s0: String, s1: String) {<br>&gt;         members = arguments<br>&gt;     }<br>&gt; <br>&gt;     mutating func updateTwoStrings(s0: String, s1: String, message: String) {<br>&gt;         print(message)<br>&gt;         members = arguments.except(message)<br>&gt;     }<br>&gt; <br>&gt; OK, I concede I&#39;m now brainstorming quite a feature list here:<br>&gt; <br>&gt; members property that turns all (stored?) properties into a tuple,<br>&gt; Members property that returns the type of the above,<br>&gt; select / except operations on any tuple that create a new tuple by filtering keys,<br>&gt; assignment of a tuple to members that matches by tuple key (and the tuple can contain a subset of all properties),<br>&gt; some way of variadically expanding a tuple type in an arg list, and<br>&gt; arguments implicit variable that gives all func args as a tuple. (That last one’s not necessary to replace this proposal; just threw it in there because I’m brainstorming.)<br>&gt; <br>&gt; That’s a lot! But all these feature are more independent, flexible, and transparent than the ones in the proposal. They (1) need not all be understood all at once, (2) have less implicit behavior and rules about corner cases, (3) thus have a simpler mental model and are easier to understand just by reading, and (4) provide more capabilities in a broader range of contexts.<br></p><p>I really don’t think the “members” computed tuple property is a workable solution for initializing `let` properties.  It would be really strange to allow it to do so.  Any such property that was allowed to do so would not work outside an initializer anyway as it would try to mutate a `let` when you used it.<br></p><p>I have also been thinking a lot about approaches that would be similar in some sense and build on a general purpose parameter forwarding mechanism.  I have some ideas that I am going to work on fleshing out tonight.<br></p><p><br>&gt; <br>&gt; Again, it’s only a sketch. Just making stuff up here! The obvious question is “how exactly would it all work,” and I don’t know either — but I feel like it could, and I’d really like to pursue this sort of direction before going with the more narrow proposal at hand.<br>&gt; <br>&gt; That said, I originally wrote:<br>&gt; <br>&gt;&gt;&gt; I think it should be deferred in search of a more generic solution, perhaps to be resurrected if the search for generality fails.<br>&gt; <br>&gt; <br>&gt; I said “deferred” instead of “rejected” because my objection is that there may be a better solution — but that’s only a gut feeling, and if we really truly establish that there isn’t, then I’d give this proposal another look.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt;&gt; <br>&gt;&gt; MxN is members x initializers.<br>&gt; <br>&gt; Yes, as others pointed out, my careless misreading! Makes much more sense now. Sorry for that.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/89ca5db4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 5:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 4:14 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Would you propose removing the current implicit memberwise initializer for structs on the same grounds?<br>&gt;&gt; <br>&gt;&gt; No, it’s a much smaller feature surface. I would proposed promoting it from a simple, situational feature to something very generic — much like what Joe Groff is doing with “lazy.”<br>&gt; <br>&gt; How exactly would you do this?  I don’t understand what you think that would look like.<br></p><p>It would like what I sketched out in remainder of my previous message.<br></p><p>&gt; Making it more capable is what my proposal is attempting to do so I am confused by this statement.<br></p><p>Making it more capable is not what I’m talking about. Making it more generic and more flexible it is what I’m talking about. <br></p><p>The property behaviors proposal, at least as I understand it, could change “lazy” from being a language feature to being a library feature. In the language, lazy is replaced with something more flexible and generic, something that could give rise to other new features totally unrelated to laziness, but built from the same new building blocks.<br></p><p>The “memberwise” proposal, on the other hand, would be analogous to expanding the “lazy” feature at the language level, adding a bunch of new rules and behavior to it.<br></p><p>• • •<br></p><p>Based on your feedback, I’m not sure the central point of my review came across. I don’t think I can explain it better than I did in the review, but maybe others can find the words.<br></p><p>&gt;&gt; Here’s a sketch of that — not a proposal, total BS syntax, totally hypothetical:<br>&gt;&gt; <br>&gt;&gt;     struct S {<br>&gt;&gt;         let s0, s1, s2: String<br>&gt;&gt;         private let i: Int<br>&gt;&gt; <br>&gt;&gt;         init(anInt: Int, anotherInt: Int, otherArgs: Members.except(i)) {<br>&gt;&gt;             members = otherArgs  // assigned members inferred from tuple item names<br>&gt;&gt;             i = anInt &gt; anotherInt ? anInt : anotherInt<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I’d be happy — happier! — with a solution like that, despite the modest additional keystrokes, because (1) members and Members would presumably have a more predictable behavior that’s easier to remember and to understand by reading, and (2) they’d be usable in other contexts:<br>&gt;&gt; <br>&gt;&gt;     mutating func updateFrom(other: S) {<br>&gt;&gt;         self.members = other.except(i)<br>&gt;&gt;         i = anInt &gt; anotherInt ? anInt : anotherInt<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; …or heck, even this:<br>&gt;&gt; <br>&gt;&gt;     mutating func updateTwoStrings(s0: String, s1: String) {<br>&gt;&gt;         members = arguments<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     mutating func updateTwoStrings(s0: String, s1: String, message: String) {<br>&gt;&gt;         print(message)<br>&gt;&gt;         members = arguments.except(message)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; OK, I concede I&#39;m now brainstorming quite a feature list here:<br>&gt;&gt; <br>&gt;&gt; members property that turns all (stored?) properties into a tuple,<br>&gt;&gt; Members property that returns the type of the above,<br>&gt;&gt; select / except operations on any tuple that create a new tuple by filtering keys,<br>&gt;&gt; assignment of a tuple to members that matches by tuple key (and the tuple can contain a subset of all properties),<br>&gt;&gt; some way of variadically expanding a tuple type in an arg list, and<br>&gt;&gt; arguments implicit variable that gives all func args as a tuple. (That last one’s not necessary to replace this proposal; just threw it in there because I’m brainstorming.)<br>&gt;&gt; <br>&gt;&gt; That’s a lot! But all these feature are more independent, flexible, and transparent than the ones in the proposal. They (1) need not all be understood all at once, (2) have less implicit behavior and rules about corner cases, (3) thus have a simpler mental model and are easier to understand just by reading, and (4) provide more capabilities in a broader range of contexts.<br>&gt; <br>&gt; I really don’t think the “members” computed tuple property is a workable solution for initializing `let` properties.<br></p><p>What not? All the static type information is there for the compiler to apply the same checks it does right now.<br></p><p>&gt; Any such property that was allowed to do so would not work outside an initializer anyway as it would try to mutate a `let` when you used it.<br></p><p>Well, yes, because instead of invisible magic, the “members = tuple” initialization behaves exactly like any other assignment.<br></p><p>&gt; I have also been thinking a lot about approaches that would be similar in some sense and build on a general purpose parameter forwarding mechanism.  I have some ideas that I am going to work on fleshing out tonight.<br></p><p>That’s the sort of thing I’d be interested in seeing.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/f4012bf4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  9, 2016 at 08:00:00pm</p></header><div class="content"><p>I like these ideas!<br></p><p>Some brain storming from me as well:<br></p><p>The members property should probably not be a tuple but a struct, thereby providing names for the values.<br>I think splitting this property into two (varMembers and letMembers) with a read-only property members tying both together for convenience (members.vars, members.lets).<br></p><p>I’ve thrown together a playground to toy with these ideas:<br></p><p>import Foundation<br></p><p>/*<br>struct S {<br>    var s0: String<br>    var s1: String = &quot;s1&quot;<br>    var s2: String = &quot;s2&quot;<br>    let j: Int default 42<br>    private let i: Int<br></p><p>    // implicit property #members<br>    var #members: Members {<br>	get { return Members(#vars, #lets) }<br>    }<br></p><p>    // implicit property #vars<br>    var #vars: Members.Vars<br></p><p>    // implicit property #lets<br>    let #lets: Members.Lets<br></p><p>    init(members: Members) {<br>        #members = members<br>    }<br></p><p>    init(anInt: Int, anotherInt: Int, members: Members) {<br>        #members = members<br>        i = anInt &gt; anotherInt ? anInt : anotherInt<br>    }<br></p><p>    mutating func updateFrom(other: S) {<br>        self.#members.vars = other.#members.vars<br>    }<br>}<br>*/<br></p><p>// faking the above<br>struct S {<br>    struct Members {<br>        struct Vars {<br>            var s0: String?<br>            var s1: String<br>            var s2: String<br>        }<br>        struct Lets {<br>            var j: Int<br>            private var i: Int?<br>        }<br>        var vars: Vars<br>        var lets: Lets<br>        init(vars: Vars, lets: Lets) {<br>            self.vars = vars<br>            self.lets = lets<br>        }<br>        init(s0: String? = nil, s1: String = &quot;s1&quot;, s2: String = &quot;s2&quot;, j: Int = 42, i: Int? = nil) {<br>            self.vars = Vars(s0: s0, s1: s1, s2: s2)<br>            self.lets = Lets(j: j, i: i)<br>        }<br>    }<br>    // having separate varMembers and letMembers allows to ensure<br>    // that letMembers cannot be changed<br>    // (this would not be possible with &quot;var members: Members&quot;)<br>    var varMembers: Members.Vars<br>    let letMembers: Members.Lets<br>    <br>    var members: Members {<br>        get { return Members(vars: varMembers, lets: letMembers) }<br>    }<br>    <br>    var s0: String {<br>        get { return varMembers.s0! }<br>        set { varMembers.s0 = newValue }<br>    }<br>    <br>    var s1: String {<br>        get { return varMembers.s1 }<br>        set { varMembers.s1 = newValue }<br>    }<br>    <br>    var s2: String {<br>        get { return varMembers.s2 }<br>        set { varMembers.s2 = newValue }<br>    }<br>    <br>    var j: Int {<br>        get { return letMembers.j }<br>    }<br>    <br>    private var i: Int {<br>        get { return letMembers.i! }<br>    }<br>    <br>    init(members: Members) {<br>        varMembers = members.vars<br>        letMembers = members.lets<br>    }<br>    <br>    init(anInt: Int, anotherInt: Int, members: Members) {<br>        varMembers = members.vars<br>        var lets = members.lets<br>        lets.i = anInt &gt; anotherInt ? anInt : anotherInt<br>        letMembers = lets<br>    }<br>    <br>    mutating func updateFrom(other: S) {<br>        self.varMembers = other.varMembers<br>        // self.letMembers = other.letMembers // type error!<br>    }<br>}<br></p><p>extension S: CustomStringConvertible {<br>    var description: String {<br>        return &quot;S(s0: \&quot;\(s0)\&quot;, s1: \&quot;\(s1)\&quot;, s2: \&quot;\(s2)\&quot;, j: \(j), i: \(i))&quot;<br>    }<br>}<br></p><p>var s: S = S(members: S.Members(s0: &quot;foo&quot;, s1: &quot;bar&quot;, s2: &quot;baz&quot;, j: 1, i: 0))<br>//s.members.lets.i = 1 // type error!<br>var s2: S = S(anInt: 1, anotherInt: 2, members: S.Members(s0: &quot;other&quot;, j: 2))<br>s.updateFrom(s2)<br>s.s0 = &quot;new&quot;<br>var ms = s.varMembers<br>ms.s0 = &quot;broken?&quot;<br>s.s0 // is still &quot;new&quot;<br>// s.members.vars.s0 = &quot;broken??&quot; // type error!<br>var s3 = S(members: s2.members)<br></p><p><br>-Thorsten<br></p><p><br></p><p>&gt; Am 08.01.2016 um 23:14 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 11:31 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t shake unease about the proposed solution. As I read the examples, they’re not quite self-explanatory: a lot of magic, but the result doesn’t feel quite magical. Without being able to see what the compiler synthesizes, it’s often not obvious what will happen. As I read the detailed rules, they all sound quite sensible, but taken together feel like they’ll be hard to keep track of, and will lead to a lot of frustrated experimenting with the compiler. Tricky questions lurk all over. For example, what happens when I have a 7-member struct, all 7 parameters use memberwise initialization, but then I want to add some custom logic for the initialization of member 3? I think I have to either reorder the params or abandon … altogether? I feel like those tricky questions should melt away once I grasp the underlying principle, but there isn’t one to grasp; it’s just a bunch of tricky cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On reflection, it comes down to this: the feature to functionality ratio is too high.<br>&gt;&gt; <br>&gt;&gt; Would you propose removing the current implicit memberwise initializer for structs on the same grounds?<br>&gt; <br>&gt; No, it’s a much smaller feature surface. I would proposed promoting it from a simple, situational feature to something very generic — much like what Joe Groff is doing with “lazy.”<br>&gt; <br>&gt;&gt; This proposal effectively fleshes that feature out giving it more functionality.  The only fundamental complexity it adds is the access control rules, which I feel are pretty important to enforce.<br>&gt; <br>&gt; I tend to agree with others who think the additional complexity in this proposal is substantial. Perhaps it would come to seem simple if we all lived with it, though that’s not my gut reaction. It’s a lot of hidden rules.<br>&gt; <br>&gt;&gt;&gt; It feels to me like this functionality should come from a feature set that is more general, more arbitrarily composable, and pays greater dividends in a wider variety of situations. As a simple example, what if I want to write an updateFrom(other: Self) method that does a mass copy of all properties? Why doesn’t this proposal help with that, too? Because the … placeholder and the synthesized copying are tightly coupled (1) to each other and (2) to initialization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure what the better answer is, but it’s out there. I didn’t follow the whole discussion, but I did notice Joe Groff’s proposal for a Members tuple; that seems to me to be getting much warmer. I’d much prefer something along those lines, even if it were slightly more verbose.<br>&gt;&gt; <br>&gt;&gt; I think the direction suggested by Joe (and Dave) is interesting.  But they haven’t explained how it would handle some important use cases this proposal addresses (default parameter values, subset of members without using a struct, etc).  If we are going to reject this proposal in hope of a more general solution I would at least like to see a path forward that might be able to address these use cases.<br>&gt; <br>&gt; Agreed — I think this proposal has tremendous value at the very least as an in-depth exploration of all the cases to consider in searching for a more general solution.<br>&gt; <br>&gt;&gt; More importantly, the general features on their own would not address the problems addressed by this proposal.  There would still need to be initializer-specific magic.  Joe hinted at what that might be but has not fleshed out all the details yet.  Maybe it would be a simpler model but we would need to see more specific details.<br>&gt;&gt; <br>&gt;&gt; I don’t believe a fully generalized solution is possible.  There are a lot of initialization-specific constraints that must be met (definitive initialization, single initialization of `let` properties, etc).<br>&gt; <br>&gt; As I said in the original review, I’d be willing to sacrifice some concision in service of making the solution more general.<br>&gt; <br>&gt; For example, the proposal goes to lengths to (1) automatically select a subset of members for memberwise initialization and (2) automatically insert the initialization code. I’d be willing to sacrifice both those implicit behaviors for some more generically composable mechanisms that let me turn a (sub)set of members into a tuple type, add it to arg lists, and mass assign it.<br>&gt; <br>&gt; Here’s a sketch of that — not a proposal, total BS syntax, totally hypothetical:<br>&gt; <br>&gt;     struct S {<br>&gt;         let s0, s1, s2: String<br>&gt;         private let i: Int<br>&gt; <br>&gt;         init(anInt: Int, anotherInt: Int, otherArgs: Members.except(i)) {<br>&gt;             members = otherArgs  // assigned members inferred from tuple item names<br>&gt;             i = anInt &gt; anotherInt ? anInt : anotherInt<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; I’d be happy — happier! — with a solution like that, despite the modest additional keystrokes, because (1) members and Members would presumably have a more predictable behavior that’s easier to remember and to understand by reading, and (2) they’d be usable in other contexts:<br>&gt; <br>&gt;     mutating func updateFrom(other: S) {<br>&gt;         self.members = other.except(i)<br>&gt;         i = anInt &gt; anotherInt ? anInt : anotherInt<br>&gt;     }<br>&gt; <br>&gt; …or heck, even this:<br>&gt; <br>&gt;     mutating func updateTwoStrings(s0: String, s1: String) {<br>&gt;         members = arguments<br>&gt;     }<br>&gt; <br>&gt;     mutating func updateTwoStrings(s0: String, s1: String, message: String) {<br>&gt;         print(message)<br>&gt;         members = arguments.except(message)<br>&gt;     }<br>&gt; <br>&gt; OK, I concede I&#39;m now brainstorming quite a feature list here:<br>&gt; <br>&gt; members property that turns all (stored?) properties into a tuple,<br>&gt; Members property that returns the type of the above,<br>&gt; select / except operations on any tuple that create a new tuple by filtering keys,<br>&gt; assignment of a tuple to members that matches by tuple key (and the tuple can contain a subset of all properties),<br>&gt; some way of variadically expanding a tuple type in an arg list, and<br>&gt; arguments implicit variable that gives all func args as a tuple. (That last one’s not necessary to replace this proposal; just threw it in there because I’m brainstorming.)<br>&gt; <br>&gt; That’s a lot! But all these feature are more independent, flexible, and transparent than the ones in the proposal. They (1) need not all be understood all at once, (2) have less implicit behavior and rules about corner cases, (3) thus have a simpler mental model and are easier to understand just by reading, and (4) provide more capabilities in a broader range of contexts.<br>&gt; <br>&gt; Again, it’s only a sketch. Just making stuff up here! The obvious question is “how exactly would it all work,” and I don’t know either — but I feel like it could, and I’d really like to pursue this sort of direction before going with the more narrow proposal at hand.<br>&gt; <br>&gt; That said, I originally wrote:<br>&gt; <br>&gt;&gt;&gt; I think it should be deferred in search of a more generic solution, perhaps to be resurrected if the search for generality fails.<br>&gt; <br>&gt; <br>&gt; I said “deferred” instead of “rejected” because my objection is that there may be a better solution — but that’s only a gut feeling, and if we really truly establish that there isn’t, then I’d give this proposal another look.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (Aside, a small nitpick, but it really bugs me: initialization has O(M+N) complexity, not O(M×N) complexity. One doesn’t initialize every member with every parameter.)<br>&gt;&gt; <br>&gt;&gt; MxN is members x initializers.<br>&gt; <br>&gt; Yes, as others pointed out, my careless misreading! Makes much more sense now. Sorry for that.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/e7167574/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; The members property should probably not be a tuple but a struct, thereby providing names for the values.<br>&gt; I think splitting this property into two (varMembers and letMembers) with a read-only property members tying both together for convenience (members.vars, members.lets).<br></p><p>I don&#39;t think the `members` tuple is a good alternative here. It looks good on paper, but think about what it actually would need to involve to match this proposal and its likely enhancements:<br></p><p>- It would need to have different elements at different levels of accessibility, and we would somehow have to select the right level for the matching initializer.<br>- It would need to include only properties *writable* at that level.<br>- It would need to include only stored properties.<br>- It would need to include only properties that are either `var`s or uninitialized `let`s.<br>- But we would need mechanisms to add items that have been excluded, and remove items that have been included.<br></p><p>Plus there&#39;s all the weirdness around using it to reassign constants.<br></p><p>Basically, once you&#39;ve applied all of the specialized rules needed to make the `members` tuple work for memberwise initializers, is `members` still going to be useful for anything else? Frankly, I think the answer to that question is &quot;No&quot;. So we end up designing something that&#39;s maybe 1/4 orthogonal instead of 0/4 orthogonal, but is also a lot less clear. In the end, I don&#39;t think that&#39;ll actually be a win.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 09.01.2016 um 21:24 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt; The members property should probably not be a tuple but a struct, thereby providing names for the values.<br>&gt;&gt; I think splitting this property into two (varMembers and letMembers) with a read-only property members tying both together for convenience (members.vars, members.lets).<br>&gt; <br>&gt; I don&#39;t think the `members` tuple is a good alternative here. It looks good on paper, but think about what it actually would need to involve to match this proposal and its likely enhancements:<br>&gt; <br>&gt; - It would need to have different elements at different levels of accessibility, and we would somehow have to select the right level for the matching initializer.<br></p><p>That’s a good point. Maybe some kind of type narrowing according to accessibility (probably explicit)?<br></p><p>&gt; - It would need to include only properties *writable* at that level.<br></p><p>Or maybe have both readable and writeable parts/views, i.e. members.readable and members.writable<br></p><p>&gt; - It would need to include only stored properties.<br></p><p>They would be included in a readable part/view, though.<br></p><p>&gt; - It would need to include only properties that are either `var`s or uninitialized `let`s.<br></p><p>That’s why I separated into vars and lets in my playground. This is already quite workable with regards to assignability if still a bit clunky.<br></p><p>&gt; - But we would need mechanisms to add items that have been excluded, and remove items that have been included.<br></p><p>Yes, that’s still a big question. This would again require some kind of type narrowing according to properties excluded.<br></p><p>&gt; Plus there&#39;s all the weirdness around using it to reassign constants.<br></p><p>That’s why I separated into varMembers and letMembers in my playground. No reassignment possible but assignment within initializers is fine.<br></p><p>&gt; Basically, once you&#39;ve applied all of the specialized rules needed to make the `members` tuple work for memberwise initializers, is `members` still going to be useful for anything else? Frankly, I think the answer to that question is &quot;No&quot;. So we end up designing something that&#39;s maybe 1/4 orthogonal instead of 0/4 orthogonal, but is also a<br></p><p>The missing things seem to be mostly<br>(1) type narrowing according to accessibility (e.g. &quot;let x: public Foo“ would give x the type of Foo narrowed to the public interface even if more of Foo would be visible here)<br>(2) maybe type narrowing according to readability/writability<br>(3) type narrowing according to excluded properties (e.g. let x: S#without(s0) would give x the type of S narrowed to the interface where s0 does not appear)<br>(4) ability to spread a struct into a parameter list (the struct’s property names becoming the parameter names)<br></p><p>I don’t immediately see a general use case for the (1)+(3) but could imagine that (4) would be generally useful and maybe even (2).<br>Maybe someone else has an idea on their usefulness or maybe there is a completely different solution with a different feature set.<br></p><p>&gt; lot less clear. In the end, I don&#39;t think that&#39;ll actually be a win.<br></p><p>Yeah. Still brainstorming here :-)<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 10, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 1:17 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; Yeah. Still brainstorming here :-)<br></p><p>So you know, I didn&#39;t really mean to put you specifically on the spot here; you&#39;re obviously trying to find concrete solutions to these problems. But it seems to me that what we&#39;re going to end up with is that, instead of having this:<br></p><p>	public init(members...: Members) {<br>		self.members = members<br>	}<br></p><p>We&#39;ll have something more like:<br></p><p>	public init(members...: Members.Public.Initializable) {<br>		self.members.public.initializable = members<br>	}<br></p><p>Which looks a whole lot worse than the original when you compare it to this proposal&#39;s:<br></p><p>	public memberwise init(...) {}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 10.01.2016 um 10:37 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 1:17 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Yeah. Still brainstorming here :-)<br>&gt; <br>&gt; So you know, I didn&#39;t really mean to put you specifically on the spot here; you&#39;re obviously trying to find concrete solutions to these problems.<br></p><p>No offense taken, I’m really interested in the opinion of everyone, that’s why I’m posting here :-)<br></p><p><br>&gt; But it seems to me that what we&#39;re going to end up with is that, instead of having this:<br>&gt; <br>&gt; 	public init(members...: Members) {<br>&gt; 		self.members = members<br>&gt; 	}<br>&gt; <br>&gt; We&#39;ll have something more like:<br>&gt; <br>&gt; 	public init(members...: Members.Public.Initializable) {<br>&gt; 		self.members.public.initializable = members<br>&gt; 	}<br></p><p>Yes, that’s just what I’m trying to find out: I do like the Members-based idea but wanted to get a clearer understanding how it might *really* unfold before casting my vote for the current proposal. <br></p><p><br>&gt; Which looks a whole lot worse than the original when you compare it to this proposal&#39;s:<br>&gt; <br>&gt; 	public memberwise init(...) {}<br></p><p>You are certainly right, although one might argue that it has the advantage of spelling out a little bit more explicitly which members are hiding behind the &quot;…“, i.e. it should be immediately clear that let properties with an initial value would not be part of Members.Public.Initializable, shouldn’t it?<br>Same for internal or private properties.<br>Whether that would be worth the longer form I’m not sure myself. At least it’s still just one simple assignment.<br></p><p>Exempting properties will certainly look even worse:<br></p><p>public init(members…: Members.Public.Initializable.except(i), x: Int) {<br>	self.members.public.initializable.except(i) = members<br>	i = 2 * x<br>}<br></p><p>In addition the syntax would need some changes to differentiate between regular property access, accessing the special property &quot;members&quot; and narrowing operations.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 10, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 10, 2016, at 4:08 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 10.01.2016 um 10:37 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 1:17 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; Yeah. Still brainstorming here :-)<br>&gt;&gt; <br>&gt;&gt; So you know, I didn&#39;t really mean to put you specifically on the spot here; you&#39;re obviously trying to find concrete solutions to these problems.<br>&gt; <br>&gt; No offense taken, I’m really interested in the opinion of everyone, that’s why I’m posting here :-)<br>&gt; <br>&gt; <br>&gt;&gt; But it seems to me that what we&#39;re going to end up with is that, instead of having this:<br>&gt;&gt; <br>&gt;&gt;    public init(members...: Members) {<br>&gt;&gt;        self.members = members<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; We&#39;ll have something more like:<br>&gt;&gt; <br>&gt;&gt;    public init(members...: Members.Public.Initializable) {<br>&gt;&gt;        self.members.public.initializable = members<br>&gt;&gt;    }<br>&gt; <br>&gt; Yes, that’s just what I’m trying to find out: I do like the Members-based idea but wanted to get a clearer understanding how it might *really* unfold before casting my vote for the current proposal. <br></p><p>I will be sharing my vision for a long-term direction later today or tomorrow.  It allows us to accept this proposal as a step forward while still having a long-term path that relies on more general features, with a clean migration path when the more general features are ready.  <br></p><p>I hope you&#39;ll be willing to support this proposal as a good first step.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; <br>&gt;&gt; Which looks a whole lot worse than the original when you compare it to this proposal&#39;s:<br>&gt;&gt; <br>&gt;&gt;    public memberwise init(...) {}<br>&gt; <br>&gt; You are certainly right, although one might argue that it has the advantage of spelling out a little bit more explicitly which members are hiding behind the &quot;…“, i.e. it should be immediately clear that let properties with an initial value would not be part of Members.Public.Initializable, shouldn’t it?<br>&gt; Same for internal or private properties.<br>&gt; Whether that would be worth the longer form I’m not sure myself. At least it’s still just one simple assignment.<br>&gt; <br>&gt; Exempting properties will certainly look even worse:<br>&gt; <br>&gt; public init(members…: Members.Public.Initializable.except(i), x: Int) {<br>&gt;    self.members.public.initializable.except(i) = members<br>&gt;    i = 2 * x<br>&gt; }<br>&gt; <br>&gt; In addition the syntax would need some changes to differentiate between regular property access, accessing the special property &quot;members&quot; and narrowing operations.<br>&gt; <br>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 10, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jan 10, 2016, at 3:37 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 10, 2016, at 1:17 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Yeah. Still brainstorming here :-)<br>&gt; <br>&gt; So you know, I didn&#39;t really mean to put you specifically on the spot here; you&#39;re obviously trying to find concrete solutions to these problems. But it seems to me that what we&#39;re going to end up with is that, instead of having this:<br>&gt; <br>&gt;    public init(members...: Members) {<br>&gt;        self.members = members<br>&gt;    }<br>&gt; <br>&gt; We&#39;ll have something more like:<br>&gt; <br>&gt;    public init(members...: Members.Public.Initializable) {<br>&gt;        self.members.public.initializable = members<br>&gt;    }<br>&gt; <br>&gt; Which looks a whole lot worse than the original when you compare it to this proposal&#39;s:<br>&gt; <br>&gt;    public memberwise init(...) {}<br></p><p>I think I have a solution to this which will be a good long-term direction with a clean migration path from the current proposal.  I&#39;ll be posting details later today or tomorrow morning.  I think you&#39;ll like it.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 10, 2016 at 12:00:00pm</p></header><div class="content"><p>Before diving into the details, I’d like to reiterate the point of my review:<br></p><p>I don’t know exactly what the better mechanism is, but I strongly suspect that it’s out there. My wish is to defer the current very narrow proposal in favor of a more searching for a general mechanism.<br></p><p>I don&#39;t think we should permanently reject a thoughtful proposal only because a better proposal might be out there. Neither do I think that having to come up with a better mechanism within the review period should be a requirement of not immediately accepting the proposal.<br></p><p>That’s the upshot of my review. The rest of this message is just noodling….<br></p><p>&gt; Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think the `members` tuple is a good alternative here. It looks good on paper, but think about what it actually would need to involve to match this proposal and its likely enhancements:<br>&gt; <br>&gt; - It would need to have different elements at different levels of accessibility, and we would somehow have to select the right level for the matching initializer.<br>&gt; - It would need to include only properties *writable* at that level.<br>&gt; - It would need to include only stored properties.<br>&gt; - It would need to include only properties that are either `var`s or uninitialized `let`s.<br></p><p>You’re imagining with all these that the initialization code must be _completely_ synthesized. But as I said, I’d happily shoulder the burden of just a little more explicitness if I got a mechanism that wasn’t so inflexible as the proposal at hand.<br></p><p>I’m quite sure that the automated synthesizing won’t always get it right. It tries, but I’ll want inevitably want manual control. And thus…<br></p><p>&gt; - But we would need mechanisms to add items that have been excluded, and remove items that have been included.<br></p><p>…I’d want such mechanisms with the current proposal too — but there’s no obvious future expansion direction for them.<br></p><p>&gt; Plus there&#39;s all the weirdness around using it to reassign constants.<br></p><p>It would follow the same rules as normal assignment. No weirdness there.<br></p><p>&gt; On Jan 10, 2016, at 3:37 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 1:17 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Yeah. Still brainstorming here :-)<br>&gt; <br>&gt; So you know, I didn&#39;t really mean to put you specifically on the spot here; you&#39;re obviously trying to find concrete solutions to these problems. But it seems to me that what we&#39;re going to end up with is that, instead of having this:<br>&gt; <br>&gt; 	public init(members...: Members) {<br>&gt; 		self.members = members<br>&gt; 	}<br>&gt; <br>&gt; We&#39;ll have something more like:<br>&gt; <br>&gt; 	public init(members...: Members.Public.Initializable) {<br>&gt; 		self.members.public.initializable = members<br>&gt; 	}<br></p><p>Well, in my brainstorms, I was loosely imagining that when members is used as an lvalue, it would infer the subset being assigned to using the labels of the rhs tuple. So you could do this:<br></p><p>	public init(members...: Members.Public.Initializable) {<br>		self.members = members<br>	}<br></p><p>…or maybe something more arbitrarily composable:<br></p><p>	public init(members...: Members.only(public, var, except: meaningOfLife)) {<br>		self.members = members<br>                meaningOfLife = 42<br>	}<br></p><p>…or even:<br></p><p>	public init(members...: Members.only(public, var).except(meaningOfLife)) {<br>		self.members = members<br>                meaningOfLife = 42<br>	}<br></p><p>Breaking that down:<br></p><p>	Members.only(public, var) → (a: Int, b: String, meaningOfLife: Int)<br>        .except(meaningOfLife) = generic operation that works on any tuple → (a: Int, b: String)<br>	members arg then gets a value like (a: 4, b: “foo”)<br>	self.members = (a: 4, b: “foo”) infers that a and b are being assigned to, and expands to:<br>		a = 4<br>		b = 4<br>	…with no additional language features necessary for access control, let/var, etc.<br></p><p>Something like that. Who knows? It’s obviously a complicated discussion. The point is just that it would do a lot more for the language to have orthogonal features for:<br></p><p>turning tuples into variadic parameters,<br>turning member or member types into a tuple, the former of which can be an lvalue, and<br>subsetting and reordering tuples.<br></p><p>…with none of those being limited to initializers.<br></p><p>Some mechanism like this would generalize much better than the current proposal, which breaks down quickly if you step outside its imagined use cases.<br></p><p>I don’t see the current proposal leading in this more useful direction, though it sounds like Matthew has something up his sleeve.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/c03c0f05/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>I had another thought last night about this proposal. Since it appears to be working as syntactic sugar, if I write something like<br></p><p>var x: Int<br>memberwise init(...) {<br>    // what does x refer to here?<br>}<br></p><p>Inside of the memberwise init, does the bare identifier `x` refer to the property, or to the implicit parameter? I think it should refer to the property, because making it refer to the implicit parameter means you&#39;d be referring to a variable that was never visibly declared anywhere. AFAIK the only precedent for that is the implicit argument `newValue` to setters, `oldValue` to didSet observers, and `error` to catch blocks, but those are all constant identifiers that mean the same thing in every such context, as opposed to memberwise init where the implicit parameters are different for each init. More generally, we should avoid exposing such non-declared variables without a compelling reason.<br></p><p>The other argument in favor of making `x` refer to the property is because that&#39;s just generally more useful. All the properties match the values of the parameters on the first line of the user-supplied body to the memberwise init, so there&#39;s no benefit to be had from leaving the parameters accessible to user code.<br></p><p>As for how to actually accomplish this, assuming this feature is implemented as an AST transformation, ideally we&#39;d have some way to synthesize identifiers in the AST that cannot possibly be referenced by user code (e.g. some form of identifier namespacing if it exists, or some form of gensym-like behavior). Alternatively, if there&#39;s no particularly good way to do this, we could just use something like `__name` as the internal parameter name.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 1:05 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I had another thought last night about this proposal. Since it appears to be working as syntactic sugar, if I write something like<br>&gt; <br>&gt; var x: Int<br>&gt; memberwise init(...) {<br>&gt;    // what does x refer to here?<br>&gt; }<br>&gt; <br>&gt; Inside of the memberwise init, does the bare identifier `x` refer to the property, or to the implicit parameter? I think it should refer to the property, because making it refer to the implicit parameter means you&#39;d be referring to a variable that was never visibly declared anywhere.<br>&gt; AFAIK the only precedent for that is the implicit argument `newValue` to setters, `oldValue` to didSet observers, and `error` to catch blocks, but those are all constant identifiers that mean the same thing in every such context, as opposed to memberwise init where the implicit parameters are different for each init. More generally, we should avoid exposing such non-declared variables without a compelling reason.<br>&gt; <br>&gt; The other argument in favor of making `x` refer to the property is because that&#39;s just generally more useful. All the properties match the values of the parameters on the first line of the user-supplied body to the memberwise init, so there&#39;s no benefit to be had from leaving the parameters accessible to user code.<br>&gt; <br>&gt; As for how to actually accomplish this, assuming this feature is implemented as an AST transformation, ideally we&#39;d have some way to synthesize identifiers in the AST that cannot possibly be referenced by user code (e.g. some form of identifier namespacing if it exists, or some form of gensym-like behavior). Alternatively, if there&#39;s no particularly good way to do this, we could just use something like `__name` as the internal parameter name.<br></p><p>Thanks for bringing this up Kevin.  I agree it should refer to the property.  Not sure what, but for some reason I didn’t think to state this explicitly in the proposal.  In fact, my examples accidentally implied otherwise because they didn’t show the compiler using a mangled name of some kind for the internal parameter name in the expansions.<br></p><p>The only downside is that it changes behavior if you transition from a memberwsie initializer to a manual initializer.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>On Fri, Jan 8, 2016, at 11:15 AM, Matthew Johnson wrote:<br>&gt; <br>&gt; &gt; On Jan 8, 2016, at 1:05 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I had another thought last night about this proposal. Since it appears to be working as syntactic sugar, if I write something like<br>&gt; &gt; <br>&gt; &gt; var x: Int<br>&gt; &gt; memberwise init(...) {<br>&gt; &gt;    // what does x refer to here?<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; Inside of the memberwise init, does the bare identifier `x` refer to the property, or to the implicit parameter? I think it should refer to the property, because making it refer to the implicit parameter means you&#39;d be referring to a variable that was never visibly declared anywhere.<br>&gt; &gt; AFAIK the only precedent for that is the implicit argument `newValue` to setters, `oldValue` to didSet observers, and `error` to catch blocks, but those are all constant identifiers that mean the same thing in every such context, as opposed to memberwise init where the implicit parameters are different for each init. More generally, we should avoid exposing such non-declared variables without a compelling reason.<br>&gt; &gt; <br>&gt; &gt; The other argument in favor of making `x` refer to the property is because that&#39;s just generally more useful. All the properties match the values of the parameters on the first line of the user-supplied body to the memberwise init, so there&#39;s no benefit to be had from leaving the parameters accessible to user code.<br>&gt; &gt; <br>&gt; &gt; As for how to actually accomplish this, assuming this feature is implemented as an AST transformation, ideally we&#39;d have some way to synthesize identifiers in the AST that cannot possibly be referenced by user code (e.g. some form of identifier namespacing if it exists, or some form of gensym-like behavior). Alternatively, if there&#39;s no particularly good way to do this, we could just use something like `__name` as the internal parameter name.<br>&gt; <br>&gt; Thanks for bringing this up Kevin.  I agree it should refer to the property.  Not sure what, but for some reason I didn’t think to state this explicitly in the proposal.  In fact, my examples accidentally implied otherwise because they didn’t show the compiler using a mangled name of some kind for the internal parameter name in the expansions.<br>&gt; <br>&gt; The only downside is that it changes behavior if you transition from a memberwsie initializer to a manual initializer.<br></p><p>If you transition to a manual initializer you can provide your own mangled internal parameter names for your manual initializer, so there&#39;s no behavioral change. And in most cases the distinction won&#39;t actually matter anyway, it&#39;s just the cases where a property may change during initialization (either due to modifying it directly, or due to calling a method that modifies it and then reading the property afterwards) where you actually care that the identifier refers to the property.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 1:17 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jan 8, 2016, at 11:15 AM, Matthew Johnson wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 1:05 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had another thought last night about this proposal. Since it appears to be working as syntactic sugar, if I write something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x: Int<br>&gt;&gt;&gt; memberwise init(...) {<br>&gt;&gt;&gt;   // what does x refer to here?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Inside of the memberwise init, does the bare identifier `x` refer to the property, or to the implicit parameter? I think it should refer to the property, because making it refer to the implicit parameter means you&#39;d be referring to a variable that was never visibly declared anywhere.<br>&gt;&gt;&gt; AFAIK the only precedent for that is the implicit argument `newValue` to setters, `oldValue` to didSet observers, and `error` to catch blocks, but those are all constant identifiers that mean the same thing in every such context, as opposed to memberwise init where the implicit parameters are different for each init. More generally, we should avoid exposing such non-declared variables without a compelling reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other argument in favor of making `x` refer to the property is because that&#39;s just generally more useful. All the properties match the values of the parameters on the first line of the user-supplied body to the memberwise init, so there&#39;s no benefit to be had from leaving the parameters accessible to user code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for how to actually accomplish this, assuming this feature is implemented as an AST transformation, ideally we&#39;d have some way to synthesize identifiers in the AST that cannot possibly be referenced by user code (e.g. some form of identifier namespacing if it exists, or some form of gensym-like behavior). Alternatively, if there&#39;s no particularly good way to do this, we could just use something like `__name` as the internal parameter name.<br>&gt;&gt; <br>&gt;&gt; Thanks for bringing this up Kevin.  I agree it should refer to the property.  Not sure what, but for some reason I didn’t think to state this explicitly in the proposal.  In fact, my examples accidentally implied otherwise because they didn’t show the compiler using a mangled name of some kind for the internal parameter name in the expansions.<br>&gt;&gt; <br>&gt;&gt; The only downside is that it changes behavior if you transition from a memberwsie initializer to a manual initializer.<br>&gt; <br>&gt; If you transition to a manual initializer you can provide your own mangled internal parameter names for your manual initializer, so there&#39;s no behavioral change. And in most cases the distinction won&#39;t actually matter anyway, it&#39;s just the cases where a property may change during initialization (either due to modifying it directly, or due to calling a method that modifies it and then reading the property afterwards) where you actually care that the identifier refers to the property.<br></p><p>Yes, of course.  But if you forget to provide your own internal name it would be a behavior change.  I agree in most cases it wouldn’t matter much either way.  I just thought it was important to point out that there is a rare case where it could result in something unintended / unexpected.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/ad12fd78/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi, Matthew. (Hi, everyone.) Thanks for putting together a detailed and well-thought-out proposal. I had some smaller comments:<br></p><p>- Given that these initializers are based on access control, is &quot;public memberwise init(...)&quot; different from &quot;internal memberwise init(...)&quot;? Can I put both in the same type?<br></p><p>- Why not just put the &quot;memberwise&quot; in the parameter list, and drop the decl modifier? This came up in the draft discussion but I didn&#39;t see any follow-up.<br></p><p>- I kind of agree now that &quot;memberwise&quot; is the wrong name, but I don&#39;t have a better one.<br></p><p>…but after reading through the formal review discussion, I have to say I don&#39;t think this is a good feature for Swift. I tend to agree with David Owens and others that this is too much magic in one keyword. (I picked David because I think his responses most closely match my concerns out of the dissenters.)<br></p><p>Imagine trying to explain this feature in The Swift Programming Language. It starts off very simple with the perfect use case:<br></p><p>public struct Point {<br>  public var x: Double<br>  public var y: Double<br>  public memberwise init(...) {}<br>}<br></p><p>…but then spends the rest of the chapter going over everything in the proposal: why you can&#39;t provide a default for &#39;let&#39; properties, why hiding a setter affects the presence of a member, and what to do if you want to change it but preserve backwards binary compatibility. It seems like a big, complicated feature that &quot;does what you mean&quot; only when it&#39;s first added and then becomes an impediment to any later change.<br></p><p>I&#39;m motivated to solve the tiny value struct case, the public C-like struct case, but I don&#39;t think I want this creeping into the interface of a public class. I&#39;d rather go with the &quot;annotation on parameters&quot; solution (which would be a separate proposal, of course).<br></p><p>public struct Point {<br>  public var x: Double<br>  public var y: Double<br>  public init(self x: Double, self y: Double) {}<br>}<br></p><p>or<br></p><p>  public init(@assigned x: Double, @assigned y: Double) {}<br>  public init(self.x: Double, self.y: Double) {}<br>  // something else<br></p><p>For comparison with other languages, the &quot;memberwise initializer&quot; proposal is closest to C&#39;s brace-initialization, but C structs aren&#39;t resilient to change in the way that classes are, and they won&#39;t break if you reorder the members, while this will. The &quot;annotation on parameters&quot; idea is precedented in CoffeeScript, but I don&#39;t know of any other languages that do it.<br></p><p>This proposal is very practical and covers many common use cases, but I just don&#39;t see it as naturally fitting into the language.<br></p><p>Best,<br>Jordan<br></p><p><br>&gt; On Jan 6, 2016, at 14:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/817ef0a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 5:18 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi, Matthew. (Hi, everyone.) Thanks for putting together a detailed and well-thought-out proposal. I had some smaller comments:<br></p><p>Hi Jordan, thanks for your review. <br></p><p>&gt; <br>&gt; - Given that these initializers are based on access control, is &quot;public memberwise init(...)&quot; different from &quot;internal memberwise init(...)&quot;? Can I put both in the same type?<br></p><p>If you have at least one internal property they would result in different signatures so would not be a duplicate declaration.  The public memberwise init would obviously need to initialize the internal property somehow.<br></p><p>&gt; <br>&gt; - Why not just put the &quot;memberwise&quot; in the parameter list, and drop the decl modifier? This came up in the draft discussion but I didn&#39;t see any follow-up.<br></p><p>Good question.  The decl modifier was initially Chris’s idea and it seemed reasonable to me so I ran with it.<br></p><p>&gt; <br>&gt; - I kind of agree now that &quot;memberwise&quot; is the wrong name, but I don&#39;t have a better one.<br></p><p>It is a bit verbose, and in many ways has the same issues as `associatedtype`.  I used it because it is the terminology in use in Swift today and also don’t have anything better to replace it with.<br></p><p>&gt; <br>&gt; …but after reading through the formal review discussion, I have to say I don&#39;t think this is a good feature for Swift. I tend to agree with David Owens and others that this is too much magic in one keyword. (I picked David because I think his responses most closely match my concerns out of the dissenters.)<br>&gt; <br>&gt; Imagine trying to explain this feature in The Swift Programming Language. It starts off very simple with the perfect use case:<br>&gt; <br>&gt; public struct Point {<br>&gt;   public var x: Double<br>&gt;   public var y: Double<br>&gt;   public memberwise init(...) {}<br>&gt; }<br>&gt; <br>&gt; …but then spends the rest of the chapter going over everything in the proposal: why you can&#39;t provide a default for &#39;let&#39; properties, why hiding a setter affects the presence of a member, and what to do if you want to change it but preserve backwards binary compatibility. It seems like a big, complicated feature that &quot;does what you mean&quot; only when it&#39;s first added and then becomes an impediment to any later change.<br></p><p>I can certainly sympathize with this.  It is the big drawback of the automatic model.  At the same time, this proposal builds on the existing memberwise init for structs and doesn’t really make the rules that much more complex.  But it does make the feature more prevalent and visible, thus making it more important to understand the rules.  And of course it could be argued that the current memberwise init is too complex as it is.<br></p><p>For the record, here is a concise list of how this proposal expands the current memberwise init:<br></p><p>1. Allow the memberwise initializer to be used in classes<br>2. Allow default parameter values for `var` properties<br>3. Fix the problem the current memberwise initializer has with lazy properties<br>4. Use the `set` rather than `get` visibility for `var` properties<br>5. Allow you to request the memberwise initializer, including:<br>	i. Add additional parameters<br>	ii. include an initializer body<br>	iii. Specify access level, which will result in omission of memberwise parameters for more-private properties (it would be reasonable to limit this to private and internal if concerns about allowing it to be public are a significant factor)<br></p><p>I am curious to hear your thoughts on which of these points are not desirable, and what your opinion is about the existing rules for the implicit memberwise init for structs.<br></p><p><br></p><p>&gt; <br>&gt; I&#39;m motivated to solve the tiny value struct case, the public C-like struct case, but I don&#39;t think I want this creeping into the interface of a public class. I&#39;d rather go with the &quot;annotation on parameters&quot; solution (which would be a separate proposal, of course).<br>&gt; <br>&gt; public struct Point {<br>&gt;   public var x: Double<br>&gt;   public var y: Double<br>&gt;   public init(self x: Double, self y: Double) {}<br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt;   public init(@assigned x: Double, @assigned y: Double) {}<br>&gt;   public init(self.x: Double, self.y: Double) {}<br>&gt;   // something else<br>&gt; <br></p><p>I’ll ask you the same question I asked David about this approach: if the parameter must be explicitly related to a property for assignment, why should we repeat the type information (and default value information if it is a var)?  Doesn’t it seem reasonable to omit the type?<br></p><p><br>&gt; For comparison with other languages, the &quot;memberwise initializer&quot; proposal is closest to C&#39;s brace-initialization, but C structs aren&#39;t resilient to change in the way that classes are, and they won&#39;t break if you reorder the members, while this will. The &quot;annotation on parameters&quot; idea is precedented in CoffeeScript, but I don&#39;t know of any other languages that do it.<br>&gt; <br>&gt; This proposal is very practical and covers many common use cases, but I just don&#39;t see it as naturally fitting into the language.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 14:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/d7ca47cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>Sorry to leave this over the weekend before getting back to you! Planning to respond here, then go catch up on the thread—a possibly questionable ordering of tasks, but one that ensures I will actually respond at all.<br></p><p>&gt;&gt; <br>&gt;&gt; - Given that these initializers are based on access control, is &quot;public memberwise init(...)&quot; different from &quot;internal memberwise init(...)&quot;? Can I put both in the same type?<br>&gt; <br>&gt; If you have at least one internal property they would result in different signatures so would not be a duplicate declaration.  The public memberwise init would obviously need to initialize the internal property somehow.<br></p><p>That&#39;s what I expected, just wanted to have it spelled out. Thanks.<br></p><p><br>&gt;&gt;  It seems like a big, complicated feature that &quot;does what you mean&quot; only when it&#39;s first added and then becomes an impediment to any later change.<br>&gt; <br>&gt; I can certainly sympathize with this.  It is the big drawback of the automatic model.  At the same time, this proposal builds on the existing memberwise init for structs and doesn’t really make the rules that much more complex.  But it does make the feature more prevalent and visible, thus making it more important to understand the rules.  And of course it could be argued that the current memberwise init is too complex as it is.<br>&gt; <br>&gt; For the record, here is a concise list of how this proposal expands the current memberwise init:<br>&gt; <br>&gt; 1. Allow the memberwise initializer to be used in classes<br>&gt; 2. Allow default parameter values for `var` properties<br>&gt; 3. Fix the problem the current memberwise initializer has with lazy properties<br>&gt; 4. Use the `set` rather than `get` visibility for `var` properties<br>&gt; 5. Allow you to request the memberwise initializer, including:<br>&gt; 	i. Add additional parameters<br>&gt; 	ii. include an initializer body<br>&gt; 	iii. Specify access level, which will result in omission of memberwise parameters for more-private properties (it would be reasonable to limit this to private and internal if concerns about allowing it to be public are a significant factor)<br>&gt; <br>&gt; I am curious to hear your thoughts on which of these points are not desirable, and what your opinion is about the existing rules for the implicit memberwise init for structs.<br></p><p>I&#39;m happy with 1, 2, and 3 as a separate proposal, or several separate proposals. (For 1 in particular, the restriction predates the access control model, but making it implicit would also interfere with inheriting designated initializers.) I&#39;m not sure 4 is interesting enough, but sure.<br></p><p>The particular concern I have with 5 is that the most interesting use case to me is for &#39;public&#39; (indeed, that&#39;s by far the majority of the requests for this we&#39;ve seen in Radar, rdar://problem/18065955), but that&#39;s also the most dangerous one if you have anything unusual going on: different access control, library evolution, etc. (i) and (ii) are mostly just extra features, but (iii) is where it gets weird.<br></p><p>(The next most common request related to this proposal is 1, memberwise inits for classes, mostly in simple cases. rdar://problem/16704095)<br></p><p>For public memberwise inits, I think my discomfort ultimately comes down to &quot;the order of stored properties in a class is not usually part of the class&#39;s ABI&quot;, and this makes it too easy to opt into that, and then too hard to explain which members and why. There&#39;s also the problem of wanting to tweak one parameter&#39;s behavior, and being unable to do that; having to build more features on top of this one to fix that seems like it&#39;s going in the wrong direction.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m motivated to solve the tiny value struct case, the public C-like struct case, but I don&#39;t think I want this creeping into the interface of a public class. I&#39;d rather go with the &quot;annotation on parameters&quot; solution (which would be a separate proposal, of course).<br>&gt;&gt; <br>&gt;&gt; public struct Point {<br>&gt;&gt;   public var x: Double<br>&gt;&gt;   public var y: Double<br>&gt;&gt;   public init(self x: Double, self y: Double) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt;   public init(@assigned x: Double, @assigned y: Double) {}<br>&gt;&gt;   public init(self.x: Double, self.y: Double) {}<br>&gt;&gt;   // something else<br>&gt;&gt; <br>&gt; <br>&gt; I’ll ask you the same question I asked David about this approach: if the parameter must be explicitly related to a property for assignment, why should we repeat the type information (and default value information if it is a var)?  Doesn’t it seem reasonable to omit the type?<br></p><p>I&#39;m happy to come up with a syntax to omit the type and default value; I do still think the listing of parameters should be explicit. (And it should be obvious where it gets any type and default value from.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/b86b6a5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 1:44 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Sorry to leave this over the weekend before getting back to you! Planning to respond here, then go catch up on the thread—a possibly questionable ordering of tasks, but one that ensures I will actually respond at all.<br></p><p>No problem.  Thanks for responding!  <br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Given that these initializers are based on access control, is &quot;public memberwise init(...)&quot; different from &quot;internal memberwise init(...)&quot;? Can I put both in the same type?<br>&gt;&gt; <br>&gt;&gt; If you have at least one internal property they would result in different signatures so would not be a duplicate declaration.  The public memberwise init would obviously need to initialize the internal property somehow.<br>&gt; <br>&gt; That&#39;s what I expected, just wanted to have it spelled out. Thanks.<br>&gt; <br>&gt; <br>&gt;&gt;&gt;  It seems like a big, complicated feature that &quot;does what you mean&quot; only when it&#39;s first added and then becomes an impediment to any later change.<br>&gt;&gt; <br>&gt;&gt; I can certainly sympathize with this.  It is the big drawback of the automatic model.  At the same time, this proposal builds on the existing memberwise init for structs and doesn’t really make the rules that much more complex.  But it does make the feature more prevalent and visible, thus making it more important to understand the rules.  And of course it could be argued that the current memberwise init is too complex as it is.<br>&gt;&gt; <br>&gt;&gt; For the record, here is a concise list of how this proposal expands the current memberwise init:<br>&gt;&gt; <br>&gt;&gt; 1. Allow the memberwise initializer to be used in classes<br>&gt;&gt; 2. Allow default parameter values for `var` properties<br>&gt;&gt; 3. Fix the problem the current memberwise initializer has with lazy properties<br>&gt;&gt; 4. Use the `set` rather than `get` visibility for `var` properties<br>&gt;&gt; 5. Allow you to request the memberwise initializer, including:<br>&gt;&gt; 	i. Add additional parameters<br>&gt;&gt; 	ii. include an initializer body<br>&gt;&gt; 	iii. Specify access level, which will result in omission of memberwise parameters for more-private properties (it would be reasonable to limit this to private and internal if concerns about allowing it to be public are a significant factor)<br>&gt;&gt; <br>&gt;&gt; I am curious to hear your thoughts on which of these points are not desirable, and what your opinion is about the existing rules for the implicit memberwise init for structs.<br>&gt; <br>&gt; I&#39;m happy with 1, 2, and 3 as a separate proposal, or several separate proposals. (For 1 in particular, the restriction predates the access control model, but making it implicit would also interfere with inheriting designated initializers.) I&#39;m not sure 4 is interesting enough, but sure.<br></p><p>Hmm, thought you had agreed with #4 in the discussion about that topic.  That said, it is less important in the context of an `internal` or `private` implicit memberwise initializer. <br></p><p>&gt; <br>&gt; The particular concern I have with 5 is that the most interesting use case to me is for &#39;public&#39; (indeed, that&#39;s by far the majority of the requests for this we&#39;ve seen in Radar, rdar://problem/18065955 &lt;rdar://problem/18065955&gt;), but that&#39;s also the most dangerous one if you have anything unusual going on: different access control, library evolution, etc. (i) and (ii) are mostly just extra features, but (iii) is where it gets weird.<br></p><p>I can certainly understand your concerns regarding `public` as well as (iii).  <br></p><p>I’m hoping this proposal will be accepted even if some features are removed.  Even if only 1-3 or 1-4 were accepted to improve the implicit memberwise initializer I would consider that a good thing.  <br></p><p>&gt; <br>&gt; (The next most common request related to this proposal is 1, memberwise inits for classes, mostly in simple cases. rdar://problem/16704095 &lt;rdar://problem/16704095&gt;)<br>&gt; <br>&gt; For public memberwise inits, I think my discomfort ultimately comes down to &quot;the order of stored properties in a class is not usually part of the class&#39;s ABI&quot;, and this makes it too easy to opt into that, and then too hard to explain which members and why. There&#39;s also the problem of wanting to tweak one parameter&#39;s behavior, and being unable to do that; having to build more features on top of this one to fix that seems like it&#39;s going in the wrong direction.<br></p><p>I hope you’ll take a look at the new proposals I submitted.  I think they provide a better approach to providing this kind of control than the enhancements I included in this proposal.  The Partial Initializers proposal might be the best one to look at first.  It would effectively supersede the explicit memberwise initializers in this proposal with a more general purpose implementation.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m motivated to solve the tiny value struct case, the public C-like struct case, but I don&#39;t think I want this creeping into the interface of a public class. I&#39;d rather go with the &quot;annotation on parameters&quot; solution (which would be a separate proposal, of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Point {<br>&gt;&gt;&gt;   public var x: Double<br>&gt;&gt;&gt;   public var y: Double<br>&gt;&gt;&gt;   public init(self x: Double, self y: Double) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public init(@assigned x: Double, @assigned y: Double) {}<br>&gt;&gt;&gt;   public init(self.x: Double, self.y: Double) {}<br>&gt;&gt;&gt;   // something else<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’ll ask you the same question I asked David about this approach: if the parameter must be explicitly related to a property for assignment, why should we repeat the type information (and default value information if it is a var)?  Doesn’t it seem reasonable to omit the type?<br>&gt; <br>&gt; I&#39;m happy to come up with a syntax to omit the type and default value; I do still think the listing of parameters should be explicit. (And it should be obvious where it gets any type and default value from.)<br></p><p><br>Glad to hear you think we could omit the type and default value (but still allow for overriding the default value).  I think as a sugar feature it needs to save as much as possible to pay its way.<br></p><p>Another idea along the lines of paying its way as much as possible: maybe if all parameters are “self” parameters you could specify that once at the function level rather than repeating it for every parameter.  What do you think about that idea?  Maybe something like an @self attribute:<br></p><p>@self public init(x, y) {}<br></p><p>I agree that it should be obvious where those come from - I think the type and default value would come from the property declaration.  Is there anywhere else it could come from?<br></p><p>I think this feature could be useful.  I just don’t see it as being a complete solution.  It would combine with my new Partial Initializers proposal very nicely.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/bff082cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>-1. I’ve always preferred explicit vs implicit/automatic behaviour and I think the this proposal ads too much complexity, syntax and keywords for a fairly small gain (for me).<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>First of all, I don’t that that initialisers are that problematic/tedious to write to warrant this proposal. But I also see this adding too much magic for the small gain.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>No.<br></p><p>&gt; If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More than a glance and quick reading, but less than an in-depth study :)<br></p><p>&gt; On 11 Jan 2016, at 22:21, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 11, 2016, at 1:44 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry to leave this over the weekend before getting back to you! Planning to respond here, then go catch up on the thread—a possibly questionable ordering of tasks, but one that ensures I will actually respond at all.<br>&gt; <br>&gt; No problem.  Thanks for responding!  <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Given that these initializers are based on access control, is &quot;public memberwise init(...)&quot; different from &quot;internal memberwise init(...)&quot;? Can I put both in the same type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have at least one internal property they would result in different signatures so would not be a duplicate declaration.  The public memberwise init would obviously need to initialize the internal property somehow.<br>&gt;&gt; <br>&gt;&gt; That&#39;s what I expected, just wanted to have it spelled out. Thanks.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;  It seems like a big, complicated feature that &quot;does what you mean&quot; only when it&#39;s first added and then becomes an impediment to any later change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can certainly sympathize with this.  It is the big drawback of the automatic model.  At the same time, this proposal builds on the existing memberwise init for structs and doesn’t really make the rules that much more complex.  But it does make the feature more prevalent and visible, thus making it more important to understand the rules.  And of course it could be argued that the current memberwise init is too complex as it is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the record, here is a concise list of how this proposal expands the current memberwise init:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Allow the memberwise initializer to be used in classes<br>&gt;&gt;&gt; 2. Allow default parameter values for `var` properties<br>&gt;&gt;&gt; 3. Fix the problem the current memberwise initializer has with lazy properties<br>&gt;&gt;&gt; 4. Use the `set` rather than `get` visibility for `var` properties<br>&gt;&gt;&gt; 5. Allow you to request the memberwise initializer, including:<br>&gt;&gt;&gt; 	i. Add additional parameters<br>&gt;&gt;&gt; 	ii. include an initializer body<br>&gt;&gt;&gt; 	iii. Specify access level, which will result in omission of memberwise parameters for more-private properties (it would be reasonable to limit this to private and internal if concerns about allowing it to be public are a significant factor)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am curious to hear your thoughts on which of these points are not desirable, and what your opinion is about the existing rules for the implicit memberwise init for structs.<br>&gt;&gt; <br>&gt;&gt; I&#39;m happy with 1, 2, and 3 as a separate proposal, or several separate proposals. (For 1 in particular, the restriction predates the access control model, but making it implicit would also interfere with inheriting designated initializers.) I&#39;m not sure 4 is interesting enough, but sure.<br>&gt; <br>&gt; Hmm, thought you had agreed with #4 in the discussion about that topic.  That said, it is less important in the context of an `internal` or `private` implicit memberwise initializer. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The particular concern I have with 5 is that the most interesting use case to me is for &#39;public&#39; (indeed, that&#39;s by far the majority of the requests for this we&#39;ve seen in Radar, rdar://problem/18065955 &lt;rdar://problem/18065955&gt;), but that&#39;s also the most dangerous one if you have anything unusual going on: different access control, library evolution, etc. (i) and (ii) are mostly just extra features, but (iii) is where it gets weird.<br>&gt; <br>&gt; I can certainly understand your concerns regarding `public` as well as (iii).  <br>&gt; <br>&gt; I’m hoping this proposal will be accepted even if some features are removed.  Even if only 1-3 or 1-4 were accepted to improve the implicit memberwise initializer I would consider that a good thing.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; (The next most common request related to this proposal is 1, memberwise inits for classes, mostly in simple cases. rdar://problem/16704095 &lt;rdar://problem/16704095&gt;)<br>&gt;&gt; <br>&gt;&gt; For public memberwise inits, I think my discomfort ultimately comes down to &quot;the order of stored properties in a class is not usually part of the class&#39;s ABI&quot;, and this makes it too easy to opt into that, and then too hard to explain which members and why. There&#39;s also the problem of wanting to tweak one parameter&#39;s behavior, and being unable to do that; having to build more features on top of this one to fix that seems like it&#39;s going in the wrong direction.<br>&gt; <br>&gt; I hope you’ll take a look at the new proposals I submitted.  I think they provide a better approach to providing this kind of control than the enhancements I included in this proposal.  The Partial Initializers proposal might be the best one to look at first.  It would effectively supersede the explicit memberwise initializers in this proposal with a more general purpose implementation.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m motivated to solve the tiny value struct case, the public C-like struct case, but I don&#39;t think I want this creeping into the interface of a public class. I&#39;d rather go with the &quot;annotation on parameters&quot; solution (which would be a separate proposal, of course).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Point {<br>&gt;&gt;&gt;&gt;   public var x: Double<br>&gt;&gt;&gt;&gt;   public var y: Double<br>&gt;&gt;&gt;&gt;   public init(self x: Double, self y: Double) {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public init(@assigned x: Double, @assigned y: Double) {}<br>&gt;&gt;&gt;&gt;   public init(self.x: Double, self.y: Double) {}<br>&gt;&gt;&gt;&gt;   // something else<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll ask you the same question I asked David about this approach: if the parameter must be explicitly related to a property for assignment, why should we repeat the type information (and default value information if it is a var)?  Doesn’t it seem reasonable to omit the type?<br>&gt;&gt; <br>&gt;&gt; I&#39;m happy to come up with a syntax to omit the type and default value; I do still think the listing of parameters should be explicit. (And it should be obvious where it gets any type and default value from.)<br>&gt; <br>&gt; <br>&gt; Glad to hear you think we could omit the type and default value (but still allow for overriding the default value).  I think as a sugar feature it needs to save as much as possible to pay its way.<br>&gt; <br>&gt; Another idea along the lines of paying its way as much as possible: maybe if all parameters are “self” parameters you could specify that once at the function level rather than repeating it for every parameter.  What do you think about that idea?  Maybe something like an @self attribute:<br>&gt; <br>&gt; @self public init(x, y) {}<br>&gt; <br>&gt; I agree that it should be obvious where those come from - I think the type and default value would come from the property declaration.  Is there anywhere else it could come from?<br>&gt; <br>&gt; I think this feature could be useful.  I just don’t see it as being a complete solution.  It would combine with my new Partial Initializers proposal very nicely.<br>&gt; <br>&gt; Matthew<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/3ecae64b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>I like the general direction of more flexible property-wise initialisation however I do have some reservations about the detailed proposal, in particular:<br></p><p>1. You can’t initialise lets.<br>2. You can’t initialise more-private-stored properties than the property-wise initialiser itself.<br>3. You can&#39;t label property-wise initialiser arguments.<br>4. It is not totally clear which properties are to be initialised property-wise.<br>5. The proposal adds to the existing menberwise initialisers and the default initialisers; which then means there are 4 initialisers (manual, current memberwise default, and new memberwise), therefore I would prefer a proposal that encompassed all of these.<br>6. Super types need a default initialiser.<br>7. The memberwise init does not have default values for its memberwise arguments which means that all memberwise arguments need to be specified when calling the memberwise init (like current memberwise init).<br>8. Stored properties have to be given a default value to participate in memberwise initialisation.<br>9. `memberwise` isn’t a great keyword, since funcs are also members<br>10. The … notation can be a bit invisible.<br></p><p>However I think that if the design space is opened up then these issues could be addressed. Here is a modification to the existing proposal:<br></p><p><br>1. Basic example: demonstrates a short form for C-like structs and let initialisation:<br></p><p>    // Short-property-wise form<br>    class Size2D properties { // Note: properties keyword<br>        let width = 0.0, height = 0.0 // Note: let<br>    }<br></p><p>    // Translation to long-property-wise form<br>    class Size2D {<br>        properties { // Note: obvious which properties are property-wise initialised<br>            let width = 0.0, height = 0.0<br>        } init(properties) {} // Note: placeholder, properties, for property-wise args and no init body<br>    }<br>    <br>    // Translation to basic Swift<br>    class Size2D {<br>        let width: Double<br>        let height: Double<br>        init(width: Double = 0.0, height: Double = 0.0) { // Note: default values for property-wise args<br>            self.width = width<br>            self.height = height<br>        }<br>    }<br></p><p><br>2. Example of how super is to be called.<br></p><p>    // Short-property-wise form<br>    class Size3D: Size2D properties(width: Double = 0.0, height: Double = 0.0) {<br>        let depth: Double = 0.0<br>    }<br></p><p>    // Translation to long-property-wise form<br>    class Size3D: Size2D {<br>        properties(width: Double = 0.0, height: Double = 0.0) {<br>            let depth: Double = 0.0<br>        } init(properties) {}<br>    }<br>    <br>    // Translation to basic Swift<br>    class Size3D: Size2D {<br>        let depth: Double<br>        init(width: Double = 0.0, height: Double = 0.0, depth: Double = 0.0) { // Note: super args before property-wise args<br>            self.depth = depth<br>            super.init(width: width, height: height)<br>        }<br>    }<br></p><p><br>3. More involved example with private property, properties arg label, other init, and other methods<br></p><p>    // Only long-property-wise form allowed since other methods and other initialisers required<br>    class LoggedAndScaledSize2D: Size2D {<br>        properties(width: Double = 0.0, height: Double = 0.0) {<br>            private var times scale: Double = 0.0 // Note: label, times, and private<br>        } init(properties) {}<br>        properties init(properties, logger: Logger? = nil) { // Note: only 1 property-wise init can have properties and super args<br>            logger?.log(self) // Note: rest of init<br>        }<br>        var scaledWidth: Double { // Note: other methods<br>            get { return scale * width }<br>    }<br></p><p>    // Translation to basic Swift<br>    class LoggedAndScaledSize2D: Size2D {<br>        private var scale: Double // Note: private<br>        init(width: Double = 0.0, height: Double = 0.0, times scale: Double = 0.0) { // Note: label times<br>            self.scale = scale<br>            super.init(width: width, height: height)<br>        }<br>        init(width: Double = 0.0, height: Double = 0.0, times scale: Double = 0.0, logger: Logger? = nil) {<br>            self.scale = scale<br>            super.init(width: width, height: height)<br>            logger?.log(self) // Rest of init<br>        }<br>        var scaledWidth: Double { // Other methods<br>            get { return scale * width }<br>            set { scale = newValue / width }<br>        }<br>        var scaledHeight: Double {<br>            get { return scale * height }<br>            set { scale = newValue / height }<br>        }<br>    }<br></p><p><br></p><p>4. The existing memberwise and default initialisers are deprecated.<br></p><p>Obviously the above is just a three examples - happy to flesh out details if there is interest.<br></p><p>The semantics of the proposal are as though the literal translations from short-property-wise form, to long-property-wise form, to basic Swift occurred.<br></p><p>The proposed semantics &quot;as though literal translated&quot; and previous compiler-written initialisers deprecated means that `struct Length { var length: Double = 0.0 }` is now an error - it has no initialisers. Programmer would write `struct Length properties { var length: Double = 0.0 }`, note added properties keyword.<br></p><p>Whether properties is much better than memberwise and … is open to some debate!<br></p><p>        * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I think a revised proposal would be viable, but marginal as it stands.<br></p><p>        * Does this proposal fit well with the feel and direction of Swift?<br></p><p>In some ways yes (because Swift has compiler written initialisation already), but in others, like adding another way of doing initialisation, no (because one aim of the evolution is not to become a ‘kitchen-sink&#39; language like C++).<br></p><p>        * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes I have used a similar feature in Scala and the current proposal is much more complicated. The Scala solution seems better to me. But see proposed alternative above.<br></p><p>        * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I have kept up with the discussions and have interacted with Matthew Johnston and others on this topic. I have also discussed with Bill Venners from Escalate; who is well known as an educator in the Scala community, the Scala version it is well liked in the Scala community and is easy to teach.<br></p><p>Glad this topic is under discussion,<br></p><p> -- Howard.<br></p><p>On 7 January 2016 at 09:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>Hello Swift community,<br></p><p>The review of &quot;Flexible property-wise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br></p><p>        https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-property-wise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-property-wise-initialization.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>        https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>        * What is your evaluation of the proposal?<br>        * Is the problem being addressed significant enough to warrant a change to Swift?<br>        * Does this proposal fit well with the feel and direction of Swift?<br>        * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>        * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>        https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>-Chris<br>Review Manager<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p><br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/3030cfda/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 5:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Overall, I think the proposal has merit. However, I have some concerns around two areas:<br></p><p>1) It adds complexity to initializers, which already have a fair amount of complexity around them.<br></p><p>2) I don&#39;t see anything in the proposal that indicates how a developer can see what the compiler synthesizes. As mentioned above, initializers are already complex, and having this capability would greatly help in troubleshooting problems when designing types.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I&#39;m ambivalent about this. I had genuinely good feelings about Swift from the time Apple introduced it at WWDC &#39;14. It provided software developers with many conveniences and removed a lot of complexity from its predecessor, Objective C. Sometimes flexibility adds complexity, and on some level I feel like this proposal adds some flexibility. While the proposal definitely solves a problem, it comes at a cost. Thus, we have to ask ourselves if the benefit outweighs the cost. At first glance, I think it does.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have not used any programming languages that synthesize sophisticated initializers. Most languages provide generate an automatic initializer that does nothing, which often leads to more problems than it is worth.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I thorough read the proposal three times, compared it to other languages that use on a regular basis, and gave it some serious thought.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>At first glance it looks like it should be a simple thing, but a closer look lead me to believe it&#39;s conflating two things:<br></p><p>1. stored properties initialization<br>2. user-visible property values<br></p><p>Stored properties are the internal state, while user-visible properties is the exposed state. Initialization is about setting the internal state. While it&#39;s common to have initializers accept values as arguments, in the general case the initializer has to convert them from the external representation to the internal representation while setting the internal state.<br></p><p>For a plain type with only raw stored properties, internal state and exposed state are the same thing, and this proposal is simple and very appealing.<br></p><p>But for more complex types where the internal state does not map one-on-one to the exposed state, the proposal seems suboptimal. What you really want is to call all the publicly available setters, not set the raw values. But that goes against how things work in an initializer, where setters are skipped and the raw values are set directly.<br></p><p>I understand the proposal is trying to work around this problem by inferring things from the visibility attributes, but the rules seems complex, bug prone (because it bypasses the setters), the feature seems incomplete (missing computed properties), and in the end unnecessary (because you can use the setters). I think we&#39;d be better served if there was simply a way to set properties in batch after initialization, perhaps like this:<br></p><p>	var object = MyObject()<br>	object .= (property1: 1, property2: &quot;a&quot;)<br></p><p>(Note: you can *almost* implement this already through reflection and a custom operator taking a tuple.)<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>This proposal is a good way to get back the default memberwise initializer that structs with no initializer get for free, and allow it for classes when it makes sense. It&#39;d be nice to have that.<br></p><p>I&#39;m also of the opinion that it&#39;s worth addressing the verbosity of setting multiple properties at once. But for complex types that hide their internal state, I don&#39;t think the added complexity for determining the parameter list and the default values is worth it.<br></p><p>Also, I see no reason why a type should have to opt-in (by providing a memberwise initializer) so its users have a convenient way to set properties: it&#39;d be much better to have a general solution that works everywhere.<br></p><p><br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Not sure.<br></p><p><br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;m not aware of any.<br></p><p><br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal, and a lot of what was discussed on the list (but not everything).<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>-1 in its current form<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes and no. First of all, I do not believe that writing initialisers is that much of a hassle to justify the proposal. Also, it makes the language even more idiosyncratic and introduces additional compiler magic. We should strive to make Swift simpler, not adding more syntactic constructs with idiosyncratic behaviour. <br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>IMO, no. See above<br></p><p>&gt; If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading, nothing in-depth<br></p><p>&gt; On 10 Jan 2016, at 19:38, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; At first glance it looks like it should be a simple thing, but a closer look lead me to believe it&#39;s conflating two things:<br>&gt; <br>&gt; 1. stored properties initialization<br>&gt; 2. user-visible property values<br>&gt; <br>&gt; Stored properties are the internal state, while user-visible properties is the exposed state. Initialization is about setting the internal state. While it&#39;s common to have initializers accept values as arguments, in the general case the initializer has to convert them from the external representation to the internal representation while setting the internal state.<br>&gt; <br>&gt; For a plain type with only raw stored properties, internal state and exposed state are the same thing, and this proposal is simple and very appealing.<br>&gt; <br>&gt; But for more complex types where the internal state does not map one-on-one to the exposed state, the proposal seems suboptimal. What you really want is to call all the publicly available setters, not set the raw values. But that goes against how things work in an initializer, where setters are skipped and the raw values are set directly.<br>&gt; <br>&gt; I understand the proposal is trying to work around this problem by inferring things from the visibility attributes, but the rules seems complex, bug prone (because it bypasses the setters), the feature seems incomplete (missing computed properties), and in the end unnecessary (because you can use the setters). I think we&#39;d be better served if there was simply a way to set properties in batch after initialization, perhaps like this:<br>&gt; <br>&gt; 	var object = MyObject()<br>&gt; 	object .= (property1: 1, property2: &quot;a&quot;)<br>&gt; <br>&gt; (Note: you can *almost* implement this already through reflection and a custom operator taking a tuple.)<br>&gt; <br>&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; This proposal is a good way to get back the default memberwise initializer that structs with no initializer get for free, and allow it for classes when it makes sense. It&#39;d be nice to have that.<br>&gt; <br>&gt; I&#39;m also of the opinion that it&#39;s worth addressing the verbosity of setting multiple properties at once. But for complex types that hide their internal state, I don&#39;t think the added complexity for determining the parameter list and the default values is worth it.<br>&gt; <br>&gt; Also, I see no reason why a type should have to opt-in (by providing a memberwise initializer) so its users have a convenient way to set properties: it&#39;d be much better to have a general solution that works everywhere.<br>&gt; <br>&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Not sure.<br>&gt; <br>&gt; <br>&gt;&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I&#39;m not aware of any.<br>&gt; <br>&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read the proposal, and a lot of what was discussed on the list (but not everything).<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 11, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>-1 with the &quot;added convenience &lt; introduced complexity&quot; rationale that has been mentioned by a few people in this discussion.<br></p><p>At first I was interested in this proposal for the obvious reason of having previously written initializer &quot;boilerplate&quot; and like with any form of boilerplate instinctively desiring to be rid of it. However over the evolution and now review of this proposal I have become much more hesitant.<br></p><p><br>Firstly, from the discussion it has become clear that this is a hard issue to solve elegantly.<br></p><p>I mostly like the proposed syntax but it adds a lot of additional language surface with complicated semantics for ultimately limited benefit.<br>Many people (on both the +1 and -1 sides) seem to be agree that this is ultimately only a &quot;partial&quot; solution and that they would like additional capabilities. However from the proposal and the discussion it seems that those would require even more special behaviour and/or syntax, again adding a lot of additional complexity for limited usefulness.<br></p><p><br>Secondly, over the course of following this discussion I have become increasingly convinced that this is not as big an issue as I first thought.<br></p><p>At least for me it seems that the annoyance towards writing (some) initializers stems mostly from an instinctual reaction to having to perform a repetitive and menial task. Upon reflection it seems the actual mental and physical work is extremely minimal and it&#39;s mostly my annoyance at doing so that seems out of proportion. Very little of my time is ultimately spent writing trivial initialization code.<br></p><p>While these initializers are annoying to type out, it is not an error prone task. They are clear and easy to understand, requiring basically no mental overhead to &quot;parse&quot;. They can be easily refactored and adapted as needs change.<br></p><p>With the proposal as it stands I can save a few keystrokes here and there. Until my initializer needs a bit of custom work at which point I might need to write it out anyway, use increasingly obscure syntax, start reordering the types properties, etc... The various extensions to this proposal increase the number of initializers that I could &quot;simplify&quot; but at the cost of a much more complex mental model. Now I need to take into account various attributes and declarations to make my initializer(s) work the way I want.<br></p><p>Writing the initializer is something that happens once, reading it will occur many times. And while it&#39;s nice to save 50 keystrokes when writing the thing, is it worth the mental overhead required to piece it together in the future?<br></p><p>The oft mentioned alternative `init(foo: Int, bar: Int) { // implicit }` improves on some of these aspects but at that point the work saved is so small as to probably not be worth the bother.<br></p><p>Now I&#39;m not saying the answers here are clear cut but for me, for now, this proposal introduces a lot of complexity to solve a very limited subset of a not so big problem. But I&#39;d be happy to see this topic revisited in the future and this detailed and well though out proposal should definitely be the starting point for any future discussions.<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Judging from the interest in this topic, probably yes. However it is a minor problem and the current solutions are too costly for too little benefit.<br></p><p><br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Syntactically mostly yes. However Swift strongly favors clarity and simplicity over conciseness and I feel this proposal has issues in that regard.<br></p><p><br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p><br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve read the proposal (an earlier draft and the current version) and followed the discussion.<br></p><p><br>- Janosch<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>As the review of the Flexible Memberwise Initialization proposal draws to a close I would like to offer some final thoughts.  <br></p><p>First, I would like to thank everyone who has reviewed the proposal and participated in the discussion.  You have all given me a lot to think about.  I believe this discussion has been very productive.  It has helped to move my thinking on the topic forward and shape a more complete, more compelling vision of where we can go.<br></p><p>At a high level I think there are a few takeaways.  <br></p><p>First, there seems to be very broad (but not universal) agreement that something should be done to make trivial initialization code more concise.  The problem is worth solving.<br></p><p>Second, there is more support than opposition for this proposal, but the response is definitely mixed.  By my tally the responses are roughly:<br></p><p>55% favorable (Chris and I are both still favorable)<br>20% mixed<br>25% opposed<br></p><p>The categorization is somewhat subjective but I believe anyone who does a tally on their own will come up with reasonably similar results.<br></p><p>Third, there are some common and valid criticisms which are addressed further down below.<br></p><p>Finally, I after much vetting I still believe this proposal does a good job of fulfilling the goal it set out to do, namely improve the existing memberwise intializer by making it much more flexible.  <br></p><p>Even several of those who oppose the proposal have agreed with that.  The basis of their opposition is that once you work out the details of doing so the resulting complexity is not worth it.  <br></p><p>Personally, I believe the increase in complexity over the current implicit memberwise initializer is not as significant as some perceive and the additional flexibility more than pays for the cost of the incremental complexity.  The changes from current state can be summarized concisely as:<br></p><p>1. Allow the memberwise initializer to be used in classes<br>2. Allow default parameter values for `var` properties<br>3. Fix the problem the current memberwise initializer has with lazy properties<br>4. Use the `set` rather than `get` visibility for `var` properties<br>5. Allow you to request the memberwise initializer, including:<br>	i. Add additional parameters<br>	ii. include an initializer body<br>	iii. Specify access level, which will result in omission of memberwise parameters for more-private properties (it would be reasonable to limit this to private and internal if concerns about allowing it to be public are a significant factor)<br></p><p>The perceived complexity of this proposal focuses on the property eligibility rules.  As noted in the list above, there are only two differences in those rules under the curernt proposal compared to the existing implicit memberwise initializer: #4 and #5.iii.  In exchange for accepting those two changes this proposal gives us the increased functionality in the rest of the list.<br></p><p>Despite the proposal doing a good job of fulfilling the basic goal, there have been some very valid critiques of it:<br></p><p>1. **Complexity:** the rules of any workable automatic model are inherently nontrivial.  <br>2. **Limitations:** it isn&#39;t possible to specify an explicit list of parameters, their order, their external lablels, and default values for `let` properties.  <br>3. **Specificity:** the memberwise initialization is a very special case feature.  It would be better to have more general facilities that support the memberwise initialization use case.<br></p><p>I have been giving a lot of thought to all of them.  I espicially want to thank Dave Abrahams and Joe Groff for starting the discussion around looking for more general facilities to support memberwise initialization. <br></p><p>Ultimately, improving the existing memberwise initializer is not the best premise for a long-term solution to address the limitations of this proposal.  A solution built on more general features can be just as clear and expressive, while also serving use cases beyond memberwise initialization.<br></p><p>With all of the above in mind, my recommendation is to accept this proposal and simultaneously keep working on more general facilities that can supercede the faciilities of this proposal (aside from the imiplicit memberwise initializer).  I make this recommendation for the following reasons:<br></p><p>1. This proposal improves the implicit memberwise initializer which will not be touched by proposals for more general features adressing.<br>2. There is no guarantee that more general features addressing memberwise initialization will make it into Swift 3.  Accepting this proposal guarantees we will see improvements that I believe are worthwhile, even if they are not a final solution.<br>3. Implementation could begin with an eye on the more general approach, possibly providing a head start on implementing them.<br></p><p>I would also like to begin discussion regarding three general facilities that can work together to improve the conciseness and expressiveness of our initializers.  The combination of the first two facilities can supercede the functionality of this proposal.  I believe all three facilities working together can signficantly increase the clarity and expressiveness of our initialization code.  <br></p><p>1. Parameter forwarding: I began working on a general purpose parameter forwarding proposal prior to this review.  This feature will add clarity to various forms of chained initializers.  It will also be to any function that needs to forward a set of arguments from its caller directly to another function, not just to initializers.<br></p><p>2. Partial initializers: The idea for this proposal was inspired by thinking about Joe&#39;s example of a more general solution.  Using a setter to perform initialization (especially of `let` properties) just seems wrong to me.  What we need is a partial initializer which can be used to factor out common initialization logic.  Partial initialzers are a general purpose initialization tool, not a tool specific to memberwise initializers.  However, when combined with parameter forwarding and a few implicit partial initializers, it is possible to replace the explicit memberwise initializers described in this proposal with syntax that is just as concise.<br></p><p>3. Property lists: Property lists were inspired by two subthreads of this review.  One was Joe&#39;s idea for a computed &quot;members&quot; tuple property.  The other is all of the discussions related to limitations and lack of control in the Flexible Memberwise Initialization proposal.  Property lists are a declaration that allows a user to declare a specific set of properties, in a specific order, with specific labels and specific default parameter values.  This declaration results in a synthesized partial initializer as well as a synthesized computed tuple property.  It may also synthesize other memberwise features in the future as new ideas for them arise.  The property list enables extremely concise yet expressive declarations of memberwise partial initializers.  It is also possible to include several implicit property lists such as `members`, `vars`, `lets`, etc which would be quite similar to some of the ideas discussed in the review thread.<br></p><p>The proposal drafts can be found at the following links:<br></p><p>* Parameter forwarding: https://github.com/anandabits/swift-evolution/blob/parameter-forwarding/proposals/NNNN-parameter-forwarding.md<br>* Partial initializers: https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br>* Property lists: https://github.com/anandabits/swift-evolution/blob/property-lists/proposals/NNNN-property-lists.md<br></p><p>They contain enough detail about the proposed solution that I believe they are ready for a first round of discussion, however none are complete drafts.  I will be starting a thread for each proposal.  Please move discussion specific to each proposal into its respective thread.<br></p><p>Any discussion pertaining to memberwise intitialization, how these proposals address concerns brought up during the review, how well these proposals together provide a good long-term direction for memberwise intialization, etc can remain in one of the threads about the current proposal.<br></p><p>I want to thank you all again for participating.  I&#39;m very much looking forward to continuing the discussion.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/7c3d9336/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>Especially after reviewing the associated proposals, I can&#39;t avoid the impression that the topic of initialization steers towards a complexity that is hard to to justify.<br>There are whole programming languages that are easier to explain than the rules that are laid out here and in the other threads — and I mean it literally:<br>Just take Scheme or Tcl as an example.<br></p><p>I already suggested to delay the decision, but now I&#39;m convinced this would be way better than to force an issue.<br>There are alternatives that have been mentioned but did not yet receive a fair treatment, and there might be better solutions no one has been talking about.<br>Initialization isn&#39;t that bad right now, so despite Matthews haste, there is imho no need to choose a solution without a neutral comparison of all options.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>It’s a well-considered and well-written proposal. I agree with the semantics of memberwise initializers (+1 to adding a reasonable implicit memberwise initializer for classes, and the ability to use default arguments in that implicit memberwise initializer). However, I would prefer to accept the semantics as improvements to the creation of the implicit memberwise initializer, so it’s a -1 to the “memberwise” specifier and “…” placeholder syntax.<br></p><p>Separately, I’m moderately nervous about the placeholder “…” getting overloaded with future intended uses for variadic generics and tuple packing/unpacking. I think the syntaxes will be distinct (“…” would always be attached to an existing parameter in the variadic-generics cases, and would be it’s own “parameter” for the memberwise initializer), but it could certainly be confusing.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, for the implicit memberwise initializer. The lack of default arguments in the implicit memberwise initializer comes up often as a feature request, and the lack of an implicit memberwise initializer for classes leads to a bunch of boilerplate for common use cases (particularly the “let’s create our first class” example, which needs to mention initializers far too early).<br></p><p>As for the “memberwise” specifier and placeholder syntax, I don’t think so. When the implicit memberwise initializer doesn’t suffice, I think it’s completely reasonable to write out a memberwise initializer directly. It’s still boilerplate, but the cases in which it happens aren’t so numerous that it’s worth having another initialization concept.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. It’s eliminating boilerplate and making structs/classes more useful and more uniform.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read through the proposal and some of the commentary and, err, I bear responsibility for the current implicit memberwise initializer semantics, and have been thinking about this problem on-and-off for a couple of years.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/e1cae902/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 11 Jan 2016, at 07:37, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; It’s a well-considered and well-written proposal. I agree with the semantics of memberwise initializers (+1 to adding a reasonable implicit memberwise initializer for classes, and the ability to use default arguments in that implicit memberwise initializer). However, I would prefer to accept the semantics as improvements to the creation of the implicit memberwise initializer, so it’s a -1 to the “memberwise” specifier and “…” placeholder syntax.<br></p><p>Since this has been mentioned a few times now I&#39;d like to add that I would support that as well.<br></p><p>I&#39;m not really sure enough yet as to how the reviews work, so I&#39;ll ask here:<br></p><p>Is it possible for a subset or modified version of a proposal to be accepted or would the proposal be rejected while asking for a reduced/modified follow-up proposal?<br></p><p>Also are proposals always accepted or rejected, or could a proposal be returned as &quot;needs more work, submit again later&quot; instead of a flat out rejection?<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/d769d0e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 3:09 PM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 11 Jan 2016, at 07:37, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; It’s a well-considered and well-written proposal. I agree with the semantics of memberwise initializers (+1 to adding a reasonable implicit memberwise initializer for classes, and the ability to use default arguments in that implicit memberwise initializer). However, I would prefer to accept the semantics as improvements to the creation of the implicit memberwise initializer, so it’s a -1 to the “memberwise” specifier and “…” placeholder syntax.<br>&gt; <br>&gt; Since this has been mentioned a few times now I&#39;d like to add that I would support that as well.<br>&gt; <br>&gt; I&#39;m not really sure enough yet as to how the reviews work, so I&#39;ll ask here:<br>&gt; <br>&gt; Is it possible for a subset or modified version of a proposal to be accepted or would the proposal be rejected while asking for a reduced/modified follow-up proposal?<br>&gt; <br>&gt; Also are proposals always accepted or rejected, or could a proposal be returned as &quot;needs more work, submit again later&quot; instead of a flat out rejection?<br></p><p><br>The core team can do any of the above, including accepting subsets of proposals, accepting a proposal with modification, sending a proposal back for revision to come through the process again, etc. In general, we’ll try to do the lowest-overhead thing that makes sense for Swift.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/63b60fb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 12 Jan 2016, at 00:18, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 11, 2016, at 3:09 PM, Janosch Hildebrand &lt;jnosh at jnosh.com &lt;mailto:jnosh at jnosh.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Jan 2016, at 07:37, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a well-considered and well-written proposal. I agree with the semantics of memberwise initializers (+1 to adding a reasonable implicit memberwise initializer for classes, and the ability to use default arguments in that implicit memberwise initializer). However, I would prefer to accept the semantics as improvements to the creation of the implicit memberwise initializer, so it’s a -1 to the “memberwise” specifier and “…” placeholder syntax.<br>&gt;&gt; <br>&gt;&gt; Since this has been mentioned a few times now I&#39;d like to add that I would support that as well.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not really sure enough yet as to how the reviews work, so I&#39;ll ask here:<br>&gt;&gt; <br>&gt;&gt; Is it possible for a subset or modified version of a proposal to be accepted or would the proposal be rejected while asking for a reduced/modified follow-up proposal?<br>&gt;&gt; <br>&gt;&gt; Also are proposals always accepted or rejected, or could a proposal be returned as &quot;needs more work, submit again later&quot; instead of a flat out rejection?<br>&gt; <br>&gt; <br>&gt; The core team can do any of the above, including accepting subsets of proposals, accepting a proposal with modification, sending a proposal back for revision to come through the process again, etc. In general, we’ll try to do the lowest-overhead thing that makes sense for Swift.<br>&gt; <br>&gt; 	- Doug<br></p><p>Thanks, that&#39;s great to hear!<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/09d627ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jan 11, 2016, at 5:22 PM, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 12 Jan 2016, at 00:18, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 11, 2016, at 3:09 PM, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 11 Jan 2016, at 07:37, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s a well-considered and well-written proposal. I agree with the semantics of memberwise initializers (+1 to adding a reasonable implicit memberwise initializer for classes, and the ability to use default arguments in that implicit memberwise initializer). However, I would prefer to accept the semantics as improvements to the creation of the implicit memberwise initializer, so it’s a -1 to the “memberwise” specifier and “…” placeholder syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this has been mentioned a few times now I&#39;d like to add that I would support that as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not really sure enough yet as to how the reviews work, so I&#39;ll ask here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it possible for a subset or modified version of a proposal to be accepted or would the proposal be rejected while asking for a reduced/modified follow-up proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also are proposals always accepted or rejected, or could a proposal be returned as &quot;needs more work, submit again later&quot; instead of a flat out rejection?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The core team can do any of the above, including accepting subsets of proposals, accepting a proposal with modification, sending a proposal back for revision to come through the process again, etc. In general, we’ll try to do the lowest-overhead thing that makes sense for Swift.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; Thanks, that&#39;s great to hear!<br></p><p>I agree.  I know that some parts of this proposal are more controversial than others, especially.  Least controversial being the improvements to the implicit memberwise initializer.  <br></p><p>I would much prefer to see a modified version of the proposal accepted than the whole thing rejected.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; - Janosch<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/4fdd08d7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 12, 2016 at 02:00:00pm</p></header><div class="content"><p>Thank you all for the discussion on this proposal.  The core team met to discuss it today and I have a boat load of notes to propagate.  The “short&quot; version is that the proposal is not accepted as-is.  I’ll write them up the notes on rationale and the changes requested when I have time, hopefully by the end of tomorrow.<br></p><p>-Chris<br></p><p>&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 12, 2016 at 11:00:00pm</p></header><div class="content"><p>On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br></p><p>Here are some long and poorly organized notes from the core team meeting to discuss this feature.  Many, many, thanks to Alex Martini for capturing many of these details, but the mess I’ve made of this is not his fault. :-)<br></p><p><br>--- Metapoints --- <br></p><p>First, some meta points that came up from several members of the core team:<br></p><p>- Less is more.  Many folks (core team and other community members both) commented that the mere presence of the expansive “future directions” section made the proposal off-putting.<br></p><p>- “Pure sugar” proposals need to have strong justification for their existence since they do not add new capabilities, but they do add new complexity to the language.<br></p><p>- This feature included justification based on the fact that the existing memberwise feature has problems, but some core team folks thought that this wasn’t good enough justification.  They commented that perhaps we should just remove the existing memberwise init for structs and call it a day.  (others strongly disagreed :-)<br></p><p>- The team wanted to evaluate “all” of the conceivable different approaches to make sure that this approach was the right one in general.  I captured notes about some of that discussion below.  On the balance, they agree that a variant of this proposal is the right way to go.<br></p><p>- We didn’t have time to bikeshed the fine details of the proposal (e.g. the “memberwise” keyword, the … sigil, etc), just discussing the general semantics and shape of what an acceptable solution would look like.<br></p><p><br>MOST SIGNIFICANTLY: there was strong pushback about considering this proposal *at all* right now: this is a pure sugar proposal with a broad design space.  It doesn’t have long term ABI implications at all, and we have other serious semantic problems in the language to clean up and address.  We can tackle this sort of sugar feature at any time, including in Swift 4.  The core team would like to defer talking about this for a couple of months until the other things (property behaviors, resilience, and other big changes) are behind us.  We need to focus on the important things, because getting syntactic niceties into Swift 3 but missing on ABI stability would be really unfortunate.  We have seriously constrained design and engineering bandwidth.  This feedback applies to other pure-sugar proposals as well.<br></p><p><br>--- Rationale --- <br></p><p>I explained three bits of rationale for why we should tackle this:<br></p><p>1) Our existing feature is half-baked and unsatisfying.  This causes me personal angst but, as pointed out above, the simplest solution is to just remove what we have until we can do it right.<br></p><p>2) Memberwise init sugar strongly benefits “POD” types and other “bags of property” types (e.g. “Vec4&quot;), and many of the C struct types that Cocoa has (CGRect etc).  In these cases, clients often want to initialize all of the fields explicitly and a memberwise init proposal eliminates this boilerplate.  This case is what our existing feature attempts to service.<br></p><p>3) Memberwise init sugar can replace some really common “builder” patterns.  These cases often have a bunch of configurable state in a class, where almost all of it has default values, but where clients want to be able to only specify deltas from the default.  In the cases where you have a type with a ton of data members, a memberwise init is very very appealing because it eliminates a ton of boilerplate to set up a builder manually, and it also allows the captured state to be immutable (if we allow memberwise init of lets, which Matthew is a huge proponent of).  This case can often be a class derived from something else (e.g. a Kit class), explaining the desire to specify super.init, add custom parameters, etc.<br></p><p><br>#3 is my distillation/abstraction of many of the arguments that Matthew has made on the list and in the proposal (e.g. his very helpful FontPicker example), but I don’t claim that this captures all of his or any one else’s motivation.  This is simply the rationale that the team discussed.<br></p><p><br>--- Common feedback and points ---<br></p><p>Getting to points common to any “memberwise initializer” proposal, the goals of the core team are:<br></p><p>- Provide a predictable model.  It was concerning to many people that you could accidentally reorder properties and break a memberwise init without knowing/thinking about it.  This directly contravenes the resilience model.  API diff’ing tools and “synthesized header” views in Xcode ameliorate this, but don’t totally solve it.<br></p><p>- After discussion, the desire to support memberwise init of let properties was found to be a strong goal.  The entire win of providing a builder-like pattern in an init method (vs doing initialize to default and reassign over the value later, C# style) is the immutability benefits.<br></p><p>- We would like for memberwise init to be orthogonal to property behaviors, access control, attributes, and all the other stuff you’d want to do on your properties.  Also, ideally, you shouldn’t be limited to what kinds of properties can participate.<br></p><p>- The issues around whether properties with a default value (both let and var) can be replaced by a memberwise init is a really important semantic decision we need to nail down.  Many of the proposals include the problem/fact that something like:<br></p><p>class C {<br>  var x : Int = foo()<br></p><p>  memberwise init(…) {}<br>}<br></p><p>would not run the foo() side effect when initialized with &quot;C(42)”.  Similarly, in a case like:<br></p><p>class C {<br>  let x : Int = 42<br>  memberwise init(…) {}<br>}<br></p><p>it is still very concerning to people that the apparent axiom that “x is 42” could be violated by a memberwise init.  Allowing lets have other implementation issues, such as suddenly making “x” require storage, where it could otherwise be optimized out.<br></p><p><br></p><p>OTOH, my previous objection about being able to write a memberwise init manually is bogus, since you could write the above out like this:<br></p><p>class C {<br>  let x : Int     // initial value removed.<br>  init(x: Int) { self.x = x }   // manually written memberwise init.<br>  init() { x = 42 }  // move the inline initial value here.<br>}<br></p><p><br></p><p>--- Approaches discussed ---<br></p><p>Here are the rough approaches we discussed, along with pros and cons.  For consistency, most of them are modeling the analog of sugarizing an example case like this:<br></p><p>class C : Derived {   // has base class<br>    var x: Int               // no default value.<br>    var y = 4.0            // default value<br>    var z = “foo&quot;          // default value<br></p><p>     // has an explicit “q” parameter as well as all the members as parameters.<br>     init(q: Int, x: Int, y: Double = 4.0, z: String = &quot;foo”) {<br>        self.x = x <br>        self.y = y<br>        self.z = z<br>        // your custom code can go here<br>        super.init(q)<br>    }<br>}<br></p><p>I ordered this so that the most promising ones are at the end, to keep you all in suspense :-)<br></p><p><br>Approach: C# model<br></p><p>As pointed out on the list, we could eliminate the notion of a synthesized memberwise init, and move the complexity to the caller side.  C# uses syntax along the lines of:<br></p><p>	new Foo(){x=42, y=17.0}<br></p><p>pro) No memberwise initializer concept<br>con) Requires all fields to be default initialized, which breaks non-nullable pointers etc.<br>con) Requires mutability, since you’re initializing, and then overwriting a field.<br>con) This specific syntax would be problematic with trailing closures etc.<br></p><p>Core team was strongly opposed to this approach.<br></p><p><br>Approach: Scala (among others) memberwise init as part of class decl<br></p><p>This would give us something like this:<br></p><p>class C(var x: Int, y: Float = 4.0, var z : String = “foo&quot;) : Derived {<br>    var extra = 4.0   // extra, non-memberwise fields supported.<br>    init(q: Int, ...) {  // all initializers get memberwise stuff added, allows bodies.<br>       extra = 17<br>        // your custom code can go here<br>        super.init(q)<br>     }<br>}<br></p><p>pro) Very predictable model, makes it very clear what is subject to memberwise init, and that the order matters<br>pro) This supports indicating that some fields don’t participate in memberwise init.<br>pro?) Syntax looks vaguely like the parameter list of the init<br>con) The syntax isn’t actually parameter list syntax, it is property syntax.  You’d want to accept public/private, let/var, behaviors, attributes, and lots of other stuff in there.  This would introduce confusion about parameter lists.<br>con) This is sticking more junk into the class decl, which is already populated with class attributes/modifiers, subclasses/protocols, etc.<br>con) This means we’ve have two very different ways to declare stored properties in a type.<br></p><p>Core team was strongly opposed to this approach.<br></p><p><br>Approach: Extract the members from the parameters of an initializer decl<br></p><p>This would give us something like this:<br></p><p>class C : Derived {<br>    // members come from the memberwise init.<br>     memberwise init(x: Int, y: Double = 4.0, z: String = &quot;foo”) {<br>        // your custom code can go here<br>        super.init(q)<br>    }<br>}<br></p><p>pro) Syntactically very terse.<br>con) This only supports one memberwise init.<br>con) Two ways to declare stored properties<br>con) Conflates the property grammar (behaviors etc) with parameter grammar, many of the same problems as approach right above does.<br></p><p>Core team was strongly opposed to this approach.<br></p><p><br>Approach: barely extend our existing model:<br></p><p>We could put default values onto our existing memberwise init, and allow you to write &quot;memberwise init(...)” to explicitly request it to be synthesized, but not allow a body.  We could bring the existing level of feature to classes.<br></p><p>pro) simple, solves some problems with the existing model.<br>pro) brings memberwise init to root classes and classes that derive from something with a init() to chain to (e.g. NSObject).<br>con) doesn’t solve enough of the problem to be worth it<br>con) feels like we are perpetuating a hack.<br>con) we’d have to extend this further at some point, this is just kicking the can down the road.<br></p><p>Core team was strongly opposed to this approach.  Better to either rip out what we have or do a bigger approach.<br></p><p><br>Approach: Magic “members” tuple (or other generics/variadics features) <br></p><p>class C : Derived {<br>    var x: Int<br>    var y = 4.0<br>    var z = “foo&quot;<br></p><p>    init(p : … Members) {<br>       self.members = p<br>    }<br></p><p>    // compiler synthesizes.<br>    typealias Members = (Int, Float, String)<br>    var members : Members { get {..} set {..}}<br>}<br></p><p>pro) seems like a more generally useful feature that could pay for itself in other ways<br>con) doesn’t work with default values, so it doesn’t solve the builder problem at all (and no, we are not adding default values back to tuple types :-)<br></p><p>Core team was strongly opposed to this as an approach for memberwise init, but can always consider doing this for other things if it is motivated by them.<br></p><p><br>Approach: Introduce sugar for “self.x = x&quot;<br></p><p>David Owens ][ mentioned that perhaps we can go with something simpler, like this (concrete syntax is just a strawman):<br></p><p>class C : Derived {<br>    var x: Int<br>    var y = 4.0<br>    var z = “foo&quot;<br></p><p>     init(q: Int, self.x, self.y, self.z) { <br>        // your custom code can go here<br>        super.init(q)<br>    }<br>}<br></p><p>… where self.x in the parameter list is sugar that says it takes whatever the x property is (incl type and initial value if present), and does &quot;self.x = x” in the body.<br></p><p>pro) Does not require introducing the notion of a memberwise init.  Any init could use this.<br>pro) Makes it very clear what members are being initialized and what the API for the init is.<br>pro) Makes it easy to pick and choose which members you want to make available to clients.<br>con) This isn’t sweet enough sugar to be worthwhile, particularly for the builder pattern case, which would require lots of boilerplate<br>con) the self.x syntax is weird and surely can be improved, but anything we came up with would be magic and weird.  Making this keyword driven (e.g. &quot;memberwise” at least gives people something to google and lets them know they’re looking at something magic).<br>con) doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br></p><p>Core team was weakly opposed to this approach, but agree that something like this could be composed on top of another proposal if that made sense.<br></p><p><br>Approach: Introduce sugar for “self.x = x”, and add “memberwise and …&quot;<br></p><p>Extending David Owens ][’s model a bit, we could keep the behavior he indicates and add memberwise/… to handle cases with default values:<br></p><p>class C : Derived {<br>    var x: Int<br>    var y = 4.0<br>    var z = “foo&quot;<br></p><p>     memberwise init(q: Int, self.x, ...) { <br>        // your custom code can go here<br>        super.init(q)<br>    }<br>}<br></p><p>… where self.x in the parameter list is sugar that says it takes whatever the x property is (incl type and initial value if present), and does &quot;self.x = x” in the body.  The presence of memberwise/… would forward all the properties with default values.<br></p><p>pro) Since default values can be provided by a callee in any order, this approach can be made stable against reordering of properties.<br>pro) Compared to the base proposal above, this would be great for the builder pattern case.<br>con) The POD case still requires you to duplicate all your properties, so this doesn’t really address that use-case.<br>con) the self.x syntax is weird and surely can be improved, but anything we came up with would be magic and weird.<br>con) doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br></p><p>Core team was weakly opposed to this approach.<br></p><p><br>Approach: Matthew’s proposal SE-0018 (the actual formal proposal :)<br></p><p>class C : Derived {<br>    var x: Int<br>    var y = 4.0<br>    var z = “foo&quot;<br></p><p>     memberwise init(q: Int, ...) {<br>        // your custom code can go here<br>        super.init(q)<br>    }<br>}<br></p><p>pro) Solves the POD case as well as the builder case.<br>pro) Keeps properties the way they are, composes with behaviors etc.<br>pro) Supports adding custom parameters to the initializer, supports custom chaining to super.init, etc.<br>pro) Supports multiple different memberwise inits in a class, e.g. that want to chain to different super.init’s.<br>pro) Like the clarity of having a keyword on the init, and a sigil in the parameter list saying that something is going on.<br>unclear) I’m not delving into it here, but the access control aspects were very controversial.  We didn’t discuss it fully.<br>con) compared to the Scala approach, doesn’t handle the ability to opt a member out of memberwise init (we’d need some thing like @nomemberwise) <br>con) Doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>con) Lots of concerns about unclarity that the order of the properties matter.  In a large type, the memberwise init could be “at the end” of the class, after a bunch of other initializers and methods, and the properties could be “up at the top”.  It could be very unclear to people that memberwise init is even happening, and changing a property could have surprising effects.<br>con) Not clear from the memberwise init declaration what the extra parameters are, you have to look at a synthesized header or something.<br></p><p>Core team thought this was very close, but the problems were significant enough to think it won’t fly, and suggest pursuing the variant below.<br></p><p><br>Approach: &quot;Opt-in&quot; version of Matthew’s proposal<br></p><p>Matthew has mentioned on list that he likes opt-in models, and after discussion the core team agreed that it is more promising than the base proposal.<br></p><p>In addition to the memberwise declmodifier, *also* introduce a declmodifier on the properties in question.  Here I’ll use “mwi” as a strawman for “memberwise initializerable”, but it is obviously not the right thing, and I’m sure it will be replaced with something else brilliant :-)<br></p><p>class C : Derived {<br>    mwi var x: Int<br>    mwi var y = 4.0<br>    mwi var z = “foo&quot;<br>    var extra = 4.0   // Doesn’t participate in memberwise inits.<br></p><p>     memberwise init(q: Int, ...) {<br>        // your custom code can go here<br>        super.init(q)<br>    }<br>}<br></p><p>pro) Solves the POD case as well as the builder case.<br>pro) Keeps properties the way they are, composes with behaviors etc.<br>pro) Supports adding custom parameters to the initializer, supports custom chaining to super.init, etc.<br>pro) Supports multiple different memberwise inits in a class, e.g. that want to chain to different super.init’s.<br>pro) Like the clarity of having a keyword on the init, and a sigil in the parameter list saying that something is going on.<br>pro) as with the Scala approach it handles the ability to have members be both memberwise and non-memberwise participating.<br>pro) Works with let and var initializer semantics.<br>pro) Looking at a property, you know immediately that it participates in memberwise init, and that you should go update the memberwise inits if you move it or change it.  We could warn/error if you have a “mwi” property and no memberwise init, or a memberwise init with no mwi property.<br>pro) because this is an opt-in model, we can eliminate the controversial access control aspect of SE-0018.<br>con) Not clear from the memberwise init declaration what the extra parameters are, you have to look at a synthesized header or something.<br>con) more verbose than Matthew’s proposal.  OTOH, the verbosity isn’t “boilerplate&quot; since we’re getting something out of it. Simple POD cases can be written as (e.g.) “mwi var x, y, z, w : Double” which isn’t bad.<br></p><p>Adding the modifier on the affected property decls helps improve the intentionality and eliminate some of the &quot;spooky action at a distance&quot; problem, but the major breakthrough (IMO) is that it allows us to include lets into the model, and gives us a simple answer for why side effects are squashed on vars.  Consider this example:<br></p><p>class C { <br>  mwi let a = 42<br>  mwi var b : Int = sideeffect()<br></p><p>  memberwise init(…) {}<br>}<br></p><p>A call site would look like this, giving A a value of 75 and would not run the side effect:<br> let tmp = C(a: 75, b: 12)<br></p><p>We’re ok with the side effect being squashed, and the let axiom being broken given that there is a decl modifier on the property decl.  This is because you can tell locally by looking at the property that a memberwise initializer provides a different value.  From an implementation perspective, this is also pretty great, because this leads to a very straight-forward codegen model that cleanly meshes with what we already have.<br></p><p><br>--- A path forward --- <br></p><p>So that’s where we left it.  Coming back to the meta point above though, the core team really doesn’t want to discuss this right now, given that this is purely a sugar proposal and we need to stay focused on the primary Swift 3 goals.  If Matthew or another community member wants to pick this up and keep running with it, that is perfectly fine, but we should defer more formal discussion about the proposal until at least march/april-ish.  Likewise, other pure sugar proposals should similarly be deferred at this point, unless they have some strong motivation that aligns with a Swift 3 goal. <br></p><p>I want to thank Matthew in particular for passionately pushing this area forward!<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/674000c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 14, 2016 at 08:00:00am</p></header><div class="content"><p>Many thanks to you and the core team for this incredibly detailed rationale and the decision. I very much like your favored approach and reasoning!<br>And many thanks to Matthew for pushing this forward with a thorough look at all the details of this area!<br></p><p>-Thorsten <br></p><p>&gt; Am 13.01.2016 um 08:24 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md<br>&gt; <br>&gt; Here are some long and poorly organized notes from the core team meeting to discuss this feature.  Many, many, thanks to Alex Martini for capturing many of these details, but the mess I’ve made of this is not his fault. :-)<br>&gt; <br>&gt; <br>&gt; --- Metapoints --- <br>&gt; <br>&gt; First, some meta points that came up from several members of the core team:<br>&gt; <br>&gt; - Less is more.  Many folks (core team and other community members both) commented that the mere presence of the expansive “future directions” section made the proposal off-putting.<br>&gt; <br>&gt; - “Pure sugar” proposals need to have strong justification for their existence since they do not add new capabilities, but they do add new complexity to the language.<br>&gt; <br>&gt; - This feature included justification based on the fact that the existing memberwise feature has problems, but some core team folks thought that this wasn’t good enough justification.  They commented that perhaps we should just remove the existing memberwise init for structs and call it a day.  (others strongly disagreed :-)<br>&gt; <br>&gt; - The team wanted to evaluate “all” of the conceivable different approaches to make sure that this approach was the right one in general.  I captured notes about some of that discussion below.  On the balance, they agree that a variant of this proposal is the right way to go.<br>&gt; <br>&gt; - We didn’t have time to bikeshed the fine details of the proposal (e.g. the “memberwise” keyword, the … sigil, etc), just discussing the general semantics and shape of what an acceptable solution would look like.<br>&gt; <br>&gt; <br>&gt; MOST SIGNIFICANTLY: there was strong pushback about considering this proposal *at all* right now: this is a pure sugar proposal with a broad design space.  It doesn’t have long term ABI implications at all, and we have other serious semantic problems in the language to clean up and address.  We can tackle this sort of sugar feature at any time, including in Swift 4.  The core team would like to defer talking about this for a couple of months until the other things (property behaviors, resilience, and other big changes) are behind us.  We need to focus on the important things, because getting syntactic niceties into Swift 3 but missing on ABI stability would be really unfortunate.  We have seriously constrained design and engineering bandwidth.  This feedback applies to other pure-sugar proposals as well.<br>&gt; <br>&gt; <br>&gt; --- Rationale --- <br>&gt; <br>&gt; I explained three bits of rationale for why we should tackle this:<br>&gt; <br>&gt; 1) Our existing feature is half-baked and unsatisfying.  This causes me personal angst but, as pointed out above, the simplest solution is to just remove what we have until we can do it right.<br>&gt; <br>&gt; 2) Memberwise init sugar strongly benefits “POD” types and other “bags of property” types (e.g. “Vec4&quot;), and many of the C struct types that Cocoa has (CGRect etc).  In these cases, clients often want to initialize all of the fields explicitly and a memberwise init proposal eliminates this boilerplate.  This case is what our existing feature attempts to service.<br>&gt; <br>&gt; 3) Memberwise init sugar can replace some really common “builder” patterns.  These cases often have a bunch of configurable state in a class, where almost all of it has default values, but where clients want to be able to only specify deltas from the default.  In the cases where you have a type with a ton of data members, a memberwise init is very very appealing because it eliminates a ton of boilerplate to set up a builder manually, and it also allows the captured state to be immutable (if we allow memberwise init of lets, which Matthew is a huge proponent of).  This case can often be a class derived from something else (e.g. a Kit class), explaining the desire to specify super.init, add custom parameters, etc.<br>&gt; <br>&gt; <br>&gt; #3 is my distillation/abstraction of many of the arguments that Matthew has made on the list and in the proposal (e.g. his very helpful FontPicker example), but I don’t claim that this captures all of his or any one else’s motivation.  This is simply the rationale that the team discussed.<br>&gt; <br>&gt; <br>&gt; --- Common feedback and points ---<br>&gt; <br>&gt; Getting to points common to any “memberwise initializer” proposal, the goals of the core team are:<br>&gt; <br>&gt; - Provide a predictable model.  It was concerning to many people that you could accidentally reorder properties and break a memberwise init without knowing/thinking about it.  This directly contravenes the resilience model.  API diff’ing tools and “synthesized header” views in Xcode ameliorate this, but don’t totally solve it.<br>&gt; <br>&gt; - After discussion, the desire to support memberwise init of let properties was found to be a strong goal.  The entire win of providing a builder-like pattern in an init method (vs doing initialize to default and reassign over the value later, C# style) is the immutability benefits.<br>&gt; <br>&gt; - We would like for memberwise init to be orthogonal to property behaviors, access control, attributes, and all the other stuff you’d want to do on your properties.  Also, ideally, you shouldn’t be limited to what kinds of properties can participate.<br>&gt; <br>&gt; - The issues around whether properties with a default value (both let and var) can be replaced by a memberwise init is a really important semantic decision we need to nail down.  Many of the proposals include the problem/fact that something like:<br>&gt; <br>&gt; class C {<br>&gt;   var x : Int = foo()<br>&gt; <br>&gt;   memberwise init(…) {}<br>&gt; }<br>&gt; <br>&gt; would not run the foo() side effect when initialized with &quot;C(42)”.  Similarly, in a case like:<br>&gt; <br>&gt; class C {<br>&gt;   let x : Int = 42<br>&gt;   memberwise init(…) {}<br>&gt; }<br>&gt; <br>&gt; it is still very concerning to people that the apparent axiom that “x is 42” could be violated by a memberwise init.  Allowing lets have other implementation issues, such as suddenly making “x” require storage, where it could otherwise be optimized out.<br>&gt; <br>&gt; <br>&gt; <br>&gt; OTOH, my previous objection about being able to write a memberwise init manually is bogus, since you could write the above out like this:<br>&gt; <br>&gt; class C {<br>&gt;   let x : Int     // initial value removed.<br>&gt;   init(x: Int) { self.x = x }   // manually written memberwise init.<br>&gt;   init() { x = 42 }  // move the inline initial value here.<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; --- Approaches discussed ---<br>&gt; <br>&gt; Here are the rough approaches we discussed, along with pros and cons.  For consistency, most of them are modeling the analog of sugarizing an example case like this:<br>&gt; <br>&gt; class C : Derived {   // has base class<br>&gt;     var x: Int               // no default value.<br>&gt;     var y = 4.0            // default value<br>&gt;     var z = “foo&quot;          // default value<br>&gt; <br>&gt;      // has an explicit “q” parameter as well as all the members as parameters.<br>&gt;      init(q: Int, x: Int, y: Double = 4.0, z: String = &quot;foo”) {<br>&gt;         self.x = x <br>&gt;         self.y = y<br>&gt;         self.z = z<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I ordered this so that the most promising ones are at the end, to keep you all in suspense :-)<br>&gt; <br>&gt; <br>&gt; Approach: C# model<br>&gt; <br>&gt; As pointed out on the list, we could eliminate the notion of a synthesized memberwise init, and move the complexity to the caller side.  C# uses syntax along the lines of:<br>&gt; <br>&gt; 	new Foo(){x=42, y=17.0}<br>&gt; <br>&gt; pro) No memberwise initializer concept<br>&gt; con) Requires all fields to be default initialized, which breaks non-nullable pointers etc.<br>&gt; con) Requires mutability, since you’re initializing, and then overwriting a field.<br>&gt; con) This specific syntax would be problematic with trailing closures etc.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: Scala (among others) memberwise init as part of class decl<br>&gt; <br>&gt; This would give us something like this:<br>&gt; <br>&gt; class C(var x: Int, y: Float = 4.0, var z : String = “foo&quot;) : Derived {<br>&gt;     var extra = 4.0   // extra, non-memberwise fields supported.<br>&gt;     init(q: Int, ...) {  // all initializers get memberwise stuff added, allows bodies.<br>&gt;        extra = 17<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;      }<br>&gt; }<br>&gt; <br>&gt; pro) Very predictable model, makes it very clear what is subject to memberwise init, and that the order matters<br>&gt; pro) This supports indicating that some fields don’t participate in memberwise init.<br>&gt; pro?) Syntax looks vaguely like the parameter list of the init<br>&gt; con) The syntax isn’t actually parameter list syntax, it is property syntax.  You’d want to accept public/private, let/var, behaviors, attributes, and lots of other stuff in there.  This would introduce confusion about parameter lists.<br>&gt; con) This is sticking more junk into the class decl, which is already populated with class attributes/modifiers, subclasses/protocols, etc.<br>&gt; con) This means we’ve have two very different ways to declare stored properties in a type.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: Extract the members from the parameters of an initializer decl<br>&gt; <br>&gt; This would give us something like this:<br>&gt; <br>&gt; class C : Derived {<br>&gt;     // members come from the memberwise init.<br>&gt;      memberwise init(x: Int, y: Double = 4.0, z: String = &quot;foo”) {<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; pro) Syntactically very terse.<br>&gt; con) This only supports one memberwise init.<br>&gt; con) Two ways to declare stored properties<br>&gt; con) Conflates the property grammar (behaviors etc) with parameter grammar, many of the same problems as approach right above does.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: barely extend our existing model:<br>&gt; <br>&gt; We could put default values onto our existing memberwise init, and allow you to write &quot;memberwise init(...)” to explicitly request it to be synthesized, but not allow a body.  We could bring the existing level of feature to classes.<br>&gt; <br>&gt; pro) simple, solves some problems with the existing model.<br>&gt; pro) brings memberwise init to root classes and classes that derive from something with a init() to chain to (e.g. NSObject).<br>&gt; con) doesn’t solve enough of the problem to be worth it<br>&gt; con) feels like we are perpetuating a hack.<br>&gt; con) we’d have to extend this further at some point, this is just kicking the can down the road.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.  Better to either rip out what we have or do a bigger approach.<br>&gt; <br>&gt; <br>&gt; Approach: Magic “members” tuple (or other generics/variadics features) <br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;     init(p : … Members) {<br>&gt;        self.members = p<br>&gt;     }<br>&gt; <br>&gt;     // compiler synthesizes.<br>&gt;     typealias Members = (Int, Float, String)<br>&gt;     var members : Members { get {..} set {..}}<br>&gt; }<br>&gt; <br>&gt; pro) seems like a more generally useful feature that could pay for itself in other ways<br>&gt; con) doesn’t work with default values, so it doesn’t solve the builder problem at all (and no, we are not adding default values back to tuple types :-)<br>&gt; <br>&gt; Core team was strongly opposed to this as an approach for memberwise init, but can always consider doing this for other things if it is motivated by them.<br>&gt; <br>&gt; <br>&gt; Approach: Introduce sugar for “self.x = x&quot;<br>&gt; <br>&gt; David Owens ][ mentioned that perhaps we can go with something simpler, like this (concrete syntax is just a strawman):<br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;      init(q: Int, self.x, self.y, self.z) { <br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; … where self.x in the parameter list is sugar that says it takes whatever the x property is (incl type and initial value if present), and does &quot;self.x = x” in the body.<br>&gt; <br>&gt; pro) Does not require introducing the notion of a memberwise init.  Any init could use this.<br>&gt; pro) Makes it very clear what members are being initialized and what the API for the init is.<br>&gt; pro) Makes it easy to pick and choose which members you want to make available to clients.<br>&gt; con) This isn’t sweet enough sugar to be worthwhile, particularly for the builder pattern case, which would require lots of boilerplate<br>&gt; con) the self.x syntax is weird and surely can be improved, but anything we came up with would be magic and weird.  Making this keyword driven (e.g. &quot;memberwise” at least gives people something to google and lets them know they’re looking at something magic).<br>&gt; con) doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>&gt; <br>&gt; Core team was weakly opposed to this approach, but agree that something like this could be composed on top of another proposal if that made sense.<br>&gt; <br>&gt; <br>&gt; Approach: Introduce sugar for “self.x = x”, and add “memberwise and …&quot;<br>&gt; <br>&gt; Extending David Owens ][’s model a bit, we could keep the behavior he indicates and add memberwise/… to handle cases with default values:<br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;      memberwise init(q: Int, self.x, ...) { <br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; … where self.x in the parameter list is sugar that says it takes whatever the x property is (incl type and initial value if present), and does &quot;self.x = x” in the body.  The presence of memberwise/… would forward all the properties with default values.<br>&gt; <br>&gt; pro) Since default values can be provided by a callee in any order, this approach can be made stable against reordering of properties.<br>&gt; pro) Compared to the base proposal above, this would be great for the builder pattern case.<br>&gt; con) The POD case still requires you to duplicate all your properties, so this doesn’t really address that use-case.<br>&gt; con) the self.x syntax is weird and surely can be improved, but anything we came up with would be magic and weird.<br>&gt; con) doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>&gt; <br>&gt; Core team was weakly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: Matthew’s proposal SE-0018 (the actual formal proposal :)<br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;      memberwise init(q: Int, ...) {<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; pro) Solves the POD case as well as the builder case.<br>&gt; pro) Keeps properties the way they are, composes with behaviors etc.<br>&gt; pro) Supports adding custom parameters to the initializer, supports custom chaining to super.init, etc.<br>&gt; pro) Supports multiple different memberwise inits in a class, e.g. that want to chain to different super.init’s.<br>&gt; pro) Like the clarity of having a keyword on the init, and a sigil in the parameter list saying that something is going on.<br>&gt; unclear) I’m not delving into it here, but the access control aspects were very controversial.  We didn’t discuss it fully.<br>&gt; con) compared to the Scala approach, doesn’t handle the ability to opt a member out of memberwise init (we’d need some thing like @nomemberwise) <br>&gt; con) Doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>&gt; con) Lots of concerns about unclarity that the order of the properties matter.  In a large type, the memberwise init could be “at the end” of the class, after a bunch of other initializers and methods, and the properties could be “up at the top”.  It could be very unclear to people that memberwise init is even happening, and changing a property could have surprising effects.<br>&gt; con) Not clear from the memberwise init declaration what the extra parameters are, you have to look at a synthesized header or something.<br>&gt; <br>&gt; Core team thought this was very close, but the problems were significant enough to think it won’t fly, and suggest pursuing the variant below.<br>&gt; <br>&gt; <br>&gt; Approach: &quot;Opt-in&quot; version of Matthew’s proposal<br>&gt; <br>&gt; Matthew has mentioned on list that he likes opt-in models, and after discussion the core team agreed that it is more promising than the base proposal.<br>&gt; <br>&gt; In addition to the memberwise declmodifier, *also* introduce a declmodifier on the properties in question.  Here I’ll use “mwi” as a strawman for “memberwise initializerable”, but it is obviously not the right thing, and I’m sure it will be replaced with something else brilliant :-)<br>&gt; <br>&gt; class C : Derived {<br>&gt;     mwi var x: Int<br>&gt;     mwi var y = 4.0<br>&gt;     mwi var z = “foo&quot;<br>&gt;     var extra = 4.0   // Doesn’t participate in memberwise inits.<br>&gt; <br>&gt;      memberwise init(q: Int, ...) {<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; pro) Solves the POD case as well as the builder case.<br>&gt; pro) Keeps properties the way they are, composes with behaviors etc.<br>&gt; pro) Supports adding custom parameters to the initializer, supports custom chaining to super.init, etc.<br>&gt; pro) Supports multiple different memberwise inits in a class, e.g. that want to chain to different super.init’s.<br>&gt; pro) Like the clarity of having a keyword on the init, and a sigil in the parameter list saying that something is going on.<br>&gt; pro) as with the Scala approach it handles the ability to have members be both memberwise and non-memberwise participating.<br>&gt; pro) Works with let and var initializer semantics.<br>&gt; pro) Looking at a property, you know immediately that it participates in memberwise init, and that you should go update the memberwise inits if you move it or change it.  We could warn/error if you have a “mwi” property and no memberwise init, or a memberwise init with no mwi property.<br>&gt; pro) because this is an opt-in model, we can eliminate the controversial access control aspect of SE-0018.<br>&gt; con) Not clear from the memberwise init declaration what the extra parameters are, you have to look at a synthesized header or something.<br>&gt; con) more verbose than Matthew’s proposal.  OTOH, the verbosity isn’t “boilerplate&quot; since we’re getting something out of it. Simple POD cases can be written as (e.g.) “mwi var x, y, z, w : Double” which isn’t bad.<br>&gt; <br>&gt; Adding the modifier on the affected property decls helps improve the intentionality and eliminate some of the &quot;spooky action at a distance&quot; problem, but the major breakthrough (IMO) is that it allows us to include lets into the model, and gives us a simple answer for why side effects are squashed on vars.  Consider this example:<br>&gt; <br>&gt; class C { <br>&gt;   mwi let a = 42<br>&gt;   mwi var b : Int = sideeffect()<br>&gt; <br>&gt;   memberwise init(…) {}<br>&gt; }<br>&gt; <br>&gt; A call site would look like this, giving A a value of 75 and would not run the side effect:<br>&gt;  let tmp = C(a: 75, b: 12)<br>&gt; <br>&gt; We’re ok with the side effect being squashed, and the let axiom being broken given that there is a decl modifier on the property decl.  This is because you can tell locally by looking at the property that a memberwise initializer provides a different value.  From an implementation perspective, this is also pretty great, because this leads to a very straight-forward codegen model that cleanly meshes with what we already have.<br>&gt; <br>&gt; <br>&gt; --- A path forward --- <br>&gt; <br>&gt; So that’s where we left it.  Coming back to the meta point above though, the core team really doesn’t want to discuss this right now, given that this is purely a sugar proposal and we need to stay focused on the primary Swift 3 goals.  If Matthew or another community member wants to pick this up and keep running with it, that is perfectly fine, but we should defer more formal discussion about the proposal until at least march/april-ish.  Likewise, other pure sugar proposals should similarly be deferred at this point, unless they have some strong motivation that aligns with a Swift 3 goal. <br>&gt; <br>&gt; I want to thank Matthew in particular for passionately pushing this area forward!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/28224665/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 14, 2016 at 08:00:00am</p></header><div class="content"><p>I want to thank the core team for putting so much thought and consideration into their feedback.  This was clearly given extensive discussion.  I also want to appologize if it proved to be a distraction from more important goals.<br></p><p>I agree with the recommendation the team has made.  I began to be concerned about the &quot;complexity&quot; of the “automatic&quot; model prior to the start of the review and those concerns proved to be shared by many.  Using an &quot;opt-in&quot; approach will provide much-needed clarity.  I am especially happy to see that the core team has decided that supporting default parameter values for `let` properties is an important aspect of an eventual solution.<br></p><p>There is one thing that isn&#39;t clear to me in the feedback.  Does the core team believe the implicit memberwise initializer should: <br></p><p>1) Remain in its current form<br>2) Remain in a slightly enhanced form (i.e. receive default parameter values)<br>3) Remain in an enhanced form and also be extended to classes<br>4) Be removed in favor of making all initilaizers explicitly declared<br></p><p>As requested, I will defer work on a modified formal proposal until the time is right.  Chris, please let me know when you&#39;re ready to take this topic up again.  I will draft a proposal based on the &quot;opt-in&quot; approach (with no future enhancements!).<br></p><p>In the meantime, anyone who is interested in seeing an outline of possible options for an &quot;opt-in&quot; approach that builds on more general initialization features should keep an eye out for the second (first complete) draft of my Partial Initializers proposal.  At John McCall&#39;s request I am including an a section that describes how partial initializers could be related to memberwise intialization.  I hope to have the draft ready later today.<br></p><p>Thank you again to everyone who participated in the discussion and review of my proposal.  It has been a very productive conversation.   My thinking about the topic has been refined and clarified significantly by this process.<br></p><p>- Matthew<br></p><p><br></p><p>&gt; On Jan 13, 2016, at 1:24 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 6, 2016, at 2:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br>&gt; <br>&gt; Here are some long and poorly organized notes from the core team meeting to discuss this feature.  Many, many, thanks to Alex Martini for capturing many of these details, but the mess I’ve made of this is not his fault. :-)<br>&gt; <br>&gt; <br>&gt; --- Metapoints --- <br>&gt; <br>&gt; First, some meta points that came up from several members of the core team:<br>&gt; <br>&gt; - Less is more.  Many folks (core team and other community members both) commented that the mere presence of the expansive “future directions” section made the proposal off-putting.<br>&gt; <br>&gt; - “Pure sugar” proposals need to have strong justification for their existence since they do not add new capabilities, but they do add new complexity to the language.<br>&gt; <br>&gt; - This feature included justification based on the fact that the existing memberwise feature has problems, but some core team folks thought that this wasn’t good enough justification.  They commented that perhaps we should just remove the existing memberwise init for structs and call it a day.  (others strongly disagreed :-)<br>&gt; <br>&gt; - The team wanted to evaluate “all” of the conceivable different approaches to make sure that this approach was the right one in general.  I captured notes about some of that discussion below.  On the balance, they agree that a variant of this proposal is the right way to go.<br>&gt; <br>&gt; - We didn’t have time to bikeshed the fine details of the proposal (e.g. the “memberwise” keyword, the … sigil, etc), just discussing the general semantics and shape of what an acceptable solution would look like.<br>&gt; <br>&gt; <br>&gt; MOST SIGNIFICANTLY: there was strong pushback about considering this proposal *at all* right now: this is a pure sugar proposal with a broad design space.  It doesn’t have long term ABI implications at all, and we have other serious semantic problems in the language to clean up and address.  We can tackle this sort of sugar feature at any time, including in Swift 4.  The core team would like to defer talking about this for a couple of months until the other things (property behaviors, resilience, and other big changes) are behind us.  We need to focus on the important things, because getting syntactic niceties into Swift 3 but missing on ABI stability would be really unfortunate.  We have seriously constrained design and engineering bandwidth.  This feedback applies to other pure-sugar proposals as well.<br>&gt; <br>&gt; <br>&gt; --- Rationale --- <br>&gt; <br>&gt; I explained three bits of rationale for why we should tackle this:<br>&gt; <br>&gt; 1) Our existing feature is half-baked and unsatisfying.  This causes me personal angst but, as pointed out above, the simplest solution is to just remove what we have until we can do it right.<br>&gt; <br>&gt; 2) Memberwise init sugar strongly benefits “POD” types and other “bags of property” types (e.g. “Vec4&quot;), and many of the C struct types that Cocoa has (CGRect etc).  In these cases, clients often want to initialize all of the fields explicitly and a memberwise init proposal eliminates this boilerplate.  This case is what our existing feature attempts to service.<br>&gt; <br>&gt; 3) Memberwise init sugar can replace some really common “builder” patterns.  These cases often have a bunch of configurable state in a class, where almost all of it has default values, but where clients want to be able to only specify deltas from the default.  In the cases where you have a type with a ton of data members, a memberwise init is very very appealing because it eliminates a ton of boilerplate to set up a builder manually, and it also allows the captured state to be immutable (if we allow memberwise init of lets, which Matthew is a huge proponent of).  This case can often be a class derived from something else (e.g. a Kit class), explaining the desire to specify super.init, add custom parameters, etc.<br>&gt; <br>&gt; <br>&gt; #3 is my distillation/abstraction of many of the arguments that Matthew has made on the list and in the proposal (e.g. his very helpful FontPicker example), but I don’t claim that this captures all of his or any one else’s motivation.  This is simply the rationale that the team discussed.<br>&gt; <br>&gt; <br>&gt; --- Common feedback and points ---<br>&gt; <br>&gt; Getting to points common to any “memberwise initializer” proposal, the goals of the core team are:<br>&gt; <br>&gt; - Provide a predictable model.  It was concerning to many people that you could accidentally reorder properties and break a memberwise init without knowing/thinking about it.  This directly contravenes the resilience model.  API diff’ing tools and “synthesized header” views in Xcode ameliorate this, but don’t totally solve it.<br>&gt; <br>&gt; - After discussion, the desire to support memberwise init of let properties was found to be a strong goal.  The entire win of providing a builder-like pattern in an init method (vs doing initialize to default and reassign over the value later, C# style) is the immutability benefits.<br>&gt; <br>&gt; - We would like for memberwise init to be orthogonal to property behaviors, access control, attributes, and all the other stuff you’d want to do on your properties.  Also, ideally, you shouldn’t be limited to what kinds of properties can participate.<br>&gt; <br>&gt; - The issues around whether properties with a default value (both let and var) can be replaced by a memberwise init is a really important semantic decision we need to nail down.  Many of the proposals include the problem/fact that something like:<br>&gt; <br>&gt; class C {<br>&gt;   var x : Int = foo()<br>&gt; <br>&gt;   memberwise init(…) {}<br>&gt; }<br>&gt; <br>&gt; would not run the foo() side effect when initialized with &quot;C(42)”.  Similarly, in a case like:<br>&gt; <br>&gt; class C {<br>&gt;   let x : Int = 42<br>&gt;   memberwise init(…) {}<br>&gt; }<br>&gt; <br>&gt; it is still very concerning to people that the apparent axiom that “x is 42” could be violated by a memberwise init.  Allowing lets have other implementation issues, such as suddenly making “x” require storage, where it could otherwise be optimized out.<br>&gt; <br>&gt; <br>&gt; <br>&gt; OTOH, my previous objection about being able to write a memberwise init manually is bogus, since you could write the above out like this:<br>&gt; <br>&gt; class C {<br>&gt;   let x : Int     // initial value removed.<br>&gt;   init(x: Int) { self.x = x }   // manually written memberwise init.<br>&gt;   init() { x = 42 }  // move the inline initial value here.<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; --- Approaches discussed ---<br>&gt; <br>&gt; Here are the rough approaches we discussed, along with pros and cons.  For consistency, most of them are modeling the analog of sugarizing an example case like this:<br>&gt; <br>&gt; class C : Derived {   // has base class<br>&gt;     var x: Int               // no default value.<br>&gt;     var y = 4.0            // default value<br>&gt;     var z = “foo&quot;          // default value<br>&gt; <br>&gt;      // has an explicit “q” parameter as well as all the members as parameters.<br>&gt;      init(q: Int, x: Int, y: Double = 4.0, z: String = &quot;foo”) {<br>&gt;         self.x = x <br>&gt;         self.y = y<br>&gt;         self.z = z<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I ordered this so that the most promising ones are at the end, to keep you all in suspense :-)<br>&gt; <br>&gt; <br>&gt; Approach: C# model<br>&gt; <br>&gt; As pointed out on the list, we could eliminate the notion of a synthesized memberwise init, and move the complexity to the caller side.  C# uses syntax along the lines of:<br>&gt; <br>&gt; 	new Foo(){x=42, y=17.0}<br>&gt; <br>&gt; pro) No memberwise initializer concept<br>&gt; con) Requires all fields to be default initialized, which breaks non-nullable pointers etc.<br>&gt; con) Requires mutability, since you’re initializing, and then overwriting a field.<br>&gt; con) This specific syntax would be problematic with trailing closures etc.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: Scala (among others) memberwise init as part of class decl<br>&gt; <br>&gt; This would give us something like this:<br>&gt; <br>&gt; class C(var x: Int, y: Float = 4.0, var z : String = “foo&quot;) : Derived {<br>&gt;     var extra = 4.0   // extra, non-memberwise fields supported.<br>&gt;     init(q: Int, ...) {  // all initializers get memberwise stuff added, allows bodies.<br>&gt;        extra = 17<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;      }<br>&gt; }<br>&gt; <br>&gt; pro) Very predictable model, makes it very clear what is subject to memberwise init, and that the order matters<br>&gt; pro) This supports indicating that some fields don’t participate in memberwise init.<br>&gt; pro?) Syntax looks vaguely like the parameter list of the init<br>&gt; con) The syntax isn’t actually parameter list syntax, it is property syntax.  You’d want to accept public/private, let/var, behaviors, attributes, and lots of other stuff in there.  This would introduce confusion about parameter lists.<br>&gt; con) This is sticking more junk into the class decl, which is already populated with class attributes/modifiers, subclasses/protocols, etc.<br>&gt; con) This means we’ve have two very different ways to declare stored properties in a type.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: Extract the members from the parameters of an initializer decl<br>&gt; <br>&gt; This would give us something like this:<br>&gt; <br>&gt; class C : Derived {<br>&gt;     // members come from the memberwise init.<br>&gt;      memberwise init(x: Int, y: Double = 4.0, z: String = &quot;foo”) {<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; pro) Syntactically very terse.<br>&gt; con) This only supports one memberwise init.<br>&gt; con) Two ways to declare stored properties<br>&gt; con) Conflates the property grammar (behaviors etc) with parameter grammar, many of the same problems as approach right above does.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: barely extend our existing model:<br>&gt; <br>&gt; We could put default values onto our existing memberwise init, and allow you to write &quot;memberwise init(...)” to explicitly request it to be synthesized, but not allow a body.  We could bring the existing level of feature to classes.<br>&gt; <br>&gt; pro) simple, solves some problems with the existing model.<br>&gt; pro) brings memberwise init to root classes and classes that derive from something with a init() to chain to (e.g. NSObject).<br>&gt; con) doesn’t solve enough of the problem to be worth it<br>&gt; con) feels like we are perpetuating a hack.<br>&gt; con) we’d have to extend this further at some point, this is just kicking the can down the road.<br>&gt; <br>&gt; Core team was strongly opposed to this approach.  Better to either rip out what we have or do a bigger approach.<br>&gt; <br>&gt; <br>&gt; Approach: Magic “members” tuple (or other generics/variadics features) <br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;     init(p : … Members) {<br>&gt;        self.members = p<br>&gt;     }<br>&gt; <br>&gt;     // compiler synthesizes.<br>&gt;     typealias Members = (Int, Float, String)<br>&gt;     var members : Members { get {..} set {..}}<br>&gt; }<br>&gt; <br>&gt; pro) seems like a more generally useful feature that could pay for itself in other ways<br>&gt; con) doesn’t work with default values, so it doesn’t solve the builder problem at all (and no, we are not adding default values back to tuple types :-)<br>&gt; <br>&gt; Core team was strongly opposed to this as an approach for memberwise init, but can always consider doing this for other things if it is motivated by them.<br>&gt; <br>&gt; <br>&gt; Approach: Introduce sugar for “self.x = x&quot;<br>&gt; <br>&gt; David Owens ][ mentioned that perhaps we can go with something simpler, like this (concrete syntax is just a strawman):<br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;      init(q: Int, self.x, self.y, self.z) { <br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; … where self.x in the parameter list is sugar that says it takes whatever the x property is (incl type and initial value if present), and does &quot;self.x = x” in the body.<br>&gt; <br>&gt; pro) Does not require introducing the notion of a memberwise init.  Any init could use this.<br>&gt; pro) Makes it very clear what members are being initialized and what the API for the init is.<br>&gt; pro) Makes it easy to pick and choose which members you want to make available to clients.<br>&gt; con) This isn’t sweet enough sugar to be worthwhile, particularly for the builder pattern case, which would require lots of boilerplate<br>&gt; con) the self.x syntax is weird and surely can be improved, but anything we came up with would be magic and weird.  Making this keyword driven (e.g. &quot;memberwise” at least gives people something to google and lets them know they’re looking at something magic).<br>&gt; con) doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>&gt; <br>&gt; Core team was weakly opposed to this approach, but agree that something like this could be composed on top of another proposal if that made sense.<br>&gt; <br>&gt; <br>&gt; Approach: Introduce sugar for “self.x = x”, and add “memberwise and …&quot;<br>&gt; <br>&gt; Extending David Owens ][’s model a bit, we could keep the behavior he indicates and add memberwise/… to handle cases with default values:<br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;      memberwise init(q: Int, self.x, ...) { <br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; … where self.x in the parameter list is sugar that says it takes whatever the x property is (incl type and initial value if present), and does &quot;self.x = x” in the body.  The presence of memberwise/… would forward all the properties with default values.<br>&gt; <br>&gt; pro) Since default values can be provided by a callee in any order, this approach can be made stable against reordering of properties.<br>&gt; pro) Compared to the base proposal above, this would be great for the builder pattern case.<br>&gt; con) The POD case still requires you to duplicate all your properties, so this doesn’t really address that use-case.<br>&gt; con) the self.x syntax is weird and surely can be improved, but anything we came up with would be magic and weird.<br>&gt; con) doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>&gt; <br>&gt; Core team was weakly opposed to this approach.<br>&gt; <br>&gt; <br>&gt; Approach: Matthew’s proposal SE-0018 (the actual formal proposal :)<br>&gt; <br>&gt; class C : Derived {<br>&gt;     var x: Int<br>&gt;     var y = 4.0<br>&gt;     var z = “foo&quot;<br>&gt; <br>&gt;      memberwise init(q: Int, ...) {<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; pro) Solves the POD case as well as the builder case.<br>&gt; pro) Keeps properties the way they are, composes with behaviors etc.<br>&gt; pro) Supports adding custom parameters to the initializer, supports custom chaining to super.init, etc.<br>&gt; pro) Supports multiple different memberwise inits in a class, e.g. that want to chain to different super.init’s.<br>&gt; pro) Like the clarity of having a keyword on the init, and a sigil in the parameter list saying that something is going on.<br>&gt; unclear) I’m not delving into it here, but the access control aspects were very controversial.  We didn’t discuss it fully.<br>&gt; con) compared to the Scala approach, doesn’t handle the ability to opt a member out of memberwise init (we’d need some thing like @nomemberwise) <br>&gt; con) Doesn’t address the problems of replacing the var/let initial values (zapping a side effect in either of them, and breaking ‘let’ axioms).<br>&gt; con) Lots of concerns about unclarity that the order of the properties matter.  In a large type, the memberwise init could be “at the end” of the class, after a bunch of other initializers and methods, and the properties could be “up at the top”.  It could be very unclear to people that memberwise init is even happening, and changing a property could have surprising effects.<br>&gt; con) Not clear from the memberwise init declaration what the extra parameters are, you have to look at a synthesized header or something.<br>&gt; <br>&gt; Core team thought this was very close, but the problems were significant enough to think it won’t fly, and suggest pursuing the variant below.<br>&gt; <br>&gt; <br>&gt; Approach: &quot;Opt-in&quot; version of Matthew’s proposal<br>&gt; <br>&gt; Matthew has mentioned on list that he likes opt-in models, and after discussion the core team agreed that it is more promising than the base proposal.<br>&gt; <br>&gt; In addition to the memberwise declmodifier, *also* introduce a declmodifier on the properties in question.  Here I’ll use “mwi” as a strawman for “memberwise initializerable”, but it is obviously not the right thing, and I’m sure it will be replaced with something else brilliant :-)<br>&gt; <br>&gt; class C : Derived {<br>&gt;     mwi var x: Int<br>&gt;     mwi var y = 4.0<br>&gt;     mwi var z = “foo&quot;<br>&gt;     var extra = 4.0   // Doesn’t participate in memberwise inits.<br>&gt; <br>&gt;      memberwise init(q: Int, ...) {<br>&gt;         // your custom code can go here<br>&gt;         super.init(q)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; pro) Solves the POD case as well as the builder case.<br>&gt; pro) Keeps properties the way they are, composes with behaviors etc.<br>&gt; pro) Supports adding custom parameters to the initializer, supports custom chaining to super.init, etc.<br>&gt; pro) Supports multiple different memberwise inits in a class, e.g. that want to chain to different super.init’s.<br>&gt; pro) Like the clarity of having a keyword on the init, and a sigil in the parameter list saying that something is going on.<br>&gt; pro) as with the Scala approach it handles the ability to have members be both memberwise and non-memberwise participating.<br>&gt; pro) Works with let and var initializer semantics.<br>&gt; pro) Looking at a property, you know immediately that it participates in memberwise init, and that you should go update the memberwise inits if you move it or change it.  We could warn/error if you have a “mwi” property and no memberwise init, or a memberwise init with no mwi property.<br>&gt; pro) because this is an opt-in model, we can eliminate the controversial access control aspect of SE-0018.<br>&gt; con) Not clear from the memberwise init declaration what the extra parameters are, you have to look at a synthesized header or something.<br>&gt; con) more verbose than Matthew’s proposal.  OTOH, the verbosity isn’t “boilerplate&quot; since we’re getting something out of it. Simple POD cases can be written as (e.g.) “mwi var x, y, z, w : Double” which isn’t bad.<br>&gt; <br>&gt; Adding the modifier on the affected property decls helps improve the intentionality and eliminate some of the &quot;spooky action at a distance&quot; problem, but the major breakthrough (IMO) is that it allows us to include lets into the model, and gives us a simple answer for why side effects are squashed on vars.  Consider this example:<br>&gt; <br>&gt; class C { <br>&gt;   mwi let a = 42<br>&gt;   mwi var b : Int = sideeffect()<br>&gt; <br>&gt;   memberwise init(…) {}<br>&gt; }<br>&gt; <br>&gt; A call site would look like this, giving A a value of 75 and would not run the side effect:<br>&gt;  let tmp = C(a: 75, b: 12)<br>&gt; <br>&gt; We’re ok with the side effect being squashed, and the let axiom being broken given that there is a decl modifier on the property decl.  This is because you can tell locally by looking at the property that a memberwise initializer provides a different value.  From an implementation perspective, this is also pretty great, because this leads to a very straight-forward codegen model that cleanly meshes with what we already have.<br>&gt; <br>&gt; <br>&gt; --- A path forward --- <br>&gt; <br>&gt; So that’s where we left it.  Coming back to the meta point above though, the core team really doesn’t want to discuss this right now, given that this is purely a sugar proposal and we need to stay focused on the primary Swift 3 goals.  If Matthew or another community member wants to pick this up and keep running with it, that is perfectly fine, but we should defer more formal discussion about the proposal until at least march/april-ish.  Likewise, other pure sugar proposals should similarly be deferred at this point, unless they have some strong motivation that aligns with a Swift 3 goal. <br>&gt; <br>&gt; I want to thank Matthew in particular for passionately pushing this area forward!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/2943fdd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 6:35 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I want to thank the core team for putting so much thought and consideration into their feedback.  This was clearly given extensive discussion.  I also want to appologize if it proved to be a distraction from more important goals.<br></p><p>No need to apologize at all, I was the one getting scolded here, not you :-)<br></p><p>&gt; I agree with the recommendation the team has made.  I began to be concerned about the &quot;complexity&quot; of the “automatic&quot; model prior to the start of the review and those concerns proved to be shared by many.  Using an &quot;opt-in&quot; approach will provide much-needed clarity.  I am especially happy to see that the core team has decided that supporting default parameter values for `let` properties is an important aspect of an eventual solution.<br>&gt; <br>&gt; There is one thing that isn&#39;t clear to me in the feedback.  Does the core team believe the implicit memberwise initializer should: <br>&gt; <br>&gt; 1) Remain in its current form<br>&gt; 2) Remain in a slightly enhanced form (i.e. receive default parameter values)<br>&gt; 3) Remain in an enhanced form and also be extended to classes<br>&gt; 4) Be removed in favor of making all initilaizers explicitly declared<br></p><p>The core team as a whole didn’t discuss this, but the design that I think makes sense is:<br></p><p>- Extend the current support to root classes and derived classes whose base has a zero-argument init to chain to (e.g. NSObject).<br>- *Consider* extending the current support to have default values on the parameters.  This will be contentious with the core team given the discussion about killing side effects and changing let axioms, etc.<br></p><p>That said, when it comes time to discuss this, I’d suggest just looking at both options and enumerating tradeoffs.<br></p><p>&gt; As requested, I will defer work on a modified formal proposal until the time is right.  Chris, please let me know when you&#39;re ready to take this topic up again.  I will draft a proposal based on the &quot;opt-in&quot; approach (with no future enhancements!).<br></p><p>Sounds great, please feel free to ping the list in the mid to late march timeframe, when hopefully we’ll have most of the big ticket items for swift 3 at least figured out, if not all finished.<br></p><p>&gt; In the meantime, anyone who is interested in seeing an outline of possible options for an &quot;opt-in&quot; approach that builds on more general initialization features should keep an eye out for the second (first complete) draft of my Partial Initializers proposal.  At John McCall&#39;s request I am including an a section that describes how partial initializers could be related to memberwise intialization.  I hope to have the draft ready later today.<br>&gt; <br>&gt; Thank you again to everyone who participated in the discussion and review of my proposal.  It has been a very productive conversation.   My thinking about the topic has been refined and clarified significantly by this process.<br></p><p>Thank you again for driving this Matthew, I still really want to see this area improved and cleaned up.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
