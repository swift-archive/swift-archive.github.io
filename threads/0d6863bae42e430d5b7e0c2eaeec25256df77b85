<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>[Proposal]Allow constraints on associatedtype and shorten type constraints list in function</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 29, 2016 at 10:00:00am</p></header><div class="content"><p>Hello swift community,<br></p><p>I want to introduce a proposal to allow constraints on associatedtype.<br>I found a bug report(https://bugs.swift.org/browse/SR-1466) and it&#39;s due to<br>without constraints on associatedtype itself.<br></p><p>This force us always have to write the redundant constraints like<br>Indices.Iterator.Element<br>== Index or Indices.SubSequence.Iterator.Element == Index on type<br>constraints in function:<br></p><p><br>public extension MutableCollection where Self : RandomAccessCollection,<br>Indices.Index == Index, Indices.SubSequence : RandomAccessCollection,<br>Indices.SubSequence.Iterator.Element == Index {<br></p><p><br></p><p>    /// Shuffle `self` in-place.<br></p><p>    mutating func shuffle() {<br></p><p>        for i in self.indices.dropLast() {<br></p><p>            let j = self.indices.suffix(from: i).random()!<br></p><p>            if i != j {<br></p><p>                swap(&amp;self[i], &amp;self[j])<br></p><p>            }<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p>Besides this, we also can write some odd definitions but allowed by swift<br>compiler.<br></p><p><br>struct MyArray : Collection {<br></p><p><br></p><p>    typealias Indices = CountableRange&lt;Int32&gt;<br></p><p><br></p><p>    var base: [Int]<br></p><p><br></p><p>    var startIndex: Int {<br></p><p>        return base.startIndex<br></p><p>    }<br></p><p>    var endIndex: Int {<br></p><p>        return base.endIndex<br></p><p>    }<br></p><p><br>    func index(after: Int) -&gt; Int {<br></p><p>        return after + 1<br></p><p>    }<br></p><p><br></p><p>    var indices: CountableRange&lt;Int32&gt; {<br></p><p>        return CountableRange(uncheckedBounds: (lower: Int32(startIndex),<br>upper: Int32(endIndex)))<br></p><p>    }<br></p><p><br></p><p>    subscript(position: Int) -&gt; Int {<br></p><p>        get {<br></p><p>            return base[position]<br></p><p>        }<br></p><p>        set {<br></p><p>            base[position] = newValue<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br>as a reference:<br>http://stackoverflow.com/questions/37581234/can-an-associated-type-be-restricted-by-protocol-conformance-and-a-where-clause<br></p><p><br>it&#39;s clearly that we need a syntax like this:<br></p><p><br>public protocol Collection : Indexable, Sequence {<br></p><p><br></p><p>    /// A sequence that represents a contiguous subrange of the collection&#39;s<br></p><p>    /// elements.<br></p><p>    ///<br></p><p>    /// This associated type appears as a requirement in the `Sequence`<br></p><p>    /// protocol, but it is restated here with stricter constraints. In a<br></p><p>    /// collection, the subsequence should also conform to `Collection`.<br></p><p>    associatedtype SubSequence : IndexableBase, Sequence where<br>SubSequence.Iterator.Element == Iterator.Element = Slice&lt;Self&gt;<br></p><p><br></p><p>    /// A type that can represent the indices that are valid for<br>subscripting the<br></p><p>    /// collection, in ascending order.<br></p><p>    associatedtype Indices : IndexableBase, Sequence where<br>Indices.Iterator.Element == Index = DefaultIndices&lt;Self&gt;<br></p><p><br>}<br></p><p><br>This  harmless and brings huge benefits to swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160729/0d687b85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Proposal]Allow constraints on associatedtype and shorten type constraints list in function</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>July 29, 2016 at 06:00:00pm</p></header><div class="content"><p>It is one of the items in the Generics Manifesto, and we had a discussion thread with a proposal on this already, however halted for being an addictive feature. Anyway, aren&#39;t discussions on post Swift 3 matters preferred to start on Aug 1?<br></p><p><br></p><p>Hart&#39;s proposal<br>https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br></p><p>[swift-evolution] [Proposal] More Powerful Constraints for Associated Types<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016354.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016354.html&gt;<br></p><p><br></p><p>Regards,<br>Anders<br></p><p><br>&gt; On 29 Jul 2016, at 10:17 AM, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift community,<br>&gt; <br>&gt; I want to introduce a proposal to allow constraints on associatedtype. <br>&gt; I found a bug report(https://bugs.swift.org/browse/SR-1466 &lt;https://bugs.swift.org/browse/SR-1466&gt;) and it&#39;s due to without constraints on associatedtype itself.<br>&gt; <br>&gt; This force us always have to write the redundant constraints like Indices.Iterator.Element == Index or Indices.SubSequence.Iterator.Element == Index on type constraints in function:<br>&gt; <br>&gt; public extension MutableCollection where Self : RandomAccessCollection, Indices.Index == Index, Indices.SubSequence : RandomAccessCollection, Indices.SubSequence.Iterator.Element == Index {<br>&gt;     <br>&gt;     /// Shuffle `self` in-place.<br>&gt;     mutating func shuffle() {<br>&gt;         for i in self.indices.dropLast() {<br>&gt;             let j = self.indices.suffix(from: i).random()!<br>&gt;             if i != j {<br>&gt;                 swap(&amp;self[i], &amp;self[j])<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Besides this, we also can write some odd definitions but allowed by swift compiler.<br>&gt; <br>&gt; struct MyArray : Collection {<br>&gt;     <br>&gt;     typealias Indices = CountableRange&lt;Int32&gt;<br>&gt;     <br>&gt;     var base: [Int]<br>&gt;     <br>&gt;     var startIndex: Int {<br>&gt;         return base.startIndex<br>&gt;     }<br>&gt;     var endIndex: Int {<br>&gt;         return base.endIndex<br>&gt;     }<br>&gt; <br>&gt;     func index(after: Int) -&gt; Int {<br>&gt;         return after + 1<br>&gt;     }<br>&gt;     <br>&gt;     var indices: CountableRange&lt;Int32&gt; {<br>&gt;         return CountableRange(uncheckedBounds: (lower: Int32(startIndex), upper: Int32(endIndex)))<br>&gt;     }<br>&gt;     <br>&gt;     subscript(position: Int) -&gt; Int {<br>&gt;         get {<br>&gt;             return base[position]<br>&gt;         }<br>&gt;         set {<br>&gt;             base[position] = newValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; as a reference: http://stackoverflow.com/questions/37581234/can-an-associated-type-be-restricted-by-protocol-conformance-and-a-where-clause &lt;http://stackoverflow.com/questions/37581234/can-an-associated-type-be-restricted-by-protocol-conformance-and-a-where-clause&gt;<br>&gt; <br>&gt; it&#39;s clearly that we need a syntax like this:<br>&gt; <br>&gt; public protocol Collection : Indexable, Sequence {<br>&gt;     <br>&gt;     /// A sequence that represents a contiguous subrange of the collection&#39;s<br>&gt;     /// elements.<br>&gt;     ///<br>&gt;     /// This associated type appears as a requirement in the `Sequence`<br>&gt;     /// protocol, but it is restated here with stricter constraints. In a<br>&gt;     /// collection, the subsequence should also conform to `Collection`.<br>&gt;     associatedtype SubSequence : IndexableBase, Sequence where SubSequence.Iterator.Element == Iterator.Element = Slice&lt;Self&gt;<br>&gt;     <br>&gt;     /// A type that can represent the indices that are valid for subscripting the<br>&gt;     /// collection, in ascending order.<br>&gt;     associatedtype Indices : IndexableBase, Sequence where Indices.Iterator.Element == Index = DefaultIndices&lt;Self&gt;<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This  harmless and brings huge benefits to swift.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160729/51790df7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>[Proposal]Allow constraints on associatedtype and shorten type constraints list in function</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 29, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks.<br></p><p>I found this proposal in pull requests after the email sent.<br></p><p>Anders Ha &lt;hello at andersio.co&gt; 於 2016年7月29日星期五 寫道：<br></p><p>&gt; It is one of the items in the Generics Manifesto, and we had a discussion<br>&gt; thread with a proposal on this already, however halted for being an<br>&gt; addictive feature. Anyway, aren&#39;t discussions on post Swift 3 matters<br>&gt; preferred to start on Aug 1?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Hart&#39;s proposal<br>&gt;<br>&gt; https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md<br>&gt;<br>&gt; [swift-evolution] [Proposal] More Powerful Constraints for Associated Types<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016354.html<br>&gt;<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt; Anders<br>&gt;<br>&gt;<br>&gt; On 29 Jul 2016, at 10:17 AM, Susan Cheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Hello swift community,<br>&gt;<br>&gt; I want to introduce a proposal to allow constraints on associatedtype.<br>&gt; I found a bug report(https://bugs.swift.org/browse/SR-1466) and it&#39;s due<br>&gt; to without constraints on associatedtype itself.<br>&gt;<br>&gt; This force us always have to write the redundant constraints like Indices.Iterator.Element<br>&gt; == Index or Indices.SubSequence.Iterator.Element == Index on type<br>&gt; constraints in function:<br>&gt;<br>&gt; public extension MutableCollection where Self : RandomAccessCollection,<br>&gt; Indices.Index == Index, Indices.SubSequence : RandomAccessCollection,<br>&gt; Indices.SubSequence.Iterator.Element == Index {<br>&gt;<br>&gt;<br>&gt;     /// Shuffle `self` in-place.<br>&gt;     mutating func shuffle() {<br>&gt;         for i in self.indices.dropLast() {<br>&gt;             let j = self.indices.suffix(from: i).random()!<br>&gt;             if i != j {<br>&gt;                 swap(&amp;self[i], &amp;self[j])<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Besides this, we also can write some odd definitions but allowed by swift<br>&gt; compiler.<br>&gt;<br>&gt; struct MyArray : Collection {<br>&gt;<br>&gt;<br>&gt;     typealias Indices = CountableRange&lt;Int32&gt;<br>&gt;<br>&gt;<br>&gt;     var base: [Int]<br>&gt;<br>&gt;<br>&gt;     var startIndex: Int {<br>&gt;         return base.startIndex<br>&gt;     }<br>&gt;     var endIndex: Int {<br>&gt;         return base.endIndex<br>&gt;     }<br>&gt;<br>&gt;     func index(after: Int) -&gt; Int {<br>&gt;         return after + 1<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     var indices: CountableRange&lt;Int32&gt; {<br>&gt;         return CountableRange(uncheckedBounds: (lower: Int32(startIndex),<br>&gt; upper: Int32(endIndex)))<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     subscript(position: Int) -&gt; Int {<br>&gt;         get {<br>&gt;             return base[position]<br>&gt;         }<br>&gt;         set {<br>&gt;             base[position] = newValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; as a reference:<br>&gt; http://stackoverflow.com/questions/37581234/can-an-associated-type-be-restricted-by-protocol-conformance-and-a-where-clause<br>&gt;<br>&gt; it&#39;s clearly that we need a syntax like this:<br>&gt;<br>&gt; public protocol Collection : Indexable, Sequence {<br>&gt;<br>&gt;<br>&gt;     /// A sequence that represents a contiguous subrange of the<br>&gt; collection&#39;s<br>&gt;     /// elements.<br>&gt;     ///<br>&gt;     /// This associated type appears as a requirement in the `Sequence`<br>&gt;     /// protocol, but it is restated here with stricter constraints. In a<br>&gt;     /// collection, the subsequence should also conform to `Collection`.<br>&gt;     associatedtype SubSequence : IndexableBase, Sequence where<br>&gt; SubSequence.Iterator.Element == Iterator.Element = Slice&lt;Self&gt;<br>&gt;<br>&gt;<br>&gt;     /// A type that can represent the indices that are valid for<br>&gt; subscripting the<br>&gt;     /// collection, in ascending order.<br>&gt;     associatedtype Indices : IndexableBase, Sequence where<br>&gt; Indices.Iterator.Element == Index = DefaultIndices&lt;Self&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; This  harmless and brings huge benefits to swift.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160729/c6bbb0a4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
