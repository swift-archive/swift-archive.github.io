<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/08045ad84066382b7a4d173e89302627?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Kevin Schlei</string> &lt;kevinschlei at gmail.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I am strongly against the proposed changes to the translation of<br>Objective-C APIs. I think the changes promote terseness for terseness sake,<br>lose vital context in method names, and are a huge loss pedagogically.<br></p><p>If you teach programming, you&#39;ll know why this line will be a nightmare:<br></p><p>let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/31dbcbb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/08045ad84066382b7a4d173e89302627?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Kevin Schlei</string> &lt;kevinschlei at gmail.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Sorry for the premature send! Continuing:<br></p><p>let content = listItemView.text.trimming(.whitespaceAndNewlines)<br></p><p>For a beginning programmer, there is no indication of what .trimming does.<br>In this case, it returns a new string instance. Where is that explained? In<br>the documentation. Nowhere near the method call.<br></p><p>So are we reduced now to looking up documentation just to read code? What<br>does this line do:<br></p><p>let next = current.updating(p)<br></p><p>It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all<br>the hints. But this line:<br></p><p>let next = current.locationByUpdatingProximity(p)<br></p><p>Lets you know that:<br></p><p>1. we&#39;re returning a *&#39;location&#39;*<br>2. &#39;*by* *updating&#39; *current with a new *&#39;proximity&#39;*<br></p><p>When is the last time you saw a gerund (-ing) as a method name? I wouldn&#39;t<br>let my students write that. Gerunds make good boolean properties. How would<br>you even read the first line above out loud? Probably by filling in the<br>words in the second line, magically.<br></p><p>My second major issue is that autocomplete grouping is totally lost when<br>dropping the type returned at the beginning of the call. How many of us<br>learned a *ton* when we just autocompleted .stringBy? Look at all the<br>things you can do! But by removing the &#39;useless word&#39; (really don&#39;t like<br>that flag name) we have no grouping of constructor methods.<br></p><p>I see a lot of discussion on how to deal with &#39;with&#39; and &#39;by&#39; and other<br>words, but I want to strongly suggest that the current naming practices<br>provide context and clarity. It makes code readable and accessible. Don&#39;t<br>forget about when you didn&#39;t know how to code! These method names are<br>teaching tools!<br></p><p>Finally, I just want to ask: why? What is the great benefit? Shouldn&#39;t<br>clarity be prioritized over brevity (where have I seen that...)<br></p><p>I can&#39;t put it better than another forums poster:<br></p><p>Does the Swift team seriously believe that systematically parsing and<br>&gt; extensively munging patterns in not-quite-natural-language is tractable to<br>&gt; support all the corner cases for? And that, even if it were, that it could<br>&gt; avoid confusion in less-than-perfect codebases? The idea that this will<br>&gt; somehow benefit a language, particularly one in which clear and obvious<br>&gt; bridging is so vital is *insane*. The best it can do is a reasonable job,<br>&gt; with some amount of either unfixable brokenness forced upon developers in<br>&gt; perpetuity, or constant churn stemming from perpetual fixing of brokenness.<br>&gt; Swift&#39;s translation is currently simple to reason about, and the language<br>&gt; as a whole has got a really great thing going on. I&#39;m really happy with<br>&gt; where it is at this moment. Why ruin it by boneheadedly detonating the<br>&gt; utility of two years of progress in literature and the library of online<br>&gt; information about Swift? Seriously, why?<br>&gt;<br></p><p><br></p><p>On Tue, Feb 2, 2016 at 1:04 PM, Kevin Schlei &lt;kevinschlei at gmail.com&gt; wrote:<br></p><p>&gt; I am strongly against the proposed changes to the translation of<br>&gt; Objective-C APIs. I think the changes promote terseness for terseness sake,<br>&gt; lose vital context in method names, and are a huge loss pedagogically.<br>&gt;<br>&gt; If you teach programming, you&#39;ll know why this line will be a nightmare:<br>&gt;<br>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/4c901b44/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:16, Kevin Schlei via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for the premature send! Continuing:<br>&gt; <br>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt; <br>&gt; For a beginning programmer, there is no indication of what .trimming does. In this case, it returns a new string instance. Where is that explained? In the documentation. Nowhere near the method call.<br>&gt; <br>&gt; So are we reduced now to looking up documentation just to read code? What does this line do:<br>&gt; <br>&gt; let next = current.updating(p)<br>&gt; <br>&gt; It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all the hints. But this line:<br></p><p>I think it&#39;s only unclear because p is not a descriptive name (next and current aren&#39;t terribly helpful either), and we don&#39;t have any context or type information.<br></p><p>&gt; let next = current.locationByUpdatingProximity(p)<br></p><p>This is definitely more clear when you completely separate these lines from their context, but code isn&#39;t written or read in complete isolation like this, so I think these examples significantly exaggerate the ambiguity of the pattern in the real world.<br></p><p>Even if you only make the minor change of renaming p to proximity (which is really what it should be), the first example becomes pretty clear:<br></p><p>&gt; let next = current.updating(proximity)<br></p><p><br>Ultimately, I don&#39;t think this is a very difficult pattern to learn. Maybe the first handful of times you see it you&#39;ll need to read the documentation to know exactly what it&#39;s doing, but once you&#39;ve seen it a few times, it&#39;s an instantly recognizable pattern. If you see a gerund method, it returns a new thing by doing the verb to the thing. Is it worth the redundancy and noise to save new developers from possibly needing to look at a method&#39;s documentation a few times?<br></p><p>I see the tradeoff here as a minor, essentially one-time decrease in clarity for new developers, and a small but indefinite increase in clarity for everyone else.<br></p><p>&gt; When is the last time you saw a gerund (-ing) as a method name? I wouldn&#39;t let my students write that. Gerunds make good boolean properties. How would you even read the first line above out loud? Probably by filling in the words in the second line, magically.<br></p><p>Not having used this pattern before isn&#39;t a valid reason to not start using it, and the API design guidelines already provide a fine pattern for boolean properties, so we don&#39;t need gerunds for them.<br></p><p>&gt; My second major issue is that autocomplete grouping is totally lost when dropping the type returned at the beginning of the call. How many of us learned a *ton* when we just autocompleted .stringBy? Look at all the things you can do! But by removing the &#39;useless word&#39; (really don&#39;t like that flag name) we have no grouping of constructor methods.<br></p><p>I agree that this is kind of unfortunate, but I also don&#39;t think that it&#39;s a good idea to limit our API design for the sake of autocomplete discovery. Documentation is readily available and is a far better form of discovery since you don&#39;t just see things that start with the same prefix that you&#39;re using. The tradeoff is that you have to go out of your way to do it, but these are the kinds of good habits we should be teaching students.<br></p><p>&gt; I see a lot of discussion on how to deal with &#39;with&#39; and &#39;by&#39; and other words, but I want to strongly suggest that the current naming practices provide context and clarity. It makes code readable and accessible. Don&#39;t forget about when you didn&#39;t know how to code! These method names are teaching tools!<br>&gt; <br>&gt; Finally, I just want to ask: why? What is the great benefit? Shouldn&#39;t clarity be prioritized over brevity (where have I seen that...) <br>&gt; <br>&gt; I can&#39;t put it better than another forums poster:<br>&gt; <br>&gt; Does the Swift team seriously believe that systematically parsing and extensively munging patterns in not-quite-natural-language is tractable to support all the corner cases for? And that, even if it were, that it could avoid confusion in less-than-perfect codebases? The idea that this will somehow benefit a language, particularly one in which clear and obvious bridging is so vital is insane. The best it can do is a reasonable job, with some amount of either unfixable brokenness forced upon developers in perpetuity, or constant churn stemming from perpetual fixing of brokenness. Swift&#39;s translation is currently simple to reason about, and the language as a whole has got a really great thing going on. I&#39;m really happy with where it is at this moment. Why ruin it by boneheadedly detonating the utility of two years of progress in literature and the library of online information about Swift? Seriously, why?<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Feb 2, 2016 at 1:04 PM, Kevin Schlei &lt;kevinschlei at gmail.com &lt;mailto:kevinschlei at gmail.com&gt;&gt; wrote:<br>&gt; I am strongly against the proposed changes to the translation of Objective-C APIs. I think the changes promote terseness for terseness sake, lose vital context in method names, and are a huge loss pedagogically.<br>&gt; <br>&gt; If you teach programming, you&#39;ll know why this line will be a nightmare:<br>&gt; <br>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/923810fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/08045ad84066382b7a4d173e89302627?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Kevin Schlei</string> &lt;kevinschlei at gmail.com&gt;<p>February  2, 2016 at 05:00:00pm</p></header><div class="content"><p>(reply-all reposting, sorry I&#39;m not very list-serve savvy)<br></p><p>I think it&#39;s only unclear because p is not a descriptive name (next and<br>&gt; current aren&#39;t terribly helpful either), and we don&#39;t have any context or<br>&gt; type information.<br>&gt;<br></p><p>Put another way: it&#39;s up to variable names to clarify what a method does.<br>I&#39;m not in favor of that, and right now it&#39;s not broken. (To be clear: I&#39;m<br>all for properly naming variables. I hope everyone else is the same.)<br></p><p>True, I intentionally chose ambiguous variable names to illustrate a point.<br>However, I have to admit that when unpacking optionals I have caught myself<br>doing this occasionally:<br></p><p>if let p = proximity {<br></p><p>}<br></p><p><br>&gt; This is definitely more clear when you completely separate these lines<br>&gt; from their context, but code isn&#39;t written or read in complete isolation<br>&gt; like this, so I think these examples significantly exaggerate the ambiguity<br>&gt; of the pattern in the real world.<br>&gt;<br></p><p>In my experience, encountering new code is an exercise in unpacking<br>individual components in order to understand the whole. Making the<br>individual parts convey less makes the whole thing harder to absorb.<br></p><p>On Tue, Feb 2, 2016 at 2:48 PM, &lt;swift at lng.la&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 2, 2016, at 11:16, Kevin Schlei via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Sorry for the premature send! Continuing:<br>&gt;<br>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;<br>&gt; For a beginning programmer, there is no indication of what .trimming does.<br>&gt; In this case, it returns a new string instance. Where is that explained? In<br>&gt; the documentation. Nowhere near the method call.<br>&gt;<br>&gt; So are we reduced now to looking up documentation just to read code? What<br>&gt; does this line do:<br>&gt;<br>&gt; let next = current.updating(p)<br>&gt;<br>&gt; It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all<br>&gt; the hints. But this line:<br>&gt;<br>&gt;<br>&gt; I think it&#39;s only unclear because p is not a descriptive name (next and<br>&gt; current aren&#39;t terribly helpful either), and we don&#39;t have any context or<br>&gt; type information.<br>&gt;<br>&gt; let next = current.locationByUpdatingProximity(p)<br>&gt;<br>&gt;<br>&gt; This is definitely more clear when you completely separate these lines<br>&gt; from their context, but code isn&#39;t written or read in complete isolation<br>&gt; like this, so I think these examples significantly exaggerate the ambiguity<br>&gt; of the pattern in the real world.<br>&gt;<br>&gt; Even if you only make the minor change of renaming p to proximity (which<br>&gt; is really what it should be), the first example becomes pretty clear:<br>&gt;<br>&gt; let next = current.updating(proximity)<br>&gt;<br>&gt;<br>&gt; Ultimately, I don&#39;t think this is a very difficult pattern to learn. Maybe<br>&gt; the first handful of times you see it you&#39;ll need to read the documentation<br>&gt; to know exactly what it&#39;s doing, but once you&#39;ve seen it a few times, it&#39;s<br>&gt; an instantly recognizable pattern. If you see a gerund method, it returns a<br>&gt; new thing by doing the verb to the thing. Is it worth the redundancy and<br>&gt; noise to save new developers from possibly needing to look at a method&#39;s<br>&gt; documentation a few times?<br>&gt;<br>&gt; I see the tradeoff here as a minor, essentially one-time decrease in<br>&gt; clarity for new developers, and a small but indefinite increase in clarity<br>&gt; for everyone else.<br>&gt;<br>&gt; When is the last time you saw a gerund (-ing) as a method name? I wouldn&#39;t<br>&gt; let my students write that. Gerunds make good boolean properties. How would<br>&gt; you even read the first line above out loud? Probably by filling in the<br>&gt; words in the second line, magically.<br>&gt;<br>&gt;<br>&gt; Not having used this pattern before isn&#39;t a valid reason to not start<br>&gt; using it, and the API design guidelines already provide a fine pattern for<br>&gt; boolean properties, so we don&#39;t need gerunds for them.<br>&gt;<br>&gt; My second major issue is that autocomplete grouping is totally lost when<br>&gt; dropping the type returned at the beginning of the call. How many of us<br>&gt; learned a *ton* when we just autocompleted .stringBy? Look at all the<br>&gt; things you can do! But by removing the &#39;useless word&#39; (really don&#39;t like<br>&gt; that flag name) we have no grouping of constructor methods.<br>&gt;<br>&gt;<br>&gt; I agree that this is kind of unfortunate, but I also don&#39;t think that it&#39;s<br>&gt; a good idea to limit our API design for the sake of autocomplete discovery.<br>&gt; Documentation is readily available and is a far better form of discovery<br>&gt; since you don&#39;t just see things that start with the same prefix that you&#39;re<br>&gt; using. The tradeoff is that you have to go out of your way to do it, but<br>&gt; these are the kinds of good habits we should be teaching students.<br>&gt;<br>&gt; I see a lot of discussion on how to deal with &#39;with&#39; and &#39;by&#39; and other<br>&gt; words, but I want to strongly suggest that the current naming practices<br>&gt; provide context and clarity. It makes code readable and accessible. Don&#39;t<br>&gt; forget about when you didn&#39;t know how to code! These method names are<br>&gt; teaching tools!<br>&gt;<br>&gt; Finally, I just want to ask: why? What is the great benefit? Shouldn&#39;t<br>&gt; clarity be prioritized over brevity (where have I seen that...)<br>&gt;<br>&gt; I can&#39;t put it better than another forums poster:<br>&gt;<br>&gt; Does the Swift team seriously believe that systematically parsing and<br>&gt;&gt; extensively munging patterns in not-quite-natural-language is tractable to<br>&gt;&gt; support all the corner cases for? And that, even if it were, that it could<br>&gt;&gt; avoid confusion in less-than-perfect codebases? The idea that this will<br>&gt;&gt; somehow benefit a language, particularly one in which clear and obvious<br>&gt;&gt; bridging is so vital is *insane*. The best it can do is a reasonable<br>&gt;&gt; job, with some amount of either unfixable brokenness forced upon developers<br>&gt;&gt; in perpetuity, or constant churn stemming from perpetual fixing of<br>&gt;&gt; brokenness. Swift&#39;s translation is currently simple to reason about, and<br>&gt;&gt; the language as a whole has got a really great thing going on. I&#39;m really<br>&gt;&gt; happy with where it is at this moment. Why ruin it by boneheadedly<br>&gt;&gt; detonating the utility of two years of progress in literature and the<br>&gt;&gt; library of online information about Swift? Seriously, why?<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Feb 2, 2016 at 1:04 PM, Kevin Schlei &lt;kevinschlei at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I am strongly against the proposed changes to the translation of<br>&gt;&gt; Objective-C APIs. I think the changes promote terseness for terseness sake,<br>&gt;&gt; lose vital context in method names, and are a huge loss pedagogically.<br>&gt;&gt;<br>&gt;&gt; If you teach programming, you&#39;ll know why this line will be a nightmare:<br>&gt;&gt;<br>&gt;&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/d6a41d82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 15:49, Kevin Schlei &lt;kevinschlei at gmail.com&gt; wrote:<br>&gt; <br>&gt; (reply-all reposting, sorry I&#39;m not very list-serve savvy)<br>&gt; <br>&gt; I think it&#39;s only unclear because p is not a descriptive name (next and current aren&#39;t terribly helpful either), and we don&#39;t have any context or type information.<br>&gt; <br>&gt; Put another way: it&#39;s up to variable names to clarify what a method does. I&#39;m not in favor of that, and right now it&#39;s not broken. (To be clear: I&#39;m all for properly naming variables. I hope everyone else is the same.)<br>&gt; <br>&gt; True, I intentionally chose ambiguous variable names to illustrate a point. However, I have to admit that when unpacking optionals I have caught myself doing this occasionally:<br>&gt; <br>&gt; if let p = proximity {<br>&gt; <br>&gt; } <br></p><p>To be honest, I don&#39;t really agree with the practice of abbreviating names in that way unless it&#39;s something so common that it could be considered universally understood (like i in a loop, not that that&#39;s a very common pattern in Swift), so I wouldn&#39;t find myself in this kind of situation. But even then, unless the body of the if statement is enormous, you can easily refer to the binding to see that p stands for proximity, so context makes all the difference here.<br></p><p>&gt; This is definitely more clear when you completely separate these lines from their context, but code isn&#39;t written or read in complete isolation like this, so I think these examples significantly exaggerate the ambiguity of the pattern in the real world.<br>&gt; <br>&gt; In my experience, encountering new code is an exercise in unpacking individual components in order to understand the whole. Making the individual parts convey less makes the whole thing harder to absorb.<br></p><p>I disagree -- when I&#39;m looking at new code, I generally try to get a high-level understanding before diving into specifics, and extra verbosity tends to distract me from that and slow me down. Dense, terse code that leverages its context tends to be much quicker for me to understand since I don&#39;t have to filter out the noise words.<br></p><p>But it seems like this is something that&#39;s highly personal, and it may be that our disagreement simply comes from the fact that we read and process code differently. That&#39;s unfortunate if that&#39;s the case, since it would mean that one of us ultimately must accept that we&#39;re not working in an environment that&#39;s ideal for us individually, but at least we now have the opportunity to express our thoughts so we can make the best decision for the Swift community as a whole.<br></p><p>Jarod<br></p><p>&gt; On Tue, Feb 2, 2016 at 2:48 PM, &lt;swift at lng.la &lt;mailto:swift at lng.la&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:16, Kevin Schlei via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry for the premature send! Continuing:<br>&gt;&gt; <br>&gt;&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;&gt; <br>&gt;&gt; For a beginning programmer, there is no indication of what .trimming does. In this case, it returns a new string instance. Where is that explained? In the documentation. Nowhere near the method call.<br>&gt;&gt; <br>&gt;&gt; So are we reduced now to looking up documentation just to read code? What does this line do:<br>&gt;&gt; <br>&gt;&gt; let next = current.updating(p)<br>&gt;&gt; <br>&gt;&gt; It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all the hints. But this line:<br>&gt; <br>&gt; I think it&#39;s only unclear because p is not a descriptive name (next and current aren&#39;t terribly helpful either), and we don&#39;t have any context or type information.<br>&gt; <br>&gt;&gt; let next = current.locationByUpdatingProximity(p)<br>&gt; <br>&gt; This is definitely more clear when you completely separate these lines from their context, but code isn&#39;t written or read in complete isolation like this, so I think these examples significantly exaggerate the ambiguity of the pattern in the real world.<br>&gt; <br>&gt; Even if you only make the minor change of renaming p to proximity (which is really what it should be), the first example becomes pretty clear:<br>&gt; <br>&gt;&gt; let next = current.updating(proximity)<br>&gt; <br>&gt; <br>&gt; Ultimately, I don&#39;t think this is a very difficult pattern to learn. Maybe the first handful of times you see it you&#39;ll need to read the documentation to know exactly what it&#39;s doing, but once you&#39;ve seen it a few times, it&#39;s an instantly recognizable pattern. If you see a gerund method, it returns a new thing by doing the verb to the thing. Is it worth the redundancy and noise to save new developers from possibly needing to look at a method&#39;s documentation a few times?<br>&gt; <br>&gt; I see the tradeoff here as a minor, essentially one-time decrease in clarity for new developers, and a small but indefinite increase in clarity for everyone else.<br>&gt; <br>&gt;&gt; When is the last time you saw a gerund (-ing) as a method name? I wouldn&#39;t let my students write that. Gerunds make good boolean properties. How would you even read the first line above out loud? Probably by filling in the words in the second line, magically.<br>&gt; <br>&gt; Not having used this pattern before isn&#39;t a valid reason to not start using it, and the API design guidelines already provide a fine pattern for boolean properties, so we don&#39;t need gerunds for them.<br>&gt; <br>&gt;&gt; My second major issue is that autocomplete grouping is totally lost when dropping the type returned at the beginning of the call. How many of us learned a *ton* when we just autocompleted .stringBy? Look at all the things you can do! But by removing the &#39;useless word&#39; (really don&#39;t like that flag name) we have no grouping of constructor methods.<br>&gt; <br>&gt; I agree that this is kind of unfortunate, but I also don&#39;t think that it&#39;s a good idea to limit our API design for the sake of autocomplete discovery. Documentation is readily available and is a far better form of discovery since you don&#39;t just see things that start with the same prefix that you&#39;re using. The tradeoff is that you have to go out of your way to do it, but these are the kinds of good habits we should be teaching students.<br>&gt; <br>&gt;&gt; I see a lot of discussion on how to deal with &#39;with&#39; and &#39;by&#39; and other words, but I want to strongly suggest that the current naming practices provide context and clarity. It makes code readable and accessible. Don&#39;t forget about when you didn&#39;t know how to code! These method names are teaching tools!<br>&gt;&gt; <br>&gt;&gt; Finally, I just want to ask: why? What is the great benefit? Shouldn&#39;t clarity be prioritized over brevity (where have I seen that...) <br>&gt;&gt; <br>&gt;&gt; I can&#39;t put it better than another forums poster:<br>&gt;&gt; <br>&gt;&gt; Does the Swift team seriously believe that systematically parsing and extensively munging patterns in not-quite-natural-language is tractable to support all the corner cases for? And that, even if it were, that it could avoid confusion in less-than-perfect codebases? The idea that this will somehow benefit a language, particularly one in which clear and obvious bridging is so vital is insane. The best it can do is a reasonable job, with some amount of either unfixable brokenness forced upon developers in perpetuity, or constant churn stemming from perpetual fixing of brokenness. Swift&#39;s translation is currently simple to reason about, and the language as a whole has got a really great thing going on. I&#39;m really happy with where it is at this moment. Why ruin it by boneheadedly detonating the utility of two years of progress in literature and the library of online information about Swift? Seriously, why?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 2, 2016 at 1:04 PM, Kevin Schlei &lt;kevinschlei at gmail.com &lt;mailto:kevinschlei at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I am strongly against the proposed changes to the translation of Objective-C APIs. I think the changes promote terseness for terseness sake, lose vital context in method names, and are a huge loss pedagogically.<br>&gt;&gt; <br>&gt;&gt; If you teach programming, you&#39;ll know why this line will be a nightmare:<br>&gt;&gt; <br>&gt;&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/3b658c53/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 12:48 PM, Jarod Long via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is definitely more clear when you completely separate these lines from their context, but code isn&#39;t written or read in complete isolation like this, so I think these examples significantly exaggerate the ambiguity of the pattern in the real world.<br>&gt; <br>&gt; Even if you only make the minor change of renaming p to proximity (which is really what it should be), the first example becomes pretty clear:<br>&gt; <br>&gt;&gt; let next = current.updating(proximity)<br>&gt; <br>&gt; <br></p><p>I just want to comment on this as I keep seeing this for arguments on the lists. APIs themselves should not be relying on well named inputs into them to create clear API signatures.<br></p><p>The following version of the API is significantly more clear with no requirement of the variable names to be matched to the expectations of the API signature:<br></p><p>let next = current.updating(proximity: p)<br></p><p>Similarly,<br></p><p>let content = listItemView.text.trimming(characters: .whitespaceAndNewlines)<br></p><p>At least I have some context at the call site what the purpose of .whitespaceAndNewlines.<br></p><p>&gt; Ultimately, I don&#39;t think this is a very difficult pattern to learn. Maybe the first handful of times you see it you&#39;ll need to read the documentation to know exactly what it&#39;s doing, but once you&#39;ve seen it a few times, it&#39;s an instantly recognizable pattern. If you see a gerund method, it returns a new thing by doing the verb to the thing. Is it worth the redundancy and noise to save new developers from possibly needing to look at a method&#39;s documentation a few times?<br></p><p><br>I really do not like the -ing form; it reads backwards. I intuitively expected the object of the “trimming” to be the parameters, not the instance invoking the method.<br></p><p>let content = listItemView.text.trimmed(characters: .whitespaceAndNewlines)<br></p><p>Whereas when I read the above, it’s natural to read that the &quot;text is trimmed with” the parameter set. The former is, “the text is trimming with” the parameter set.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/48a2dbdd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; Sorry for the premature send! Continuing:<br>&gt;&gt; <br>&gt;&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;&gt; <br>&gt;&gt; For a beginning programmer, there is no indication of what .trimming does. In this case, it returns a new string instance. Where is that explained? In the documentation. Nowhere near the method call.<br>&gt;&gt; <br>&gt;&gt; So are we reduced now to looking up documentation just to read code? What does this line do:<br>&gt;&gt; <br>&gt;&gt; let next = current.updating(p)<br>&gt;&gt; <br>&gt;&gt; It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all the hints. But this line:<br>&gt; <br>&gt; I think it&#39;s only unclear because p is not a descriptive name (next and current aren&#39;t terribly helpful either), and we don&#39;t have any context or type information.<br>&gt; <br>&gt;&gt; let next = current.locationByUpdatingProximity(p)<br>&gt; <br>&gt; This is definitely more clear when you completely separate these lines from their context, but code isn&#39;t written or read in complete isolation like this, so I think these examples significantly exaggerate the ambiguity of the pattern in the real world.<br>&gt; <br>&gt; Even if you only make the minor change of renaming p to proximity (which is really what it should be), the first example becomes pretty clear:<br></p><p>i could not agree more. i find this proposed change terrible, and it kills one of the core things that make Cocoa APIs great.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eaa4b4d9d379600e42edf692da91a00c?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Aaron Crespo</string> &lt;aaroncrespo at gmail.com&gt;<p>February  2, 2016 at 02:00:00pm</p></header><div class="content"><p>I think Kevin and I come from the same place and largely agree. I feel like<br>this is trading in of accessibility and discoverability for the sake of<br>terseness. This might be aesthetically pleasing but gives up many positive<br>side effects the more descriptive names provide.<br></p><p>Consider the time before you knew you could or how to &quot;check the<br>documentation&quot;. Or the time spent scanning unfamiliar or long forgotten<br>code.<br></p><p>These concerns might be eased if consideration was also being given to the<br>first parameter rule. And the (now) odd difference between initializers and<br>function parameter names. Apply the same rules as any parameter name.<br></p><p>Stealing Kevins example:<br></p><p>let next = current.updating(proximity: p)<br></p><p>Not great but better.<br></p><p><br>On Tue, Feb 2, 2016 at 2:16 PM, Kevin Schlei via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry for the premature send! Continuing:<br>&gt;<br>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;<br>&gt; For a beginning programmer, there is no indication of what .trimming does.<br>&gt; In this case, it returns a new string instance. Where is that explained? In<br>&gt; the documentation. Nowhere near the method call.<br>&gt;<br>&gt; So are we reduced now to looking up documentation just to read code? What<br>&gt; does this line do:<br>&gt;<br>&gt; let next = current.updating(p)<br>&gt;<br>&gt; It&#39;s 100% unclear because you&#39;re relying on parameter names to contain all<br>&gt; the hints. But this line:<br>&gt;<br>&gt; let next = current.locationByUpdatingProximity(p)<br>&gt;<br>&gt; Lets you know that:<br>&gt;<br>&gt; 1. we&#39;re returning a *&#39;location&#39;*<br>&gt; 2. &#39;*by* *updating&#39; *current with a new *&#39;proximity&#39;*<br>&gt;<br>&gt; When is the last time you saw a gerund (-ing) as a method name? I wouldn&#39;t<br>&gt; let my students write that. Gerunds make good boolean properties. How would<br>&gt; you even read the first line above out loud? Probably by filling in the<br>&gt; words in the second line, magically.<br>&gt;<br>&gt; My second major issue is that autocomplete grouping is totally lost when<br>&gt; dropping the type returned at the beginning of the call. How many of us<br>&gt; learned a *ton* when we just autocompleted .stringBy? Look at all the<br>&gt; things you can do! But by removing the &#39;useless word&#39; (really don&#39;t like<br>&gt; that flag name) we have no grouping of constructor methods.<br>&gt;<br>&gt; I see a lot of discussion on how to deal with &#39;with&#39; and &#39;by&#39; and other<br>&gt; words, but I want to strongly suggest that the current naming practices<br>&gt; provide context and clarity. It makes code readable and accessible. Don&#39;t<br>&gt; forget about when you didn&#39;t know how to code! These method names are<br>&gt; teaching tools!<br>&gt;<br>&gt; Finally, I just want to ask: why? What is the great benefit? Shouldn&#39;t<br>&gt; clarity be prioritized over brevity (where have I seen that...)<br>&gt;<br>&gt; I can&#39;t put it better than another forums poster:<br>&gt;<br>&gt; Does the Swift team seriously believe that systematically parsing and<br>&gt;&gt; extensively munging patterns in not-quite-natural-language is tractable to<br>&gt;&gt; support all the corner cases for? And that, even if it were, that it could<br>&gt;&gt; avoid confusion in less-than-perfect codebases? The idea that this will<br>&gt;&gt; somehow benefit a language, particularly one in which clear and obvious<br>&gt;&gt; bridging is so vital is *insane*. The best it can do is a reasonable<br>&gt;&gt; job, with some amount of either unfixable brokenness forced upon developers<br>&gt;&gt; in perpetuity, or constant churn stemming from perpetual fixing of<br>&gt;&gt; brokenness. Swift&#39;s translation is currently simple to reason about, and<br>&gt;&gt; the language as a whole has got a really great thing going on. I&#39;m really<br>&gt;&gt; happy with where it is at this moment. Why ruin it by boneheadedly<br>&gt;&gt; detonating the utility of two years of progress in literature and the<br>&gt;&gt; library of online information about Swift? Seriously, why?<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Feb 2, 2016 at 1:04 PM, Kevin Schlei &lt;kevinschlei at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I am strongly against the proposed changes to the translation of<br>&gt;&gt; Objective-C APIs. I think the changes promote terseness for terseness sake,<br>&gt;&gt; lose vital context in method names, and are a huge loss pedagogically.<br>&gt;&gt;<br>&gt;&gt; If you teach programming, you&#39;ll know why this line will be a nightmare:<br>&gt;&gt;<br>&gt;&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/5f800f9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 11:49, Aaron Crespo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think Kevin and I come from the same place and largely agree. I feel like this is trading in of accessibility and discoverability for the sake of terseness. This might be aesthetically pleasing but gives up many positive side effects the more descriptive names provide.<br>&gt; <br>&gt; Consider the time before you knew you could or how to &quot;check the documentation&quot;. Or the time spent scanning unfamiliar or long forgotten code.<br></p><p>I think it&#39;s a failing of the learning process if you&#39;re working with an API in a way that autocomplete discoverability is valuable but you don&#39;t know how to check its documentation. If this is a real problem, we should find better ways to teach people how to find and use the documentation.<br></p><p>Jarod<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/de7ad0a98b5a246d7825f220b0174f4a?s=50"></div><header><strong>Issues with 0005-Better Translation of Objective-C APIs Into Swift</strong> from <string>Preston Sumner</string> &lt;preston.sumner at gmail.com&gt;<p>February  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 12:16 PM, Kevin Schlei via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for the premature send! Continuing:<br>&gt; <br>&gt; let content = listItemView.text.trimming(.whitespaceAndNewlines)<br>&gt; <br>&gt; For a beginning programmer, there is no indication of what .trimming does. In this case, it returns a new string instance. Where is that explained? In the documentation. Nowhere near the method call.<br></p><p>To me, it reads like documentation: “content” is assigned the list item view’s text, trimming whitespace and newlines. <br></p><p>Preston<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/59e6bcc3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
