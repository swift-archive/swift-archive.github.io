<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Say I have been passed an array of objects that conform to a protocol<br>called &quot;Eatable&quot; i.e [Eatable]<br></p><p>If I then try to cast them to an array of classes who happen to implement<br>that protocol i.e [Burger]<br></p><p>The compiler lets me but in the runtime it corrupts the memory.<br></p><p>*___________________________________*<br></p><p>*James⎥iOS Lead*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/a08cef31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>Hey James,<br></p><p>The appropriate place for compiler bugs is https://bugs.swift.org &lt;https://bugs.swift.org/&gt;, not Swift Evolution.<br></p><p>Best,<br>— Radek<br></p><p>&gt; On 25 Feb 2016, at 17:44, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Say I have been passed an array of objects that conform to a protocol called &quot;Eatable&quot; i.e [Eatable]<br>&gt; <br>&gt; If I then try to cast them to an array of classes who happen to implement that protocol i.e [Burger]<br>&gt; <br>&gt; The compiler lets me but in the runtime it corrupts the memory.<br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥iOS Lead<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/cb387d0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 25, 2016 at 09:00:00am</p></header><div class="content"><p>I think there are two things going on here:<br></p><p>- The compiler allows a memory-corrupting cast, which should be rejected (a bug).<br>- But it&#39;s a useful thing to do (a language change).<br></p><p>I&#39;m actually surprised about the bug, since we get plenty of questions about why the compiler doesn&#39;t allow it, implying that the compiler is indeed rejecting it. The answer is that protocol values and class values don&#39;t have the same representation, so converting between [Eatable] and [Burger] is an O(N) operation that requires allocating a new array. But that may not be a good enough reason not to allow it—conversions from NSArray to Array can do the same thing if the NSArray was mutable.<br></p><p>Jordan<br></p><p><br>&gt; On Feb 25, 2016, at 8:53 , Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey James,<br>&gt; <br>&gt; The appropriate place for compiler bugs is https://bugs.swift.org &lt;https://bugs.swift.org/&gt;, not Swift Evolution.<br>&gt; <br>&gt; Best,<br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 17:44, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Say I have been passed an array of objects that conform to a protocol called &quot;Eatable&quot; i.e [Eatable]<br>&gt;&gt; <br>&gt;&gt; If I then try to cast them to an array of classes who happen to implement that protocol i.e [Burger]<br>&gt;&gt; <br>&gt;&gt; The compiler lets me but in the runtime it corrupts the memory.<br>&gt;&gt; ___________________________________<br>&gt;&gt; <br>&gt;&gt; James⎥iOS Lead<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt; Sup<br>&gt;&gt; <br>&gt;&gt; Runway East &gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 10 Finsbury Square<br>&gt;&gt; <br>&gt;&gt; London<br>&gt;&gt; <br>&gt;&gt;  &gt;&gt; EC2A 1AF <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/04206cc1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>In the actual code, the array with the protocol type i.e [Eatable] is used<br>as an associated type. So perhaps it normally gets rejected but isn&#39;t in<br>this case ?<br></p><p><br></p><p>*___________________________________*<br></p><p>*James⎥Head of Clown*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Thu, Feb 25, 2016 at 5:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; I think there are two things going on here:<br>&gt;<br>&gt; - The compiler allows a memory-corrupting cast, which should be rejected<br>&gt; (a bug).<br>&gt; - But it&#39;s a useful thing to do (a language change).<br>&gt;<br>&gt; I&#39;m actually surprised about the bug, since we get plenty of questions<br>&gt; about why the compiler doesn&#39;t allow it, implying that the compiler is<br>&gt; indeed rejecting it. The answer is that protocol values and class values<br>&gt; don&#39;t have the same representation, so converting between [Eatable] and<br>&gt; [Burger] is an O(N) operation that requires allocating a new array. But<br>&gt; that may not be a good enough reason not to allow it—conversions from<br>&gt; NSArray to Array can do the same thing if the NSArray was mutable.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Feb 25, 2016, at 8:53 , Radosław Pietruszewski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hey James,<br>&gt;<br>&gt; The appropriate place for compiler bugs is https://bugs.swift.org, not<br>&gt; Swift Evolution.<br>&gt;<br>&gt; Best,<br>&gt; — Radek<br>&gt;<br>&gt; On 25 Feb 2016, at 17:44, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Say I have been passed an array of objects that conform to a protocol<br>&gt; called &quot;Eatable&quot; i.e [Eatable]<br>&gt;<br>&gt; If I then try to cast them to an array of classes who happen to implement<br>&gt; that protocol i.e [Burger]<br>&gt;<br>&gt; The compiler lets me but in the runtime it corrupts the memory.<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥iOS Lead*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/9ce789e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 9:07 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think there are two things going on here:<br>&gt; <br>&gt; - The compiler allows a memory-corrupting cast, which should be rejected (a bug).<br>&gt; - But it&#39;s a useful thing to do (a language change).<br>&gt; <br>&gt; I&#39;m actually surprised about the bug, since we get plenty of questions about why the compiler doesn&#39;t allow it, implying that the compiler is indeed rejecting it. The answer is that protocol values and class values don&#39;t have the same representation, so converting between [Eatable] and [Burger] is an O(N) operation that requires allocating a new array. But that may not be a good enough reason not to allow it—conversions from NSArray to Array can do the same thing if the NSArray was mutable.<br></p><p>I&#39;ve overheard discussion of removing the covariant container conversions altogether, since they&#39;re inconsistent with the rest of the language, lead to a lot of type-checker and runtime dynamic cast complexity, and have unpredictable performance if generalized, and moving in the direction of encouraging the use of abstract AnyCollection values instead of concrete Arrays, that would free us to make covariant conversions cheaper by wrapping instead of eagerly mapping the array representation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February 25, 2016 at 11:00:00am</p></header><div class="content"><p>That&#39;s a bold move. Is opt-in covariance/contravariance as an alternative, with performance caveats explicitly denoted, still off the table? Would the Any(X)Collection types be automatically covariant, like Array&lt;T&gt; is now, or would it work differently somehow?<br></p><p>Austin<br></p><p>&gt; On Feb 25, 2016, at 11:12 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 9:07 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think there are two things going on here:<br>&gt;&gt; <br>&gt;&gt; - The compiler allows a memory-corrupting cast, which should be rejected (a bug).<br>&gt;&gt; - But it&#39;s a useful thing to do (a language change).<br>&gt;&gt; <br>&gt;&gt; I&#39;m actually surprised about the bug, since we get plenty of questions about why the compiler doesn&#39;t allow it, implying that the compiler is indeed rejecting it. The answer is that protocol values and class values don&#39;t have the same representation, so converting between [Eatable] and [Burger] is an O(N) operation that requires allocating a new array. But that may not be a good enough reason not to allow it—conversions from NSArray to Array can do the same thing if the NSArray was mutable.<br>&gt; <br>&gt; I&#39;ve overheard discussion of removing the covariant container conversions altogether, since they&#39;re inconsistent with the rest of the language, lead to a lot of type-checker and runtime dynamic cast complexity, and have unpredictable performance if generalized, and moving in the direction of encouraging the use of abstract AnyCollection values instead of concrete Arrays, that would free us to make covariant conversions cheaper by wrapping instead of eagerly mapping the array representation.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Interesting. Two Qs:<br></p><p>- when you say &quot;moving in the direction of encouraging the use of abstract AnyCollection values&quot;, do you mean in general? To encourage people to use AnyCollection&lt;T&gt; instead of [T] in their code?<br>- how could covariant collection casting look like in this world?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 25 Feb 2016, at 20:12, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 9:07 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think there are two things going on here:<br>&gt;&gt; <br>&gt;&gt; - The compiler allows a memory-corrupting cast, which should be rejected (a bug).<br>&gt;&gt; - But it&#39;s a useful thing to do (a language change).<br>&gt;&gt; <br>&gt;&gt; I&#39;m actually surprised about the bug, since we get plenty of questions about why the compiler doesn&#39;t allow it, implying that the compiler is indeed rejecting it. The answer is that protocol values and class values don&#39;t have the same representation, so converting between [Eatable] and [Burger] is an O(N) operation that requires allocating a new array. But that may not be a good enough reason not to allow it—conversions from NSArray to Array can do the same thing if the NSArray was mutable.<br>&gt; <br>&gt; I&#39;ve overheard discussion of removing the covariant container conversions altogether, since they&#39;re inconsistent with the rest of the language, lead to a lot of type-checker and runtime dynamic cast complexity, and have unpredictable performance if generalized, and moving in the direction of encouraging the use of abstract AnyCollection values instead of concrete Arrays, that would free us to make covariant conversions cheaper by wrapping instead of eagerly mapping the array representation.<br>&gt; <br>&gt; -Joe<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 26, 2016 at 06:00:00am</p></header><div class="content"><p>I think it would be a good idea to remove the covariance of Array since it<br>is compiler magic and that would clear the way for a more general solution.<br></p><p>On Friday, 26 February 2016, Radek Pietruszewski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Interesting. Two Qs:<br>&gt;<br>&gt; - when you say &quot;moving in the direction of encouraging the use of abstract<br>&gt; AnyCollection values&quot;, do you mean in general? To encourage people to use<br>&gt; AnyCollection&lt;T&gt; instead of [T] in their code?<br>&gt; - how could covariant collection casting look like in this world?<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On 25 Feb 2016, at 20:12, Joe Groff &lt;jgroff at apple.com &lt;javascript:;&gt;&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Feb 25, 2016, at 9:07 AM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think there are two things going on here:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - The compiler allows a memory-corrupting cast, which should be<br>&gt; rejected (a bug).<br>&gt; &gt;&gt; - But it&#39;s a useful thing to do (a language change).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m actually surprised about the bug, since we get plenty of questions<br>&gt; about why the compiler doesn&#39;t allow it, implying that the compiler is<br>&gt; indeed rejecting it. The answer is that protocol values and class values<br>&gt; don&#39;t have the same representation, so converting between [Eatable] and<br>&gt; [Burger] is an O(N) operation that requires allocating a new array. But<br>&gt; that may not be a good enough reason not to allow it—conversions from<br>&gt; NSArray to Array can do the same thing if the NSArray was mutable.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve overheard discussion of removing the covariant container<br>&gt; conversions altogether, since they&#39;re inconsistent with the rest of the<br>&gt; language, lead to a lot of type-checker and runtime dynamic cast<br>&gt; complexity, and have unpredictable performance if generalized, and moving<br>&gt; in the direction of encouraging the use of abstract AnyCollection values<br>&gt; instead of concrete Arrays, that would free us to make covariant<br>&gt; conversions cheaper by wrapping instead of eagerly mapping the array<br>&gt; representation.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/20f53880/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 11:45 AM, Radek Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; Interesting. Two Qs:<br>&gt; <br>&gt; - when you say &quot;moving in the direction of encouraging the use of abstract AnyCollection values&quot;, do you mean in general? To encourage people to use AnyCollection&lt;T&gt; instead of [T] in their code?<br></p><p>Yeah. In Cocoa, the NSArray and NSDictionary class clusters serve the purpose not only of standard collections but as abstract interfaces for ordered and keyed collections, after all.<br></p><p>&gt; - how could covariant collection casting look like in this world?<br></p><p>A no-language-support-needed approach might be to give the CollectionType protocol a `mapToType(T.self)` method which can be given specialized implementations for cases that can be efficiently implemented (such as mapping an array of class references to another class type), and/or fall back to wrapping with a lazy adapter in cases like going from a collection of ConcreteType to a collection of ProtocolType.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 25, 2016 at 09:00:00pm</p></header><div class="content"><p>Hm. Obviously, you have far more insight into current implementation and performance difficulties, but purely from a programmer&#39;s perspective, going from [Foo] to AnyCollection&lt;Foo&gt; and from &#39;xs as? [Bar]&#39; to &#39;xs.mapAsType(Bar.self)&#39; seems like a step back.<br></p><p>Regarding the latter, wouldn&#39;t it be better to somehow generalize covariant collection casts? Perhaps a special protocol different collection types can conform to to define their cast implementation?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 25 Feb 2016, at 20:50, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 11:45 AM, Radek Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Interesting. Two Qs:<br>&gt;&gt; <br>&gt;&gt; - when you say &quot;moving in the direction of encouraging the use of abstract AnyCollection values&quot;, do you mean in general? To encourage people to use AnyCollection&lt;T&gt; instead of [T] in their code?<br>&gt; <br>&gt; Yeah. In Cocoa, the NSArray and NSDictionary class clusters serve the purpose not only of standard collections but as abstract interfaces for ordered and keyed collections, after all.<br>&gt; <br>&gt;&gt; - how could covariant collection casting look like in this world?<br>&gt; <br>&gt; A no-language-support-needed approach might be to give the CollectionType protocol a `mapToType(T.self)` method which can be given specialized implementations for cases that can be efficiently implemented (such as mapping an array of class references to another class type), and/or fall back to wrapping with a lazy adapter in cases like going from a collection of ConcreteType to a collection of ProtocolType.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 12:07 PM, Radek Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hm. Obviously, you have far more insight into current implementation and performance difficulties, but purely from a programmer&#39;s perspective, going from [Foo] to AnyCollection&lt;Foo&gt; and from &#39;xs as? [Bar]&#39; to &#39;xs.mapAsType(Bar.self)&#39; seems like a step back.<br></p><p>True. This is all just ideas at this point. If we were serious about changing the currency type for collections, we&#39;d probably want to change the type sugar to match.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Regarding the latter, wouldn&#39;t it be better to somehow generalize covariant collection casts? Perhaps a special protocol different collection types can conform to to define their cast implementation?<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 20:50, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 25, 2016, at 11:45 AM, Radek Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interesting. Two Qs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - when you say &quot;moving in the direction of encouraging the use of abstract AnyCollection values&quot;, do you mean in general? To encourage people to use AnyCollection&lt;T&gt; instead of [T] in their code?<br>&gt;&gt; <br>&gt;&gt; Yeah. In Cocoa, the NSArray and NSDictionary class clusters serve the purpose not only of standard collections but as abstract interfaces for ordered and keyed collections, after all.<br>&gt;&gt; <br>&gt;&gt;&gt; - how could covariant collection casting look like in this world?<br>&gt;&gt; <br>&gt;&gt; A no-language-support-needed approach might be to give the CollectionType protocol a `mapToType(T.self)` method which can be given specialized implementations for cases that can be efficiently implemented (such as mapping an array of class references to another class type), and/or fall back to wrapping with a lazy adapter in cases like going from a collection of ConcreteType to a collection of ProtocolType.<br>&gt;&gt; <br>&gt;&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting Bug Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 12:14 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 25, 2016, at 12:07 PM, Radek Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hm. Obviously, you have far more insight into current implementation and performance difficulties, but purely from a programmer&#39;s perspective, going from [Foo] to AnyCollection&lt;Foo&gt; and from &#39;xs as? [Bar]&#39; to &#39;xs.mapAsType(Bar.self)&#39; seems like a step back.<br>&gt; <br>&gt; True. This is all just ideas at this point. If we were serious about changing the currency type for collections, we&#39;d probably want to change the type sugar to match.<br></p><p>An explicit `mapAsType` operation might also serve as the basis for a compiler-blessed protocol that allows for user-defined covariant container types.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/80cd1342/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
