<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>Pitch: Modify the meaning of IBOutlet to remove the ! from the type</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>May 18, 2016 at 09:00:00am</p></header><div class="content"><p>I would like to propose we modify the meaning of @IBOutlet in light of the accepted proposal SE-0054 Abolish ImplicitlyUnwrappedOptional type. I think this fits in with the current Swift 3 goals.<br></p><p>Currently we use “var” and “!” when we declare an outlet like this:<br></p><p>@IBOutlet weak var myLabel: UILabel!<br></p><p>The “!” in the declaration allows us to use the outlet like this without unwrapping it<br></p><p>myLabel.text = “Hello&quot;<br></p><p>We use “var” and “UILabel!&quot; because myLabel starts its life out as nil and does not have a value until the connection is made. i.e. myLabel must be an optional if it accepts nil and the type is UILabel! instead of UILabel? so that we don’t have to unwrap it each time we use it.<br></p><p>If we break the connection to the UILabel instance we crash at runtime for attempting to unwrap nil.<br></p><p>Given this, I propose that we be able to write<br></p><p>@IBOutlet weak let myLabel: UILabel<br></p><p>In this case @IBOutlet has a meaning somewhat similar to lazy - it’s not that myLabel doesn’t exist until we first call it, but @IBOutlet indicates that myLabel should exist before we call it. <br></p><p>If the connection isn’t made and myLabel doesn’t exist, we should crash as we do now. If the connection is not made in the nib or storyboard, this will crash at development time. <br></p><p>This removes a case in which we use var - not because we want to change the value of a property but because of a detail in the tooling.<br></p><p>This change also removes a case in which we use an Optional again for a detail in lifecycle and tooling.<br></p><p>Best,<br></p><p>Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Pitch: Modify the meaning of IBOutlet to remove the ! from the type</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>Correct me if I&#39;m wrong, but `weak` reference can not be `let` just by <br>definition: at some point in time such reference *can* become nil.<br></p><p>On 18.05.2016 16:22, Daniel Steinberg via swift-evolution wrote:<br>&gt; I would like to propose we modify the meaning of @IBOutlet in light of the accepted proposal SE-0054 Abolish ImplicitlyUnwrappedOptional type. I think this fits in with the current Swift 3 goals.<br>&gt;<br>&gt; Currently we use “var” and “!” when we declare an outlet like this:<br>&gt;<br>&gt; @IBOutlet weak var myLabel: UILabel!<br>&gt;<br>&gt; The “!” in the declaration allows us to use the outlet like this without unwrapping it<br>&gt;<br>&gt; myLabel.text = “Hello&quot;<br>&gt;<br>&gt; We use “var” and “UILabel!&quot; because myLabel starts its life out as nil and does not have a value until the connection is made. i.e. myLabel must be an optional if it accepts nil and the type is UILabel! instead of UILabel? so that we don’t have to unwrap it each time we use it.<br>&gt;<br>&gt; If we break the connection to the UILabel instance we crash at runtime for attempting to unwrap nil.<br>&gt;<br>&gt; Given this, I propose that we be able to write<br>&gt;<br>&gt; @IBOutlet weak let myLabel: UILabel<br>&gt;<br>&gt; In this case @IBOutlet has a meaning somewhat similar to lazy - it’s not that myLabel doesn’t exist until we first call it, but @IBOutlet indicates that myLabel should exist before we call it.<br>&gt;<br>&gt; If the connection isn’t made and myLabel doesn’t exist, we should crash as we do now. If the connection is not made in the nib or storyboard, this will crash at development time.<br>&gt;<br>&gt; This removes a case in which we use var - not because we want to change the value of a property but because of a detail in the tooling.<br>&gt;<br>&gt; This change also removes a case in which we use an Optional again for a detail in lifecycle and tooling.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Daniel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Pitch: Modify the meaning of IBOutlet to remove the ! from the type</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Similarly, a weak reference cannot be non-optional. I would be<br>uncomfortable with an attribute changing that behavior. Having a<br>non-optional field become nil or crash behind the scenes discards the<br>safety of the Swift type system.<br></p><p>There are legitimate situations where a class might have unused outlets as<br>well, where you would want an optional (`?`) type; for example, you could<br>have an iPad nib that has additional views that aren&#39;t present in an iPhone<br>nib, but both share the same view controller. In that case, you would want<br>to have some of those outlets still be optional. (Your pitch may not<br>prevent that behavior, but it&#39;s worth pointing out as a use case.)<br></p><p><br>On Wed, May 18, 2016 at 6:42 AM Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Correct me if I&#39;m wrong, but `weak` reference can not be `let` just by<br>&gt; definition: at some point in time such reference *can* become nil.<br>&gt;<br>&gt; On 18.05.2016 16:22, Daniel Steinberg via swift-evolution wrote:<br>&gt; &gt; I would like to propose we modify the meaning of @IBOutlet in light of<br>&gt; the accepted proposal SE-0054 Abolish ImplicitlyUnwrappedOptional type. I<br>&gt; think this fits in with the current Swift 3 goals.<br>&gt; &gt;<br>&gt; &gt; Currently we use “var” and “!” when we declare an outlet like this:<br>&gt; &gt;<br>&gt; &gt; @IBOutlet weak var myLabel: UILabel!<br>&gt; &gt;<br>&gt; &gt; The “!” in the declaration allows us to use the outlet like this without<br>&gt; unwrapping it<br>&gt; &gt;<br>&gt; &gt; myLabel.text = “Hello&quot;<br>&gt; &gt;<br>&gt; &gt; We use “var” and “UILabel!&quot; because myLabel starts its life out as nil<br>&gt; and does not have a value until the connection is made. i.e. myLabel must<br>&gt; be an optional if it accepts nil and the type is UILabel! instead of<br>&gt; UILabel? so that we don’t have to unwrap it each time we use it.<br>&gt; &gt;<br>&gt; &gt; If we break the connection to the UILabel instance we crash at runtime<br>&gt; for attempting to unwrap nil.<br>&gt; &gt;<br>&gt; &gt; Given this, I propose that we be able to write<br>&gt; &gt;<br>&gt; &gt; @IBOutlet weak let myLabel: UILabel<br>&gt; &gt;<br>&gt; &gt; In this case @IBOutlet has a meaning somewhat similar to lazy - it’s not<br>&gt; that myLabel doesn’t exist until we first call it, but @IBOutlet indicates<br>&gt; that myLabel should exist before we call it.<br>&gt; &gt;<br>&gt; &gt; If the connection isn’t made and myLabel doesn’t exist, we should crash<br>&gt; as we do now. If the connection is not made in the nib or storyboard, this<br>&gt; will crash at development time.<br>&gt; &gt;<br>&gt; &gt; This removes a case in which we use var - not because we want to change<br>&gt; the value of a property but because of a detail in the tooling.<br>&gt; &gt;<br>&gt; &gt; This change also removes a case in which we use an Optional again for a<br>&gt; detail in lifecycle and tooling.<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt;<br>&gt; &gt; Daniel<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/d3a14af6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Pitch: Modify the meaning of IBOutlet to remove the ! from the type</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 18, 2016 at 11:00:00am</p></header><div class="content"><p>The attribute wouldn&#39;t change the behavior. The reference is still<br>implicitly unwrapped. IB Outlets are, at least currently, IUO by necessity.<br>I think that this proposal looks to make it less redundant. I didn&#39;t fully<br>spot the use of `let` on the first or second reading but there is another<br>proposal being pitched for allowing computer properties to be `let`. This<br>is similar in that regard. From the discussion there, it sounds like that<br>part might not fit with the core team&#39;s vision for the optimizer?<br></p><p>On Wed, May 18, 2016 at 10:36 AM, Tony Allevato via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Similarly, a weak reference cannot be non-optional. I would be<br>&gt; uncomfortable with an attribute changing that behavior. Having a<br>&gt; non-optional field become nil or crash behind the scenes discards the<br>&gt; safety of the Swift type system.<br>&gt;<br>&gt; There are legitimate situations where a class might have unused outlets as<br>&gt; well, where you would want an optional (`?`) type; for example, you could<br>&gt; have an iPad nib that has additional views that aren&#39;t present in an iPhone<br>&gt; nib, but both share the same view controller. In that case, you would want<br>&gt; to have some of those outlets still be optional. (Your pitch may not<br>&gt; prevent that behavior, but it&#39;s worth pointing out as a use case.)<br>&gt;<br>&gt;<br>&gt; On Wed, May 18, 2016 at 6:42 AM Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Correct me if I&#39;m wrong, but `weak` reference can not be `let` just by<br>&gt;&gt; definition: at some point in time such reference *can* become nil.<br>&gt;&gt;<br>&gt;&gt; On 18.05.2016 16:22, Daniel Steinberg via swift-evolution wrote:<br>&gt;&gt; &gt; I would like to propose we modify the meaning of @IBOutlet in light of<br>&gt;&gt; the accepted proposal SE-0054 Abolish ImplicitlyUnwrappedOptional type. I<br>&gt;&gt; think this fits in with the current Swift 3 goals.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Currently we use “var” and “!” when we declare an outlet like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; @IBOutlet weak var myLabel: UILabel!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The “!” in the declaration allows us to use the outlet like this<br>&gt;&gt; without unwrapping it<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; myLabel.text = “Hello&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We use “var” and “UILabel!&quot; because myLabel starts its life out as nil<br>&gt;&gt; and does not have a value until the connection is made. i.e. myLabel must<br>&gt;&gt; be an optional if it accepts nil and the type is UILabel! instead of<br>&gt;&gt; UILabel? so that we don’t have to unwrap it each time we use it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If we break the connection to the UILabel instance we crash at runtime<br>&gt;&gt; for attempting to unwrap nil.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Given this, I propose that we be able to write<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; @IBOutlet weak let myLabel: UILabel<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In this case @IBOutlet has a meaning somewhat similar to lazy - it’s<br>&gt;&gt; not that myLabel doesn’t exist until we first call it, but @IBOutlet<br>&gt;&gt; indicates that myLabel should exist before we call it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If the connection isn’t made and myLabel doesn’t exist, we should crash<br>&gt;&gt; as we do now. If the connection is not made in the nib or storyboard, this<br>&gt;&gt; will crash at development time.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This removes a case in which we use var - not because we want to change<br>&gt;&gt; the value of a property but because of a detail in the tooling.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This change also removes a case in which we use an Optional again for a<br>&gt;&gt; detail in lifecycle and tooling.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Daniel<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/416e2338/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Pitch: Modify the meaning of IBOutlet to remove the ! from the type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>The really nice thing about the &quot;!&quot; operator is that it is always explicit. Either in the variable declaration, or when unwrapping it with &quot;!&quot; or &quot;if let&quot;. &quot;@IBOutlet weak var&quot;s should therefore really not introduce an implicit &quot;!&quot;. It&#39;s just one character, and it&#39;s good to see that this is actually an implicitly unwrapped optional. Furthermore, IOUs are made exactly for the case where you have a variable that *can* not be nil (unless you messed something up), but it cannot be proven by the compiler. If it is not a logic error if you try to use such a variable in code and it is nil, you should use a real optional instead. Furthermore, you can also write &quot;@IBOutlet weak var foo: UIBar?&quot; - both are valid. For example, a view controller can also do stuff if the view is not yet loaded.<br></p><p>and yes, &quot;weak let&quot; would break the semantic meaning of &quot;let&quot;.<br></p><p>I think Optionals are really very very carefully designed already, and provide a simple(, useful) and consistent model. The description of [optionals, &quot;!&quot;, &quot;?&quot;, &quot;if let&quot;, &quot;weak&quot;, &quot;unowned&quot;] can be fully defined in a few sentences, and I&#39;m against anything that just bloats this description without being an essential improvement.<br></p><p>-Michael<br></p><p>&gt; Am 18.05.2016 um 15:42 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Correct me if I&#39;m wrong, but `weak` reference can not be `let` just by definition: at some point in time such reference *can* become nil.<br>&gt; <br>&gt; On 18.05.2016 16:22, Daniel Steinberg via swift-evolution wrote:<br>&gt;&gt; I would like to propose we modify the meaning of @IBOutlet in light of the accepted proposal SE-0054 Abolish ImplicitlyUnwrappedOptional type. I think this fits in with the current Swift 3 goals.<br>&gt;&gt; <br>&gt;&gt; Currently we use “var” and “!” when we declare an outlet like this:<br>&gt;&gt; <br>&gt;&gt; @IBOutlet weak var myLabel: UILabel!<br>&gt;&gt; <br>&gt;&gt; The “!” in the declaration allows us to use the outlet like this without unwrapping it<br>&gt;&gt; <br>&gt;&gt; myLabel.text = “Hello&quot;<br>&gt;&gt; <br>&gt;&gt; We use “var” and “UILabel!&quot; because myLabel starts its life out as nil and does not have a value until the connection is made. i.e. myLabel must be an optional if it accepts nil and the type is UILabel! instead of UILabel? so that we don’t have to unwrap it each time we use it.<br>&gt;&gt; <br>&gt;&gt; If we break the connection to the UILabel instance we crash at runtime for attempting to unwrap nil.<br>&gt;&gt; <br>&gt;&gt; Given this, I propose that we be able to write<br>&gt;&gt; <br>&gt;&gt; @IBOutlet weak let myLabel: UILabel<br>&gt;&gt; <br>&gt;&gt; In this case @IBOutlet has a meaning somewhat similar to lazy - it’s not that myLabel doesn’t exist until we first call it, but @IBOutlet indicates that myLabel should exist before we call it.<br>&gt;&gt; <br>&gt;&gt; If the connection isn’t made and myLabel doesn’t exist, we should crash as we do now. If the connection is not made in the nib or storyboard, this will crash at development time.<br>&gt;&gt; <br>&gt;&gt; This removes a case in which we use var - not because we want to change the value of a property but because of a detail in the tooling.<br>&gt;&gt; <br>&gt;&gt; This change also removes a case in which we use an Optional again for a detail in lifecycle and tooling.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>Pitch: Modify the meaning of IBOutlet to remove the ! from the type</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Within this proposal, would it be still possible to test the variable against nil? <br></p><p>If yes, then it&#39;d be very confusing, since you&#39;d have a variable declared as non-optional, but you&#39;d be comparing it to nil.<br></p><p>If no, this is not correct since the instance can be executing code before the nib file is loaded and the UI elements connected. Which is again a weird situation where you have variables that when accessed, the app crashes, but you can&#39;t check if it&#39;s valid.<br></p><p>The @IBOutlet variables are pretty much just dynamic vars with an extra annotation so that IB knows that they can be connected in the UI. This would be causing the annotation to change the type of the variable which is a matter discussed in another thread here as well.<br></p><p>Krystof<br></p><p>&gt; On May 18, 2016, at 3:22 PM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like to propose we modify the meaning of @IBOutlet in light of the accepted proposal SE-0054 Abolish ImplicitlyUnwrappedOptional type. I think this fits in with the current Swift 3 goals.<br>&gt; <br>&gt; Currently we use “var” and “!” when we declare an outlet like this:<br>&gt; <br>&gt; @IBOutlet weak var myLabel: UILabel!<br>&gt; <br>&gt; The “!” in the declaration allows us to use the outlet like this without unwrapping it<br>&gt; <br>&gt; myLabel.text = “Hello&quot;<br>&gt; <br>&gt; We use “var” and “UILabel!&quot; because myLabel starts its life out as nil and does not have a value until the connection is made. i.e. myLabel must be an optional if it accepts nil and the type is UILabel! instead of UILabel? so that we don’t have to unwrap it each time we use it.<br>&gt; <br>&gt; If we break the connection to the UILabel instance we crash at runtime for attempting to unwrap nil.<br>&gt; <br>&gt; Given this, I propose that we be able to write<br>&gt; <br>&gt; @IBOutlet weak let myLabel: UILabel<br>&gt; <br>&gt; In this case @IBOutlet has a meaning somewhat similar to lazy - it’s not that myLabel doesn’t exist until we first call it, but @IBOutlet indicates that myLabel should exist before we call it. <br>&gt; <br>&gt; If the connection isn’t made and myLabel doesn’t exist, we should crash as we do now. If the connection is not made in the nib or storyboard, this will crash at development time. <br>&gt; <br>&gt; This removes a case in which we use var - not because we want to change the value of a property but because of a detail in the tooling.<br>&gt; <br>&gt; This change also removes a case in which we use an Optional again for a detail in lifecycle and tooling.<br>&gt; <br>&gt; Best,<br>&gt; <br>&gt; Daniel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
