<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>on Sun Jan 10 2016, Davide Italiano via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br></p><p>&gt; Feedback very appreciated.<br>&gt;<br>&gt; Add stableSort() to the standard library.<br>&gt;<br>&gt; ####<br>&gt; Introduction<br>&gt; ####<br>&gt; At the time of writing the Swift standard library provides two way two<br>&gt; different versions of sort.<br>&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt; use only a constant amount of extra space (independent from the input size).<br>&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt; to provide a stable version of sorting.<br></p><p>A few thoughts:<br></p><p>1. The C++ stable sort algorithm draws on just nearly every other<br>   algorithm in the entire standard library, many of which we don&#39;t<br>   currently have in Swift.  Doing something similar would expand the<br>   algorithms we support, which IMO would be a good thing.<br></p><p>2. I am very intrigued with Python&#39;s argument that, for a<br>   general-purpose audience, stable sorting should be the default.  It&#39;s<br>   certainly more widely-useful than unstable sorting.<br></p><p>3. There are several interesting and fast stable sorting algorithms out<br>   there, including Python&#39;s timsort; it would take some experimentation<br>   to discover which one(s) to use for Swift.<br></p><p>4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>   because of the added API complexity.  People who want a<br>   faster-but-unstable sort can call unstableSort, right?<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 to all points<br></p><p>-Thorsten<br></p><p><br>&gt; Am 20.01.2016 um 18:58 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org &lt;http://swift-evolution-m3fhrko0vlzytjvyw6ydsg-at-public.gmane.org/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Feedback very appreciated.<br>&gt;&gt; <br>&gt;&gt; Add stableSort() to the standard library.<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Introduction<br>&gt;&gt; ####<br>&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt; different versions of sort.<br>&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt; to provide a stable version of sorting.<br>&gt; <br>&gt; A few thoughts:<br>&gt; <br>&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt;   algorithms we support, which IMO would be a good thing.<br>&gt; <br>&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt;   certainly more widely-useful than unstable sorting.<br>&gt; <br>&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt;   to discover which one(s) to use for Swift.<br>&gt; <br>&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt;   because of the added API complexity.  People who want a<br>&gt;   faster-but-unstable sort can call unstableSort, right?<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/4f1c95d2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org &lt;http://swift-evolution-m3fhrko0vlzytjvyw6ydsg-at-public.gmane.org/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Feedback very appreciated.<br>&gt;&gt; <br>&gt;&gt; Add stableSort() to the standard library.<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Introduction<br>&gt;&gt; ####<br>&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt; different versions of sort.<br>&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt; to provide a stable version of sorting.<br>&gt; <br>&gt; A few thoughts:<br>&gt; <br>&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt;   algorithms we support, which IMO would be a good thing.<br>&gt; <br>&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt;   certainly more widely-useful than unstable sorting.<br>&gt; <br>&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt;   to discover which one(s) to use for Swift.<br>&gt; <br>&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt;   because of the added API complexity.  People who want a<br>&gt;   faster-but-unstable sort can call unstableSort, right?<br></p><p>I think the potential here is that people might not even be aware there is such an option. unstableSort() not terribly autocomplete friendly which I think adds to complexity. It seems like a parameter would be in line with API’s like print(_:separator:terminator:), even though the print arguments are not constants. I think the print API is very intuitive, but perhaps I’m misunderstanding what you mean by complexity?<br></p><p>Tyler<br></p><p><br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/be41ac64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 20.01.2016 um 21:19 schrieb Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt;&gt;   because of the added API complexity.  People who want a<br>&gt;&gt;   faster-but-unstable sort can call unstableSort, right?<br>&gt; <br>&gt; I think the potential here is that people might not even be aware there is such an option. unstableSort() not terribly autocomplete friendly which I think adds to complexity. It seems like a parameter would be in line with API’s like print(_:separator:terminator:), even though the print arguments are not constants. I think the print API is very intuitive, but perhaps I’m misunderstanding what you mean by complexity?<br></p><p>I would think that for making use of unstableSort() you would have to understand what unstable sorting means in the first place and therefore it’s not unreasonable to expect that people wanting to use an unstable sort for performance reasons would actively look for one and have no problems finding it, especially if the documentation for sort() says „see also: unstableSort()“. The latter would also help other’s not (that) aware of unstable sorting to discover it.<br>But I’m not strongly opposed to a parameter (the default should be .Stable in that case as well, I think). It certainly helps discoverability even more than the docs.<br>Maybe autocomplete should point out alternatives from the „see also“ section of the documentation as well ;-)<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/832c768c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 20, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Jan 20 2016, Tyler Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution<br>&gt;&gt; &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org<br>&gt;<br>&gt;&gt; &lt;http://swift-evolution-m3fhrko0vlzytjvyw6ydsg-at-public.gmane.org/&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Feedback very appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add stableSort() to the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt;&gt; different versions of sort.<br>&gt;&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt;&gt; to provide a stable version of sorting.<br>&gt;&gt; <br>&gt;&gt; A few thoughts:<br>&gt;&gt; <br>&gt;&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt;&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt;&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt;&gt;   algorithms we support, which IMO would be a good thing.<br>&gt;&gt; <br>&gt;&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt;&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt;&gt;   certainly more widely-useful than unstable sorting.<br>&gt;&gt; <br>&gt;&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt;&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt;&gt;   to discover which one(s) to use for Swift.<br>&gt;&gt; <br>&gt;&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt;&gt;   because of the added API complexity.  People who want a<br>&gt;&gt;   faster-but-unstable sort can call unstableSort, right?<br>&gt;<br>&gt; I think the potential here is that people might not even be aware<br>&gt; there is such an option. unstableSort() not terribly autocomplete<br>&gt; friendly which I think adds to complexity. <br></p><p>sortFasterButUnstably, then ;-)<br></p><p>&gt; It seems like a parameter<br>&gt; would be in line with API’s like print(_:separator:terminator:), even<br>&gt; though the print arguments are not constants. I think the print API is<br>&gt; very intuitive, but perhaps I’m misunderstanding what you mean by<br>&gt; complexity?<br></p><p>No, I think you understand me.<br></p><p>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br>&gt; <br>&gt;&gt; Feedback very appreciated.<br>&gt;&gt; <br>&gt;&gt; Add stableSort() to the standard library.<br>&gt;&gt; <br>&gt;&gt; ####<br>&gt;&gt; Introduction<br>&gt;&gt; ####<br>&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt; different versions of sort.<br>&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt; to provide a stable version of sorting.<br>&gt; <br>&gt; A few thoughts:<br>&gt; <br>&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt;   algorithms we support, which IMO would be a good thing.<br>&gt; <br>&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt;   certainly more widely-useful than unstable sorting.<br></p><p>Stable sorting as the default would follow the Principle of Least Astonishment, I think (especially for programmers coming from Python and Java, where stable is the default). And the more widely useful algorithm, even if it is at the expense of performance, seems like the right choice for a standard library.<br></p><p>&gt; <br>&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt;   to discover which one(s) to use for Swift.<br></p><p>I suppose one complication for Swift is that any particular algorithm might perform well with reference types but less so with value types if they happen to be large and the algorithm does a relatively large amount of copying.<br></p><p>&gt; <br>&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt;   because of the added API complexity.  People who want a<br>&gt;   faster-but-unstable sort can call unstableSort, right?<br></p><p>I wonder if anyone actually would be clamoring for an unstable sort option, per se, given how well timsort seems to perform. <br></p><p>An algorithm, stable or unstable, with lower memory requirements or different edge case behavior might be the most useful alternative. For instance, an algorithm that sorts in-place without any significant memory overhead (“in-place&quot; not in the mutating sense, but in not requiring temporary storage during the sort) could be handy when dealing with large sequences on more memory-constrained devices. Still, I wonder if it will really be a pain point for anyone if the only option is a state-of-the-art stable sort.<br></p><p>—CK<br></p><p>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Jan 21 2016, Charles Kissinger &lt;crk-AT-akkyra.com&gt; wrote:<br></p><p>&gt;&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution<br>&gt;&gt; &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Feedback very appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add stableSort() to the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt;&gt;&gt; different versions of sort.<br>&gt;&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt;&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt;&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt;&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt;&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt;&gt;&gt; to provide a stable version of sorting.<br>&gt;&gt; <br>&gt;&gt; A few thoughts:<br>&gt;&gt; <br>&gt;&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt;&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt;&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt;&gt;   algorithms we support, which IMO would be a good thing.<br>&gt;&gt; <br>&gt;&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt;&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt;&gt;   certainly more widely-useful than unstable sorting.<br>&gt;<br>&gt; Stable sorting as the default would follow the Principle of Least<br>&gt; Astonishment, I think (especially for programmers coming from Python<br>&gt; and Java, where stable is the default). And the more widely useful<br>&gt; algorithm, even if it is at the expense of performance, seems like the<br>&gt; right choice for a standard library.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt;&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt;&gt;   to discover which one(s) to use for Swift.<br>&gt;<br>&gt; I suppose one complication for Swift is that any particular algorithm<br>&gt; might perform well with reference types but less so with value types<br>&gt; if they happen to be large and the algorithm does a relatively large<br>&gt; amount of copying.<br></p><p>That&#39;s true, but if that&#39;s the case we could (and should) select the<br>algorithm accordingly.  It&#39;s all statically-knowable, so shouldn&#39;t even<br>cost a branch in practice.<br></p><p>&gt;&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt;&gt;   because of the added API complexity.  People who want a<br>&gt;&gt;   faster-but-unstable sort can call unstableSort, right?<br>&gt;<br>&gt; I wonder if anyone actually would be clamoring for an unstable sort<br>&gt; option, per se, given how well timsort seems to perform.<br></p><p>Maybe not.  If you look around, you&#39;ll find timsort has a handful of<br>competitors we also ought to examine.<br></p><p>&gt; An algorithm, stable or unstable, with lower memory requirements or<br>&gt; different edge case behavior might be the most useful alternative. For<br>&gt; instance, an algorithm that sorts in-place without any significant<br>&gt; memory overhead (“in-place&quot; not in the mutating sense, but in not<br>&gt; requiring temporary storage during the sort) could be handy when<br>&gt; dealing with large sequences on more memory-constrained<br>&gt; devices. <br></p><p>True; that&#39;s what the current algorithm does.<br></p><p>&gt; Still, I wonder if it will really be a pain point for anyone<br>&gt; if the only option is a state-of-the-art stable sort.<br></p><p>A real question.  There&#39;s a lot of research to do, here.  If someone<br>wanted to take on this investigation and do a thorough job of it, I&#39;m<br>sure it would have a big impact.<br></p><p>Cheers,<br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e945bafe2bd7703bdb8383ddcd009ded?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>ankit goel</string> &lt;ankit1ank at gmail.com&gt;<p>January 22, 2016 at 06:00:00pm</p></header><div class="content"><p>Hey,<br></p><p>A single sort function with an enum parameter that let&#39;s you choose among<br>sort(), sortInPlace() and stableSort() would be nice.<br></p><p>enum SortOptions {<br>  case none<br>  case InPlace<br>  case Stable<br>}<br></p><p>func sort(items, type: SortOptions = .none)<br></p><p>// call to sort function<br>sort([1,2,3,4], type: .Stable)<br></p><p>This way a single sort function handles all three cases and enums provide<br>autocompletion while calling the function.<br></p><p><br>On Fri, Jan 22, 2016 at 3:22 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Jan 21 2016, Charles Kissinger &lt;crk-AT-akkyra.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Feedback very appreciated.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Add stableSort() to the standard library.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ####<br>&gt; &gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt; ####<br>&gt; &gt;&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt; &gt;&gt;&gt; different versions of sort.<br>&gt; &gt;&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting<br>&gt; algorithm.<br>&gt; &gt;&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting<br>&gt; with the<br>&gt; &gt;&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e.,<br>&gt; it will<br>&gt; &gt;&gt;&gt; use only a constant amount of extra space (independent from the input<br>&gt; size).<br>&gt; &gt;&gt;&gt; The aim of this proposal is to implement a third variant,<br>&gt; stableSort(), in order<br>&gt; &gt;&gt;&gt; to provide a stable version of sorting.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A few thoughts:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt; &gt;&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt; &gt;&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt; &gt;&gt;   algorithms we support, which IMO would be a good thing.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt; &gt;&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt; &gt;&gt;   certainly more widely-useful than unstable sorting.<br>&gt; &gt;<br>&gt; &gt; Stable sorting as the default would follow the Principle of Least<br>&gt; &gt; Astonishment, I think (especially for programmers coming from Python<br>&gt; &gt; and Java, where stable is the default). And the more widely useful<br>&gt; &gt; algorithm, even if it is at the expense of performance, seems like the<br>&gt; &gt; right choice for a standard library.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt; &gt;&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt; &gt;&gt;   to discover which one(s) to use for Swift.<br>&gt; &gt;<br>&gt; &gt; I suppose one complication for Swift is that any particular algorithm<br>&gt; &gt; might perform well with reference types but less so with value types<br>&gt; &gt; if they happen to be large and the algorithm does a relatively large<br>&gt; &gt; amount of copying.<br>&gt;<br>&gt; That&#39;s true, but if that&#39;s the case we could (and should) select the<br>&gt; algorithm accordingly.  It&#39;s all statically-knowable, so shouldn&#39;t even<br>&gt; cost a branch in practice.<br>&gt;<br>&gt; &gt;&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt; &gt;&gt;   because of the added API complexity.  People who want a<br>&gt; &gt;&gt;   faster-but-unstable sort can call unstableSort, right?<br>&gt; &gt;<br>&gt; &gt; I wonder if anyone actually would be clamoring for an unstable sort<br>&gt; &gt; option, per se, given how well timsort seems to perform.<br>&gt;<br>&gt; Maybe not.  If you look around, you&#39;ll find timsort has a handful of<br>&gt; competitors we also ought to examine.<br>&gt;<br>&gt; &gt; An algorithm, stable or unstable, with lower memory requirements or<br>&gt; &gt; different edge case behavior might be the most useful alternative. For<br>&gt; &gt; instance, an algorithm that sorts in-place without any significant<br>&gt; &gt; memory overhead (“in-place&quot; not in the mutating sense, but in not<br>&gt; &gt; requiring temporary storage during the sort) could be handy when<br>&gt; &gt; dealing with large sequences on more memory-constrained<br>&gt; &gt; devices.<br>&gt;<br>&gt; True; that&#39;s what the current algorithm does.<br>&gt;<br>&gt; &gt; Still, I wonder if it will really be a pain point for anyone<br>&gt; &gt; if the only option is a state-of-the-art stable sort.<br>&gt;<br>&gt; A real question.  There&#39;s a lot of research to do, here.  If someone<br>&gt; wanted to take on this investigation and do a thorough job of it, I&#39;m<br>&gt; sure it would have a big impact.<br>&gt;<br>&gt; Cheers,<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/6d9c32b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>Add stableSort() to the standard library.</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 22, 2016 at 11:00:00am</p></header><div class="content"><p>This seems interesting, simple and clean. Also, this kinda reminds me of the Strategy Pattern &lt;https://en.wikipedia.org/wiki/Strategy_pattern&gt;:<br></p><p>protocol SortingStrategy { /* declare `sort()` */ }<br></p><p>class StableSort: SortingStrategy { /* implement a stable `sort()` */ }<br></p><p>class UnstableSort: SortingStrategy { /* implement a unstable `sort()` */ }<br></p><p>class Sorter {<br></p><p>    let strategy: SortingStrategy<br></p><p>    init(using strategy: SortingStrategy) { self.strategy = strategy }<br></p><p>    func sort( /* ... */ ) { return self.strategy.sort( /* ... */ ) }<br>}<br></p><p>let stableSort = Sorter(using: StableSort())<br>stableSort.sort( /* ... */ )<br></p><p>let unstableSort = Sorter(using: UnstableSort())<br>unstableSort.sort( /* ... */ )<br></p><p>One could go further and, instead of `StableSort` and `UnstableSort`, provide different options of sorting algorithms:<br></p><p>class IntroSort: SortingStrategy { /* intro sort implementation */ }<br>class QuickSort: SortingStrategy { /* quick sort implementation */ }<br>class MergeSort: SortingStrategy { /* merge sort implementation */ }<br>// ...<br></p><p>Not sure, however, if having those in the language itself would be make sense. Perhaps a separate library would be a better place.<br></p><p>Wonder if using protocol with default implementations above, rather than classes, would’ve been better...<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jan 22, 2016, at 8:03 AM, ankit goel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey,<br>&gt; <br>&gt; A single sort function with an enum parameter that let&#39;s you choose among sort(), sortInPlace() and stableSort() would be nice.<br>&gt; <br>&gt; enum SortOptions {<br>&gt;   case none<br>&gt;   case InPlace<br>&gt;   case Stable<br>&gt; }<br>&gt; <br>&gt; func sort(items, type: SortOptions = .none)<br>&gt; <br>&gt; // call to sort function<br>&gt; sort([1,2,3,4], type: .Stable)<br>&gt; <br>&gt; This way a single sort function handles all three cases and enums provide autocompletion while calling the function.<br>&gt; <br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 3:22 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; on Thu Jan 21 2016, Charles Kissinger &lt;crk-AT-akkyra.com&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Jan 20, 2016, at 9:58 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Sun Jan 10 2016, Davide Italiano via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org &lt;http://swift-evolution-m3fhrko0vlzytjvyw6ydsg-at-public.gmane.org/&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Feedback very appreciated.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Add stableSort() to the standard library.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ####<br>&gt; &gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt; ####<br>&gt; &gt;&gt;&gt; At the time of writing the Swift standard library provides two way two<br>&gt; &gt;&gt;&gt; different versions of sort.<br>&gt; &gt;&gt;&gt; The first one is sort(), which provides a regular unstable[1] sorting algorithm.<br>&gt; &gt;&gt;&gt; The second one, sortInPlace(), which also provides unstable sorting with the<br>&gt; &gt;&gt;&gt; additional guarantee that the algorithm will operate in-place, i.e., it will<br>&gt; &gt;&gt;&gt; use only a constant amount of extra space (independent from the input size).<br>&gt; &gt;&gt;&gt; The aim of this proposal is to implement a third variant, stableSort(), in order<br>&gt; &gt;&gt;&gt; to provide a stable version of sorting.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A few thoughts:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1. The C++ stable sort algorithm draws on just nearly every other<br>&gt; &gt;&gt;   algorithm in the entire standard library, many of which we don&#39;t<br>&gt; &gt;&gt;   currently have in Swift.  Doing something similar would expand the<br>&gt; &gt;&gt;   algorithms we support, which IMO would be a good thing.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2. I am very intrigued with Python&#39;s argument that, for a<br>&gt; &gt;&gt;   general-purpose audience, stable sorting should be the default.  It&#39;s<br>&gt; &gt;&gt;   certainly more widely-useful than unstable sorting.<br>&gt; &gt;<br>&gt; &gt; Stable sorting as the default would follow the Principle of Least<br>&gt; &gt; Astonishment, I think (especially for programmers coming from Python<br>&gt; &gt; and Java, where stable is the default). And the more widely useful<br>&gt; &gt; algorithm, even if it is at the expense of performance, seems like the<br>&gt; &gt; right choice for a standard library.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3. There are several interesting and fast stable sorting algorithms out<br>&gt; &gt;&gt;   there, including Python&#39;s timsort; it would take some experimentation<br>&gt; &gt;&gt;   to discover which one(s) to use for Swift.<br>&gt; &gt;<br>&gt; &gt; I suppose one complication for Swift is that any particular algorithm<br>&gt; &gt; might perform well with reference types but less so with value types<br>&gt; &gt; if they happen to be large and the algorithm does a relatively large<br>&gt; &gt; amount of copying.<br>&gt; <br>&gt; That&#39;s true, but if that&#39;s the case we could (and should) select the<br>&gt; algorithm accordingly.  It&#39;s all statically-knowable, so shouldn&#39;t even<br>&gt; cost a branch in practice.<br>&gt; <br>&gt; &gt;&gt; 4. I&#39;m not a fan of adding a parameter to sort to select stability,<br>&gt; &gt;&gt;   because of the added API complexity.  People who want a<br>&gt; &gt;&gt;   faster-but-unstable sort can call unstableSort, right?<br>&gt; &gt;<br>&gt; &gt; I wonder if anyone actually would be clamoring for an unstable sort<br>&gt; &gt; option, per se, given how well timsort seems to perform.<br>&gt; <br>&gt; Maybe not.  If you look around, you&#39;ll find timsort has a handful of<br>&gt; competitors we also ought to examine.<br>&gt; <br>&gt; &gt; An algorithm, stable or unstable, with lower memory requirements or<br>&gt; &gt; different edge case behavior might be the most useful alternative. For<br>&gt; &gt; instance, an algorithm that sorts in-place without any significant<br>&gt; &gt; memory overhead (“in-place&quot; not in the mutating sense, but in not<br>&gt; &gt; requiring temporary storage during the sort) could be handy when<br>&gt; &gt; dealing with large sequences on more memory-constrained<br>&gt; &gt; devices.<br>&gt; <br>&gt; True; that&#39;s what the current algorithm does.<br>&gt; <br>&gt; &gt; Still, I wonder if it will really be a pain point for anyone<br>&gt; &gt; if the only option is a state-of-the-art stable sort.<br>&gt; <br>&gt; A real question.  There&#39;s a lot of research to do, here.  If someone<br>&gt; wanted to take on this investigation and do a thorough job of it, I&#39;m<br>&gt; sure it would have a big impact.<br>&gt; <br>&gt; Cheers,<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/e43cee06/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
