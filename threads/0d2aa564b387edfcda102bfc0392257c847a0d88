<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 08:00:00pm</p></header><div class="content"><p>I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Can you directly pass arguments to the function crossing the ABI boundary, and can you directly access them on the other side? If so, what you can do is simply synthesize arguments that cross the full range of the bit-representation of the argument types, and validate that you see the same range on the other side.<br></p><p>I don&#39;t know anything about what this interface looks like so I don&#39;t have more specific ideas, but if you can give me a little more context I&#39;ve worked on this in the past...<br></p><p>Technically you can&#39;t necessarily compare the LLVM IR, since there are ways to represent the same ABI call with different #s of IR arguments in corner cases.<br></p><p> - Daniel<br></p><p>&gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ef689a9f25009bea0126bb577a86c41f?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>Flamedoge</string> &lt;code.kchoi at gmail.com&gt;<p>October 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; getting the ABI slightly wrong<br></p><p>Does this call for something like a validation pass? It would seem<br>appropriate to apply it to SIL and not LLVM IR since it&#39;s inter-language<br>ABI specific to Swift frontend.<br></p><p>On Tue, Oct 11, 2016 at 8:17 PM, Daniel Dunbar via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Can you directly pass arguments to the function crossing the ABI boundary,<br>&gt; and can you directly access them on the other side? If so, what you can do<br>&gt; is simply synthesize arguments that cross the full range of the<br>&gt; bit-representation of the argument types, and validate that you see the<br>&gt; same range on the other side.<br>&gt;<br>&gt; I don&#39;t know anything about what this interface looks like so I don&#39;t have<br>&gt; more specific ideas, but if you can give me a little more context I&#39;ve<br>&gt; worked on this in the past...<br>&gt;<br>&gt; Technically you can&#39;t necessarily compare the LLVM IR, since there are<br>&gt; ways to represent the same ABI call with different #s of IR arguments in<br>&gt; corner cases.<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt; &gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I just tracked down a bug due to C++ code in the Swift runtime code<br>&gt; trying to interface with standard library code written in Swift, but<br>&gt; getting the ABI slightly wrong and leading to some nasty hard-to-reproduce<br>&gt; heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it<br>&gt; seems like this is a potentially continuing source of maintenance bugs,<br>&gt; especially as we try to bring up the Swift calling convention in the coming<br>&gt; year. I&#39;m wondering if there&#39;s anything we could do to help validate that<br>&gt; C++ and Swift code in the runtime is correctly interfacing. We could at<br>&gt; least check that we&#39;re passing the right number of arguments by comparing<br>&gt; the LLVM IR of the runtime and stdlib, perhaps, though this would have to<br>&gt; be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to<br>&gt; agree on the exact pointer types of arguments.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161012/f9b4c899/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br></p><p>One potential approach:  make a def file with the names and (somehow abstracted) expected prototypes of Swift functions defined by the standard library but used by the runtime.  In the runtime, use that to autogenerate a header.  In IRGen, add a +Asserts check before finalizing the module that, if there are any functions with those names, they do match the abstract prototypes.  Hope that all such interactions use only portable IRGen call-lowering patterns.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>October 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 11:11 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br>&gt; <br>&gt; One potential approach:  make a def file with the names and (somehow abstracted) expected prototypes of Swift functions defined by the standard library but used by the runtime.  In the runtime, use that to autogenerate a header.  In IRGen, add a +Asserts check before finalizing the module that, if there are any functions with those names, they do match the abstract prototypes.  Hope that all such interactions use only portable IRGen call-lowering patterns.<br></p><p>Or perhaps have a swiftc mode that generates a C prototype for every function marked with @_silgen_name, and use that to build an autogenerated C header. (I.e., skip the def file and use the swift file as the canonical description.)<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161012/ff7d787d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 3:46 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt; On Oct 12, 2016, at 11:11 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br>&gt;&gt; <br>&gt;&gt; One potential approach:  make a def file with the names and (somehow abstracted) expected prototypes of Swift functions defined by the standard library but used by the runtime.  In the runtime, use that to autogenerate a header.  In IRGen, add a +Asserts check before finalizing the module that, if there are any functions with those names, they do match the abstract prototypes.  Hope that all such interactions use only portable IRGen call-lowering patterns.<br>&gt; <br>&gt; Or perhaps have a swiftc mode that generates a C prototype for every function marked with @_silgen_name, and use that to build an autogenerated C header. (I.e., skip the def file and use the swift file as the canonical description.)<br></p><p>That&#39;s nice in theory, but it creates a build dependency between the C++ and Swift sources wherever we want to do this.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161012/7328918a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 4:36 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 3:46 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 12, 2016, at 11:11 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One potential approach:  make a def file with the names and (somehow abstracted) expected prototypes of Swift functions defined by the standard library but used by the runtime.  In the runtime, use that to autogenerate a header.  In IRGen, add a +Asserts check before finalizing the module that, if there are any functions with those names, they do match the abstract prototypes.  Hope that all such interactions use only portable IRGen call-lowering patterns.<br>&gt;&gt; <br>&gt;&gt; Or perhaps have a swiftc mode that generates a C prototype for every function marked with @_silgen_name, and use that to build an autogenerated C header. (I.e., skip the def file and use the swift file as the canonical description.)<br>&gt; <br>&gt; That&#39;s nice in theory, but it creates a build dependency between the C++ and Swift sources wherever we want to do this.<br></p><p>I have not thought about the build dependency issue, but just off the top of my head, using it for building seems unnecessary. That is we could instead of using the autogenerated C header file for compilation, just generate those files for testing purposes. Then we could still use the .def file normally, but could at least have a bot that checks that things are correct.<br></p><p>I am not sure if there is a clang mode for diffing/comparing declarations like these though.<br></p><p>Michael<br></p><p>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/7d060e4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Validating ABI consistency between runtime C++ and standard library Swift code</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 9:30 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; On Oct 12, 2016, at 4:36 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 12, 2016, at 3:46 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 12, 2016, at 11:11 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 8:10 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I just tracked down a bug due to C++ code in the Swift runtime code trying to interface with standard library code written in Swift, but getting the ABI slightly wrong and leading to some nasty hard-to-reproduce heisenbugs. While I&#39;ve narrowed down the bug in this specific case, it seems like this is a potentially continuing source of maintenance bugs, especially as we try to bring up the Swift calling convention in the coming year. I&#39;m wondering if there&#39;s anything we could do to help validate that C++ and Swift code in the runtime is correctly interfacing. We could at least check that we&#39;re passing the right number of arguments by comparing the LLVM IR of the runtime and stdlib, perhaps, though this would have to be a fuzzy type-level match since Clang and Swift aren&#39;t normally going to agree on the exact pointer types of arguments.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One potential approach:  make a def file with the names and (somehow abstracted) expected prototypes of Swift functions defined by the standard library but used by the runtime.  In the runtime, use that to autogenerate a header.  In IRGen, add a +Asserts check before finalizing the module that, if there are any functions with those names, they do match the abstract prototypes.  Hope that all such interactions use only portable IRGen call-lowering patterns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or perhaps have a swiftc mode that generates a C prototype for every function marked with @_silgen_name, and use that to build an autogenerated C header. (I.e., skip the def file and use the swift file as the canonical description.)<br>&gt;&gt; <br>&gt;&gt; That&#39;s nice in theory, but it creates a build dependency between the C++ and Swift sources wherever we want to do this.<br>&gt; <br>&gt; I have not thought about the build dependency issue, but just off the top of my head, using it for building seems unnecessary. That is we could instead of using the autogenerated C header file for compilation, just generate those files for testing purposes. Then we could still use the .def file normally, but could at least have a bot that checks that things are correct.<br>&gt; <br>&gt; I am not sure if there is a clang mode for diffing/comparing declarations like these though.<br></p><p>If we have to have a .def file, just consuming it for assertions in IRGen seems like the way to go.<br></p><p>John.<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/bc313263/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
