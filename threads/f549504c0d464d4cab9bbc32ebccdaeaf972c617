<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>June 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>This is a great proposal which was sorely needed, so I strongly support it<br>in general. I have a few comments and suggestions to make.<br></p><p><br>First of all, a bit of background to explain where I&#39;m coming from: in the<br>past weeks I have been working for educational purposes on a Rational&lt;T:<br>SignedInteger&gt; type. This is one of those things that seem trivial at first<br>sight, but are surprisingly difficult to do right. Thoroughly testing and<br>avoiding traps or incorrect results in edge cases was a lot of work.<br>I have now updated my code to use the new interfaces described in the<br>proposal, and I was able to remove a lot of custom protocols and<br>boilerplate. So it was a net improvement.<br></p><p><br>The first comment I have to make is that, as has already been noted by plx,<br>the Arithmetic protocol looks like a &quot;bag of syntax&quot; with loose semantics<br>attached. It will be used by signed integers, unsigned integers (naturals),<br>floating point numbers; and is an obvious conformance for a Rational type as<br>well.<br>In the proposal, there is no indication of the expected semantics of the<br>four basic operations.<br>- Are addition and multiplication commutative?<br>- Is multiplication distributive over addition?<br>- Is &#39;rhs != 0&#39; a precondition for division?<br>- Presumably associativity must match the associativity of the operators.<br>- What is (a / b) * b?<br>- Is T(exactly: n) * x guaranteed to be == (x + ... + x) n times?<br></p><p>While this protocol is useful to simplify the implementation of operators,<br>it might be largely superseded by other improvements related to SE-0091.<br>Taken alone, I&#39;m not sure it pulls its own weight.<br></p><p>For example say I wanted to write some generic code using values that<br>represent probabilities. I would need arithmetic to work on such values, but<br>since probabilities are strictly in the interval [0.0, 1.0], integers would<br>be useless. I could make the code generic over FloatingPoint, but a Rational<br>type would fit the bill as well, and guarantee accuracy. So to write<br>meaningful generic code I&#39;d need a different protocol, one that made more<br>promises about the semantics of division.<br></p><p><br>Now about the AbsoluteValue associatedtype, which several other people have<br>already shown doubts about.<br>I found it useful, precisely for the reason stated in the proposal<br>(generating the description of a Rational). However, it seems to be mostly<br>an implementation detail, used to:<br>1) work around the fact that -Int.min isn&#39;t representable in two&#39;s complement;<br>2) provide a way to get the unsigned version of an integer type, to be used<br>by the doubleWidthMultiply() return type.<br></p><p>These uses suggest that the Integer protocol might not be the best place for<br>this associatedtype: both of the use cases above would not apply to a<br>BigInt. It seems more appropriate for it to be part of FixedWidthInteger.<br>It might even make sense to rename it UnsignedSelf, to make it clear that<br>it&#39;s intended to be the unsigned equivalent of Self.<br></p><p><br>I also join Karoly&#39;s request for double-width division operations. In<br>particular I would suggest:<br></p><p>static func doubleWidthDivideWithOverflow(_ lhs: (high: Self, low:<br>AbsoluteValue), by rhs: Self) -&gt; (partialValue: Self, overflow:<br>ArithmeticOverflow)<br></p><p>static func doubleWidthRemainder(_ lhs: (high: Self, low: AbsoluteValue), by<br>rhs: Self) -&gt; Self<br></p><p>Note that I needed to use static members here, because the first argument of<br>the division is not Self. Alternatively, the result of doubleWidthMultiply()<br>could be a struct, so that double-width division operations could be members<br>of that struct.<br></p><p>These operations are difficult to implement, and are very useful.<br></p><p>In my specific use case of Rational, addition is the trickiest operation to<br>implement because it can have transient overflows, which get simplified in<br>the final result. To handle them, I need to do two double-width multiplies,<br>followed by a double-width addition (which is easily implemented without<br>explicit support from the standard library). Then I need a double-width<br>remainder to compute the GCD, and finally an overflowing double-width<br>division to attempt fitting the result in a single-width numerator.<br></p><p>Without support for double-width division, the proposal falls short of being<br>really useful for this kind of operations.<br></p><p><br>Finally, I don&#39;t understand this example, which is also repeated twice in<br>the proposal. Is it perhaps a copy&amp;paste error?<br></p><p>public struct Int8 {<br>  public func addingWithOverflow(_ rhs: DoubleWidth&lt;T&gt;)<br>    -&gt; (partialValue: DoubleWidth&lt;T&gt;, overflow: ArithmeticOverflow) {<br>    // efficient implementation<br>  }<br>}<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Absolutely. Working with integer types in generic code is currently one of<br>the most frustrating experiences in Swift. The proposal should address most<br>of the common issues.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very well. The new protocols are much more consistent and cohesive than the<br>status quo.<br></p><p>&gt; * If you have used other languages or libraries with a similar feature,<br>how do you feel that this proposal compares to those?<br></p><p>I haven&#39;t.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>Many hours of experience with the current IntegerArithmetic hierarchy,<br>carefully read all the discussion, and used the new semantics in real code<br>obtaining significant improvements.<br></p><p>Thanks,<br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>June 27, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 2016-06-25, at 14:23, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The first comment I have to make is that, as has already been noted by plx,<br>&gt; the Arithmetic protocol looks like a &quot;bag of syntax&quot; with loose semantics<br>&gt; attached. It will be used by signed integers, unsigned integers (naturals),<br>&gt; floating point numbers; and is an obvious conformance for a Rational type as<br>&gt; well.<br>&gt; In the proposal, there is no indication of the expected semantics of the<br>&gt; four basic operations.<br>&gt; - Are addition and multiplication commutative?<br>&gt; - Is multiplication distributive over addition?<br>&gt; - Is &#39;rhs != 0&#39; a precondition for division?<br>&gt; - Presumably associativity must match the associativity of the operators.<br>&gt; - What is (a / b) * b?<br>&gt; - Is T(exactly: n) * x guaranteed to be == (x + ... + x) n times?<br></p><p>I’m not sure if this has been mentioned yet, but the semantics of Integer operations also needs to be tied down. In particular, the expected behavior of the remainder operation (in all forms) when given a negative numerator and/or denumerator should be explicitly spelled out.<br></p><p>&gt; Now about the AbsoluteValue associatedtype, which several other people have<br>&gt; already shown doubts about.<br>&gt; I found it useful, precisely for the reason stated in the proposal<br>&gt; (generating the description of a Rational). However, it seems to be mostly<br>&gt; an implementation detail, used to:<br>&gt; 1) work around the fact that -Int.min isn&#39;t representable in two&#39;s complement;<br>&gt; 2) provide a way to get the unsigned version of an integer type, to be used<br>&gt; by the doubleWidthMultiply() return type.<br>&gt; <br>&gt; These uses suggest that the Integer protocol might not be the best place for<br>&gt; this associatedtype: both of the use cases above would not apply to a<br>&gt; BigInt. It seems more appropriate for it to be part of FixedWidthInteger.<br>&gt; It might even make sense to rename it UnsignedSelf, to make it clear that<br>&gt; it&#39;s intended to be the unsigned equivalent of Self.<br></p><p>I think absoluteValue would be a better fit in SignedInteger or SignedArithmetic. But if implementation experience suggests it should be in Integer, I don’t mind including AbsoluteValue as an alias to Self (or BigUInt) in the BigInt case.<br></p><p>I’m also a bit suspicious of Integer&#39;s static isSigned property. What is its intended usecase? Why do we need it, given that we also have SignedInteger/UnsignedInteger protocols? (Does it ever make sense to implement Integer without also implementing SignedInteger or UnsignedInteger?)<br></p><p>&gt; I also join Karoly&#39;s request for double-width division operations. In<br>&gt; particular I would suggest:<br>&gt; <br>&gt; static func doubleWidthDivideWithOverflow(_ lhs: (high: Self, low:<br>&gt; AbsoluteValue), by rhs: Self) -&gt; (partialValue: Self, overflow:<br>&gt; ArithmeticOverflow)<br>&gt; <br>&gt; static func doubleWidthRemainder(_ lhs: (high: Self, low: AbsoluteValue), by<br>&gt; rhs: Self) -&gt; Self<br>&gt; <br>&gt; Note that I needed to use static members here, because the first argument of<br>&gt; the division is not Self. Alternatively, the result of doubleWidthMultiply()<br>&gt; could be a struct, so that double-width division operations could be members<br>&gt; of that struct.<br></p><p>I suggest to combine generation of the quotient and remainder into a single division operation. (The implementations I know of provide both, so it makes sense to combine them.)<br></p><p>    static func doubleWidthDivide(_ numerator: (high: Self, low: AbsoluteValue), by denumerator: Self) -&gt; (partialQuotient: Self, remainder: Self, overflow: ArithmeticOverflow)<br></p><p>A more spoon-feeding name would be “doubleWidthQuotientAndRemainderWithOverflow(dividing:, by:)”, but yuck.<br></p><p>(I’d personally also be fine with simplifying this by requiring that the division not overflow, i.e., that lhs.high &lt; rhs (assuming rhs &gt; 0), and treating overflow as a precondition failure. I know Rational&#39;s addition needs to handle overflow, but perhaps it would be OK to move this check outside the function? I imagine the code is already full of branches like that.)<br></p><p>    static func doubleWidthDivide(_ numerator: (high: Self, low: AbsoluteValue), by denumerator: Self) -&gt; (quotient: Self, remainder: Self)<br></p><p>&gt; These operations are difficult to implement, and are very useful.<br></p><p>The difficulty of their implementation might be a problem for people who want to implement FixedWidthInteger outside stdlib, but don’t care about supporting bignums or rationals. (Is that usecase desirable?) I think it would be possible to provide a divide-n-conquer default implementation for double-width division and multiplication, like the code I linked to earlier. However, without support for splitting a FixedWidthInteger into two narrower halves, the code for this would have to use nthWord, which would essentially involve implementing half of a bigint library. :-/<br></p><p>-- <br>Karoly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 6:38 PM, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not sure if this has been mentioned yet, but the semantics of Integer operations also needs to be tied down. In particular, the expected behavior of the remainder operation (in all forms) when given a negative numerator and/or denumerator should be explicitly spelled out.<br></p><p>It may not be clearly documented in the stdlib (I haven’t checked), but it definitely *is* tied down.  Swift using truncating division, and remainder is defined to satisfy the usual definition of division:<br></p><p>	a = (a/b)*b + (a%b)<br></p><p>In particular, this means that if r = a%b, sign(r) == sign(a), and abs(r) &lt; abs(b).<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/eee946a8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Jun 27, 2016 at 12:38 AM, Károly Lőrentey &lt;karoly at lorentey.hu&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On 2016-06-25, at 14:23, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; The first comment I have to make is that, as has already been noted by<br>&gt; plx,<br>&gt; &gt; the Arithmetic protocol looks like a &quot;bag of syntax&quot; with loose semantics<br>&gt; &gt; attached. It will be used by signed integers, unsigned integers<br>&gt; (naturals),<br>&gt; &gt; floating point numbers; and is an obvious conformance for a Rational<br>&gt; type as<br>&gt; &gt; well.<br>&gt; &gt; In the proposal, there is no indication of the expected semantics of the<br>&gt; &gt; four basic operations.<br>&gt; &gt; - Are addition and multiplication commutative?<br>&gt; &gt; - Is multiplication distributive over addition?<br>&gt; &gt; - Is &#39;rhs != 0&#39; a precondition for division?<br>&gt; &gt; - Presumably associativity must match the associativity of the operators.<br>&gt; &gt; - What is (a / b) * b?<br>&gt; &gt; - Is T(exactly: n) * x guaranteed to be == (x + ... + x) n times?<br>&gt;<br>&gt; I’m not sure if this has been mentioned yet, but the semantics of Integer<br>&gt; operations also needs to be tied down. In particular, the expected behavior<br>&gt; of the remainder operation (in all forms) when given a negative numerator<br>&gt; and/or denumerator should be explicitly spelled out.<br>&gt;<br>&gt; &gt; Now about the AbsoluteValue associatedtype, which several other people<br>&gt; have<br>&gt; &gt; already shown doubts about.<br>&gt; &gt; I found it useful, precisely for the reason stated in the proposal<br>&gt; &gt; (generating the description of a Rational). However, it seems to be<br>&gt; mostly<br>&gt; &gt; an implementation detail, used to:<br>&gt; &gt; 1) work around the fact that -Int.min isn&#39;t representable in two&#39;s<br>&gt; complement;<br>&gt; &gt; 2) provide a way to get the unsigned version of an integer type, to be<br>&gt; used<br>&gt; &gt; by the doubleWidthMultiply() return type.<br>&gt; &gt;<br>&gt; &gt; These uses suggest that the Integer protocol might not be the best place<br>&gt; for<br>&gt; &gt; this associatedtype: both of the use cases above would not apply to a<br>&gt; &gt; BigInt. It seems more appropriate for it to be part of FixedWidthInteger.<br>&gt; &gt; It might even make sense to rename it UnsignedSelf, to make it clear that<br>&gt; &gt; it&#39;s intended to be the unsigned equivalent of Self.<br>&gt;<br>&gt; I think absoluteValue would be a better fit in SignedInteger or<br>&gt; SignedArithmetic. But if implementation experience suggests it should be in<br>&gt; Integer, I don’t mind including AbsoluteValue as an alias to Self (or<br>&gt; BigUInt) in the BigInt case.<br>&gt;<br></p><p>AbsoluteValue is currently part of the signature of doubleWidthMultiply()<br>in FixedWidthInteger. I suppose that moving it to SignedInteger would<br>require having FixedWithSignedInteger and FixedWidthUnsignedInteger, with<br>different signatures for the function.<br></p><p><br>&gt;<br>&gt; I’m also a bit suspicious of Integer&#39;s static isSigned property. What is<br>&gt; its intended usecase? Why do we need it, given that we also have<br>&gt; SignedInteger/UnsignedInteger protocols? (Does it ever make sense to<br>&gt; implement Integer without also implementing SignedInteger or<br>&gt; UnsignedInteger?)<br>&gt;<br>&gt; &gt; I also join Karoly&#39;s request for double-width division operations. In<br>&gt; &gt; particular I would suggest:<br>&gt; &gt;<br>&gt; &gt; static func doubleWidthDivideWithOverflow(_ lhs: (high: Self, low:<br>&gt; &gt; AbsoluteValue), by rhs: Self) -&gt; (partialValue: Self, overflow:<br>&gt; &gt; ArithmeticOverflow)<br>&gt; &gt;<br>&gt; &gt; static func doubleWidthRemainder(_ lhs: (high: Self, low:<br>&gt; AbsoluteValue), by<br>&gt; &gt; rhs: Self) -&gt; Self<br>&gt; &gt;<br>&gt; &gt; Note that I needed to use static members here, because the first<br>&gt; argument of<br>&gt; &gt; the division is not Self. Alternatively, the result of<br>&gt; doubleWidthMultiply()<br>&gt; &gt; could be a struct, so that double-width division operations could be<br>&gt; members<br>&gt; &gt; of that struct.<br>&gt;<br>&gt; I suggest to combine generation of the quotient and remainder into a<br>&gt; single division operation. (The implementations I know of provide both, so<br>&gt; it makes sense to combine them.)<br>&gt;<br>&gt;     static func doubleWidthDivide(_ numerator: (high: Self, low:<br>&gt; AbsoluteValue), by denumerator: Self) -&gt; (partialQuotient: Self, remainder:<br>&gt; Self, overflow: ArithmeticOverflow)<br>&gt;<br>&gt; A more spoon-feeding name would be<br>&gt; “doubleWidthQuotientAndRemainderWithOverflow(dividing:, by:)”, but yuck.<br>&gt;<br></p><p>If it&#39;s guaranteed to be free, no objections. I separated them because in<br>one case I need the quotient and not the remainder, and in another case the<br>opposite.<br></p><p><br>&gt; (I’d personally also be fine with simplifying this by requiring that the<br>&gt; division not overflow, i.e., that lhs.high &lt; rhs (assuming rhs &gt; 0), and<br>&gt; treating overflow as a precondition failure. I know Rational&#39;s addition<br>&gt; needs to handle overflow, but perhaps it would be OK to move this check<br>&gt; outside the function? I imagine the code is already full of branches like<br>&gt; that.)<br>&gt;<br></p><p>When the divisor is positive the check is simple, but as we have seen with<br>the edge case Int.min / -1, when the divisor is negative things get a lot<br>more complicated. So I think it&#39;s better to leave the check in the library,<br>allowing it to take advantage of hardware support.<br></p><p><br>&gt;     static func doubleWidthDivide(_ numerator: (high: Self, low:<br>&gt; AbsoluteValue), by denumerator: Self) -&gt; (quotient: Self, remainder: Self)<br>&gt;<br>&gt; &gt; These operations are difficult to implement, and are very useful.<br>&gt;<br>&gt; The difficulty of their implementation might be a problem for people who<br>&gt; want to implement FixedWidthInteger outside stdlib, but don’t care about<br>&gt; supporting bignums or rationals. (Is that usecase desirable?) I think it<br>&gt; would be possible to provide a divide-n-conquer default implementation for<br>&gt; double-width division and multiplication, like the code I linked to<br>&gt; earlier. However, without support for splitting a FixedWidthInteger into<br>&gt; two narrower halves, the code for this would have to use nthWord, which<br>&gt; would essentially involve implementing half of a bigint library. :-/<br>&gt;<br>&gt; --<br>&gt; Karoly<br>&gt; @lorentey<br>&gt;<br>&gt;<br>Nicola<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/02f3ba98/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
