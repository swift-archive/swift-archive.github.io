<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>It&#39;s sometimes useful to get the first element of a sequence. To that<br>end I&#39;d like to propose<br></p><p>extension SequenceType {<br></p><p>/// Returns the first element of `self`, or `nil` if `self` is empty.<br></p><p>/// - Complexity: O(1)<br></p><p>var first: Self.Generator.Element? {<br></p><p>var gen = generate()<br></p><p>return gen.next()<br></p><p>}<br></p><p>}<br></p><p><br></p><p>I think it makes sense to add this property to the definition of<br>SequenceType as well, so various sequences can override it to avoid<br>constructing a generator.<br></p><p>With this added to SequenceType, we can remove it from CollectionType,<br>as the behavior will be the same.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a9d92176/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>Users who don’t get the single-pass nature of SequenceType may expect a .last as well.<br></p><p>&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s sometimes useful to get the first element of a sequence. To that end I&#39;d like to propose<br>&gt;  <br>&gt; extension SequenceType {<br>&gt;     /// Returns the first element of `self`, or `nil` if `self` is empty.<br>&gt;     /// - Complexity: O(1)<br>&gt;     var first: Self.Generator.Element? {<br>&gt;         var gen = generate()<br>&gt;         return gen.next()<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; I think it makes sense to add this property to the definition of SequenceType as well, so various sequences can override it to avoid constructing a generator.<br>&gt;  <br>&gt; With this added to SequenceType, we can remove it from CollectionType, as the behavior will be the same.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/4a42de4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>We already don&#39;t have a .last on CollectionType and nobody&#39;s been<br>complaining about that. Besides, sequences don&#39;t necessarily even<br>terminate.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt; Users who don’t get the single-pass nature of SequenceType may expect<br>&gt; a .last as well.<br>&gt;<br>&gt;&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It&#39;s sometimes useful to get the first element of a sequence. To that<br>&gt;&gt; end I&#39;d like to propose<br>&gt;&gt;<br>&gt;&gt; extensionSequenceType { /// Returns the first element of<br>&gt;&gt; `self`, or `nil` if `self` is empty. /// - Complexity: O(1) var<br>&gt;&gt; first: Self.Generator.Element? { var gen = generate() return<br>&gt;&gt; gen.next()    } }<br>&gt;&gt;<br>&gt;&gt; I think it makes sense to add this property to the definition of<br>&gt;&gt; SequenceType as well, so various sequences can override it to avoid<br>&gt;&gt; constructing a generator.<br>&gt;&gt;<br>&gt;&gt; With this added to SequenceType, we can remove it from<br>&gt;&gt; CollectionType, as the behavior will be the same.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/ff4c8058/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>Here it is https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26&gt;<br></p><p>&gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been complaining about that. Besides, sequences don&#39;t necessarily even terminate.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt;&gt; Users who don’t get the single-pass nature of SequenceType may expect a .last as well.<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; It&#39;s sometimes useful to get the first element of a sequence. To that end I&#39;d like to propose<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionSequenceType {<br>&gt;&gt;&gt; /// Returns the first element of `self`, or `nil` if `self` is empty.<br>&gt;&gt;&gt; /// - Complexity: O(1)<br>&gt;&gt;&gt; var first: Self.Generator.Element? {<br>&gt;&gt;&gt; var gen = generate()<br>&gt;&gt;&gt; return gen.next()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think it makes sense to add this property to the definition of SequenceType as well, so various sequences can override it to avoid constructing a generator.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; With this added to SequenceType, we can remove it from CollectionType, as the behavior will be the same.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/ea689c26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 04:39 PM, Daniel Duan wrote:<br>&gt; Here it is https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26<br>&gt;<br>&gt;&gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been<br>&gt;&gt; complaining about that. Besides, sequences don&#39;t necessarily even<br>&gt;&gt; terminate.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt;&gt;&gt; Users who don’t get the single-pass nature of SequenceType may<br>&gt;&gt;&gt; expect a .last as well.<br></p><p>Ah you&#39;re right, I was just looking at the unconstrained protocol. In<br>any case, we could theoretically provide a .last, but I don&#39;t think<br>that&#39;s useful enough on sequences to warrant inclusion. I know I&#39;ve<br>wanted .first many times and I&#39;ve never wanted .last.<br></p><p>Another motivation for adding this that I forgot to mention is that<br>today the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy at<br>all, it filters the entire collection and builds a new array (because<br>SequenceType doesn&#39;t have .first so it resolves the .filter() to the<br>eager version instead of the lazy version). Adding .first to<br>SequenceType makes that expression actually do what the user intended<br>(although my other proposal for SequenceType.find() provides a much<br>better way to accomplish the same task).<br></p><p>On Wed, Dec 30, 2015, at 04:40 PM, gs. wrote:<br>&gt; I like this addition and I think that we should take care to document<br>&gt; whether or not this mutates the sequence. I actually expect it to but<br>&gt; maybe I am mistaken.<br></p><p>(moving this back to the list)<br></p><p>I considered documenting that, but none of the existing &quot;destructive&quot;<br>methods on SequenceType document that. I think the assumption is that<br>anything that has to inspect the contents of the sequence is obviously<br>consuming the sequence to do that. In fact, the one method that doesn&#39;t<br>consume anything (not counting generate() since any use of the generator<br>is destructive), underestimateCount(), is explicitly documented as being<br>non-destructive.<br></p><p>Also, I couldn&#39;t think of a non-awkward way to say &quot;this property<br>partially consumes the sequence if it&#39;s a sequence that is destructively<br>&quot;consumed&quot; by iteration&quot;. Especially because &quot;partially consumed&quot; isn&#39;t<br>actually a property of sequences; it&#39;s explicitly documented that<br>calling generate() a second time after any iteration is allowed to<br>return a completely arbitrary sequence of elements from the second<br>generator (for example, a generator that returns lines read from some<br>stream might buffer more data internally and therefore constructing a<br>second generator would possibly skip data that was never returned from<br>the first generator).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/dd63e18d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>+1. I doubt anyone would really complain, just had to point it out.<br></p><p>&gt; On Dec 30, 2015, at 5:00 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 30, 2015, at 04:39 PM, Daniel Duan wrote:<br>&gt;&gt; Here it is https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26&gt;<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been complaining about that. Besides, sequences don&#39;t necessarily even terminate.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt;&gt;&gt;&gt; Users who don’t get the single-pass nature of SequenceType may expect a .last as well.<br>&gt;  <br>&gt; Ah you&#39;re right, I was just looking at the unconstrained protocol. In any case, we could theoretically provide a .last, but I don&#39;t think that&#39;s useful enough on sequences to warrant inclusion. I know I&#39;ve wanted .first many times and I&#39;ve never wanted .last.<br>&gt;  <br>&gt; Another motivation for adding this that I forgot to mention is that today the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy at all, it filters the entire collection and builds a new array (because SequenceType doesn&#39;t have .first so it resolves the .filter() to the eager version instead of the lazy version). Adding .first to SequenceType makes that expression actually do what the user intended (although my other proposal for SequenceType.find() provides a much better way to accomplish the same task).<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 04:40 PM, gs. wrote:<br>&gt;&gt; I like this addition and I think that we should take care to document whether or not this mutates the sequence. I actually expect it to but maybe I am mistaken.<br>&gt;  <br>&gt; (moving this back to the list)<br>&gt;  <br>&gt; I considered documenting that, but none of the existing &quot;destructive&quot; methods on SequenceType document that. I think the assumption is that anything that has to inspect the contents of the sequence is obviously consuming the sequence to do that. In fact, the one method that doesn&#39;t consume anything (not counting generate() since any use of the generator is destructive), underestimateCount(), is explicitly documented as being non-destructive.<br>&gt;  <br>&gt; Also, I couldn&#39;t think of a non-awkward way to say &quot;this property partially consumes the sequence if it&#39;s a sequence that is destructively &quot;consumed&quot; by iteration&quot;. Especially because &quot;partially consumed&quot; isn&#39;t actually a property of sequences; it&#39;s explicitly documented that calling generate() a second time after any iteration is allowed to return a completely arbitrary sequence of elements from the second generator (for example, a generator that returns lines read from some stream might buffer more data internally and therefore constructing a second generator would possibly skip data that was never returned from the first generator).<br>&gt;  <br>&gt; -Kevin Ballard<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a964d0de/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>-Dave<br></p><p>&gt; On Dec 30, 2015, at 5:00 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 30, 2015, at 04:39 PM, Daniel Duan wrote:<br>&gt;&gt; Here it is https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26&gt;<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been complaining about that. Besides, sequences don&#39;t necessarily even terminate.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt;&gt;&gt;&gt; Users who don’t get the single-pass nature of SequenceType may expect a .last as well.<br>&gt;  <br>&gt; Ah you&#39;re right, I was just looking at the unconstrained protocol. In any case, we could theoretically provide a .last, but I don&#39;t think that&#39;s useful enough on sequences to warrant inclusion. I know I&#39;ve wanted .first many times and I&#39;ve never wanted .last.<br>&gt;  <br>&gt; Another motivation for adding this that I forgot to mention is that today the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy at all, it filters the entire collection and builds a new array (because SequenceType doesn&#39;t have .first so it resolves the .filter() to the eager version instead of the lazy version).<br></p><p>Oh, that’s nasty.  I wonder if there’s something we can do with ambiguity to make the eager overload inaccessible in that context?  Would you mind opening a bug for this? <br></p><p>&gt; Adding .first to SequenceType makes that expression actually do what the user intended (although my other proposal for SequenceType.find() provides a much better way to accomplish the same task).<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 04:40 PM, gs. wrote:<br>&gt;&gt; I like this addition and I think that we should take care to document whether or not this mutates the sequence. I actually expect it to but maybe I am mistaken.<br>&gt;  <br>&gt; (moving this back to the list)<br>&gt;  <br>&gt; I considered documenting that, but none of the existing &quot;destructive&quot; methods on SequenceType document that. I think the assumption is that anything that has to inspect the contents of the sequence is obviously consuming the sequence to do that. In fact, the one method that doesn&#39;t consume anything (not counting generate() since any use of the generator is destructive), underestimateCount(), is explicitly documented as being non-destructive.<br>&gt;  <br>&gt; Also, I couldn&#39;t think of a non-awkward way to say &quot;this property partially consumes the sequence if it&#39;s a sequence that is destructively &quot;consumed&quot; by iteration&quot;. Especially because &quot;partially consumed&quot; isn&#39;t actually a property of sequences; it&#39;s explicitly documented that calling generate() a second time after any iteration is allowed to return a completely arbitrary sequence of elements from the second generator (for example, a generator that returns lines read from some stream might buffer more data internally and therefore constructing a second generator would possibly skip data that was never returned from the first generator).<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/1d1a59d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>I submitted another proposal a few hours ago regarding @available(*, unavailable) that&#39;s designed to turn this into a compile-time error.<br></p><p>Although I wonder if a stopgap would be to provide a `first` property on LazySequenceType that&#39;s marked as unavailable. I haven&#39;t checked to see how that behaves but I hope it would trigger an error instead of resolving to the eager filter.<br></p><p>-Kevin Ballard<br></p><p>On Dec 31, 2015, 12:40 AM -0800, Dave Abrahams&lt;dabrahams at apple.com&gt;, wrote:<br>&gt;  <br>&gt; -Dave<br>&gt; &gt; On Dec 30, 2015, at 5:00 PM, Kevin Ballard via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; On Wed, Dec 30, 2015, at 04:39 PM, Daniel Duan wrote:<br>&gt; &gt; &gt; Here it ishttps://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26<br>&gt; &gt; &gt; &gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been complaining about that. Besides, sequences don&#39;t necessarily even terminate.<br>&gt; &gt; &gt; &gt; -Kevin Ballard<br>&gt; &gt; &gt; &gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt; &gt; &gt; &gt; &gt; Users who don’t get the single-pass nature of SequenceType may expect a .last as well.<br>&gt; &gt; Ah you&#39;re right, I was just looking at the unconstrained protocol. In any case, we could theoretically provide a .last, but I don&#39;t think that&#39;s useful enough on sequences to warrant inclusion. I know I&#39;ve wanted .first many times and I&#39;ve never wanted .last.<br>&gt; &gt; Another motivation for adding this that I forgot to mention is that today the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy at all, it filters the entire collection and builds a new array (because SequenceType doesn&#39;t have .first so it resolves the .filter() to the eager version instead of the lazy version).<br>&gt;  <br>&gt; Oh, that’s nasty.I wonder if there’s something we can do with ambiguity to make the eager overload inaccessible in that context?Would you mind opening a bug for this?<br>&gt;  <br>&gt; &gt; Adding .first to SequenceType makes that expression actually do what the user intended (although my other proposal for SequenceType.find() provides a much better way to accomplish the same task).<br>&gt; &gt; On Wed, Dec 30, 2015, at 04:40 PM, gs. wrote:<br>&gt; &gt; &gt; I like this addition and I think that we should take care to document whether or not this mutates the sequence. I actually expect it to but maybe I am mistaken.<br>&gt; &gt; (moving this back to the list)<br>&gt; &gt; I considered documenting that, but none of the existing &quot;destructive&quot; methods on SequenceType document that. I think the assumption is that anything that has to inspect the contents of the sequence is obviously consuming the sequence to do that. In fact, the one method that doesn&#39;t consume anything (not counting generate() since any use of the generator is destructive), underestimateCount(), is explicitly documented as being non-destructive.<br>&gt; &gt; Also, I couldn&#39;t think of a non-awkward way to say &quot;this property partially consumes the sequence if it&#39;s a sequence that is destructively &quot;consumed&quot; by iteration&quot;. Especially because &quot;partially consumed&quot; isn&#39;t actually a property of sequences; it&#39;s explicitly documented that calling generate() a second time after any iteration is allowed to return a completely arbitrary sequence of elements from the second generator (for example, a generator that returns lines read from some stream might buffer more data internally and therefore constructing a second generator would possibly skip data that was never returned from the first generator).<br>&gt; &gt; -Kevin Ballard_______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/864e7e18/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015, at 12:40 AM, Dave Abrahams wrote:<br>&gt;&gt; Another motivation for adding this that I forgot to mention is that<br>&gt;&gt; today the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy<br>&gt;&gt; at all, it filters the entire collection and builds a new array<br>&gt;&gt; (because SequenceType doesn&#39;t have .first so it resolves the<br>&gt;&gt; .filter() to the eager version instead of the lazy version).<br>&gt;<br>&gt; Oh, that’s nasty.  I wonder if there’s something we can do with<br>&gt; ambiguity to make the eager overload inaccessible in that context?<br>&gt; Would you mind opening a bug for this?<br></p><p>Incidentally, I misspoke; the problem is with<br>`someSeq.lazy.filter(pred).first`. `LazyCollection.filter` returns a<br>`CollectionType`, so `someCol.lazy.filter(pred).first` works fine there.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/6e41b086/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January  1, 2016 at 10:00:00am</p></header><div class="content"><p>Related to this I&#39;ve been toying around with a tweak to GeneratorType - it<br>could clear up some of the issues with .first consuming part of the<br>sequence:<br></p><p>public protocol NewGeneratorType {<br></p><p>    typealias Element<br></p><p>    func next() -&gt; (value: Element, state: Self)?<br></p><p>}<br></p><p><br>extension NewGeneratorType {<br></p><p>    mutating func next() -&gt; Element? {<br></p><p>        let nextPair: (value: Element, state: Self)? = self.next()<br></p><p>        if let state = nextPair?.state {<br></p><p>            self = state<br></p><p>        }<br></p><p>        return nextPair?.value<br></p><p>    }<br></p><p>}<br></p><p><br>I haven&#39;t had time for a proposal yet, but thought I&#39;d mention it as it<br>seemed relevant.<br></p><p><br></p><p>On Thu, Dec 31, 2015 at 7:40 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; On Dec 30, 2015, at 5:00 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Wed, Dec 30, 2015, at 04:39 PM, Daniel Duan wrote:<br>&gt;<br>&gt; Here it is<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26<br>&gt;<br>&gt;<br>&gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;<br>&gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been<br>&gt; complaining about that. Besides, sequences don&#39;t necessarily even terminate.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt;<br>&gt; Users who don’t get the single-pass nature of SequenceType may expect a<br>&gt; .last as well.<br>&gt;<br>&gt;<br>&gt; Ah you&#39;re right, I was just looking at the unconstrained protocol. In any<br>&gt; case, we could theoretically provide a .last, but I don&#39;t think that&#39;s<br>&gt; useful enough on sequences to warrant inclusion. I know I&#39;ve wanted .first<br>&gt; many times and I&#39;ve never wanted .last.<br>&gt;<br>&gt; Another motivation for adding this that I forgot to mention is that today<br>&gt; the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy at all, it<br>&gt; filters the entire collection and builds a new array (because SequenceType<br>&gt; doesn&#39;t have .first so it resolves the .filter() to the eager version<br>&gt; instead of the lazy version).<br>&gt;<br>&gt;<br>&gt; Oh, that’s nasty.  I wonder if there’s something we can do with ambiguity<br>&gt; to make the eager overload inaccessible in that context?  Would you mind<br>&gt; opening a bug for this?<br>&gt;<br>&gt; Adding .first to SequenceType makes that expression actually do what the<br>&gt; user intended (although my other proposal for SequenceType.find() provides<br>&gt; a much better way to accomplish the same task).<br>&gt;<br>&gt; On Wed, Dec 30, 2015, at 04:40 PM, gs. wrote:<br>&gt;<br>&gt; I like this addition and I think that we should take care to document<br>&gt; whether or not this mutates the sequence. I actually expect it to but maybe<br>&gt; I am mistaken.<br>&gt;<br>&gt;<br>&gt; (moving this back to the list)<br>&gt;<br>&gt; I considered documenting that, but none of the existing &quot;destructive&quot;<br>&gt; methods on SequenceType document that. I think the assumption is that<br>&gt; anything that has to inspect the contents of the sequence is obviously<br>&gt; consuming the sequence to do that. In fact, the one method that doesn&#39;t<br>&gt; consume anything (not counting generate() since any use of the generator is<br>&gt; destructive), underestimateCount(), is explicitly documented as being<br>&gt; non-destructive.<br>&gt;<br>&gt; Also, I couldn&#39;t think of a non-awkward way to say &quot;this property<br>&gt; partially consumes the sequence if it&#39;s a sequence that is destructively<br>&gt; &quot;consumed&quot; by iteration&quot;. Especially because &quot;partially consumed&quot; isn&#39;t<br>&gt; actually a property of sequences; it&#39;s explicitly documented that calling<br>&gt; generate() a second time after any iteration is allowed to return a<br>&gt; completely arbitrary sequence of elements from the second generator (for<br>&gt; example, a generator that returns lines read from some stream might buffer<br>&gt; more data internally and therefore constructing a second generator would<br>&gt; possibly skip data that was never returned from the first generator).<br>&gt;<br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/67199a1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 3:36 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Related to this I&#39;ve been toying around with a tweak to GeneratorType - it could clear up some of the issues with .first consuming part of the sequence:<br>&gt; <br>&gt; public protocol NewGeneratorType {<br>&gt;     typealias Element<br>&gt;     func next() -&gt; (value: Element, state: Self)?<br>&gt; }<br>&gt; <br>&gt; extension NewGeneratorType {<br>&gt;     mutating func next() -&gt; Element? {<br>&gt;         let nextPair: (value: Element, state: Self)? = self.next()<br>&gt;         if let state = nextPair?.state {<br>&gt;             self = state<br>&gt;         }<br>&gt;         return nextPair?.value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I haven&#39;t had time for a proposal yet, but thought I&#39;d mention it as it seemed relevant.<br></p><p>The only way this can solve the problem is that if your new next() method is required to return the same result for multiple consecutive calls.  There’s a reason GeneratorType wasn’t designed that way: it effectively requires generators of volatile streams to have a 1-element buffer, which is an avoidable overhead for the many algorithms make a single pass and don’t try to get the same element multiple times (consecutively).  Any algorithm that wants to do that can keep its own cache instead of imposing the cache overhead on every generator.<br></p><p>&gt; On Thu, Dec 31, 2015 at 7:40 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 5:00 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 30, 2015, at 04:39 PM, Daniel Duan wrote:<br>&gt;&gt;&gt; Here it is https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionAlgorithms.swift.gyb#L26&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 4:27 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; We already don&#39;t have a .last on CollectionType and nobody&#39;s been complaining about that. Besides, sequences don&#39;t necessarily even terminate.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Wed, Dec 30, 2015, at 04:01 PM, Daniel Duan wrote:<br>&gt;&gt;&gt;&gt;&gt; Users who don’t get the single-pass nature of SequenceType may expect a .last as well.<br>&gt;&gt;  <br>&gt;&gt; Ah you&#39;re right, I was just looking at the unconstrained protocol. In any case, we could theoretically provide a .last, but I don&#39;t think that&#39;s useful enough on sequences to warrant inclusion. I know I&#39;ve wanted .first many times and I&#39;ve never wanted .last.<br>&gt;&gt;  <br>&gt;&gt; Another motivation for adding this that I forgot to mention is that today the code `someCol.lazy.filter(pred).first` actually isn&#39;t lazy at all, it filters the entire collection and builds a new array (because SequenceType doesn&#39;t have .first so it resolves the .filter() to the eager version instead of the lazy version).<br>&gt; <br>&gt; Oh, that’s nasty.  I wonder if there’s something we can do with ambiguity to make the eager overload inaccessible in that context?  Would you mind opening a bug for this? <br>&gt; <br>&gt;&gt; Adding .first to SequenceType makes that expression actually do what the user intended (although my other proposal for SequenceType.find() provides a much better way to accomplish the same task).<br>&gt;&gt;  <br>&gt;&gt; On Wed, Dec 30, 2015, at 04:40 PM, gs. wrote:<br>&gt;&gt;&gt; I like this addition and I think that we should take care to document whether or not this mutates the sequence. I actually expect it to but maybe I am mistaken.<br>&gt;&gt;  <br>&gt;&gt; (moving this back to the list)<br>&gt;&gt;  <br>&gt;&gt; I considered documenting that, but none of the existing &quot;destructive&quot; methods on SequenceType document that. I think the assumption is that anything that has to inspect the contents of the sequence is obviously consuming the sequence to do that. In fact, the one method that doesn&#39;t consume anything (not counting generate() since any use of the generator is destructive), underestimateCount(), is explicitly documented as being non-destructive.<br>&gt;&gt;  <br>&gt;&gt; Also, I couldn&#39;t think of a non-awkward way to say &quot;this property partially consumes the sequence if it&#39;s a sequence that is destructively &quot;consumed&quot; by iteration&quot;. Especially because &quot;partially consumed&quot; isn&#39;t actually a property of sequences; it&#39;s explicitly documented that calling generate() a second time after any iteration is allowed to return a completely arbitrary sequence of elements from the second generator (for example, a generator that returns lines read from some stream might buffer more data internally and therefore constructing a second generator would possibly skip data that was never returned from the first generator).<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/11e13fb8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s sometimes useful to get the first element of a sequence. To that end I&#39;d like to propose<br>&gt;  <br>&gt; extension SequenceType {<br>&gt;     /// Returns the first element of `self`, or `nil` if `self` is empty.<br>&gt;     /// - Complexity: O(1)<br>&gt;     var first: Self.Generator.Element? {<br>&gt;         var gen = generate()<br>&gt;         return gen.next()<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; I think it makes sense to add this property to the definition of SequenceType as well, so various sequences can override it to avoid constructing a generator.<br>&gt;  <br>&gt; With this added to SequenceType, we can remove it from CollectionType, as the behavior will be the same.<br></p><p>Property accesses should not mutate the receiver, and because of how Sequences work, inspecting first may consume the first element. I suggest you consider adding a BufferedSequence&lt;Base: SequenceType&gt; that has a stable first property (at least until it is iterated)<br></p><p>Another related adapter I’d like to add is a model of CollectionType that is backed by a sequence and lazily populated in fixed-sized chunks.<br></p><p><br>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/e469f8bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 08:00:00pm</p></header><div class="content"><p>Generator should always generates value from start of sequence. I don&#39;t see<br>any problems with this implementation.<br></p><p>Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; 於<br>2015年12月31日星期四 寫道：<br></p><p>&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; It&#39;s sometimes useful to get the first element of a sequence. To that end<br>&gt; I&#39;d like to propose<br>&gt;<br>&gt; extension SequenceType {<br>&gt;     /// Returns the first element of `self`, or `nil` if `self` is empty.<br>&gt;     /// - Complexity: O(1)<br>&gt;     var first: Self.Generator.Element? {<br>&gt;         var gen = generate()<br>&gt;         return gen.next()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; I think it makes sense to add this property to the definition of<br>&gt; SequenceType as well, so various sequences can override it to avoid<br>&gt; constructing a generator.<br>&gt;<br>&gt; With this added to SequenceType, we can remove it from CollectionType, as<br>&gt; the behavior will be the same.<br>&gt;<br>&gt;<br>&gt; Property accesses should not mutate the receiver, and because of how<br>&gt; Sequences work, inspecting first may consume the first element. I suggest<br>&gt; you consider adding a BufferedSequence&lt;Base: SequenceType&gt; that has a<br>&gt; stable first property (at least until it is iterated)<br>&gt;<br>&gt; Another related adapter I’d like to add is a model of CollectionType that<br>&gt; is backed by a sequence and lazily populated in fixed-sized chunks.<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/5e89bda8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Consider this,<br></p><p>struct RandomGenerator : GeneratorType, SequenceType {<br></p><p><br></p><p>    mutating func next() -&gt; UInt32? {<br></p><p>        return arc4random()<br></p><p>    }<br></p><p>}<br></p><p>what&#39;s the expected result of follows??<br></p><p><br>let random = RandomGenerator()<br></p><p><br>let resultA = random.first<br></p><p>let resultB = random.first<br></p><p>let resultC = Array(random.prefix(4))<br></p><p>let resultD = Array(random.prefix(4))<br></p><p>all should agree that resultC and resultD will get different array. what&#39;s<br>about with resultA and resultB?<br></p><p>Gwendal Roué &lt;gwendal.roue at gmail.com&gt; 於 2016年1月2日 下午8:13 寫道：<br></p><p>Hello,<br></p><p>My two cents: I feel uncomfortable with SequenceType.first since<br>SequenceType clearly states that it may be destructed on iteration.<br></p><p>Compare :<br></p><p>seq.generate().next() // clear that it may give another result if called<br>twice<br>seq.first             // unclear that it may give another result if called<br>twice<br></p><p>Gwendal<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/f38decf3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015, at 12:36 AM, Dave Abrahams wrote:<br>&gt;&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It&#39;s sometimes useful to get the first element of a sequence. To that<br>&gt;&gt; end I&#39;d like to propose<br>&gt;&gt;<br>&gt;&gt; extensionSequenceType { /// Returns the first element of<br>&gt;&gt; `self`, or `nil` if `self` is empty. /// - Complexity: O(1) var<br>&gt;&gt; first: Self.Generator.Element? { var gen = generate() return<br>&gt;&gt; gen.next()    } }<br>&gt;&gt;<br>&gt;&gt; I think it makes sense to add this property to the definition of<br>&gt;&gt; SequenceType as well, so various sequences can override it to avoid<br>&gt;&gt; constructing a generator.<br>&gt;&gt;<br>&gt;&gt; With this added to SequenceType, we can remove it from<br>&gt;&gt; CollectionType, as the behavior will be the same.<br>&gt;<br>&gt; Property accesses should not mutate the receiver, and because of how<br>&gt; Sequences work, inspecting first may consume the first element.<br></p><p>Fair enough. Swift does support `mutating get`, but it looks like the<br>stdlib doesn&#39;t actually use this anywhere (at least, in the public API).<br></p><p>Still, it&#39;s a shame that there&#39;s no way to do this generically for<br>sequences. It&#39;s something I need upon occasion. I wish I could actually<br>say something like `seq.generate().next()`, but you can&#39;t call mutating<br>functions on temporaries.<br></p><p>I&#39;d be tempted to say we should have a `func first()` method, except<br>then CollectionTypes would have both a property and a method named<br>`first` and that would just be confusing.<br></p><p>&gt; I suggest you consider adding a BufferedSequence&lt;Base: SequenceType&gt;<br>&gt; that has a stable first property (at least until it is iterated)<br></p><p>Good idea, though I&#39;d probably call it PeekSequence because it would<br>only buffer a single element (and BufferedSequence sounds like it&#39;s got<br>an arbitrary-sized buffer). Perhaps more useful would be the associated<br>PeekGenerator, because peek() is a useful thing to have when writing<br>custom generator-using code.<br></p><p>I&#39;ll write up a more detailed email with a proposed design in a minute.<br></p><p>&gt; Another related adapter I’d like to add is a model of<br>&gt; CollectionType that is backed by a sequence and lazily populated in<br>&gt; fixed-sized chunks.<br></p><p>Also a good idea. Although really it could just be backed by a<br>ContiguousArray, those things already grow in chunks. I&#39;ll write up a<br>design for that too.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/6f7b4578/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 1:58 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 31, 2015, at 12:36 AM, Dave Abrahams wrote:<br>&gt;&gt;&gt; On Dec 30, 2015, at 3:57 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; It&#39;s sometimes useful to get the first element of a sequence. To that end I&#39;d like to propose<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionSequenceType {<br>&gt;&gt;&gt; /// Returns the first element of `self`, or `nil` if `self` is empty.<br>&gt;&gt;&gt; /// - Complexity: O(1)<br>&gt;&gt;&gt; var first: Self.Generator.Element? {<br>&gt;&gt;&gt; var gen = generate()<br>&gt;&gt;&gt; return gen.next()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think it makes sense to add this property to the definition of SequenceType as well, so various sequences can override it to avoid constructing a generator.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; With this added to SequenceType, we can remove it from CollectionType, as the behavior will be the same.<br>&gt;&gt;  <br>&gt;&gt; Property accesses should not mutate the receiver, and because of how Sequences work, inspecting first may consume the first element.<br>&gt;  <br>&gt; Fair enough. Swift does support `mutating get`, but it looks like the stdlib doesn&#39;t actually use this anywhere (at least, in the public API).<br>&gt;  <br>&gt; Still, it&#39;s a shame that there&#39;s no way to do this generically for sequences. It&#39;s something I need upon occasion. I wish I could actually say something like `seq.generate().next()`, but you can&#39;t call mutating functions on temporaries.<br>&gt;  <br>&gt; I&#39;d be tempted to say we should have a `func first()` method, except then CollectionTypes would have both a property and a method named `first` and that would just be confusing.<br>&gt;  <br>&gt;&gt; I suggest you consider adding a BufferedSequence&lt;Base: SequenceType&gt; that has a stable first property (at least until it is iterated)<br>&gt;  <br>&gt; Good idea, though I&#39;d probably call it PeekSequence because it would only buffer a single element (and BufferedSequence sounds like it&#39;s got an arbitrary-sized buffer). Perhaps more useful would be the associated PeekGenerator, because peek() is a useful thing to have when writing custom generator-using code.<br></p><p>The size of the buffer is an implementation detail, and I don’t find “peek” descriptive.<br></p><p>&gt; I&#39;ll write up a more detailed email with a proposed design in a minute.<br>&gt;  <br>&gt;&gt; Another related adapter I’d like to add is a model of CollectionType that is backed by a sequence and lazily populated in fixed-sized chunks.<br>&gt;  <br>&gt; Also a good idea. Although really it could just be backed by a ContiguousArray, those things already grow in chunks. I&#39;ll write up a design for that too.<br></p><p>Not unless you want to keep the buffers alive longer than necessary.  Imagine you’re parsing a long stream with some amount of lookahead.  You can scan this collection by slicing it and the buffer segments that are no longer in use will be automatically collected.<br></p><p>&gt; -Kevin Ballard<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/ae5b5498/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015, at 02:03 PM, Dave Abrahams wrote:<br>&gt;<br>&gt;&gt; On Dec 31, 2015, at 1:58 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Good idea, though I&#39;d probably call it PeekSequence because it would<br>&gt;&gt; only buffer a single element (and BufferedSequence sounds like it&#39;s<br>&gt;&gt; got an arbitrary-sized buffer). Perhaps more useful would be the<br>&gt;&gt; associated PeekGenerator, because peek() is a useful thing to have<br>&gt;&gt; when writing custom generator-using code.<br>&gt;<br>&gt; The size of the buffer is an implementation detail, and I don’t find<br>&gt; “peek” descriptive.<br></p><p>There&#39;s precedent for the name &quot;peek&quot;. More importantly, that&#39;s the name<br>you&#39;d use for the generator method; the sequence would still have the<br>&quot;first&quot; property.<br></p><p>My concern with making the size of the buffer be an implementation<br>detail is I&#39;d rather not add array allocation if I only need a single<br>element of lookahead. I suppose it could have an `enum {<br>OneElement(Element), Buffer([Element]) }` as the storage, but that still<br>does end up being a little bit of extra work on every call to next().<br></p><p>&gt;&gt; I&#39;ll write up a more detailed email with a proposed design in a<br>&gt;&gt; minute.<br>&gt;&gt;<br>&gt;&gt;&gt; Another related adapter I’d like to add is a model of CollectionType<br>&gt;&gt;&gt; that is backed by a sequence and lazily populated in fixed-sized<br>&gt;&gt;&gt; chunks.<br>&gt;&gt;<br>&gt;&gt; Also a good idea. Although really it could just be backed by a<br>&gt;&gt; ContiguousArray, those things already grow in chunks. I&#39;ll write up a<br>&gt;&gt; design for that too.<br>&gt;<br>&gt; Not unless you want to keep the buffers alive longer than necessary.<br>&gt; Imagine you’re parsing a long stream with some amount of lookahead.<br>&gt; You can scan this collection by slicing it and the buffer segments<br>&gt; that are no longer in use will be automatically collected.<br></p><p>Ah, I didn&#39;t realize you wanted to collect chunks that haven&#39;t been used<br>lately. But I don&#39;t think that&#39;s possible; since it&#39;s backed by a<br>sequence, the chunks MUST be generated in order; there&#39;s no way to skip<br>ahead, and no way to generate an older chunk that you&#39;ve thrown away.<br>But since it&#39;s a CollectionType, you need to preserve the ability to<br>access older values. So the only way to actually have this be a<br>CollectionType is to buffer the entire sequence up to the highest-<br>accessed index.<br></p><p>Of course, your use-case of processing a stream with some amount of<br>lookahead and throwing away the old data actually sounds like something<br>a &quot;BufferedSequence&quot; might provide. Or actually, a &quot;BufferedGenerator&quot;,<br>because the only way to process a sequence is with a generator and so<br>all a &quot;BufferedSequence&quot; would really do is just give you a<br>&quot;BufferedGenerator&quot; from its generate() method.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/84b59e44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 3:20 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 31, 2015, at 02:03 PM, Dave Abrahams wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 31, 2015, at 1:58 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Good idea, though I&#39;d probably call it PeekSequence because it would only buffer a single element (and BufferedSequence sounds like it&#39;s got an arbitrary-sized buffer). Perhaps more useful would be the associated PeekGenerator, because peek() is a useful thing to have when writing custom generator-using code.<br>&gt;&gt;  <br>&gt;&gt; The size of the buffer is an implementation detail, and I don’t find “peek” descriptive.<br>&gt;  <br>&gt; There&#39;s precedent for the name &quot;peek&quot;. More importantly, that&#39;s the name you&#39;d use for the generator method; the sequence would still have the &quot;first&quot; property.<br>&gt;  <br>&gt; My concern with making the size of the buffer be an implementation detail is I&#39;d rather not add array allocation if I only need a single element of lookahead. I suppose it could have an `enum { OneElement(Element), Buffer([Element]) }` as the storage, but that still does end up being a little bit of extra work on every call to next().<br>&gt;  <br>&gt;&gt;&gt; I&#39;ll write up a more detailed email with a proposed design in a minute.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Another related adapter I’d like to add is a model of CollectionType that is backed by a sequence and lazily populated in fixed-sized chunks.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Also a good idea. Although really it could just be backed by a ContiguousArray, those things already grow in chunks. I&#39;ll write up a design for that too.<br>&gt;&gt;  <br>&gt;&gt; Not unless you want to keep the buffers alive longer than necessary.  Imagine you’re parsing a long stream with some amount of lookahead.  You can scan this collection by slicing it and the buffer segments that are no longer in use will be automatically collected.<br>&gt;  <br>&gt; Ah, I didn&#39;t realize you wanted to collect chunks that haven&#39;t been used lately. But I don&#39;t think that&#39;s possible;<br></p><p>&gt; since it&#39;s backed by a sequence, the chunks MUST be generated in order; there&#39;s no way to skip ahead, and no way to generate an older chunk that you&#39;ve thrown away.<br></p><p>Right…?<br></p><p>&gt; But since it&#39;s a CollectionType, you need to preserve the ability to access older values.<br></p><p>Not once you replace it with a slice of itself.<br></p><p>&gt; So the only way to actually have this be a CollectionType is to buffer the entire sequence up to the highest-accessed index.<br>&gt;  <br>&gt; Of course, your use-case of processing a stream with some amount of lookahead and throwing away the old data actually sounds like something a &quot;BufferedSequence&quot; might provide. Or actually, a &quot;BufferedGenerator&quot;, because the only way to process a sequence is with a generator and so all a &quot;BufferedSequence&quot; would really do is just give you a &quot;BufferedGenerator&quot; from its generate() method.<br></p><p>I’m quite certain this is buildable.  I’ve got my hands full at the moment or I’d create a prototype…<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/906cc177/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  2, 2016 at 07:00:00pm</p></header><div class="content"><p>On Sat, Jan 2, 2016, at 07:17 PM, Dave Abrahams wrote:<br>&gt;&gt; But since it&#39;s a CollectionType, you need to preserve the ability to<br>&gt;&gt; access older values.<br>&gt;<br>&gt; Not once you replace it with a slice of itself.<br></p><p>Ah I see, I missed that subtlety. Or more specifically, when you first<br>said &quot;slice&quot; I was thinking of the Slice struct, but if you implement<br>slicing by hand then you can do this just fine.<br></p><p>&gt;&gt; So the only way to actually have this be a CollectionType is to<br>&gt;&gt; buffer the entire sequence up to the highest-accessed index.<br>&gt;&gt;<br>&gt;&gt; Of course, your use-case of processing a stream with some amount of<br>&gt;&gt; lookahead and throwing away the old data actually sounds like<br>&gt;&gt; something a &quot;BufferedSequence&quot; might provide. Or actually, a<br>&gt;&gt; &quot;BufferedGenerator&quot;, because the only way to process a sequence is<br>&gt;&gt; with a generator and so all a &quot;BufferedSequence&quot; would really do is<br>&gt;&gt; just give you a &quot;BufferedGenerator&quot; from its generate() method.<br>&gt;<br>&gt; I’m quite certain this is buildable.  I’ve got my hands full at the<br>&gt; moment or I’d create a prototype…<br></p><p>Now that I realize exactly what you meant, it should indeed be<br>buildable. Though short of requiring the user to provide it, I&#39;m not<br>sure how to pick an appropriate chunk size.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/1a3010c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>I&#39;ve submitted a proposal to the ML for BufferedSequence / BufferedGenerator as https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005010.html. I kept the name &quot;peek&quot; for the method because, as mentioned in that email, there&#39;s plenty of precedent for it.<br></p><p>-Kevin Ballard<br></p><p>P.S. The plain-text version of the email is hard to read because the<br>     FastMail web interface doesn&#39;t handle rich text very well. The rich<br>     text version should be much more readable.<br></p><p>On Thu, Dec 31, 2015, at 02:03 PM, Dave Abrahams wrote:<br>&gt;&gt;&gt; I suggest you consider adding a BufferedSequence&lt;Base: SequenceType&gt;<br>&gt;&gt;&gt; that has a stable first property (at least until it is iterated)<br>&gt;&gt;<br>&gt;&gt; Good idea, though I&#39;d probably call it PeekSequence because it would<br>&gt;&gt; only buffer a single element (and BufferedSequence sounds like it&#39;s<br>&gt;&gt; got an arbitrary-sized buffer). Perhaps more useful would be the<br>&gt;&gt; associated PeekGenerator, because peek() is a useful thing to have<br>&gt;&gt; when writing custom generator-using code.<br>&gt;<br>&gt; The size of the buffer is an implementation detail, and I don’t find<br>&gt; “peek” descriptive.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/2bc5a3df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 4:19 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve submitted a proposal to the ML for BufferedSequence / BufferedGenerator as https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005010.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005010.html&gt;.<br></p><p>Thanks.<br></p><p>&gt; I kept the name &quot;peek&quot; for the method because, as mentioned in that email, there&#39;s plenty of precedent for it.<br></p><p>It’s a perfectly cromulent name for that purpose.  I just don’t think it belongs in the type name.<br> <br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; P.S. The plain-text version of the email is hard to read because the FastMail web interface doesn&#39;t handle rich text very well. The rich text version should be much more readable.<br>&gt;  <br>&gt; On Thu, Dec 31, 2015, at 02:03 PM, Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt; I suggest you consider adding a BufferedSequence&lt;Base: SequenceType&gt; that has a stable first property (at least until it is iterated)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Good idea, though I&#39;d probably call it PeekSequence because it would only buffer a single element (and BufferedSequence sounds like it&#39;s got an arbitrary-sized buffer). Perhaps more useful would be the associated PeekGenerator, because peek() is a useful thing to have when writing custom generator-using code.<br>&gt;&gt;  <br>&gt;&gt; The size of the buffer is an implementation detail, and I don’t find “peek” descriptive.<br>&gt;  <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/a7b3fb6b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  2, 2016 at 04:00:00am</p></header><div class="content"><p>May I suggest a simple solution?<br></p><p>	extension SequenceType {<br>		/// Returns one element from the beginning of the sequence, or `nil` if the sequence is empty.<br>		/// If `self` is a single-pass sequence, this may consume the element.<br>		func one() -&gt; Generator.Element? {<br>			var generator = generate()<br>			return generator.next()<br>		}<br>	}<br></p><p>This should probably be a method in the protocol, and CollectionType should have an override which calls `first`.<br></p><p>The BufferedSequence stuff suggested elsewhere is probably useful too, and should be considered in addition to this, but I think this would cover the most common case.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  2, 2016 at 02:00:00pm</p></header><div class="content"><p>The best interface is no interface, isn’t it? Why should we absolutely add methods with unclear meanings or behavior, when there are already perfectly clear, if verbose, alternatives? seq.generate().next() may not be nice, but no one can get fooled by it.<br></p><p>Maybe we should discuss use cases, instead of &quot;completing&quot; a standard lib that did not ask anything. It never stops: shouldn’t we add isEmpty to SequenceType, if first was added? With the same ambiguity in both meaning and behavior...<br></p><p>Indeed I agree that the buffered sequence is much more interesting, and that it overlaps with the implicit enhancement request behind SequenceType.first. I have one experience where I wanted to know whether a sequence was empty before consuming it, and a standard buffered sequence would have been a much welcomed tool.<br></p><p>Gwendal<br> <br>&gt; Le 2 janv. 2016 à 13:42, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; May I suggest a simple solution?<br>&gt; <br>&gt; 	extension SequenceType {<br>&gt; 		/// Returns one element from the beginning of the sequence, or `nil` if the sequence is empty.<br>&gt; 		/// If `self` is a single-pass sequence, this may consume the element.<br>&gt; 		func one() -&gt; Generator.Element? {<br>&gt; 			var generator = generate()<br>&gt; 			return generator.next()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; This should probably be a method in the protocol, and CollectionType should have an override which calls `first`.<br>&gt; <br>&gt; The BufferedSequence stuff suggested elsewhere is probably useful too, and should be considered in addition to this, but I think this would cover the most common case.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  2, 2016 at 02:00:00pm</p></header><div class="content"><p>No one appears to have considered the C# example yet. In C#, IEnumerable&lt;T&gt; (Swift&#39;s SequenceType) has a `First()` (and `FirstOrDefault(T)`) method.<br></p><p>C# also has a coroutine syntax (`yield return xyz`) that makes it easy to create sequences that are evaluated with side effects. However, Googling &quot;c# ienumerable first&quot;, nobody seems to be wondering if the sequence will be evaluated multiple times. This true even though C# has a coroutine syntax that makes it very easy to create sequences with side effects.<br></p><p>I&#39;m not passionate about whether a `first` property on sequences needs to feel &quot;part of the language&quot; (since that&#39;s what the stdlib is about), or how it should behave exactly. However, off the list into the world of making programs, it doesn&#39;t appear to matter much whether using `first` successively evaluates the sequence multiple times or not. If it needs to be evaluated just once, there are trivial ways to make that happen.<br></p><p>(I don&#39;t think that the observation can be extended to a lot of other sequence methods. This is about the specific case of `first`.)<br></p><p>Félix<br></p><p>&gt; Le 2 janv. 2016 à 08:53:39, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The best interface is no interface, isn’t it? Why should we absolutely add methods with unclear meanings or behavior, when there are already perfectly clear, if verbose, alternatives? seq.generate().next() may not be nice, but no one can get fooled by it.<br>&gt; <br>&gt; Maybe we should discuss use cases, instead of &quot;completing&quot; a standard lib that did not ask anything. It never stops: shouldn’t we add isEmpty to SequenceType, if first was added? With the same ambiguity in both meaning and behavior...<br>&gt; <br>&gt; Indeed I agree that the buffered sequence is much more interesting, and that it overlaps with the implicit enhancement request behind SequenceType.first. I have one experience where I wanted to know whether a sequence was empty before consuming it, and a standard buffered sequence would have been a much welcomed tool.<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt;&gt; Le 2 janv. 2016 à 13:42, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; May I suggest a simple solution?<br>&gt;&gt; <br>&gt;&gt; 	extension SequenceType {<br>&gt;&gt; 		/// Returns one element from the beginning of the sequence, or `nil` if the sequence is empty.<br>&gt;&gt; 		/// If `self` is a single-pass sequence, this may consume the element.<br>&gt;&gt; 		func one() -&gt; Generator.Element? {<br>&gt;&gt; 			var generator = generate()<br>&gt;&gt; 			return generator.next()<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; This should probably be a method in the protocol, and CollectionType should have an override which calls `first`.<br>&gt;&gt; <br>&gt;&gt; The BufferedSequence stuff suggested elsewhere is probably useful too, and should be considered in addition to this, but I think this would cover the most common case.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Why should we absolutely add methods with unclear meanings or behavior, when there are already perfectly clear, if verbose, alternatives? seq.generate().next() may not be nice, but no one can get fooled by it.<br></p><p>Well, for one thing, because it doesn&#39;t work. You can&#39;t call a mutating method directly on a return value without assigning it to a variable first. And put simply, a temporary variable seems a bridge too far to me.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  2, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Jan 2, 2016, at 12:13 PM, Brent Royal-Gordon wrote:<br>&gt; &gt; Why should we absolutely add methods with unclear meanings or behavior, when there are already perfectly clear, if verbose, alternatives? seq.generate().next() may not be nice, but no one can get fooled by it.<br>&gt; <br>&gt; Well, for one thing, because it doesn&#39;t work. You can&#39;t call a mutating method directly on a return value without assigning it to a variable first. And put simply, a temporary variable seems a bridge too far to me.<br></p><p>Exactly. If `seq.generate().next()` worked, I&#39;d be perfectly happy with that. I&#39;d be tempted to submit a proposal saying this should be legal, but I believe that disallowing mutating methods on temporaries is an intentional decision that was intended to prevent the user from writing code that looks like it&#39;s mutating something that it isn&#39;t.<br></p><p>For example, given the following interface:<br></p><p>struct Foo {<br>    var ary: [Int] { get }<br>}<br></p><p>Allowing mutating of temporaries would let me write code like<br></p><p>func foo(x: Foo) -&gt; Int? {<br>    return x.ary.popLast()<br>}<br></p><p>and yet this won&#39;t actually mutate the array at all (and it will incur an unwanted copy of the array storage that is immediately thrown away).<br></p><p>We could try and come up with some workaround, like maybe an attribute on `mutating func next()` that says &quot;this may be called on a temporary&quot;, but it seems kind of hacky. And I can&#39;t think of anything other than `GeneratorType.next` that actually wants this behavior anyway (the closest alternative I can think of is passing a scalar as an UnsafePointer or UnsafeMutablePointer to a C function where you don&#39;t actually care about the output, where in C you can actually say something like `&amp;(int){42}` if you want, but I haven&#39;t actually hit that case in Swift yet and it&#39;s pretty rare anyway).<br></p><p>Incidentally, the same rule is also what prohibits arrays from being passed to an inout parameter where a downcast is required. Arrays implicitly downcast as needed to simulate covariance on its element type, e.g. if U &lt;: T then [U] can be used where a [T] is expected because an implicit downcasted copy is made. But you cannot pass a [U] to a function that expects an inout [T] because temporaries are immutable (and implicit array conversion produces a temporary).<br></p><p>-Kevin Ballard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 12:13 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Why should we absolutely add methods with unclear meanings or behavior, when there are already perfectly clear, if verbose, alternatives? seq.generate().next() may not be nice, but no one can get fooled by it.<br>&gt; <br>&gt; Well, for one thing, because it doesn&#39;t work. You can&#39;t call a mutating method directly on a return value without assigning it to a variable first. And put simply, a temporary variable seems a bridge too far to me.<br></p><p>For a possibly-mutating operation, I think it’s perfectly appropriate that you have to create an intermediate variable.  If you want to create an extension with a “func possiblyConsumeFirst() -&gt; Generator.Element”, you are welcome to do so; that’s what extensions are for.  IMO the standard library should not hide volatile sequence consumption under a property access.<br></p><p>If I don’t sound sympathetic, it’s because nobody has shown a use-case for this functionality, and until I see one I am going to have a hard time believing there’s a problem worth solving.  If you want to make the case that we need something like this, please show me why. <br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; If I don’t sound sympathetic, it’s because nobody has shown a use-case for this functionality, and until I see one I am going to have a hard time believing there’s a problem worth solving.  If you want to make the case that we need something like this, please show me why. <br></p><p>Didn&#39;t this thread start off with a use case?<br></p><p>	seq.lazy.filter(predicate).first		// is not actually lazy, and Swift provides no good way to do this<br></p><p>One way to fix this is to add `first` to `SequenceType`, but it feels strange for a property to potentially consume part of the sequence. `buffered` ultimately has the same problem. By representing this as a function, it at least looks like something that might have side effects.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  3, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Le 3 janv. 2016 à 01:58, Kevin Ballard &lt;kevin at sb.org&gt; a écrit :<br>&gt; <br>&gt;&gt;&gt; seq.generate().next() may not be nice, but no one can get fooled by it.<br>&gt;&gt; <br>&gt;&gt; Well, for one thing, because it doesn&#39;t work. […]<br>&gt; <br>&gt; Exactly. If `seq.generate().next()` worked, I&#39;d be perfectly happy with that. […]<br></p><p>Right.<br></p><p>&gt; Le 3 janv. 2016 à 06:50, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br>&gt; <br>&gt;&gt; If I don’t sound sympathetic, it’s because nobody has shown a use-case for this functionality, and until I see one I am going to have a hard time believing there’s a problem worth solving.  If you want to make the case that we need something like this, please show me why. <br>&gt; <br>&gt; Didn&#39;t this thread start off with a use case?<br>&gt; <br>&gt; 	seq.lazy.filter(predicate).first		// is not actually lazy, and Swift provides no good way to do this<br>&gt; <br>&gt; One way to fix this is to add `first` to `SequenceType`, but it feels strange for a property to potentially consume part of the sequence. `buffered` ultimately has the same problem. By representing this as a function, it at least looks like something that might have side effects.<br></p><p>Out of honesty, here is another use case: `database.fetch(…).first`.<br></p><p>Since this is not possible today, database APIs have to expose another `fetchFirst()` (fetchOne, pluck, whatever) method, that uses a temporary generator on the sequence returned by the fetch() method.<br></p><p>If sequence.first would exist, the database API would not have to define this extra method.<br></p><p>Gwendal<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  2, 2016 at 10:00:00pm</p></header><div class="content"><p>On Sat, Jan 2, 2016, at 09:50 PM, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; &gt; If I don’t sound sympathetic, it’s because nobody has shown a use-case for this functionality, and until I see one I am going to have a hard time believing there’s a problem worth solving.  If you want to make the case that we need something like this, please show me why. <br>&gt; <br>&gt; Didn&#39;t this thread start off with a use case?<br>&gt; <br>&gt; 	seq.lazy.filter(predicate).first		// is not actually lazy, and Swift provides no good way to do this<br>&gt; <br>&gt; One way to fix this is to add `first` to `SequenceType`, but it feels strange for a property to potentially consume part of the sequence. `buffered` ultimately has the same problem. By representing this as a function, it at least looks like something that might have side effects.<br></p><p>`buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br></p><p>-Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; `buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br></p><p>If `seq` is a single-pass sequence, then `seq.buffered.first` will consume an element from `seq`, even though you only accessed two properties. That&#39;s why I call it problematic.<br></p><p>(If calling `buffered` somehow rendered the original sequence unusable—for instance, if we had some way to express that the `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t bother me as much.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  2, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sat, Jan 2, 2016, at 11:17 PM, Brent Royal-Gordon wrote:<br>&gt; &gt; `buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br>&gt; <br>&gt; If `seq` is a single-pass sequence, then `seq.buffered.first` will consume an element from `seq`, even though you only accessed two properties. That&#39;s why I call it problematic.<br>&gt; <br>&gt; (If calling `buffered` somehow rendered the original sequence unusable—for instance, if we had some way to express that the `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t bother me as much.)<br></p><p>If `sequence` is a single-pass sequence, wrapping it in any other sequence type and then doing anything with that other sequence type makes the original sequence unusable (or rather, you can still use it but the elements yielded from any further access to the original sequence can be completely arbitrary).<br></p><p>And for the record we already have precedent for the specific case of `seq.prop1.prop2` destructively consuming the original sequence: `seq.lazy.array`.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 11:26 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Jan 2, 2016, at 11:17 PM, Brent Royal-Gordon wrote:<br>&gt;&gt;&gt; `buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br>&gt;&gt; <br>&gt;&gt; If `seq` is a single-pass sequence, then `seq.buffered.first` will consume an element from `seq`, even though you only accessed two properties. That&#39;s why I call it problematic.<br>&gt;&gt; <br>&gt;&gt; (If calling `buffered` somehow rendered the original sequence unusable—for instance, if we had some way to express that the `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t bother me as much.)<br>&gt; <br>&gt; If `sequence` is a single-pass sequence, wrapping it in any other sequence type and then doing anything with that other sequence type makes the original sequence unusable (or rather, you can still use it but the elements yielded from any further access to the original sequence can be completely arbitrary).<br>&gt; <br>&gt; And for the record we already have precedent for the specific case of `seq.prop1.prop2` destructively consuming the original sequence: `seq.lazy.array`.<br></p><p>Yes, and there are arguments for dropping “.array” as a property.  The convention is that “conversions” (ill-defined, I know) use constructor syntax, and we are currently heading towards the elimination of &quot;convenience” interfaces that duplicate functionality, so we might end up with Array(seq).  <br></p><p>All that said, single-pass Sequences are just weird in that they get mutated without calling any mutating methods on them; you mutate them by calling a mutating method on a separate generator instance.  In other words, they fundamentally have reference semantics.  There may be some better way to address this whole area, but we’ll have to go much deeper than merely poking at the question of a  `.first` property. <br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  3, 2016 at 12:00:00am</p></header><div class="content"><p>On Sat, Jan 2, 2016, at 11:53 PM, Dave Abrahams wrote:<br>&gt; <br>&gt; &gt; On Jan 2, 2016, at 11:26 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; On Sat, Jan 2, 2016, at 11:17 PM, Brent Royal-Gordon wrote:<br>&gt; &gt;&gt;&gt; `buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; If `seq` is a single-pass sequence, then `seq.buffered.first` will consume an element from `seq`, even though you only accessed two properties. That&#39;s why I call it problematic.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; (If calling `buffered` somehow rendered the original sequence unusable—for instance, if we had some way to express that the `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t bother me as much.)<br>&gt; &gt; <br>&gt; &gt; If `sequence` is a single-pass sequence, wrapping it in any other sequence type and then doing anything with that other sequence type makes the original sequence unusable (or rather, you can still use it but the elements yielded from any further access to the original sequence can be completely arbitrary).<br>&gt; &gt; <br>&gt; &gt; And for the record we already have precedent for the specific case of `seq.prop1.prop2` destructively consuming the original sequence: `seq.lazy.array`.<br>&gt; <br>&gt; Yes, and there are arguments for dropping “.array” as a property.  The convention is that “conversions” (ill-defined, I know) use constructor syntax, and we are currently heading towards the elimination of &quot;convenience” interfaces that duplicate functionality, so we might end up with Array(seq).  <br>&gt; <br>&gt; All that said, single-pass Sequences are just weird in that they get mutated without calling any mutating methods on them; you mutate them by calling a mutating method on a separate generator instance.  In other words, they fundamentally have reference semantics.  There may be some better way to address this whole area, but we’ll have to go much deeper than merely poking at the question of a  `.first` property.<br></p><p>FWIW move-only structs (and safe immutable references) are a great solution to this. Rust is a good example. Rust&#39;s equivalent to SequenceType is IntoIterator, which has a method into_iter() that consumes the receiver and returns an Iterator. If a sequence is multi-pass, then instead of just implementing it on the type, the IntoIterator trait is also implemented on references to that type (e.g. both `Vec&lt;T&gt;` and `&amp;&#39;a Vec&lt;T&gt;` implement it) and sometimes on mutable references too (`&amp;&#39;a mut Vec&lt;T&gt;`). The multi-pass iterators actually yield references to the elements involved (e.g. the Iterator for `Vec&lt;T&gt;` yields `T`, but the Iterator for `&amp;&#39;a Vec&lt;T&gt;` yields `&amp;&#39;a T`). Similarly Iterator itself can be move-only if it&#39;s a single-pass iterator, but for multi-pass iterators the Iterator is either copyable or Clone-able. This scheme means that the type system documents whether a sequence/iterator is multi-pass and statically prevents you from violating that guarantee.<br></p><p>Of course, Swift doesn&#39;t have move-only structs and it doesn&#39;t have immutable references, but thinking long-term this does seem like a great model to be aware of.<br></p><p>-Kevin Ballard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 23:53, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 2, 2016, at 11:26 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sat, Jan 2, 2016, at 11:17 PM, Brent Royal-Gordon wrote:<br>&gt;&gt;&gt;&gt; `buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If `seq` is a single-pass sequence, then `seq.buffered.first` will consume an element from `seq`, even though you only accessed two properties. That&#39;s why I call it problematic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (If calling `buffered` somehow rendered the original sequence unusable—for instance, if we had some way to express that the `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t bother me as much.)<br>&gt;&gt; <br>&gt;&gt; If `sequence` is a single-pass sequence, wrapping it in any other sequence type and then doing anything with that other sequence type makes the original sequence unusable (or rather, you can still use it but the elements yielded from any further access to the original sequence can be completely arbitrary).<br>&gt;&gt; <br>&gt;&gt; And for the record we already have precedent for the specific case of `seq.prop1.prop2` destructively consuming the original sequence: `seq.lazy.array`.<br>&gt; <br>&gt; Yes, and there are arguments for dropping “.array” as a property.  The convention is that “conversions” (ill-defined, I know) use constructor syntax, and we are currently heading towards the elimination of &quot;convenience” interfaces that duplicate functionality, so we might end up with Array(seq).  <br>&gt; <br>&gt; All that said, single-pass Sequences are just weird in that they get mutated without calling any mutating methods on them; you mutate them by calling a mutating method on a separate generator instance.  In other words, they fundamentally have reference semantics. There may be some better way to address this whole area, but we’ll have to go much deeper than merely poking at the question of a `.first` property. <br></p><p>Should &quot;generate()&quot; be a mutating method on SequenceType, then? And a non-mutating one on CollectionType, obviously.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/39ba58f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Jan 5, 2016, at 03:43 PM, Jordan Rose wrote:<br>&gt;<br>&gt;&gt; On Jan 2, 2016, at 23:53, Dave Abrahams via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 2, 2016, at 11:26 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Jan 2, 2016, at 11:17 PM, Brent Royal-Gordon wrote:<br>&gt;&gt;&gt;&gt;&gt; `buffered` is no more problematic than `lazy` is. In fact, calling<br>&gt;&gt;&gt;&gt;&gt; `buffered` actually doesn&#39;t have any side-effects at all (it can<br>&gt;&gt;&gt;&gt;&gt; avoid fetching the first element until you call `first` on the<br>&gt;&gt;&gt;&gt;&gt; result of `buffered`).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If `seq` is a single-pass sequence, then `seq.buffered.first` will<br>&gt;&gt;&gt;&gt; consume an element from `seq`, even though you only accessed two<br>&gt;&gt;&gt;&gt; properties. That&#39;s why I call it problematic.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (If calling `buffered` somehow rendered the original sequence<br>&gt;&gt;&gt;&gt; unusable—for instance, if we had some way to express that the<br>&gt;&gt;&gt;&gt; `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t<br>&gt;&gt;&gt;&gt; bother me as much.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If `sequence` is a single-pass sequence, wrapping it in any other<br>&gt;&gt;&gt; sequence type and then doing anything with that other sequence type<br>&gt;&gt;&gt; makes the original sequence unusable (or rather, you can still use<br>&gt;&gt;&gt; it but the elements yielded from any further access to the original<br>&gt;&gt;&gt; sequence can be completely arbitrary).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And for the record we already have precedent for the specific case<br>&gt;&gt;&gt; of `seq.prop1.prop2` destructively consuming the original sequence:<br>&gt;&gt;&gt; `seq.lazy.array`.<br>&gt;&gt;<br>&gt;&gt; Yes, and there are arguments for dropping “.array” as a property.<br>&gt;&gt; The convention is that “conversions” (ill-defined, I know) use<br>&gt;&gt; constructor syntax, and we are currently heading towards the<br>&gt;&gt; elimination of &quot;convenience” interfaces that duplicate functionality,<br>&gt;&gt; so we might end up with Array(seq).<br>&gt;&gt;<br>&gt;&gt; All that said, single-pass Sequences are just weird in that they get<br>&gt;&gt; mutated without calling any mutating methods on them; you mutate them<br>&gt;&gt; by calling a mutating method on a separate generator instance.  In<br>&gt;&gt; other words, they fundamentally have reference semantics. There may<br>&gt;&gt; be some better way to address this whole area, but we’ll have to go<br>&gt;&gt; much deeper than merely poking at the question of a `.first`<br>&gt;&gt; property.<br>&gt;<br>&gt; Should &quot;generate()&quot; be a mutating method on SequenceType, then? And a<br>&gt; non-mutating one on CollectionType, obviously.<br></p><p>No, that would make SequenceType too hard to use. Specific sequences<br>could still have non-mutating generate() methods, but any kind of<br>generic Sequence wrapper would be forced to use a mutating generate(),<br>and that would make the ergonomics of using them awful. For example,<br>instead of<br></p><p>for x in seq.lazy.map(f) { ... }<br></p><p>you&#39;d have to say<br></p><p>var seq2 = seq.lazy.map(f)    for x in seq { ... }<br></p><p>And in the end, it wouldn&#39;t really solve anything anyway, because you<br>can still implement single-pass sequences using a non-mutating<br>generate() anyway (either the sequence is a class, or it uses a class or<br>UnsafeMutablePointer internally, or it manipulates global state, e.g. a<br>sequence that reads lines from stdin with readLine()).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/47ba0dba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 16:43 , Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jan 5, 2016, at 03:43 PM, Jordan Rose wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 2, 2016, at 23:53, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 2, 2016, at 11:26 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Sat, Jan 2, 2016, at 11:17 PM, Brent Royal-Gordon wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; `buffered` is no more problematic than `lazy` is. In fact, calling `buffered` actually doesn&#39;t have any side-effects at all (it can avoid fetching the first element until you call `first` on the result of `buffered`).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; If `seq` is a single-pass sequence, then `seq.buffered.first` will consume an element from `seq`, even though you only accessed two properties. That&#39;s why I call it problematic.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; (If calling `buffered` somehow rendered the original sequence unusable—for instance, if we had some way to express that the `BufferedSequence` takes unique ownership of its base—this wouldn&#39;t bother me as much.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; If `sequence` is a single-pass sequence, wrapping it in any other sequence type and then doing anything with that other sequence type makes the original sequence unusable (or rather, you can still use it but the elements yielded from any further access to the original sequence can be completely arbitrary).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; And for the record we already have precedent for the specific case of `seq.prop1.prop2` destructively consuming the original sequence: `seq.lazy.array`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Yes, and there are arguments for dropping “.array” as a property.  The convention is that “conversions” (ill-defined, I know) use constructor syntax, and we are currently heading towards the elimination of &quot;convenience” interfaces that duplicate functionality, so we might end up with Array(seq).  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; All that said, single-pass Sequences are just weird in that they get mutated without calling any mutating methods on them; you mutate them by calling a mutating method on a separate generator instance.  In other words, they fundamentally have reference semantics. There may be some better way to address this whole area, but we’ll have to go much deeper than merely poking at the question of a `.first` property.<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; Should &quot;generate()&quot; be a mutating method on SequenceType, then? And a non-mutating one on CollectionType, obviously.<br>&gt;  <br>&gt; No, that would make SequenceType too hard to use. Specific sequences could still have non-mutating generate() methods, but any kind of generic Sequence wrapper would be forced to use a mutating generate(), and that would make the ergonomics of using them awful. For example, instead of<br>&gt;  <br>&gt;     for x in seq.lazy.map(f) { ... }<br>&gt;  <br>&gt; you&#39;d have to say<br>&gt;  <br>&gt;     var seq2 = seq.lazy.map(f)<br>&gt;     for x in seq { ... }<br>&gt;  <br>&gt; And in the end, it wouldn&#39;t really solve anything anyway, because you can still implement single-pass sequences using a non-mutating generate() anyway (either the sequence is a class, or it uses a class or UnsafeMutablePointer internally, or it manipulates global state, e.g. a sequence that reads lines from stdin with readLine()).<br>&gt;  <br></p><p>That&#39;s a good point. I still feel like there&#39;s something missing (see also my Sequence/Generator/Collection thoughts on the PermutationGenerator thread), but we certainly wouldn&#39;t want to break simple, common uses of LazySequence or AnySequence.<br></p><p>Thanks for steering me in the right direction.<br>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/8f3163a2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Add SequenceType.first</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>My two cents: I feel uncomfortable with SequenceType.first since SequenceType clearly states that it may be destructed on iteration.<br></p><p>Compare :<br></p><p>seq.generate().next() // clear that it may give another result if called twice<br>seq.first             // unclear that it may give another result if called twice<br></p><p>Gwendal<br></p><p>&gt; Le 31 déc. 2015 à 00:57, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; It&#39;s sometimes useful to get the first element of a sequence. To that end I&#39;d like to propose<br>&gt;  <br>&gt; extension SequenceType {<br>&gt;     /// Returns the first element of `self`, or `nil` if `self` is empty.<br>&gt;     /// - Complexity: O(1)<br>&gt;     var first: Self.Generator.Element? {<br>&gt;         var gen = generate()<br>&gt;         return gen.next()<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; I think it makes sense to add this property to the definition of SequenceType as well, so various sequences can override it to avoid constructing a generator.<br>&gt;  <br>&gt; With this added to SequenceType, we can remove it from CollectionType, as the behavior will be the same.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/5515083e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
