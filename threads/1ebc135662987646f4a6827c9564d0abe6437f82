<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br></p><p>Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br></p><p>anArray.map{$0.anInstanceMethod()}<br></p><p>becomes:<br></p><p>anArray.map(.anInstanceMethod())<br></p><p>This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br></p><p>The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br></p><p>I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c753185b2c9261f9da6bf4372036cd07?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Sean Kosanovich</string> &lt;sean7512 at me.com&gt;<p>December 18, 2015 at 07:00:00am</p></header><div class="content"><p>This was/is being discussed at length in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002742.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002742.html&gt;<br></p><p><br></p><p>&gt; On Dec 17, 2015, at 10:27 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt; <br>&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt; <br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt; <br>&gt; becomes:<br>&gt; <br>&gt; anArray.map(.anInstanceMethod())<br>&gt; <br>&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt; <br>&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt; <br>&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/aa0f85c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 06:00:00am</p></header><div class="content"><p>Thanks for lining to the original thread Sean.  I should have done that myself.<br></p><p>I started a new thread as this is really an independent feature that is related to the spread operator but stands on its own.  It deserves a thread and subject line of its own.<br></p><p>Matthew<br></p><p><br>Sent from my iPad<br></p><p>&gt; On Dec 18, 2015, at 6:38 AM, Sean Kosanovich &lt;sean7512 at me.com&gt; wrote:<br>&gt; <br>&gt; This was/is being discussed at length in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002742.html<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 10:27 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt; <br>&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt; <br>&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt; <br>&gt;&gt; becomes:<br>&gt;&gt; <br>&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt; <br>&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt; <br>&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt; <br>&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/bd739242/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c753185b2c9261f9da6bf4372036cd07?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Sean Kosanovich</string> &lt;sean7512 at me.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>Matthew,<br></p><p>Understood, I just wanted to link the conversations together.<br></p><p>As for the idea, I am a huge fan of removing the necessary $0.<br></p><p>-Sean<br></p><p>&gt; On Dec 18, 2015, at 7:57 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks for lining to the original thread Sean.  I should have done that myself.<br>&gt; <br>&gt; I started a new thread as this is really an independent feature that is related to the spread operator but stands on its own.  It deserves a thread and subject line of its own.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 18, 2015, at 6:38 AM, Sean Kosanovich &lt;sean7512 at me.com &lt;mailto:sean7512 at me.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; This was/is being discussed at length in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002742.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002742.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 10:27 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/629170dc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt; <br>&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt; <br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt; <br>&gt; becomes:<br>&gt; <br>&gt; anArray.map(.anInstanceMethod())<br>&gt; <br>&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt; <br>&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt; <br>&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt; <br>&gt; Matthew<br></p><p>I’d be interested to hear peoples thoughts regarding this proposal. I’m personally in favour, but perhaps there are potential issues with the suggestion?<br></p><p>It’s only a small visual change, but I think it is a syntactic improvement. Let’s pretend for a moment that the current syntax was:<br>anArray.map(.anInstanceMethod())<br></p><p>I’m not sure many people would argue for it to be changed to:<br>anArray.map { $0.anInstanceMethod() }<br></p><p>Al<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/6530a120/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt; <br>&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt; <br>&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt; <br>&gt;&gt; becomes:<br>&gt;&gt; <br>&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt; <br>&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt; <br>&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt; <br>&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt; <br>&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m personally in favour, but perhaps there are potential issues with the suggestion?<br>&gt; <br>&gt; It’s only a small visual change, but I think it is a syntactic improvement. Let’s pretend for a moment that the current syntax was:<br>&gt; anArray.map(.anInstanceMethod())<br>&gt; <br>&gt; I’m not sure many people would argue for it to be changed to:<br>&gt; anArray.map { $0.anInstanceMethod() }<br></p><p>Thanks Al.  I should have also pointed out that the syntactic advantage is a bit greater in other contexts where the braces would not replace parentheses:<br></p><p>struct S {<br>  var predicate: String -&gt; Bool<br>}<br></p><p>var s = S()<br>s.predicate = { $0.hasPrefix(“abc”) }<br></p><p>vs<br>s.predicate = .hasPrefix(“abc”)<br></p><p>It’s not a super important change, but maybe a low-hanging fruit item that can improve clarity and readability.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8c1fb354/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>+1. One important consideration, however, and I would love to see some<br>input from Chris Lattner or someone else who works on LLVM, is how much it<br>would complicate the grammar of the language when all possible cases are<br>considered.<br></p><p>On Fri, Dec 18, 2015, 8:05 AM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br>&gt;<br>&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift currently offers dot shorthand for static members of type Self in<br>&gt; type contexts expecting a value of the type in question.  This is most<br>&gt; commonly used with enum cases.<br>&gt;<br>&gt; Swift does not currently offer shorthand for instance members.<br>&gt; Introducing a shorthand for instance members would improve clarity and<br>&gt; readability of code in common cases:<br>&gt;<br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;<br>&gt; becomes:<br>&gt;<br>&gt; anArray.map(.anInstanceMethod())<br>&gt;<br>&gt; This shorthand would work in typing contexts expecting a single argument<br>&gt; function.  It would allow abbreviated access to any visible instance<br>&gt; property getter or instance method on the type of the argument.  Of course<br>&gt; the return type would need to match the return type expected by the context<br>&gt; or a type mismatch compiler error would occur.<br>&gt;<br>&gt; The readability advantage is arguably small but it does exist.  The<br>&gt; feature also aligns very well with an existing language feature.<br>&gt;<br>&gt; I think it’s an interesting idea and am wondering whether others feel like<br>&gt; it is something worth pursuing or not.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m<br>&gt; personally in favour, but perhaps there are potential issues with the<br>&gt; suggestion?<br>&gt;<br>&gt; It’s only a small visual change, but I think it is a syntactic<br>&gt; improvement. Let’s pretend for a moment that the current syntax was:<br>&gt; *anArray.map(.anInstanceMethod())*<br>&gt;<br>&gt; I’m not sure many people would argue for it to be changed to:<br>&gt; *anArray.map { $0.anInstanceMethod() }*<br>&gt;<br>&gt;<br>&gt; Thanks Al.  I should have also pointed out that the syntactic advantage is<br>&gt; a bit greater in other contexts where the braces would not replace<br>&gt; parentheses:<br>&gt;<br>&gt; struct S {<br>&gt;   var predicate: String -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; var s = S()<br>&gt; s.predicate = { $0.hasPrefix(“abc”) }<br>&gt;<br>&gt; vs<br>&gt; s.predicate = .hasPrefix(“abc”)<br>&gt;<br>&gt; It’s not a super important change, but maybe a low-hanging fruit item that<br>&gt; can improve clarity and readability.<br>&gt;<br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/401b4cdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; +1. One important consideration, however, and I would love to see some input from Chris Lattner or someone else who works on LLVM, is how much it would complicate the grammar of the language when all possible cases are considered.<br></p><p>I ran this by Joe Groff on Twitter and he said it makes sense.  Would be great to get a comment on the list as well.  <br></p><p>It’s quite similar to the existing dot shorthand for static members but applies in a different typing context.  I may be overlooking something but I don’t believe there would be any complications that were not addressed there.<br></p><p><br>&gt; <br>&gt; On Fri, Dec 18, 2015, 8:05 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm &lt;mailto:al_skipp at fastmail.fm&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m personally in favour, but perhaps there are potential issues with the suggestion?<br>&gt;&gt; <br>&gt;&gt; It’s only a small visual change, but I think it is a syntactic improvement. Let’s pretend for a moment that the current syntax was:<br>&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt; <br>&gt;&gt; I’m not sure many people would argue for it to be changed to:<br>&gt;&gt; anArray.map { $0.anInstanceMethod() }<br>&gt; <br>&gt; Thanks Al.  I should have also pointed out that the syntactic advantage is a bit greater in other contexts where the braces would not replace parentheses:<br>&gt; <br>&gt; struct S {<br>&gt;   var predicate: String -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; var s = S()<br>&gt; s.predicate = { $0.hasPrefix(“abc”) }<br>&gt; <br>&gt; vs<br>&gt; s.predicate = .hasPrefix(“abc”)<br>&gt; <br>&gt; It’s not a super important change, but maybe a low-hanging fruit item that can improve clarity and readability.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1d86c183/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/57885cfd0c4b4db16653e76d9e6f0266?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Johan Jensen</string> &lt;jj at johanjensen.dk&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>I’m not very fond of having just a single dot in front of the method call,<br>as it could easily be missed.<br>In the case of s.predicate = .hasPrefix(&quot;abc&quot;), I would prefer something<br>slightly more expressive.<br></p><p>As it is right now in Swift, accessing methods directly gives you a curried<br>function back, which expects the object instance as argument in the first<br>call, and the rest in the second call.<br>E.g. String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;) is the same as &quot;abcd&quot;.hasPrefix(&quot;a&quot;)<br></p><p>Flipping the arguments like this:<br>func flip&lt;A, B, C&gt;(f: A -&gt; B -&gt; C) -&gt; (B -&gt; A -&gt; C) {<br>    return { valB in<br>        return { valA in<br>            return f(valA)(valB)<br>        }<br>    }<br>}<br></p><p>String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;)<br>let myHasPrefix = flip(String.hasPrefix)<br>myHasPrefix(&quot;a&quot;)(&quot;abcd&quot;)<br></p><p>…would allow us to write the following:<br>s.predicate = flip(String.hasPrefix(&quot;abcd&quot;))<br></p><p>Perhaps it could be extended to something akin to<br>s.predicate = String::hasPrefix(&quot;abcd&quot;)<br></p><p>The currying only works for methods and not for properties, so this isn’t<br>currently possible to express like the above:<br>[&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.endIndex })<br>[&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.characters.count })<br></p><p>—Johan<br></p><p>On Fri, Dec 18, 2015 at 2:05 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br>&gt;<br>&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift currently offers dot shorthand for static members of type Self in<br>&gt; type contexts expecting a value of the type in question.  This is most<br>&gt; commonly used with enum cases.<br>&gt;<br>&gt; Swift does not currently offer shorthand for instance members.<br>&gt; Introducing a shorthand for instance members would improve clarity and<br>&gt; readability of code in common cases:<br>&gt;<br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;<br>&gt; becomes:<br>&gt;<br>&gt; anArray.map(.anInstanceMethod())<br>&gt;<br>&gt; This shorthand would work in typing contexts expecting a single argument<br>&gt; function.  It would allow abbreviated access to any visible instance<br>&gt; property getter or instance method on the type of the argument.  Of course<br>&gt; the return type would need to match the return type expected by the context<br>&gt; or a type mismatch compiler error would occur.<br>&gt;<br>&gt; The readability advantage is arguably small but it does exist.  The<br>&gt; feature also aligns very well with an existing language feature.<br>&gt;<br>&gt; I think it’s an interesting idea and am wondering whether others feel like<br>&gt; it is something worth pursuing or not.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m<br>&gt; personally in favour, but perhaps there are potential issues with the<br>&gt; suggestion?<br>&gt;<br>&gt; It’s only a small visual change, but I think it is a syntactic<br>&gt; improvement. Let’s pretend for a moment that the current syntax was:<br>&gt; *anArray.map(.anInstanceMethod())*<br>&gt;<br>&gt; I’m not sure many people would argue for it to be changed to:<br>&gt; *anArray.map { $0.anInstanceMethod() }*<br>&gt;<br>&gt;<br>&gt; Thanks Al.  I should have also pointed out that the syntactic advantage is<br>&gt; a bit greater in other contexts where the braces would not replace<br>&gt; parentheses:<br>&gt;<br>&gt; struct S {<br>&gt;   var predicate: String -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; var s = S()<br>&gt; s.predicate = { $0.hasPrefix(“abc”) }<br>&gt;<br>&gt; vs<br>&gt; s.predicate = .hasPrefix(“abc”)<br>&gt;<br>&gt; It’s not a super important change, but maybe a low-hanging fruit item that<br>&gt; can improve clarity and readability.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/4b02b7f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; As it is right now in Swift, accessing methods directly gives you a curried function back, which expects the object instance as argument in the first call, and the rest in the second call.<br>That was my first thought when I read the proposal - and as there is already a change planned for currying, it could be easy to change the way it works for methods.<br></p><p>I really don&#39;t think that &quot;.method()&quot; improves clarity, but &quot;Type.method&quot; definitely does.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/12f82841/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>Johan, you are right that all of this is possible but it seems rather verbose to me.  I’d rather use the currently possible { $0.member } syntax.  The point of the idea is to remove syntactic noise.  <br></p><p>It’s reasonable to argue that this isn’t necessary, but in that case the current state suffices IMO.  We don’t need a more verbose alternative to what we already have.<br></p><p><br>&gt; On Dec 18, 2015, at 9:00 AM, Johan Jensen &lt;jj at johanjensen.dk&gt; wrote:<br>&gt; <br>&gt; I’m not very fond of having just a single dot in front of the method call, as it could easily be missed.<br>&gt; In the case of s.predicate = .hasPrefix(&quot;abc&quot;), I would prefer something slightly more expressive.<br>&gt; <br>&gt; As it is right now in Swift, accessing methods directly gives you a curried function back, which expects the object instance as argument in the first call, and the rest in the second call.<br>&gt; E.g. String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;) is the same as &quot;abcd&quot;.hasPrefix(&quot;a&quot;)<br>&gt; <br>&gt; Flipping the arguments like this:<br>&gt; func flip&lt;A, B, C&gt;(f: A -&gt; B -&gt; C) -&gt; (B -&gt; A -&gt; C) {<br>&gt;     return { valB in<br>&gt;         return { valA in<br>&gt;             return f(valA)(valB)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;)<br>&gt; let myHasPrefix = flip(String.hasPrefix)<br>&gt; myHasPrefix(&quot;a&quot;)(&quot;abcd&quot;)<br>&gt; <br>&gt; …would allow us to write the following:<br>&gt; s.predicate = flip(String.hasPrefix(&quot;abcd&quot;))<br>&gt; <br>&gt; Perhaps it could be extended to something akin to<br>&gt; s.predicate = String::hasPrefix(&quot;abcd&quot;)<br>&gt; <br>&gt; The currying only works for methods and not for properties, so this isn’t currently possible to express like the above:<br>&gt; [&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.endIndex })<br>&gt; [&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.characters.count })<br>&gt; <br>&gt; —Johan<br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 2:05 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm &lt;mailto:al_skipp at fastmail.fm&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m personally in favour, but perhaps there are potential issues with the suggestion?<br>&gt;&gt; <br>&gt;&gt; It’s only a small visual change, but I think it is a syntactic improvement. Let’s pretend for a moment that the current syntax was:<br>&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt; <br>&gt;&gt; I’m not sure many people would argue for it to be changed to:<br>&gt;&gt; anArray.map { $0.anInstanceMethod() }<br>&gt; <br>&gt; Thanks Al.  I should have also pointed out that the syntactic advantage is a bit greater in other contexts where the braces would not replace parentheses:<br>&gt; <br>&gt; struct S {<br>&gt;   var predicate: String -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; var s = S()<br>&gt; s.predicate = { $0.hasPrefix(“abc”) }<br>&gt; <br>&gt; vs<br>&gt; s.predicate = .hasPrefix(“abc”)<br>&gt; <br>&gt; It’s not a super important change, but maybe a low-hanging fruit item that can improve clarity and readability.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1e0dacaf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>For me there are two sources to the feeling of noise with simple single-statement closures and using $0, etc. - The first are the braces that seem redundant when there’s only a single statement, and the second is the presence of $0. <br></p><p>I played around a bit, and this is probably just a personal preference thing, but I don’t think it’s the $ that bothers me, really, but instead it is the digit that makes it feel noisy. When I change $0 to $a, $b, etc. suddenly the code doesn’t feel so noisy to me. This may simply be because I rarely ever put a number in my variable names, and if I do, I almost always start at 1 and not 0. :P Again, this might just be me. :)<br></p><p>    someArray.map({ $0.property })<br>    someArray.map({ $a.property })<br></p><p>Then it occurred to me that for the simple case of doing a map or filter or whatever using a single method call, what if Swift could instead make an assumption that if there’s a $ variable outside of a closure, we meant to start a single-statement closure so something like this could be possible:<br></p><p>    someArray.map($0.property)<br>    someArray.map($a.property)<br></p><p>And going farther with this, in the case where there’s only a single argument in the closure, maybe we could skip the number/letter entirely and just use are bare $ instead of $0:<br></p><p>    someArray.map({ $.property })<br></p><p>And finally, combined with the single-statement shortcut:<br></p><p>    someArray.map($.property)<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 18, 2015, at 9:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Johan, you are right that all of this is possible but it seems rather verbose to me.  I’d rather use the currently possible { $0.member } syntax.  The point of the idea is to remove syntactic noise.  <br>&gt; <br>&gt; It’s reasonable to argue that this isn’t necessary, but in that case the current state suffices IMO.  We don’t need a more verbose alternative to what we already have.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 9:00 AM, Johan Jensen &lt;jj at johanjensen.dk&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not very fond of having just a single dot in front of the method call, as it could easily be missed.<br>&gt;&gt; In the case of s.predicate = .hasPrefix(&quot;abc&quot;), I would prefer something slightly more expressive.<br>&gt;&gt; <br>&gt;&gt; As it is right now in Swift, accessing methods directly gives you a curried function back, which expects the object instance as argument in the first call, and the rest in the second call.<br>&gt;&gt; E.g. String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;) is the same as &quot;abcd&quot;.hasPrefix(&quot;a&quot;)<br>&gt;&gt; <br>&gt;&gt; Flipping the arguments like this:<br>&gt;&gt; func flip&lt;A, B, C&gt;(f: A -&gt; B -&gt; C) -&gt; (B -&gt; A -&gt; C) {<br>&gt;&gt;     return { valB in<br>&gt;&gt;         return { valA in<br>&gt;&gt;             return f(valA)(valB)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;)<br>&gt;&gt; let myHasPrefix = flip(String.hasPrefix)<br>&gt;&gt; myHasPrefix(&quot;a&quot;)(&quot;abcd&quot;)<br>&gt;&gt; <br>&gt;&gt; …would allow us to write the following:<br>&gt;&gt; s.predicate = flip(String.hasPrefix(&quot;abcd&quot;))<br>&gt;&gt; <br>&gt;&gt; Perhaps it could be extended to something akin to<br>&gt;&gt; s.predicate = String::hasPrefix(&quot;abcd&quot;)<br>&gt;&gt; <br>&gt;&gt; The currying only works for methods and not for properties, so this isn’t currently possible to express like the above:<br>&gt;&gt; [&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.endIndex })<br>&gt;&gt; [&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.characters.count })<br>&gt;&gt; <br>&gt;&gt; —Johan<br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 18, 2015 at 2:05 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m personally in favour, but perhaps there are potential issues with the suggestion?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s only a small visual change, but I think it is a syntactic improvement. Let’s pretend for a moment that the current syntax was:<br>&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure many people would argue for it to be changed to:<br>&gt;&gt;&gt; anArray.map { $0.anInstanceMethod() }<br>&gt;&gt; <br>&gt;&gt; Thanks Al.  I should have also pointed out that the syntactic advantage is a bit greater in other contexts where the braces would not replace parentheses:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   var predicate: String -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var s = S()<br>&gt;&gt; s.predicate = { $0.hasPrefix(“abc”) }<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; s.predicate = .hasPrefix(“abc”)<br>&gt;&gt; <br>&gt;&gt; It’s not a super important change, but maybe a low-hanging fruit item that can improve clarity and readability.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>That&#39;s an interesting idea.  It&#39;s a further shorthand for closures rather than an extension of dot shorthand in a new type context.  I wonder if this would apply in contexts where the dot shorthand wouldn&#39;t.<br></p><p>From a readability point of view I definitely prefer the dot shorthand.  The $ after the opening parenthesis doesn&#39;t leave enough &quot;whitespace&quot; for my eyes and makes things appear cluttered.<br></p><p>someArray.map($.property)<br></p><p>someArray.map(.property)<br></p><p>That said, I do like the idea of being able to drop the 0 in more complex single-argument closures.<br></p><p>Matthew<br></p><p><br>Sent from my iPad<br></p><p>&gt; On Dec 18, 2015, at 10:15 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; For me there are two sources to the feeling of noise with simple single-statement closures and using $0, etc. - The first are the braces that seem redundant when there’s only a single statement, and the second is the presence of $0. <br>&gt; <br>&gt; I played around a bit, and this is probably just a personal preference thing, but I don’t think it’s the $ that bothers me, really, but instead it is the digit that makes it feel noisy. When I change $0 to $a, $b, etc. suddenly the code doesn’t feel so noisy to me. This may simply be because I rarely ever put a number in my variable names, and if I do, I almost always start at 1 and not 0. :P Again, this might just be me. :)<br>&gt; <br>&gt;    someArray.map({ $0.property })<br>&gt;    someArray.map({ $a.property })<br>&gt; <br>&gt; Then it occurred to me that for the simple case of doing a map or filter or whatever using a single method call, what if Swift could instead make an assumption that if there’s a $ variable outside of a closure, we meant to start a single-statement closure so something like this could be possible:<br>&gt; <br>&gt;    someArray.map($0.property)<br>&gt;    someArray.map($a.property)<br>&gt; <br>&gt; And going farther with this, in the case where there’s only a single argument in the closure, maybe we could skip the number/letter entirely and just use are bare $ instead of $0:<br>&gt; <br>&gt;    someArray.map({ $.property })<br>&gt; <br>&gt; And finally, combined with the single-statement shortcut:<br>&gt; <br>&gt;    someArray.map($.property)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 9:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Johan, you are right that all of this is possible but it seems rather verbose to me.  I’d rather use the currently possible { $0.member } syntax.  The point of the idea is to remove syntactic noise.  <br>&gt;&gt; <br>&gt;&gt; It’s reasonable to argue that this isn’t necessary, but in that case the current state suffices IMO.  We don’t need a more verbose alternative to what we already have.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 9:00 AM, Johan Jensen &lt;jj at johanjensen.dk&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not very fond of having just a single dot in front of the method call, as it could easily be missed.<br>&gt;&gt;&gt; In the case of s.predicate = .hasPrefix(&quot;abc&quot;), I would prefer something slightly more expressive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As it is right now in Swift, accessing methods directly gives you a curried function back, which expects the object instance as argument in the first call, and the rest in the second call.<br>&gt;&gt;&gt; E.g. String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;) is the same as &quot;abcd&quot;.hasPrefix(&quot;a&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Flipping the arguments like this:<br>&gt;&gt;&gt; func flip&lt;A, B, C&gt;(f: A -&gt; B -&gt; C) -&gt; (B -&gt; A -&gt; C) {<br>&gt;&gt;&gt;    return { valB in<br>&gt;&gt;&gt;        return { valA in<br>&gt;&gt;&gt;            return f(valA)(valB)<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; String.hasPrefix(&quot;abcd&quot;)(&quot;a&quot;)<br>&gt;&gt;&gt; let myHasPrefix = flip(String.hasPrefix)<br>&gt;&gt;&gt; myHasPrefix(&quot;a&quot;)(&quot;abcd&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …would allow us to write the following:<br>&gt;&gt;&gt; s.predicate = flip(String.hasPrefix(&quot;abcd&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps it could be extended to something akin to<br>&gt;&gt;&gt; s.predicate = String::hasPrefix(&quot;abcd&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The currying only works for methods and not for properties, so this isn’t currently possible to express like the above:<br>&gt;&gt;&gt; [&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.endIndex })<br>&gt;&gt;&gt; [&quot;John&quot;, &quot;Rachel&quot;, &quot;Thomas&quot;].map({ $0.characters.count })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —Johan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015 at 2:05 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 18, 2015, at 6:52 AM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 18 Dec 2015, at 03:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be interested to hear peoples thoughts regarding this proposal. I’m personally in favour, but perhaps there are potential issues with the suggestion?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s only a small visual change, but I think it is a syntactic improvement. Let’s pretend for a moment that the current syntax was:<br>&gt;&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure many people would argue for it to be changed to:<br>&gt;&gt;&gt;&gt; anArray.map { $0.anInstanceMethod() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks Al.  I should have also pointed out that the syntactic advantage is a bit greater in other contexts where the braces would not replace parentheses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;  var predicate: String -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var s = S()<br>&gt;&gt;&gt; s.predicate = { $0.hasPrefix(“abc”) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; s.predicate = .hasPrefix(“abc”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not a super important change, but maybe a low-hanging fruit item that can improve clarity and readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/e9da4544/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>December 18, 2015 at 08:00:00pm</p></header><div class="content"><p>Interesting! I’d definitely be for some shortcut syntax here, as this seems to be a very, very common pattern. Passing a function to, say, `map` is so much easier and cleaner than passing a method in Swift — even though Swift generally always prefers methods to functions!<br></p><p>I haven’t spent too much thinking this through, but I think this is sound.<br></p><p>For contexts where a T is expected, .foo means T.foo<br></p><p>But it’s not ambiguous here, because we’re expecting T -&gt; U here, and functions can’t have static members (or any members for that matter :P). So passing a .foo could unambiguously mean T.foo(T) — an instance method on T, returning U.<br></p><p>I’d be for dropping the parens, they seem unnecessary, and are confusing (we’re passing a function, not calling it). It should be unambiguous with properties since methods and properties share a name space.<br></p><p>And, speaking of, I’d also just make it work with properties with the same syntax. So array.map(.foo) would call $0.foo() if `foo` is a method, or $0.foo if `foo` is a property.<br></p><p>(Am I missing something?)<br></p><p>— Radek<br></p><p>&gt; On 18 Dec 2015, at 04:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt; <br>&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt; <br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt; <br>&gt; becomes:<br>&gt; <br>&gt; anArray.map(.anInstanceMethod())<br>&gt; <br>&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt; <br>&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt; <br>&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 1:36 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; Interesting! I’d definitely be for some shortcut syntax here, as this seems to be a very, very common pattern. Passing a function to, say, `map` is so much easier and cleaner than passing a method in Swift — even though Swift generally always prefers methods to functions!<br>&gt; <br>&gt; I haven’t spent too much thinking this through, but I think this is sound.<br>&gt; <br>&gt; For contexts where a T is expected, .foo means T.foo<br>&gt; <br>&gt; But it’s not ambiguous here, because we’re expecting T -&gt; U here, and functions can’t have static members (or any members for that matter :P). So passing a .foo could unambiguously mean T.foo(T) — an instance method on T, returning U.<br>&gt; <br>&gt; I’d be for dropping the parens, they seem unnecessary, and are confusing (we’re passing a function, not calling it). It should be unambiguous with properties since methods and properties share a name space.<br>&gt; <br>&gt; And, speaking of, I’d also just make it work with properties with the same syntax. So array.map(.foo) would call $0.foo() if `foo` is a method, or $0.foo if `foo` is a property.<br></p><p>I probably should have showed more examples in my original post.<br></p><p>Making this work with property getters was one of the examples I posted in the other thread:<br></p><p>anArray.map(.aProperty)<br></p><p>The reason I used parentheses in the example of a method that takes no argument is that what we’re actually doing is binding the non-self arguments.  This is more clear with an example of a method that does take additional arguments:<br></p><p>anArray.map(.hasPrefix(“foo”))<br></p><p>I hadn’t tried declaring property and no argument method with the same name until you said this.  You are correct that it’s unambiguous. I didn’t realize this when I first posted this idea.  <br></p><p>If we don’t omit them it’s always clear whether we are passing a property or a method.  I think requiring the parentheses is probably worth the syntactic cost.  It also allows for a straightforward rewrite to a closure by wrapping the expression in braces and placing $0 prior to the dot.<br></p><p>&gt; <br>&gt; (Am I missing something?)<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 04:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt; <br>&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt; <br>&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt; <br>&gt;&gt; becomes:<br>&gt;&gt; <br>&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt; <br>&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt; <br>&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt; <br>&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>December 19, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; anArray.map(.hasPrefix(“foo”))<br></p><p>I’m against this. Yes, it extends the functionality of the proposal even more and could allow for more closures to be rewritten in this style — but at a severe cost in clarity IMHO.<br></p><p>I mean, with `map(.aMethod)`, you’re passing a reference to a method available on the receiver. This is actually very similar to passing `foo(.EnumCase)`, as in both cases we’re accessing a static member of the type. (Yes, also with the former example if you consider instance methods as curried functions on the type that take self as the first parameter.) So, there’s some nice symmetry and predictability, even if the dot-syntax has more than one use.<br></p><p>But with `map(.hasPrefix(“foo”))`, you’re implicitly constructing a new closure, that calls a method, and passes an argument. This isn’t immediately obvious. There’s no symmetry. It looks as if I was passing the result of calling some method, and the dot at the beginning meant something else (cf the se-0009 review thread). I couldn’t figure easily figure out that this is actually implicit contents of a new closure.<br></p><p>The potential for confusion is great. I’m not convinced the benefit outweighs the cost here.<br></p><p>— Radek<br></p><p>&gt; On 19 Dec 2015, at 02:10, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 1:36 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Interesting! I’d definitely be for some shortcut syntax here, as this seems to be a very, very common pattern. Passing a function to, say, `map` is so much easier and cleaner than passing a method in Swift — even though Swift generally always prefers methods to functions!<br>&gt;&gt; <br>&gt;&gt; I haven’t spent too much thinking this through, but I think this is sound.<br>&gt;&gt; <br>&gt;&gt; For contexts where a T is expected, .foo means T.foo<br>&gt;&gt; <br>&gt;&gt; But it’s not ambiguous here, because we’re expecting T -&gt; U here, and functions can’t have static members (or any members for that matter :P). So passing a .foo could unambiguously mean T.foo(T) — an instance method on T, returning U.<br>&gt;&gt; <br>&gt;&gt; I’d be for dropping the parens, they seem unnecessary, and are confusing (we’re passing a function, not calling it). It should be unambiguous with properties since methods and properties share a name space.<br>&gt;&gt; <br>&gt;&gt; And, speaking of, I’d also just make it work with properties with the same syntax. So array.map(.foo) would call $0.foo() if `foo` is a method, or $0.foo if `foo` is a property.<br>&gt; <br>&gt; I probably should have showed more examples in my original post.<br>&gt; <br>&gt; Making this work with property getters was one of the examples I posted in the other thread:<br>&gt; <br>&gt; anArray.map(.aProperty)<br>&gt; <br>&gt; The reason I used parentheses in the example of a method that takes no argument is that what we’re actually doing is binding the non-self arguments.  This is more clear with an example of a method that does take additional arguments:<br>&gt; <br>&gt; anArray.map(.hasPrefix(“foo”))<br>&gt; <br>&gt; I hadn’t tried declaring property and no argument method with the same name until you said this.  You are correct that it’s unambiguous. I didn’t realize this when I first posted this idea.  <br>&gt; <br>&gt; If we don’t omit them it’s always clear whether we are passing a property or a method.  I think requiring the parentheses is probably worth the syntactic cost.  It also allows for a straightforward rewrite to a closure by wrapping the expression in braces and placing $0 prior to the dot.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; (Am I missing something?)<br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 04:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 19, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 2:19 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; anArray.map(.hasPrefix(“foo”))<br>&gt; <br>&gt; I’m against this. Yes, it extends the functionality of the proposal even more and could allow for more closures to be rewritten in this style — but at a severe cost in clarity IMHO.<br>&gt; <br>&gt; I mean, with `map(.aMethod)`, you’re passing a reference to a method available on the receiver. This is actually very similar to passing `foo(.EnumCase)`, as in both cases we’re accessing a static member of the type. (Yes, also with the former example if you consider instance methods as curried functions on the type that take self as the first parameter.) So, there’s some nice symmetry and predictability, even if the dot-syntax has more than one use.<br>&gt; <br>&gt; But with `map(.hasPrefix(“foo”))`, you’re implicitly constructing a new closure, that calls a method, and passes an argument. This isn’t immediately obvious. There’s no symmetry. It looks as if I was passing the result of calling some method, and the dot at the beginning meant something else (cf the se-0009 review thread). I couldn’t figure easily figure out that this is actually implicit contents of a new closure.<br>&gt; <br>&gt; The potential for confusion is great. I’m not convinced the benefit outweighs the cost here.<br></p><p>That is a fair position.  It sounds like you oppose this shorthand for methods that require arguments but not for nullary methods and not for property getters.  Is that correct?  Do you believe it is valuable in those cases?<br></p><p>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 19 Dec 2015, at 02:10, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 1:36 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interesting! I’d definitely be for some shortcut syntax here, as this seems to be a very, very common pattern. Passing a function to, say, `map` is so much easier and cleaner than passing a method in Swift — even though Swift generally always prefers methods to functions!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t spent too much thinking this through, but I think this is sound.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For contexts where a T is expected, .foo means T.foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it’s not ambiguous here, because we’re expecting T -&gt; U here, and functions can’t have static members (or any members for that matter :P). So passing a .foo could unambiguously mean T.foo(T) — an instance method on T, returning U.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be for dropping the parens, they seem unnecessary, and are confusing (we’re passing a function, not calling it). It should be unambiguous with properties since methods and properties share a name space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And, speaking of, I’d also just make it work with properties with the same syntax. So array.map(.foo) would call $0.foo() if `foo` is a method, or $0.foo if `foo` is a property.<br>&gt;&gt; <br>&gt;&gt; I probably should have showed more examples in my original post.<br>&gt;&gt; <br>&gt;&gt; Making this work with property getters was one of the examples I posted in the other thread:<br>&gt;&gt; <br>&gt;&gt; anArray.map(.aProperty)<br>&gt;&gt; <br>&gt;&gt; The reason I used parentheses in the example of a method that takes no argument is that what we’re actually doing is binding the non-self arguments.  This is more clear with an example of a method that does take additional arguments:<br>&gt;&gt; <br>&gt;&gt; anArray.map(.hasPrefix(“foo”))<br>&gt;&gt; <br>&gt;&gt; I hadn’t tried declaring property and no argument method with the same name until you said this.  You are correct that it’s unambiguous. I didn’t realize this when I first posted this idea.  <br>&gt;&gt; <br>&gt;&gt; If we don’t omit them it’s always clear whether we are passing a property or a method.  I think requiring the parentheses is probably worth the syntactic cost.  It also allows for a straightforward rewrite to a closure by wrapping the expression in braces and placing $0 prior to the dot.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Am I missing something?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Dec 2015, at 04:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>December 19, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; That is a fair position.  It sounds like you oppose this shorthand for methods that require arguments but not for nullary methods and not for property getters.  Is that correct?  Do you believe it is valuable in those cases?<br></p><p>Correct. I’m for foo(.aMethod) and foo(.aProperty), but not foo(.aMethod(withArgs)), because the former maps pretty nicely to what we already have, and the latter can be seriously confusing.<br></p><p>PS. I’d like to try and analyze my Swift codebases to see how I usually use closures with things like map, just to have some (admittedly biased) data on what kind of patterns are common in practice.<br></p><p>— Radek<br></p><p>&gt; On 19 Dec 2015, at 16:21, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 2:19 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.hasPrefix(“foo”))<br>&gt;&gt; <br>&gt;&gt; I’m against this. Yes, it extends the functionality of the proposal even more and could allow for more closures to be rewritten in this style — but at a severe cost in clarity IMHO.<br>&gt;&gt; <br>&gt;&gt; I mean, with `map(.aMethod)`, you’re passing a reference to a method available on the receiver. This is actually very similar to passing `foo(.EnumCase)`, as in both cases we’re accessing a static member of the type. (Yes, also with the former example if you consider instance methods as curried functions on the type that take self as the first parameter.) So, there’s some nice symmetry and predictability, even if the dot-syntax has more than one use.<br>&gt;&gt; <br>&gt;&gt; But with `map(.hasPrefix(“foo”))`, you’re implicitly constructing a new closure, that calls a method, and passes an argument. This isn’t immediately obvious. There’s no symmetry. It looks as if I was passing the result of calling some method, and the dot at the beginning meant something else (cf the se-0009 review thread). I couldn’t figure easily figure out that this is actually implicit contents of a new closure.<br>&gt;&gt; <br>&gt;&gt; The potential for confusion is great. I’m not convinced the benefit outweighs the cost here.<br>&gt; <br>&gt; That is a fair position.  It sounds like you oppose this shorthand for methods that require arguments but not for nullary methods and not for property getters.  Is that correct?  Do you believe it is valuable in those cases?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 19 Dec 2015, at 02:10, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 1:36 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Interesting! I’d definitely be for some shortcut syntax here, as this seems to be a very, very common pattern. Passing a function to, say, `map` is so much easier and cleaner than passing a method in Swift — even though Swift generally always prefers methods to functions!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven’t spent too much thinking this through, but I think this is sound.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For contexts where a T is expected, .foo means T.foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it’s not ambiguous here, because we’re expecting T -&gt; U here, and functions can’t have static members (or any members for that matter :P). So passing a .foo could unambiguously mean T.foo(T) — an instance method on T, returning U.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be for dropping the parens, they seem unnecessary, and are confusing (we’re passing a function, not calling it). It should be unambiguous with properties since methods and properties share a name space.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And, speaking of, I’d also just make it work with properties with the same syntax. So array.map(.foo) would call $0.foo() if `foo` is a method, or $0.foo if `foo` is a property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I probably should have showed more examples in my original post.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Making this work with property getters was one of the examples I posted in the other thread:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.aProperty)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason I used parentheses in the example of a method that takes no argument is that what we’re actually doing is binding the non-self arguments.  This is more clear with an example of a method that does take additional arguments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; anArray.map(.hasPrefix(“foo”))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hadn’t tried declaring property and no argument method with the same name until you said this.  You are correct that it’s unambiguous. I didn’t realize this when I first posted this idea.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we don’t omit them it’s always clear whether we are passing a property or a method.  I think requiring the parentheses is probably worth the syntactic cost.  It also allows for a straightforward rewrite to a closure by wrapping the expression in braces and placing $0 prior to the dot.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Am I missing something?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 18 Dec 2015, at 04:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question. This is most commonly used with enum cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; becomes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/fcae2e33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 19, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On 19 Dec 2015, at 22:03, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; That is a fair position.  It sounds like you oppose this shorthand for methods that require arguments but not for nullary methods and not for property getters.  Is that correct?  Do you believe it is valuable in those cases?<br>&gt; <br>&gt; Correct. I’m for foo(.aMethod) and foo(.aProperty), but not foo(.aMethod(withArgs)), because the former maps pretty nicely to what we already have, and the latter can be seriously confusing.<br>&gt; <br>&gt; PS. I’d like to try and analyze my Swift codebases to see how I usually use closures with things like map, just to have some (admittedly biased) data on what kind of patterns are common in practice.<br>&gt; <br>&gt; — Radek<br></p><p><br>Methods that take arguments do introduce some interesting problems. Here is an example with current Swift syntax:<br>[&quot;dog&quot;,&quot;cat&quot;,&quot;rat&quot;].map { $0.hasPrefix(&quot;ca&quot;) } // [false, true, false]<br></p><p>Now if we wanted to use the following syntax instead:<br>[&quot;dog&quot;,&quot;cat&quot;,&quot;rat&quot;].map(.hasPrefix(&quot;ca&quot;))<br></p><p>This would require auto-currying of the function, so that the parameter passed to ‘hasPrefix’ is partially applied. The ‘map’ function would then pass each element of the Array to the partially applied function. Further more the order of the parameters would need to be reversed to get the expected result. Basically it would need to do something like the following:<br></p><p>func hasPrefix(prefix: String)(str: String) -&gt; Bool {<br>  return str.hasPrefix(prefix)<br>}<br></p><p>[&quot;dog&quot;,&quot;cat&quot;,&quot;rat&quot;].map(hasPrefix(&quot;ca&quot;)) // [false, true, false]<br></p><p>Perhaps that’s too much implicit rearranging? I would find it odd if were necessary to use the current syntax for methods with arguments, but have the ability to use the shorter syntax for methods without args.<br></p><p>Al<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/5db1fae3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 20, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 5:29 PM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br>&gt; <br>&gt;&gt; On 19 Dec 2015, at 22:03, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; That is a fair position.  It sounds like you oppose this shorthand for methods that require arguments but not for nullary methods and not for property getters.  Is that correct?  Do you believe it is valuable in those cases?<br>&gt;&gt; <br>&gt;&gt; Correct. I’m for foo(.aMethod) and foo(.aProperty), but not foo(.aMethod(withArgs)), because the former maps pretty nicely to what we already have, and the latter can be seriously confusing.<br>&gt;&gt; <br>&gt;&gt; PS. I’d like to try and analyze my Swift codebases to see how I usually use closures with things like map, just to have some (admittedly biased) data on what kind of patterns are common in practice.<br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt; <br>&gt; <br>&gt; Methods that take arguments do introduce some interesting problems. Here is an example with current Swift syntax:<br>&gt; [&quot;dog&quot;,&quot;cat&quot;,&quot;rat&quot;].map { $0.hasPrefix(&quot;ca&quot;) } // [false, true, false]<br>&gt; <br>&gt; Now if we wanted to use the following syntax instead:<br>&gt; [&quot;dog&quot;,&quot;cat&quot;,&quot;rat&quot;].map(.hasPrefix(&quot;ca&quot;))<br>&gt; <br>&gt; This would require auto-currying of the function, so that the parameter passed to ‘hasPrefix’ is partially applied. The ‘map’ function would then pass each element of the Array to the partially applied function. Further more the order of the parameters would need to be reversed to get the expected result. Basically it would need to do something like the following:<br>&gt; <br>&gt; func hasPrefix(prefix: String)(str: String) -&gt; Bool {<br>&gt;   return str.hasPrefix(prefix)<br>&gt; }<br>&gt; <br>&gt; [&quot;dog&quot;,&quot;cat&quot;,&quot;rat&quot;].map(hasPrefix(&quot;ca&quot;)) // [false, true, false]<br>&gt; <br>&gt; Perhaps that’s too much implicit rearranging? I would find it odd if were necessary to use the current syntax for methods with arguments, but have the ability to use the shorter syntax for methods without args.<br>&gt; <br></p><p>The shorthand syntax could be implemented in different was.  If it is just shorthand for a single expression closure then rearranging the call like that isn’t necessary.  In reality, from a user point of view it doesn’t matter how it is implemented and it might be best to think of it as a single expression closure regardless of how the implementation is done.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/b36454bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>December 19, 2015 at 01:00:00am</p></header><div class="content"><p>When you access a static member of a type using the dot shortcut, Swift<br>evaluates the expression immediately.<br></p><p>Are you proposing that when you access a member of an instance, Swift<br>generate a closure?<br></p><p>Or are you proposing that Swift generate a closure or not depending on how<br>the expression&#39;s value is to be used?<br></p><p>Either way seems inconsistent with the static member situation, and like a<br>potential source of confusion: not everyone uses the One True Convention™<br>of .Capitalized .Static .Members and .lowercase .instance .members, so one<br>cannot reliably deduce the outcome based on the case of the character after<br>the dot.<br></p><p>On Thu, Dec 17, 2015 at 9:27 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;<br>&gt; becomes:<br>&gt;<br>&gt; anArray.map(.anInstanceMethod())<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/ea6fc7e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 19, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 1:37 AM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When you access a static member of a type using the dot shortcut, Swift evaluates the expression immediately.<br>&gt; <br>&gt; Are you proposing that when you access a member of an instance, Swift generate a closure?<br>&gt; <br>&gt; Or are you proposing that Swift generate a closure or not depending on how the expression&#39;s value is to be used?<br></p><p>I was thinking of it more in terms of binding the non-self arguments, but either way is effectively the same.  This would be necessary in all cases, although in the case of property getters and nullary methods there would no arguments to bind.<br></p><p>&gt; Either way seems inconsistent with the static member situation, and like a potential source of confusion: not everyone uses the One True Convention™ of .Capitalized .Static .Members and .lowercase .instance .members, so one cannot reliably deduce the outcome based on the case of the character after the dot.<br></p><p>You can easily deduce it by the type context which you need to know to understand the code anyway.  As capitalization is not enforced by the language it is not reasonable to deduce anything based on that.<br></p><p>If you think it could potentially be confusing that is a reasonable position.<br></p><p>&gt; <br>&gt; On Thu, Dec 17, 2015 at 9:27 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt; <br>&gt; becomes:<br>&gt; <br>&gt; anArray.map(.anInstanceMethod())<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/6ea47140/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December 20, 2015 at 02:00:00am</p></header><div class="content"><p>Interesting proposal, but how would it work with closures that take two<br>or more params? What would the following expression become:<br></p><p>[1,2,3,4].reduce(&quot;&quot;, { $0.description + $1.description })<br></p><p>Is this special syntax that would only apply to closures with one<br>parameter? If so I&#39;m not sure that I would consider it worth the added<br>complexity (though I agree that the $0 doesn&#39;t look that nice normally).<br></p><p>- Kevin<br></p><p>On 12/17/2015 10:27 PM, Matthew Johnson via swift-evolution wrote:<br>&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;<br>&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;<br>&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;<br>&gt; becomes:<br>&gt;<br>&gt; anArray.map(.anInstanceMethod())<br>&gt;<br>&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;<br>&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;<br>&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;<br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] dot shorthand for instance members</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 20, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 1:06 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting proposal, but how would it work with closures that take two<br>&gt; or more params? What would the following expression become:<br>&gt; <br>&gt; [1,2,3,4].reduce(&quot;&quot;, { $0.description + $1.description })<br>&gt; <br>&gt; Is this special syntax that would only apply to closures with one<br>&gt; parameter? If so I&#39;m not sure that I would consider it worth the added<br>&gt; complexity (though I agree that the $0 doesn&#39;t look that nice normally).<br></p><p>It wouldn’t work for two or more arguments.  The point of it is to be shorthand for unbound instance members (or partially bound if we allow methods taking additional arguments), which would inherently receive a single argument - the instance.<br></p><p>Whether or not it is worth the cost is a fair question that needs to be answered through discussion.<br></p><p>I think it is worth continuing to discuss and explore because it addresses a very common use case.  Many higher order functions take function arguments that receive only a single argument.<br></p><p>&gt; <br>&gt; - Kevin<br>&gt; <br>&gt; On 12/17/2015 10:27 PM, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt; Swift currently offers dot shorthand for static members of type Self in type contexts expecting a value of the type in question.  This is most commonly used with enum cases.<br>&gt;&gt; <br>&gt;&gt; Swift does not currently offer shorthand for instance members.  Introducing a shorthand for instance members would improve clarity and readability of code in common cases:<br>&gt;&gt; <br>&gt;&gt; anArray.map{$0.anInstanceMethod()}<br>&gt;&gt; <br>&gt;&gt; becomes:<br>&gt;&gt; <br>&gt;&gt; anArray.map(.anInstanceMethod())<br>&gt;&gt; <br>&gt;&gt; This shorthand would work in typing contexts expecting a single argument function.  It would allow abbreviated access to any visible instance property getter or instance method on the type of the argument.  Of course the return type would need to match the return type expected by the context or a type mismatch compiler error would occur.<br>&gt;&gt; <br>&gt;&gt; The readability advantage is arguably small but it does exist.  The feature also aligns very well with an existing language feature.<br>&gt;&gt; <br>&gt;&gt; I think it’s an interesting idea and am wondering whether others feel like it is something worth pursuing or not.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
