<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 16, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; This is a proposal for representing copy-on-write buffers in<br>&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt; depends on how we move forward with SIL ownership.<br>&gt;<br>&gt; :orphan:<br>&gt;<br>&gt; .. highlight:: sil<br>&gt;<br>&gt; ===================================<br>&gt; Copy-On-Write Representation in SIL<br>&gt; ===================================<br>&gt;<br>&gt; .. contents::<br>&gt;<br>&gt; Overview<br>&gt; ========<br>&gt;<br>&gt; This document proposes:<br>&gt;<br>&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;   types.<br>&gt;<br>&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;   of it.<br>&gt;<br>&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt; in the same way as a programmer can do.<br>&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;<br>&gt; .. note::<br>&gt;     In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;     It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;<br>&gt; COW Types<br>&gt; =========<br>&gt;<br>&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;<br>&gt;     class COWBuffer {<br>&gt;       var someData: Int<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt;     struct COWType {<br>&gt;       var b : COWBuffer<br>&gt;<br>&gt;       mutating func change_it() {<br>&gt;         if (!isUniquelyReferenced(b)) {<br>&gt;           b = copy_buffer(b)<br>&gt;         }<br>&gt;         b.someData = ...<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt; But there is no representation of this special behavior in the SIL.<br>&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;<br>&gt; For example::<br>&gt;<br>&gt;     func foo(arr : [Int]) {<br>&gt;       x = arr[0]<br>&gt;       opaque_function()<br>&gt;       y = arr[0] // can RLE replace this with y = x?<br>&gt;     }<br>&gt;<br>&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt; has to copy it. <br></p><p>...or determine that it&#39;s uniquely-referenced.<br></p><p>&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt; that opaque_function() will write to the location of arr[0].<br>&gt;<br>&gt; Copy-on-write Ownership Attribute<br>&gt; =================================<br>&gt;<br>&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;<br>&gt; Swift Syntax<br>&gt; ------------<br>&gt;<br>&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;<br>&gt;     struct COWType {<br>&gt;       copy_on_write var b : COWBuffer<br>&gt;<br>&gt;       // ...<br>&gt;     }<br>&gt;<br>&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt; It does not change the semantics of the program.<br></p><p>Presumably, it changes what code you can execute on `b` without invoking<br>traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>to do anything differently to take advantage of the annotation.  What<br>are the rules for writing code that uses `copy_on_write`?<br></p><p>&gt; .. note::<br>&gt;<br>&gt;   “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;   Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;   Another question is if we should open this attribute for the public or just<br>&gt;   use it internally in the library, because violating the implied rules<br>&gt;   (see below) could break memory safety.<br>&gt;<br>&gt; Implementation<br>&gt; --------------<br>&gt;<br>&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt; buffer class type.<br>&gt;<br>&gt; In SIL the buffer reference will have type::<br>&gt;<br>&gt;     $@sil_cow COWBuffer<br>&gt;<br>&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;<br>&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt; type to a regular reference type::<br>&gt;<br>&gt;     cow_to_ref<br>&gt;     ref_to_cow<br>&gt;  <br>&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;<br>&gt; For example the SIL code for::<br>&gt;<br>&gt;     var c: COWType<br>&gt;     let x = c.b.someData<br>&gt;<br>&gt; would be::<br>&gt;<br>&gt;     %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;     %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;     %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;     %4 = load %3 : $*Int<br>&gt;<br>&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt; COW type.<br>&gt;<br>&gt; COW Buffers and the Optimizer<br>&gt; =============================<br>&gt;<br>&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;<br>&gt;   *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;   during the lifetime of the reference.*<br></p><p>This seems like much too broad a rule to allow inplace mutations of<br>uniquely referenced buffers.  Unless you mean the reference is<br>immutable, rather than the storage being referred to by it.<br></p><p>&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt; considered to point to immutable memory.<br>&gt;<br>&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt; representation in SIL:<br>&gt;<br>&gt; - Redundant load elimination<br>&gt;<br>&gt;   RLE can assume that opaque code does not modify a COW buffer.<br></p><p>How do you distinguish “opaque code” from “code that is meant to<br>modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br></p><p>&gt;   Example::<br>&gt;<br>&gt;       %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;       %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;       %4 = load %3 : $*Int<br>&gt;       %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;       %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;<br>&gt;   Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;   like array count propagation. These hacks would not be needed<br>&gt;   anymore.<br></p><p>W0000000000000000000000t.<br></p><p>&gt;   Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;   projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;   memory.<br>&gt;<br>&gt; - CSE, loop hoisting<br>&gt;<br>&gt;   Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;   COW buffer<br></p><p>Same question here as above, then.<br>&gt;<br>&gt; - ARC optimization<br>&gt;<br>&gt;   Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;   can remove retain/release pairs across such code::<br>&gt;<br>&gt;       %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;       %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;       %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;       %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;       // Use %4<br>&gt;       destroy_value %4 : $MyClass<br>&gt;<br>&gt; Scoping instructions<br>&gt; --------------------<br>&gt;<br>&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt; buffer reference. For example::<br>&gt;<br>&gt;     %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;     // load something from %b1<br>&gt;     %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;     %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;     // load something from %b2<br>&gt;  <br>&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt; buffer.<br>&gt;<br>&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;<br>&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt; of references to an immutable buffer and references to the mutable buffer.<br></p><p>Looks reasonable.<br></p><p>&gt; The following example shows why the scoping instructions (specifically the<br>&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt; interleaving mutable and immutable liferanges::<br>&gt;<br>&gt;     // there should be a begin-of-scope %baddr<br>&gt;     %mut_b = load %baddr<br>&gt;     store %x to %mut_b    // modification of the buffer<br>&gt;     // there should be a end-of-scope %baddr<br>&gt;<br>&gt;     loop {<br>&gt;       %b = load %baddr<br>&gt;       %y = load %b        // load from the buffer<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;<br>&gt;     %mut_b = load %baddr<br>&gt;     %b = load %baddr        // moved out of the loop<br>&gt;     store %x to %mut_b<br>&gt;<br>&gt;     loop {<br>&gt;       %y = load %b<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt; also hoist the load::<br>&gt;<br>&gt;     %mut_b = load %baddr<br>&gt;     %b = load %baddr<br>&gt;     %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;     store %x to %mut_b<br>&gt;<br>&gt;     loop {<br>&gt;       ...<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;<br>&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt; -----------------------------------------<br>&gt;<br>&gt; SIL instructions<br>&gt; ^^^^^^^^^^^^^^^^<br>&gt;<br>&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;<br>&gt;     bb0:<br>&gt;       is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;     bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;       // usually empty<br>&gt;       br bb3(%1 : $COWBuffer)<br>&gt;     bb2:                  // the false-block<br>&gt;       // usually contains:<br>&gt;       %2 = apply %copy_buffer<br>&gt;       %3 = cow_to_ref %2<br>&gt;       store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;       br bb3(%2 : $COWBuffer)<br>&gt;     bb3(%4 : $COWBuffer):<br>&gt;       // Modify the buffer referenced by %4<br>&gt;       // ...<br>&gt;<br>&gt; The end-of-scope instruction is::<br>&gt;<br>&gt;     end_unique_addr %0 : $*COWBuffer<br>&gt;<br>&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt; verifier.<br>&gt;<br>&gt; The two instructions must be paired properly but not necessarily in the<br>&gt; same function.<br>&gt;<br>&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt; Both instructions take an address to the COW buffer reference and are<br>&gt; considered as potential stores to the reference.<br>&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt; across these instructions.<br>&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt; a ``is_unique_addr_br``::<br>&gt;<br>&gt;     %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;     // do something with %1<br>&gt;     …<br>&gt;     is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;     …<br>&gt;     %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;<br>&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt; from the COWType.<br>&gt; Example::<br>&gt;<br>&gt;   %1 = load_strong %0 : $*COWBuffer<br>&gt;   %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;   %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;   store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;<br>&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;<br>&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;<br>&gt;     is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;<br>&gt;     %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;<br>&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt; ``end_unique_addr``.<br>&gt; For example in the following code, where the COW data is passed as-value and<br>&gt; all the mutating functions are inlined::<br>&gt;<br>&gt;     func foo(arr : [Int], x: Int) {<br>&gt;       arr[0] = 27<br>&gt;       …<br>&gt;       y = arr[x]<br>&gt;       …<br>&gt;     }<br>&gt;<br>&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt; immutable reference to a mutable reference::<br>&gt;<br>&gt;     %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;<br>&gt; which is basically just a simpler representation of the following pattern::<br>&gt;<br>&gt;     bb0:<br>&gt;       is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;     bb1(%1 : $COWBuffer):<br>&gt;       … // main control flow continues here<br>&gt;     bb2:<br>&gt;       unreachable<br>&gt;<br>&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;<br>&gt; Built-ins<br>&gt; ^^^^^^^^^<br>&gt;<br>&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;<br>&gt;     func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;     func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;<br>&gt; For example::<br>&gt;<br>&gt;     struct COWType {<br>&gt;       copy_on_write var b : COWBuffer<br>&gt;<br>&gt;       mutating func makeMutable() -&gt; COWBuffer {<br>&gt;         if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;           return uniqueBuffer<br>&gt;         }<br>&gt;         let copiedBuffer = copyBuffer(self.b)<br>&gt;         self.b = copiedBuffer<br>&gt;         return copiedBuffer<br>&gt;       }<br>&gt;<br>&gt;       mutating func setSomeData(x: Int) {<br>&gt;         let uniqueBuffer = makeMutable()<br>&gt;         uniqueBuffer.someData = x<br>&gt;         endUnique(&amp;self.b)<br>&gt;       }<br>&gt;     }<br></p><p>This seems reasonable, but it also looks like the compiler could do the<br>`endUnique` dance for us based, e.g., on the mutability of methods.  <br></p><p>&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt; In this case usually the original buffer is copied and the reference to the<br>&gt; copy is written back to the original buffer reference location<br>&gt; (``self.b = copiedBuffer``).<br>&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt; a unique buffer reference.<br>&gt;<br>&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;<br>&gt; .. note::<br>&gt;   This makes the definition of the unique buffer location lifetime a little bit<br>&gt;   problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;   the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;   can do its job).<br></p><p>I don&#39;t know what the implications of these diamonds and the problem<br>described above might be, FWIW.<br></p><p>&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;<br>&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;    same function.<br>&gt;<br>&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;<br>&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;    pair.<br>&gt;<br>&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;    reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;<br>&gt;    Note that the lifetime of the unique buffer reference does not include the<br>&gt;    part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;    of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;    for the purpose of copying.<br>&gt;<br>&gt; Examples::<br>&gt;<br>&gt;     mutating func setSomeData(x: Int) {<br>&gt;       let uniqueBuffer = makeMutable()<br>&gt;       uniqueBuffer.someData = x<br>&gt;       // violates rule 1<br>&gt;     }<br>&gt;<br>&gt;     mutating func setSomeData(x: Int) {<br>&gt;       makeMutable()<br>&gt;       self.b.someData = x // violates rule 2<br>&gt;       endUnique(&amp;self.b)<br>&gt;     }<br>&gt;<br>&gt;     mutating func setSomeData(x: Int) {<br>&gt;       let uniqueBuffer = makeMutable()<br>&gt;       uniqueBuffer.someData = x<br>&gt;       endUnique(&amp;self.b)<br>&gt;       uniqueBuffer.someData = 27 // violates rule 3<br>&gt;     }<br>&gt;<br>&gt;     mutating func incrementSomeData() {<br>&gt;       let uniqueBuffer = makeMutable()<br>&gt;       uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;       endUnique(&amp;self.b)<br>&gt;     }<br></p><p>It would be instructive to write down the *correct* code for these<br>operations.<br></p><p>&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt; analysis maybe even in most cases).<br>&gt;<br>&gt; This approach would require to change some of the internals of our<br>&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt; the unique buffer.<br></p><p>No big deal.<br></p><p>&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt; --------------------------------------------<br>&gt;<br>&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt; purpose of defining the scope of a COW mutation.<br>&gt;<br>&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt; scope of a COW buffer.<br>&gt;<br>&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;<br>&gt;     begin_exclusive<br>&gt;     end_exclusive<br>&gt;<br>&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt; look like potential writes to the inout variable.<br>&gt;<br>&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt; done in mutating functions.<br>&gt;<br>&gt; Example::<br>&gt;<br>&gt;     // &gt; mutating func setSomeData(x: Int) {<br>&gt;     // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;     sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;     bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;<br>&gt;     // &gt;   makeMutable() (inlined)<br>&gt;     // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;     // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;     begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;<br>&gt;     // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;     // Extract a unique inout reference to the class reference to the array storage.<br>&gt;     // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;     // but the scope helps ensure this is the only alias to _storage.<br>&gt;     %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;<br>&gt;     // Uniqueness checking requires an inout reference to the class reference.<br>&gt;     // The is_unique instruction does not need to create a new storage reference.<br>&gt;     // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;     // is inout, and prevent the inout scope from being optimized away.<br>&gt;     %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;<br>&gt;     // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;     end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;<br>&gt;     br %isuniq, bb_continue, bb_slow<br>&gt;<br>&gt;     bb_slow:<br>&gt;     // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;     // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;     %copied_storage_class = alloc_ref ...<br>&gt;     // A begin/end exclusive scope is implicit in store [assign].<br>&gt;     store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;     br bb_continue<br>&gt;<br>&gt;     bb_continue:<br>&gt;<br>&gt;     // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;     // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;     // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;     // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;     // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;     // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;     // they must be consumed within this scope.<br>&gt;     end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;<br>&gt;     // &gt;    self._storage.someData = x<br>&gt;     // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;     %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;<br>&gt;     // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;     %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;     %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;<br>&gt;     // Write some data into the CoW buffer.<br>&gt;     // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;     // A single-use _addr instruction, so no scope.<br>&gt;     %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;     // A store with an implicit [exclusive] scope.<br>&gt;     store [assign] %x to %somedata_addr<br>&gt;<br>&gt;     strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;<br>&gt;     // End the isUnique argument&#39;s exclusive scope.<br>&gt;     // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;     end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;<br>&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt; alternative.<br></p><p>Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>generates this SIL.<br></p><p>&gt; But it depends on implementing the general feature to insert the inout<br>&gt; scoping instructions.  Also, we still have to think through all the<br>&gt; details of this approach.<br></p><p>FWIW, I am convinced we will need (and get) a stricter inout model that<br>would be conducive to inserting the scoping instructions.<br></p><p><br>&gt; Dependency between a buffer reference to the scope-begin<br>&gt; --------------------------------------------------------<br></p><p>You can only have a dependency between two things, but as phrased “a<br>buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>would fix it.<br></p><p>&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt; to a scope-begin instruction::<br>&gt;<br>&gt;     %b_cow = load %baddr<br>&gt;     %b = cow_to_ref %b_cow<br>&gt;     %x = load %b             // No dependency between this...<br>&gt;     ...<br>&gt;     begin_exclusive %baddr   // ... and this instruction.<br>&gt;     ...<br>&gt;<br>&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;<br>&gt;     %b_cow = load %baddr<br>&gt;     %b = cow_to_ref %b_cow<br>&gt;     ...<br>&gt;     begin_exclusive %baddr<br>&gt;     %x = load %b             // Wrong! Buffer could be modified here<br>&gt;     ...<br>&gt;<br>&gt; We still have to figure out how to cope with this.<br>&gt;<br>&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;   the optimizer may not move over a begin-of-scope instruction.<br>&gt;<br>&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;   reference may not be moved over a begin-of-scope instruction.<br>&gt;<br>&gt; Preconditions<br>&gt; =============<br>&gt;<br>&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt; buffer. <br></p><p>As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>why this would be dependent on it.<br></p><p>&gt; At least for Array this is implemented as low-level bit operations and<br>&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt; RC-root for the buffer reference).<br>&gt;<br>&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt; safety when violating the inout rule. Example::<br>&gt;<br>&gt;     var arr = [MyClass()]  // a global array<br>&gt;<br>&gt;     foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;<br>&gt;     func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;       let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;       let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;       arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;       return r.i        // use-after-free!<br>&gt;     }<br></p><p>I only know of one way to resolve inout and pinning:<br></p><p>* Semantically, references are replaced with a trap value when entering<br>  an inout context so that all inout values are provably unique<br>  references in the absence of unsafe code.  We drop pinning and provide<br>  explicit operations that provide simultaneous lvalue accesses to<br>  distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br></p><p>If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>should probably decide that this is what we&#39;re doing so that we can move<br>forward without this looming uncertainty.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 17, 2016 at 08:00:00am</p></header><div class="content"><p>On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br></p><p><br>&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt; <br>&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt; reference types and as value type payloads, <br>&gt; <br>&gt; Foundation does, or would if they could.<br>&gt; <br>&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt; <br>&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt; <br>&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt; <br>&gt; +1<br>&gt; <br>&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt; across calls without relying on inlining and IPO.<br>&gt; <br>&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt; need some participation from the programmer (either an agreement not to<br>&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt; identify operations that create/preserve uniqueness.<br></p><p>If a mutating reference (like self in a mutating method) is move-only then you would not be able to “copy” it to a global.<br></p><p>&gt; <br>&gt; <br>&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt; <br>&gt;&gt; :orphan:<br>&gt;&gt; <br>&gt;&gt; .. highlight:: sil<br>&gt;&gt; <br>&gt;&gt; ===================================<br>&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt; ===================================<br>&gt;&gt; <br>&gt;&gt; .. contents::<br>&gt;&gt; <br>&gt;&gt; Overview<br>&gt;&gt; ========<br>&gt;&gt; <br>&gt;&gt; This document proposes:<br>&gt;&gt; <br>&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;  types.<br>&gt;&gt; <br>&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;  of it.<br>&gt;&gt; <br>&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt; <br>&gt;&gt; .. note::<br>&gt;&gt;    In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;    It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt; <br>&gt;&gt; COW Types<br>&gt;&gt; =========<br>&gt;&gt; <br>&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt; <br>&gt;&gt;    class COWBuffer {<br>&gt;&gt;      var someData: Int<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    struct COWType {<br>&gt;&gt;      var b : COWBuffer<br>&gt;&gt; <br>&gt;&gt;      mutating func change_it() {<br>&gt;&gt;        if (!isUniquelyReferenced(b)) {<br>&gt;&gt;          b = copy_buffer(b)<br>&gt;&gt;        }<br>&gt;&gt;        b.someData = ...<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt; <br>&gt;&gt; For example::<br>&gt;&gt; <br>&gt;&gt;    func foo(arr : [Int]) {<br>&gt;&gt;      x = arr[0]<br>&gt;&gt;      opaque_function()<br>&gt;&gt;      y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt; has to copy it. <br>&gt; <br>&gt; ...or determine that it&#39;s uniquely-referenced.<br></p><p>In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not uniquely-referenced.<br></p><p>&gt; <br>&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt; <br>&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt; =================================<br>&gt;&gt; <br>&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt; <br>&gt;&gt; Swift Syntax<br>&gt;&gt; ------------<br>&gt;&gt; <br>&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt; <br>&gt;&gt;    struct COWType {<br>&gt;&gt;      copy_on_write var b : COWBuffer<br>&gt;&gt; <br>&gt;&gt;      // ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt; It does not change the semantics of the program.<br>&gt; <br>&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt; to do anything differently to take advantage of the annotation.<br></p><p>That’s true.<br></p><p>&gt; What are the rules for writing code that uses `copy_on_write`?<br></p><p>See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br></p><p>&gt; <br>&gt;&gt; .. note::<br>&gt;&gt; <br>&gt;&gt;  “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;  Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;  Another question is if we should open this attribute for the public or just<br>&gt;&gt;  use it internally in the library, because violating the implied rules<br>&gt;&gt;  (see below) could break memory safety.<br>&gt;&gt; <br>&gt;&gt; Implementation<br>&gt;&gt; --------------<br>&gt;&gt; <br>&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt; buffer class type.<br>&gt;&gt; <br>&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt; <br>&gt;&gt;    $@sil_cow COWBuffer<br>&gt;&gt; <br>&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt; <br>&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt; type to a regular reference type::<br>&gt;&gt; <br>&gt;&gt;    cow_to_ref<br>&gt;&gt;    ref_to_cow<br>&gt;&gt; <br>&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt; <br>&gt;&gt; For example the SIL code for::<br>&gt;&gt; <br>&gt;&gt;    var c: COWType<br>&gt;&gt;    let x = c.b.someData<br>&gt;&gt; <br>&gt;&gt; would be::<br>&gt;&gt; <br>&gt;&gt;    %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt; <br>&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt; COW type.<br>&gt;&gt; <br>&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt; =============================<br>&gt;&gt; <br>&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt; <br>&gt;&gt;  *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;  during the lifetime of the reference.*<br>&gt; <br>&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt; uniquely referenced buffers.<br></p><p>The point is that all mutations must be guarded by an is_unique, which takes the _address_ of the buffer reference as argument.<br>And the optimizer considers this instruction as a potential write to the buffer reference.<br>The effect is that the lifetime of a buffer reference (as a SIL value) will not outlive a is_unique - regardless if this is inside a called function or inlined.<br></p><p>&gt;  Unless you mean the reference is<br>&gt; immutable, rather than the storage being referred to by it.<br>&gt; <br>&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt; considered to point to immutable memory.<br>&gt;&gt; <br>&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt; representation in SIL:<br>&gt;&gt; <br>&gt;&gt; - Redundant load elimination<br>&gt;&gt; <br>&gt;&gt;  RLE can assume that opaque code does not modify a COW buffer.<br>&gt; <br>&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br></p><p>Again, the is_unique which takes the address of the reference, will guarantee that during the lifetime of a buffer there are no modifications of the buffer.<br></p><p>&gt; <br>&gt;&gt;  Example::<br>&gt;&gt; <br>&gt;&gt;      %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;      %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;      %4 = load %3 : $*Int<br>&gt;&gt;      %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;      %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt; <br>&gt;&gt;  Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;  like array count propagation. These hacks would not be needed<br>&gt;&gt;  anymore.<br>&gt; <br>&gt; W0000000000000000000000t.<br>&gt; <br>&gt;&gt;  Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;  projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;  memory.<br>&gt;&gt; <br>&gt;&gt; - CSE, loop hoisting<br>&gt;&gt; <br>&gt;&gt;  Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;  COW buffer<br>&gt; <br>&gt; Same question here as above, then.<br>&gt;&gt; <br>&gt;&gt; - ARC optimization<br>&gt;&gt; <br>&gt;&gt;  Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;  can remove retain/release pairs across such code::<br>&gt;&gt; <br>&gt;&gt;      %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;      %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;      %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;      %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;      // Use %4<br>&gt;&gt;      destroy_value %4 : $MyClass<br>&gt;&gt; <br>&gt;&gt; Scoping instructions<br>&gt;&gt; --------------------<br>&gt;&gt; <br>&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt; buffer reference. For example::<br>&gt;&gt; <br>&gt;&gt;    %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;    // load something from %b1<br>&gt;&gt;    %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;    %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;    // load something from %b2<br>&gt;&gt; <br>&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt; buffer.<br>&gt;&gt; <br>&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt; <br>&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt; <br>&gt; Looks reasonable.<br>&gt; <br>&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt; <br>&gt;&gt;    // there should be a begin-of-scope %baddr<br>&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;    store %x to %mut_b    // modification of the buffer<br>&gt;&gt;    // there should be a end-of-scope %baddr<br>&gt;&gt; <br>&gt;&gt;    loop {<br>&gt;&gt;      %b = load %baddr<br>&gt;&gt;      %y = load %b        // load from the buffer<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt; <br>&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;    %b = load %baddr        // moved out of the loop<br>&gt;&gt;    store %x to %mut_b<br>&gt;&gt; <br>&gt;&gt;    loop {<br>&gt;&gt;      %y = load %b<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt; also hoist the load::<br>&gt;&gt; <br>&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;    %b = load %baddr<br>&gt;&gt;    %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;    store %x to %mut_b<br>&gt;&gt; <br>&gt;&gt;    loop {<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt; <br>&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt; -----------------------------------------<br>&gt;&gt; <br>&gt;&gt; SIL instructions<br>&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt; <br>&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt; <br>&gt;&gt;    bb0:<br>&gt;&gt;      is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;    bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;      // usually empty<br>&gt;&gt;      br bb3(%1 : $COWBuffer)<br>&gt;&gt;    bb2:                  // the false-block<br>&gt;&gt;      // usually contains:<br>&gt;&gt;      %2 = apply %copy_buffer<br>&gt;&gt;      %3 = cow_to_ref %2<br>&gt;&gt;      store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;      br bb3(%2 : $COWBuffer)<br>&gt;&gt;    bb3(%4 : $COWBuffer):<br>&gt;&gt;      // Modify the buffer referenced by %4<br>&gt;&gt;      // ...<br>&gt;&gt; <br>&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt; <br>&gt;&gt;    end_unique_addr %0 : $*COWBuffer<br>&gt;&gt; <br>&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt; verifier.<br>&gt;&gt; <br>&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt; same function.<br>&gt;&gt; <br>&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt; across these instructions.<br>&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt; <br>&gt;&gt;    %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;    // do something with %1<br>&gt;&gt;    …<br>&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;    …<br>&gt;&gt;    %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt; <br>&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt; from the COWType.<br>&gt;&gt; Example::<br>&gt;&gt; <br>&gt;&gt;  %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;  store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt; <br>&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt; <br>&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt; <br>&gt;&gt;    is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt; <br>&gt;&gt;    %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt; <br>&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt; ``end_unique_addr``.<br>&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt; <br>&gt;&gt;    func foo(arr : [Int], x: Int) {<br>&gt;&gt;      arr[0] = 27<br>&gt;&gt;      …<br>&gt;&gt;      y = arr[x]<br>&gt;&gt;      …<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt; <br>&gt;&gt;    %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt; <br>&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt; <br>&gt;&gt;    bb0:<br>&gt;&gt;      is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;    bb1(%1 : $COWBuffer):<br>&gt;&gt;      … // main control flow continues here<br>&gt;&gt;    bb2:<br>&gt;&gt;      unreachable<br>&gt;&gt; <br>&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt; <br>&gt;&gt; Built-ins<br>&gt;&gt; ^^^^^^^^^<br>&gt;&gt; <br>&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt; <br>&gt;&gt;    func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;    func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt; <br>&gt;&gt; For example::<br>&gt;&gt; <br>&gt;&gt;    struct COWType {<br>&gt;&gt;      copy_on_write var b : COWBuffer<br>&gt;&gt; <br>&gt;&gt;      mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;        if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;          return uniqueBuffer<br>&gt;&gt;        }<br>&gt;&gt;        let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;        self.b = copiedBuffer<br>&gt;&gt;        return copiedBuffer<br>&gt;&gt;      }<br>&gt;&gt; <br>&gt;&gt;      mutating func setSomeData(x: Int) {<br>&gt;&gt;        let uniqueBuffer = makeMutable()<br>&gt;&gt;        uniqueBuffer.someData = x<br>&gt;&gt;        endUnique(&amp;self.b)<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt; <br>&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br></p><p>I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout scope.<br></p><p>&gt; <br>&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt; a unique buffer reference.<br>&gt;&gt; <br>&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt; <br>&gt;&gt; .. note::<br>&gt;&gt;  This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;  problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;  the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;  can do its job).<br>&gt; <br>&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt; described above might be, FWIW.<br>&gt; <br>&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt; <br>&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;   same function.<br>&gt;&gt; <br>&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt; <br>&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;   pair.<br>&gt;&gt; <br>&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;   reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt; <br>&gt;&gt;   Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;   part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;   of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;   for the purpose of copying.<br>&gt;&gt; <br>&gt;&gt; Examples::<br>&gt;&gt; <br>&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;      // violates rule 1<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;      makeMutable()<br>&gt;&gt;      self.b.someData = x // violates rule 2<br>&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;      uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func incrementSomeData() {<br>&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;      uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;    }<br>&gt; <br>&gt; It would be instructive to write down the *correct* code for these<br>&gt; operations.<br></p><p>added to my todo list.<br></p><p>&gt; <br>&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt; <br>&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt; the unique buffer.<br>&gt; <br>&gt; No big deal.<br>&gt; <br>&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt; --------------------------------------------<br>&gt;&gt; <br>&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt; <br>&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt; scope of a COW buffer.<br>&gt;&gt; <br>&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt; <br>&gt;&gt;    begin_exclusive<br>&gt;&gt;    end_exclusive<br>&gt;&gt; <br>&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt; <br>&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt; done in mutating functions.<br>&gt;&gt; <br>&gt;&gt; Example::<br>&gt;&gt; <br>&gt;&gt;    // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;    // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;    sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;    bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt; <br>&gt;&gt;    // &gt;   makeMutable() (inlined)<br>&gt;&gt;    // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;    // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;    begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt; <br>&gt;&gt;    // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;    // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;    // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;    // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;    %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt; <br>&gt;&gt;    // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;    // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;    // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;    // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;    %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;    end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    br %isuniq, bb_continue, bb_slow<br>&gt;&gt; <br>&gt;&gt;    bb_slow:<br>&gt;&gt;    // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;    // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;    %copied_storage_class = alloc_ref ...<br>&gt;&gt;    // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;    store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;    br bb_continue<br>&gt;&gt; <br>&gt;&gt;    bb_continue:<br>&gt;&gt; <br>&gt;&gt;    // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;    // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;    // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;    // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;    // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;    // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;    // they must be consumed within this scope.<br>&gt;&gt;    end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt; <br>&gt;&gt;    // &gt;    self._storage.someData = x<br>&gt;&gt;    // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;    %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt; <br>&gt;&gt;    // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;    %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;    %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt; <br>&gt;&gt;    // Write some data into the CoW buffer.<br>&gt;&gt;    // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;    // A single-use _addr instruction, so no scope.<br>&gt;&gt;    %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;    // A store with an implicit [exclusive] scope.<br>&gt;&gt;    store [assign] %x to %somedata_addr<br>&gt;&gt; <br>&gt;&gt;    strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;    // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;    end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt; <br>&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt; alternative.<br>&gt; <br>&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt; generates this SIL.<br>&gt; <br>&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt; details of this approach.<br>&gt; <br>&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt; would be conducive to inserting the scoping instructions.<br>&gt; <br>&gt; <br>&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt; --------------------------------------------------------<br>&gt; <br>&gt; You can only have a dependency between two things, but as phrased “a<br>&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt; would fix it.<br>&gt; <br>&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt; to a scope-begin instruction::<br>&gt;&gt; <br>&gt;&gt;    %b_cow = load %baddr<br>&gt;&gt;    %b = cow_to_ref %b_cow<br>&gt;&gt;    %x = load %b             // No dependency between this...<br>&gt;&gt;    ...<br>&gt;&gt;    begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;    ...<br>&gt;&gt; <br>&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt; <br>&gt;&gt;    %b_cow = load %baddr<br>&gt;&gt;    %b = cow_to_ref %b_cow<br>&gt;&gt;    ...<br>&gt;&gt;    begin_exclusive %baddr<br>&gt;&gt;    %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;    ...<br>&gt;&gt; <br>&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt; <br>&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;  the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt; <br>&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;  reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt; <br>&gt;&gt; Preconditions<br>&gt;&gt; =============<br>&gt;&gt; <br>&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt; buffer. <br>&gt; <br>&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt; why this would be dependent on it.<br></p><p>We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the optimizer.<br>For example, the SIL code to get from an Array to a native ContiguousArrayStorage reference is pretty hard to understand for the optimizer (involves low level bit operations, etc.).<br></p><p>&gt; <br>&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt; <br>&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt; <br>&gt;&gt;    var arr = [MyClass()]  // a global array<br>&gt;&gt; <br>&gt;&gt;    foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt; <br>&gt;&gt;    func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;      let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;      let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;      arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;      return r.i        // use-after-free!<br>&gt;&gt;    }<br>&gt; <br>&gt; I only know of one way to resolve inout and pinning:<br>&gt; <br>&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;  an inout context so that all inout values are provably unique<br>&gt;  references in the absence of unsafe code.  We drop pinning and provide<br>&gt;  explicit operations that provide simultaneous lvalue accesses to<br>&gt;  distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt; <br>&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt; forward without this looming uncertainty.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161017/671af6dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com&gt; wrote:<br></p><p>&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt; <br>&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt; <br>&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt; <br>&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;<br>&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt; then you would not be able to “copy” it to a global.<br></p><p>Yes, a reference to a move-only type would work for this purpose.<br></p><p><br>&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overview<br>&gt;&gt;&gt; ========<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;  types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;  of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;    In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;    It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt; =========<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    class COWBuffer {<br>&gt;&gt;&gt;      var someData: Int<br>&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct COWType {<br>&gt;&gt;&gt;      var b : COWBuffer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      mutating func change_it() {<br>&gt;&gt;&gt;        if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;          b = copy_buffer(b)<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;        b.someData = ...<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func foo(arr : [Int]) {<br>&gt;&gt;&gt;      x = arr[0]<br>&gt;&gt;&gt;      opaque_function()<br>&gt;&gt;&gt;      y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt; has to copy it. <br>&gt;&gt; <br>&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;<br>&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt; uniquely-referenced.<br></p><p>Right.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt; =================================<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt; ------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct COWType {<br>&gt;&gt;&gt;      copy_on_write var b : COWBuffer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      // ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt; <br>&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;<br>&gt; That’s true.<br>&gt;<br>&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;<br>&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br></p><p>Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>semantics” at this point in the proposal leaves a gap, because it does<br>change semantic *requirements*.  You should mention that.<br></p><p>&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;  Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;  Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;  use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;  (see below) could break memory safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt; --------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    $@sil_cow COWBuffer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    cow_to_ref<br>&gt;&gt;&gt;    ref_to_cow<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var c: COWType<br>&gt;&gt;&gt;    let x = c.b.someData<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt; =============================<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;  during the lifetime of the reference.*<br>&gt;&gt; <br>&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt; uniquely referenced buffers.<br>&gt;<br>&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt; takes the _address_ of the buffer reference as argument.<br>&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt; function or inlined.<br></p><p>I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>in a @sil_cow reference, given what you wrote above.<br></p><p><br>&gt;&gt;  Unless you mean the reference is<br>&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt; <br>&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt; <br>&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;<br>&gt; Again, the is_unique which takes the address of the reference, will<br>&gt; guarantee that during the lifetime of a buffer there are no<br>&gt; modifications of the buffer.<br></p><p>Again, that sounds like it rules out inplace modification of uniquely<br>referenced buffers.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;  Example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;      %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;      %4 = load %3 : $*Int<br>&gt;&gt;&gt;      %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;      %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;  like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;  anymore.<br>&gt;&gt; <br>&gt;&gt; W0000000000000000000000t.<br>&gt;&gt; <br>&gt;&gt;&gt;  Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;  projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;  memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;  COW buffer<br>&gt;&gt; <br>&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;  can remove retain/release pairs across such code::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;      %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;      %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;      %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;      // Use %4<br>&gt;&gt;&gt;      destroy_value %4 : $MyClass<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;    // load something from %b1<br>&gt;&gt;&gt;    %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;    %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;    // load something from %b2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt; <br>&gt;&gt; Looks reasonable.<br>&gt;&gt; <br>&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;&gt;    store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;    // there should be a end-of-scope %baddr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    loop {<br>&gt;&gt;&gt;      %b = load %baddr<br>&gt;&gt;&gt;      %y = load %b        // load from the buffer<br>&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;&gt;    %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;    store %x to %mut_b<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    loop {<br>&gt;&gt;&gt;      %y = load %b<br>&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;&gt;    %b = load %baddr<br>&gt;&gt;&gt;    %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;    store %x to %mut_b<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    loop {<br>&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    bb0:<br>&gt;&gt;&gt;      is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;    bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;      // usually empty<br>&gt;&gt;&gt;      br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;    bb2:                  // the false-block<br>&gt;&gt;&gt;      // usually contains:<br>&gt;&gt;&gt;      %2 = apply %copy_buffer<br>&gt;&gt;&gt;      %3 = cow_to_ref %2<br>&gt;&gt;&gt;      store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;      br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;    bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;      // Modify the buffer referenced by %4<br>&gt;&gt;&gt;      // ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt; same function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;    // do something with %1<br>&gt;&gt;&gt;    …<br>&gt;&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;    …<br>&gt;&gt;&gt;    %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt; Example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;  store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;      arr[0] = 27<br>&gt;&gt;&gt;      …<br>&gt;&gt;&gt;      y = arr[x]<br>&gt;&gt;&gt;      …<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    bb0:<br>&gt;&gt;&gt;      is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;    bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;      … // main control flow continues here<br>&gt;&gt;&gt;    bb2:<br>&gt;&gt;&gt;      unreachable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;    func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct COWType {<br>&gt;&gt;&gt;      copy_on_write var b : COWBuffer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;        if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;          return uniqueBuffer<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;        let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;        self.b = copiedBuffer<br>&gt;&gt;&gt;        return copiedBuffer<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;      mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;        let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;        uniqueBuffer.someData = x<br>&gt;&gt;&gt;        endUnique(&amp;self.b)<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;<br>&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt; scope.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;  This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;  problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;  the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;  can do its job).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt; described above might be, FWIW.<br>&gt;&gt; <br>&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;   same function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;   pair.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;   reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;   part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;   of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;   for the purpose of copying.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;&gt;      // violates rule 1<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;      makeMutable()<br>&gt;&gt;&gt;      self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;      uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    mutating func incrementSomeData() {<br>&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;      uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt; operations.<br>&gt;<br>&gt; added to my todo list.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt; the unique buffer.<br>&gt;&gt; <br>&gt;&gt; No big deal.<br>&gt;&gt; <br>&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    begin_exclusive<br>&gt;&gt;&gt;    end_exclusive<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;    // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;    sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;    bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;    // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;    // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;    begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;    // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;    // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;    // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;    %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;    // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;    // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;    // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;    %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;    end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    bb_slow:<br>&gt;&gt;&gt;    // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;    // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;    %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;    // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;    store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;    br bb_continue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    bb_continue:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;    // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;    // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;    // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;    // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;    // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;    // they must be consumed within this scope.<br>&gt;&gt;&gt;    end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;    // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;    %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;    %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;    %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // Write some data into the CoW buffer.<br>&gt;&gt;&gt;    // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;    // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;    %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;    // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;    store [assign] %x to %somedata_addr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;    // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;    end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt; alternative.<br>&gt;&gt; <br>&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt; generates this SIL.<br>&gt;&gt; <br>&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt; details of this approach.<br>&gt;&gt; <br>&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt; <br>&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt; would fix it.<br>&gt;&gt; <br>&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %b_cow = load %baddr<br>&gt;&gt;&gt;    %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;    %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;    begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    %b_cow = load %baddr<br>&gt;&gt;&gt;    %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;    begin_exclusive %baddr<br>&gt;&gt;&gt;    %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;  the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;  reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt; =============<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt; buffer. <br>&gt;&gt; <br>&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt; why this would be dependent on it.<br>&gt;<br>&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt; optimizer.<br>&gt; For example, the SIL code to get from an Array to a native<br>&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt; optimizer (involves low level bit operations, etc.).<br></p><p>It wouldn&#39;t need to do low-level bit operations if our enums were<br>capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>couldn&#39;t give the optimizer something to work with that has higher level<br>semantics than what we currently do.<br></p><p>&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;      let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;      let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;      arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;      return r.i        // use-after-free!<br>&gt;&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt; <br>&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;  an inout context so that all inout values are provably unique<br>&gt;&gt;  references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;  explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;  distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt; <br>&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 10:21 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;&gt; <br>&gt;&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt;&gt; then you would not be able to “copy” it to a global.<br>&gt; <br>&gt; Yes, a reference to a move-only type would work for this purpose.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overview<br>&gt;&gt;&gt;&gt; ========<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;&gt; of it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;   In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;&gt;   It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt;&gt; =========<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   class COWBuffer {<br>&gt;&gt;&gt;&gt;     var someData: Int<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct COWType {<br>&gt;&gt;&gt;&gt;     var b : COWBuffer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     mutating func change_it() {<br>&gt;&gt;&gt;&gt;       if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;&gt;         b = copy_buffer(b)<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;       b.someData = ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func foo(arr : [Int]) {<br>&gt;&gt;&gt;&gt;     x = arr[0]<br>&gt;&gt;&gt;&gt;     opaque_function()<br>&gt;&gt;&gt;&gt;     y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt;&gt; has to copy it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;&gt; <br>&gt;&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt;&gt; uniquely-referenced.<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt;&gt; =================================<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt;&gt; ------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct COWType {<br>&gt;&gt;&gt;&gt;     copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;&gt; <br>&gt;&gt; That’s true.<br>&gt;&gt; <br>&gt;&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;&gt; <br>&gt;&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br>&gt; <br>&gt; Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>&gt; semantics” at this point in the proposal leaves a gap, because it does<br>&gt; change semantic *requirements*.  You should mention that.<br>&gt; <br>&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;&gt; Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;&gt; Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;&gt; use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;&gt; (see below) could break memory safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt;&gt; --------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   cow_to_ref<br>&gt;&gt;&gt;&gt;   ref_to_cow<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var c: COWType<br>&gt;&gt;&gt;&gt;   let x = c.b.someData<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;&gt;   %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;   %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;&gt;   %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt;&gt; =============================<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;&gt; during the lifetime of the reference.*<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt;&gt; uniquely referenced buffers.<br>&gt;&gt; <br>&gt;&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt;&gt; takes the _address_ of the buffer reference as argument.<br>&gt;&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt;&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt;&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt;&gt; function or inlined.<br>&gt; <br>&gt; I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>&gt; in a @sil_cow reference, given what you wrote above.<br></p><p>You would not be able to get a reference to a mutable buffer by reading the COW type’s @sil_cow field.<br>Instead you would only get such a reference as a result of the is_unique instruction/builtin. Or, of course, by creating a new buffer.<br></p><p>I’m not sure if this was the question, though.<br></p><p>Plus: we will have an explicit conversion instruction (start_unique) to convert an immutable reference to a mutable referece.<br>A SIL optimization can replace an is_unique with this instruction if  it can prove that the reference is already unique at that point.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; Unless you mean the reference is<br>&gt;&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;&gt; <br>&gt;&gt; Again, the is_unique which takes the address of the reference, will<br>&gt;&gt; guarantee that during the lifetime of a buffer there are no<br>&gt;&gt; modifications of the buffer.<br>&gt; <br>&gt; Again, that sounds like it rules out inplace modification of uniquely<br>&gt; referenced buffers.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;     %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;     %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;     %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;&gt;     %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;&gt; like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; W0000000000000000000000t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;&gt; projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;&gt; memory.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;&gt; COW buffer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;&gt; can remove retain/release pairs across such code::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;     %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;&gt;     %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;&gt;     %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;&gt;     // Use %4<br>&gt;&gt;&gt;&gt;     destroy_value %4 : $MyClass<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;&gt;   // load something from %b1<br>&gt;&gt;&gt;&gt;   %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;&gt;   %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;&gt;   // load something from %b2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looks reasonable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;&gt;   %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;   store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;&gt;   // there should be a end-of-scope %baddr<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   loop {<br>&gt;&gt;&gt;&gt;     %b = load %baddr<br>&gt;&gt;&gt;&gt;     %y = load %b        // load from the buffer<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;   %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;&gt;   store %x to %mut_b<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   loop {<br>&gt;&gt;&gt;&gt;     %y = load %b<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;   %b = load %baddr<br>&gt;&gt;&gt;&gt;   %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;&gt;   store %x to %mut_b<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   loop {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   bb0:<br>&gt;&gt;&gt;&gt;     is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;&gt;   bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;&gt;     // usually empty<br>&gt;&gt;&gt;&gt;     br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;&gt;   bb2:                  // the false-block<br>&gt;&gt;&gt;&gt;     // usually contains:<br>&gt;&gt;&gt;&gt;     %2 = apply %copy_buffer<br>&gt;&gt;&gt;&gt;     %3 = cow_to_ref %2<br>&gt;&gt;&gt;&gt;     store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;     br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;&gt;   bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;&gt;     // Modify the buffer referenced by %4<br>&gt;&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;   // do something with %1<br>&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;   is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;   %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt; %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt; %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt; store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;&gt;     arr[0] = 27<br>&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;     y = arr[x]<br>&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   bb0:<br>&gt;&gt;&gt;&gt;     is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;&gt;   bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;&gt;     … // main control flow continues here<br>&gt;&gt;&gt;&gt;   bb2:<br>&gt;&gt;&gt;&gt;     unreachable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;&gt;   func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct COWType {<br>&gt;&gt;&gt;&gt;     copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;&gt;       if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;&gt;         return uniqueBuffer<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;       let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;&gt;       self.b = copiedBuffer<br>&gt;&gt;&gt;&gt;       return copiedBuffer<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;       let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;       uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;       endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;&gt; <br>&gt;&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt;&gt; scope.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt; This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;&gt; problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;&gt; the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;&gt; can do its job).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt;&gt; described above might be, FWIW.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;&gt;  same function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;&gt;  pair.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;&gt;  reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;&gt;  part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;&gt;  of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;&gt;  for the purpose of copying.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;     let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;     uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;     // violates rule 1<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;     makeMutable()<br>&gt;&gt;&gt;&gt;     self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;&gt;     endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;     let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;     uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;     endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;     uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   mutating func incrementSomeData() {<br>&gt;&gt;&gt;&gt;     let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;     uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;&gt;     endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt;&gt; operations.<br>&gt;&gt; <br>&gt;&gt; added to my todo list.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt;&gt; the unique buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No big deal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   begin_exclusive<br>&gt;&gt;&gt;&gt;   end_exclusive<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;   // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;&gt;   sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;&gt;   bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;&gt;   // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;&gt;   // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;&gt;   begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;&gt;   // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;&gt;   // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;&gt;   // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;&gt;   %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;&gt;   // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;&gt;   // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;&gt;   // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;&gt;   %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;&gt;   end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   bb_slow:<br>&gt;&gt;&gt;&gt;   // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;&gt;   // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;&gt;   %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;&gt;   // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;&gt;   store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;&gt;   br bb_continue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   bb_continue:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;&gt;   // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;&gt;   // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;&gt;   // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;&gt;   // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;&gt;   // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;&gt;   // they must be consumed within this scope.<br>&gt;&gt;&gt;&gt;   end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;&gt;   // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;&gt;   %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;&gt;   %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;   %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // Write some data into the CoW buffer.<br>&gt;&gt;&gt;&gt;   // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;&gt;   // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;&gt;   %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;&gt;   // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;&gt;   store [assign] %x to %somedata_addr<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;&gt;   // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;&gt;   end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt;&gt; generates this SIL.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt;&gt; details of this approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt;&gt; would fix it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;   %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;   %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;   begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;   %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;   begin_exclusive %baddr<br>&gt;&gt;&gt;&gt;   %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;&gt; the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;&gt; reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt;&gt; =============<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt;&gt; buffer. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt;&gt; why this would be dependent on it.<br>&gt;&gt; <br>&gt;&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt;&gt; optimizer.<br>&gt;&gt; For example, the SIL code to get from an Array to a native<br>&gt;&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt;&gt; optimizer (involves low level bit operations, etc.).<br>&gt; <br>&gt; It wouldn&#39;t need to do low-level bit operations if our enums were<br>&gt; capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>&gt; couldn&#39;t give the optimizer something to work with that has higher level<br>&gt; semantics than what we currently do.<br>&gt; <br>&gt;&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;&gt;     let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;&gt;     let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;&gt;     arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;&gt;     return r.i        // use-after-free!<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;&gt; an inout context so that all inout values are provably unique<br>&gt;&gt;&gt; references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;&gt; explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;&gt; distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
