<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 26, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br></p><p>	control.sendAction(“doSomething:”, to: target, forEvent: event)<br></p><p>There are many points of failure here:<br></p><p>1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>2) The compiler doesn’t look for existing methods with this selector anywhere<br>3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md).<br></p><p>I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br></p><p>	control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br></p><p>“doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br></p><p>	extension MyApplication {<br>		@objc(jumpUpAndDown:)<br>		func doSomething(sender: AnyObject?) { … }<br>	}<br></p><p>By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br></p><p>This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br></p><p>	let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>	let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br></p><p>I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 27, 2015 at 12:00:00am</p></header><div class="content"><p>This is a neat idea. Here are some of my thoughts after initial readthrough:<br></p><p>- For symmetry with Obj-C code, how about using &quot;@selector&quot;, such as<br>@selector(UIView.`insertSubview(_:at:)`) ?<br></p><p>- Or, why bother with a new expression? Could the compiler just do this<br>automatically when it encounters an @objc function being passed as a<br>Selector? So, you&#39;d simply be able to say &quot;let sel1: Selector =<br>UIView.`frame.get`&quot;<br></p><p>- Should the migrator offer to convert string-constant selectors to this<br>form?<br></p><p>- It might be worth considering this in the context of the &quot;type-safe<br>selectors&quot; idea that was floating around a while back.<br></p><p>- Would it be valid to qualify a function with a subclass&#39;s name, when it&#39;s<br>really only defined on the superclass? That is, would<br>&quot;objc_selector(MyView.`frame.get`)&quot; work even if MyView doesn&#39;t override<br>the `frame` property?<br></p><p>I could see this last one as a potential source of user confusion, because<br>naming a particular class wouldn&#39;t actually tell you which implementation<br>gets called when performing the selector (that&#39;s just the nature of the<br>Obj-C runtime).<br></p><p>Jacob Bandes-Storch<br></p><p>On Sat, Dec 26, 2015 at 11:48 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Currently, producing an Objective-C selector in Swift is an error-prone<br>&gt; operation. One effectively just writes a string literal and uses it in a<br>&gt; context where an ObjectiveC.Selector is expected:<br>&gt;<br>&gt;         control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt;<br>&gt; There are many points of failure here:<br>&gt;<br>&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid<br>&gt; spelling for a selector<br>&gt; 2) The compiler doesn’t look for existing methods with this selector<br>&gt; anywhere<br>&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t<br>&gt; always immediately obvious (especially for initializers), and will be<br>&gt; getting significantly more complicated with the renaming work for Swift 3 (<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt; ).<br>&gt;<br>&gt; I suggest that we add an expression ‘objc_selector(method-reference)` that<br>&gt; produces the Objective-C selector for the named method, and produces an<br>&gt; error if the method does not have an Objective-C entry point. For example:<br>&gt;<br>&gt;         control.sendAction(objc_selector(MyApplication.doSomething), to:<br>&gt; target, forEvent: event)<br>&gt;<br>&gt; “doSomething” is a method of MyApplication, which might even have a<br>&gt; completely-unrelated name in Objective-C:<br>&gt;<br>&gt;         extension MyApplication {<br>&gt;                 @objc(jumpUpAndDown:)<br>&gt;                 func doSomething(sender: AnyObject?) { … }<br>&gt;         }<br>&gt;<br>&gt; By naming the Swift method and having objc_selector do the work to form<br>&gt; the Objective-C selector, we free the programming from having to do the<br>&gt; naming translation manually and get static checking that the method exists<br>&gt; and is exposed to Objective-C.<br>&gt;<br>&gt; This proposal composes with my “Generalized Naming for Any Function”<br>&gt; proposal, which lets us name methods fully, including getters/setters:<br>&gt;<br>&gt;         let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`)<br>&gt; // produces the Selector “insertSubview:atIndex:&quot;<br>&gt;         let sel2: Selector = objc_selector(UIView.`frame.get`) // produces<br>&gt; the Selector “frame&quot;<br>&gt;<br>&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this<br>&gt; functionality is straightforward.<br>&gt;<br>&gt;         - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/9409201e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 29, 2015 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 27, 2015, at 12:07 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is a neat idea. Here are some of my thoughts after initial readthrough:<br>&gt; <br>&gt; - For symmetry with Obj-C code, how about using &quot;@selector&quot;, such as @selector(UIView.`insertSubview(_:at:)`) ?<br></p><p>@ means at-tribute in Swift, whereas this is a specific expression. <br></p><p>&gt; - Or, why bother with a new expression? Could the compiler just do this automatically when it encounters an @objc function being passed as a Selector? So, you&#39;d simply be able to say &quot;let sel1: Selector = UIView.`frame.get`&quot;<br></p><p>It could, but I don&#39;t think it should: the operation is not common enough that making it implicit would reduce overall syntactic noise, and it would introduce ambiguities between selector- and closure-based APIs. <br></p><p>&gt; - Should the migrator offer to convert string-constant selectors to this form?<br></p><p>Yes, absolutely.<br></p><p>&gt; - It might be worth considering this in the context of the &quot;type-safe selectors&quot; idea that was floating around a while back.<br></p><p>Yes, I should have referenced that. Apologies!<br></p><p>&gt; - Would it be valid to qualify a function with a subclass&#39;s name, when it&#39;s really only defined on the superclass? That is, would &quot;objc_selector(MyView.`frame.get`)&quot; work even if MyView doesn&#39;t override the `frame` property?<br></p><p>Yes. MyView still has that property even if it doesn&#39;t override it. <br>&gt; <br>&gt; I could see this last one as a potential source of user confusion, because naming a particular class wouldn&#39;t actually tell you which implementation gets called when performing the selector (that&#39;s just the nature of the Obj-C runtime).<br></p><p>To some extent, that&#39;s the nature of overriding. But objective-c allows one to use a selector with an unrelated class, which can certainly be confusing. I feel like that comes from the runtime itself, and isn&#39;t something we can avoid with any syntax we pick. <br></p><p>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt;&gt; On Sat, Dec 26, 2015 at 11:48 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br>&gt;&gt; <br>&gt;&gt;         control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt;&gt; <br>&gt;&gt; There are many points of failure here:<br>&gt;&gt; <br>&gt;&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>&gt;&gt; 2) The compiler doesn’t look for existing methods with this selector anywhere<br>&gt;&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md).<br>&gt;&gt; <br>&gt;&gt; I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br>&gt;&gt; <br>&gt;&gt;         control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;&gt; <br>&gt;&gt; “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt;&gt; <br>&gt;&gt;         extension MyApplication {<br>&gt;&gt;                 @objc(jumpUpAndDown:)<br>&gt;&gt;                 func doSomething(sender: AnyObject?) { … }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt;&gt; <br>&gt;&gt; This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br>&gt;&gt; <br>&gt;&gt;         let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>&gt;&gt;         let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br>&gt;&gt; <br>&gt;&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br>&gt;&gt; <br>&gt;&gt;         - Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/d535fd5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 29, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 12:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 27, 2015, at 12:07 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; This is a neat idea. Here are some of my thoughts after initial readthrough:<br>&gt;&gt; <br>&gt;&gt; - For symmetry with Obj-C code, how about using &quot;@selector&quot;, such as @selector(UIView.`insertSubview(_:at:)`) ?<br>&gt; <br>&gt; @ means at-tribute in Swift, whereas this is a specific expression. <br>&gt; <br>&gt;&gt; - Or, why bother with a new expression? Could the compiler just do this automatically when it encounters an @objc function being passed as a Selector? So, you&#39;d simply be able to say &quot;let sel1: Selector = UIView.`frame.get`&quot;<br>&gt; <br>&gt; It could, but I don&#39;t think it should: the operation is not common enough that making it implicit would reduce overall syntactic noise, and it would introduce ambiguities between selector- and closure-based APIs. <br></p><p>Maybe we can make constructor-like &quot;Selector(Class.method)&quot; syntax work (and &quot;Selector(getterFor:/setterFor: Class.property)&quot; for property accessors) instead of introducing a new magic function name.<br></p><p>-Joe<br></p><p>&gt;&gt; - Should the migrator offer to convert string-constant selectors to this form?<br>&gt; <br>&gt; Yes, absolutely.<br>&gt; <br>&gt;&gt; - It might be worth considering this in the context of the &quot;type-safe selectors&quot; idea that was floating around a while back.<br>&gt; <br>&gt; Yes, I should have referenced that. Apologies!<br>&gt; <br>&gt;&gt; - Would it be valid to qualify a function with a subclass&#39;s name, when it&#39;s really only defined on the superclass? That is, would &quot;objc_selector(MyView.`frame.get`)&quot; work even if MyView doesn&#39;t override the `frame` property?<br>&gt; <br>&gt; Yes. MyView still has that property even if it doesn&#39;t override it. <br>&gt;&gt; <br>&gt;&gt; I could see this last one as a potential source of user confusion, because naming a particular class wouldn&#39;t actually tell you which implementation gets called when performing the selector (that&#39;s just the nature of the Obj-C runtime).<br>&gt; <br>&gt; To some extent, that&#39;s the nature of overriding. But objective-c allows one to use a selector with an unrelated class, which can certainly be confusing. I feel like that comes from the runtime itself, and isn&#39;t something we can avoid with any syntax we pick. <br>&gt; <br>&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt; <br>&gt;&gt; On Sat, Dec 26, 2015 at 11:48 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br>&gt;&gt; <br>&gt;&gt;         control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt;&gt; <br>&gt;&gt; There are many points of failure here:<br>&gt;&gt; <br>&gt;&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>&gt;&gt; 2) The compiler doesn’t look for existing methods with this selector anywhere<br>&gt;&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;).<br>&gt;&gt; <br>&gt;&gt; I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br>&gt;&gt; <br>&gt;&gt;         control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;&gt; <br>&gt;&gt; “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt;&gt; <br>&gt;&gt;         extension MyApplication {<br>&gt;&gt;                 @objc(jumpUpAndDown:)<br>&gt;&gt;                 func doSomething(sender: AnyObject?) { … }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt;&gt; <br>&gt;&gt; This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br>&gt;&gt; <br>&gt;&gt;         let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>&gt;&gt;         let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br>&gt;&gt; <br>&gt;&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br>&gt;&gt; <br>&gt;&gt;         - Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/93d0e270/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 29, 2015 at 10:00:00pm</p></header><div class="content"><p>What if you could just refer to it by pointing to a special property ?<br></p><p>button.addTarget( class.prototype.handlePress)<br></p><p>If it has parameters these could be specified like so<br></p><p>button.addTarget(class.prototype.handlePress(sender:))<br></p><p><br>Sent from my iPhone<br></p><p>&gt; On 29 Dec 2015, at 21:46, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 12:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 12:07 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a neat idea. Here are some of my thoughts after initial readthrough:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For symmetry with Obj-C code, how about using &quot;@selector&quot;, such as @selector(UIView.`insertSubview(_:at:)`) ?<br>&gt;&gt; <br>&gt;&gt; @ means at-tribute in Swift, whereas this is a specific expression. <br>&gt;&gt; <br>&gt;&gt;&gt; - Or, why bother with a new expression? Could the compiler just do this automatically when it encounters an @objc function being passed as a Selector? So, you&#39;d simply be able to say &quot;let sel1: Selector = UIView.`frame.get`&quot;<br>&gt;&gt; <br>&gt;&gt; It could, but I don&#39;t think it should: the operation is not common enough that making it implicit would reduce overall syntactic noise, and it would introduce ambiguities between selector- and closure-based APIs. <br>&gt; <br>&gt; Maybe we can make constructor-like &quot;Selector(Class.method)&quot; syntax work (and &quot;Selector(getterFor:/setterFor: Class.property)&quot; for property accessors) instead of introducing a new magic function name.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt;&gt; - Should the migrator offer to convert string-constant selectors to this form?<br>&gt;&gt; <br>&gt;&gt; Yes, absolutely.<br>&gt;&gt; <br>&gt;&gt;&gt; - It might be worth considering this in the context of the &quot;type-safe selectors&quot; idea that was floating around a while back.<br>&gt;&gt; <br>&gt;&gt; Yes, I should have referenced that. Apologies!<br>&gt;&gt; <br>&gt;&gt;&gt; - Would it be valid to qualify a function with a subclass&#39;s name, when it&#39;s really only defined on the superclass? That is, would &quot;objc_selector(MyView.`frame.get`)&quot; work even if MyView doesn&#39;t override the `frame` property?<br>&gt;&gt; <br>&gt;&gt; Yes. MyView still has that property even if it doesn&#39;t override it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could see this last one as a potential source of user confusion, because naming a particular class wouldn&#39;t actually tell you which implementation gets called when performing the selector (that&#39;s just the nature of the Obj-C runtime).<br>&gt;&gt; <br>&gt;&gt; To some extent, that&#39;s the nature of overriding. But objective-c allows one to use a selector with an unrelated class, which can certainly be confusing. I feel like that comes from the runtime itself, and isn&#39;t something we can avoid with any syntax we pick. <br>&gt;&gt; <br>&gt;&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 26, 2015 at 11:48 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are many points of failure here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>&gt;&gt;&gt;&gt; 2) The compiler doesn’t look for existing methods with this selector anywhere<br>&gt;&gt;&gt;&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         extension MyApplication {<br>&gt;&gt;&gt;&gt;                 @objc(jumpUpAndDown:)<br>&gt;&gt;&gt;&gt;                 func doSomething(sender: AnyObject?) { … }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>&gt;&gt;&gt;&gt;         let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/33d27812/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 09:00:00am</p></header><div class="content"><p>What if selectors arguments could be imported into swift to take a closure instead ? <br></p><p>This would fit into the proposal to rewrite the imported objective c Apis <br></p><p>So <br></p><p>- addAction:(Selector)action<br></p><p>Becomes<br></p><p>addAction(action:(AnyObject)-&gt;Void)<br></p><p>Instead of<br></p><p>addAction(action:String) <br></p><p>Like it does now.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 29 Dec 2015, at 21:46, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 12:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 12:07 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a neat idea. Here are some of my thoughts after initial readthrough:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For symmetry with Obj-C code, how about using &quot;@selector&quot;, such as @selector(UIView.`insertSubview(_:at:)`) ?<br>&gt;&gt; <br>&gt;&gt; @ means at-tribute in Swift, whereas this is a specific expression. <br>&gt;&gt; <br>&gt;&gt;&gt; - Or, why bother with a new expression? Could the compiler just do this automatically when it encounters an @objc function being passed as a Selector? So, you&#39;d simply be able to say &quot;let sel1: Selector = UIView.`frame.get`&quot;<br>&gt;&gt; <br>&gt;&gt; It could, but I don&#39;t think it should: the operation is not common enough that making it implicit would reduce overall syntactic noise, and it would introduce ambiguities between selector- and closure-based APIs. <br>&gt; <br>&gt; Maybe we can make constructor-like &quot;Selector(Class.method)&quot; syntax work (and &quot;Selector(getterFor:/setterFor: Class.property)&quot; for property accessors) instead of introducing a new magic function name.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt;&gt; - Should the migrator offer to convert string-constant selectors to this form?<br>&gt;&gt; <br>&gt;&gt; Yes, absolutely.<br>&gt;&gt; <br>&gt;&gt;&gt; - It might be worth considering this in the context of the &quot;type-safe selectors&quot; idea that was floating around a while back.<br>&gt;&gt; <br>&gt;&gt; Yes, I should have referenced that. Apologies!<br>&gt;&gt; <br>&gt;&gt;&gt; - Would it be valid to qualify a function with a subclass&#39;s name, when it&#39;s really only defined on the superclass? That is, would &quot;objc_selector(MyView.`frame.get`)&quot; work even if MyView doesn&#39;t override the `frame` property?<br>&gt;&gt; <br>&gt;&gt; Yes. MyView still has that property even if it doesn&#39;t override it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could see this last one as a potential source of user confusion, because naming a particular class wouldn&#39;t actually tell you which implementation gets called when performing the selector (that&#39;s just the nature of the Obj-C runtime).<br>&gt;&gt; <br>&gt;&gt; To some extent, that&#39;s the nature of overriding. But objective-c allows one to use a selector with an unrelated class, which can certainly be confusing. I feel like that comes from the runtime itself, and isn&#39;t something we can avoid with any syntax we pick. <br>&gt;&gt; <br>&gt;&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 26, 2015 at 11:48 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are many points of failure here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>&gt;&gt;&gt;&gt; 2) The compiler doesn’t look for existing methods with this selector anywhere<br>&gt;&gt;&gt;&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         extension MyApplication {<br>&gt;&gt;&gt;&gt;                 @objc(jumpUpAndDown:)<br>&gt;&gt;&gt;&gt;                 func doSomething(sender: AnyObject?) { … }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>&gt;&gt;&gt;&gt;         let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/50d9f870/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>+1 for that. Closures are much more swift-y than selectors (and honestly,<br>even in Objective-C, selectors are a pain to use). This would definitely be<br>nice, although I&#39;m not quite sure if it&#39;s possible with reasonable effort.<br>Selectors are very, very different beasts.<br></p><p>On Wed, Dec 30, 2015 at 10:56 AM, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What if selectors arguments could be imported into swift to take a closure<br>&gt; instead ?<br>&gt;<br>&gt; This would fit into the proposal to rewrite the imported objective c Apis<br>&gt;<br>&gt; So<br>&gt;<br>&gt; - addAction:(Selector)action<br>&gt;<br>&gt; Becomes<br>&gt;<br>&gt; addAction(action:(AnyObject)-&gt;Void)<br>&gt;<br>&gt; Instead of<br>&gt;<br>&gt; addAction(action:String)<br>&gt;<br>&gt; Like it does now.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 29 Dec 2015, at 21:46, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 29, 2015, at 12:19 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Dec 27, 2015, at 12:07 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; This is a neat idea. Here are some of my thoughts after initial<br>&gt; readthrough:<br>&gt;<br>&gt; - For symmetry with Obj-C code, how about using &quot;@selector&quot;, such as<br>&gt; @selector(UIView.`insertSubview(_:at:)`) ?<br>&gt;<br>&gt;<br>&gt; @ means at-tribute in Swift, whereas this is a specific expression.<br>&gt;<br>&gt; - Or, why bother with a new expression? Could the compiler just do this<br>&gt; automatically when it encounters an @objc function being passed as a<br>&gt; Selector? So, you&#39;d simply be able to say &quot;let sel1: Selector =<br>&gt; UIView.`frame.get`&quot;<br>&gt;<br>&gt;<br>&gt; It could, but I don&#39;t think it should: the operation is not common enough<br>&gt; that making it implicit would reduce overall syntactic noise, and it would<br>&gt; introduce ambiguities between selector- and closure-based APIs.<br>&gt;<br>&gt;<br>&gt; Maybe we can make constructor-like &quot;Selector(Class.method)&quot; syntax work<br>&gt; (and &quot;Selector(getterFor:/setterFor: Class.property)&quot; for property<br>&gt; accessors) instead of introducing a new magic function name.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; - Should the migrator offer to convert string-constant selectors to this<br>&gt; form?<br>&gt;<br>&gt;<br>&gt; Yes, absolutely.<br>&gt;<br>&gt; - It might be worth considering this in the context of the &quot;type-safe<br>&gt; selectors&quot; idea that was floating around a while back.<br>&gt;<br>&gt;<br>&gt; Yes, I should have referenced that. Apologies!<br>&gt;<br>&gt; - Would it be valid to qualify a function with a subclass&#39;s name, when<br>&gt; it&#39;s really only defined on the superclass? That is, would<br>&gt; &quot;objc_selector(MyView.`frame.get`)&quot; work even if MyView doesn&#39;t override<br>&gt; the `frame` property?<br>&gt;<br>&gt;<br>&gt; Yes. MyView still has that property even if it doesn&#39;t override it.<br>&gt;<br>&gt;<br>&gt; I could see this last one as a potential source of user confusion, because<br>&gt; naming a particular class wouldn&#39;t actually tell you which implementation<br>&gt; gets called when performing the selector (that&#39;s just the nature of the<br>&gt; Obj-C runtime).<br>&gt;<br>&gt;<br>&gt; To some extent, that&#39;s the nature of overriding. But objective-c allows<br>&gt; one to use a selector with an unrelated class, which can certainly be<br>&gt; confusing. I feel like that comes from the runtime itself, and isn&#39;t<br>&gt; something we can avoid with any syntax we pick.<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Sat, Dec 26, 2015 at 11:48 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; Currently, producing an Objective-C selector in Swift is an error-prone<br>&gt;&gt; operation. One effectively just writes a string literal and uses it in a<br>&gt;&gt; context where an ObjectiveC.Selector is expected:<br>&gt;&gt;<br>&gt;&gt;         control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt;&gt;<br>&gt;&gt; There are many points of failure here:<br>&gt;&gt;<br>&gt;&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid<br>&gt;&gt; spelling for a selector<br>&gt;&gt; 2) The compiler doesn’t look for existing methods with this selector<br>&gt;&gt; anywhere<br>&gt;&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t<br>&gt;&gt; always immediately obvious (especially for initializers), and will be<br>&gt;&gt; getting significantly more complicated with the renaming work for Swift 3 (<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt; ).<br>&gt;&gt;<br>&gt;&gt; I suggest that we add an expression ‘objc_selector(method-reference)`<br>&gt;&gt; that produces the Objective-C selector for the named method, and produces<br>&gt;&gt; an error if the method does not have an Objective-C entry point. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt;         control.sendAction(objc_selector(MyApplication.doSomething), to:<br>&gt;&gt; target, forEvent: event)<br>&gt;&gt;<br>&gt;&gt; “doSomething” is a method of MyApplication, which might even have a<br>&gt;&gt; completely-unrelated name in Objective-C:<br>&gt;&gt;<br>&gt;&gt;         extension MyApplication {<br>&gt;&gt;                 @objc(jumpUpAndDown:)<br>&gt;&gt;                 func doSomething(sender: AnyObject?) { … }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; By naming the Swift method and having objc_selector do the work to form<br>&gt;&gt; the Objective-C selector, we free the programming from having to do the<br>&gt;&gt; naming translation manually and get static checking that the method exists<br>&gt;&gt; and is exposed to Objective-C.<br>&gt;&gt;<br>&gt;&gt; This proposal composes with my “Generalized Naming for Any Function”<br>&gt;&gt; proposal, which lets us name methods fully, including getters/setters:<br>&gt;&gt;<br>&gt;&gt;         let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`)<br>&gt;&gt; // produces the Selector “insertSubview:atIndex:&quot;<br>&gt;&gt;         let sel2: Selector = objc_selector(UIView.`frame.get`) //<br>&gt;&gt; produces the Selector “frame&quot;<br>&gt;&gt;<br>&gt;&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think<br>&gt;&gt; this functionality is straightforward.<br>&gt;&gt;<br>&gt;&gt;         - Doug<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Author of the Sparkling language<br>http://h2co3.org/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/ec6f6b39/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 30, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; What if selectors arguments could be imported into swift to take a closure instead ? <br>&gt; <br>&gt; This would fit into the proposal to rewrite the imported objective c Apis <br>&gt; <br>&gt; So <br>&gt; <br>&gt; - addAction:(Selector)action<br>&gt; <br>&gt; Becomes<br>&gt; <br>&gt; addAction(action:(AnyObject)-&gt;Void)<br>&gt; <br>&gt; Instead of<br>&gt; <br>&gt; addAction(action:String) <br>&gt; <br>&gt; Like it does now.<br></p><p>Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br></p><p>Three questions about your proposal:<br></p><p>1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and <br></p><p>2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br></p><p>3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>These are very good points. <br>&gt; <br>&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br></p><p>Yes :) should have looked it up before I tried to remember it off the top of my head.<br></p><p>&gt; <br>&gt; Three questions about your proposal:<br>&gt; <br>&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and <br></p><p>Well I would want to know what selectors people would us:<br></p><p>One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br></p><p>Others with more tend to be for canPerformSelector which is replaced by optionals.<br></p><p>The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br></p><p>&gt; <br>&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt; <br></p><p>I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br></p><p>But this would be irrelevant if we moved towards closure Apis.<br></p><p>&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br></p><p>I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br></p><p>To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br></p><p>I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 11:00:00am</p></header><div class="content"><p>In the performSelector and nsinvocation case.<br></p><p>Are people using it for existing functions in which case type safety is important.<br></p><p>But if it&#39;s for dynamic calling of a method ( for example for a visitor pattern) then I don&#39;t think there is any safety that can easily be applied via a special syntax and if it can it would be done another way. <br></p><p>I think in most cases the selector has been replaced in swift.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 11:21, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; <br>&gt; These are very good points. <br>&gt;&gt; <br>&gt;&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br>&gt; <br>&gt; Yes :) should have looked it up before I tried to remember it off the top of my head.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Three questions about your proposal:<br>&gt;&gt; <br>&gt;&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and<br>&gt; <br>&gt; Well I would want to know what selectors people would us:<br>&gt; <br>&gt; One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br>&gt; <br>&gt; Others with more tend to be for canPerformSelector which is replaced by optionals.<br>&gt; <br>&gt; The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt; <br>&gt; I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br>&gt; <br>&gt; But this would be irrelevant if we moved towards closure Apis.<br>&gt; <br>&gt;&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br>&gt; <br>&gt; I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br>&gt; <br>&gt; To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br>&gt; <br>&gt; I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Le 30 déc. 2015 à 12:21, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; These are very good points. <br>&gt;&gt; <br>&gt;&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br>&gt; <br>&gt; Yes :) should have looked it up before I tried to remember it off the top of my head.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Three questions about your proposal:<br>&gt;&gt; <br>&gt;&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and <br>&gt; <br>&gt; Well I would want to know what selectors people would us:<br>&gt; <br>&gt; One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br>&gt; <br>&gt; Others with more tend to be for canPerformSelector which is replaced by optionals.<br>&gt; <br>&gt; The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt;&gt; <br>&gt; <br>&gt; I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br>&gt; <br>&gt; But this would be irrelevant if we moved towards closure Apis.<br>&gt; <br>&gt;&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br>&gt; <br>&gt; I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br>&gt; <br>&gt; To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br>&gt; <br>&gt; I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br></p><p>How would the closure based API work with Interface Builder ?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>Ah good point, in swift you can return a function as a closure (see that link) so interface builder could bind an action. Like so :<br></p><p>addAction(myClass.actionFunction)<br></p><p>Instead of what it does now:<br></p><p>addAction(myClass, action:&quot;actionFunction:&quot;)<br></p><p><br>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 14:14, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 30 déc. 2015 à 12:21, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; These are very good points. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br>&gt;&gt; <br>&gt;&gt; Yes :) should have looked it up before I tried to remember it off the top of my head.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Three questions about your proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and<br>&gt;&gt; <br>&gt;&gt; Well I would want to know what selectors people would us:<br>&gt;&gt; <br>&gt;&gt; One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br>&gt;&gt; <br>&gt;&gt; Others with more tend to be for canPerformSelector which is replaced by optionals.<br>&gt;&gt; <br>&gt;&gt; The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt;&gt; <br>&gt;&gt; I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br>&gt;&gt; <br>&gt;&gt; But this would be irrelevant if we moved towards closure Apis.<br>&gt;&gt; <br>&gt;&gt;&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br>&gt;&gt; <br>&gt;&gt; I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br>&gt;&gt; <br>&gt;&gt; To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br>&gt;&gt; <br>&gt;&gt; I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br>&gt; <br>&gt; How would the closure based API work with Interface Builder ? <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>How do you import the API to Swift when the target and action properties are separate? <br></p><p>Félix<br></p><p>&gt; Le 30 déc. 2015 à 09:36:24, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Ah good point, in swift you can return a function as a closure (see that link) so interface builder could bind an action. Like so :<br>&gt; <br>&gt; addAction(myClass.actionFunction)<br>&gt; <br>&gt; Instead of what it does now:<br>&gt; <br>&gt; addAction(myClass, action:&quot;actionFunction:&quot;)<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 30 Dec 2015, at 14:14, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 30 déc. 2015 à 12:21, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These are very good points. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes :) should have looked it up before I tried to remember it off the top of my head.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Three questions about your proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well I would want to know what selectors people would us:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Others with more tend to be for canPerformSelector which is replaced by optionals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But this would be irrelevant if we moved towards closure Apis.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br>&gt;&gt; <br>&gt;&gt; How would the closure based API work with Interface Builder ? <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>Do you have an example of use ?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 15:48, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; How do you import the API to Swift when the target and action properties are separate? <br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 déc. 2015 à 09:36:24, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Ah good point, in swift you can return a function as a closure (see that link) so interface builder could bind an action. Like so :<br>&gt;&gt; <br>&gt;&gt; addAction(myClass.actionFunction)<br>&gt;&gt; <br>&gt;&gt; Instead of what it does now:<br>&gt;&gt; <br>&gt;&gt; addAction(myClass, action:&quot;actionFunction:&quot;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Dec 2015, at 14:14, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 30 déc. 2015 à 12:21, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These are very good points. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes :) should have looked it up before I tried to remember it off the top of my head.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Three questions about your proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well I would want to know what selectors people would us:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Others with more tend to be for canPerformSelector which is replaced by optionals.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But this would be irrelevant if we moved towards closure Apis.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How would the closure based API work with Interface Builder ?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>NSControl and subclasses have an action property and a target property but no method to set both at once (in opposition to, say, NSTimer, which has methods that accept a target and a selector at the same time).<br></p><p>Félix<br></p><p>&gt; Le 30 déc. 2015 à 11:52:41, James Campbell &lt;james at supmenow.com&gt; a écrit :<br>&gt; <br>&gt; Do you have an example of use ?<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 30 Dec 2015, at 15:48, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How do you import the API to Swift when the target and action properties are separate? <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 30 déc. 2015 à 09:36:24, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah good point, in swift you can return a function as a closure (see that link) so interface builder could bind an action. Like so :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; addAction(myClass.actionFunction)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of what it does now:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; addAction(myClass, action:&quot;actionFunction:&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Dec 2015, at 14:14, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 30 déc. 2015 à 12:21, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These are very good points. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Actually, it comes in as addAction(action: Selector), not String. You can initialize a Selector from a string literal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes :) should have looked it up before I tried to remember it off the top of my head.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Three questions about your proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Where does &quot;AnyObject -&gt; Void&quot; come from? The only signature information in a selector is the (minimum) number of arguments. Those arguments can be of any type, and<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well I would want to know what selectors people would us:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One with one argument tend to be for events like button actions and notifications which could be replaced by closures. We could deprecate or provide warnings when trying to use the Selector Apis in swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Others with more tend to be for canPerformSelector which is replaced by optionals.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The one edge case not handled is nsinvocation or performSelector, I would be interested why people use this use case and how we would replace it in swift (if at all).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. How are we supposed to implement this? You need to somehow convert a closure (a pointer to a bunch of captured variables with a pointer to a function embedded inside it) into a selector (a pointer to a table of selectors inside the Objective-C runtime, which does not do any normal memory management); I just don&#39;t see how you make that work. Saying &quot;let&#39;s do this thing&quot; doesn&#39;t mean it&#39;s *possible* to do the thing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I get that they are different but I had the idea that the compiler could generate a unique name for each closure which when referenced by a selector it would invoke.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But this would be irrelevant if we moved towards closure Apis.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. What about other uses for selectors? addAction() is all well and good, but you also need removeAction(), and Swift closures don&#39;t have stable identities to test with.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I question when we use things such as removeAction? I&#39;ve only used addAction. But I guess again if we moved to closure Apis this point would be moot.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To me the only case that needs selectors is performSelector or Nsinvocation. The others can be replaced by closures and the selector api to be deprecated or to show a warning in swift :) (Xcode could even help migrate by moving it to a closure that calls the function the selector was pointing to)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not a compiler expert so I rely on the swift team to tell me what&#39;s possible (although at this early stage I think it&#39;s more important to figure out what we want and not be bound by what&#39;s possible right now)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How would the closure based API work with Interface Builder ?<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; Ah good point, in swift you can return a function as a closure (see that link) so interface builder could bind an action.<br>afaics this cannot work when myClass is nil:<br>The transponder chain might be invisible on iOS, but for OS X, it is vital.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not as familiar with OS X but why is it vital there ? <br></p><p>Also for Linux this api is unneeded since there is no access to objective c <br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 16:06, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Ah good point, in swift you can return a function as a closure (see that link) so interface builder could bind an action.<br>&gt; afaics this cannot work when myClass is nil:<br>&gt; The transponder chain might be invisible on iOS, but for OS X, it is vital.<br>&gt; <br>&gt; Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 30, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; I&#39;m not as familiar with OS X but why is it vital there ? <br></p><p>&gt; Do you have an example of use ?<br></p><p>If those questions are for me ;-):<br>Afair (have to do iOS most of the time now), &quot;Undo&quot; is the most prominent example. You don&#39;t link those menu entries to a concrete object, but rather say &quot;bind this to a selector whose name is…&quot;, and then the system can determine the actual target (there may be many controls which support undo).<br>Additionally, before this can happen, the system has to determine wether an entry is enabled at all — you can&#39;t do this when you have only a simple closure.<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 31, 2015 at 01:00:00am</p></header><div class="content"><p>Good point. Not sure if that&#39;s replaceable via a protocol or if that Api is just not suited for swift. <br></p><p>There is a proposal somewhere to be able to reference swift methods via back ticks a sort of selector for swift so maybe in this case we would use that.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 20:27, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I&#39;m not as familiar with OS X but why is it vital there ?<br>&gt; <br>&gt;&gt; Do you have an example of use ?<br>&gt; <br>&gt; If those questions are for me ;-):<br>&gt; Afair (have to do iOS most of the time now), &quot;Undo&quot; is the most prominent example. You don&#39;t link those menu entries to a concrete object, but rather say &quot;bind this to a selector whose name is…&quot;, and then the system can determine the actual target (there may be many controls which support undo).<br>&gt; Additionally, before this can happen, the system has to determine wether an entry is enabled at all — you can&#39;t do this when you have only a simple closure.<br>&gt; <br>&gt; Best regards,<br>&gt; Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  1, 2016 at 10:00:00pm</p></header><div class="content"><p>This is a relevant article https://www.mikeash.com/pyblog/friday-qa-2015-12-25-swifty-targetaction.html?utm_campaign=iOS%2BDev%2BWeekly&amp;utm_medium=email&amp;utm_source=iOS_Dev_Weekly_Issue_231<br></p><p>For this topic<br></p><p>Sent from my iPhone<br></p><p>&gt; On 31 Dec 2015, at 01:33, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; <br>&gt; Good point. Not sure if that&#39;s replaceable via a protocol or if that Api is just not suited for swift. <br>&gt; <br>&gt; There is a proposal somewhere to be able to reference swift methods via back ticks a sort of selector for swift so maybe in this case we would use that.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 30 Dec 2015, at 20:27, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not as familiar with OS X but why is it vital there ?<br>&gt;&gt; <br>&gt;&gt;&gt; Do you have an example of use ?<br>&gt;&gt; <br>&gt;&gt; If those questions are for me ;-):<br>&gt;&gt; Afair (have to do iOS most of the time now), &quot;Undo&quot; is the most prominent example. You don&#39;t link those menu entries to a concrete object, but rather say &quot;bind this to a selector whose name is…&quot;, and then the system can determine the actual target (there may be many controls which support undo).<br>&gt;&gt; Additionally, before this can happen, the system has to determine wether an entry is enabled at all — you can&#39;t do this when you have only a simple closure.<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Tino<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>December 27, 2015 at 12:00:00pm</p></header><div class="content"><p>Great idea, but why make it a free function instead of a Selector<br>initializer?<br></p><p>    let sel1 = Selector(UIView.`insertSubview(_:at:)`)<br>    let sel2 = Selector(UIView.`frame.get`)<br></p><p>Of course if there were such a thing as<br>GeneralizedFunctionNameLiteralConvertible, we could get a “free” conversion<br>to Selector:<br></p><p>    control.sendAction(MyTarget.`doSomething(_:)`, to: target, forEvent:<br>event)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/ca99bff5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 27, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 26, 2015, at 11:48 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br>&gt; <br>&gt; 	control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt; <br>&gt; There are many points of failure here:<br>&gt; <br>&gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>&gt; 2) The compiler doesn’t look for existing methods with this selector anywhere<br>&gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md).<br>&gt; <br>&gt; I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br>&gt; <br>&gt; 	control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt; <br>&gt; “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt; <br>&gt; 	extension MyApplication {<br>&gt; 		@objc(jumpUpAndDown:)<br>&gt; 		func doSomething(sender: AnyObject?) { … }<br>&gt; 	}<br>&gt; <br>&gt; By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt; <br>&gt; This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br>&gt; <br>&gt; 	let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>&gt; 	let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br>&gt; <br>&gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br></p><p>Selectors can be seen as &quot;just&quot; a kind of function value. Do we need a new syntax form at all? We ought to be able to turn an unbound function reference like UIView.insertSubview into a selector reference in Selector type context, or maybe a typed @convention(selector) function as discussed in another thread, without any explicit get-a-selector operation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 27, 2015 at 08:00:00pm</p></header><div class="content"><p>I would add to what Joe mentioned above the fact that the concept of<br>&quot;selector&quot; may not mean a whole lot to developers who are first introduced<br>to Swift without any prior Obj-C or Cocoa experience. Thinking of them as<br>functions I believe avoids introducing complexity in the form of additional<br>concepts that one must understand and differentiate (&quot;what&#39;s a selector and<br>why/how is it different from a function value?&quot;)<br>On Sun, Dec 27, 2015 at 10:07 AM Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 26, 2015, at 11:48 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; Currently, producing an Objective-C selector in Swift is an error-prone<br>&gt; operation. One effectively just writes a string literal and uses it in a<br>&gt; context where an ObjectiveC.Selector is expected:<br>&gt; &gt;<br>&gt; &gt;       control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt; &gt;<br>&gt; &gt; There are many points of failure here:<br>&gt; &gt;<br>&gt; &gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid<br>&gt; spelling for a selector<br>&gt; &gt; 2) The compiler doesn’t look for existing methods with this selector<br>&gt; anywhere<br>&gt; &gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t<br>&gt; always immediately obvious (especially for initializers), and will be<br>&gt; getting significantly more complicated with the renaming work for Swift 3 (<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt; ).<br>&gt; &gt;<br>&gt; &gt; I suggest that we add an expression ‘objc_selector(method-reference)`<br>&gt; that produces the Objective-C selector for the named method, and produces<br>&gt; an error if the method does not have an Objective-C entry point. For<br>&gt; example:<br>&gt; &gt;<br>&gt; &gt;       control.sendAction(objc_selector(MyApplication.doSomething), to:<br>&gt; target, forEvent: event)<br>&gt; &gt;<br>&gt; &gt; “doSomething” is a method of MyApplication, which might even have a<br>&gt; completely-unrelated name in Objective-C:<br>&gt; &gt;<br>&gt; &gt;       extension MyApplication {<br>&gt; &gt;               @objc(jumpUpAndDown:)<br>&gt; &gt;               func doSomething(sender: AnyObject?) { … }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; By naming the Swift method and having objc_selector do the work to form<br>&gt; the Objective-C selector, we free the programming from having to do the<br>&gt; naming translation manually and get static checking that the method exists<br>&gt; and is exposed to Objective-C.<br>&gt; &gt;<br>&gt; &gt; This proposal composes with my “Generalized Naming for Any Function”<br>&gt; proposal, which lets us name methods fully, including getters/setters:<br>&gt; &gt;<br>&gt; &gt;       let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`)<br>&gt; // produces the Selector “insertSubview:atIndex:&quot;<br>&gt; &gt;       let sel2: Selector = objc_selector(UIView.`frame.get`) // produces<br>&gt; the Selector “frame&quot;<br>&gt; &gt;<br>&gt; &gt; I don’t like the `objc_selector` syntax at all, but otherwise I think<br>&gt; this functionality is straightforward.<br>&gt;<br>&gt; Selectors can be seen as &quot;just&quot; a kind of function value. Do we need a new<br>&gt; syntax form at all? We ought to be able to turn an unbound function<br>&gt; reference like UIView.insertSubview into a selector reference in Selector<br>&gt; type context, or maybe a typed @convention(selector) function as discussed<br>&gt; in another thread, without any explicit get-a-selector operation.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/70b5a05c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>Would it be possible to add properties to closures/method objects?<br></p><p>Right now, it&#39;s possible to write:<br></p><p>&gt; @objc<br>&gt; class Foo : NSObject {<br>&gt; 	func doSomething(value: Int) -&gt; Int {<br>&gt; 		return value + 1<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; let method = Foo.doSomething<br></p><p>Maybe we could have Foo.doSomething.selector for @objc methods?<br></p><p>Félix<br></p><p>&gt; Le 27 déc. 2015 à 15:55:31, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I would add to what Joe mentioned above the fact that the concept of &quot;selector&quot; may not mean a whole lot to developers who are first introduced to Swift without any prior Obj-C or Cocoa experience. Thinking of them as functions I believe avoids introducing complexity in the form of additional concepts that one must understand and differentiate (&quot;what&#39;s a selector and why/how is it different from a function value?&quot;)<br>&gt; On Sun, Dec 27, 2015 at 10:07 AM Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 26, 2015, at 11:48 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; Currently, producing an Objective-C selector in Swift is an error-prone operation. One effectively just writes a string literal and uses it in a context where an ObjectiveC.Selector is expected:<br>&gt; &gt;<br>&gt; &gt;       control.sendAction(“doSomething:”, to: target, forEvent: event)<br>&gt; &gt;<br>&gt; &gt; There are many points of failure here:<br>&gt; &gt;<br>&gt; &gt; 1) The compiler doesn’t syntax-check at all to make sure it’s a valid spelling for a selector<br>&gt; &gt; 2) The compiler doesn’t look for existing methods with this selector anywhere<br>&gt; &gt; 3) The mapping from a Swift method name to an Objective-C selector isn’t always immediately obvious (especially for initializers), and will be getting significantly more complicated with the renaming work for Swift 3 (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;).<br>&gt; &gt;<br>&gt; &gt; I suggest that we add an expression ‘objc_selector(method-reference)` that produces the Objective-C selector for the named method, and produces an error if the method does not have an Objective-C entry point. For example:<br>&gt; &gt;<br>&gt; &gt;       control.sendAction(objc_selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt; &gt;<br>&gt; &gt; “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt; &gt;<br>&gt; &gt;       extension MyApplication {<br>&gt; &gt;               @objc(jumpUpAndDown:)<br>&gt; &gt;               func doSomething(sender: AnyObject?) { … }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; By naming the Swift method and having objc_selector do the work to form the Objective-C selector, we free the programming from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt; &gt;<br>&gt; &gt; This proposal composes with my “Generalized Naming for Any Function” proposal, which lets us name methods fully, including getters/setters:<br>&gt; &gt;<br>&gt; &gt;       let sel1: Selector = objc_selector(UIView.`insertSubview(_:at:)`) // produces the Selector “insertSubview:atIndex:&quot;<br>&gt; &gt;       let sel2: Selector = objc_selector(UIView.`frame.get`) // produces the Selector “frame&quot;<br>&gt; &gt;<br>&gt; &gt; I don’t like the `objc_selector` syntax at all, but otherwise I think this functionality is straightforward.<br>&gt; <br>&gt; Selectors can be seen as &quot;just&quot; a kind of function value. Do we need a new syntax form at all? We ought to be able to turn an unbound function reference like UIView.insertSubview into a selector reference in Selector type context, or maybe a typed @convention(selector) function as discussed in another thread, without any explicit get-a-selector operation.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/36bbdd7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 10:46 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Would it be possible to add properties to closures/method objects?<br>&gt; <br>&gt; Right now, it&#39;s possible to write:<br>&gt; <br>&gt;&gt; @objc<br>&gt;&gt; class Foo : NSObject {<br>&gt;&gt; 	func doSomething(value: Int) -&gt; Int {<br>&gt;&gt; 		return value + 1<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let method = Foo.doSomething<br>&gt; <br>&gt; Maybe we could have Foo.doSomething.selector for @objc methods?<br></p><p>Once you have a normal function value, it&#39;s not guaranteed you can recover any identity from it, since an arbitrary T -&gt; U doesn&#39;t necessarily correspond to an @objc method. I&#39;m proposing we do this by type context, similar to how we form C function pointers and blocks. Just like you can do:<br></p><p>let fptr: @convention(c) (Double) -&gt; Double = sqrt<br></p><p>to get the function pointer for `sqrt`, you could say:<br></p><p>let sel: Selector = Foo.doSomething<br></p><p>to get the selector for `doSomething`.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/cfa1cc2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 28, 2015 at 02:00:00pm</p></header><div class="content"><p>I really only was talking about the case where the compiler knows that it&#39;s an @objc method (with the understanding that the information is lost as soon as you make an unattributed T -&gt; U closure out of it).<br></p><p>Either syntax would make me happy.<br></p><p>Félix<br></p><p>&gt; Le 28 déc. 2015 à 13:49:22, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 10:46 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it be possible to add properties to closures/method objects?<br>&gt;&gt; <br>&gt;&gt; Right now, it&#39;s possible to write:<br>&gt;&gt; <br>&gt;&gt;&gt; @objc<br>&gt;&gt;&gt; class Foo : NSObject {<br>&gt;&gt;&gt; 	func doSomething(value: Int) -&gt; Int {<br>&gt;&gt;&gt; 		return value + 1<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let method = Foo.doSomething<br>&gt;&gt; <br>&gt;&gt; Maybe we could have Foo.doSomething.selector for @objc methods?<br>&gt; <br>&gt; Once you have a normal function value, it&#39;s not guaranteed you can recover any identity from it, since an arbitrary T -&gt; U doesn&#39;t necessarily correspond to an @objc method. I&#39;m proposing we do this by type context, similar to how we form C function pointers and blocks. Just like you can do:<br>&gt; <br>&gt; let fptr: @convention(c) (Double) -&gt; Double = sqrt<br>&gt; <br>&gt; to get the function pointer for `sqrt`, you could say:<br>&gt; <br>&gt; let sel: Selector = Foo.doSomething<br>&gt; <br>&gt; to get the selector for `doSomething`.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/24346a5b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>January  6, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree, we don’t need anything special for this. Let a function reference decay into a selector where appropriate.<br></p><p>For that matter I want properties and subscripts to decay into getter/setter function references in contextually appropriate places as well, but haven’t proposed it yet.<br></p><p><br>—russ<br></p><p>&gt; On Dec 27, 2015, at 10:07 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt; Selectors can be seen as &quot;just&quot; a kind of function value. Do we need a new syntax form at all? We ought to be able to turn an unbound function reference like UIView.insertSubview into a selector reference in Selector type context, or maybe a typed @convention(selector) function as discussed in another thread, without any explicit get-a-selector operation.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/3b532e94/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 30, 2015 at 07:00:00am</p></header><div class="content"><p>For reference, I&#39;ll just point out that there was an interesting discussion about this topic at the beginning of December.<br>https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Idea] Expression to retrieve the Objective-C selector of a method</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>Totally agree with that proposal, I think we should do that as a temporary step but also look to reduce the need for selectors in favour of closures.<br></p><p>As I think a lot of the behaviour of selectors <br>Could be replicated by existing swift features. <br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 12:54, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For reference, I&#39;ll just point out that there was an interesting discussion about this topic at the beginning of December.<br>&gt; https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html<br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
