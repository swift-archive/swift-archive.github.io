<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>These are the definitions of the right shift operators<br></p><p>	public func &gt;&gt;(lhs: Int8, rhs: Int8) -&gt; Int8<br></p><p>	public func &gt;&gt;(lhs: Int, rhs: Int) -&gt; Int<br></p><p>	public func &gt;&gt;(lhs: UInt, rhs: UInt) -&gt; UInt<br></p><p>	public func &gt;&gt;(lhs: Int64, rhs: Int64) -&gt; Int64<br></p><p>	public func &gt;&gt;(lhs: UInt64, rhs: UInt64) -&gt; UInt64<br></p><p>	public func &gt;&gt;(lhs: UInt8, rhs: UInt8) -&gt; UInt8<br></p><p>	public func &gt;&gt;(lhs: UInt16, rhs: UInt16) -&gt; UInt16<br></p><p>	public func &gt;&gt;(lhs: Int16, rhs: Int16) -&gt; Int16<br></p><p>	public func &gt;&gt;(lhs: Int32, rhs: Int32) -&gt; Int32<br></p><p>	public func &gt;&gt;(lhs: UInt32, rhs: UInt32) -&gt; UInt32<br></p><p><br>Note that both left and right hand side are of the same type. In my opinion, rhs, which represents the number of bits to shift, should always be an Int e.g.<br></p><p>	public func &gt;&gt;(lhs: UInt64, rhs: Int) -&gt; UInt64<br></p><p>The two operands are fundamentally different, the left hand one is conceptually an array of bits and the right hand one is conceptually a count. <br></p><p>The current definitions mean that I almost always have to do a cast on the right operand with shift operations. e.g. the following snippet that converts a UInt64 into an array of boolean values.<br></p><p>    let aNumber: UInt64 = 0x123456<br>    var numberAsBits: [Bool] = [];<br>    for i in 0 ..&lt; 64<br>    {<br>        numberAsBits.append((aNumber &gt;&gt; i) &amp; 1 != 0); // Error because i needs to be cast to a UInt64<br>    }<br></p><p>I would like additional versions of the shift operator where rhs is an Int please.<br></p><p>Needless to say, the same applies to the left shift operators.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>I agree with you. The proposal probably needs to be considered before the ABI freeze.<br></p><p>&gt; Le 18 déc. 2015 à 06:55:38, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; These are the definitions of the right shift operators<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int8, rhs: Int8) -&gt; Int8<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int, rhs: Int) -&gt; Int<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt, rhs: UInt) -&gt; UInt<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int64, rhs: Int64) -&gt; Int64<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt64, rhs: UInt64) -&gt; UInt64<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt8, rhs: UInt8) -&gt; UInt8<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt16, rhs: UInt16) -&gt; UInt16<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int16, rhs: Int16) -&gt; Int16<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int32, rhs: Int32) -&gt; Int32<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt32, rhs: UInt32) -&gt; UInt32<br>&gt; <br>&gt; <br>&gt; Note that both left and right hand side are of the same type. In my opinion, rhs, which represents the number of bits to shift, should always be an Int e.g.<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt64, rhs: Int) -&gt; UInt64<br>&gt; <br>&gt; The two operands are fundamentally different, the left hand one is conceptually an array of bits and the right hand one is conceptually a count. <br>&gt; <br>&gt; The current definitions mean that I almost always have to do a cast on the right operand with shift operations. e.g. the following snippet that converts a UInt64 into an array of boolean values.<br>&gt; <br>&gt;    let aNumber: UInt64 = 0x123456<br>&gt;    var numberAsBits: [Bool] = [];<br>&gt;    for i in 0 ..&lt; 64<br>&gt;    {<br>&gt;        numberAsBits.append((aNumber &gt;&gt; i) &amp; 1 != 0); // Error because i needs to be cast to a UInt64<br>&gt;    }<br>&gt; <br>&gt; I would like additional versions of the shift operator where rhs is an Int please.<br>&gt; <br>&gt; Needless to say, the same applies to the left shift operators.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 18, 2015 at 08:00:00am</p></header><div class="content"><p>+1. In fact, I would go even farther than asking for an additional version that uses Int on the rhs, I think all of the existing definitions are arguably wrong and they should all just be changed to use Int. I just took a brief scan of all uses of &gt;&gt; and &lt;&lt; in the stdlib: most use constants on the rhs, and so would be unaffected. It looks like all the rest either use Int on the lhs or require explicit casting or calling numericCast() to get the rhs to match. <br></p><p>	- Greg<br></p><p>&gt; On Dec 18, 2015, at 3:55 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; These are the definitions of the right shift operators<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int8, rhs: Int8) -&gt; Int8<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int, rhs: Int) -&gt; Int<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt, rhs: UInt) -&gt; UInt<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int64, rhs: Int64) -&gt; Int64<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt64, rhs: UInt64) -&gt; UInt64<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt8, rhs: UInt8) -&gt; UInt8<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt16, rhs: UInt16) -&gt; UInt16<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int16, rhs: Int16) -&gt; Int16<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: Int32, rhs: Int32) -&gt; Int32<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt32, rhs: UInt32) -&gt; UInt32<br>&gt; <br>&gt; <br>&gt; Note that both left and right hand side are of the same type. In my opinion, rhs, which represents the number of bits to shift, should always be an Int e.g.<br>&gt; <br>&gt; 	public func &gt;&gt;(lhs: UInt64, rhs: Int) -&gt; UInt64<br>&gt; <br>&gt; The two operands are fundamentally different, the left hand one is conceptually an array of bits and the right hand one is conceptually a count. <br>&gt; <br>&gt; The current definitions mean that I almost always have to do a cast on the right operand with shift operations. e.g. the following snippet that converts a UInt64 into an array of boolean values.<br>&gt; <br>&gt;    let aNumber: UInt64 = 0x123456<br>&gt;    var numberAsBits: [Bool] = [];<br>&gt;    for i in 0 ..&lt; 64<br>&gt;    {<br>&gt;        numberAsBits.append((aNumber &gt;&gt; i) &amp; 1 != 0); // Error because i needs to be cast to a UInt64<br>&gt;    }<br>&gt; <br>&gt; I would like additional versions of the shift operator where rhs is an Int please.<br>&gt; <br>&gt; Needless to say, the same applies to the left shift operators.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 20, 2015 at 12:00:00am</p></header><div class="content"><p>+1<br></p><p>Something worth considering with this proposal: Should it be IntMax rather<br>than Int? (or UIntMax, does a negative count make sense?).<br></p><p>Although it&#39;s probably never going to be enough if you want to calculate<br>the next largest known prime number in swift, the last was 2^57885161 − 1.<br></p><p>*Also if it&#39;s in scope:*<br></p><p>Left and right shift are the only operators on integers that aren&#39;t<br>generalised by a protocol. Every other operator is somehow part of<br>IntegerType.<br></p><p>See IntegerArithmeticType, SignedNumberType and BitwiseOperationsType.<br></p><p>It would be nice to create a new protocol for something that can shift. The<br>new protocol could be:<br></p><p>protocol IntegerBitShiftType {<br>    var sizeInBits: UIntMax<br></p><p>    @warn_unused_result<br></p><p>    func &lt;&lt;(lhs: Self, rhs: UIntMax) -&gt; Self<br></p><p><br>    @warn_unused_result<br></p><p>    func &gt;&gt;(lhs: Self, rhs: UIntMax) -&gt; Self<br>}<br></p><p><br>If IntegerType conformed to that protocol I don&#39;t think there&#39;s anything I<br>want that Int can do and IntegerType can&#39;t.<br></p><p>*A related but slightly off-topic gripe:*<br>Integer protocols in Standard Library define init(_: IntMax) or init(_:<br>UIntMax), they assume that there isn&#39;t a wider type. When trying to make a<br>new type conform to IntegerType (ie. a BigInt library) this can be an issue.<br></p><p>It also seems to be necessary that things implementing IntegerType must<br>conform to _MaxBuiltinIntegerType. It&#39;s type is much wider than IntMax (64x<br>for me) and its interface is empty which makes it hard to conform.<br></p><p>I think currently _MaxBuiltinIntegerType is 4096 bits, but it is still much<br>smaller than what you want from a BigInt type. While I have suggested using<br>IntMax in this implementation I think that IntMax is inherently flawed in<br>its usage. However it is the best available at the moment in my opinion.<br></p><p>Something like this may work in a more general case:<br></p><p>protocol IntegerBitShiftType {<br>    @warn_unused_result<br></p><p>    func &lt;&lt; &lt;T: UnsignedIntegerType&gt;(lhs: Self, rhs: T) -&gt; Self<br></p><p><br>    @warn_unused_result<br></p><p>    func &gt;&gt; &lt;T: UnsignedIntegerType&gt;(lhs: Self, rhs: T) -&gt; Self<br>}<br></p><p><br>On Sat, Dec 19, 2015 at 3:02 AM, Greg Titus via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1. In fact, I would go even farther than asking for an additional version<br>&gt; that uses Int on the rhs, I think all of the existing definitions are<br>&gt; arguably wrong and they should all just be changed to use Int. I just took<br>&gt; a brief scan of all uses of &gt;&gt; and &lt;&lt; in the stdlib: most use constants on<br>&gt; the rhs, and so would be unaffected. It looks like all the rest either use<br>&gt; Int on the lhs or require explicit casting or calling numericCast() to get<br>&gt; the rhs to match.<br>&gt;<br>&gt;         - Greg<br>&gt;<br>&gt; &gt; On Dec 18, 2015, at 3:55 AM, Jeremy Pereira via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; These are the definitions of the right shift operators<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int8, rhs: Int8) -&gt; Int8<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int, rhs: Int) -&gt; Int<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt, rhs: UInt) -&gt; UInt<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int64, rhs: Int64) -&gt; Int64<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt64, rhs: UInt64) -&gt; UInt64<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt8, rhs: UInt8) -&gt; UInt8<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt16, rhs: UInt16) -&gt; UInt16<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int16, rhs: Int16) -&gt; Int16<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int32, rhs: Int32) -&gt; Int32<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt32, rhs: UInt32) -&gt; UInt32<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Note that both left and right hand side are of the same type. In my<br>&gt; opinion, rhs, which represents the number of bits to shift, should always<br>&gt; be an Int e.g.<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt64, rhs: Int) -&gt; UInt64<br>&gt; &gt;<br>&gt; &gt; The two operands are fundamentally different, the left hand one is<br>&gt; conceptually an array of bits and the right hand one is conceptually a<br>&gt; count.<br>&gt; &gt;<br>&gt; &gt; The current definitions mean that I almost always have to do a cast on<br>&gt; the right operand with shift operations. e.g. the following snippet that<br>&gt; converts a UInt64 into an array of boolean values.<br>&gt; &gt;<br>&gt; &gt;    let aNumber: UInt64 = 0x123456<br>&gt; &gt;    var numberAsBits: [Bool] = [];<br>&gt; &gt;    for i in 0 ..&lt; 64<br>&gt; &gt;    {<br>&gt; &gt;        numberAsBits.append((aNumber &gt;&gt; i) &amp; 1 != 0); // Error because i<br>&gt; needs to be cast to a UInt64<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; I would like additional versions of the shift operator where rhs is an<br>&gt; Int please.<br>&gt; &gt;<br>&gt; &gt; Needless to say, the same applies to the left shift operators.<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/cb9ec7b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>+1 to dropping the existing signatures and providing a consistent right-hand side.<br></p><p>I&#39;m a little concerned about not allowing Int as the shift type. Even though we disallow negative shifts, we generally encourage using &#39;Int&#39; as the &quot;vocabulary&quot; type for integers, which means any shift by a non-constant amount might require a conversion. I do see that BigInts may be shifted by more than 2^64, however, so hardcoding Int wouldn&#39;t be right either.<br></p><p>(We do want to make sure the implementation is efficient when both argument types are a machine-representable integers, though, which may not be possible with all UnsignedIntegerTypes.)<br></p><p>Jordan<br></p><p>&gt; On Dec 19, 2015, at 5:54 , Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; Something worth considering with this proposal: Should it be IntMax rather than Int? (or UIntMax, does a negative count make sense?).<br>&gt; <br>&gt; Although it&#39;s probably never going to be enough if you want to calculate the next largest known prime number in swift, the last was 2^57885161 − 1.<br>&gt; <br>&gt; Also if it&#39;s in scope:<br>&gt; <br>&gt; Left and right shift are the only operators on integers that aren&#39;t generalised by a protocol. Every other operator is somehow part of IntegerType.<br>&gt; <br>&gt; See IntegerArithmeticType, SignedNumberType and BitwiseOperationsType.<br>&gt; <br>&gt; It would be nice to create a new protocol for something that can shift. The new protocol could be:<br>&gt; protocol IntegerBitShiftType {<br>&gt;     var sizeInBits: UIntMax<br>&gt; <br>&gt;     @warn_unused_result<br>&gt;     func &lt;&lt;(lhs: Self, rhs: UIntMax) -&gt; Self<br>&gt; <br>&gt;     @warn_unused_result<br>&gt;     func &gt;&gt;(lhs: Self, rhs: UIntMax) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; If IntegerType conformed to that protocol I don&#39;t think there&#39;s anything I want that Int can do and IntegerType can&#39;t.<br>&gt; <br>&gt; A related but slightly off-topic gripe:<br>&gt; Integer protocols in Standard Library define init(_: IntMax) or init(_: UIntMax), they assume that there isn&#39;t a wider type. When trying to make a new type conform to IntegerType (ie. a BigInt library) this can be an issue.<br>&gt; <br>&gt; It also seems to be necessary that things implementing IntegerType must conform to _MaxBuiltinIntegerType. It&#39;s type is much wider than IntMax (64x for me) and its interface is empty which makes it hard to conform.<br>&gt; <br>&gt; I think currently _MaxBuiltinIntegerType is 4096 bits, but it is still much smaller than what you want from a BigInt type. While I have suggested using IntMax in this implementation I think that IntMax is inherently flawed in its usage. However it is the best available at the moment in my opinion.<br>&gt; <br>&gt; Something like this may work in a more general case:<br>&gt; <br>&gt; protocol IntegerBitShiftType {<br>&gt;     @warn_unused_result<br>&gt;     func &lt;&lt; &lt;T: UnsignedIntegerType&gt;(lhs: Self, rhs: T) -&gt; Self<br>&gt; <br>&gt;     @warn_unused_result<br>&gt;     func &gt;&gt; &lt;T: UnsignedIntegerType&gt;(lhs: Self, rhs: T) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 3:02 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1. In fact, I would go even farther than asking for an additional version that uses Int on the rhs, I think all of the existing definitions are arguably wrong and they should all just be changed to use Int. I just took a brief scan of all uses of &gt;&gt; and &lt;&lt; in the stdlib: most use constants on the rhs, and so would be unaffected. It looks like all the rest either use Int on the lhs or require explicit casting or calling numericCast() to get the rhs to match.<br>&gt; <br>&gt;         - Greg<br>&gt; <br>&gt; &gt; On Dec 18, 2015, at 3:55 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; These are the definitions of the right shift operators<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int8, rhs: Int8) -&gt; Int8<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int, rhs: Int) -&gt; Int<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt, rhs: UInt) -&gt; UInt<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int64, rhs: Int64) -&gt; Int64<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt64, rhs: UInt64) -&gt; UInt64<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt8, rhs: UInt8) -&gt; UInt8<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt16, rhs: UInt16) -&gt; UInt16<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int16, rhs: Int16) -&gt; Int16<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: Int32, rhs: Int32) -&gt; Int32<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt32, rhs: UInt32) -&gt; UInt32<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Note that both left and right hand side are of the same type. In my opinion, rhs, which represents the number of bits to shift, should always be an Int e.g.<br>&gt; &gt;<br>&gt; &gt;       public func &gt;&gt;(lhs: UInt64, rhs: Int) -&gt; UInt64<br>&gt; &gt;<br>&gt; &gt; The two operands are fundamentally different, the left hand one is conceptually an array of bits and the right hand one is conceptually a count.<br>&gt; &gt;<br>&gt; &gt; The current definitions mean that I almost always have to do a cast on the right operand with shift operations. e.g. the following snippet that converts a UInt64 into an array of boolean values.<br>&gt; &gt;<br>&gt; &gt;    let aNumber: UInt64 = 0x123456<br>&gt; &gt;    var numberAsBits: [Bool] = [];<br>&gt; &gt;    for i in 0 ..&lt; 64<br>&gt; &gt;    {<br>&gt; &gt;        numberAsBits.append((aNumber &gt;&gt; i) &amp; 1 != 0); // Error because i needs to be cast to a UInt64<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; I would like additional versions of the shift operator where rhs is an Int please.<br>&gt; &gt;<br>&gt; &gt; Needless to say, the same applies to the left shift operators.<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/27774384/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>I don&#39;t support picking a single RHS type.<br></p><p>Again I&#39;ll mention that the prototype &lt;https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L1082&gt; I&#39;m already working on to replace the integer protocols and types already supports any integer type appearing on the RHS of a shift operation, where the LHS is any fixed-width integer type.  It also supports negative shifts and overshifts without trapping or causing undefined behavior (as suggested by Steve Canon there&#39;s also a new masking shift operator that masks the RHS before shifting, for those who can&#39;t afford the branch).<br></p><p><br>&gt; On Dec 19, 2015, at 7:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to dropping the existing signatures and providing a consistent right-hand side.<br>&gt; <br>&gt; I&#39;m a little concerned about not allowing Int as the shift type. Even though we disallow negative shifts, we generally encourage using &#39;Int&#39; as the &quot;vocabulary&quot; type for integers, which means any shift by a non-constant amount might require a conversion. I do see that BigInts may be shifted by more than 2^64, however, so hardcoding Int wouldn&#39;t be right either.<br>&gt; <br>&gt; (We do want to make sure the implementation is efficient when both argument types are a machine-representable integers, though, which may not be possible with all UnsignedIntegerTypes.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 5:54 , Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; Something worth considering with this proposal: Should it be IntMax rather than Int? (or UIntMax, does a negative count make sense?).<br>&gt;&gt; <br>&gt;&gt; Although it&#39;s probably never going to be enough if you want to calculate the next largest known prime number in swift, the last was 2^57885161 − 1.<br>&gt;&gt; <br>&gt;&gt; Also if it&#39;s in scope:<br>&gt;&gt; <br>&gt;&gt; Left and right shift are the only operators on integers that aren&#39;t generalised by a protocol. Every other operator is somehow part of IntegerType.<br>&gt;&gt; <br>&gt;&gt; See IntegerArithmeticType, SignedNumberType and BitwiseOperationsType.<br>&gt;&gt; <br>&gt;&gt; It would be nice to create a new protocol for something that can shift. The new protocol could be:<br>&gt;&gt; protocol IntegerBitShiftType {<br>&gt;&gt;     var sizeInBits: UIntMax<br>&gt;&gt; <br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     func &lt;&lt;(lhs: Self, rhs: UIntMax) -&gt; Self<br>&gt;&gt; <br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     func &gt;&gt;(lhs: Self, rhs: UIntMax) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If IntegerType conformed to that protocol I don&#39;t think there&#39;s anything I want that Int can do and IntegerType can&#39;t.<br>&gt;&gt; <br>&gt;&gt; A related but slightly off-topic gripe:<br>&gt;&gt; Integer protocols in Standard Library define init(_: IntMax) or init(_: UIntMax), they assume that there isn&#39;t a wider type. When trying to make a new type conform to IntegerType (ie. a BigInt library) this can be an issue.<br>&gt;&gt; <br>&gt;&gt; It also seems to be necessary that things implementing IntegerType must conform to _MaxBuiltinIntegerType. It&#39;s type is much wider than IntMax (64x for me) and its interface is empty which makes it hard to conform.<br>&gt;&gt; <br>&gt;&gt; I think currently _MaxBuiltinIntegerType is 4096 bits, but it is still much smaller than what you want from a BigInt type. While I have suggested using IntMax in this implementation I think that IntMax is inherently flawed in its usage. However it is the best available at the moment in my opinion.<br>&gt;&gt; <br>&gt;&gt; Something like this may work in a more general case:<br>&gt;&gt; <br>&gt;&gt; protocol IntegerBitShiftType {<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     func &lt;&lt; &lt;T: UnsignedIntegerType&gt;(lhs: Self, rhs: T) -&gt; Self<br>&gt;&gt; <br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     func &gt;&gt; &lt;T: UnsignedIntegerType&gt;(lhs: Self, rhs: T) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Dec 19, 2015 at 3:02 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1. In fact, I would go even farther than asking for an additional version that uses Int on the rhs, I think all of the existing definitions are arguably wrong and they should all just be changed to use Int. I just took a brief scan of all uses of &gt;&gt; and &lt;&lt; in the stdlib: most use constants on the rhs, and so would be unaffected. It looks like all the rest either use Int on the lhs or require explicit casting or calling numericCast() to get the rhs to match.<br>&gt;&gt; <br>&gt;&gt;         - Greg<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 18, 2015, at 3:55 AM, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; These are the definitions of the right shift operators<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: Int8, rhs: Int8) -&gt; Int8<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: Int, rhs: Int) -&gt; Int<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: UInt, rhs: UInt) -&gt; UInt<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: Int64, rhs: Int64) -&gt; Int64<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: UInt64, rhs: UInt64) -&gt; UInt64<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: UInt8, rhs: UInt8) -&gt; UInt8<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: UInt16, rhs: UInt16) -&gt; UInt16<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: Int16, rhs: Int16) -&gt; Int16<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: Int32, rhs: Int32) -&gt; Int32<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: UInt32, rhs: UInt32) -&gt; UInt32<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Note that both left and right hand side are of the same type. In my opinion, rhs, which represents the number of bits to shift, should always be an Int e.g.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public func &gt;&gt;(lhs: UInt64, rhs: Int) -&gt; UInt64<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The two operands are fundamentally different, the left hand one is conceptually an array of bits and the right hand one is conceptually a count.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The current definitions mean that I almost always have to do a cast on the right operand with shift operations. e.g. the following snippet that converts a UInt64 into an array of boolean values.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    let aNumber: UInt64 = 0x123456<br>&gt;&gt; &gt;    var numberAsBits: [Bool] = [];<br>&gt;&gt; &gt;    for i in 0 ..&lt; 64<br>&gt;&gt; &gt;    {<br>&gt;&gt; &gt;        numberAsBits.append((aNumber &gt;&gt; i) &amp; 1 != 0); // Error because i needs to be cast to a UInt64<br>&gt;&gt; &gt;    }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I would like additional versions of the shift operator where rhs is an Int please.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Needless to say, the same applies to the left shift operators.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/a6da2539/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 7:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to dropping the existing signatures and providing a consistent right-hand side.<br>&gt; <br>&gt; I&#39;m a little concerned about not allowing Int as the shift type. Even though we disallow negative shifts, we generally encourage using &#39;Int&#39; as the &quot;vocabulary&quot; type for integers, which means any shift by a non-constant amount might require a conversion. I do see that BigInts may be shifted by more than 2^64, however, so hardcoding Int wouldn&#39;t be right either.<br></p><p>Unless it is somehow sparsely encoded, a bigint with more than 2^64 bits couldn’t be held in memory.  <br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/89c93579/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 8:02 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 7:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 to dropping the existing signatures and providing a consistent right-hand side.<br>&gt;&gt; <br>&gt;&gt; I&#39;m a little concerned about not allowing Int as the shift type. Even though we disallow negative shifts, we generally encourage using &#39;Int&#39; as the &quot;vocabulary&quot; type for integers, which means any shift by a non-constant amount might require a conversion. I do see that BigInts may be shifted by more than 2^64, however, so hardcoding Int wouldn&#39;t be right either.<br>&gt; <br>&gt; Unless it is somehow sparsely encoded, a bigint with more than 2^64 bits couldn’t be held in memory.  <br></p><p>I don&#39;t believe bit shifting should be supported for BigInt anyway.  The lossy semantics of bit shifting is pretty closely tied to fixed-width integers.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/0012357f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Shift operator: the type of the second operand</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 11:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 8:02 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 19, 2015, at 7:43 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to dropping the existing signatures and providing a consistent right-hand side.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m a little concerned about not allowing Int as the shift type. Even though we disallow negative shifts, we generally encourage using &#39;Int&#39; as the &quot;vocabulary&quot; type for integers, which means any shift by a non-constant amount might require a conversion. I do see that BigInts may be shifted by more than 2^64, however, so hardcoding Int wouldn&#39;t be right either.<br>&gt;&gt; <br>&gt;&gt; Unless it is somehow sparsely encoded, a bigint with more than 2^64 bits couldn’t be held in memory.  <br>&gt; <br>&gt; I don&#39;t believe bit shifting should be supported for BigInt anyway.  The lossy semantics of bit shifting is pretty closely tied to fixed-width integers.<br></p><p>Yes, A BigInt type should probably eschew shift operators for this reason.  Instead, I would rather have either a sparse representation for powers of two that can be used with the usual multiply / divide, or explicit multiplyByTwoToThe( ) and divideByTwoToThe( ) functions (names to be bikeshedded, obviously).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/cf365390/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
