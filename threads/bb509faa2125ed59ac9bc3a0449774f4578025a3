<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Which functionality should be covered by a native Swift math/numerics library that ships with the standard lib?</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>August  5, 2016 at 08:00:00pm</p></header><div class="content"><p>You could use the pointer/raw memory API to implement that. <br></p><p>One reason why I dislike the idea of introducing fixed-size arrays as a first-class language feature is that it adds an additional construct with quite niche use. Non-type generic parameters instead give you a powerful tool that you can use to implement all kinds of things. <br></p><p>BTW, another way to have fixed-size arrays would be to extend the tuple type. However, if i understand correctly, the biggest optimisation potential comes from knowing the size of the array at the compile time. So we do need some sort of specialisation parameter. <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; I don&#39;t think that non-type generic arguments are enough to create fixed-size arrays. How would you fill in `struct Vector&lt;T, count: Int&gt;{ ... }`?<br>&gt; <br>&gt; Seems to me that the first step would be actual language support for non-parametrizable fixed-size arrays.<br>&gt; <br>&gt; Félix<br>&gt; &gt; Le 5 août 2016 à 04:53:20, Taras Zakharko via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; &gt; A few things immediately spring to mind:<br>&gt; &gt; &gt; • Fixed-size arrays<br>&gt; &gt; &gt; • An optimized Matrix type<br>&gt; &gt; &gt; • Swifty syntax for Fourier transforms<br>&gt; &gt; &gt; • A numerical integrator (or diff-eq solver!)<br>&gt; &gt; &gt; • BigInt capabilities<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The first of these (fixed-size arrays) will probably require compiler support.<br>&gt; &gt; <br>&gt; &gt; Fixed-size arrays should be easy enough to implement if the Swift generics are enhanced with support for constraints beyond type variables. E.g.<br>&gt; &gt; <br>&gt; &gt; struct Vector&lt;T, count: Int&gt;{ … }<br>&gt; &gt; <br>&gt; &gt; var x : Vector&lt;Float, count=16&gt;<br>&gt; &gt; <br>&gt; &gt; or even<br>&gt; &gt; <br>&gt; &gt; struct SparseTensor&lt;T, dimensions : [Int]&gt;{ … }<br>&gt; &gt; <br>&gt; &gt; var x: SparseTensor&lt;Float, dimensions = [100, 100, 100, 100]&gt;= SparseTensor(withValue: 0)<br>&gt; &gt; <br>&gt; &gt; I believe that something like this was mentioned in the discussion of the Generics Manifesto. If you are interested in making Swift more suitable for numerical operations, I’d say that the first order of business is to work towards implementing this sort of generic constants.<br>&gt; &gt; <br>&gt; &gt; Best,<br>&gt; &gt; <br>&gt; &gt; Taras<br>&gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The rest can already be done in a library, except I believe they will hit the “generics cannot be specialized across module boundaries” slowdown, and must be explicitly specialized for common numeric types to avoid it. (Has this been fixed yet? Are there plans to?)<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Nevin<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; On Wed, Aug 3, 2016 at 8:41 AM, Björn Forster&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; Hello Swift community,<br>&gt; &gt; &gt; &gt; to make use of Swift more appealing and useful for science, engineering and finance and everything else involving actually calculating things, I think it would be a big step forward if Swift would ship with its own math/numerics library.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Wouldn&#39;t it be great if Swift would offer functionality similar to Numpy in its native math lib? It think it would be great to have a &quot;standard&quot; annotation for vector arithmetic that the Swift community has agreed on and that scientific packages can build on.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Which functionality should be covered by a Swift&#39;s math lib and where should be drawn the line?<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Any thoughts?<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; (If it is not the right time now to talk this topic, as it is not mentioned in the goals for Swift 4 by Chris, I apologize for bringing this up now. But I think then this should be discussed later at some point not in the infinite future)<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Björn<br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Which functionality should be covered by a native Swift math/numerics library that ships with the standard lib?</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  6, 2016 at 03:00:00pm</p></header><div class="content"><p>If you&#39;d allocate memory for a fixed-size array, you might as well use a non-fixed-size array. You need the overhead of a full object header to be able to implement copy-on-write semantics anyway.<br></p><p>Right now, C fixed-size arrays are imported as tuples. int[4] translates to (Int32, Int32, Int32, Int32). If nothing else, fixed-size arrays as first-class constructs would let you access objects at a variable index or iterate over them without doing the little raw pointer dance.<br></p><p>Félix<br></p><p>&gt; Le 5 août 2016 à 11:00:58, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; a écrit :<br>&gt; <br>&gt; You could use the pointer/raw memory API to implement that. <br>&gt; <br>&gt; One reason why I dislike the idea of introducing fixed-size arrays as a first-class language feature is that it adds an additional construct with quite niche use. Non-type generic parameters instead give you a powerful tool that you can use to implement all kinds of things. <br>&gt; <br>&gt; BTW, another way to have fixed-size arrays would be to extend the tuple type. However, if i understand correctly, the biggest optimisation potential comes from knowing the size of the array at the compile time. So we do need some sort of specialisation parameter. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt; Taras<br>&gt; <br>&gt;&gt; I don&#39;t think that non-type generic arguments are enough to create fixed-size arrays. How would you fill in `struct Vector&lt;T, count: Int&gt;{ ... }`?<br>&gt;&gt; <br>&gt;&gt; Seems to me that the first step would be actual language support for non-parametrizable fixed-size arrays.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt;&gt; Le 5 août 2016 à 04:53:20, Taras Zakharko via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A few things immediately spring to mind:<br>&gt;&gt;&gt;&gt; • Fixed-size arrays<br>&gt;&gt;&gt;&gt; • An optimized Matrix type<br>&gt;&gt;&gt;&gt; • Swifty syntax for Fourier transforms<br>&gt;&gt;&gt;&gt; • A numerical integrator (or diff-eq solver!)<br>&gt;&gt;&gt;&gt; • BigInt capabilities<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first of these (fixed-size arrays) will probably require compiler support.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fixed-size arrays should be easy enough to implement if the Swift generics are enhanced with support for constraints beyond type variables. E.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Vector&lt;T, count: Int&gt;{ … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x : Vector&lt;Float, count=16&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or even<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct SparseTensor&lt;T, dimensions : [Int]&gt;{ … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x: SparseTensor&lt;Float, dimensions = [100, 100, 100, 100]&gt;= SparseTensor(withValue: 0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe that something like this was mentioned in the discussion of the Generics Manifesto. If you are interested in making Swift more suitable for numerical operations, I’d say that the first order of business is to work towards implementing this sort of generic constants.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rest can already be done in a library, except I believe they will hit the “generics cannot be specialized across module boundaries” slowdown, and must be explicitly specialized for common numeric types to avoid it. (Has this been fixed yet? Are there plans to?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Aug 3, 2016 at 8:41 AM, Björn Forster&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt; to make use of Swift more appealing and useful for science, engineering and finance and everything else involving actually calculating things, I think it would be a big step forward if Swift would ship with its own math/numerics library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t it be great if Swift would offer functionality similar to Numpy in its native math lib? It think it would be great to have a &quot;standard&quot; annotation for vector arithmetic that the Swift community has agreed on and that scientific packages can build on.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Which functionality should be covered by a Swift&#39;s math lib and where should be drawn the line?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (If it is not the right time now to talk this topic, as it is not mentioned in the goals for Swift 4 by Chris, I apologize for bringing this up now. But I think then this should be discussed later at some point not in the infinite future)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Björn<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160806/6d5ffbc3/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
