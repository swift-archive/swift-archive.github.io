<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[Proposal] Using Union instead of Generic Enum to implement Optional</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 15, 2016 at 07:00:00pm</p></header><div class="content"><p>This is the example implemented with generic and enum.<br></p><p>enum UnionOf3 &lt;T,U,V&gt;{<br>    case type0(T)<br>    case type1(U)<br>    case type2(V)<br>}<br></p><p>func input(value: UnionOf3&lt;A,B,C&gt;) {<br>    switch value {<br>    case let .type0(a):<br>        print(a)<br>    case let .type1(b):<br>        print(b)<br>    case let .type2(c):<br>        print(c)<br>    }<br>}<br></p><p>let a = A()<br>input(UnionOf3.type0(a))<br></p><p>For each different number N of types to get union, you should announce UnionOfN for each.<br>it is more complicated then the union solution. <br></p><p>func input(value: (A | B | C)) {<br>    switch value {<br>    case a as A:<br>        print(a)<br>    case b as B:<br>        print(b)<br>    case let .type2(c):<br>        print(c)<br>    }<br>}<br></p><p>let a= A()<br>input(a)<br></p><p><br>And the most bad thing is,<br>compiler doesn’t know the type relation between generic union with original type,<br> for example, the type relation between A and A | B and A | B | C.<br></p><p>compare:<br></p><p>enum UnionOf3 &lt;T,U,V&gt;{<br>    case type0(T)<br>    case type1(U)<br>    case type2(V)<br>}<br></p><p>let a = A()<br>let union: UnionOf3&lt;A,B,C&gt; = UnionOf3.type0(a) // You should wrap by yourself.<br></p><p>a == union // probably the compiler will refuse to compare.<br></p><p>sub-typing: <br></p><p>var fn0: A-&gt;Void = {print($0)}<br>var fn1: UnionOf2&lt;A,B&gt;-&gt;Void = {print($0)}<br></p><p>fn0 = fn1 // This should be allowed. But will be rejected since using enum.<br></p><p>var fn2: UnionOf3&lt;A,B,C&gt;-&gt;Void = {print($0)}<br></p><p>fn0 = fn2 // This should be allowed. But will be rejected since using enum.<br>fn1 = fn2 // This should be allowed. But will be rejected since using enum.<br></p><p><br>---------------------------------------------------------------------------<br></p><p>If using union, this problem can be solved easily.<br></p><p>let a = A()<br>let union: (A|B|C) = a // Automatically wrap.<br></p><p>a == union // Yes<br></p><p>sub-typing: <br></p><p>var fn0: A-&gt;Void = {print(v0)}<br>var fn1: (A|B)-&gt;Void = {print(v0)}<br></p><p>fn0 = fn1 // OK<br></p><p>var fn2: (A|B|C)-&gt;Void = {print($0)}<br></p><p>fn0 = fn2 // OK<br>fn1 = fn2 // OK<br></p><p><br>&gt; 下面是被转发的邮件：<br>&gt; <br>&gt; 发件人: Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; 主题: [swift-evolution] Fwd: Union instead of Optional<br>&gt; 日期: 2016年5月15日 GMT+8 18:34:44<br>&gt; 收件人: Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; 回复－收件人: Cao Jiannan &lt;frogcjn at 163.com&gt;<br>&gt; <br>&gt; for example, there is a method input union of 3 types: A, B, C,<br>&gt; <br>&gt; This is the three class.<br>&gt; <br>&gt; class A {}<br>&gt; <br>&gt; class B {}<br>&gt; <br>&gt; class C {}<br>&gt; <br>&gt; This is how it implemented under Swift 2:<br>&gt; <br>&gt; enum UnionABC {<br>&gt;     case classA(A)<br>&gt;     case classB(B)<br>&gt;     case classC(C)<br>&gt; }<br>&gt; <br>&gt; func input(value: UnionABC) {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; let b = B()<br>&gt; let c = C()<br>&gt; input(UnionABC.classA(a))<br>&gt; <br>&gt; <br>&gt; It needs announce all the cases and name each cases and cannot use class names as their case names.<br>&gt; <br>&gt; what about using union? It is more easy and rational.<br>&gt; <br>&gt; <br>&gt; func input(value: (A | B | C)) {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; let a= A()<br>&gt; input(a)<br>&gt; <br>&gt; Or you can implement it with protocol and extension, but compiler will not know how many cases it should have.<br>&gt; <br>&gt; <br>&gt; protocol UnionABC {<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; extension A: UnionABC {}<br>&gt; extension B: UnionABC {}<br>&gt; extension C: UnionABC {}<br>&gt; <br>&gt; <br>&gt; func input(value: UnionABC) {<br>&gt;     if value is A {<br>&gt;         <br>&gt;     } else if value is B {<br>&gt;         <br>&gt;     } else if value is C {<br>&gt;         <br>&gt;     } else {<br>&gt;         // There are other cases? Compiler doesn&#39;t know<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; input(a)<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt; <br>&gt;&gt; 发件人: frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;<br>&gt;&gt; 主题: 回复： [swift-evolution] Union instead of Optional<br>&gt;&gt; 日期: 2016年5月15日 GMT+8 18:00:55<br>&gt;&gt; 收件人: Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Enum and Union are two things.<br>&gt;&gt; <br>&gt;&gt; If you use Enum to implement Union, you should announce it with case name.<br>&gt;&gt; <br>&gt;&gt; Another issue using enum instead of union is that,  union can combine types as many as possible, you just write ( A | B | C ... | Z), but for enum, you should carefully announce it for each case. <br>&gt;&gt; <br>&gt;&gt; 在 2016年5月15日，15:22，Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt;&gt; In addition, not everything in Swift can be modeled in terms of inheritance relationships.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/5b8da41d/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
