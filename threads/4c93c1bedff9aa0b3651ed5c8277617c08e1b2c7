<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>As we have discussed throughout this thread, the initial proposal was<br>modified to include alternative subscript methods instead of modifying the<br>default operator/subscript behaviour.<br>The first draft is here:<br>https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br></p><p>I&#39;ve also put this as a gist so that you can leave comments with respect to<br>the proposal document itself. Any suggestion or help is very welcome.<br>https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br></p><p>Regards,<br></p><p>- Luis<br></p><p>On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;<br>wrote:<br></p><p>&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator)<br>&gt; in order to avoid **Array index out of range** errors in execution time.<br>&gt;<br>&gt; Here is my first draft for this proposal:<br>&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;<br>&gt; In short, doing that in Swift causes a runtime error:<br>&gt;<br>&gt; let a = [1,2,3]<br>&gt; let b = a[0..&lt;5]<br>&gt; print(b)<br>&gt;<br>&gt; &gt; Error running code:<br>&gt; &gt; fatal error: Array index out of range<br>&gt;<br>&gt; The proposed solution is to slice the array returning all elements that<br>&gt; are below the half-open operator, even though the number of elements is<br>&gt; lesser than the ending of the half-open operator. So the example above<br>&gt; would return [1,2,3].<br>&gt; We can see this very behaviour in other languages, such as Python and Ruby<br>&gt; as shown in the proposal draft.<br>&gt;<br>&gt; This would eliminate the need for verifications on the array size before<br>&gt; slicing it -- and consequently runtime errors in cases when the programmer<br>&gt; didn&#39;t.<br>&gt;<br>&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt; Thanks!<br>&gt;<br>&gt; Luis Henrique Borges<br>&gt; @luishborges<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/4c93b2c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 04:00:00pm</p></header><div class="content"><p>I support this proposal. Probably we all should select the best labels <br>(truncate/lenient or other). As not native English speaker, I don&#39;t feel <br>like &#39;lenient&#39; is well-known word or often-used word in software <br>development. But all this just a details we need to discuss.<br></p><p>What I think could be improved - is a motivation section. IMO the main <br>purpose of proposed features is not to &quot;eliminate the need for validations, <br>reduce the number of fatal errors in runtime&quot; but to allow us to have more <br>clean code when *such validations just don&#39;t required*, when we just *don&#39;t <br>care* about details.<br>I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5, <br>a.endIndex)] and bounds checking manually to have the same result as in <br>proposed subscripts.<br></p><p>I.e. it is just a very handy addition to standard methods for collections, <br>just like we can get first element by index but we have handy property <br>&#39;.first&#39; for this purpose. Btw, it does not raise error, but returns T?. I <br>think you can add notes regarding analogues with .first / .last <br>properties(and probably with other) in proposal text.<br></p><p>Someone can argue, that by using these subscripts, coders can write &#39;bad&#39; <br>code - but I can&#39;t accept such an argument - &#39;bad&#39; coders already can write <br>&#39;bad&#39; code with other features of Swift and at the end they can implement <br>these subscripts in their project and write &#39;bad&#39; code. Should we stop to <br>introduce handy and explicit feature for &#39;good&#39; coders because of this?<br></p><p>On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt; modified to include alternative subscript methods instead of modifying the<br>&gt; default operator/subscript behaviour.<br>&gt; The first draft is<br>&gt; here: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;<br>&gt; I&#39;ve also put this as a gist so that you can leave comments with respect to<br>&gt; the proposal document itself. Any suggestion or help is very welcome.<br>&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;     execution time.<br>&gt;<br>&gt;     Here is my first draft for this proposal:<br>&gt;     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;<br>&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;<br>&gt;     leta =[1,2,3]<br>&gt;     letb =a[0..&lt;5]<br>&gt;     print(b)<br>&gt;<br>&gt;     &gt; Error running code:<br>&gt;     &gt; fatal error: Array index out of range<br>&gt;<br>&gt;     The proposed solution is to slice the array returning all elements that<br>&gt;     are below the half-open operator, even though the number of elements is<br>&gt;     lesser than the ending of the half-open operator. So the example above<br>&gt;     would return [1,2,3].<br>&gt;     We can see this very behaviour in other languages, such as Python and<br>&gt;     Ruby as shown in the proposal draft.<br>&gt;<br>&gt;     This would eliminate the need for verifications on the array size<br>&gt;     before slicing it -- and consequently runtime errors in cases when the<br>&gt;     programmer didn&#39;t.<br>&gt;<br>&gt;     Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;<br>&gt;     Thanks!<br>&gt;<br>&gt;     Luis Henrique Borges<br>&gt;     @luishborges<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks Vladimir, your considerations and suggestions are totally valid, I&#39;m<br>going to change the document accordingly.<br>Also as a non-native English speaker I think that other words could fit<br>better, such as &#39;tolerant&#39; or &#39;permissive&#39; -- but I dunno if they would<br>look great as a label. We will come up with the right keyword for it.<br></p><p>In relation to bad code, it could be a valid argument if my initial<br>proposal was under discussion instead, where the default &#39;fail fast&#39;<br>behaviour would be &quot;camouflaged&quot; and bugs would be more difficult to catch.<br>In this new proposal we have such features explicitly defined, where the<br>user will be familiar with what it does and what results to expect for. I<br>don&#39;t see a way that it could drive to bad written code.<br></p><p>- Luis<br></p><p>On Thu, Apr 28, 2016 at 2:37 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; I support this proposal. Probably we all should select the best labels<br>&gt; (truncate/lenient or other). As not native English speaker, I don&#39;t feel<br>&gt; like &#39;lenient&#39; is well-known word or often-used word in software<br>&gt; development. But all this just a details we need to discuss.<br>&gt;<br>&gt; What I think could be improved - is a motivation section. IMO the main<br>&gt; purpose of proposed features is not to &quot;eliminate the need for validations,<br>&gt; reduce the number of fatal errors in runtime&quot; but to allow us to have more<br>&gt; clean code when *such validations just don&#39;t required*, when we just *don&#39;t<br>&gt; care* about details.<br>&gt; I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5,<br>&gt; a.endIndex)] and bounds checking manually to have the same result as in<br>&gt; proposed subscripts.<br>&gt;<br>&gt; I.e. it is just a very handy addition to standard methods for collections,<br>&gt; just like we can get first element by index but we have handy property<br>&gt; &#39;.first&#39; for this purpose. Btw, it does not raise error, but returns T?. I<br>&gt; think you can add notes regarding analogues with .first / .last<br>&gt; properties(and probably with other) in proposal text.<br>&gt;<br>&gt; Someone can argue, that by using these subscripts, coders can write &#39;bad&#39;<br>&gt; code - but I can&#39;t accept such an argument - &#39;bad&#39; coders already can write<br>&gt; &#39;bad&#39; code with other features of Swift and at the end they can implement<br>&gt; these subscripts in their project and write &#39;bad&#39; code. Should we stop to<br>&gt; introduce handy and explicit feature for &#39;good&#39; coders because of this?<br>&gt;<br>&gt; On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt;<br>&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt; modified to include alternative subscript methods instead of modifying the<br>&gt;&gt; default operator/subscript behaviour.<br>&gt;&gt; The first draft is<br>&gt;&gt; here:<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with respect<br>&gt;&gt; to<br>&gt;&gt; the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa &lt;<br>&gt;&gt; lshsousa at gmail.com<br>&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;     execution time.<br>&gt;&gt;<br>&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;<br>&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;     print(b)<br>&gt;&gt;<br>&gt;&gt;     &gt; Error running code:<br>&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;<br>&gt;&gt;     The proposed solution is to slice the array returning all elements<br>&gt;&gt; that<br>&gt;&gt;     are below the half-open operator, even though the number of elements<br>&gt;&gt; is<br>&gt;&gt;     lesser than the ending of the half-open operator. So the example above<br>&gt;&gt;     would return [1,2,3].<br>&gt;&gt;     We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;<br>&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;     before slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt;     programmer didn&#39;t.<br>&gt;&gt;<br>&gt;&gt;     Viewing that it is my very first proposal, any feedback will be<br>&gt;&gt; helpful.<br>&gt;&gt;<br>&gt;&gt;     Thanks!<br>&gt;&gt;<br>&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;     @luishborges<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/cba2567b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Some alternatives to &#39;safe:&#39;<br></p><p>existing:<br>bounded:<br>valid:<br></p><p>-Thorsten <br></p><p>&gt; Am 29.04.2016 um 00:20 schrieb Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Thanks Vladimir, your considerations and suggestions are totally valid, I&#39;m going to change the document accordingly. <br>&gt; Also as a non-native English speaker I think that other words could fit better, such as &#39;tolerant&#39; or &#39;permissive&#39; -- but I dunno if they would look great as a label. We will come up with the right keyword for it.<br>&gt; <br>&gt; In relation to bad code, it could be a valid argument if my initial proposal was under discussion instead, where the default &#39;fail fast&#39; behaviour would be &quot;camouflaged&quot; and bugs would be more difficult to catch. In this new proposal we have such features explicitly defined, where the user will be familiar with what it does and what results to expect for. I don&#39;t see a way that it could drive to bad written code.<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt;&gt; On Thu, Apr 28, 2016 at 2:37 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; I support this proposal. Probably we all should select the best labels (truncate/lenient or other). As not native English speaker, I don&#39;t feel like &#39;lenient&#39; is well-known word or often-used word in software development. But all this just a details we need to discuss.<br>&gt;&gt; <br>&gt;&gt; What I think could be improved - is a motivation section. IMO the main purpose of proposed features is not to &quot;eliminate the need for validations, reduce the number of fatal errors in runtime&quot; but to allow us to have more clean code when *such validations just don&#39;t required*, when we just *don&#39;t care* about details.<br>&gt;&gt; I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5, a.endIndex)] and bounds checking manually to have the same result as in proposed subscripts.<br>&gt;&gt; <br>&gt;&gt; I.e. it is just a very handy addition to standard methods for collections, just like we can get first element by index but we have handy property &#39;.first&#39; for this purpose. Btw, it does not raise error, but returns T?. I think you can add notes regarding analogues with .first / .last properties(and probably with other) in proposal text.<br>&gt;&gt; <br>&gt;&gt; Someone can argue, that by using these subscripts, coders can write &#39;bad&#39; code - but I can&#39;t accept such an argument - &#39;bad&#39; coders already can write &#39;bad&#39; code with other features of Swift and at the end they can implement these subscripts in their project and write &#39;bad&#39; code. Should we stop to introduce handy and explicit feature for &#39;good&#39; coders because of this?<br>&gt;&gt; <br>&gt;&gt;&gt; On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt;&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;&gt; modified to include alternative subscript methods instead of modifying the<br>&gt;&gt;&gt; default operator/subscript behaviour.<br>&gt;&gt;&gt; The first draft is<br>&gt;&gt;&gt; here: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with respect to<br>&gt;&gt;&gt; the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;&gt;     execution time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;&gt;     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;&gt;     print(b)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     &gt; Error running code:<br>&gt;&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     The proposed solution is to slice the array returning all elements that<br>&gt;&gt;&gt;     are below the half-open operator, even though the number of elements is<br>&gt;&gt;&gt;     lesser than the ending of the half-open operator. So the example above<br>&gt;&gt;&gt;     would return [1,2,3].<br>&gt;&gt;&gt;     We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;&gt;     before slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt;&gt;     programmer didn&#39;t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;&gt;     @luishborges<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/d859e3ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 29, 2016 at 07:00:00pm</p></header><div class="content"><p>From my point of view,<br>truncate -&gt; bounded<br>lenient -&gt; keep &quot;lenient:&quot; ? &quot;requested:&quot; ? &quot;optional:&quot;?<br></p><p>On 29.04.2016 17:46, Thorsten Seitz wrote:<br>&gt; Some alternatives to &#39;safe:&#39;<br>&gt;<br>&gt; existing:<br>&gt; bounded:<br>&gt; valid:<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 29.04.2016 um 00:20 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;&gt; Thanks Vladimir, your considerations and suggestions are totally valid,<br>&gt;&gt; I&#39;m going to change the document accordingly.<br>&gt;&gt; Also as a non-native English speaker I think that other words could fit<br>&gt;&gt; better, such as &#39;tolerant&#39; or &#39;permissive&#39; -- but I dunno if they would<br>&gt;&gt; look great as a label. We will come up with the right keyword for it.<br>&gt;&gt;<br>&gt;&gt; In relation to bad code, it could be a valid argument if my initial<br>&gt;&gt; proposal was under discussion instead, where the default &#39;fail fast&#39;<br>&gt;&gt; behaviour would be &quot;camouflaged&quot; and bugs would be more difficult to<br>&gt;&gt; catch. In this new proposal we have such features explicitly defined,<br>&gt;&gt; where the user will be familiar with what it does and what results to<br>&gt;&gt; expect for. I don&#39;t see a way that it could drive to bad written code.<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Thu, Apr 28, 2016 at 2:37 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     I support this proposal. Probably we all should select the best<br>&gt;&gt;     labels (truncate/lenient or other). As not native English speaker, I<br>&gt;&gt;     don&#39;t feel like &#39;lenient&#39; is well-known word or often-used word in<br>&gt;&gt;     software development. But all this just a details we need to discuss.<br>&gt;&gt;<br>&gt;&gt;     What I think could be improved - is a motivation section. IMO the<br>&gt;&gt;     main purpose of proposed features is not to &quot;eliminate the need for<br>&gt;&gt;     validations, reduce the number of fatal errors in runtime&quot; but to<br>&gt;&gt;     allow us to have more clean code when *such validations just don&#39;t<br>&gt;&gt;     required*, when we just *don&#39;t care* about details.<br>&gt;&gt;     I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5,<br>&gt;&gt;     a.endIndex)] and bounds checking manually to have the same result as<br>&gt;&gt;     in proposed subscripts.<br>&gt;&gt;<br>&gt;&gt;     I.e. it is just a very handy addition to standard methods for<br>&gt;&gt;     collections, just like we can get first element by index but we have<br>&gt;&gt;     handy property &#39;.first&#39; for this purpose. Btw, it does not raise<br>&gt;&gt;     error, but returns T?. I think you can add notes regarding analogues<br>&gt;&gt;     with .first / .last properties(and probably with other) in proposal text.<br>&gt;&gt;<br>&gt;&gt;     Someone can argue, that by using these subscripts, coders can write<br>&gt;&gt;     &#39;bad&#39; code - but I can&#39;t accept such an argument - &#39;bad&#39; coders<br>&gt;&gt;     already can write &#39;bad&#39; code with other features of Swift and at the<br>&gt;&gt;     end they can implement these subscripts in their project and write<br>&gt;&gt;     &#39;bad&#39; code. Should we stop to introduce handy and explicit feature<br>&gt;&gt;     for &#39;good&#39; coders because of this?<br>&gt;&gt;<br>&gt;&gt;     On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;         As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;         modified to include alternative subscript methods instead of<br>&gt;&gt;         modifying the<br>&gt;&gt;         default operator/subscript behaviour.<br>&gt;&gt;         The first draft is<br>&gt;&gt;         here:<br>&gt;&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt;         I&#39;ve also put this as a gist so that you can leave comments with<br>&gt;&gt;         respect to<br>&gt;&gt;         the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt;         https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;<br>&gt;&gt;         Regards,<br>&gt;&gt;<br>&gt;&gt;         - Luis<br>&gt;&gt;<br>&gt;&gt;         On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;         &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;         &lt;mailto:lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;             This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;             operator) in order to avoid **Array index out of range**<br>&gt;&gt;         errors in<br>&gt;&gt;             execution time.<br>&gt;&gt;<br>&gt;&gt;             Here is my first draft for this proposal:<br>&gt;&gt;<br>&gt;&gt;         https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt;             In short, doing that in Swift causes a runtime error:<br>&gt;&gt;<br>&gt;&gt;             leta =[1,2,3]<br>&gt;&gt;             letb =a[0..&lt;5]<br>&gt;&gt;             print(b)<br>&gt;&gt;<br>&gt;&gt;             &gt; Error running code:<br>&gt;&gt;             &gt; fatal error: Array index out of range<br>&gt;&gt;<br>&gt;&gt;             The proposed solution is to slice the array returning all<br>&gt;&gt;         elements that<br>&gt;&gt;             are below the half-open operator, even though the number of<br>&gt;&gt;         elements is<br>&gt;&gt;             lesser than the ending of the half-open operator. So the<br>&gt;&gt;         example above<br>&gt;&gt;             would return [1,2,3].<br>&gt;&gt;             We can see this very behaviour in other languages, such as<br>&gt;&gt;         Python and<br>&gt;&gt;             Ruby as shown in the proposal draft.<br>&gt;&gt;<br>&gt;&gt;             This would eliminate the need for verifications on the array size<br>&gt;&gt;             before slicing it -- and consequently runtime errors in cases<br>&gt;&gt;         when the<br>&gt;&gt;             programmer didn&#39;t.<br>&gt;&gt;<br>&gt;&gt;             Viewing that it is my very first proposal, any feedback will<br>&gt;&gt;         be helpful.<br>&gt;&gt;<br>&gt;&gt;             Thanks!<br>&gt;&gt;<br>&gt;&gt;             Luis Henrique Borges<br>&gt;&gt;             @luishborges<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&quot;bounded&quot; sounds good to me, but I don&#39;t know if &quot;optional&quot; is a good<br>choice as it could be highlighted as a reserved keyword:<br></p><p>https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br></p><p>- Luis<br></p><p>On Fri, Apr 29, 2016 at 5:08 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; From my point of view,<br>&gt; truncate -&gt; bounded<br>&gt; lenient -&gt; keep &quot;lenient:&quot; ? &quot;requested:&quot; ? &quot;optional:&quot;?<br>&gt;<br>&gt; On 29.04.2016 17:46, Thorsten Seitz wrote:<br>&gt;<br>&gt;&gt; Some alternatives to &#39;safe:&#39;<br>&gt;&gt;<br>&gt;&gt; existing:<br>&gt;&gt; bounded:<br>&gt;&gt; valid:<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 29.04.2016 um 00:20 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt; Thanks Vladimir, your considerations and suggestions are totally valid,<br>&gt;&gt;&gt; I&#39;m going to change the document accordingly.<br>&gt;&gt;&gt; Also as a non-native English speaker I think that other words could fit<br>&gt;&gt;&gt; better, such as &#39;tolerant&#39; or &#39;permissive&#39; -- but I dunno if they would<br>&gt;&gt;&gt; look great as a label. We will come up with the right keyword for it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In relation to bad code, it could be a valid argument if my initial<br>&gt;&gt;&gt; proposal was under discussion instead, where the default &#39;fail fast&#39;<br>&gt;&gt;&gt; behaviour would be &quot;camouflaged&quot; and bugs would be more difficult to<br>&gt;&gt;&gt; catch. In this new proposal we have such features explicitly defined,<br>&gt;&gt;&gt; where the user will be familiar with what it does and what results to<br>&gt;&gt;&gt; expect for. I don&#39;t see a way that it could drive to bad written code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Apr 28, 2016 at 2:37 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I support this proposal. Probably we all should select the best<br>&gt;&gt;&gt;     labels (truncate/lenient or other). As not native English speaker, I<br>&gt;&gt;&gt;     don&#39;t feel like &#39;lenient&#39; is well-known word or often-used word in<br>&gt;&gt;&gt;     software development. But all this just a details we need to discuss.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     What I think could be improved - is a motivation section. IMO the<br>&gt;&gt;&gt;     main purpose of proposed features is not to &quot;eliminate the need for<br>&gt;&gt;&gt;     validations, reduce the number of fatal errors in runtime&quot; but to<br>&gt;&gt;&gt;     allow us to have more clean code when *such validations just don&#39;t<br>&gt;&gt;&gt;     required*, when we just *don&#39;t care* about details.<br>&gt;&gt;&gt;     I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5,<br>&gt;&gt;&gt;     a.endIndex)] and bounds checking manually to have the same result as<br>&gt;&gt;&gt;     in proposed subscripts.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I.e. it is just a very handy addition to standard methods for<br>&gt;&gt;&gt;     collections, just like we can get first element by index but we have<br>&gt;&gt;&gt;     handy property &#39;.first&#39; for this purpose. Btw, it does not raise<br>&gt;&gt;&gt;     error, but returns T?. I think you can add notes regarding analogues<br>&gt;&gt;&gt;     with .first / .last properties(and probably with other) in proposal<br>&gt;&gt;&gt; text.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Someone can argue, that by using these subscripts, coders can write<br>&gt;&gt;&gt;     &#39;bad&#39; code - but I can&#39;t accept such an argument - &#39;bad&#39; coders<br>&gt;&gt;&gt;     already can write &#39;bad&#39; code with other features of Swift and at the<br>&gt;&gt;&gt;     end they can implement these subscripts in their project and write<br>&gt;&gt;&gt;     &#39;bad&#39; code. Should we stop to introduce handy and explicit feature<br>&gt;&gt;&gt;     for &#39;good&#39; coders because of this?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         As we have discussed throughout this thread, the initial<br>&gt;&gt;&gt; proposal was<br>&gt;&gt;&gt;         modified to include alternative subscript methods instead of<br>&gt;&gt;&gt;         modifying the<br>&gt;&gt;&gt;         default operator/subscript behaviour.<br>&gt;&gt;&gt;         The first draft is<br>&gt;&gt;&gt;         here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         I&#39;ve also put this as a gist so that you can leave comments with<br>&gt;&gt;&gt;         respect to<br>&gt;&gt;&gt;         the proposal document itself. Any suggestion or help is very<br>&gt;&gt;&gt; welcome.<br>&gt;&gt;&gt;         https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;         &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;         &lt;mailto:lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             This proposal seeks to provide a safer ..&lt; (aka half-open<br>&gt;&gt;&gt; range<br>&gt;&gt;&gt;             operator) in order to avoid **Array index out of range**<br>&gt;&gt;&gt;         errors in<br>&gt;&gt;&gt;             execution time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Here is my first draft for this proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             leta =[1,2,3]<br>&gt;&gt;&gt;             letb =a[0..&lt;5]<br>&gt;&gt;&gt;             print(b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt; Error running code:<br>&gt;&gt;&gt;             &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             The proposed solution is to slice the array returning all<br>&gt;&gt;&gt;         elements that<br>&gt;&gt;&gt;             are below the half-open operator, even though the number of<br>&gt;&gt;&gt;         elements is<br>&gt;&gt;&gt;             lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;         example above<br>&gt;&gt;&gt;             would return [1,2,3].<br>&gt;&gt;&gt;             We can see this very behaviour in other languages, such as<br>&gt;&gt;&gt;         Python and<br>&gt;&gt;&gt;             Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             This would eliminate the need for verifications on the array<br>&gt;&gt;&gt; size<br>&gt;&gt;&gt;             before slicing it -- and consequently runtime errors in cases<br>&gt;&gt;&gt;         when the<br>&gt;&gt;&gt;             programmer didn&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Viewing that it is my very first proposal, any feedback will<br>&gt;&gt;&gt;         be helpful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Luis Henrique Borges<br>&gt;&gt;&gt;             @luishborges<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/f9daab01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  6, 2016 at 11:00:00am</p></header><div class="content"><p>Did you consider making the safer, optional overload the &quot;default&quot; and just omit the label?<br></p><p>Sent from my iPad<br></p><p>&gt; On May 6, 2016, at 10:23 AM, Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;bounded&quot; sounds good to me, but I don&#39;t know if &quot;optional&quot; is a good choice as it could be highlighted as a reserved keyword:<br>&gt; <br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt;&gt; On Fri, Apr 29, 2016 at 5:08 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; From my point of view,<br>&gt;&gt; truncate -&gt; bounded<br>&gt;&gt; lenient -&gt; keep &quot;lenient:&quot; ? &quot;requested:&quot; ? &quot;optional:&quot;?<br>&gt;&gt; <br>&gt;&gt;&gt; On 29.04.2016 17:46, Thorsten Seitz wrote:<br>&gt;&gt;&gt; Some alternatives to &#39;safe:&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; existing:<br>&gt;&gt;&gt; bounded:<br>&gt;&gt;&gt; valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 29.04.2016 um 00:20 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks Vladimir, your considerations and suggestions are totally valid,<br>&gt;&gt;&gt;&gt; I&#39;m going to change the document accordingly.<br>&gt;&gt;&gt;&gt; Also as a non-native English speaker I think that other words could fit<br>&gt;&gt;&gt;&gt; better, such as &#39;tolerant&#39; or &#39;permissive&#39; -- but I dunno if they would<br>&gt;&gt;&gt;&gt; look great as a label. We will come up with the right keyword for it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In relation to bad code, it could be a valid argument if my initial<br>&gt;&gt;&gt;&gt; proposal was under discussion instead, where the default &#39;fail fast&#39;<br>&gt;&gt;&gt;&gt; behaviour would be &quot;camouflaged&quot; and bugs would be more difficult to<br>&gt;&gt;&gt;&gt; catch. In this new proposal we have such features explicitly defined,<br>&gt;&gt;&gt;&gt; where the user will be familiar with what it does and what results to<br>&gt;&gt;&gt;&gt; expect for. I don&#39;t see a way that it could drive to bad written code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Apr 28, 2016 at 2:37 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     I support this proposal. Probably we all should select the best<br>&gt;&gt;&gt;&gt;     labels (truncate/lenient or other). As not native English speaker, I<br>&gt;&gt;&gt;&gt;     don&#39;t feel like &#39;lenient&#39; is well-known word or often-used word in<br>&gt;&gt;&gt;&gt;     software development. But all this just a details we need to discuss.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     What I think could be improved - is a motivation section. IMO the<br>&gt;&gt;&gt;&gt;     main purpose of proposed features is not to &quot;eliminate the need for<br>&gt;&gt;&gt;&gt;     validations, reduce the number of fatal errors in runtime&quot; but to<br>&gt;&gt;&gt;&gt;     allow us to have more clean code when *such validations just don&#39;t<br>&gt;&gt;&gt;&gt;     required*, when we just *don&#39;t care* about details.<br>&gt;&gt;&gt;&gt;     I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5,<br>&gt;&gt;&gt;&gt;     a.endIndex)] and bounds checking manually to have the same result as<br>&gt;&gt;&gt;&gt;     in proposed subscripts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     I.e. it is just a very handy addition to standard methods for<br>&gt;&gt;&gt;&gt;     collections, just like we can get first element by index but we have<br>&gt;&gt;&gt;&gt;     handy property &#39;.first&#39; for this purpose. Btw, it does not raise<br>&gt;&gt;&gt;&gt;     error, but returns T?. I think you can add notes regarding analogues<br>&gt;&gt;&gt;&gt;     with .first / .last properties(and probably with other) in proposal text.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Someone can argue, that by using these subscripts, coders can write<br>&gt;&gt;&gt;&gt;     &#39;bad&#39; code - but I can&#39;t accept such an argument - &#39;bad&#39; coders<br>&gt;&gt;&gt;&gt;     already can write &#39;bad&#39; code with other features of Swift and at the<br>&gt;&gt;&gt;&gt;     end they can implement these subscripts in their project and write<br>&gt;&gt;&gt;&gt;     &#39;bad&#39; code. Should we stop to introduce handy and explicit feature<br>&gt;&gt;&gt;&gt;     for &#39;good&#39; coders because of this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;&gt;&gt;         modified to include alternative subscript methods instead of<br>&gt;&gt;&gt;&gt;         modifying the<br>&gt;&gt;&gt;&gt;         default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;         The first draft is<br>&gt;&gt;&gt;&gt;         here:<br>&gt;&gt;&gt;&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         I&#39;ve also put this as a gist so that you can leave comments with<br>&gt;&gt;&gt;&gt;         respect to<br>&gt;&gt;&gt;&gt;         the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt;&gt;&gt;         https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         Regards,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;         &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;         &lt;mailto:lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;&gt;&gt;             operator) in order to avoid **Array index out of range**<br>&gt;&gt;&gt;&gt;         errors in<br>&gt;&gt;&gt;&gt;             execution time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             leta =[1,2,3]<br>&gt;&gt;&gt;&gt;             letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;             print(b)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             &gt; Error running code:<br>&gt;&gt;&gt;&gt;             &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             The proposed solution is to slice the array returning all<br>&gt;&gt;&gt;&gt;         elements that<br>&gt;&gt;&gt;&gt;             are below the half-open operator, even though the number of<br>&gt;&gt;&gt;&gt;         elements is<br>&gt;&gt;&gt;&gt;             lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;&gt;         example above<br>&gt;&gt;&gt;&gt;             would return [1,2,3].<br>&gt;&gt;&gt;&gt;             We can see this very behaviour in other languages, such as<br>&gt;&gt;&gt;&gt;         Python and<br>&gt;&gt;&gt;&gt;             Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             This would eliminate the need for verifications on the array size<br>&gt;&gt;&gt;&gt;             before slicing it -- and consequently runtime errors in cases<br>&gt;&gt;&gt;&gt;         when the<br>&gt;&gt;&gt;&gt;             programmer didn&#39;t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             Viewing that it is my very first proposal, any feedback will<br>&gt;&gt;&gt;&gt;         be helpful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             Luis Henrique Borges<br>&gt;&gt;&gt;&gt;             @luishborges<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/c313e976/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Yes @Matthew, I did; my very first draft sought to change the default<br>subscript method. However, there were some opinions against overriding the<br>default *fail fast* behaviour as it could result in more bugs and in an<br>overload to debug. It wasn&#39;t set in stone, so I think it&#39;s something that<br>could be discussed if this proposal goes to review.<br></p><p>- Luis<br></p><p>On Fri, May 6, 2016 at 5:22 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; Did you consider making the safer, optional overload the &quot;default&quot; and<br>&gt; just omit the label?<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 6, 2016, at 10:23 AM, Luis Henrique B. Sousa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &quot;bounded&quot; sounds good to me, but I don&#39;t know if &quot;optional&quot; is a good<br>&gt; choice as it could be highlighted as a reserved keyword:<br>&gt;<br>&gt;<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Fri, Apr 29, 2016 at 5:08 PM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; From my point of view,<br>&gt;&gt; truncate -&gt; bounded<br>&gt;&gt; lenient -&gt; keep &quot;lenient:&quot; ? &quot;requested:&quot; ? &quot;optional:&quot;?<br>&gt;&gt;<br>&gt;&gt; On 29.04.2016 17:46, Thorsten Seitz wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Some alternatives to &#39;safe:&#39;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; existing:<br>&gt;&gt;&gt; bounded:<br>&gt;&gt;&gt; valid:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 29.04.2016 um 00:20 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks Vladimir, your considerations and suggestions are totally valid,<br>&gt;&gt;&gt;&gt; I&#39;m going to change the document accordingly.<br>&gt;&gt;&gt;&gt; Also as a non-native English speaker I think that other words could fit<br>&gt;&gt;&gt;&gt; better, such as &#39;tolerant&#39; or &#39;permissive&#39; -- but I dunno if they would<br>&gt;&gt;&gt;&gt; look great as a label. We will come up with the right keyword for it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In relation to bad code, it could be a valid argument if my initial<br>&gt;&gt;&gt;&gt; proposal was under discussion instead, where the default &#39;fail fast&#39;<br>&gt;&gt;&gt;&gt; behaviour would be &quot;camouflaged&quot; and bugs would be more difficult to<br>&gt;&gt;&gt;&gt; catch. In this new proposal we have such features explicitly defined,<br>&gt;&gt;&gt;&gt; where the user will be familiar with what it does and what results to<br>&gt;&gt;&gt;&gt; expect for. I don&#39;t see a way that it could drive to bad written code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, Apr 28, 2016 at 2:37 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     I support this proposal. Probably we all should select the best<br>&gt;&gt;&gt;&gt;     labels (truncate/lenient or other). As not native English speaker, I<br>&gt;&gt;&gt;&gt;     don&#39;t feel like &#39;lenient&#39; is well-known word or often-used word in<br>&gt;&gt;&gt;&gt;     software development. But all this just a details we need to<br>&gt;&gt;&gt;&gt; discuss.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     What I think could be improved - is a motivation section. IMO the<br>&gt;&gt;&gt;&gt;     main purpose of proposed features is not to &quot;eliminate the need for<br>&gt;&gt;&gt;&gt;     validations, reduce the number of fatal errors in runtime&quot; but to<br>&gt;&gt;&gt;&gt;     allow us to have more clean code when *such validations just don&#39;t<br>&gt;&gt;&gt;&gt;     required*, when we just *don&#39;t care* about details.<br>&gt;&gt;&gt;&gt;     I.e. in situations, when we&#39;ll use [max(-1, a.startIndex) ..&lt; min(5,<br>&gt;&gt;&gt;&gt;     a.endIndex)] and bounds checking manually to have the same result as<br>&gt;&gt;&gt;&gt;     in proposed subscripts.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     I.e. it is just a very handy addition to standard methods for<br>&gt;&gt;&gt;&gt;     collections, just like we can get first element by index but we have<br>&gt;&gt;&gt;&gt;     handy property &#39;.first&#39; for this purpose. Btw, it does not raise<br>&gt;&gt;&gt;&gt;     error, but returns T?. I think you can add notes regarding analogues<br>&gt;&gt;&gt;&gt;     with .first / .last properties(and probably with other) in proposal<br>&gt;&gt;&gt;&gt; text.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Someone can argue, that by using these subscripts, coders can write<br>&gt;&gt;&gt;&gt;     &#39;bad&#39; code - but I can&#39;t accept such an argument - &#39;bad&#39; coders<br>&gt;&gt;&gt;&gt;     already can write &#39;bad&#39; code with other features of Swift and at the<br>&gt;&gt;&gt;&gt;     end they can implement these subscripts in their project and write<br>&gt;&gt;&gt;&gt;     &#39;bad&#39; code. Should we stop to introduce handy and explicit feature<br>&gt;&gt;&gt;&gt;     for &#39;good&#39; coders because of this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On 28.04.2016 15:11, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         As we have discussed throughout this thread, the initial<br>&gt;&gt;&gt;&gt; proposal was<br>&gt;&gt;&gt;&gt;         modified to include alternative subscript methods instead of<br>&gt;&gt;&gt;&gt;         modifying the<br>&gt;&gt;&gt;&gt;         default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;         The first draft is<br>&gt;&gt;&gt;&gt;         here:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         I&#39;ve also put this as a gist so that you can leave comments with<br>&gt;&gt;&gt;&gt;         respect to<br>&gt;&gt;&gt;&gt;         the proposal document itself. Any suggestion or help is very<br>&gt;&gt;&gt;&gt; welcome.<br>&gt;&gt;&gt;&gt;         https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Regards,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;         &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;         &lt;mailto:lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             This proposal seeks to provide a safer ..&lt; (aka half-open<br>&gt;&gt;&gt;&gt; range<br>&gt;&gt;&gt;&gt;             operator) in order to avoid **Array index out of range**<br>&gt;&gt;&gt;&gt;         errors in<br>&gt;&gt;&gt;&gt;             execution time.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             leta =[1,2,3]<br>&gt;&gt;&gt;&gt;             letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;             print(b)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             &gt; Error running code:<br>&gt;&gt;&gt;&gt;             &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             The proposed solution is to slice the array returning all<br>&gt;&gt;&gt;&gt;         elements that<br>&gt;&gt;&gt;&gt;             are below the half-open operator, even though the number of<br>&gt;&gt;&gt;&gt;         elements is<br>&gt;&gt;&gt;&gt;             lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;&gt;         example above<br>&gt;&gt;&gt;&gt;             would return [1,2,3].<br>&gt;&gt;&gt;&gt;             We can see this very behaviour in other languages, such as<br>&gt;&gt;&gt;&gt;         Python and<br>&gt;&gt;&gt;&gt;             Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             This would eliminate the need for verifications on the<br>&gt;&gt;&gt;&gt; array size<br>&gt;&gt;&gt;&gt;             before slicing it -- and consequently runtime errors in<br>&gt;&gt;&gt;&gt; cases<br>&gt;&gt;&gt;&gt;         when the<br>&gt;&gt;&gt;&gt;             programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             Viewing that it is my very first proposal, any feedback will<br>&gt;&gt;&gt;&gt;         be helpful.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             Thanks!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             Luis Henrique Borges<br>&gt;&gt;&gt;&gt;             @luishborges<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/2f7245fa/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; lenient -&gt; keep &quot;lenient:&quot; ? &quot;requested:&quot; ? &quot;optional:&quot;?<br></p><p>`checking:`, to indicate that the index will be checked before it&#39;s used?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>Sounds good for me.<br></p><p>How about:<br></p><p>a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside: -1 ..&lt; 5] )<br></p><p>a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>a[optional: 5]        --&gt;  a[checking: 5]<br></p><p>?<br></p><p>On 10.05.2016 4:29, Brent Royal-Gordon wrote:<br>&gt;&gt; lenient -&gt; keep &quot;lenient:&quot; ? &quot;requested:&quot; ? &quot;optional:&quot;?<br>&gt;<br>&gt; `checking:`, to indicate that the index will be checked before it&#39;s used?<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections (was: [Proposal] Safer half-open range operator)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 10, 2016 at 01:00:00pm</p></header><div class="content"><p>I like the idea of the of the bounded subscript, however the optional one I feel could be used for clumsy code.<br></p><p>.first and .last have value, but once you start stepping several arbitrary indices in, then that code is likely fragile?<br></p><p><br>I can think of ‘within’, ‘inside’ and ‘intersecting’ as alternative names for ‘bounded’ that attempt to explain what is going on:<br></p><p>let a = [1, 2, 3]<br></p><p>a[within: 0 ..&lt; 5] // [1, 2, 3]<br>a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br></p><p><br>&gt; On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As we have discussed throughout this thread, the initial proposal was modified to include alternative subscript methods instead of modifying the default operator/subscript behaviour. <br>&gt; The first draft is here: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md &lt;https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md&gt;<br>&gt; <br>&gt; I&#39;ve also put this as a gist so that you can leave comments with respect to the proposal document itself. Any suggestion or help is very welcome.<br>&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8 &lt;https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8&gt;<br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator) in order to avoid **Array index out of range** errors in execution time.<br>&gt; <br>&gt; Here is my first draft for this proposal: https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md &lt;https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md&gt;<br>&gt; <br>&gt; In short, doing that in Swift causes a runtime error:<br>&gt; let a = [1,2,3]<br>&gt; let b = a[0..&lt;5]<br>&gt; print(b)<br>&gt; <br>&gt; &gt; Error running code: <br>&gt; &gt; fatal error: Array index out of range<br>&gt; <br>&gt; The proposed solution is to slice the array returning all elements that are below the half-open operator, even though the number of elements is lesser than the ending of the half-open operator. So the example above would return [1,2,3]. <br>&gt; We can see this very behaviour in other languages, such as Python and Ruby as shown in the proposal draft.<br>&gt; <br>&gt; This would eliminate the need for verifications on the array size before slicing it -- and consequently runtime errors in cases when the programmer didn&#39;t. <br>&gt; <br>&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; Luis Henrique Borges<br>&gt; @luishborges<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/307399c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br></p><p>How about such changes in proposal:<br></p><p>a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside: -1 ..&lt; 5] )<br></p><p>a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>a[optional: 5]        --&gt;  a[checking: 5]<br></p><p>?<br></p><p>On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt; I like the idea of the of the bounded subscript, however the optional one I<br>&gt; feel could be used for clumsy code.<br>&gt;<br>&gt; .first and .last have value, but once you start stepping several arbitrary<br>&gt; indices in, then that code is likely fragile?<br>&gt;<br>&gt;<br>&gt; I can think of ‘within’, ‘inside’ and ‘intersecting’ as alternative names<br>&gt; for ‘bounded’ that attempt to explain what is going on:<br>&gt;<br>&gt; let a = [1, 2, 3]<br>&gt;<br>&gt; a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt; a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt; a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;<br>&gt;<br>&gt;&gt; On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt; modified to include alternative subscript methods instead of modifying<br>&gt;&gt; the default operator/subscript behaviour.<br>&gt;&gt; The first draft is<br>&gt;&gt; here: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with respect<br>&gt;&gt; to the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;     execution time.<br>&gt;&gt;<br>&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;<br>&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;     print(b)<br>&gt;&gt;<br>&gt;&gt;     &gt; Error running code:<br>&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;<br>&gt;&gt;     The proposed solution is to slice the array returning all elements<br>&gt;&gt;     that are below the half-open operator, even though the number of<br>&gt;&gt;     elements is lesser than the ending of the half-open operator. So the<br>&gt;&gt;     example above would return [1,2,3].<br>&gt;&gt;     We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;<br>&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;     before slicing it -- and consequently runtime errors in cases when<br>&gt;&gt;     the programmer didn&#39;t.<br>&gt;&gt;<br>&gt;&gt;     Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;&gt;<br>&gt;&gt;     Thanks!<br>&gt;&gt;<br>&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;     @luishborges<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br></p><p>I&#39;ve just updated the proposal:<br>https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br></p><p>- Luis<br></p><p>On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;<br>&gt; How about such changes in proposal:<br>&gt;<br>&gt; a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside: -1 ..&lt; 5] )<br>&gt;<br>&gt; a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt; a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;<br>&gt;&gt; I like the idea of the of the bounded subscript, however the optional one<br>&gt;&gt; I<br>&gt;&gt; feel could be used for clumsy code.<br>&gt;&gt;<br>&gt;&gt; .first and .last have value, but once you start stepping several arbitrary<br>&gt;&gt; indices in, then that code is likely fragile?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I can think of ‘within’, ‘inside’ and ‘intersecting’ as alternative names<br>&gt;&gt; for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;<br>&gt;&gt; let a = [1, 2, 3]<br>&gt;&gt;<br>&gt;&gt; a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt; a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt; a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;&gt; modified to include alternative subscript methods instead of modifying<br>&gt;&gt;&gt; the default operator/subscript behaviour.<br>&gt;&gt;&gt; The first draft is<br>&gt;&gt;&gt; here:<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with respect<br>&gt;&gt;&gt; to the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;&gt;     execution time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;&gt;     print(b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt; Error running code:<br>&gt;&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     The proposed solution is to slice the array returning all elements<br>&gt;&gt;&gt;     that are below the half-open operator, even though the number of<br>&gt;&gt;&gt;     elements is lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;     example above would return [1,2,3].<br>&gt;&gt;&gt;     We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;&gt;     before slicing it -- and consequently runtime errors in cases when<br>&gt;&gt;&gt;     the programmer didn&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Viewing that it is my very first proposal, any feedback will be<br>&gt;&gt;&gt; helpful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;&gt;     @luishborges<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/43d3dbf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Please let me know if you have more suggestions or corrections on this<br>proposal.<br>I&#39;m tempted to submit it for review. :-)<br></p><p>- Luis<br></p><p>On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;<br>wrote:<br></p><p>&gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br>&gt;<br>&gt; I&#39;ve just updated the proposal:<br>&gt;<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;<br>&gt;&gt; How about such changes in proposal:<br>&gt;&gt;<br>&gt;&gt; a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside: -1 ..&lt; 5] )<br>&gt;&gt;<br>&gt;&gt; a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt; a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;<br>&gt;&gt; ?<br>&gt;&gt;<br>&gt;&gt; On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I like the idea of the of the bounded subscript, however the optional<br>&gt;&gt;&gt; one I<br>&gt;&gt;&gt; feel could be used for clumsy code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; .first and .last have value, but once you start stepping several<br>&gt;&gt;&gt; arbitrary<br>&gt;&gt;&gt; indices in, then that code is likely fragile?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can think of ‘within’, ‘inside’ and ‘intersecting’ as alternative names<br>&gt;&gt;&gt; for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let a = [1, 2, 3]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt; a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt; a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;&gt;&gt; modified to include alternative subscript methods instead of modifying<br>&gt;&gt;&gt;&gt; the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt; The first draft is<br>&gt;&gt;&gt;&gt; here:<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with respect<br>&gt;&gt;&gt;&gt; to the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;&gt;&gt;     execution time.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;     print(b)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt; Error running code:<br>&gt;&gt;&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     The proposed solution is to slice the array returning all elements<br>&gt;&gt;&gt;&gt;     that are below the half-open operator, even though the number of<br>&gt;&gt;&gt;&gt;     elements is lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;&gt;     example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;     We can see this very behaviour in other languages, such as Python<br>&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;&gt;&gt;     before slicing it -- and consequently runtime errors in cases when<br>&gt;&gt;&gt;&gt;     the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Viewing that it is my very first proposal, any feedback will be<br>&gt;&gt;&gt;&gt; helpful.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Thanks!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;&gt;&gt;     @luishborges<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/4848bc15/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 13, 2016 at 04:00:00pm</p></header><div class="content"><p>It seems that there is a consensus that this proposal might be a good<br>addition to the standard library. All comments on this thread in the past<br>few weeks were related to naming, not around the behaviour or validity of<br>the proposed methods. So I will submit this proposal for review very soon<br>assuming that nobody else has strong arguments against it. :-)<br></p><p>Proposal:<br>https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br></p><p>If you have any corrections or suggestions to the proposal text itself,<br>please comment on this gist:<br>https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>(or pull request to my repo)<br></p><p>Regards,<br></p><p>- Luis<br></p><p>On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;<br>wrote:<br></p><p>&gt; Please let me know if you have more suggestions or corrections on this<br>&gt; proposal.<br>&gt; I&#39;m tempted to submit it for review. :-)<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa &lt;<br>&gt; lshsousa at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve just updated the proposal:<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How about such changes in proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside: -1 ..&lt; 5] )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt; a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like the idea of the of the bounded subscript, however the optional<br>&gt;&gt;&gt;&gt; one I<br>&gt;&gt;&gt;&gt; feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; .first and .last have value, but once you start stepping several<br>&gt;&gt;&gt;&gt; arbitrary<br>&gt;&gt;&gt;&gt; indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I can think of ‘within’, ‘inside’ and ‘intersecting’ as alternative<br>&gt;&gt;&gt;&gt; names<br>&gt;&gt;&gt;&gt; for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt; a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt; a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;&gt;&gt;&gt; modified to include alternative subscript methods instead of modifying<br>&gt;&gt;&gt;&gt;&gt; the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt; The first draft is<br>&gt;&gt;&gt;&gt;&gt; here:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with<br>&gt;&gt;&gt;&gt;&gt; respect<br>&gt;&gt;&gt;&gt;&gt; to the proposal document itself. Any suggestion or help is very<br>&gt;&gt;&gt;&gt;&gt; welcome.<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;&gt;&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;&gt;&gt;&gt;     execution time.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;     print(b)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     The proposed solution is to slice the array returning all elements<br>&gt;&gt;&gt;&gt;&gt;     that are below the half-open operator, even though the number of<br>&gt;&gt;&gt;&gt;&gt;     elements is lesser than the ending of the half-open operator. So<br>&gt;&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;     example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;     We can see this very behaviour in other languages, such as Python<br>&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;&gt;&gt;&gt;     before slicing it -- and consequently runtime errors in cases when<br>&gt;&gt;&gt;&gt;&gt;     the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Viewing that it is my very first proposal, any feedback will be<br>&gt;&gt;&gt;&gt;&gt; helpful.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Thanks!<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;     @luishborges<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/e8348a33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>May 14, 2016 at 11:00:00pm</p></header><div class="content"><p>One point which should be discussed is the following behaviour:<br></p><p>let array = [0]<br>// ranges are completely out of bounds and produce an error<br>array[clamping: 1...2] // error<br>array[clamping: -2...-1] // error<br></p><p>Should a range which has no intersection with the indices of the collection produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br></p><p>Best regards<br>Maximilian<br></p><p>&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; It seems that there is a consensus that this proposal might be a good addition to the standard library. All comments on this thread in the past few weeks were related to naming, not around the behaviour or validity of the proposed methods. So I will submit this proposal for review very soon assuming that nobody else has strong arguments against it. :-)<br>&gt; <br>&gt; Proposal: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt; <br>&gt; If you have any corrections or suggestions to the proposal text itself, please comment on this gist:<br>&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt; (or pull request to my repo)<br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt; wrote:<br>&gt;&gt; Please let me know if you have more suggestions or corrections on this proposal. <br>&gt;&gt; I&#39;m tempted to submit it for review. :-)<br>&gt;&gt; <br>&gt;&gt; - Luis<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt; wrote:<br>&gt;&gt;&gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve just updated the proposal: <br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about such changes in proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside: -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt; a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; I like the idea of the of the bounded subscript, however the optional one I<br>&gt;&gt;&gt;&gt;&gt; feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .first and .last have value, but once you start stepping several arbitrary<br>&gt;&gt;&gt;&gt;&gt; indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can think of ‘within’, ‘inside’ and ‘intersecting’ as alternative names<br>&gt;&gt;&gt;&gt;&gt; for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt; a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt; a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As we have discussed throughout this thread, the initial proposal was<br>&gt;&gt;&gt;&gt;&gt;&gt; modified to include alternative subscript methods instead of modifying<br>&gt;&gt;&gt;&gt;&gt;&gt; the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt; The first draft is<br>&gt;&gt;&gt;&gt;&gt;&gt; here: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve also put this as a gist so that you can leave comments with respect<br>&gt;&gt;&gt;&gt;&gt;&gt; to the proposal document itself. Any suggestion or help is very welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;&gt;&gt;&gt;&gt;     operator) in order to avoid **Array index out of range** errors in<br>&gt;&gt;&gt;&gt;&gt;&gt;     execution time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;&gt;     letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;&gt;     print(b)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;&gt;     &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     The proposed solution is to slice the array returning all elements<br>&gt;&gt;&gt;&gt;&gt;&gt;     that are below the half-open operator, even though the number of<br>&gt;&gt;&gt;&gt;&gt;&gt;     elements is lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;&gt;&gt;&gt;     example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;&gt;     We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;&gt;&gt;&gt;&gt;     Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     This would eliminate the need for verifications on the array size<br>&gt;&gt;&gt;&gt;&gt;&gt;     before slicing it -- and consequently runtime errors in cases when<br>&gt;&gt;&gt;&gt;&gt;&gt;     the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;&gt;     @luishborges<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/30946f01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 15, 2016 at 12:00:00pm</p></header><div class="content"><p>On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt; One point which should be discussed is the following behaviour:<br>&gt;<br>&gt; let array = [0]<br>&gt; // ranges are completely out of bounds and produce an error<br>&gt; array[clamping: 1...2] // error<br>&gt; array[clamping: -2...-1] // error<br>&gt;<br>&gt; Should a range which has no intersection with the indices of the collection<br>&gt; produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br></p><p>I expect it will returns [] i.e. empty array, as no elements with <br>1...2(-2..-1) indexes in the array. I understand `clamping` similar as <br>&#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10] <br>will silently move the right position to allowed index(4), and <br>[0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that <br>in [0][clamping: 1...2] will try to move both limits to allowed, and as no <br>intersection - silently return empty array.<br></p><p>&gt;<br>&gt; Best regards<br>&gt; Maximilian<br>&gt;<br>&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt; addition to the standard library. All comments on this thread in the past<br>&gt;&gt; few weeks were related to naming, not around the behaviour or validity of<br>&gt;&gt; the proposed methods. So I will submit this proposal for review very soon<br>&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;<br>&gt;&gt; Proposal: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt; please comment on this gist:<br>&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt; (or pull request to my repo)<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;     this proposal.<br>&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;<br>&gt;&gt;     - Luis<br>&gt;&gt;<br>&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;         and @Brent.<br>&gt;&gt;<br>&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;<br>&gt;&gt;         - Luis<br>&gt;&gt;<br>&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;<br>&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;<br>&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside:<br>&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;<br>&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;<br>&gt;&gt;             ?<br>&gt;&gt;<br>&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;                 I like the idea of the of the bounded subscript, however<br>&gt;&gt;                 the optional one I<br>&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;<br>&gt;&gt;                 .first and .last have value, but once you start stepping<br>&gt;&gt;                 several arbitrary<br>&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;                 alternative names<br>&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;<br>&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;<br>&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;                     via swift-evolution<br>&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;                     initial proposal was<br>&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;                     instead of modifying<br>&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;                     The first draft is<br>&gt;&gt;                     here:<br>&gt;&gt;                     https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;<br>&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;                     comments with respect<br>&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;                     help is very welcome.<br>&gt;&gt;                     https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;<br>&gt;&gt;                     Regards,<br>&gt;&gt;<br>&gt;&gt;                     - Luis<br>&gt;&gt;<br>&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;                     half-open range<br>&gt;&gt;                         operator) in order to avoid **Array index out of<br>&gt;&gt;                     range** errors in<br>&gt;&gt;                         execution time.<br>&gt;&gt;<br>&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;<br>&gt;&gt;                     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt;                         In short, doing that in Swift causes a runtime error:<br>&gt;&gt;<br>&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;                         print(b)<br>&gt;&gt;<br>&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;<br>&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;                     returning all elements<br>&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;                     though the number of<br>&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;                     half-open operator. So the<br>&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;                     languages, such as Python and<br>&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;<br>&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;                     on the array size<br>&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;                     errors in cases when<br>&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;<br>&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;<br>&gt;&gt;                         Thanks!<br>&gt;&gt;<br>&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;                         @luishborges<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                     _______________________________________________<br>&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 _______________________________________________<br>&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;             _______________________________________________<br>&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Exactly, the idea is to return an empty array just like other languages do.<br>(e.g. python)<br></p><p>- Luis<br></p><p>On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;<br>&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;<br>&gt;&gt; let array = [0]<br>&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;<br>&gt;&gt; Should a range which has no intersection with the indices of the<br>&gt;&gt; collection<br>&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br>&gt;&gt;<br>&gt;<br>&gt; I expect it will returns [] i.e. empty array, as no elements with<br>&gt; 1...2(-2..-1) indexes in the array. I understand `clamping` similar as<br>&gt; &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10]<br>&gt; will silently move the right position to allowed index(4), and<br>&gt; [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that<br>&gt; in [0][clamping: 1...2] will try to move both limits to allowed, and as no<br>&gt; intersection - silently return empty array.<br>&gt;<br>&gt;<br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt;<br>&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt; addition to the standard library. All comments on this thread in the past<br>&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or validity of<br>&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very soon<br>&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside:<br>&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 I like the idea of the of the bounded subscript, however<br>&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 .first and .last have value, but once you start stepping<br>&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B.<br>&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;                         operator) in order to avoid **Array index out of<br>&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         In short, doing that in Swift causes a runtime<br>&gt;&gt;&gt; error:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/9fd3a017/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>May 15, 2016 at 04:00:00pm</p></header><div class="content"><p>I brought these up because the current implementation produces an error in these cases. You have to insert additional min/max operations.<br></p><p>&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;:<br>&gt; <br>&gt; Exactly, the idea is to return an empty array just like other languages do. (e.g. python)<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt;&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should a range which has no intersection with the indices of the collection<br>&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br>&gt;&gt; <br>&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with 1...2(-2..-1) indexes in the array. I understand `clamping` similar as &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10] will silently move the right position to allowed index(4), and [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that in [0][clamping: 1...2] will try to move both limits to allowed, and as no intersection - silently return empty array.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the past<br>&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or validity of<br>&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very soon<br>&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside:<br>&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript, however<br>&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start stepping<br>&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;                     https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;                     https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out of<br>&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/079a898c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>Yes. The suggested implementation does use min/max:<br></p><p>https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br></p><p>- Luis<br></p><p>On Sun, May 15, 2016 at 3:42 PM, Maximilian Hünenberger &lt;<br>m.huenenberger at me.com&gt; wrote:<br></p><p>&gt; I brought these up because the current implementation produces an error in<br>&gt; these cases. You have to insert additional min/max operations.<br>&gt;<br>&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt; &gt;:<br>&gt;<br>&gt; Exactly, the idea is to return an empty array just like other languages<br>&gt; do. (e.g. python)<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Should a range which has no intersection with the indices of the<br>&gt;&gt;&gt; collection<br>&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with<br>&gt;&gt; 1...2(-2..-1) indexes in the array. I understand `clamping` similar as<br>&gt;&gt; &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10]<br>&gt;&gt; will silently move the right position to allowed index(4), and<br>&gt;&gt; [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that<br>&gt;&gt; in [0][clamping: 1...2] will try to move both limits to allowed, and as no<br>&gt;&gt; intersection - silently return empty array.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the<br>&gt;&gt;&gt;&gt; past<br>&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or validity<br>&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very<br>&gt;&gt;&gt;&gt; soon<br>&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or<br>&gt;&gt;&gt;&gt; a[inside:<br>&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript, however<br>&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start stepping<br>&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B.<br>&gt;&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out of<br>&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a runtime<br>&gt;&gt;&gt;&gt; error:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/ae6e9ade/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>May 17, 2016 at 11:00:00pm</p></header><div class="content"><p>While it is true that it uses min and max, you have to add additional min max in order to achieve the desired behavior.<br></p><p>So the implementation should be: (also considering (hopefully all) recent naming/index model updates)<br></p><p>// Index is already Comparable<br>extension Collection {<br></p><p>    subscript(clamping range: Range&lt;Index&gt;) -&gt; SubSequence {<br>        // ---&gt; here you have to use the additional min/max<br>        let start = min(max(startIndex, range.startIndex), endIndex)<br>        let end = max(min(endIndex, range.endIndex), startIndex)<br>        return self[start ..&lt; end]<br></p><p>        // ---&gt; or as alternative, probably a bit less performant but Swiftier<br>        return self[range.clamping(startIndex..&lt;endIndex)]<br>    }<br></p><p>    subscript(checking range: Range&lt;Index&gt;) -&gt; SubSequence? {<br>        guard range.startIndex &gt;= startIndex &amp;&amp; range.endIndex &lt;= endIndex<br>            else { return nil }<br>        return self[range]<br>    }<br></p><p>    subscript(checking index: Index) -&gt; Generator.Element? {<br>        // ---&gt; minor syntax update *<br>        guard self.indices.contains(index)<br>            else { return nil }<br>        return self[index]<br>    }<br></p><p>}<br></p><p>* I&#39;m not sure it is worth the performance cost for arbitrary indices collection with O(n) search. I could imagine Set and Dictionary indices cannot be easily validated in comparison to Array indices. However this approach is more general and handles non trivial index collections where there is no guarantee that any index between startIndex and endIndex is a valid one.<br>The same arguments also apply to `subscript(checking range ...)` where you could validate start and endIndex of the range. <br></p><p>Best regards<br>Maximilian<br></p><p>&gt; Am 16.05.2016 um 09:45 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;:<br>&gt; <br>&gt; Yes. The suggested implementation does use min/max:<br>&gt; <br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt;&gt; On Sun, May 15, 2016 at 3:42 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; I brought these up because the current implementation produces an error in these cases. You have to insert additional min/max operations.<br>&gt;&gt; <br>&gt;&gt;&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly, the idea is to return an empty array just like other languages do. (e.g. python)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Should a range which has no intersection with the indices of the collection<br>&gt;&gt;&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with 1...2(-2..-1) indexes in the array. I understand `clamping` similar as &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10] will silently move the right position to allowed index(4), and [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that in [0][clamping: 1...2] will try to move both limits to allowed, and as no intersection - silently return empty array.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the past<br>&gt;&gt;&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or validity of<br>&gt;&gt;&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very soon<br>&gt;&gt;&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt;&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside:<br>&gt;&gt;&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript, however<br>&gt;&gt;&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start stepping<br>&gt;&gt;&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;&gt;&gt;                     https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt;                     https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out of<br>&gt;&gt;&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/5c7c7405/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 17, 2016 at 11:00:00pm</p></header><div class="content"><p>Many thanks, @Maximilian. I&#39;m also not sure about the performance cost, but<br>I think it is worth it.<br>So I just updated the proposal also including the additional min/max you<br>have suggested (thanks once again):<br>https://github.com/apple/swift-evolution/pull/328<br></p><p>Best regards,<br></p><p>- Luis<br></p><p>On Tue, May 17, 2016 at 10:32 PM, Maximilian Hünenberger &lt;<br>m.huenenberger at me.com&gt; wrote:<br></p><p>&gt; While it is true that it uses min and max, you have to add *additional<br>&gt; min max* in order to achieve the desired behavior.<br>&gt;<br>&gt; So the implementation should be: (also considering (hopefully all) recent<br>&gt; naming/index model updates)<br>&gt;<br>&gt; // Index is already Comparable<br>&gt; extension Collection {<br>&gt;<br>&gt;     subscript(clamping range: Range&lt;Index&gt;) -&gt; SubSequence {<br>&gt;         // ---&gt; here you have to use the additional min/max<br>&gt;         let start = min(max(startIndex, range.startIndex), endIndex)<br>&gt;         let end = max(min(endIndex, range.endIndex), startIndex)<br>&gt;         return self[start ..&lt; end]<br>&gt;<br>&gt;         // ---&gt; or as alternative, probably a bit less performant but<br>&gt; Swiftier<br>&gt;         return self[range.clamping(startIndex..&lt;endIndex)]<br>&gt;     }<br>&gt;<br>&gt;     subscript(checking range: Range&lt;Index&gt;) -&gt; SubSequence? {<br>&gt;         guard range.startIndex &gt;= startIndex &amp;&amp; range.endIndex &lt;= endIndex<br>&gt;             else { return nil }<br>&gt;         return self[range]<br>&gt;     }<br>&gt;<br>&gt;     subscript(checking index: Index) -&gt; Generator.Element? {<br>&gt;         // ---&gt; minor syntax update *<br>&gt;         guard self.indices.contains(index)<br>&gt;             else { return nil }<br>&gt;         return self[index]<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; * I&#39;m not sure it is worth the performance cost for arbitrary indices<br>&gt; collection with O(n) search. I could imagine Set and Dictionary indices<br>&gt; cannot be easily validated in comparison to Array indices. However this<br>&gt; approach is more general and handles non trivial index collections where<br>&gt; there is no guarantee that any index between startIndex and endIndex is a<br>&gt; valid one.<br>&gt; The same arguments also apply to `subscript(checking range ...)` where you<br>&gt; could validate start and endIndex of the range.<br>&gt;<br>&gt; Best regards<br>&gt; Maximilian<br>&gt;<br>&gt; Am 16.05.2016 um 09:45 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt; &gt;:<br>&gt;<br>&gt; Yes. The suggested implementation does use min/max:<br>&gt;<br>&gt;<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Sun, May 15, 2016 at 3:42 PM, Maximilian Hünenberger &lt;<br>&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; I brought these up because the current implementation produces an error<br>&gt;&gt; in these cases. You have to insert additional min/max operations.<br>&gt;&gt;<br>&gt;&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt; &gt;:<br>&gt;&gt;<br>&gt;&gt; Exactly, the idea is to return an empty array just like other languages<br>&gt;&gt; do. (e.g. python)<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Should a range which has no intersection with the indices of the<br>&gt;&gt;&gt;&gt; collection<br>&gt;&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively<br>&gt;&gt;&gt;&gt; endIndex..&lt;endIndex?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with<br>&gt;&gt;&gt; 1...2(-2..-1) indexes in the array. I understand `clamping` similar as<br>&gt;&gt;&gt; &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10]<br>&gt;&gt;&gt; will silently move the right position to allowed index(4), and<br>&gt;&gt;&gt; [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that<br>&gt;&gt;&gt; in [0][clamping: 1...2] will try to move both limits to allowed, and as no<br>&gt;&gt;&gt; intersection - silently return empty array.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via<br>&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the<br>&gt;&gt;&gt;&gt;&gt; past<br>&gt;&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or validity<br>&gt;&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very<br>&gt;&gt;&gt;&gt;&gt; soon<br>&gt;&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or<br>&gt;&gt;&gt;&gt;&gt; a[inside:<br>&gt;&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript,<br>&gt;&gt;&gt;&gt;&gt; however<br>&gt;&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start<br>&gt;&gt;&gt;&gt;&gt; stepping<br>&gt;&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B.<br>&gt;&gt;&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out<br>&gt;&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a runtime<br>&gt;&gt;&gt;&gt;&gt; error:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/97e32dff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>May 17, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 17, 2016, at 5:18 PM, Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Many thanks, @Maximilian. I&#39;m also not sure about the performance cost, but I think it is worth it. <br>&gt; So I just updated the proposal also including the additional min/max you have suggested (thanks once again):<br>&gt; https://github.com/apple/swift-evolution/pull/328<br>&gt; <br>&gt; Best regards,<br>&gt; <br>&gt; - Luis<br></p><p>The new Range types have a clamped(to:) method that should do what you need.<br></p><p>http://swiftdoc.org/v3.0/type/Range/#func-clamped-to_<br></p><p>&gt;&gt; On Tue, May 17, 2016 at 10:32 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; While it is true that it uses min and max, you have to add additional min max in order to achieve the desired behavior.<br>&gt;&gt; <br>&gt;&gt; So the implementation should be: (also considering (hopefully all) recent naming/index model updates)<br>&gt;&gt; <br>&gt;&gt; // Index is already Comparable<br>&gt;&gt; extension Collection {<br>&gt;&gt; <br>&gt;&gt;     subscript(clamping range: Range&lt;Index&gt;) -&gt; SubSequence {<br>&gt;&gt;         // ---&gt; here you have to use the additional min/max<br>&gt;&gt;         let start = min(max(startIndex, range.startIndex), endIndex)<br>&gt;&gt;         let end = max(min(endIndex, range.endIndex), startIndex)<br>&gt;&gt;         return self[start ..&lt; end]<br>&gt;&gt; <br>&gt;&gt;         // ---&gt; or as alternative, probably a bit less performant but Swiftier<br>&gt;&gt;         return self[range.clamping(startIndex..&lt;endIndex)]<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     subscript(checking range: Range&lt;Index&gt;) -&gt; SubSequence? {<br>&gt;&gt;         guard range.startIndex &gt;= startIndex &amp;&amp; range.endIndex &lt;= endIndex<br>&gt;&gt;             else { return nil }<br>&gt;&gt;         return self[range]<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     subscript(checking index: Index) -&gt; Generator.Element? {<br>&gt;&gt;         // ---&gt; minor syntax update *<br>&gt;&gt;         guard self.indices.contains(index)<br>&gt;&gt;             else { return nil }<br>&gt;&gt;         return self[index]<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; * I&#39;m not sure it is worth the performance cost for arbitrary indices collection with O(n) search. I could imagine Set and Dictionary indices cannot be easily validated in comparison to Array indices. However this approach is more general and handles non trivial index collections where there is no guarantee that any index between startIndex and endIndex is a valid one.<br>&gt;&gt; The same arguments also apply to `subscript(checking range ...)` where you could validate start and endIndex of the range. <br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 16.05.2016 um 09:45 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. The suggested implementation does use min/max:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, May 15, 2016 at 3:42 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I brought these up because the current implementation produces an error in these cases. You have to insert additional min/max operations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Exactly, the idea is to return an empty array just like other languages do. (e.g. python)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Should a range which has no intersection with the indices of the collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively endIndex..&lt;endIndex?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with 1...2(-2..-1) indexes in the array. I understand `clamping` similar as &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10] will silently move the right position to allowed index(4), and [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that in [0][clamping: 1...2] will try to move both limits to allowed, and as no intersection - silently return empty array.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the past<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or validity of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very soon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text itself,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or a[inside:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript, however<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start stepping<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’ as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going on:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt; (aka<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         This would eliminate the need for verifications<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/b53d6eb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 18, 2016 at 09:00:00am</p></header><div class="content"><p>Yes @Nate, thanks for pointing that out. It was mentioned here:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014807.html<br></p><p>You mean it should do what we need in order to avoid those min/max<br>operations, right? Just asking because the discussion before (in the link<br>above) was regards to the validity of this proposal considering that we<br>could have exactly the same behaviour if using `Range.clamped(to:)` before<br>applying the `subscript(range:)`. But I think our arguments on having a<br>more clear and handy way to do that are valid so far.<br></p><p>- Luis<br></p><p>On Tue, May 17, 2016 at 11:54 PM, Nate Cook &lt;nate at natecook.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 17, 2016, at 5:18 PM, Luis Henrique B. Sousa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Many thanks, @Maximilian. I&#39;m also not sure about the performance cost,<br>&gt; but I think it is worth it.<br>&gt; So I just updated the proposal also including the additional min/max you<br>&gt; have suggested (thanks once again):<br>&gt; https://github.com/apple/swift-evolution/pull/328<br>&gt;<br>&gt; Best regards,<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt;<br>&gt; The new Range types have a clamped(to:) method that should do what you<br>&gt; need.<br>&gt;<br>&gt; http://swiftdoc.org/v3.0/type/Range/#func-clamped-to_<br>&gt;<br>&gt; On Tue, May 17, 2016 at 10:32 PM, Maximilian Hünenberger &lt;<br>&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; While it is true that it uses min and max, you have to add *additional<br>&gt;&gt; min max* in order to achieve the desired behavior.<br>&gt;&gt;<br>&gt;&gt; So the implementation should be: (also considering (hopefully all) recent<br>&gt;&gt; naming/index model updates)<br>&gt;&gt;<br>&gt;&gt; // Index is already Comparable<br>&gt;&gt; extension Collection {<br>&gt;&gt;<br>&gt;&gt;     subscript(clamping range: Range&lt;Index&gt;) -&gt; SubSequence {<br>&gt;&gt;         // ---&gt; here you have to use the additional min/max<br>&gt;&gt;         let start = min(max(startIndex, range.startIndex), endIndex)<br>&gt;&gt;         let end = max(min(endIndex, range.endIndex), startIndex)<br>&gt;&gt;         return self[start ..&lt; end]<br>&gt;&gt;<br>&gt;&gt;         // ---&gt; or as alternative, probably a bit less performant but<br>&gt;&gt; Swiftier<br>&gt;&gt;         return self[range.clamping(startIndex..&lt;endIndex)]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     subscript(checking range: Range&lt;Index&gt;) -&gt; SubSequence? {<br>&gt;&gt;         guard range.startIndex &gt;= startIndex &amp;&amp; range.endIndex &lt;= endIndex<br>&gt;&gt;             else { return nil }<br>&gt;&gt;         return self[range]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     subscript(checking index: Index) -&gt; Generator.Element? {<br>&gt;&gt;         // ---&gt; minor syntax update *<br>&gt;&gt;         guard self.indices.contains(index)<br>&gt;&gt;             else { return nil }<br>&gt;&gt;         return self[index]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; * I&#39;m not sure it is worth the performance cost for arbitrary indices<br>&gt;&gt; collection with O(n) search. I could imagine Set and Dictionary indices<br>&gt;&gt; cannot be easily validated in comparison to Array indices. However this<br>&gt;&gt; approach is more general and handles non trivial index collections where<br>&gt;&gt; there is no guarantee that any index between startIndex and endIndex is a<br>&gt;&gt; valid one.<br>&gt;&gt; The same arguments also apply to `subscript(checking range ...)` where<br>&gt;&gt; you could validate start and endIndex of the range.<br>&gt;&gt;<br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt;<br>&gt;&gt; Am 16.05.2016 um 09:45 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt; &gt;:<br>&gt;&gt;<br>&gt;&gt; Yes. The suggested implementation does use min/max:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Sun, May 15, 2016 at 3:42 PM, Maximilian Hünenberger &lt;<br>&gt;&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I brought these up because the current implementation produces an error<br>&gt;&gt;&gt; in these cases. You have to insert additional min/max operations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;<br>&gt;&gt;&gt; lshsousa at gmail.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Exactly, the idea is to return an empty array just like other languages<br>&gt;&gt;&gt; do. (e.g. python)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Should a range which has no intersection with the indices of the<br>&gt;&gt;&gt;&gt;&gt; collection<br>&gt;&gt;&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively<br>&gt;&gt;&gt;&gt;&gt; endIndex..&lt;endIndex?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with<br>&gt;&gt;&gt;&gt; 1...2(-2..-1) indexes in the array. I understand `clamping` similar as<br>&gt;&gt;&gt;&gt; &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10]<br>&gt;&gt;&gt;&gt; will silently move the right position to allowed index(4), and<br>&gt;&gt;&gt;&gt; [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that<br>&gt;&gt;&gt;&gt; in [0][clamping: 1...2] will try to move both limits to allowed, and as no<br>&gt;&gt;&gt;&gt; intersection - silently return empty array.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via<br>&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the<br>&gt;&gt;&gt;&gt;&gt;&gt; past<br>&gt;&gt;&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or<br>&gt;&gt;&gt;&gt;&gt;&gt; validity of<br>&gt;&gt;&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very<br>&gt;&gt;&gt;&gt;&gt;&gt; soon<br>&gt;&gt;&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text<br>&gt;&gt;&gt;&gt;&gt;&gt; itself,<br>&gt;&gt;&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or<br>&gt;&gt;&gt;&gt;&gt;&gt; a[inside:<br>&gt;&gt;&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript,<br>&gt;&gt;&gt;&gt;&gt;&gt; however<br>&gt;&gt;&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start<br>&gt;&gt;&gt;&gt;&gt;&gt; stepping<br>&gt;&gt;&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’<br>&gt;&gt;&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going<br>&gt;&gt;&gt;&gt;&gt;&gt; on:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B.<br>&gt;&gt;&gt;&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B.<br>&gt;&gt;&gt;&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; (aka<br>&gt;&gt;&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out<br>&gt;&gt;&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a<br>&gt;&gt;&gt;&gt;&gt;&gt; runtime error:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         This would eliminate the need for<br>&gt;&gt;&gt;&gt;&gt;&gt; verifications<br>&gt;&gt;&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/883ac8e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>July 19, 2016 at 11:00:00am</p></header><div class="content"><p>As regards some comments in the pull request<br>&lt;https://github.com/apple/swift-evolution/pull/328&gt; (thanks @Adriano<br>Ferreira), I have updated the implementation<br>&lt;https://github.com/luish/swift-evolution/blob/proposal-lenient-collection-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design&gt;<br>to<br>Swift 3.0. It now uses `clamped(to:)` as suggested by @Nate -- I think it<br>does look much more elegant. :-)<br></p><p>You can see the current code, run and test it from here:<br>https://swiftlang.ng.bluemix.net/#/repl/578ccabaf0ebe4d91be1e605<br></p><p>Considering that there were some other threads and drafts around this very<br>subject, more feedback and discussion are required on this idea. Even with<br>the new Range.clamped(to:) method, I still think that this addition could<br>be handy and useful. I do know that it is a very simple extension and that<br>it doesn&#39;t do much behind the scenes, but I would like to have it available<br>and ready to use when convenient.<br></p><p>Furthermore, it&#39;s not all about the &quot;syntax sugar&quot; aspect, it&#39;s something<br>to discuss when the fail-fast perspective doesn&#39;t apply directly, when the<br>operation doesn&#39;t necessarily causes a bug if it fails, when we&#39;d rather<br>have the subscript method executing &quot;safely&quot; (controversial term, but you<br>got my point) than the application crashing in runtime.<br></p><p>There are many cases where I have to add extra code with operations and<br>validations in order to get subarrays or an element in a specific position.<br>For example, given an application with some sort of &quot;top 5&quot;, currently I<br>must be careful and check the array size beforehand. I would rather avoid<br>that and take advantage of a more intuitive and clear solution e.g.<br>`records[clamping:<br>0..&lt;5]`, instead of validating that the array is not empty and then<br>returning something like `records.count &gt; 5 ? records[0..&lt;5] :<br>records[0..records.count]`.<br></p><p>tl;dr;<br></p><p>After all, I&#39;m just seeking a behaviour that could be compared to what we<br>have for dictionaries when trying to get the value for a non-existing key:<br></p><p>let dict = [&quot;a&quot;: 1, &quot;b&quot;: 2]<br>*&gt; dict[&quot;c&quot;] // nil*<br></p><p>let array = [1,2,3]<br>*&gt; array[5] // fatal error: index out of range*<br>*&gt; array[0..&lt;5] // fatal error: index out of range*<br></p><p>with this proposal:<br>*&gt; array[checking: 5] // nil*<br>*&gt; array[checking: 0..&lt;5] // nil (Optional)*<br>*&gt; array[clamping: 0..&lt;5] // [1,2,3] (clamped to bounds)*<br></p><p>Regards,<br>Luis<br></p><p>On Tue, May 17, 2016 at 11:54 PM, Nate Cook &lt;nate at natecook.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 17, 2016, at 5:18 PM, Luis Henrique B. Sousa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Many thanks, @Maximilian. I&#39;m also not sure about the performance cost,<br>&gt; but I think it is worth it.<br>&gt; So I just updated the proposal also including the additional min/max you<br>&gt; have suggested (thanks once again):<br>&gt; https://github.com/apple/swift-evolution/pull/328<br>&gt;<br>&gt; Best regards,<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt;<br>&gt; The new Range types have a clamped(to:) method that should do what you<br>&gt; need.<br>&gt;<br>&gt; http://swiftdoc.org/v3.0/type/Range/#func-clamped-to_<br>&gt;<br>&gt; On Tue, May 17, 2016 at 10:32 PM, Maximilian Hünenberger &lt;<br>&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; While it is true that it uses min and max, you have to add *additional<br>&gt;&gt; min max* in order to achieve the desired behavior.<br>&gt;&gt;<br>&gt;&gt; So the implementation should be: (also considering (hopefully all) recent<br>&gt;&gt; naming/index model updates)<br>&gt;&gt;<br>&gt;&gt; // Index is already Comparable<br>&gt;&gt; extension Collection {<br>&gt;&gt;<br>&gt;&gt;     subscript(clamping range: Range&lt;Index&gt;) -&gt; SubSequence {<br>&gt;&gt;         // ---&gt; here you have to use the additional min/max<br>&gt;&gt;         let start = min(max(startIndex, range.startIndex), endIndex)<br>&gt;&gt;         let end = max(min(endIndex, range.endIndex), startIndex)<br>&gt;&gt;         return self[start ..&lt; end]<br>&gt;&gt;<br>&gt;&gt;         // ---&gt; or as alternative, probably a bit less performant but<br>&gt;&gt; Swiftier<br>&gt;&gt;         return self[range.clamping(startIndex..&lt;endIndex)]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     subscript(checking range: Range&lt;Index&gt;) -&gt; SubSequence? {<br>&gt;&gt;         guard range.startIndex &gt;= startIndex &amp;&amp; range.endIndex &lt;= endIndex<br>&gt;&gt;             else { return nil }<br>&gt;&gt;         return self[range]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     subscript(checking index: Index) -&gt; Generator.Element? {<br>&gt;&gt;         // ---&gt; minor syntax update *<br>&gt;&gt;         guard self.indices.contains(index)<br>&gt;&gt;             else { return nil }<br>&gt;&gt;         return self[index]<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; * I&#39;m not sure it is worth the performance cost for arbitrary indices<br>&gt;&gt; collection with O(n) search. I could imagine Set and Dictionary indices<br>&gt;&gt; cannot be easily validated in comparison to Array indices. However this<br>&gt;&gt; approach is more general and handles non trivial index collections where<br>&gt;&gt; there is no guarantee that any index between startIndex and endIndex is a<br>&gt;&gt; valid one.<br>&gt;&gt; The same arguments also apply to `subscript(checking range ...)` where<br>&gt;&gt; you could validate start and endIndex of the range.<br>&gt;&gt;<br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt;<br>&gt;&gt; Am 16.05.2016 um 09:45 schrieb Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt; &gt;:<br>&gt;&gt;<br>&gt;&gt; Yes. The suggested implementation does use min/max:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Sun, May 15, 2016 at 3:42 PM, Maximilian Hünenberger &lt;<br>&gt;&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I brought these up because the current implementation produces an error<br>&gt;&gt;&gt; in these cases. You have to insert additional min/max operations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 15.05.2016 um 16:38 schrieb Luis Henrique B. Sousa &lt;<br>&gt;&gt;&gt; lshsousa at gmail.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Exactly, the idea is to return an empty array just like other languages<br>&gt;&gt;&gt; do. (e.g. python)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, May 15, 2016 at 10:13 AM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 15.05.2016 0:09, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One point which should be discussed is the following behaviour:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; let array = [0]<br>&gt;&gt;&gt;&gt;&gt; // ranges are completely out of bounds and produce an error<br>&gt;&gt;&gt;&gt;&gt; array[clamping: 1...2] // error<br>&gt;&gt;&gt;&gt;&gt; array[clamping: -2...-1] // error<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Should a range which has no intersection with the indices of the<br>&gt;&gt;&gt;&gt;&gt; collection<br>&gt;&gt;&gt;&gt;&gt; produce an error or just clamp to 0..&lt;0 respectively<br>&gt;&gt;&gt;&gt;&gt; endIndex..&lt;endIndex?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I expect it will returns [] i.e. empty array, as no elements with<br>&gt;&gt;&gt;&gt; 1...2(-2..-1) indexes in the array. I understand `clamping` similar as<br>&gt;&gt;&gt;&gt; &#39;bounded&#39;,&#39;in these bounds&#39;. And as soon as [0,1,2,3,4][clamping:2...10]<br>&gt;&gt;&gt;&gt; will silently move the right position to allowed index(4), and<br>&gt;&gt;&gt;&gt; [0,1,2,3,4][clamping:-2...0]  will move left position to 0, I expect that<br>&gt;&gt;&gt;&gt; in [0][clamping: 1...2] will try to move both limits to allowed, and as no<br>&gt;&gt;&gt;&gt; intersection - silently return empty array.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 13.05.2016 um 17:10 schrieb Luis Henrique B. Sousa via<br>&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It seems that there is a consensus that this proposal might be a good<br>&gt;&gt;&gt;&gt;&gt;&gt; addition to the standard library. All comments on this thread in the<br>&gt;&gt;&gt;&gt;&gt;&gt; past<br>&gt;&gt;&gt;&gt;&gt;&gt; few weeks were related to naming, not around the behaviour or<br>&gt;&gt;&gt;&gt;&gt;&gt; validity of<br>&gt;&gt;&gt;&gt;&gt;&gt; the proposed methods. So I will submit this proposal for review very<br>&gt;&gt;&gt;&gt;&gt;&gt; soon<br>&gt;&gt;&gt;&gt;&gt;&gt; assuming that nobody else has strong arguments against it. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; If you have any corrections or suggestions to the proposal text<br>&gt;&gt;&gt;&gt;&gt;&gt; itself,<br>&gt;&gt;&gt;&gt;&gt;&gt; please comment on this gist:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt; (or pull request to my repo)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 4:13 PM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     Please let me know if you have more suggestions or corrections on<br>&gt;&gt;&gt;&gt;&gt;&gt;     this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;     I&#39;m tempted to submit it for review. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     On Tue, May 10, 2016 at 8:53 AM, Luis Henrique B. Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         It sounds good, thanks for you suggestions @Vladimir, @Patrick<br>&gt;&gt;&gt;&gt;&gt;&gt;         and @Brent.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         I&#39;ve just updated the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         On Tue, May 10, 2016 at 6:50 AM, Vladimir.S via<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             Yes, I feel like &#39;within&#39; is much better than &#39;bounded&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             How about such changes in proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[bounded: -1 ..&lt; 5]  --&gt;  a[within: -1 ..&lt; 5]  (or<br>&gt;&gt;&gt;&gt;&gt;&gt; a[inside:<br>&gt;&gt;&gt;&gt;&gt;&gt;             -1 ..&lt; 5] )<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 0 ..&lt; 5]  --&gt;  a[checking: 0 ..&lt; 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;             a[optional: 5]        --&gt;  a[checking: 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             ?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             On 10.05.2016 6:27, Patrick Smith via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 I like the idea of the of the bounded subscript,<br>&gt;&gt;&gt;&gt;&gt;&gt; however<br>&gt;&gt;&gt;&gt;&gt;&gt;                 the optional one I<br>&gt;&gt;&gt;&gt;&gt;&gt;                 feel could be used for clumsy code.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 .first and .last have value, but once you start<br>&gt;&gt;&gt;&gt;&gt;&gt; stepping<br>&gt;&gt;&gt;&gt;&gt;&gt;                 several arbitrary<br>&gt;&gt;&gt;&gt;&gt;&gt;                 indices in, then that code is likely fragile?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 I can think of ‘within’, ‘inside’ and ‘intersecting’<br>&gt;&gt;&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt;&gt;&gt;                 alternative names<br>&gt;&gt;&gt;&gt;&gt;&gt;                 for ‘bounded’ that attempt to explain what is going<br>&gt;&gt;&gt;&gt;&gt;&gt; on:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 let a = [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[within: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[inside: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                 a[intersecting: 0 ..&lt; 5] // [1, 2, 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     On 28 Apr 2016, at 10:11 PM, Luis Henrique B.<br>&gt;&gt;&gt;&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;                     via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     As we have discussed throughout this thread, the<br>&gt;&gt;&gt;&gt;&gt;&gt;                     initial proposal was<br>&gt;&gt;&gt;&gt;&gt;&gt;                     modified to include alternative subscript methods<br>&gt;&gt;&gt;&gt;&gt;&gt;                     instead of modifying<br>&gt;&gt;&gt;&gt;&gt;&gt;                     the default operator/subscript behaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt;                     The first draft is<br>&gt;&gt;&gt;&gt;&gt;&gt;                     here:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     I&#39;ve also put this as a gist so that you can leave<br>&gt;&gt;&gt;&gt;&gt;&gt;                     comments with respect<br>&gt;&gt;&gt;&gt;&gt;&gt;                     to the proposal document itself. Any suggestion or<br>&gt;&gt;&gt;&gt;&gt;&gt;                     help is very welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/luish/832c34ee913159f130d97a914810dbd8<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     - Luis<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     On Mon, Apr 11, 2016 at 1:23 PM, Luis Henrique B.<br>&gt;&gt;&gt;&gt;&gt;&gt; Sousa<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;lshsousa at gmail.com &lt;mailto:lshsousa at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:lshsousa at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         This proposal seeks to provide a safer ..&lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; (aka<br>&gt;&gt;&gt;&gt;&gt;&gt;                     half-open range<br>&gt;&gt;&gt;&gt;&gt;&gt;                         operator) in order to avoid **Array index out<br>&gt;&gt;&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt;&gt;&gt;                     range** errors in<br>&gt;&gt;&gt;&gt;&gt;&gt;                         execution time.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         In short, doing that in Swift causes a<br>&gt;&gt;&gt;&gt;&gt;&gt; runtime error:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         leta =[1,2,3]<br>&gt;&gt;&gt;&gt;&gt;&gt;                         letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt;&gt;&gt;                         print(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; Error running code:<br>&gt;&gt;&gt;&gt;&gt;&gt;                         &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         The proposed solution is to slice the array<br>&gt;&gt;&gt;&gt;&gt;&gt;                     returning all elements<br>&gt;&gt;&gt;&gt;&gt;&gt;                         that are below the half-open operator, even<br>&gt;&gt;&gt;&gt;&gt;&gt;                     though the number of<br>&gt;&gt;&gt;&gt;&gt;&gt;                         elements is lesser than the ending of the<br>&gt;&gt;&gt;&gt;&gt;&gt;                     half-open operator. So the<br>&gt;&gt;&gt;&gt;&gt;&gt;                         example above would return [1,2,3].<br>&gt;&gt;&gt;&gt;&gt;&gt;                         We can see this very behaviour in other<br>&gt;&gt;&gt;&gt;&gt;&gt;                     languages, such as Python and<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         This would eliminate the need for<br>&gt;&gt;&gt;&gt;&gt;&gt; verifications<br>&gt;&gt;&gt;&gt;&gt;&gt;                     on the array size<br>&gt;&gt;&gt;&gt;&gt;&gt;                         before slicing it -- and consequently runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;                     errors in cases when<br>&gt;&gt;&gt;&gt;&gt;&gt;                         the programmer didn&#39;t.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Viewing that it is my very first proposal, any<br>&gt;&gt;&gt;&gt;&gt;&gt;                     feedback will be helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                         Luis Henrique Borges<br>&gt;&gt;&gt;&gt;&gt;&gt;                         @luishborges<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/e09f7b76/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br>&gt; <br>&gt; I&#39;ve just updated the proposal: <br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt; <br>&gt; - Luis<br></p><p>Hmm. If you&#39;re going with `checking` for one of them, perhaps the other should be `clamping` (for the analogous method on `Range`, which you might want to use in the implementation of that subscript). That would create a nicely matched pair:<br></p><p>	array[checking: 0..&lt;10]<br>	array[clamping: 0..&lt;10]<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 12, 2016 at 10:00:00am</p></header><div class="content"><p>Yes, it would really be more consistent. &quot;within&quot; sounds great to me as<br>well, but I don&#39;t know if there is a naming convention for it.<br>I am okay to change our proposal to have those labels as two verbs -<br>instead of a preposition and a verb - as suggested by @Brent.<br></p><p>More opinions?<br></p><p>- Luis<br></p><p>On Thu, May 12, 2016 at 7:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and<br>&gt; @Brent.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve just updated the proposal:<br>&gt; &gt;<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt; &gt;<br>&gt; &gt; - Luis<br>&gt;<br>&gt; Hmm. If you&#39;re going with `checking` for one of them, perhaps the other<br>&gt; should be `clamping` (for the analogous method on `Range`, which you might<br>&gt; want to use in the implementation of that subscript). That would create a<br>&gt; nicely matched pair:<br>&gt;<br>&gt;         array[checking: 0..&lt;10]<br>&gt;         array[clamping: 0..&lt;10]<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/fdedfc16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 12, 2016 at 02:00:00pm</p></header><div class="content"><p>If there is a method with such name in Range(with equal meaning) - then it <br>seems like `clamping` will be the best solution here.<br>(as non-native speaker I don&#39;t feel this word is often used especially in <br>software development, but.. it seems like anyone who is writing in Swift <br>must be strong native English speaker/writer :-P I also mean all these <br>naming conversions, verb/noun, -ing/-ed/-able etc ;-) )<br></p><p>On 12.05.2016 12:56, Luis Henrique B. Sousa wrote:<br>&gt; Yes, it would really be more consistent. &quot;within&quot; sounds great to me as<br>&gt; well, but I don&#39;t know if there is a naming convention for it.<br>&gt; I am okay to change our proposal to have those labels as two verbs -<br>&gt; instead of a preposition and a verb - as suggested by @Brent.<br>&gt;<br>&gt; More opinions?<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Thu, May 12, 2016 at 7:25 AM, Brent Royal-Gordon &lt;brent at architechies.com<br>&gt; &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;<br>&gt;     &gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br>&gt;     &gt;<br>&gt;     &gt; I&#39;ve just updated the proposal:<br>&gt;     &gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;     &gt;<br>&gt;     &gt; - Luis<br>&gt;<br>&gt;     Hmm. If you&#39;re going with `checking` for one of them, perhaps the other<br>&gt;     should be `clamping` (for the analogous method on `Range`, which you<br>&gt;     might want to use in the implementation of that subscript). That would<br>&gt;     create a nicely matched pair:<br>&gt;<br>&gt;             array[checking: 0..&lt;10]<br>&gt;             array[clamping: 0..&lt;10]<br>&gt;<br>&gt;     --<br>&gt;     Brent Royal-Gordon<br>&gt;     Architechies<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I agree with your parenthesis, but it might not be a valid argument if we<br>consider that &quot;clamp&quot; is already a word used in the standard library<br>&lt;https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_HalfOpenInterval_Structure/index.html#//apple_ref/swift/structm/HalfOpenInterval/s:FVs16HalfOpenInterval5clampFGS_x_GS_x_&gt;<br>.<br>(but I have to say that also as a non-native speaker &quot;within&quot; was way more<br>clear to me at first sight... 8-) )<br></p><p>- Luis<br></p><p>On Thu, May 12, 2016 at 12:08 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; If there is a method with such name in Range(with equal meaning) - then it<br>&gt; seems like `clamping` will be the best solution here.<br>&gt; (as non-native speaker I don&#39;t feel this word is often used especially in<br>&gt; software development, but.. it seems like anyone who is writing in Swift<br>&gt; must be strong native English speaker/writer :-P I also mean all these<br>&gt; naming conversions, verb/noun, -ing/-ed/-able etc ;-) )<br>&gt;<br>&gt; On 12.05.2016 12:56, Luis Henrique B. Sousa wrote:<br>&gt;<br>&gt;&gt; Yes, it would really be more consistent. &quot;within&quot; sounds great to me as<br>&gt;&gt; well, but I don&#39;t know if there is a naming convention for it.<br>&gt;&gt; I am okay to change our proposal to have those labels as two verbs -<br>&gt;&gt; instead of a preposition and a verb - as suggested by @Brent.<br>&gt;&gt;<br>&gt;&gt; More opinions?<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Thu, May 12, 2016 at 7:25 AM, Brent Royal-Gordon &lt;<br>&gt;&gt; brent at architechies.com<br>&gt;&gt; &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and<br>&gt;&gt; @Brent.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; I&#39;ve just updated the proposal:<br>&gt;&gt;     &gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; - Luis<br>&gt;&gt;<br>&gt;&gt;     Hmm. If you&#39;re going with `checking` for one of them, perhaps the<br>&gt;&gt; other<br>&gt;&gt;     should be `clamping` (for the analogous method on `Range`, which you<br>&gt;&gt;     might want to use in the implementation of that subscript). That would<br>&gt;&gt;     create a nicely matched pair:<br>&gt;&gt;<br>&gt;&gt;             array[checking: 0..&lt;10]<br>&gt;&gt;             array[clamping: 0..&lt;10]<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Brent Royal-Gordon<br>&gt;&gt;     Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/4368bfb5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>Perhaps another word that could fit in the first case<br>(truncate/bounded/within/clamping) is `flat`. Along the same lines of the<br>`flatMap` which returns only non-nil values, here we have an empty array<br>instead of nil when the range doesn&#39;t apply at all.<br></p><p>let array = [1,2,3]<br></p><p>array[flat: 0..&lt;10] // [1,2,3]<br>array[checking: 0..&lt;10] // nil<br></p><p>I&#39;m still not sure if `clamping` is the right word. What do you think?<br></p><p>- Luis<br></p><p>On Thu, May 12, 2016 at 7:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and<br>&gt; @Brent.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve just updated the proposal:<br>&gt; &gt;<br>&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt; &gt;<br>&gt; &gt; - Luis<br>&gt;<br>&gt; Hmm. If you&#39;re going with `checking` for one of them, perhaps the other<br>&gt; should be `clamping` (for the analogous method on `Range`, which you might<br>&gt; want to use in the implementation of that subscript). That would create a<br>&gt; nicely matched pair:<br>&gt;<br>&gt;         array[checking: 0..&lt;10]<br>&gt;         array[clamping: 0..&lt;10]<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/637eac82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Personally I don&#39;t feel like `flat` is better. Especially if there is <br>`clamping` in Range for the same purpose. Then we should not re-invent the <br>wheel.<br></p><p>On 13.05.2016 16:09, Luis Henrique B. Sousa wrote:<br>&gt; Perhaps another word that could fit in the first case<br>&gt; (truncate/bounded/within/clamping) is `flat`. Along the same lines of the<br>&gt; `flatMap` which returns only non-nil values, here we have an empty array<br>&gt; instead of nil when the range doesn&#39;t apply at all.<br>&gt;<br>&gt; let array = [1,2,3]<br>&gt;<br>&gt; array[flat: 0..&lt;10] // [1,2,3]<br>&gt; array[checking: 0..&lt;10] // nil<br>&gt;<br>&gt; I&#39;m still not sure if `clamping` is the right word. What do you think?<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Thu, May 12, 2016 at 7:25 AM, Brent Royal-Gordon &lt;brent at architechies.com<br>&gt; &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;<br>&gt;     &gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and @Brent.<br>&gt;     &gt;<br>&gt;     &gt; I&#39;ve just updated the proposal:<br>&gt;     &gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;     &gt;<br>&gt;     &gt; - Luis<br>&gt;<br>&gt;     Hmm. If you&#39;re going with `checking` for one of them, perhaps the other<br>&gt;     should be `clamping` (for the analogous method on `Range`, which you<br>&gt;     might want to use in the implementation of that subscript). That would<br>&gt;     create a nicely matched pair:<br>&gt;<br>&gt;             array[checking: 0..&lt;10]<br>&gt;             array[clamping: 0..&lt;10]<br>&gt;<br>&gt;     --<br>&gt;     Brent Royal-Gordon<br>&gt;     Architechies<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] More lenient subscript methods over Collections</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>May 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Alright, so as you are also okay with `clamping` I will update the proposal<br>with it. :-)<br></p><p>- Luis<br></p><p>On Fri, May 13, 2016 at 3:00 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; Personally I don&#39;t feel like `flat` is better. Especially if there is<br>&gt; `clamping` in Range for the same purpose. Then we should not re-invent the<br>&gt; wheel.<br>&gt;<br>&gt; On 13.05.2016 16:09, Luis Henrique B. Sousa wrote:<br>&gt;<br>&gt;&gt; Perhaps another word that could fit in the first case<br>&gt;&gt; (truncate/bounded/within/clamping) is `flat`. Along the same lines of the<br>&gt;&gt; `flatMap` which returns only non-nil values, here we have an empty array<br>&gt;&gt; instead of nil when the range doesn&#39;t apply at all.<br>&gt;&gt;<br>&gt;&gt; let array = [1,2,3]<br>&gt;&gt;<br>&gt;&gt; array[flat: 0..&lt;10] // [1,2,3]<br>&gt;&gt; array[checking: 0..&lt;10] // nil<br>&gt;&gt;<br>&gt;&gt; I&#39;m still not sure if `clamping` is the right word. What do you think?<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Thu, May 12, 2016 at 7:25 AM, Brent Royal-Gordon &lt;<br>&gt;&gt; brent at architechies.com<br>&gt;&gt; &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt; It sounds good, thanks for you suggestions @Vladimir, @Patrick and<br>&gt;&gt; @Brent.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; I&#39;ve just updated the proposal:<br>&gt;&gt;     &gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/more-lenient-subscripts/proposals/nnnn-more-lenient-collections-subscripts.md#detailed-design<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; - Luis<br>&gt;&gt;<br>&gt;&gt;     Hmm. If you&#39;re going with `checking` for one of them, perhaps the<br>&gt;&gt; other<br>&gt;&gt;     should be `clamping` (for the analogous method on `Range`, which you<br>&gt;&gt;     might want to use in the implementation of that subscript). That would<br>&gt;&gt;     create a nicely matched pair:<br>&gt;&gt;<br>&gt;&gt;             array[checking: 0..&lt;10]<br>&gt;&gt;             array[clamping: 0..&lt;10]<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Brent Royal-Gordon<br>&gt;&gt;     Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/63db5b36/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
