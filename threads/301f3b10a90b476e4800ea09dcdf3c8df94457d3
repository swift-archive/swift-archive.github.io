<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  1, 2016 at 05:00:00pm</p></header><div class="content"><p>It sure seems natural.<br></p><p>Is there some reason the language can&#39;t allow a sub-struct to add member variables, such that the whole is treated like a contiguous set of members?<br></p><p>In my case, I have a rect-like value type, but I&#39;d rather it inherit from CGRect, rather than contain a CGRect. That makes it much more natural to use.<br></p><p>Is allowing that just too complicated, or does it create type safety issues?<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>August  1, 2016 at 06:00:00pm</p></header><div class="content"><p>I’m pretty sure one of the reasons is because inheritance implies method inheritance, which implies being able to override methods, and that opens a big can of worms which will be familiar to any experienced C++ programmers.<br></p><p>Swift struct methods aren’t dynamically dispatched; they’re just function calls. But if you could subclass a struct and override methods, then the methods would need to be dynamically dispatched … but that implies that structs would need to contain vtables (or isa pointers), which makes them a lot more heavyweight. Or on the other hand, if struct methods stayed statically dispatched, then overriding them would be fraught with peril, for the same reason that overriding nonvirtual methods in C++ is generally a very bad idea.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160801/11f2817b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a3f4fec228fa9e2ad948ca70f1791?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>davelist at mac.com</string> &lt;davelist at mac.com&gt;<p>August  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 8:28 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It sure seems natural.<br>&gt; <br>&gt; Is there some reason the language can&#39;t allow a sub-struct to add member variables, such that the whole is treated like a contiguous set of members?<br>&gt; <br>&gt; In my case, I have a rect-like value type, but I&#39;d rather it inherit from CGRect, rather than contain a CGRect. That makes it much more natural to use.<br>&gt; <br>&gt; Is allowing that just too complicated, or does it create type safety issues?<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br></p><p><br>Inheritance isn&#39;t really compatible with value types at least if they&#39;re allocated on a stack (known as &quot;stack-dynamic) and take a fixed amount of space (think about what would happen if you assigned it to a subclass that had additional data - no room to store the additional data). References are typically stored on a heap with a pointer to the object stored on a stack (pointers takes the same amount of memory no matter what type they point to). <br></p><p>If you don&#39;t need extra data (additional instance variables), you can add new methods to CGRect using extensions.<br></p><p>HTH,<br>Dave Reed<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 5:28 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It sure seems natural.<br>&gt; <br>&gt; Is there some reason the language can&#39;t allow a sub-struct to add member variables, such that the whole is treated like a contiguous set of members?<br></p><p>Structs are very &quot;raw&quot;:<br></p><p>* There is no extra overhead for metadata; objects have a header which includes a type reference, a reference count, and various other housekeeping bits.<br></p><p>* Structs have a fixed size; there&#39;s no space for additional fields.<br></p><p>* Structs have statically-dispatched methods and properties; there&#39;s no ability to override.<br></p><p>This makes them small and fast, which are necessities if we&#39;re to use them to implement fundamental data types like `Int`. Basically, if structs weren&#39;t already so &quot;primitive&quot;, <br></p><p>&gt; In my case, I have a rect-like value type, but I&#39;d rather it inherit from CGRect, rather than contain a CGRect. That makes it much more natural to use.<br></p><p>Keep in mind that you have three options—not just one—if you want to increase the capabilities of a struct:<br></p><p>	1. Composition, as you seem to have already evaluated.<br></p><p>	2. Extensions to add extra methods or computed properties to an existing struct.<br></p><p>	3. Protocols and retroactive modeling if you want to be able to handle instances of both types with a single piece of code.<br></p><p>You don&#39;t mention what it is you want to do, but it&#39;s possible that one of these will address your needs.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  2, 2016 at 01:00:00am</p></header><div class="content"><p>Oops, forgot to finish a sentence:<br></p><p>&gt; On Aug 2, 2016, at 1:24 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; This makes them small and fast, which are necessities if we&#39;re to use them to implement fundamental data types like `Int`. Basically, if structs weren&#39;t already so &quot;primitive&quot;, <br></p><p>we would need to have *actual* primitive types to get the necessary performance.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; * Structs have statically-dispatched methods and properties; there&#39;s no ability to override.<br>&gt; <br></p><p>I wonder if that is an inherent property of structs, or a side-effect from them having no inheritance. There is no way to define something else which also “is” a CGRect, so all structs are final, and final is what gives static dispatch.<br>If you access a struct via a protocol reference (PWT), you will get dynamic dispatch.<br></p><p>&gt; In my case, I have a rect-like value type, but I&#39;d rather it inherit from CGRect, rather than contain a CGRect. That makes it much more natural to use.<br></p><p>I’m reading this to mean you want something which “is” a CGRect. If we allowed those kinds of relationships for structs, and when using the open base type:<br></p><p>- Methods would have to be dynamically dispatched unless declared final<br>- Instance size would not be known, requiring heap allocation and storing pointers when used as a member<br>- The sub-structs would lose information when bridged to their C equivalents. The CoreGraphics/UIKit framework code is not going to store and pass around your big CGRects<br></p><p>The problem you are facing is a library limitation. CoreGraphics and UIKit do not allow you to abstract the concept of a “rect”. You could suggest that they replace CGRect with an extendable abstraction (i.e. an open class or a protocol) to represent a rectangle. Those libraries follow this pattern in other areas - for example, UITextPosition and UITextRange are abstract classes and intended to be subclassed. However, replacing CGRect would break lots of existing code and possibly introduce performance regressions, and the benefits are not likely to be significant enough to warrant it.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 07:48 , Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; * Structs have statically-dispatched methods and properties; there&#39;s no ability to override.<br>&gt;&gt; <br>&gt; <br>&gt; I wonder if that is an inherent property of structs, or a side-effect from them having no inheritance. There is no way to define something else which also “is” a CGRect, so all structs are final, and final is what gives static dispatch.<br>&gt; If you access a struct via a protocol reference (PWT), you will get dynamic dispatch.<br>&gt; <br>&gt;&gt; In my case, I have a rect-like value type, but I&#39;d rather it inherit from CGRect, rather than contain a CGRect. That makes it much more natural to use.<br>&gt; <br>&gt; I’m reading this to mean you want something which “is” a CGRect. If we allowed those kinds of relationships for structs, and when using the open base type:<br>&gt; <br>&gt; - Methods would have to be dynamically dispatched unless declared final<br>&gt; - Instance size would not be known, requiring heap allocation and storing pointers when used as a member<br>&gt; - The sub-structs would lose information when bridged to their C equivalents. The CoreGraphics/UIKit framework code is not going to store and pass around your big CGRects<br>&gt; <br>&gt; The problem you are facing is a library limitation. CoreGraphics and UIKit do not allow you to abstract the concept of a “rect”. You could suggest that they replace CGRect with an extendable abstraction (i.e. an open class or a protocol) to represent a rectangle. Those libraries follow this pattern in other areas - for example, UITextPosition and UITextRange are abstract classes and intended to be subclassed. However, replacing CGRect would break lots of existing code and possibly introduce performance regressions, and the benefits are not likely to be significant enough to warrant it.<br></p><p>What I used to do in C++ was subclass CGRect. In this way, I could pass my rect to CoreGraphics methods directly, because the any reference to my subclass started with the same bytes as the CGRect, and everything worked (not withstanding that most of CG copies rects, rather than operating on references to them).<br></p><p>Maybe this particular use case is too limited or specialized, but I wish I could do the same thing in Swift.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August  2, 2016 at 11:00:00am</p></header><div class="content"><p>There is no fundamental reason to disallow struct inheritance, and I started a pitch where afair one member of core agreed it would be useful — I hope there is time to add it in the next year.<br>There is, however, a fundamental problem with struct polymorphism:<br>As soon as you add members, you loose compatibility (a Point3D: Point2D can&#39;t be stored or passed where its parent is expected), and when you cross module borders, there might be issues as well.<br>Struct and class have to behave different in inheritance, and to disallow struct subtyping completely is just the easiest solution.<br>Imho it&#39;s definitely not the best solution, as it forces you to use classes whenever you want to use inheritance (I don&#39;t think that composition is superior in general).<br>It could be even possible to create structs that inherit from classes and vice versa.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 4:03 AM, Tino Heth via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; There is no fundamental reason to disallow struct inheritance, and I started a pitch where afair one member of core agreed it would be useful — I hope there is time to add it in the next year.<br>&gt; There is, however, a fundamental problem with struct polymorphism:<br>&gt; As soon as you add members, you loose compatibility (a Point3D: Point2D can&#39;t be stored or passed where its parent is expected), and when you cross module borders, there might be issues as well.<br>&gt; Struct and class have to behave different in inheritance, and to disallow struct subtyping completely is just the easiest solution.<br>&gt; Imho it&#39;s definitely not the best solution, as it forces you to use classes whenever you want to use inheritance (I don&#39;t think that composition is superior in general).<br>&gt; It could be even possible to create structs that inherit from classes and vice versa.<br></p><p>I thought the problem with struct polymorphism (specifically the stack size issue) *was* the fundamental reason we can’t have “substructs”.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August  3, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; I thought the problem with struct polymorphism (specifically the stack size issue) *was* the fundamental reason we can’t have “substructs”.<br>As I said:<br>I guess this is the reason we don&#39;t have &quot;substructs&quot; now — but inheritance can be useful without polymorphism:<br>Imagine an application that managers data of customers and employees.<br>It would be reasonable to model those data-containers as structs, and as both structs share many properties, a &quot;person&quot;-type would be quite convenient, even if it is not possible to create collections which contain customers as well as employees*.<br></p><p>Tino<br></p><p>* yes, an embedded &quot;address&quot;-struct would be an alternative — but copy &amp; paste or writing everything in assembler is an alternative as well ;-)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160803/1472fc7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 8:44 PM, Tino Heth via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; * yes, an embedded &quot;address&quot;-struct would be an alternative — but copy &amp; paste or writing everything in assembler is an alternative as well ;-)<br></p><p>The other alternative for this particular case is a Person protocol which Customer and Employee both conform to. Protocols currently require you to redeclare their properties, but we could add a feature to change that if there was a strong enough justification.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August  3, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Protocols currently require you to redeclare their properties, but we could add a feature to change that if there was a strong enough justification.<br>Sometimes, this would be very handy (not only for structs) — but I&#39;d expect that there are at least as many cases where you don&#39;t want that behavior…<br>It would be possible to silently generate readwrite-properties (and even functions returning void or an optional), but that feels a little bit to much magic for me.<br></p><p>Also, this would be a use-case for protocols that is completely different from their normal role.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Why can&#39;t structs inherit from other structs?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 1, 2016, at 5:28 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It sure seems natural.<br>&gt; <br>&gt; Is there some reason the language can&#39;t allow a sub-struct to add member variables, such that the whole is treated like a contiguous set of members?<br></p><p>Class-style inheritance is tied to identity. Value types in Swift have no identity except for the value they contain, and they can be freely copied (or not) by the implementation. By adding fields to a struct, you change the value of that struct, and it doesn&#39;t make sense to say that a value with fewer fields &quot;is-a&quot; value with added fields. Those extra fields added by a sub-struct could be arbitrarily lost by copying (as often happens in C++ when copy constructors are invoked on inherited structs) and make defining equality difficult. Classes don&#39;t have these problems since each instance has a unique independent identity, and only references to that instance are passed around.<br></p><p>&gt; In my case, I have a rect-like value type, but I&#39;d rather it inherit from CGRect, rather than contain a CGRect. That makes it much more natural to use.<br>&gt; <br>&gt; Is allowing that just too complicated, or does it create type safety issues?<br></p><p>There is a different kind of inheritance that may make sense for value types. You can consider a type that can represent a proper subset (or the same set) of values from another type to be its subtype; for example, UInt8 could be a subtype of UInt16. If you have another rect-like type, which represents rectangles in a different way (perhaps using integer coordinates instead of Double, or using coordinate ranges instead of base + size), it might make sense for us to allow you to treat it as a subtype of CGRect for convenience.<br></p><p>-Joe<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
