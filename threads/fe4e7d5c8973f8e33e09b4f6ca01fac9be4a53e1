<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b94b2c18a5a83bc842d4197add92169?s=50"></div><header><strong>Allow strengthening argument types in functions declared for protocol conformance</strong> from <string>Terrence Katzenbaer</string> &lt;tkatzenbaer at me.com&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>Maybe I shouldn&#39;t have mentioned anything about the runtime since that&#39;s more about the implementation instead of the general idea... Something more &quot;swifty&quot; could be a compile check on the newly strengthened arguments.<br></p><p>If I understand your example code, it&#39;s calling didPerformSomeAction(object: Bar) instead of the Foo version because of function overloading? It seems this functionally satisfies not having to typecast, but it doesn&#39;t solve the verbosity problem since you&#39;re still forced to implement the extraneous didPerformSomeAction(object: Foo).<br></p><p>Using the Cocoa framework as an example, NSOutlineViewDelegate has the method:<br>optional func outlineView(_ outlineView: NSOutlineView,<br>         shouldSelectItem item: AnyObject) -&gt; Bool<br></p><p>If my NSOutlineView contained objects of a single type, it makes little sense to be forced to implement a method solely for handling AnyObjects or being forced to typecast to my model type.<br></p><p>It seems more expressive and more functionally correct to be able to implement a method strengthening AnyObject to my model type while still conforming to the protocol (since my model would pass &quot;is AnyObject&quot;).<br></p><p>On Dec 16, 2015, at 12:35 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br></p><p>Sorry, that should be<br></p><p>    extension FooDelegate where Self: BarController {<br>        func didPerformSomeAction(object: Bar) {}<br>    }<br></p><p><br>On Wed, Dec 16, 2015 at 3:32 PM Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br>-1<br></p><p>I think the basic problem is saying the runtime should fail. I feel like a large part of the power of Swift is letting the compiler and the programmer make strong assumptions about types specifically to prevent the runtime from dealing with it.<br></p><p>In fact, the type system can save us here! I wrote some code you can play with here: http://swiftstub.com/318278733<br></p><p>The basic idea is that if you do something like<br></p><p>    extension FooDelegate where Self: BarController {<br>        func didPerformSomeAction(object: Foo) {}<br>    }<br></p><p>calls to didPerformSomeAction with an argument of type Bar will call the right one for the type! There might be better ways to do that, but that is what immediately came to mind.<br></p><p>On Wed, Dec 16, 2015 at 2:43 PM Terrence Katzenbaer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Because APIs are designed to be generic, protocols that must be conformed generally use types like Object or other base classes for a given framework. This introduces type casting verbosity when implementing the protocol for a specific use. I would like to see the ability to strengthen argument types in functions declared for protocol conformance.<br></p><p>An example:<br>class Foo { }<br></p><p>class Bar: Foo { }<br></p><p>protocol FooDelegate {<br>    func didPerformSomeAction(object: Foo)<br>}<br></p><p>class FooController: FooDelegate {<br>    func didPerformSomeAction(var object: Foo) {<br>        // I know that object must be a Bar instance<br>        object = object as! Bar<br>        // do something with object<br>    }<br>}<br></p><p>class ProposedFooController: FooDelegate { // Type &#39;ProposedFooController&#39; does not conform to protocol &#39;FooDelegate&#39;<br>    func didPerformSomeAction(object: Bar) {<br>        // do something with Bar instance<br>    }<br>}<br></p><p>The glaring issue I see outright is how the runtime should fail when `didPerformSomeAction` in `ProposedFooController` is called with a non-Bar instance... But perhaps it /should/ fail outright because the programmer has explicitly stated that the type should be Bar.<br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/fe4e53e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Allow strengthening argument types in functions declared for protocol conformance</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; It seems more expressive and more functionally correct to be able<br>to implement a method strengthening AnyObject to my model type while still<br>conforming to the protocol (since my model would pass &quot;is AnyObject&quot;).<br></p><p>This seems to be better addressed with a generic protocol. While there are<br>currently some limitations surrounding generics, and so I won&#39;t give<br>specific examples, this has been stated as an area of focus for Swift 3.<br></p><p>&gt; If my NSOutlineView contained objects of a single type, it makes little<br>sense to be forced to implement a method solely for handling AnyObjects or<br>being forced to typecast to my model type.<br></p><p>In this example NSOutlineView should be specialized to some type T then.<br></p><p>On Wed, Dec 16, 2015 at 23:45 Terrence Katzenbaer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Maybe I shouldn&#39;t have mentioned anything about the runtime since that&#39;s<br>&gt; more about the implementation instead of the general idea... Something more<br>&gt; &quot;swifty&quot; could be a compile check on the newly strengthened arguments.<br>&gt;<br>&gt; If I understand your example code, it&#39;s calling<br>&gt; didPerformSomeAction(object: Bar) instead of the Foo version because of<br>&gt; function overloading? It seems this functionally satisfies not having to<br>&gt; typecast, but it doesn&#39;t solve the verbosity problem since you&#39;re still<br>&gt; forced to implement the extraneous didPerformSomeAction(object: Foo).<br>&gt;<br>&gt; Using the Cocoa framework as an example, NSOutlineViewDelegate has the<br>&gt; method:<br>&gt; optional func outlineView(_ *outlineView*: NSOutlineView<br>&gt; &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSOutlineView_Class/index.html#//apple_ref/swift/cl/c:objc(cs)NSOutlineView&gt;<br>&gt; ,<br>&gt;          shouldSelectItem *item*: AnyObject<br>&gt; &lt;https://developer.apple.com/library/mac/documentation/Swift/Reference/Swift_AnyObject_Protocol/index.html#//apple_ref/swift/intf/s:PSs9AnyObject&gt;)<br>&gt; -&gt; Bool<br>&gt; &lt;https://developer.apple.com/library/mac/documentation/Swift/Reference/Swift_Bool_Structure/index.html#//apple_ref/swift/struct/s:Sb&gt;<br>&gt;<br>&gt; If my NSOutlineView contained objects of a single type, it makes little<br>&gt; sense to be forced to implement a method solely for handling AnyObjects or<br>&gt; being forced to typecast to my model type.<br>&gt;<br>&gt; It seems more expressive and more functionally correct to be able<br>&gt; to implement a method strengthening AnyObject to my model type while still<br>&gt; conforming to the protocol (since my model would pass &quot;is AnyObject&quot;).<br>&gt;<br>&gt; On Dec 16, 2015, at 12:35 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br>&gt;<br>&gt; Sorry, that should be<br>&gt;<br>&gt;     extension FooDelegate where Self: BarController {<br>&gt;         func didPerformSomeAction(object: Bar) {}<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 3:32 PM Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; -1<br>&gt;&gt;<br>&gt;&gt; I think the basic problem is saying the runtime should fail. I feel like<br>&gt;&gt; a large part of the power of Swift is letting the compiler and the<br>&gt;&gt; programmer make strong assumptions about types specifically to prevent the<br>&gt;&gt; runtime from dealing with it.<br>&gt;&gt;<br>&gt;&gt; In fact, the type system can save us here! I wrote some code you can play<br>&gt;&gt; with here: http://swiftstub.com/318278733<br>&gt;&gt;<br>&gt;&gt; The basic idea is that if you do something like<br>&gt;&gt;<br>&gt;&gt;     extension FooDelegate where Self: BarController {<br>&gt;&gt;         func didPerformSomeAction(object: Foo) {}<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; calls to didPerformSomeAction with an argument of type Bar will call the<br>&gt;&gt; right one for the type! There might be better ways to do that, but that is<br>&gt;&gt; what immediately came to mind.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 2:43 PM Terrence Katzenbaer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Because APIs are designed to be generic, protocols that must be<br>&gt;&gt;&gt; conformed generally use types like Object or other base classes for a given<br>&gt;&gt;&gt; framework. This introduces type casting verbosity when implementing the<br>&gt;&gt;&gt; protocol for a specific use. I would like to see the ability to strengthen<br>&gt;&gt;&gt; argument types in functions declared for protocol conformance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Foo { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Bar: Foo { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol FooDelegate {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func didPerformSomeAction(object: Foo)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class FooController: FooDelegate {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func didPerformSomeAction(var object: Foo) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // I know that object must be a Bar instance<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         object = object as! Bar<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // do something with object<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class ProposedFooController: FooDelegate { // Type<br>&gt;&gt;&gt; &#39;ProposedFooController&#39; does not conform to protocol &#39;FooDelegate&#39;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func didPerformSomeAction(object: Bar) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // do something with Bar instance<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The glaring issue I see outright is how the runtime should fail when<br>&gt;&gt;&gt; `didPerformSomeAction` in `ProposedFooController` is called with a non-Bar<br>&gt;&gt;&gt; instance... But perhaps it /should/ fail outright because the programmer<br>&gt;&gt;&gt; has explicitly stated that the type should be Bar.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/47ebaf7d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
