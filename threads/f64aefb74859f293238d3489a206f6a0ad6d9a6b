<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August 12, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu Aug 11 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sent from my iPhone<br>&gt;<br>&gt;&gt; On Aug 4, 2016, at 2:36 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 4 Aug 2016, at 03:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt;&gt;&gt;&gt; than simple inheritance of protocols. The way this could be<br>&gt;&gt;&gt;&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt;&gt;&gt;&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt;&gt;&gt;&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt;&gt;&gt;&gt; performance will be any different than simple inheritance. Further,<br>&gt;&gt;&gt;&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt;&gt;&gt;&gt; second pass of semantic analysis.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding—which may be incorrect, by the way—is that the<br>&gt;&gt;&gt; issue is mainly with protocol extensions adding conformances, not<br>&gt;&gt;&gt; specifically with those conformances being conditional, and that it<br>&gt;&gt;&gt; specifically has to do with `is` and `as?` checks across module<br>&gt;&gt;&gt; boundaries.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Suppose you have these declarations in module M:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public protocol AProtocol {…}<br>&gt;&gt;&gt;    public protocol BProtocol: AProtocol {…}<br>&gt;&gt;&gt;    public protocol CProtocol {…}<br>&gt;&gt;&gt;    <br>&gt;&gt;&gt;    // Public or otherwise doesn&#39;t matter here.<br>&gt;&gt;&gt;    public struct Foo: BProtocol {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Foo essentially has a flat list of the protocols it conforms to attached to it. Notionally, you can think of that list as looking like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And when you write `foo is CProtocol`, that eventually translates into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    foo.dynamicType.conformsTo.contains(CProtocol.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For a `Foo`, since the `conformsTo` list doesn&#39;t include `CProtocol.self`, it returns `false`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now imagine that you write a new module, N, and in it you say:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension Foo: CProtocol {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have now retroactively conformed `Foo` to `CProtocol`. Swift<br>&gt;&gt;&gt; needs to reach into module M and add `CProtocol.self` to the<br>&gt;&gt;&gt; `Foo.self.conformsTo` list. This is perfectly doable for a concrete<br>&gt;&gt;&gt; type—it&#39;s one flat list, after all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, though, imagine that module N extended `AProtocol` to add a conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension AProtocol: CProtocol {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two ways to handle this. One is to find all types<br>&gt;&gt;&gt; conforming to `AProtocol`, recursively, and add `CProtocol.self` to<br>&gt;&gt;&gt; their conformance list. The other is to scrap the flat list of<br>&gt;&gt;&gt; conformances and instead make `is` and `as?` recursively search<br>&gt;&gt;&gt; each protocol. Either way, you have replaced a fast, flat operation<br>&gt;&gt;&gt; with a slow, recursive one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformance adds another wrinkle to this, of course—you<br>&gt;&gt;&gt; must not only recursively search the list, but also evaluate the<br>&gt;&gt;&gt; condition to see if it applies in this case. But the general<br>&gt;&gt;&gt; problem of having to replace a fast search with a slow search<br>&gt;&gt;&gt; applies either way.<br>&gt;&gt; <br>&gt;&gt; Great explanation! This switch from flat to recursively searched<br>&gt;&gt; though seems like it would only occur when the extension is in an<br>&gt;&gt; external module though; for internal modules would it not still be<br>&gt;&gt; possible to determine the flat list for each type? In that case<br>&gt;&gt; extending a type from another module could be either disallowed, or<br>&gt;&gt; produce a warning to indicate the performance implication?<br>&gt;&gt; <br>&gt;&gt; The feature would still be very useful even just for internal use<br>&gt;&gt; after all. Also it seems useful on a relatively small number of<br>&gt;&gt; types, and the number of external modules that need/want to do this<br>&gt;&gt; must narrow that even further, so external extensions may be quite<br>&gt;&gt; niche, i.e- not worth losing the feature for internal use if that is<br>&gt;&gt; indeed easier?<br>&gt;<br>&gt; Swift doesn&#39;t really have any features that stop working across<br>&gt; modules. We&#39;re okay with the programmer having to think more and be<br>&gt; more explicit across module boundaries (since it is API design at that<br>&gt; point), but it&#39;d take a very strong argument to have different runtime<br>&gt; semantics across module boundaries.<br>&gt;<br>&gt; FWIW, I&#39;m planning to write a complete proposal for conditional<br>&gt; conformances and will start posting drafts once it is far enough along<br>&gt; to be useful. It won&#39;t have support for protocols conforming to other<br>&gt; protocols, though.<br></p><p>So “a Collection is Equatable if its elements are?” == not supported?<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
