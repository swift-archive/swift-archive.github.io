<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p><br>Am 13. Mai 2016 um 09:31 schrieb &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;:<br></p><p><br>I don&#39;t feel that InvariantSelf reflects the fact that class conformed to<br>protocol with `f()-&gt;InvariantSelf` requirement will actually return<br>&#39;self or some base class&#39;. Especially when this `InvariantSelf` means<br>`exactly this concrete static type name` inside type declaration.<br></p><p>Probably the better name is BaseType (BaseSelf, ThisType.. #Type ?)<br></p><p>But actually I don&#39;t fully understand how this would work in generic functions:<br></p><p>protocol A {<br>func g()-&gt;StaticSelf<br>}<br></p><p>class B: A {<br>func g()-&gt;StaticSelf {return B()}<br>}<br></p><p>class C: B {<br>}<br></p><p><br>func x(a: A ){<br>var xx : A = a.g() // will this work? as g returns *some in hierarchy*<br>print(xx)<br>}<br></p><p><br>StaticSelf within the protocol should just be the protocol, i.e. here A<br></p><p><br>Only for non-protocol types conforming to the protocol StaticSelf becomes equal to the first type where the respective method gets implemented (if we should get abstract classes some day this would mean that for an abstract class conforming to the protocol but not implementing the method a, StaticSelf would still be A).<br></p><p><br></p><p><br>func z&lt;T: A&gt;(t: T) {<br>let u = t.g() // will this work?<br>print(u)<br>}<br></p><p><br>This will work as well with static type of `u` being A.<br></p><p><br></p><p>let c = C()<br>z(c)<br></p><p><br>This is of course correct because C conforms to A. The static type of `u` within `z` is A (see comment above). This is independent from the dynamic type of the parameter `t` (which has nothing to do with StaticSelf).<br></p><p><br></p><p><br>x(c)<br></p><p><br>Again `c` conforms to A, so this is correct.<br></p><p><br>-Thorsten<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>On 13.05.2016 4:59, Xiaodi Wu via swift-evolution wrote:<br></p><p>I like the way the motivation for this feature has been explained here. Now<br>that the reasoning behind it is evident, I have to say I&#39;m leaning towards<br>the &quot;InvariantSelf&quot; name--after all, you describe this feature in the title<br>as &quot;an invariant self.&quot;<br></p><p><br></p><p><br>On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p><br>Erica Sadun and I have written a proposal are following up the recent<br>discussion thread &quot;[RFC] #Self” with a proposal to introduce<br>StaticSelf, an invariant Self.<br></p><p><br>The recent discussion can be found<br>here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br></p><p><br></p><p>The proposal can be found<br>here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br></p><p><br></p><p>We look forward to continuing the discussion. We plan to submit a PR<br>in the near future after incorporating your final feedback.<br></p><p><br>Thanks,<br>Matthew<br></p><p><br></p><p><br>Introducing StaticSelf, an Invariant Self<br></p><p><br>* Proposal: TBD<br>* Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica<br>Sadun &lt;https://github.com/erica&gt;<br></p><p>* Status: TBD<br>* Review manager: TBD<br></p><p><br></p><p><br>Introduction<br></p><p><br>This proposal introduces a new keyword that provides consistent<br>invariant type semantics in all contexts.<br></p><p><br>/The Swift-evolution thread about this topic can be found here: [RFC]<br>#Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br></p><p><br></p><p><br></p><p>Motivation<br></p><p><br>The distinction between covariant and non-covariant type references<br>come into play when<br>conforming non-final classes to protocols. Fixing a protocol<br>requirement to a covarying type<br>means that a method returning |Self| must be overriden by all<br>subclasses in order to return<br>the correct, matching type.<br></p><p><br>This proposal builds on the covariant construct |Self| accepted<br>in SE–0068<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br></p><p>to introduce an invariant type identifier. It enables protocol<br>declarations to consistently<br>refer to a type that is fixed at compile time. This ensures that<br>subclasses can inherit<br>protocol implementations without having to re-implement that code at<br>each level of<br>inheritance.<br></p><p><br>Under this proposal, a new identifier keyword is fixed in use /at the<br>point of protocol conformance/<br>to the static type of that construct.<br></p><p><br>|class A: MyProtocol|<br></p><p><br>The invariant |StaticSelf| identifier will always refer to |A|,<br>unlike |Self|, which is covarying and refers to<br>the type of the actual instance. Since multiple inheritance for<br>non-protocol types is disallowed,<br>this establishes this invariant type identifier with no possibility for<br>conflict.<br></p><p><br>Consider the following example, under the current system:<br></p><p><br>|protocol StringCreatable { static func createWithString(s: String) -&gt;<br>Self } extension NSURL: StringCreatable { // cannot conform because<br>NSURL is non-final // error: method &#39;createWithString&#39; in non-final<br>class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39; }|<br></p><p><br>Introducing a static, invariant version of |Self| permits the desired<br>conformance:<br></p><p><br>|protocol StringCreatable { static func createWithString(s: String) -&gt;<br>StaticSelf } extension NSURL: StringCreatable { // can now conform<br>conform because NSURL is fixed and matches the static // type of the<br>conforming construct. Subclasses need not re-implement // NOTE: the<br>return type can be declared as StaticSelf *or* as NSURL // they are<br>interchangeable static func createWithString(s: String) -&gt; StaticSelf {<br>// ... } }|<br></p><p><br></p><p><br>Additional Utility<br></p><p><br>The utility of |StaticSelf| is not limited to protocols. A secondary<br>use enables code to refer to the lexical context’s current type without<br>explicitly mentioning its name. This provides a useful shortcut when<br>referencing static type members with especially long names and when<br>re-purposing code between types.<br></p><p><br>|class StructWithAVeryLongName { static func foo() -&gt; String { // ... }<br>func bar() { // ... let s = StaticSelf.foo() // } }|<br></p><p><br></p><p><br>Detailed Design<br></p><p><br>This proposal introduces |StaticSelf|, a new keyword that may be used<br>in protocols to refer to the invariant static type of a conforming<br>construct. |StaticSelf| may also be used in the lexical context of any<br>type declaration. In such use, the keyword is identical to spelling out<br>the full name of that type.<br></p><p><br></p><p><br>Impact on existing code<br></p><p><br>Being additive, there should be no impact on existing code.<br></p><p><br></p><p><br>Alternatives considered<br></p><p><br>The keyword is not fixed at this time. Alternatives that have been<br>discussed include |StaticType|, |InvariantSelf|, |SelfType|, or |Type|.<br>The community is welcome to bikeshed on the most clear and concise name<br>for this keyword.<br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/407516af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 13, 2016, at 8:37 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Comments inline.<br>&gt; <br>&gt;&gt; Am 13. Mai 2016 um 09:31 schrieb &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t feel that InvariantSelf reflects the fact that class conformed to <br>&gt;&gt; protocol with `f()-&gt;InvariantSelf` requirement will actually return<br>&gt;&gt; &#39;self or some base class&#39;. Especially when this `InvariantSelf` means <br>&gt;&gt; `exactly this concrete static type name` inside type declaration.<br>&gt;&gt; <br>&gt;&gt; Probably the better name is BaseType (BaseSelf, ThisType.. #Type ?)<br>&gt;&gt; <br>&gt;&gt; But actually I don&#39;t fully understand how this would work in generic functions:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt; func g()-&gt;StaticSelf<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class B: A {<br>&gt;&gt; func g()-&gt;StaticSelf {return B()}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: B {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func x(a: A ){<br>&gt;&gt; var xx : A = a.g() // will this work? as g returns *some in hierarchy*<br>&gt;&gt; print(xx)<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; StaticSelf within the protocol should just be the protocol, i.e. here A<br>&gt; <br>&gt; Only for non-protocol types conforming to the protocol StaticSelf becomes equal to the first type where the respective method gets implemented (if we should get abstract classes some day this would mean that for an abstract class conforming to the protocol but not implementing the method a, StaticSelf would still be A).<br>&gt; <br></p><p>Yes, it is exactly as if you had copy and pasted the signature from the protocol declaration into the conforming type.<br></p><p>&gt;&gt; <br>&gt;&gt; func z&lt;T: A&gt;(t: T) {<br>&gt;&gt; let u = t.g() // will this work?<br>&gt;&gt; print(u)<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; This will work as well with static type of `u` being A.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; z(c)<br>&gt; <br>&gt; <br>&gt; This is of course correct because C conforms to A. The static type of `u` within `z` is A (see comment above). This is independent from the dynamic type of the parameter `t` (which has nothing to do with StaticSelf).<br>&gt; <br>&gt; <br>&gt;&gt; x(c)<br>&gt; <br>&gt; <br>&gt; Again `c` conforms to A, so this is correct.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 13.05.2016 4:59, Xiaodi Wu via swift-evolution wrote:<br>&gt;&gt;&gt; I like the way the motivation for this feature has been explained here. Now<br>&gt;&gt;&gt; that the reasoning behind it is evident, I have to say I&#39;m leaning towards<br>&gt;&gt;&gt; the &quot;InvariantSelf&quot; name--after all, you describe this feature in the title<br>&gt;&gt;&gt; as &quot;an invariant self.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 12, 2016 at 7:49 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Erica Sadun and I have written a proposal are following up the recent<br>&gt;&gt;&gt; discussion thread &quot;[RFC] #Self” with a proposal to introduce<br>&gt;&gt;&gt; StaticSelf, an invariant Self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The recent discussion can be found<br>&gt;&gt;&gt; here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal can be found<br>&gt;&gt;&gt; here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We look forward to continuing the discussion. We plan to submit a PR<br>&gt;&gt;&gt; in the near future after incorporating your final feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing StaticSelf, an Invariant Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Proposal: TBD<br>&gt;&gt;&gt; * Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica<br>&gt;&gt;&gt; Sadun &lt;https://github.com/erica&gt;<br>&gt;&gt;&gt; * Status: TBD<br>&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces a new keyword that provides consistent<br>&gt;&gt;&gt; invariant type semantics in all contexts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /The Swift-evolution thread about this topic can be found here: [RFC]<br>&gt;&gt;&gt; #Self &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The distinction between covariant and non-covariant type references<br>&gt;&gt;&gt; come into play when<br>&gt;&gt;&gt; conforming non-final classes to protocols. Fixing a protocol<br>&gt;&gt;&gt; requirement to a covarying type<br>&gt;&gt;&gt; means that a method returning |Self| must be overriden by all<br>&gt;&gt;&gt; subclasses in order to return<br>&gt;&gt;&gt; the correct, matching type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal builds on the covariant construct |Self| accepted<br>&gt;&gt;&gt; in SE–0068<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>&gt;&gt;&gt; to introduce an invariant type identifier. It enables protocol<br>&gt;&gt;&gt; declarations to consistently<br>&gt;&gt;&gt; refer to a type that is fixed at compile time. This ensures that<br>&gt;&gt;&gt; subclasses can inherit<br>&gt;&gt;&gt; protocol implementations without having to re-implement that code at<br>&gt;&gt;&gt; each level of<br>&gt;&gt;&gt; inheritance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under this proposal, a new identifier keyword is fixed in use /at the<br>&gt;&gt;&gt; point of protocol conformance/<br>&gt;&gt;&gt; to the static type of that construct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; |class A: MyProtocol|<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The invariant |StaticSelf| identifier will always refer to |A|,<br>&gt;&gt;&gt; unlike |Self|, which is covarying and refers to<br>&gt;&gt;&gt; the type of the actual instance. Since multiple inheritance for<br>&gt;&gt;&gt; non-protocol types is disallowed,<br>&gt;&gt;&gt; this establishes this invariant type identifier with no possibility for<br>&gt;&gt;&gt; conflict.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt;&gt;&gt; Self } extension NSURL: StringCreatable { // cannot conform because<br>&gt;&gt;&gt; NSURL is non-final // error: method &#39;createWithString&#39; in non-final<br>&gt;&gt;&gt; class &#39;NSURL&#39; must return `Self` to conform to protocol &#39;A&#39; }|<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing a static, invariant version of |Self| permits the desired<br>&gt;&gt;&gt; conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; |protocol StringCreatable { static func createWithString(s: String) -&gt;<br>&gt;&gt;&gt; StaticSelf } extension NSURL: StringCreatable { // can now conform<br>&gt;&gt;&gt; conform because NSURL is fixed and matches the static // type of the<br>&gt;&gt;&gt; conforming construct. Subclasses need not re-implement // NOTE: the<br>&gt;&gt;&gt; return type can be declared as StaticSelf *or* as NSURL // they are<br>&gt;&gt;&gt; interchangeable static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;&gt;&gt; // ... } }|<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additional Utility<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The utility of |StaticSelf| is not limited to protocols. A secondary<br>&gt;&gt;&gt; use enables code to refer to the lexical context’s current type without<br>&gt;&gt;&gt; explicitly mentioning its name. This provides a useful shortcut when<br>&gt;&gt;&gt; referencing static type members with especially long names and when<br>&gt;&gt;&gt; re-purposing code between types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; |class StructWithAVeryLongName { static func foo() -&gt; String { // ... }<br>&gt;&gt;&gt; func bar() { // ... let s = StaticSelf.foo() // } }|<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces |StaticSelf|, a new keyword that may be used<br>&gt;&gt;&gt; in protocols to refer to the invariant static type of a conforming<br>&gt;&gt;&gt; construct. |StaticSelf| may also be used in the lexical context of any<br>&gt;&gt;&gt; type declaration. In such use, the keyword is identical to spelling out<br>&gt;&gt;&gt; the full name of that type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being additive, there should be no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The keyword is not fixed at this time. Alternatives that have been<br>&gt;&gt;&gt; discussed include |StaticType|, |InvariantSelf|, |SelfType|, or |Type|.<br>&gt;&gt;&gt; The community is welcome to bikeshed on the most clear and concise name<br>&gt;&gt;&gt; for this keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/b0cdffba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 05:00:00pm</p></header><div class="content"><p>After all these discussions, and after I found out *for myself* what does <br>the proposed `-&gt;StaticSelf` in protocol mean, I&#39;m giving my strong +1 to <br>this proposal. This will be a good and useful in some cases language <br>feature, that will add flexibility to Swift.<br></p><p>Also it will help to make the code clean and reduce copy-paste errors or <br>requirements to re-type concrete type name inside its declaration.<br>It&#39;s so naturally to say &#39;this concrete type name&#39; i.e. `StaticSelf` <br>*inside* the type declaration instead of having its name everywhere. <br>Especially, if name of the declaring type has common elements with another <br>class like MyVeryGoodClass.f() and MyVeryBadClass.f() so I need to <br>carefully read name of which class used.<br></p><p>But the question regarding the name of StaticSelf is still here...<br>I feel like something that will be resolved at compile-time should have `#` <br>before its name.. Probably the best name for me is #BaseType (or #TypeBase, <br>or #This #BaseThis #ThisBase)... as having StaticSelf, we IMO should have <br>DynamicSelf instead of current `Self`.. Even probably the initially <br>proposed #Self is better for me.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
