<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 02:00:00pm</p></header><div class="content"><p>It would be handy if a callback could be marked as required with an<br>optional descriptive message i.e<br></p><p>class BackgroundTask {<br> func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>your app for being a bad citizen&quot;) () -&gt; Void)<br>}<br></p><p>That was the developer can comunicate the bad things that can happen if<br>this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>background task or perhaps memory leaks caused by clean up code unable to<br>be triggered.<br></p><p>*___________________________________*<br></p><p>*James*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/b6e3b0db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 02:00:00pm</p></header><div class="content"><p>I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>around if I intend to call `end` by passing it to a helper function in<br>another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>inspect that `end` is always called by that other module, and if calling<br>`end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>need a companion annotation to pass along the requirement to the callee, or<br>some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>enforce at runtime) if the closure is escaping.<br>On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It would be handy if a callback could be marked as required with an<br>&gt; optional descriptive message i.e<br>&gt;<br>&gt; class BackgroundTask {<br>&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt; }<br>&gt;<br>&gt; That was the developer can comunicate the bad things that can happen if<br>&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt; be triggered.<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/420c62de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 03:00:00pm</p></header><div class="content"><p>I think as long as the end callback is referenced in some way that would<br>still be better than what we have now, if you pass it into your own code<br>but then continue on to not call it then I think it would be fair for the<br>compiler to let you shoot yourself in the foot in that case.<br></p><p>Calling end more than once is another case which isn&#39;t covered by this<br>proposal.<br></p><p>so this:<br></p><p>run() { end in<br></p><p>}<br></p><p>would have an error:<br></p><p>but<br></p><p>run() end in {<br> MyModule(end)<br>}<br></p><p>would not since we have at least referenced it.<br></p><p><br>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 15:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt; inspect that `end` is always called by that other module, and if calling<br>&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt; enforce at runtime) if the closure is escaping.<br>&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt; optional descriptive message i.e<br>&gt;&gt;<br>&gt;&gt; class BackgroundTask {<br>&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt; be triggered.<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/115efdc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 04:00:00pm</p></header><div class="content"><p>I wonder if we can be a little more elegant:<br></p><p>- no need for an optional message: if the compiler is going to force you<br>the implementor to call something, it really doesn&#39;t matter why--you just<br>call it; any additional explanation can be given in doc comments<br></p><p>- at the implementation site, you the implementor would have to parrot<br>@required in the declaration; that in itself wins some clarity (the<br>implementor has to know it&#39;s required)<br></p><p>- instead of allowing any assignment or reference of the callback to<br>satisfy the requirement, either require actual invocation in the body, or<br>allow the callback to be called/assigned/whatever with an extra attribute<br>@invoked (or whatever the preferred bikeshed)<br></p><p>MyModule(@invoked end)<br>// or live dangerously:<br>// _ = @invoked end<br></p><p>On Tue, Aug 16, 2016 at 09:54 James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt;<br>&gt; I think as long as the end callback is referenced in some way that would<br>&gt; still be better than what we have now, if you pass it into your own code<br>&gt; but then continue on to not call it then I think it would be fair for the<br>&gt; compiler to let you shoot yourself in the foot in that case.<br>&gt;<br>&gt; Calling end more than once is another case which isn&#39;t covered by this<br>&gt; proposal.<br>&gt;<br>&gt; so this:<br>&gt;<br>&gt; run() { end in<br>&gt;<br>&gt; }<br>&gt;<br>&gt; would have an error:<br>&gt;<br>&gt; but<br>&gt;<br>&gt; run() end in {<br>&gt;  MyModule(end)<br>&gt; }<br>&gt;<br>&gt; would not since we have at least referenced it.<br>&gt;<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Hustler*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On 16 August 2016 at 15:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *James*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/996c8f6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>I think that tidies it up a lot, that would make it stick out a lot for me<br>especially when dealing with iOS&#39;s app delegate callbacks.<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 17:29, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; I wonder if we can be a little more elegant:<br>&gt;<br>&gt; - no need for an optional message: if the compiler is going to force you<br>&gt; the implementor to call something, it really doesn&#39;t matter why--you just<br>&gt; call it; any additional explanation can be given in doc comments<br>&gt;<br>&gt; - at the implementation site, you the implementor would have to parrot<br>&gt; @required in the declaration; that in itself wins some clarity (the<br>&gt; implementor has to know it&#39;s required)<br>&gt;<br>&gt; - instead of allowing any assignment or reference of the callback to<br>&gt; satisfy the requirement, either require actual invocation in the body, or<br>&gt; allow the callback to be called/assigned/whatever with an extra attribute<br>&gt; @invoked (or whatever the preferred bikeshed)<br>&gt;<br>&gt; MyModule(@invoked end)<br>&gt; // or live dangerously:<br>&gt; // _ = @invoked end<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 09:54 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I think as long as the end callback is referenced in some way that would<br>&gt;&gt; still be better than what we have now, if you pass it into your own code<br>&gt;&gt; but then continue on to not call it then I think it would be fair for the<br>&gt;&gt; compiler to let you shoot yourself in the foot in that case.<br>&gt;&gt;<br>&gt;&gt; Calling end more than once is another case which isn&#39;t covered by this<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; so this:<br>&gt;&gt;<br>&gt;&gt; run() { end in<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; would have an error:<br>&gt;&gt;<br>&gt;&gt; but<br>&gt;&gt;<br>&gt;&gt; run() end in {<br>&gt;&gt;  MyModule(end)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; would not since we have at least referenced it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt;<br>&gt;&gt; On 16 August 2016 at 15:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt;&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt;&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *James*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/116b9950/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Required Callback</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work around if I intend to call `end` by passing it to a helper function in another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to inspect that `end` is always called by that other module, and if calling `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d need a companion annotation to pass along the requirement to the callee, or some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t enforce at runtime) if the closure is escaping.<br>&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It would be handy if a callback could be marked as required with an optional descriptive message i.e<br>&gt; <br>&gt; class BackgroundTask {<br>&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise your app for being a bad citizen&quot;) () -&gt; Void) <br>&gt; }<br>&gt; <br>&gt; That was the developer can comunicate the bad things that can happen if this callback isn&#39;t called such as iOS peanlizing them for not ending a background task or perhaps memory leaks caused by clean up code unable to be triggered.<br></p><p>Could this not just behave in the same way as @noescape, in which case you can pass the closure on to other functions so long as they also have the @noescape attribute? In this case passing it as a parameter to another method with the @required attribute would be equivalent to calling it directly (since you know the other method must eventually call it).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/d69a0841/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Nice! Still need an escape hatch for when that other function isn&#39;t<br>annotated though, for those situations when you *know* it&#39;s always going to<br>be called and that you should never call it twice.<br>On Tue, Aug 16, 2016 at 11:50 Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt;<br>&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt; inspect that `end` is always called by that other module, and if calling<br>&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt; enforce at runtime) if the closure is escaping.<br>&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt; optional descriptive message i.e<br>&gt;&gt;<br>&gt;&gt; class BackgroundTask {<br>&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt; be triggered.<br>&gt;&gt;<br>&gt;<br>&gt; Could this not just behave in the same way as @noescape, in which case you<br>&gt; can pass the closure on to other functions so long as they also have the<br>&gt; @noescape attribute? In this case passing it as a parameter to another<br>&gt; method with the @required attribute would be equivalent to calling it<br>&gt; directly (since you know the other method must eventually call it).<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/2293b643/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>I guess that would make sense and you could wrap the callback up in a<br>anon-closure if the module hadn&#39;t adpated the @required property so you get<br>both compatibility, safety and clarity.<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt;<br>&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt; inspect that `end` is always called by that other module, and if calling<br>&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt; enforce at runtime) if the closure is escaping.<br>&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt; optional descriptive message i.e<br>&gt;&gt;<br>&gt;&gt; class BackgroundTask {<br>&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt; be triggered.<br>&gt;&gt;<br>&gt;<br>&gt; Could this not just behave in the same way as @noescape, in which case you<br>&gt; can pass the closure on to other functions so long as they also have the<br>&gt; @noescape attribute? In this case passing it as a parameter to another<br>&gt; method with the @required attribute would be equivalent to calling it<br>&gt; directly (since you know the other method must eventually call it).<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/e56de9ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Nicer still!<br>On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; I guess that would make sense and you could wrap the callback up in a<br>&gt; anon-closure if the module hadn&#39;t adpated the @required property so you get<br>&gt; both compatibility, safety and clarity.<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Hustler*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Could this not just behave in the same way as @noescape, in which case<br>&gt;&gt; you can pass the closure on to other functions so long as they also have<br>&gt;&gt; the @noescape attribute? In this case passing it as a parameter to another<br>&gt;&gt; method with the @required attribute would be equivalent to calling it<br>&gt;&gt; directly (since you know the other method must eventually call it).<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/4d9e4e97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;ll write up a draft proposal :) I think we have something nice :)<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Nicer still!<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;<br>&gt;&gt; I guess that would make sense and you could wrap the callback up in a<br>&gt;&gt; anon-closure if the module hadn&#39;t adpated the @required property so you get<br>&gt;&gt; both compatibility, safety and clarity.<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt;<br>&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will penalise<br>&gt;&gt;&gt;&gt; your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen if<br>&gt;&gt;&gt;&gt; this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which case<br>&gt;&gt;&gt; you can pass the closure on to other functions so long as they also have<br>&gt;&gt;&gt; the @noescape attribute? In this case passing it as a parameter to another<br>&gt;&gt;&gt; method with the @required attribute would be equivalent to calling it<br>&gt;&gt;&gt; directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/1e98082d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Wait, doesn&#39;t work. Your anonymous closure would then be dinged for not<br>satisfying the requirement. Turtles all the way down. Still need an escape<br>hatch.<br>On Tue, Aug 16, 2016 at 11:54 James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; I&#39;ll write up a draft proposal :) I think we have something nice :)<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Hustler*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Nicer still!<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I guess that would make sense and you could wrap the callback up in a<br>&gt;&gt;&gt; anon-closure if the module hadn&#39;t adpated the @required property so you get<br>&gt;&gt;&gt; both compatibility, safety and clarity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt;&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will<br>&gt;&gt;&gt;&gt;&gt; penalise your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen<br>&gt;&gt;&gt;&gt;&gt; if this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which case<br>&gt;&gt;&gt;&gt; you can pass the closure on to other functions so long as they also have<br>&gt;&gt;&gt;&gt; the @noescape attribute? In this case passing it as a parameter to another<br>&gt;&gt;&gt;&gt; method with the @required attribute would be equivalent to calling it<br>&gt;&gt;&gt;&gt; directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/34a8805a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>It would though, look :) :<br></p><p>Backend.run() { requiredCallback in<br></p><p> NonAnotatedModuled({<br></p><p>//We send a anon closure to the module and we call the callback with a<br>required specifier to indicate to the compiler it will be called :)<br>@required requiredCallback()<br>})<br>}<br></p><p>This would be the same as this:<br></p><p><br>Backend.run() { requiredCallback in<br></p><p> AnotatedModuled(requiredCallback)<br>}<br></p><p>And this:<br></p><p><br>Backend.run() { requiredCallback in<br></p><p>@required requiredCallback()<br>}<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 17:55, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Wait, doesn&#39;t work. Your anonymous closure would then be dinged for not<br>&gt; satisfying the requirement. Turtles all the way down. Still need an escape<br>&gt; hatch.<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 11:54 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ll write up a draft proposal :) I think we have something nice :)<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt;<br>&gt;&gt; On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Nicer still!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I guess that would make sense and you could wrap the callback up in a<br>&gt;&gt;&gt;&gt; anon-closure if the module hadn&#39;t adpated the @required property so you get<br>&gt;&gt;&gt;&gt; both compatibility, safety and clarity.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt;&gt;&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt;&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will<br>&gt;&gt;&gt;&gt;&gt;&gt; penalise your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen<br>&gt;&gt;&gt;&gt;&gt;&gt; if this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt;&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt;&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which case<br>&gt;&gt;&gt;&gt;&gt; you can pass the closure on to other functions so long as they also have<br>&gt;&gt;&gt;&gt;&gt; the @noescape attribute? In this case passing it as a parameter to another<br>&gt;&gt;&gt;&gt;&gt; method with the @required attribute would be equivalent to calling it<br>&gt;&gt;&gt;&gt;&gt; directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/57638394/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>Well, the callsite @required would be what I call your escape hatch :)<br></p><p>Hmm, lemme think on this...<br>On Tue, Aug 16, 2016 at 11:59 James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; It would though, look :) :<br>&gt;<br>&gt; Backend.run() { requiredCallback in<br>&gt;<br>&gt;  NonAnotatedModuled({<br>&gt;<br>&gt; //We send a anon closure to the module and we call the callback with a<br>&gt; required specifier to indicate to the compiler it will be called :)<br>&gt; @required requiredCallback()<br>&gt; })<br>&gt; }<br>&gt;<br>&gt; This would be the same as this:<br>&gt;<br>&gt;<br>&gt; Backend.run() { requiredCallback in<br>&gt;<br>&gt;  AnotatedModuled(requiredCallback)<br>&gt; }<br>&gt;<br>&gt; And this:<br>&gt;<br>&gt;<br>&gt; Backend.run() { requiredCallback in<br>&gt;<br>&gt; @required requiredCallback()<br>&gt; }<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Hustler*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On 16 August 2016 at 17:55, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Wait, doesn&#39;t work. Your anonymous closure would then be dinged for not<br>&gt;&gt; satisfying the requirement. Turtles all the way down. Still need an escape<br>&gt;&gt; hatch.<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 16, 2016 at 11:54 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;ll write up a draft proposal :) I think we have something nice :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Nicer still!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I guess that would make sense and you could wrap the callback up in a<br>&gt;&gt;&gt;&gt;&gt; anon-closure if the module hadn&#39;t adpated the @required property so you get<br>&gt;&gt;&gt;&gt;&gt; both compatibility, safety and clarity.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to work<br>&gt;&gt;&gt;&gt;&gt;&gt; around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt;&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt;&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt;&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt;&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalise your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can happen<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if this callback isn&#39;t called such as iOS peanlizing them for not ending a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; background task or perhaps memory leaks caused by clean up code unable to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be triggered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which<br>&gt;&gt;&gt;&gt;&gt;&gt; case you can pass the closure on to other functions so long as they also<br>&gt;&gt;&gt;&gt;&gt;&gt; have the @noescape attribute? In this case passing it as a parameter to<br>&gt;&gt;&gt;&gt;&gt;&gt; another method with the @required attribute would be equivalent to calling<br>&gt;&gt;&gt;&gt;&gt;&gt; it directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/f4beb1fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Required Callback</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>One alternative that comes to mind:<br></p><p>The @escaping stuff came with a helper function, withoutActuallyEscaping,<br>to deal with attribute mismatches. Perhaps we could have the same here, for<br>consistency, something like withActuallyInvoking?<br>On Tue, Aug 16, 2016 at 12:05 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Well, the callsite @required would be what I call your escape hatch :)<br>&gt;<br>&gt; Hmm, lemme think on this...<br>&gt; On Tue, Aug 16, 2016 at 11:59 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;<br>&gt;&gt; It would though, look :) :<br>&gt;&gt;<br>&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;<br>&gt;&gt;  NonAnotatedModuled({<br>&gt;&gt;<br>&gt;&gt; //We send a anon closure to the module and we call the callback with a<br>&gt;&gt; required specifier to indicate to the compiler it will be called :)<br>&gt;&gt; @required requiredCallback()<br>&gt;&gt; })<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This would be the same as this:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;<br>&gt;&gt;  AnotatedModuled(requiredCallback)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; And this:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;<br>&gt;&gt; @required requiredCallback()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt;<br>&gt;&gt; On 16 August 2016 at 17:55, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Wait, doesn&#39;t work. Your anonymous closure would then be dinged for not<br>&gt;&gt;&gt; satisfying the requirement. Turtles all the way down. Still need an escape<br>&gt;&gt;&gt; hatch.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:54 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ll write up a draft proposal :) I think we have something nice :)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Nicer still!<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I guess that would make sense and you could wrap the callback up in a<br>&gt;&gt;&gt;&gt;&gt;&gt; anon-closure if the module hadn&#39;t adpated the @required property so you get<br>&gt;&gt;&gt;&gt;&gt;&gt; both compatibility, safety and clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; work around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optional descriptive message i.e<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalise your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; happen if this callback isn&#39;t called such as iOS peanlizing them for not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ending a background task or perhaps memory leaks caused by clean up code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unable to be triggered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case you can pass the closure on to other functions so long as they also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have the @noescape attribute? In this case passing it as a parameter to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; another method with the @required attribute would be equivalent to calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/fa8bf61d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 08:00:00pm</p></header><div class="content"><p>That sounds fair, the closure that function returns could trigger a runtime<br>warning when it detects the closure has be deallocated without being<br>triggered (or even mutliple times but ofc not the focus for this proposal)<br></p><p><br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 18:39, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; One alternative that comes to mind:<br>&gt;<br>&gt; The @escaping stuff came with a helper function, withoutActuallyEscaping,<br>&gt; to deal with attribute mismatches. Perhaps we could have the same here, for<br>&gt; consistency, something like withActuallyInvoking?<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 12:05 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Well, the callsite @required would be what I call your escape hatch :)<br>&gt;&gt;<br>&gt;&gt; Hmm, lemme think on this...<br>&gt;&gt; On Tue, Aug 16, 2016 at 11:59 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It would though, look :) :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  NonAnotatedModuled({<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //We send a anon closure to the module and we call the callback with a<br>&gt;&gt;&gt; required specifier to indicate to the compiler it will be called :)<br>&gt;&gt;&gt; @required requiredCallback()<br>&gt;&gt;&gt; })<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would be the same as this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  AnotatedModuled(requiredCallback)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @required requiredCallback()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 16 August 2016 at 17:55, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Wait, doesn&#39;t work. Your anonymous closure would then be dinged for not<br>&gt;&gt;&gt;&gt; satisfying the requirement. Turtles all the way down. Still need an escape<br>&gt;&gt;&gt;&gt; hatch.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:54 James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;ll write up a draft proposal :) I think we have something nice :)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Nicer still!<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I guess that would make sense and you could wrap the callback up in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a anon-closure if the module hadn&#39;t adpated the @required property so you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; get both compatibility, safety and clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; work around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an optional descriptive message i.e<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalise your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; happen if this callback isn&#39;t called such as iOS peanlizing them for not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ending a background task or perhaps memory leaks caused by clean up code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unable to be triggered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case you can pass the closure on to other functions so long as they also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have the @noescape attribute? In this case passing it as a parameter to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; another method with the @required attribute would be equivalent to calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/458bb341/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Proposed ! https://github.com/apple/swift-evolution/pull/502<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 20:44, James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; That sounds fair, the closure that function returns could trigger a<br>&gt; runtime warning when it detects the closure has be deallocated without<br>&gt; being triggered (or even mutliple times but ofc not the focus for this<br>&gt; proposal)<br>&gt;<br>&gt;<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Hustler*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On 16 August 2016 at 18:39, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; One alternative that comes to mind:<br>&gt;&gt;<br>&gt;&gt; The @escaping stuff came with a helper function, withoutActuallyEscaping,<br>&gt;&gt; to deal with attribute mismatches. Perhaps we could have the same here, for<br>&gt;&gt; consistency, something like withActuallyInvoking?<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 16, 2016 at 12:05 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Well, the callsite @required would be what I call your escape hatch :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hmm, lemme think on this...<br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:59 James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would though, look :) :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  NonAnotatedModuled({<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; //We send a anon closure to the module and we call the callback with a<br>&gt;&gt;&gt;&gt; required specifier to indicate to the compiler it will be called :)<br>&gt;&gt;&gt;&gt; @required requiredCallback()<br>&gt;&gt;&gt;&gt; })<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This would be the same as this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  AnotatedModuled(requiredCallback)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Backend.run() { requiredCallback in<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @required requiredCallback()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 16 August 2016 at 17:55, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Wait, doesn&#39;t work. Your anonymous closure would then be dinged for<br>&gt;&gt;&gt;&gt;&gt; not satisfying the requirement. Turtles all the way down. Still need an<br>&gt;&gt;&gt;&gt;&gt; escape hatch.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:54 James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ll write up a draft proposal :) I think we have something nice :)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 16 August 2016 at 17:54, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nicer still!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 11:53 James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I guess that would make sense and you could wrap the callback up in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a anon-closure if the module hadn&#39;t adpated the @required property so you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; get both compatibility, safety and clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *___________________________________*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *Sup*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *Runway East *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *London*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * EC2A 1AF *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 August 2016 at 17:50, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 16 Aug 2016, at 15:49, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can see the use case, but it&#39;d be annoying (or, impossible) to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; work around if I intend to call `end` by passing it to a helper function in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; another (let&#39;s say, precompiled) module. There&#39;s no way for the compiler to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inspect that `end` is always called by that other module, and if calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `end` twice causes bad things to happen, I&#39;m totally out of luck. You&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need a companion annotation to pass along the requirement to the callee, or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some sort of force-unrequire, but the latter can&#39;t have teeth (i.e. can&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enforce at runtime) if the closure is escaping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 08:39 James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be handy if a callback could be marked as required with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an optional descriptive message i.e<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class BackgroundTask {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func run(end: @required(&quot;You must call end otherwise iOS will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; penalise your app for being a bad citizen&quot;) () -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That was the developer can comunicate the bad things that can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; happen if this callback isn&#39;t called such as iOS peanlizing them for not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ending a background task or perhaps memory leaks caused by clean up code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unable to be triggered.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Could this not just behave in the same way as @noescape, in which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case you can pass the closure on to other functions so long as they also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have the @noescape attribute? In this case passing it as a parameter to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; another method with the @required attribute would be equivalent to calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it directly (since you know the other method must eventually call it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/e93f8339/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>Required Callback</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>August 16, 2016 at 11:00:00pm</p></header><div class="content"><p>What are the differences between <br>&lt;https://github.com/apple/swift-evolution/pull/502&gt; and <br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md&gt;<br>?<br></p><p>application(_:handleEventsForBackgroundURLSession:completionHandler:) <br>has an @escaping `completionHandler`, so can @required be enforced?<br></p><p>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008478.html&gt;<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 11:00:00pm</p></header><div class="content"><p>@noescape is a hint that the callback will only be called once and allows<br>compiler to optimise, we may or may not be able to combine @required<br>functionality into that but it looks like it was rejected for now.<br></p><p>@required is a compiler hint / sanity check to enforce that the callback is<br>actually called once by the developer. There is no focus on any compiler<br>enhancements other than that.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/a1b17a67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 16, 2016 at 11:00:00pm</p></header><div class="content"><p>​I&#39;m not sure about that last question, I guess someone who knows more<br>about it than me could answer.​<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 16 August 2016 at 23:37, James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; @noescape is a hint that the callback will only be called once and allows<br>&gt; compiler to optimise, we may or may not be able to combine @required<br>&gt; functionality into that but it looks like it was rejected for now.<br>&gt;<br>&gt; @required is a compiler hint / sanity check to enforce that the callback<br>&gt; is actually called once by the developer. There is no focus on any compiler<br>&gt; enhancements other than that.<br>&gt; ​<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/15f2caff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>Required Callback</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August 17, 2016 at 01:00:00am</p></header><div class="content"><p>Why the callback is special ?<br></p><p>The compiler should has a warning for unused parameters of function.<br></p><p>I think this is enough. More works should be leaved for a lint tool.<br></p><p><br>James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月17日<br>周三06:39写道：<br></p><p>&gt; ​I&#39;m not sure about that last question, I guess someone who knows more<br>&gt; about it than me could answer.​<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Lead Hustler*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On 16 August 2016 at 23:37, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;<br>&gt;&gt; @noescape is a hint that the callback will only be called once and allows<br>&gt;&gt; compiler to optimise, we may or may not be able to combine @required<br>&gt;&gt; functionality into that but it looks like it was rejected for now.<br>&gt;&gt;<br>&gt;&gt; @required is a compiler hint / sanity check to enforce that the callback<br>&gt;&gt; is actually called once by the developer. There is no focus on any compiler<br>&gt;&gt; enhancements other than that.<br>&gt;&gt; ​<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/f3f86b7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 17, 2016 at 09:00:00am</p></header><div class="content"><p>​Thats true, my only concern with that is if the user disables that<br>warning.​<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 17 August 2016 at 02:49, Boris Wang &lt;kona.ming at gmail.com&gt; wrote:<br></p><p>&gt; Why the callback is special ?<br>&gt;<br>&gt; The compiler should has a warning for unused parameters of function.<br>&gt;<br>&gt; I think this is enough. More works should be leaved for a lint tool.<br>&gt;<br>&gt;<br>&gt; James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月17日<br>&gt; 周三06:39写道：<br>&gt;<br>&gt;&gt; ​I&#39;m not sure about that last question, I guess someone who knows more<br>&gt;&gt; about it than me could answer.​<br>&gt;&gt;<br>&gt;&gt; *___________________________________*<br>&gt;&gt;<br>&gt;&gt; *James⎥Lead Hustler*<br>&gt;&gt;<br>&gt;&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt;&gt; &lt;http://supmenow.com&gt;*<br>&gt;&gt;<br>&gt;&gt; *Sup*<br>&gt;&gt;<br>&gt;&gt; *Runway East *<br>&gt;&gt;<br>&gt;&gt; *10 Finsbury Square*<br>&gt;&gt;<br>&gt;&gt; *London*<br>&gt;&gt;<br>&gt;&gt; * EC2A 1AF *<br>&gt;&gt;<br>&gt;&gt; On 16 August 2016 at 23:37, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; @noescape is a hint that the callback will only be called once and<br>&gt;&gt;&gt; allows compiler to optimise, we may or may not be able to combine @required<br>&gt;&gt;&gt; functionality into that but it looks like it was rejected for now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @required is a compiler hint / sanity check to enforce that the callback<br>&gt;&gt;&gt; is actually called once by the developer. There is no focus on any compiler<br>&gt;&gt;&gt; enhancements other than that.<br>&gt;&gt;&gt; ​<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/cc16a4ed/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Required Callback</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 17, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 17 Aug 2016, at 02:49, Boris Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why the callback is special ?<br>&gt; <br>&gt; The compiler should has a warning for unused parameters of function.<br>&gt; <br>&gt; I think this is enough. More works should be leaved for a lint tool.<br></p><p>Actually I think that that kind of warning should be left for linters as well; a protocol might define parameters that not all implementations use, or a type may define a method with a parameter that is intended only for future use (to avoid defining an overload later), these aren&#39;t necessarily problems.<br></p><p>Also, how do you want to define unused? I suppose a non-escaping closure is unused if it&#39;s never called (since it can&#39;t be stored), but that doesn&#39;t guarantee that it *will* be called, which is the point of this proposal, i.e- a non-escaping closure may be part of a loop that may not execute, which is fine since it has no requirement to be used in every call, only that it isn&#39;t stored.<br></p><p>So yeah, even if a warning like this could be done right, I&#39;m not sure it replaces the case put forward for @required.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 17, 2016 at 03:00:00pm</p></header><div class="content"><p>In this case the @required callback is something *all* implementations<br>should use for the mentioned reasons (memory leaks etc) just to clarify :).<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 17 August 2016 at 11:31, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 17 Aug 2016, at 02:49, Boris Wang via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Why the callback is special ?<br>&gt; &gt;<br>&gt; &gt; The compiler should has a warning for unused parameters of function.<br>&gt; &gt;<br>&gt; &gt; I think this is enough. More works should be leaved for a lint tool.<br>&gt;<br>&gt; Actually I think that that kind of warning should be left for linters as<br>&gt; well; a protocol might define parameters that not all implementations use,<br>&gt; or a type may define a method with a parameter that is intended only for<br>&gt; future use (to avoid defining an overload later), these aren&#39;t necessarily<br>&gt; problems.<br>&gt;<br>&gt; Also, how do you want to define unused? I suppose a non-escaping closure<br>&gt; is unused if it&#39;s never called (since it can&#39;t be stored), but that doesn&#39;t<br>&gt; guarantee that it *will* be called, which is the point of this proposal,<br>&gt; i.e- a non-escaping closure may be part of a loop that may not execute,<br>&gt; which is fine since it has no requirement to be used in every call, only<br>&gt; that it isn&#39;t stored.<br>&gt;<br>&gt; So yeah, even if a warning like this could be done right, I&#39;m not sure it<br>&gt; replaces the case put forward for @required.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/9ea412b3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Required Callback</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 17, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 12:44 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That sounds fair, the closure that function returns could trigger a runtime warning when it detects the closure has be deallocated without being triggered (or even mutliple times but ofc not the focus for this proposal)<br></p><p>You know, I&#39;m thinking about that &quot;multiple times&quot; thing...<br></p><p>We know we want a @once (formerly @noescape(once)) for closures which are guaranteed to be called exactly once. This would help us with initializing variables, and especially properties, from a closure. Perhaps we should extend that to support @escaping @once. Would that handle these use cases? Are there use cases for @required where you expect more than one call? I think all of the use cases we&#39;ve discussed here—ending handlers and such—should only be called once.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Required Callback</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>August 17, 2016 at 03:00:00pm</p></header><div class="content"><p>Most of the cases I can think of for @required are for clean up mechanisms<br>triggered by the closure and as such would only need to be called once.<br></p><p>So in theory @once may be able to cover this case, in a sense I guess you<br>could argue @once is just a subset of @required it would check it is<br>exactly once. But @required is about making sure it is called at all.<br></p><p>*___________________________________*<br></p><p>*James⎥Lead Hustler*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 17 August 2016 at 13:43, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Aug 16, 2016, at 12:44 PM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; That sounds fair, the closure that function returns could trigger a<br>&gt; runtime warning when it detects the closure has be deallocated without<br>&gt; being triggered (or even mutliple times but ofc not the focus for this<br>&gt; proposal)<br>&gt;<br>&gt; You know, I&#39;m thinking about that &quot;multiple times&quot; thing...<br>&gt;<br>&gt; We know we want a @once (formerly @noescape(once)) for closures which are<br>&gt; guaranteed to be called exactly once. This would help us with initializing<br>&gt; variables, and especially properties, from a closure. Perhaps we should<br>&gt; extend that to support @escaping @once. Would that handle these use cases?<br>&gt; Are there use cases for @required where you expect more than one call? I<br>&gt; think all of the use cases we&#39;ve discussed here—ending handlers and<br>&gt; such—should only be called once.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/853d3b93/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
