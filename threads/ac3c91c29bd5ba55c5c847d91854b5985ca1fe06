<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 10, 2016 at 07:00:00pm</p></header><div class="content"><p>I really love this idea.  My mental model of it is that it is exactly like ‘defer’, except it works on the lifetime of the object instance instead of a function/method.  Same thing, different scope.<br></p><p>I like how the creation and destruction are right next to one another.  It also solves a lot of potential issues with partial initialization, I believe.<br></p><p>I might spell it ‘deferToDeinit’ or &#39;deferUntilDeinit&#39;<br></p><p>The only issue I see is accidentally capturing self strongly.  Is there a way to mark a closure as implicitly unowned self so the end programmer doesn’t have to worry about it?<br></p><p>Thanks,<br>Jon<br>&gt; Twitter tl;dr: <br>&gt; &gt; Brent: So each instance must remember which init was used for it and then run the matching deinit code at deinit time?<br>&gt; &gt; Me: In my version, the constructive act and destructive act are always paired, even redundantly, using a stack if needed<br>&gt; &gt; Graham: so all your deferredDeinit blocks would run, no matter which init was invoked?<br>&gt; &gt; Brent: Closure stack in the worst case. Might be able to optimize to something cheaper if no captures.  Degenerate case: `for i in 0..&lt;10 { deinit { print(i) } <br>&gt; <br>&gt; So continuing on from Twitter, assuming the compiler cannot optimize in the case of multiple inits, and init-redirections, how about allowing traditional deinit as well, and introduce compile-time optimization into traditional de-init if the compiler finds only one initialization path per class? We can also warn anyone using my version in a complicated degenerate way that it can be costly through education, manual, etc. It would also help if (especially in Cocoa), you could legally use shared initialization setup closures.<br>&gt; <br>&gt; If I create an observer, I want to be able to handle its end-of-life at that point. If I allocate memory, ditto. Etc etc. Surely Swift should be able to support doing this.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; &gt; On Jun 8, 2016, at 3:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I really like this idea. Spatially moving cleanup next to unsafe operations is good practice.<br>&gt; &gt; <br>&gt; &gt; In normal code, I want my cleanup to follow as closely as possible to my unsafe act:<br>&gt; &gt; <br>&gt; &gt; let buffer: UnsafeMutablePointer&lt;CChar&gt; = UnsafeMutablePointer(allocatingCapacity: chunkSize)<br>&gt; &gt;     defer { buffer.deallocateCapacity(chunkSize) }<br>&gt; &gt; <br>&gt; &gt; (Sorry for the horrible example, but it&#39;s the best I could grep up with on a moment&#39;s notice)<br>&gt; &gt; <br>&gt; &gt; I like your idea but what I want to see is not the deinit child closure in init you propose but a new keyword that means defer-on-deinit-cleanup<br>&gt; &gt; <br>&gt; &gt; self.ptr = UnsafeMutablePointer&lt;T&gt;(allocatingCapacity: count)<br>&gt; &gt;     deferringDeInit { self.ptr.deallocateCapacity(count) }<br>&gt; &gt; <br>&gt; &gt; Or something.<br>&gt; &gt; <br>&gt; &gt; -- E<br>&gt; &gt; p.s. Normally I put them on the same line with a semicolon but dang these things can be long<br>&gt; &gt; <br>&gt; &gt;&gt; On Jun 8, 2016, at 10:54 AM, Graham Perks via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; &lt;mailto:swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Teach init a &#39;defer&#39;-like ability to deinit<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; &#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Swift offers no support for resources acquired during &#39;init&#39;.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt; &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;&gt;<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt; &gt;&gt;     self.count = count<br>&gt; &gt;&gt;     self.space = count<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt; &gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; deinit {<br>&gt; &gt;&gt;     ptr.destroy(...)<br>&gt; &gt;&gt;     ptr.dealloc(...)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt; &gt;&gt;     self.count = count<br>&gt; &gt;&gt;     self.space = count<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt; &gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;     deinit {<br>&gt; &gt;&gt;         ptr.destroy(...)<br>&gt; &gt;&gt;         ptr.dealloc(...)<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;     // NSNotificationCenter example too<br>&gt; &gt;&gt;     NSNotificationCenter.defaultCenter().addObserver(...)<br>&gt; &gt;&gt;     deinit { <br>&gt; &gt;&gt;         NSNotificationCenter.defaultCenter().removeObserver(...)<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Considerations:<br>&gt; &gt;&gt; 1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>&gt; &gt;&gt; 2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>&gt; &gt;&gt; 3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br>&gt; &gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/ac3cfe06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 10, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Jun 10, 2016 at 9:55 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I really love this idea.  My mental model of it is that it is exactly like<br>&gt; ‘defer’, except it works on the lifetime of the object instance instead of<br>&gt; a function/method.  Same thing, different scope.<br>&gt;<br>&gt; I like how the creation and destruction are right next to one another.  It<br>&gt; also solves a lot of potential issues with partial initialization, I<br>&gt; believe.<br>&gt;<br>&gt; I might spell it ‘deferToDeinit’ or &#39;deferUntilDeinit&#39;<br>&gt;<br>&gt; The only issue I see is accidentally capturing self strongly.  Is there a<br>&gt; way to mark a closure as implicitly unowned self so the end programmer<br>&gt; doesn’t have to worry about it?<br>&gt;<br></p><p>I really like this idea as well. Does it need to be a regular closure? This<br>is one of those things that can be built into the language itself, surely?<br>Then the implicitly unowned self part would be taken care of...<br></p><p><br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; Twitter tl;dr:<br>&gt; &gt;* Brent: So each instance must remember which init was used for it and then run the matching deinit code at deinit time?<br>&gt; *&gt;* Me: In my version, the constructive act and destructive act are always paired, even redundantly, using a stack if needed<br>&gt; *&gt;* Graham: so all your deferredDeinit blocks would run, no matter which init was invoked?<br>&gt; *&gt;* Brent: Closure stack in the worst case. Might be able to optimize to something cheaper if no captures.  Degenerate case: `for i in 0..&lt;10 { deinit { print(i) }<br>&gt; *<br>&gt; So continuing on from Twitter, assuming the compiler cannot optimize in the case of multiple inits, and init-redirections, how about allowing traditional deinit as well, and introduce compile-time optimization into traditional de-init if the compiler finds only one initialization path per class? We can also warn anyone using my version in a complicated degenerate way that it can be costly through education, manual, etc. It would also help if (especially in Cocoa), you could legally use shared initialization setup closures.<br>&gt;<br>&gt; If I create an observer, I want to be able to handle its end-of-life at that point. If I allocate memory, ditto. Etc etc. Surely Swift should be able to support doing this.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; &gt;* On Jun 8, 2016, at 3:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; *&gt; &gt;* I really like this idea. Spatially moving cleanup next to unsafe operations is good practice.<br>&gt; *&gt; &gt;* In normal code, I want my cleanup to follow as closely as possible to my unsafe act:<br>&gt; *&gt; &gt;* let buffer: UnsafeMutablePointer&lt;CChar&gt; = UnsafeMutablePointer(allocatingCapacity: chunkSize)<br>&gt; *&gt;*     defer { buffer.deallocateCapacity(chunkSize) }<br>&gt; *&gt; &gt;* (Sorry for the horrible example, but it&#39;s the best I could grep up with on a moment&#39;s notice)<br>&gt; *&gt; &gt;* I like your idea but what I want to see is not the deinit child closure in init you propose but a new keyword that means defer-on-deinit-cleanup<br>&gt; *&gt; &gt;* self.ptr = UnsafeMutablePointer&lt;T&gt;(allocatingCapacity: count)<br>&gt; *&gt;*     deferringDeInit { self.ptr.deallocateCapacity(count) }<br>&gt; *&gt; &gt;* Or something.<br>&gt; *&gt; &gt;* -- E<br>&gt; *&gt;* p.s. Normally I put them on the same line with a semicolon but dang these things can be long<br>&gt; *&gt; &gt;&gt;* On Jun 8, 2016, at 10:54 AM, Graham Perks via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; &lt;mailto:swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt; wrote:<br>&gt; *&gt;&gt; &gt;&gt;* Teach init a &#39;defer&#39;-like ability to deinit<br>&gt; *&gt;&gt; &gt;&gt;* &#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br>&gt; *&gt;&gt; &gt;&gt;* Swift offers no support for resources acquired during &#39;init&#39;.<br>&gt; *&gt;&gt; &gt;&gt;* For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt; &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;&gt;<br>&gt; *<br>&gt; &gt;&gt; &gt;&gt;* init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt; *&gt;&gt;*     self.count = count<br>&gt; *&gt;&gt;*     self.space = count<br>&gt; *&gt;&gt; &gt;&gt;*     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt; *&gt;&gt;*     self.ptr.initializeFrom(ptr, count: count)<br>&gt; *&gt;&gt;* }<br>&gt; *&gt;&gt; &gt;&gt;* deinit {<br>&gt; *&gt;&gt;*     ptr.destroy(...)<br>&gt; *&gt;&gt;*     ptr.dealloc(...)<br>&gt; *&gt;&gt;* }<br>&gt; *&gt;&gt; &gt;&gt;* Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br>&gt; *&gt;&gt; &gt;&gt;* Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br>&gt; *&gt;&gt; &gt;&gt;* init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt; *&gt;&gt;*     self.count = count<br>&gt; *&gt;&gt;*     self.space = count<br>&gt; *&gt;&gt; &gt;&gt;*     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt; *&gt;&gt;*     self.ptr.initializeFrom(ptr, count: count)<br>&gt; *&gt;&gt; &gt;&gt;*     deinit {<br>&gt; *&gt;&gt;*         ptr.destroy(...)<br>&gt; *&gt;&gt;*         ptr.dealloc(...)<br>&gt; *&gt;&gt;*     }<br>&gt; *&gt;&gt; &gt;&gt;*     // NSNotificationCenter example too<br>&gt; *&gt;&gt;*     NSNotificationCenter.defaultCenter().addObserver(...)<br>&gt; *&gt;&gt;*     deinit {<br>&gt; *&gt;&gt;*         NSNotificationCenter.defaultCenter().removeObserver(...)<br>&gt; *&gt;&gt;*     }<br>&gt; *&gt;&gt;* }<br>&gt; *&gt;&gt; &gt;&gt;* The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br>&gt; *&gt;&gt; &gt;&gt;* Considerations:<br>&gt; *&gt;&gt;* 1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>&gt; *&gt;&gt;* 2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>&gt; *&gt;&gt;* 3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br>&gt; *&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/59c6f11f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 13, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 5:18 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jun 10, 2016 at 9:55 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I really love this idea.  My mental model of it is that it is exactly like ‘defer’, except it works on the lifetime of the object instance instead of a function/method.  Same thing, different scope.<br>&gt; <br>&gt; I like how the creation and destruction are right next to one another.  It also solves a lot of potential issues with partial initialization, I believe.<br>&gt; <br>&gt; I might spell it ‘deferToDeinit’ or &#39;deferUntilDeinit&#39;<br>&gt; <br>&gt; The only issue I see is accidentally capturing self strongly.  Is there a way to mark a closure as implicitly unowned self so the end programmer doesn’t have to worry about it?<br>&gt; <br>&gt; I really like this idea as well. Does it need to be a regular closure? This is one of those things that can be built into the language itself, surely? Then the implicitly unowned self part would be taken care of...<br></p><p>This should be handled by the compiler and the code within the block should be used to create a deinit method.<br></p><p>Several issues to deal with:<br></p><p>- if there are deferred de-inits in init, is regular deinit {} allowed? If yes, does the deferred deinit code from init get called before or after?<br></p><p>- what if there are several initializers and each has its own deferred de-inits? Would the instance need to keep the information which initializer was used and call proper deinit based on that?<br></p><p>&gt;  <br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt;&gt; Twitter tl;dr: <br>&gt;&gt; &gt; Brent: So each instance must remember which init was used for it and then run the matching deinit code at deinit time?<br>&gt;&gt; &gt; Me: In my version, the constructive act and destructive act are always paired, even redundantly, using a stack if needed<br>&gt;&gt; &gt; Graham: so all your deferredDeinit blocks would run, no matter which init was invoked?<br>&gt;&gt; &gt; Brent: Closure stack in the worst case. Might be able to optimize to something cheaper if no captures.  Degenerate case: `for i in 0..&lt;10 { deinit { print(i) } <br>&gt;&gt; <br>&gt;&gt; So continuing on from Twitter, assuming the compiler cannot optimize in the case of multiple inits, and init-redirections, how about allowing traditional deinit as well, and introduce compile-time optimization into traditional de-init if the compiler finds only one initialization path per class? We can also warn anyone using my version in a complicated degenerate way that it can be costly through education, manual, etc. It would also help if (especially in Cocoa), you could legally use shared initialization setup closures.<br>&gt;&gt; <br>&gt;&gt; If I create an observer, I want to be able to handle its end-of-life at that point. If I allocate memory, ditto. Etc etc. Surely Swift should be able to support doing this.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 8, 2016, at 3:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I really like this idea. Spatially moving cleanup next to unsafe operations is good practice.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; In normal code, I want my cleanup to follow as closely as possible to my unsafe act:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; let buffer: UnsafeMutablePointer&lt;CChar&gt; = UnsafeMutablePointer(allocatingCapacity: chunkSize)<br>&gt;&gt; &gt;     defer { buffer.deallocateCapacity(chunkSize) }<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; (Sorry for the horrible example, but it&#39;s the best I could grep up with on a moment&#39;s notice)<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I like your idea but what I want to see is not the deinit child closure in init you propose but a new keyword that means defer-on-deinit-cleanup<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; self.ptr = UnsafeMutablePointer&lt;T&gt;(allocatingCapacity: count)<br>&gt;&gt; &gt;     deferringDeInit { self.ptr.deallocateCapacity(count) }<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Or something.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt; p.s. Normally I put them on the same line with a semicolon but dang these things can be long<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; On Jun 8, 2016, at 10:54 AM, Graham Perks via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; &lt;mailto:swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Teach init a &#39;defer&#39;-like ability to deinit<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; &#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Swift offers no support for resources acquired during &#39;init&#39;.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt; &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;&gt;<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;&gt; &gt;&gt;     self.count = count<br>&gt;&gt; &gt;&gt;     self.space = count<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;&gt; &gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; deinit {<br>&gt;&gt; &gt;&gt;     ptr.destroy(...)<br>&gt;&gt; &gt;&gt;     ptr.dealloc(...)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;&gt; &gt;&gt;     self.count = count<br>&gt;&gt; &gt;&gt;     self.space = count<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;&gt; &gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;     deinit {<br>&gt;&gt; &gt;&gt;         ptr.destroy(...)<br>&gt;&gt; &gt;&gt;         ptr.dealloc(...)<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;     // NSNotificationCenter example too<br>&gt;&gt; &gt;&gt;     NSNotificationCenter.defaultCenter().addObserver(...)<br>&gt;&gt; &gt;&gt;     deinit { <br>&gt;&gt; &gt;&gt;         NSNotificationCenter.defaultCenter().removeObserver(...)<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Considerations:<br>&gt;&gt; &gt;&gt; 1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>&gt;&gt; &gt;&gt; 2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>&gt;&gt; &gt;&gt; 3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br>&gt;&gt; &gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/f0cf05fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
