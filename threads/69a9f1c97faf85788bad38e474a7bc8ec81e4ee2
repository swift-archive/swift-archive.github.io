<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bbea2d379c2fdc51fe02db1c3caa15de?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Dan Raviv</string> &lt;dan.raviv at gmail.com&gt;<p>March 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Would it make sense to allow mutable properties in structs, which could be<br>mutated even by non-mutating methods?<br></p><p>I&#39;ve noticed this could be useful when implementing a non-mutating protocol<br>method. The method semantically doesn&#39;t change the state of the protocol&#39;s<br>implementor, and therefore shouldn&#39;t be declared as mutating. However,<br>*some* implementations might need to change some internal state for<br>implementing the functionality. Making specific struct properties mutable<br>for such a case could make sense.<br></p><p>Alternatively, Swift could allow implementing a non-mutating protocol<br>method as a mutating method in the implementor. Currently, this doesn&#39;t<br>seem to be  allowed; Swift doesn&#39;t recognize the mutating method as a match<br>for the non-mutating protocol method.<br></p><p>Cheers,<br>Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/69a94ee2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Would it make sense to allow mutable properties in structs, which could be mutated even by non-mutating methods?<br></p><p>This would break the whole mutability model of structs. The whole idea is: structs are always immutable, and you can mark things as “mutable”, but this can only happen if a struct is assigned to a mutable variable.<br></p><p>— Radek<br></p><p>&gt; On 11 Mar 2016, at 11:38, Dan Raviv via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it make sense to allow mutable properties in structs, which could be mutated even by non-mutating methods?<br>&gt; <br>&gt; I&#39;ve noticed this could be useful when implementing a non-mutating protocol method. The method semantically doesn&#39;t change the state of the protocol&#39;s implementor, and therefore shouldn&#39;t be declared as mutating. However, *some* implementations might need to change some internal state for implementing the functionality. Making specific struct properties mutable for such a case could make sense.<br>&gt; <br>&gt; Alternatively, Swift could allow implementing a non-mutating protocol method as a mutating method in the implementor. Currently, this doesn&#39;t seem to be  allowed; Swift doesn&#39;t recognize the mutating method as a match for the non-mutating protocol method.<br>&gt; <br>&gt; Cheers,<br>&gt; Dan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree with Radek, -1 on this.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 11.03.2016, o godz. 12:26:<br>&gt; <br>&gt;&gt; Would it make sense to allow mutable properties in structs, which could be mutated even by non-mutating methods?<br>&gt; <br>&gt; This would break the whole mutability model of structs. The whole idea is: structs are always immutable, and you can mark things as “mutable”, but this can only happen if a struct is assigned to a mutable variable.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 11 Mar 2016, at 11:38, Dan Raviv via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it make sense to allow mutable properties in structs, which could be mutated even by non-mutating methods?<br>&gt;&gt; <br>&gt;&gt; I&#39;ve noticed this could be useful when implementing a non-mutating protocol method. The method semantically doesn&#39;t change the state of the protocol&#39;s implementor, and therefore shouldn&#39;t be declared as mutating. However, *some* implementations might need to change some internal state for implementing the functionality. Making specific struct properties mutable for such a case could make sense.<br>&gt;&gt; <br>&gt;&gt; Alternatively, Swift could allow implementing a non-mutating protocol method as a mutating method in the implementor. Currently, this doesn&#39;t seem to be  allowed; Swift doesn&#39;t recognize the mutating method as a match for the non-mutating protocol method.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Dan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/bc03588e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 11, 2016, at 2:38 AM, Dan Raviv via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it make sense to allow mutable properties in structs, which could be mutated even by non-mutating methods?<br>&gt; <br>&gt; I&#39;ve noticed this could be useful when implementing a non-mutating protocol method. The method semantically doesn&#39;t change the state of the protocol&#39;s implementor, and therefore shouldn&#39;t be declared as mutating. However, *some* implementations might need to change some internal state for implementing the functionality. Making specific struct properties mutable for such a case could make sense.<br>&gt; <br>&gt; Alternatively, Swift could allow implementing a non-mutating protocol method as a mutating method in the implementor. Currently, this doesn&#39;t seem to be  allowed; Swift doesn&#39;t recognize the mutating method as a match for the non-mutating protocol method.<br></p><p>We currently have the property that, even in generic code, we can assume that an immutable value of type T is safe from read-read races, either because all types are never changed by immutable operations or are accessed through runtime calls with the appropriate synchronization (retain/release, weak references). To preserve these &#39;let&#39; semantics with mutable fields, it would have to be the implementor&#39;s responsibility to ensure its mutating accesses are properly synchronized. Note that you can already get the effect of a mutable field in a struct by embedding a reference to a mutable class reference:<br></p><p>struct Foo {<br>  var x: Int<br>  class MutableFields {<br>    var y: Int<br>    init(y: Int) { self.y = y }<br>  }<br></p><p>  private var mutableFields: MutableFields<br>  var y: Int {<br>    get { return mutableFields.y }<br>    set { mutableFields.y = newValue }<br>  }<br>}<br></p><p>This can for instance be used to implement a memoized lazy field, as in https://github.com/robrix/Memo.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/bade3349/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>March 12, 2016 at 04:00:00am</p></header><div class="content"><p>In general, I like things the way they are.<br></p><p>The only exception to this is that it would be nice occasionally to have an<br>easy way to make mutable computed property.<br></p><p>For example, to allow &quot;array.first&quot; or &quot;array.last&quot; to be mutable.<br></p><p>I have a feeling this would be difficult to implement (i.e.: most of Swift<br>is designed to pass values and structs as copies, so within your getter if<br>you as much as &quot;var tempA = a&quot; you ave a copy). Having said that, I have<br>had occasions where not being able to do so has annoyed me.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160312/16d870e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>March 12, 2016 at 05:00:00am</p></header><div class="content"><p>... just to clarify my last comment.<br></p><p>Maybe &quot;array.first&quot; and &quot;array.last&quot; is a bad example, since it was<br>probably a design choice to make them &quot;read only&quot;<br></p><p>Here&#39;s a contrived example of what sometimes irritates me:<br></p><p>*struct Foo {*<br>* var point =  CGPoint( x:0, y:0 )*<br>* var prop: CGPoint {*<br>* return self.point*<br>* }*<br>*}*<br></p><p>*var foo = Foo()*<br></p><p>*foo.prop.x = 10 // illegal*<br></p><p><br>When I&#39;m writing something like this, it does make me wish I could tell the<br>compiler to send &quot;prop&quot; by reference. If I&#39;m just creating the getter as a<br>convenience to find the correct property (like .first) it&#39;s a bit of a drag<br>to fill out the setter side also.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160312/3fda8813/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Allowing mutable members in structs</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>March 12, 2016 at 09:00:00am</p></header><div class="content"><p>What I would find ideal is to keep everything else the same, but add:<br></p><p>struct Foo {<br>var point =  CGPoint( x:0, y:0 )<br>*inout* prop: CGPoint {<br>return *&amp;*self.point<br>}<br>}<br></p><p>var foo = Foo()<br></p><p>foo.prop.x = 10<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160312/f0ca4364/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
