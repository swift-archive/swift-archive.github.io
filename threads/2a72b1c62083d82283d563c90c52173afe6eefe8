<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January 29, 2016 at 08:00:00am</p></header><div class="content"><p>Hello,<br></p><p>I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br></p><p>For example:<br></p><p>	func f(@noescape(executed) closure: () -&gt; ()) {<br>	    closure()<br>	}<br></p><p>The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br></p><p>	let x: Int  // Not initialized<br>	f { x = 1 }<br>	print(x)    // Guaranteed to be initialized<br></p><p>Today developers have to write pessimistic code like below:<br></p><p>	var x: Int = 0 // `var` declaration, with some irrelevant value<br>	f { x = 1 }<br>	print(x)<br></p><p>As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br></p><p>	let items: [Item]<br>	let users: [User]<br>	dbQueue.inDatabase { db in<br>	    items = Item.all().fetchAll(db)<br>	    users = Item.all().fetchAll(db)<br>	}<br></p><p>Gwendal Roué<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/2a72efe8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;ve wanted something like this as well. I think it would be harder than it<br>seems, because &quot;x = 1&quot; might need to perform initialization, or assignment,<br>depending how it&#39;s used.<br></p><p>It could make sense to have something like<br>&quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not<br>worth it. And I&#39;m not sure how it should interact with throws.<br></p><p>Jacob<br></p><p>On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I’d like to discuss the opportunity to let functions declare that a<br>&gt; closure argument is guaranteed to have been executed when the function has<br>&gt; returned.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;     closure()<br>&gt; }<br>&gt;<br>&gt; The expected advantage is that the compiler would know that a variable set<br>&gt; inside the closure is guaranteed to be initialized, and that it can be used<br>&gt; after the execution of the function, as below:<br>&gt;<br>&gt; let x: Int  // Not initialized<br>&gt; f { x = 1 }<br>&gt; print(x)    // Guaranteed to be initialized<br>&gt;<br>&gt; Today developers have to write pessimistic code like below:<br>&gt;<br>&gt; var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt; f { x = 1 }<br>&gt; print(x)<br>&gt;<br>&gt; As for a real world usage, I’d like to access a database in a safe<br>&gt; (queued) way, and fetch values out of it:<br>&gt;<br>&gt; let items: [Item]<br>&gt; let users: [User]<br>&gt; dbQueue.inDatabase { db in<br>&gt;     items = Item.all().fetchAll(db)<br>&gt;     users = Item.all().fetchAll(db)<br>&gt; }<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/db3217f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>Glad we’re a few longing for this feature :-)<br></p><p>You are right Jacob, a modifier `@noescape(once)` would be better, as it would help compiler distinguish between assignment and initialization of captured variables.<br></p><p>The utility of such a new feature is maybe tiny, but clear: it extends the opportunities to declare variables before initializing them. The Swift 1 to 2 transition has already extended those opportunities, so we’re just following an existing trend, here.<br></p><p>As for throwing functions, here is a few proposals:<br></p><p># No errors<br></p><p>	func f(@noescape(once) once: () ()) {<br>		once()<br>	}<br>	let x: Int<br>	f { x = 1 }<br>	print(x) // OK<br>	<br>	<br># Function declared as throws<br></p><p>	func f(@noescape(once) once: () throws -&gt; ()) throws {<br>		try once()<br>	}<br>	let x: Int<br>	do {<br>		try f { x = try ... }<br>		print(x) // OK: function did not throw so x is initialized<br>	} catch {<br>		print(x) // BAD: y may not be initialized<br>	}<br></p><p><br># Function declared as rethrows<br></p><p>	func f(@noescape(once) once: () throws -&gt; ()) rethrows {<br>		try once()<br>	}<br>	<br>	let x: Int<br>	f { x = 1 }<br>	print(x) // OK: function did not throw so x is initialized<br></p><p>	let x: Int<br>	do {<br>		try f { x = try ... }<br>		print(x) // OK: function did not throw so x is initialized<br>	} catch {<br>		print(x) // BAD: y may not be initialized<br>	}<br></p><p>When a rethrowing function has several throwing closures, it does not change much. Generally, if the function throws, then the variable may not be initialized. If it does not throw, the variable is surely initialized.<br></p><p>Gwendal<br>	<br>&gt; Le 29 janv. 2016 à 09:23, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt; <br>&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello,<br>&gt; <br>&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt; 	    closure()<br>&gt; 	}<br>&gt; <br>&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt; <br>&gt; 	let x: Int  // Not initialized<br>&gt; 	f { x = 1 }<br>&gt; 	print(x)    // Guaranteed to be initialized<br>&gt; <br>&gt; Today developers have to write pessimistic code like below:<br>&gt; <br>&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt; 	f { x = 1 }<br>&gt; 	print(x)<br>&gt; <br>&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt; <br>&gt; 	let items: [Item]<br>&gt; 	let users: [User]<br>&gt; 	dbQueue.inDatabase { db in<br>&gt; 	    items = Item.all().fetchAll(db)<br>&gt; 	    users = Item.all().fetchAll(db)<br>&gt; 	}<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; You are right Jacob, a modifier `@noescape(once)` would be better, as it would help compiler distinguish between assignment and initialization of captured variables.<br>&gt; <br>&gt; The utility of such a new feature is maybe tiny, but clear: it extends the opportunities to declare variables before initializing them. The Swift 1 to 2 transition has already extended those opportunities, so we’re just following an existing trend, here.<br></p><p>I actually think that `once` is orthogonal to `noescape`. There are a *lot* of closures that are not noescape, but are called exactly once, such as dispatch_async and most completion handlers.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt; <br>&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br></p><p>I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br></p><p>The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br></p><p>This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello,<br>&gt; <br>&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt; 	    closure()<br>&gt; 	}<br>&gt; <br>&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt; <br>&gt; 	let x: Int  // Not initialized<br>&gt; 	f { x = 1 }<br>&gt; 	print(x)    // Guaranteed to be initialized<br>&gt; <br>&gt; Today developers have to write pessimistic code like below:<br>&gt; <br>&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt; 	f { x = 1 }<br>&gt; 	print(x)<br>&gt; <br>&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt; <br>&gt; 	let items: [Item]<br>&gt; 	let users: [User]<br>&gt; 	dbQueue.inDatabase { db in<br>&gt; 	    items = Item.all().fetchAll(db)<br>&gt; 	    users = Item.all().fetchAll(db)<br>&gt; 	}<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f30e6d89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I don&#39;t have much to add but I also think that it would be nice to have.<br></p><p>Félix<br></p><p>&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt; <br>&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt; <br>&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt; <br>&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt; <br>&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt; 	    closure()<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt; <br>&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt; 	f { x = 1 }<br>&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt; <br>&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt; <br>&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt; 	f { x = 1 }<br>&gt;&gt; 	print(x)<br>&gt;&gt; <br>&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt; <br>&gt;&gt; 	let items: [Item]<br>&gt;&gt; 	let users: [User]<br>&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f4972358/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January 30, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;m very supportive of this type of proposal.<br></p><p>I do agree with Brent though that @noescape and &#39;once&#39; is somewhat orthogonal.<br></p><p>There are a lot of places where you want to be clear that the block will be called but no more than once. For example, the NSURLSession callback blocks you would expect never to be called multiple times. Completion handlers are almost always used only once. I don&#39;t think this case, which is extremely common, can be overlooked.<br></p><p>On the other hand, I suspect the majority of places you use closures with @noescape, it seems more likely you&#39;d want it used multiple times, like a search, filter, find etc of multiple items in a collection or group, otherwise you&#39;d generally just put the closured activity before or after. The only areas where I would expect to see such closures of @noescape and &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom code in the middle of a complex operation of a method.<br></p><p>It seems to me that separating them, but allowing them to be used together, makes more sense.<br></p><p>Rod<br></p><p><br>&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;&gt; <br>&gt;&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt;&gt; <br>&gt;&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt;&gt; <br>&gt;&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;&gt;&gt; 	    closure()<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt; 	print(x)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let items: [Item]<br>&gt;&gt;&gt;&gt; 	let users: [User]<br>&gt;&gt;&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt;&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/fb34d110/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 30, 2016 at 02:00:00pm</p></header><div class="content"><p>I agree that many closures are expected to be executed only once, but it seems to me that it&#39;s only useful to the compiler if it&#39;s also marked @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t allow the compiler to determine that a variable will have been initialized after the call that takes the closure.<br></p><p>So in these other cases, it only serves as documentation. I&#39;m not very enthusiastic about attributes that only serve as documentation because there is an infinity of attributes that can be added to the language for documentation purposes.<br></p><p>There are other places than `dispatch_sync` where you may want a `@noescape(once)` attribute. Any function that executes a closure while providing some sort of guarantee/RAII-like handle can benefit from it. Most of the functions starting with `with` in the standard library could benefit from it: withExtendedLifetime, withUnsafePointer and friends, withVaList. String&#39;s `withCString` and `withMutableCharacters` could benefit from it too. Someone who writes a `withLock(lock) { closure }` function would be happy to have it too.<br></p><p>Félix<br></p><p>&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com&gt; a écrit :<br>&gt; <br>&gt; I&#39;m very supportive of this type of proposal.<br>&gt; <br>&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat orthogonal.<br>&gt; <br>&gt; There are a lot of places where you want to be clear that the block will be called but no more than once. For example, the NSURLSession callback blocks you would expect never to be called multiple times. Completion handlers are almost always used only once. I don&#39;t think this case, which is extremely common, can be overlooked.<br>&gt; <br>&gt; On the other hand, I suspect the majority of places you use closures with @noescape, it seems more likely you&#39;d want it used multiple times, like a search, filter, find etc of multiple items in a collection or group, otherwise you&#39;d generally just put the closured activity before or after. The only areas where I would expect to see such closures of @noescape and &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom code in the middle of a complex operation of a method.<br>&gt; <br>&gt; It seems to me that separating them, but allowing them to be used together, makes more sense.<br>&gt; <br>&gt; Rod<br>&gt; <br>&gt; <br>&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;&gt;&gt; 	    closure()<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt; 	print(x)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let items: [Item]<br>&gt;&gt;&gt;&gt; 	let users: [User]<br>&gt;&gt;&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt;&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/41fe8eea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that many closures are expected to be executed only once, but it seems to me that it&#39;s only useful to the compiler if it&#39;s also marked @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t allow the compiler to determine that a variable will have been initialized after the call that takes the closure.<br>&gt; <br>&gt; So in these other cases, it only serves as documentation. I&#39;m not very enthusiastic about attributes that only serve as documentation because there is an infinity of attributes that can be added to the language for documentation purposes.<br></p><p>It also serves as a guarantee that the closure is executed exactly once.  Even if the compiler can’t use it for optimization the guarantee could be useful.<br></p><p>&gt; <br>&gt; There are other places than `dispatch_sync` where you may want a `@noescape(once)` attribute. Any function that executes a closure while providing some sort of guarantee/RAII-like handle can benefit from it. Most of the functions starting with `with` in the standard library could benefit from it: withExtendedLifetime, withUnsafePointer and friends, withVaList. String&#39;s `withCString` and `withMutableCharacters` could benefit from it too. Someone who writes a `withLock(lock) { closure }` function would be happy to have it too.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;m very supportive of this type of proposal.<br>&gt;&gt; <br>&gt;&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat orthogonal.<br>&gt;&gt; <br>&gt;&gt; There are a lot of places where you want to be clear that the block will be called but no more than once. For example, the NSURLSession callback blocks you would expect never to be called multiple times. Completion handlers are almost always used only once. I don&#39;t think this case, which is extremely common, can be overlooked.<br>&gt;&gt; <br>&gt;&gt; On the other hand, I suspect the majority of places you use closures with @noescape, it seems more likely you&#39;d want it used multiple times, like a search, filter, find etc of multiple items in a collection or group, otherwise you&#39;d generally just put the closured activity before or after. The only areas where I would expect to see such closures of @noescape and &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom code in the middle of a complex operation of a method.<br>&gt;&gt; <br>&gt;&gt; It seems to me that separating them, but allowing them to be used together, makes more sense.<br>&gt;&gt; <br>&gt;&gt; Rod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt; 	    closure()<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt; 	print(x)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let items: [Item]<br>&gt;&gt;&gt;&gt;&gt; 	let users: [User]<br>&gt;&gt;&gt;&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt;&gt;&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/cab764b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 30, 2016 at 12:00:00pm</p></header><div class="content"><p>The &quot;noescape + exactly once&quot; guarantee is useful to the compiler because<br>it allows the closure to *initialize* variables that it captures. The way<br>to think about this is that the closure body is effectively inlined.<br></p><p>&quot;noescape, but not exactly once&quot; is still useful because you can omit<br>references to self, and know that variable modifications in the closure<br>will be visible after the function call. But you can&#39;t perform<br>initialization (because the closure might be called more than once), nor<br>can you be sure variables are initialized after the function call (because<br>the closure might not be called at all).<br></p><p>&quot;exactly once, but escaping&quot; is an important API contract that should be<br>documented, but if the closure can escape the call, then you still can&#39;t<br>perform initialization in the closure, because the order it happens in<br>w.r.t. the function call isn&#39;t guaranteed. I might be missing something,<br>but I don&#39;t see any reason for this feature to exist, because...well, it<br>isn&#39;t really a feature if it can&#39;t do anything.<br></p><p>Jacob<br></p><p>On Sat, Jan 30, 2016 at 12:07 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 30, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree that many closures are expected to be executed only once, but it<br>&gt; seems to me that it&#39;s only useful to the compiler if it&#39;s also marked<br>&gt; @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t<br>&gt; allow the compiler to determine that a variable will have been initialized<br>&gt; after the call that takes the closure.<br>&gt;<br>&gt; So in these other cases, it only serves as documentation. I&#39;m not very<br>&gt; enthusiastic about attributes that only serve as documentation because<br>&gt; there is an infinity of attributes that can be added to the language for<br>&gt; documentation purposes.<br>&gt;<br>&gt;<br>&gt; It also serves as a guarantee that the closure is executed exactly once.<br>&gt; Even if the compiler can’t use it for optimization the guarantee could be<br>&gt; useful.<br>&gt;<br>&gt;<br>&gt; There are other places than `dispatch_sync` where you may want a<br>&gt; `@noescape(once)` attribute. Any function that executes a closure while<br>&gt; providing some sort of guarantee/RAII-like handle can benefit from it. Most<br>&gt; of the functions starting with `with` in the standard library could benefit<br>&gt; from it: withExtendedLifetime, withUnsafePointer and friends, withVaList.<br>&gt; String&#39;s `withCString` and `withMutableCharacters` could benefit from it<br>&gt; too. Someone who writes a `withLock(lock) { closure }` function would be<br>&gt; happy to have it too.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com&gt; a écrit<br>&gt; :<br>&gt;<br>&gt; I&#39;m very supportive of this type of proposal.<br>&gt;<br>&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat<br>&gt; orthogonal.<br>&gt;<br>&gt; There are a lot of places where you want to be clear that the block will<br>&gt; be called but no more than once. For example, the NSURLSession callback<br>&gt; blocks you would expect never to be called multiple times. Completion<br>&gt; handlers are almost always used only once. I don&#39;t think this case, which<br>&gt; is extremely common, can be overlooked.<br>&gt;<br>&gt; On the other hand, I suspect the majority of places you use closures with<br>&gt; @noescape, it seems more likely you&#39;d *want *it used multiple times, like<br>&gt; a search, filter, find etc of multiple items in a collection or group,<br>&gt; otherwise you&#39;d generally just put the closured activity before or after.<br>&gt; The only areas where I would expect to see such closures of @noescape and<br>&gt; &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom<br>&gt; code in the middle of a complex operation of a method.<br>&gt;<br>&gt; It seems to me that separating them, but allowing them to be used<br>&gt; together, makes more sense.<br>&gt;<br>&gt; Rod<br>&gt;<br>&gt;<br>&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve wanted something like this as well. I think it would be harder than<br>&gt; it seems, because &quot;x = 1&quot; might need to perform initialization, or<br>&gt; assignment, depending how it&#39;s used.<br>&gt;<br>&gt; It could make sense to have something like<br>&gt; &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not<br>&gt; worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;<br>&gt;<br>&gt; I think that something like this is implementable, and making it a<br>&gt; modifier to @noescape is sensible.<br>&gt;<br>&gt; The semantics we could support is that the function is guaranteed to call<br>&gt; the closure exactly once on any path that could lead to a return or throw.<br>&gt;<br>&gt; This approach allows you to pass the closure down the stack, and composes<br>&gt; with error handling.  It is obviously limited what you can do with the<br>&gt; closure, but that is necessary to validate correctness.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; I’d like to discuss the opportunity to let functions declare that a<br>&gt;&gt; closure argument is guaranteed to have been executed when the function has<br>&gt;&gt; returned.<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;     closure()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The expected advantage is that the compiler would know that a variable<br>&gt;&gt; set inside the closure is guaranteed to be initialized, and that it can be<br>&gt;&gt; used after the execution of the function, as below:<br>&gt;&gt;<br>&gt;&gt; let x: Int  // Not initialized<br>&gt;&gt; f { x = 1 }<br>&gt;&gt; print(x)    // Guaranteed to be initialized<br>&gt;&gt;<br>&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;<br>&gt;&gt; var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt; f { x = 1 }<br>&gt;&gt; print(x)<br>&gt;&gt;<br>&gt;&gt; As for a real world usage, I’d like to access a database in a safe<br>&gt;&gt; (queued) way, and fetch values out of it:<br>&gt;&gt;<br>&gt;&gt; let items: [Item]<br>&gt;&gt; let users: [User]<br>&gt;&gt; dbQueue.inDatabase { db in<br>&gt;&gt;     items = Item.all().fetchAll(db)<br>&gt;&gt;     users = Item.all().fetchAll(db)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Gwendal Roué<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/fc9fec8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 12:19 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The &quot;noescape + exactly once&quot; guarantee is useful to the compiler because it allows the closure to *initialize* variables that it captures. The way to think about this is that the closure body is effectively inlined.<br>&gt; <br>&gt; &quot;noescape, but not exactly once&quot; is still useful because you can omit references to self, and know that variable modifications in the closure will be visible after the function call. But you can&#39;t perform initialization (because the closure might be called more than once), nor can you be sure variables are initialized after the function call (because the closure might not be called at all).<br>&gt; <br>&gt; &quot;exactly once, but escaping&quot; is an important API contract that should be documented, but if the closure can escape the call, then you still can&#39;t perform initialization in the closure, because the order it happens in w.r.t. the function call isn&#39;t guaranteed. I might be missing something, but I don&#39;t see any reason for this feature to exist, because...well, it isn&#39;t really a feature if it can&#39;t do anything.<br></p><p>+1, exactly right.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January 31, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, I agree. Very good points.<br></p><p>+1<br></p><p>&gt; On 31 Jan 2016, at 8:55 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 30, 2016, at 12:19 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The &quot;noescape + exactly once&quot; guarantee is useful to the compiler because it allows the closure to *initialize* variables that it captures. The way to think about this is that the closure body is effectively inlined.<br>&gt;&gt; <br>&gt;&gt; &quot;noescape, but not exactly once&quot; is still useful because you can omit references to self, and know that variable modifications in the closure will be visible after the function call. But you can&#39;t perform initialization (because the closure might be called more than once), nor can you be sure variables are initialized after the function call (because the closure might not be called at all).<br>&gt;&gt; <br>&gt;&gt; &quot;exactly once, but escaping&quot; is an important API contract that should be documented, but if the closure can escape the call, then you still can&#39;t perform initialization in the closure, because the order it happens in w.r.t. the function call isn&#39;t guaranteed. I might be missing something, but I don&#39;t see any reason for this feature to exist, because...well, it isn&#39;t really a feature if it can&#39;t do anything.<br>&gt; <br>&gt; +1, exactly right.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 31, 2016 at 01:00:00am</p></header><div class="content"><p>I&#39;d like to pitch this proposal to implement the feature: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br></p><p>Rationale for some points:<br></p><p>&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br></p><p><br>The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br></p><p>&gt; it is not required to be executed on a code path that throws;<br></p><p><br>It may need to be clarified into &quot;must&quot; or &quot;must not&quot;, but I can&#39;t think about very good examples supporting either case right now.<br></p><p>Félix<br></p><p>&gt; Le 30 janv. 2016 à 19:54:19, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Yes, I agree. Very good points.<br>&gt; <br>&gt; +1<br>&gt; <br>&gt;&gt; On 31 Jan 2016, at 8:55 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 30, 2016, at 12:19 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;noescape + exactly once&quot; guarantee is useful to the compiler because it allows the closure to *initialize* variables that it captures. The way to think about this is that the closure body is effectively inlined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;noescape, but not exactly once&quot; is still useful because you can omit references to self, and know that variable modifications in the closure will be visible after the function call. But you can&#39;t perform initialization (because the closure might be called more than once), nor can you be sure variables are initialized after the function call (because the closure might not be called at all).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;exactly once, but escaping&quot; is an important API contract that should be documented, but if the closure can escape the call, then you still can&#39;t perform initialization in the closure, because the order it happens in w.r.t. the function call isn&#39;t guaranteed. I might be missing something, but I don&#39;t see any reason for this feature to exist, because...well, it isn&#39;t really a feature if it can&#39;t do anything.<br>&gt;&gt; <br>&gt;&gt; +1, exactly right.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/821760fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January 31, 2016 at 08:00:00am</p></header><div class="content"><p>Thank you very much, Félix!<br></p><p>Gwendal<br></p><p>&gt; Le 31 janv. 2016 à 07:17, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;d like to pitch this proposal to implement the feature: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt; <br>&gt; Rationale for some points:<br>&gt; <br>&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt; <br>&gt; <br>&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br>&gt; <br>&gt;&gt; it is not required to be executed on a code path that throws;<br>&gt; <br>&gt; <br>&gt; It may need to be clarified into &quot;must&quot; or &quot;must not&quot;, but I can&#39;t think about very good examples supporting either case right now.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 janv. 2016 à 19:54:19, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Yes, I agree. Very good points.<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt;&gt; On 31 Jan 2016, at 8:55 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 30, 2016, at 12:19 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The &quot;noescape + exactly once&quot; guarantee is useful to the compiler because it allows the closure to *initialize* variables that it captures. The way to think about this is that the closure body is effectively inlined.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;noescape, but not exactly once&quot; is still useful because you can omit references to self, and know that variable modifications in the closure will be visible after the function call. But you can&#39;t perform initialization (because the closure might be called more than once), nor can you be sure variables are initialized after the function call (because the closure might not be called at all).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;exactly once, but escaping&quot; is an important API contract that should be documented, but if the closure can escape the call, then you still can&#39;t perform initialization in the closure, because the order it happens in w.r.t. the function call isn&#39;t guaranteed. I might be missing something, but I don&#39;t see any reason for this feature to exist, because...well, it isn&#39;t really a feature if it can&#39;t do anything.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1, exactly right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/0b4734d3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Le 31 janv. 2016 à 01:17, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;d like to pitch this proposal to implement the feature: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt; <br>&gt; Rationale for some points:<br>&gt; <br>&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt; <br>&gt; <br>&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br>&gt; <br>&gt;&gt; it is not required to be executed on a code path that throws;<br>&gt; <br>&gt; <br>&gt; It may need to be clarified into &quot;must&quot; or &quot;must not&quot;, but I can&#39;t think about very good examples supporting either case right now.<br>&gt; <br></p><p>What is the implication of this @noescape(once) closure not being call on throws when the caller use try? variation? Looks like the compiler will have to assume that the @escape(once) is both not called and not not called (sorry for the double-negative). For the try!, i think that the compiler could assume that the @escape(none) is called, as the process would crash otherwise anyway on the throw.<br></p><p>    var bad: Bool = true<br>    enum e: ErrorType {<br>        case Simple<br>    }<br>    func f(@noescape closure: () -&gt; ()) throws {<br>        if (bad) { throw e.Simple }<br>        closure()<br>    }<br>    let x: Int  // Not initialized<br>    try? f { x = 1 }<br>    print(x)    // May still be uninitialized, compiler must generate error<br>    x = 2       // May have been initialized, compiler must generate error<br></p><p>This should probably be highlighted in the proposal as an intended limitation for the typical usage.<br>Another special case with try? that people may be unlikely to use, is:<br></p><p>    func g(@noescape closure: () -&gt; ()) throws -&gt; Int {<br>        if (bad) { throw e.Simple }<br>        closure()<br>        return 1<br>    }<br>    if let data = try? g({ x = 1 }) {<br>        print(x) // Guaranteed to be initialized<br>    }<br>    print(x)    // May still be uninitialized, compiler must generate error<br>    x = 2       // May have been initialized, compiler must generate error<br></p><p>Not sure if this case will make the implementation more complex, it is why I’m mentioning it.<br></p><p>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/924e360d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 31, 2016 at 10:00:00pm</p></header><div class="content"><p>To simplify my explanations, let&#39;s have these functions:<br></p><p>&gt; func foo() {<br>&gt; 	let bar: Int<br>&gt; 	withNoEscape { bar = 1 }<br>&gt; }<br>&gt; <br>&gt; func withNoEscape(@autoclosure(once) closure: () -&gt; ()) { /* snip */ }<br></p><p><br>Looking back, I do think that there should be a way to exit from `withNoEscape` without calling the closure, so yes, throwing should imply that the closure wasn&#39;t executed. If it&#39;s possible that `foo` swallowed an error from a throwing `withNoEscape`, the compiler should assume that the variables within haven&#39;t been initialized:<br></p><p>&gt; func foo() {<br>&gt; 	let bar: Int<br>&gt; 	do {<br>&gt; 		try withNoEscape { bar = 1 }<br>&gt; 		// bar has been initialized<br>&gt; 	}<br>&gt; 	catch {<br>&gt; 		// bar has not been initialized<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; func foo() {<br>&gt; 	let bar: Int<br>&gt; 	try? withNoEscape { bar = 1 }<br>&gt; 	// bar has not been initialized<br>&gt; }<br>&gt; <br>&gt; func foo() {<br>&gt; 	let bar: Int<br>&gt; 	try! withNoEscape { bar = 1 }<br>&gt; 	// bar has been initialized<br>&gt; }<br></p><p>Closures that can throw are harder since normal functions are allowed to catch an error from a closure. For a @noescape(once) closure, it has been partially executed only and it would be non-trivial to determine what has been executed and what hasn&#39;t. As I see it, the best solution would be to force any code path in `withNoEscape` where it catches an exception from the closure to throw to indicate failure (even if the closure partially ran).<br></p><p>Another solution is to prevent `withNoEscape` from throwing, and prevent `@noescape(once)` closures from throwing. It&#39;s less classy, but the current places in the standard library where it would be nice to have it do not throw and I have a hunch that most cases won&#39;t need to throw either. Recovering from throwing closures does add a lot of complexity that I&#39;m not sure the feature will pay for in the long run.<br></p><p>Félix<br></p><p>&gt; Le 31 janv. 2016 à 12:54:27, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 31 janv. 2016 à 01:17, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to pitch this proposal to implement the feature: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt; <br>&gt;&gt; Rationale for some points:<br>&gt;&gt; <br>&gt;&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br>&gt;&gt; <br>&gt;&gt;&gt; it is not required to be executed on a code path that throws;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It may need to be clarified into &quot;must&quot; or &quot;must not&quot;, but I can&#39;t think about very good examples supporting either case right now.<br>&gt;&gt; <br>&gt; <br>&gt; What is the implication of this @noescape(once) closure not being call on throws when the caller use try? variation? Looks like the compiler will have to assume that the @escape(once) is both not called and not not called (sorry for the double-negative). For the try!, i think that the compiler could assume that the @escape(none) is called, as the process would crash otherwise anyway on the throw.<br>&gt; <br>&gt;     var bad: Bool = true<br>&gt;     enum e: ErrorType {<br>&gt;         case Simple<br>&gt;     }<br>&gt;     func f(@noescape closure: () -&gt; ()) throws {<br>&gt;         if (bad) { throw e.Simple }<br>&gt;         closure()<br>&gt;     }<br>&gt;     let x: Int  // Not initialized<br>&gt;     try? f { x = 1 }<br>&gt;     print(x)    // May still be uninitialized, compiler must generate error<br>&gt;     x = 2       // May have been initialized, compiler must generate error<br>&gt; <br>&gt; This should probably be highlighted in the proposal as an intended limitation for the typical usage.<br>&gt; Another special case with try? that people may be unlikely to use, is:<br>&gt; <br>&gt;     func g(@noescape closure: () -&gt; ()) throws -&gt; Int {<br>&gt;         if (bad) { throw e.Simple }<br>&gt;         closure()<br>&gt;         return 1<br>&gt;     }<br>&gt;     if let data = try? g({ x = 1 }) {<br>&gt;         print(x) // Guaranteed to be initialized<br>&gt;     }<br>&gt;     print(x)    // May still be uninitialized, compiler must generate error<br>&gt;     x = 2       // May have been initialized, compiler must generate error<br>&gt; <br>&gt; Not sure if this case will make the implementation more complex, it is why I’m mentioning it.<br>&gt; <br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/10d7db42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt; 	let bar: Int<br>&gt;&gt; 	withNoEscape { bar = 1 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func withNoEscape(@autoclosure(once) closure: () -&gt; ()) { /* snip */ }<br>&gt; <br>&gt; <br>&gt; Looking back, I do think that there should be a way to exit from `withNoEscape` without calling the closure, so yes, throwing should imply that the closure wasn&#39;t executed. If it&#39;s possible that `foo` swallowed an error from a throwing `withNoEscape`, the compiler should assume that the variables within haven&#39;t been initialized:<br></p><p>I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br></p><p>As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br></p><p>This would be handy in the case of the short-circuiting boolean operators, for example:<br></p><p>@warn_unused_result func &amp;&amp;&lt;T : BooleanType, U : BooleanType&gt;(_ lhs: T, @autoclosure(once?) _ rhs: () throws -&gt; U) rethrows -&gt; Bool<br></p><p>-Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/e404ccd4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>@Matthew: The @autoclosure was actually an accident; I meant @noescape. :) That said, yes, I think that we&#39;ll often want @noescape(once) on @autoclosure parameters.<br></p><p>As for &quot;once?&quot; seems to me that calling a non-escaping closure a second time on accident isn&#39;t a very frequent mistake, and when it happens it ought to be very easy to debug. It also doesn&#39;t add benefits outside of this verification, so it&#39;s unclear to me that the it pulls its own weight. Even as I was writing the @noescape(once) proposal, I was having doubts that it itself would pull its own weight.<br></p><p>@Brent: no matter how useful it is, we can&#39;t reasonably prove that an escaping closure is called exactly once without move semantics (and move-only closures). For now, if @once is distinct, it needs to be accompanied by @noescape.<br></p><p>@Gwendal: that&#39;s one solution. A third solution would be to enforce that @noescape(once) parameters are executed in parameter order.<br></p><p>Do you have any example of UIKit where a function accepts two closures that could reasonably be marked @noescape(once)?<br></p><p>Félix<br></p><p>&gt; Le 1 févr. 2016 à 09:31:53, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; func foo() {<br>&gt;&gt;&gt; 	let bar: Int<br>&gt;&gt;&gt; 	withNoEscape { bar = 1 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func withNoEscape(@autoclosure(once) closure: () -&gt; ()) { /* snip */ }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Looking back, I do think that there should be a way to exit from `withNoEscape` without calling the closure, so yes, throwing should imply that the closure wasn&#39;t executed. If it&#39;s possible that `foo` swallowed an error from a throwing `withNoEscape`, the compiler should assume that the variables within haven&#39;t been initialized:<br>&gt; <br>&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt; <br>&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br>&gt; <br>&gt; This would be handy in the case of the short-circuiting boolean operators, for example:<br>&gt; <br>&gt; @warn_unused_result func &amp;&amp;&lt;T : BooleanType, U : BooleanType&gt;(_ lhs: T, @autoclosure(once?) _ rhs: () throws -&gt; U) rethrows -&gt; Bool<br>&gt; <br>&gt; -Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/650674fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 1 févr. 2016 à 18:29, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; @Gwendal: that&#39;s one solution. A third solution would be to enforce that @noescape(once) parameters are executed in parameter order.<br>&gt; <br>&gt; Do you have any example of UIKit where a function accepts two closures that could reasonably be marked @noescape(once)?<br></p><p>No Félix, no example in UIKit itself. I was thinking of higher-order applications or library functions that wrap any stateful API. A very artificial example involving UIKit :<br></p><p>	func f(@noescape(once) closure1: () -&gt; (), @noescape(once) closure2: () -&gt; (), @noescape(once) closure3: () -&gt; ()) {<br>		closure1()<br>		tableView.beginUpdates()<br>		closure2()<br>		tableView.endUpdates()<br>		closure3()<br>	}<br></p><p>So unless it would be too complex to implement, I would support letting the compiler accept several once closures, without requiring any execution order, and without double-guessing the needs of the developer.<br></p><p>Gwendal<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/628cb636/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>On Feb 1, 2016, at 6:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; func foo() {<br>&gt;&gt;&gt; 	let bar: Int<br>&gt;&gt;&gt; 	withNoEscape { bar = 1 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func withNoEscape(@autoclosure(once) closure: () -&gt; ()) { /* snip */ }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Looking back, I do think that there should be a way to exit from `withNoEscape` without calling the closure, so yes, throwing should imply that the closure wasn&#39;t executed. If it&#39;s possible that `foo` swallowed an error from a throwing `withNoEscape`, the compiler should assume that the variables within haven&#39;t been initialized:<br>&gt; <br>&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt; <br>&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br></p><p>I don’t see how this is useful.  You wouldn’t be able to initialize a value with this semantic, so it isn’t any more powerful than @noescape on the caller side.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/00611b98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 2:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 1, 2016, at 6:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; func foo() {<br>&gt;&gt;&gt;&gt; 	let bar: Int<br>&gt;&gt;&gt;&gt; 	withNoEscape { bar = 1 }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func withNoEscape(@autoclosure(once) closure: () -&gt; ()) { /* snip */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking back, I do think that there should be a way to exit from `withNoEscape` without calling the closure, so yes, throwing should imply that the closure wasn&#39;t executed. If it&#39;s possible that `foo` swallowed an error from a throwing `withNoEscape`, the compiler should assume that the variables within haven&#39;t been initialized:<br>&gt;&gt; <br>&gt;&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt;&gt; <br>&gt;&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br>&gt; <br>&gt; I don’t see how this is useful.  You wouldn’t be able to initialize a value with this semantic, so it isn’t any more powerful than @noescape on the caller side.<br></p><p>Right, you would not be able to use it for initialization.<br></p><p>It gives a guarantee that the closure will not be executed twice.  This semantic guarantee could be useful, especially if the closure has side-effects.  It adds the clarity of a guarantee  to APIs where the zero-or-one-times semantic is implicit with @noescape alone.<br></p><p>-Matthew <br> <br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/f0340133/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>On Feb 1, 2016, at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br>&gt;&gt; <br>&gt;&gt; I don’t see how this is useful.  You wouldn’t be able to initialize a value with this semantic, so it isn’t any more powerful than @noescape on the caller side.<br>&gt; <br>&gt; Right, you would not be able to use it for initialization.<br>&gt; <br>&gt; It gives a guarantee that the closure will not be executed twice.  This semantic guarantee could be useful, especially if the closure has side-effects.  It adds the clarity of a guarantee  to APIs where the zero-or-one-times semantic is implicit with @noescape alone.<br></p><p>Right, but unless the compiler is going to enforce it somehow, it doesn’t add any value above a comment.  Particularly given that we want to keep the language simple where possible, I think that a comment would be perfectly fine for this.  We don’t want to be in the business of providing a &quot;documentation hook” in the language for every theoretical invariant someone might want to express.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/f0933bfb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 3:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 1, 2016, at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see how this is useful.  You wouldn’t be able to initialize a value with this semantic, so it isn’t any more powerful than @noescape on the caller side.<br>&gt;&gt; <br>&gt;&gt; Right, you would not be able to use it for initialization.<br>&gt;&gt; <br>&gt;&gt; It gives a guarantee that the closure will not be executed twice.  This semantic guarantee could be useful, especially if the closure has side-effects.  It adds the clarity of a guarantee  to APIs where the zero-or-one-times semantic is implicit with @noescape alone.<br>&gt; <br>&gt; Right, but unless the compiler is going to enforce it somehow, it doesn’t add any value above a comment.  Particularly given that we want to keep the language simple where possible, I think that a comment would be perfectly fine for this.  We don’t want to be in the business of providing a &quot;documentation hook” in the language for every theoretical invariant someone might want to express.<br></p><p>I agree if the compiler isn’t going to enforce it.  The value is in the guarantee.  <br></p><p>Why wouldn’t the compiler enforce it in this case?  Is it hard to implement?  It doesn’t seem like it should be any harder than guaranteeing exactly once.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/2dc1cc61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 1:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 3:25 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t see how this is useful.  You wouldn’t be able to initialize a value with this semantic, so it isn’t any more powerful than @noescape on the caller side.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, you would not be able to use it for initialization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It gives a guarantee that the closure will not be executed twice.  This semantic guarantee could be useful, especially if the closure has side-effects.  It adds the clarity of a guarantee  to APIs where the zero-or-one-times semantic is implicit with @noescape alone.<br>&gt;&gt; <br>&gt;&gt; Right, but unless the compiler is going to enforce it somehow, it doesn’t add any value above a comment.  Particularly given that we want to keep the language simple where possible, I think that a comment would be perfectly fine for this.  We don’t want to be in the business of providing a &quot;documentation hook” in the language for every theoretical invariant someone might want to express.<br>&gt; <br>&gt; I agree if the compiler isn’t going to enforce it.  The value is in the guarantee.  <br>&gt; <br>&gt; Why wouldn’t the compiler enforce it in this case?  Is it hard to implement?  It doesn’t seem like it should be any harder than guaranteeing exactly once.<br></p><p>You’re right, the caller could enforce this, so it does provide marginal value beyond a comment.  I think the rest of my point stands though.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/684ba4dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 3:59 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:43 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 3:25 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 1:02 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m glad to see an @autoclosure func in this thread.  We will want to be able to use this feature with @autoclosure in addition to @noescape.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As far as exiting without calling the closure, I suggest `@noescape(once?)`.  The `?` indicates the closure may or may not be called, but will not be called more than once.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t see how this is useful.  You wouldn’t be able to initialize a value with this semantic, so it isn’t any more powerful than @noescape on the caller side.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right, you would not be able to use it for initialization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It gives a guarantee that the closure will not be executed twice.  This semantic guarantee could be useful, especially if the closure has side-effects.  It adds the clarity of a guarantee  to APIs where the zero-or-one-times semantic is implicit with @noescape alone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but unless the compiler is going to enforce it somehow, it doesn’t add any value above a comment.  Particularly given that we want to keep the language simple where possible, I think that a comment would be perfectly fine for this.  We don’t want to be in the business of providing a &quot;documentation hook” in the language for every theoretical invariant someone might want to express.<br>&gt;&gt; <br>&gt;&gt; I agree if the compiler isn’t going to enforce it.  The value is in the guarantee.  <br>&gt;&gt; <br>&gt;&gt; Why wouldn’t the compiler enforce it in this case?  Is it hard to implement?  It doesn’t seem like it should be any harder than guaranteeing exactly once.<br>&gt; <br>&gt; You’re right, the caller could enforce this, so it does provide marginal value beyond a comment.  I think the rest of my point stands though.<br></p><p>Sure, I think it’s a somewhat subjective judgement call.  <br></p><p>I prefer to get as many guarantees as possible from the compiler.  In cases where the semantics are likely to be documented in a comment, assumed or implicit I would prefer to see them expressed directly in the language.<br></p><p>I understand the case that it is simpler to leave it in a comment, I just have a different preference.  <br></p><p>There have been other topics where a similar tradeoff / judgement call is relevant, such as the `local` access control proposal.  <br></p><p>My sense so far is that Swift tries to strike a middle path, introducing annotations where the perceived benefit passes a test of being significant enough (such as the @noescape annotation and likely the once modifier).  It seems like in *most* cases a mere semantic guarantee by the compiler isn’t considered to be benefit enough to pass that test - optimization potential and / or a new capability (such as the ability to initialize values).  <br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/f5558990/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br></p><p>Things that changed:<br></p><p>It now says that the closure must be called on code paths where the function throws;<br>you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br></p><p>I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br></p><p>do {<br>	let foo: Int<br>	try withLock(someLock, timeout: 0.5) {<br>		foo = sharedThing.foo<br>	}<br>} catch {<br>	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>}<br></p><p>which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/c4f3bfce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 1:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt; <br>&gt; Things that changed:<br>&gt; <br>&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt; <br>&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet.<br></p><p>To be clear, (once) needs to specify either that the closure is guaranteed to be executed on the error path, or that it is guaranteed not to be.  I can see the argument that “guaranteed not” is the best default.  If you think that is the best way to go, feel free to make that be the proposal.  Either way, please mention in “alternatives” that it needs to be one or the other, but could be switched (from whatever you propose) if there is a compelling reason.<br></p><p>-Chris<br></p><p>&gt; If throwing allows me to return without calling the closure, I can write this:<br>&gt; <br>&gt; do {<br>&gt; 	let foo: Int<br>&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt; 		foo = sharedThing.foo<br>&gt; 	}<br>&gt; } catch {<br>&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt; }<br>&gt; <br>&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt; <br>&gt; Félix<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/cc573f6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks. I have updated the proposal to reflect this.<br></p><p>One thing that remains unspecified is the behavior when the closure throws. Feedback and opinions would be very welcome here.<br></p><p>Some alternatives that I can think of:<br></p><p>disallow throwing from @noescape(once) closures;<br>allow throwing and allow the error to be re-thrown (and force `once` closures to be executed on throwing paths);<br>return the closure error (possibly incompatible with some function return types).<br></p><p>Félix<br></p><p>&gt; Le 3 févr. 2016 à 17:18:51, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 3, 2016, at 1:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt; <br>&gt;&gt; Things that changed:<br>&gt;&gt; <br>&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. <br>&gt; <br>&gt; To be clear, (once) needs to specify either that the closure is guaranteed to be executed on the error path, or that it is guaranteed not to be.  I can see the argument that “guaranteed not” is the best default.  If you think that is the best way to go, feel free to make that be the proposal.  Either way, please mention in “alternatives” that it needs to be one or the other, but could be switched (from whatever you propose) if there is a compelling reason.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; 	let foo: Int<br>&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt; 	}<br>&gt;&gt; } catch {<br>&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt; <br>&gt;&gt; Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/7fb92d41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 3:00 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Thanks. I have updated the proposal to reflect this.<br>&gt; <br>&gt; One thing that remains unspecified is the behavior when the closure throws. Feedback and opinions would be very welcome here.<br>&gt; <br>&gt; Some alternatives that I can think of:<br>&gt; <br>&gt; disallow throwing from @noescape(once) closures;<br></p><p>I’d strongly prefer this.  Once/if the base proposal is accepted and implemented, we can always expand from there if strong motivation exists for doing so.<br></p><p>-Chris<br></p><p>&gt; allow throwing and allow the error to be re-thrown (and force `once` closures to be executed on throwing paths);<br>&gt; return the closure error (possibly incompatible with some function return types).<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 3 févr. 2016 à 17:18:51, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 1:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. <br>&gt;&gt; <br>&gt;&gt; To be clear, (once) needs to specify either that the closure is guaranteed to be executed on the error path, or that it is guaranteed not to be.  I can see the argument that “guaranteed not” is the best default.  If you think that is the best way to go, feel free to make that be the proposal.  Either way, please mention in “alternatives” that it needs to be one or the other, but could be switched (from whatever you propose) if there is a compelling reason.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/ceb0cd3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 3 févr. 2016 à 19:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 3:00 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks. I have updated the proposal to reflect this.<br>&gt;&gt; <br>&gt;&gt; One thing that remains unspecified is the behavior when the closure throws. Feedback and opinions would be very welcome here.<br>&gt;&gt; <br>&gt;&gt; Some alternatives that I can think of:<br>&gt;&gt; <br>&gt;&gt; disallow throwing from @noescape(once) closures;<br>&gt; <br>&gt; I’d strongly prefer this.  Once/if the base proposal is accepted and implemented, we can always expand from there if strong motivation exists for doing so.<br>&gt; <br>&gt; -Chris<br></p><p>Previously I had thought of the try? and try! but even with plain try the compiler might not know if a variable is initialized or not if the @noescape(once) must not run on throws<br></p><p>let foo: Int<br>do {<br>    try withLock(someLock, timeout: 0.5) {<br>        foo = sharedThing.foo<br>    }<br>    // immutable foo can be read not written to<br>} catch {<br>    print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>}<br>// is immutable foo initialized or not, must prevent both reads and writes<br></p><p>So will the compiler be able to properly handle this ambiguity?<br></p><p>Dany<br></p><p>&gt; <br>&gt;&gt; allow throwing and allow the error to be re-thrown (and force `once` closures to be executed on throwing paths);<br>&gt;&gt; return the closure error (possibly incompatible with some function return types).<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 3 févr. 2016 à 17:18:51, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 1:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To be clear, (once) needs to specify either that the closure is guaranteed to be executed on the error path, or that it is guaranteed not to be.  I can see the argument that “guaranteed not” is the best default.  If you think that is the best way to go, feel free to make that be the proposal.  Either way, please mention in “alternatives” that it needs to be one or the other, but could be switched (from whatever you propose) if there is a compelling reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/69b75555/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 4:45 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 3 févr. 2016 à 19:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 3:00 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks. I have updated the proposal to reflect this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing that remains unspecified is the behavior when the closure throws. Feedback and opinions would be very welcome here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some alternatives that I can think of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; disallow throwing from @noescape(once) closures;<br>&gt;&gt; <br>&gt;&gt; I’d strongly prefer this.  Once/if the base proposal is accepted and implemented, we can always expand from there if strong motivation exists for doing so.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; Previously I had thought of the try? and try! but even with plain try the compiler might not know if a variable is initialized or not if the @noescape(once) must not run on throws<br>&gt; <br>&gt; let foo: Int<br>&gt; do {<br>&gt;     try withLock(someLock, timeout: 0.5) {<br>&gt;         foo = sharedThing.foo<br>&gt;     }<br>&gt;     // immutable foo can be read not written to<br>&gt; } catch {<br>&gt;     print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt; }<br>&gt; // is immutable foo initialized or not, must prevent both reads and writes<br>&gt; <br>&gt; So will the compiler be able to properly handle this ambiguity?<br></p><p>I believe so, but I can’t say with 100% certainty without diving into some more details.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/7c55e934/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  4, 2016 at 01:00:00am</p></header><div class="content"><p>It seems to me that it isn&#39;t very different from:<br></p><p>&gt; let foo: Int<br>&gt; if someCondition {<br>&gt; 	foo = 4<br>&gt; }<br>&gt; // is immutable foo initialized or not, must prevent both reads and writes<br></p><p>which is currently handled properly.<br></p><p>Félix<br></p><p>&gt; Le 3 févr. 2016 à 19:45:11, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 3 févr. 2016 à 19:22, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 3:00 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks. I have updated the proposal to reflect this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing that remains unspecified is the behavior when the closure throws. Feedback and opinions would be very welcome here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some alternatives that I can think of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; disallow throwing from @noescape(once) closures;<br>&gt;&gt; <br>&gt;&gt; I’d strongly prefer this.  Once/if the base proposal is accepted and implemented, we can always expand from there if strong motivation exists for doing so.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; Previously I had thought of the try? and try! but even with plain try the compiler might not know if a variable is initialized or not if the @noescape(once) must not run on throws<br>&gt; <br>&gt; let foo: Int<br>&gt; do {<br>&gt;     try withLock(someLock, timeout: 0.5) {<br>&gt;         foo = sharedThing.foo<br>&gt;     }<br>&gt;     // immutable foo can be read not written to<br>&gt; } catch {<br>&gt;     print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt; }<br>&gt; // is immutable foo initialized or not, must prevent both reads and writes<br>&gt; <br>&gt; So will the compiler be able to properly handle this ambiguity?<br>&gt; <br>&gt; Dany<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; allow throwing and allow the error to be re-thrown (and force `once` closures to be executed on throwing paths);<br>&gt;&gt;&gt; return the closure error (possibly incompatible with some function return types).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 févr. 2016 à 17:18:51, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 3, 2016, at 1:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt;&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To be clear, (once) needs to specify either that the closure is guaranteed to be executed on the error path, or that it is guaranteed not to be.  I can see the argument that “guaranteed not” is the best default.  If you think that is the best way to go, feel free to make that be the proposal.  Either way, please mention in “alternatives” that it needs to be one or the other, but could be switched (from whatever you propose) if there is a compelling reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/a3d3123d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>I was wondering if this topic had evolved in anyway since its original introduction.<br></p><p>@noescape(once) would still be a useful addition to the language!<br></p><p>Gwendal Roué<br></p><p><br></p><p>&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt; <br>&gt; Things that changed:<br>&gt; <br>&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt; <br>&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt; <br>&gt; do {<br>&gt; 	let foo: Int<br>&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt; 		foo = sharedThing.foo<br>&gt; 	}<br>&gt; } catch {<br>&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt; }<br>&gt; <br>&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/d61a248b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 10, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi, not beyond this thread that I have seen. I think it&#39;s worth you<br>summarizing this thread in a formal proposal and putting it up for<br>discussion or submitting it as a PR :)<br></p><p>On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello all,<br>&gt;<br>&gt; I was wondering if this topic had evolved in anyway since its original<br>&gt; introduction.<br>&gt;<br>&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;<br>&gt; I updated the proposal to address some concerns. It can be found at:<br>&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;<br>&gt; Things that changed:<br>&gt;<br>&gt;<br>&gt;    - It now says that the closure must be called on code paths where the<br>&gt;    function throws;<br>&gt;    - you can have multiple @noescape(once) parameters but they can&#39;t make<br>&gt;    assumptions from one another.<br>&gt;<br>&gt;<br>&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is<br>&gt; always desirable. I&#39;ve changed it because Chris&#39;s support probably means<br>&gt; that the feature has better chances of making it, but I&#39;m not convinced<br>&gt; yet. If throwing allows me to return without calling the closure, I can<br>&gt; write this:<br>&gt;<br>&gt; do {<br>&gt; let foo: Int<br>&gt; try withLock(someLock, timeout: 0.5) {<br>&gt; foo = sharedThing.foo<br>&gt; }<br>&gt; } catch {<br>&gt; print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt; }<br>&gt;<br>&gt; which would be kind of messy if instead, the closure needed a parameter to<br>&gt; tell whether the lock was acquired or not when it runs.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/346c2e58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 10, 2016 at 03:00:00pm</p></header><div class="content"><p>Felix Cloutier already wrote one: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br></p><p>Do you think it needs to be rewritten?<br></p><p>Gwendal Roué<br></p><p>&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you summarizing this thread in a formal proposal and putting it up for discussion or submitting it as a PR :)<br>&gt; <br>&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello all,<br>&gt; <br>&gt; I was wondering if this topic had evolved in anyway since its original introduction.<br>&gt; <br>&gt; @noescape(once) would still be a useful addition to the language!<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt; <br>&gt;&gt; Things that changed:<br>&gt;&gt; <br>&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; 	let foo: Int<br>&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt; 	}<br>&gt;&gt; } catch {<br>&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/d8c955ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 11, 2016 at 07:00:00am</p></header><div class="content"><p>Sorry I missed that scrolling back through the history, that proposal looks<br>great. It doesn&#39;t look like it has been submitted as a pull request to<br>swift-evolution yet though.<br></p><p>On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br></p><p>&gt; Felix Cloutier already wrote one:<br>&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;<br>&gt; Do you think it needs to be rewritten?<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cacoyi at gmail.com&#39;);&gt;&gt; a écrit :<br>&gt;<br>&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you<br>&gt; summarizing this thread in a formal proposal and putting it up for<br>&gt; discussion or submitting it as a PR :)<br>&gt;<br>&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; I was wondering if this topic had evolved in anyway since its original<br>&gt;&gt; introduction.<br>&gt;&gt;<br>&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;<br>&gt;&gt; Gwendal Roué<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; I updated the proposal to address some concerns. It can be found at:<br>&gt;&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;<br>&gt;&gt; Things that changed:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - It now says that the closure must be called on code paths where the<br>&gt;&gt;    function throws;<br>&gt;&gt;    - you can have multiple @noescape(once) parameters but they can&#39;t<br>&gt;&gt;    make assumptions from one another.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is<br>&gt;&gt; always desirable. I&#39;ve changed it because Chris&#39;s support probably means<br>&gt;&gt; that the feature has better chances of making it, but I&#39;m not convinced<br>&gt;&gt; yet. If throwing allows me to return without calling the closure, I can<br>&gt;&gt; write this:<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt; let foo: Int<br>&gt;&gt; try withLock(someLock, timeout: 0.5) {<br>&gt;&gt; foo = sharedThing.foo<br>&gt;&gt; }<br>&gt;&gt; } catch {<br>&gt;&gt; print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; which would be kind of messy if instead, the closure needed a parameter<br>&gt;&gt; to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/85134d50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 23, 2016 at 12:00:00pm</p></header><div class="content"><p>Hello Andrew,<br></p><p>I&#39;m rather embarrassed: the initial design of this proposal was based on a modifier of @noescape:<br></p><p>	func f(@noescape(once) closure: () -&gt; ()) { … }<br></p><p>But since the 0049 proposal has been accepted (https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md), @noescape is no longer an argument qualifier, but a type attribute.<br></p><p>The `once` discussed here can not be part of the type: if noescape can understandably be part of the type, the fact that a function guarantees it will call a closure once is a quality of that function, not of the closure.<br></p><p>So the proposed @noescape(once) syntax is now confusing as it would mix a type attribute and a argument qualifier.<br></p><p>I don&#39;t quite know how to escape this:<br></p><p>	// two @ signs<br>	func f(@noescape @once closure: () -&gt; ()) { … }<br></p><p>	// Implies @noescape<br>	func f(@once closure: () -&gt; ()) { … }<br></p><p>I&#39;d like advice from competent people before I would attempt a rewrite of the proposal.<br></p><p>Gwendal Roué<br></p><p>&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Sorry I missed that scrolling back through the history, that proposal looks great. It doesn&#39;t look like it has been submitted as a pull request to swift-evolution yet though.<br>&gt; <br>&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; wrote:<br>&gt; Felix Cloutier already wrote one: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt; <br>&gt; Do you think it needs to be rewritten?<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cacoyi at gmail.com&#39;);&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you summarizing this thread in a formal proposal and putting it up for discussion or submitting it as a PR :)<br>&gt;&gt; <br>&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I was wondering if this topic had evolved in anyway since its original introduction.<br>&gt;&gt; <br>&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/0d9f03c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Gwendal,<br></p><p>&gt; Am 23.04.2016 um 12:18 schrieb Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hello Andrew,<br>&gt; <br>&gt; I&#39;m rather embarrassed: the initial design of this proposal was based on a modifier of @noescape:<br>&gt; <br>&gt; 	func f(@noescape(once) closure: () -&gt; ()) { … }<br>&gt; <br>&gt; But since the 0049 proposal has been accepted (https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md), @noescape is no longer an argument qualifier, but a type attribute.<br></p><p>maybe I cannot give competent advice from the language designers perspective, but I can speak as a language user.<br></p><p>I think it is more intuitive to have the name of the argument first: &quot;ARGUMENT-NAME: NOESCAPE AUTOCLOSURE TYPE FOOBAR-QUALIFIER..., NEXT-ARGUMENT-NAME...&quot; and not &quot;SOME-MODIFIERS-FIRST ARGUMENT-NAME: SOME-MODIFIERS-LAST&quot;. I think the old behavior reminded me too much of C, where the argument name is at some arbitrary place, surrounded by type names, parens, and whatnot; &quot;void foo(int __cdecl (*bar)(int foobar, void *context))&quot; where &quot;bar&quot; is the argument name, the first &quot;int&quot; is the return type of the &quot;bar&quot; function, &quot;int&quot; and &quot;void*&quot; are the two argument types, and &quot;__cdecl&quot; is the calling convention of the &quot;bar&quot; function.<br></p><p>And about @noescape(once)... Would it not work anymore? I know it&#39;s not part of the current SE-0049 proposal, but I can&#39;t see why it couldn&#39;t be expanded to include `once`. Or maybe it&#39;s just because I can&#39;t think of a realistic use case for using &quot;@noescape(once)&quot;.<br></p><p>&gt; The `once` discussed here can not be part of the type: if noescape can understandably be part of the type, the fact that a function guarantees it will call a closure once is a quality of that function, not of the closure.<br></p><p>Yes it is a quality of the function and not of the type. But why not just leave it at that place and just call it &quot;argument qualifier&quot;? Or maybe the general layout changed? In Swift 2 it was &quot;ARGUMENT_QUALIFIERS ARGUMENT_NAME: TYPE_ATTRIBUTES TYPE&quot;, and in Swift 3 it is &quot;ARGUMENT_NAME: ARGUMENT_QUALIFIERS TYPE_ATTRIBUTES TYPE&quot;?<br></p><p>&gt; So the proposed @noescape(once) syntax is now confusing as it would mix a type attribute and a argument qualifier.<br>&gt; <br>&gt; I don&#39;t quite know how to escape this:<br>&gt; <br>&gt; 	// two @ signs<br>&gt; 	func f(@noescape @once closure: () -&gt; ()) { … }<br>&gt; <br>&gt; 	// Implies @noescape<br>&gt; 	func f(@once closure: () -&gt; ()) { … }<br></p><p>How about<br></p><p>    func f(closure: @noescape(once) () -&gt; ()) { ... }<br></p><p>-Michael<br></p><p>&gt; <br>&gt; I&#39;d like advice from competent people before I would attempt a rewrite of the proposal.<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Sorry I missed that scrolling back through the history, that proposal looks great. It doesn&#39;t look like it has been submitted as a pull request to swift-evolution yet though.<br>&gt;&gt; <br>&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;&gt; Felix Cloutier already wrote one: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt; <br>&gt;&gt; Do you think it needs to be rewritten?<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you summarizing this thread in a formal proposal and putting it up for discussion or submitting it as a PR :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was wondering if this topic had evolved in anyway since its original introduction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	• It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt;&gt; 	• you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for your input Michael,<br></p><p>You&#39;re right that argument modifiers should go before the argument, and type qualifiers before the type:<br></p><p>	func f(@once closure: @noescape () -&gt; ())<br></p><p>Since @once actually implies @noescape (as described earlier in the thread), it can be shortened to:<br></p><p>	func f(@once closure: () -&gt; ())	// implicit @noescape<br></p><p>&gt; Or maybe it&#39;s just because I can&#39;t think of a realistic use case for using &quot;@noescape(once)&quot;.<br></p><p>The use case is the following: @once closures let the compiler know that the closure code is executed. It allows declaration of undefined `let` variables that are initialized in the @once closure:<br></p><p>	let x: Int<br>	f { x = 1 }<br>	// use x<br></p><p>Without @once, the developer has to work around:<br></p><p>	var x: Int = 0 // two problems: `var` declaration, and dummy value<br>	f { x = 1 }<br>	// use x<br></p><p>If this proposal would be accepted, the next step would be to ask for dispatch_sync functions et al. to use this qualifier (as well as other standard functions like autoreleasepool, withUnsafeBufferPointer, etc.):<br></p><p>	let x: Int<br>	dispatch_sync(queue) {<br>		x = 1<br>	}<br></p><p>And now high-level objects that use internal queues are easier to use:<br></p><p>	let items: [Item]<br>	let users: [User]<br>	dbQueue.inDatabase { db in<br>		items = Item.fetchAll(db)<br>		users = User.fetchAll(db)<br>	}<br></p><p>This pattern would greatly improve many libraries, and my own http://github.com/groue/GRDB.swift in particular.<br></p><p>Gwendal Roué<br></p><p><br>&gt; Le 23 avr. 2016 à 14:16, Michael Peternell &lt;michael.peternell at gmx.at&gt; a écrit :<br>&gt; <br>&gt; Hi Gwendal,<br>&gt; <br>&gt;&gt; Am 23.04.2016 um 12:18 schrieb Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Hello Andrew,<br>&gt;&gt; <br>&gt;&gt; I&#39;m rather embarrassed: the initial design of this proposal was based on a modifier of @noescape:<br>&gt;&gt; <br>&gt;&gt; 	func f(@noescape(once) closure: () -&gt; ()) { … }<br>&gt;&gt; <br>&gt;&gt; But since the 0049 proposal has been accepted (https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md), @noescape is no longer an argument qualifier, but a type attribute.<br>&gt; <br>&gt; maybe I cannot give competent advice from the language designers perspective, but I can speak as a language user.<br>&gt; <br>&gt; I think it is more intuitive to have the name of the argument first: &quot;ARGUMENT-NAME: NOESCAPE AUTOCLOSURE TYPE FOOBAR-QUALIFIER..., NEXT-ARGUMENT-NAME...&quot; and not &quot;SOME-MODIFIERS-FIRST ARGUMENT-NAME: SOME-MODIFIERS-LAST&quot;. I think the old behavior reminded me too much of C, where the argument name is at some arbitrary place, surrounded by type names, parens, and whatnot; &quot;void foo(int __cdecl (*bar)(int foobar, void *context))&quot; where &quot;bar&quot; is the argument name, the first &quot;int&quot; is the return type of the &quot;bar&quot; function, &quot;int&quot; and &quot;void*&quot; are the two argument types, and &quot;__cdecl&quot; is the calling convention of the &quot;bar&quot; function.<br>&gt; <br>&gt; And about @noescape(once)... Would it not work anymore? I know it&#39;s not part of the current SE-0049 proposal, but I can&#39;t see why it couldn&#39;t be expanded to include `once`. Or maybe it&#39;s just because I can&#39;t think of a realistic use case for using &quot;@noescape(once)&quot;.<br>&gt; <br>&gt;&gt; The `once` discussed here can not be part of the type: if noescape can understandably be part of the type, the fact that a function guarantees it will call a closure once is a quality of that function, not of the closure.<br>&gt; <br>&gt; Yes it is a quality of the function and not of the type. But why not just leave it at that place and just call it &quot;argument qualifier&quot;? Or maybe the general layout changed? In Swift 2 it was &quot;ARGUMENT_QUALIFIERS ARGUMENT_NAME: TYPE_ATTRIBUTES TYPE&quot;, and in Swift 3 it is &quot;ARGUMENT_NAME: ARGUMENT_QUALIFIERS TYPE_ATTRIBUTES TYPE&quot;?<br>&gt; <br>&gt;&gt; So the proposed @noescape(once) syntax is now confusing as it would mix a type attribute and a argument qualifier.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t quite know how to escape this:<br>&gt;&gt; <br>&gt;&gt; 	// two @ signs<br>&gt;&gt; 	func f(@noescape @once closure: () -&gt; ()) { … }<br>&gt;&gt; <br>&gt;&gt; 	// Implies @noescape<br>&gt;&gt; 	func f(@once closure: () -&gt; ()) { … }<br>&gt; <br>&gt; How about<br>&gt; <br>&gt;    func f(closure: @noescape(once) () -&gt; ()) { ... }<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;d like advice from competent people before I would attempt a rewrite of the proposal.<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt;&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry I missed that scrolling back through the history, that proposal looks great. It doesn&#39;t look like it has been submitted as a pull request to swift-evolution yet though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Felix Cloutier already wrote one: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you think it needs to be rewritten?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you summarizing this thread in a formal proposal and putting it up for discussion or submitting it as a PR :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was wondering if this topic had evolved in anyway since its original introduction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt;&gt;&gt; 	• you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>&gt; Am 23.04.2016 um 14:56 schrieb Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Thanks for your input Michael,<br>&gt; <br>&gt; You&#39;re right that argument modifiers should go before the argument, and type qualifiers before the type:<br>&gt; <br>&gt; 	func f(@once closure: @noescape () -&gt; ())<br>&gt; <br>&gt; Since @once actually implies @noescape (as described earlier in the thread), it can be shortened to:<br>&gt; <br>&gt; 	func f(@once closure: () -&gt; ())	// implicit @noescape<br></p><p>why not just write<br></p><p>    func f(closure: @once () -&gt; ()) // ?<br></p><p>Because, to be honest, I don&#39;t want to have to learn the difference between an &quot;argument qualifier&quot; and a &quot;type attribute&quot;. They are both just words to me. Internally, I have two conflicting definitions of them: 1) &quot;argument qualifier&quot; = &quot;what is left of the name&quot;, &quot;type attribute&quot; = &quot;what comes right after the name, but before the type&quot; and 2) don&#39;t wanna say it because it&#39;s even more wrong. What I wanna say: the average user will not care about that distinction, he will not want to understand it, and he certainly will not want to have to understand it. And putting everything (however it is called), after the name, looks much nicer IMHO. I also think that this is one of the reason why SE-0049 was accepted. Furthermore, I don&#39;t think my definition 1) is too wrong, because I think the implementation of SE-0049 is a syntax-only change, right?<br></p><p>&gt; <br>&gt;&gt; Or maybe it&#39;s just because I can&#39;t think of a realistic use case for using &quot;@noescape(once)&quot;.<br>&gt; <br>&gt; The use case is the following: @once closures let the compiler know that the closure code is executed. It allows declaration of undefined `let` variables that are initialized in the @once closure:<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	f { x = 1 }<br>&gt; 	// use x<br>&gt; <br>&gt; Without @once, the developer has to work around:<br>&gt; <br>&gt; 	var x: Int = 0 // two problems: `var` declaration, and dummy value<br>&gt; 	f { x = 1 }<br>&gt; 	// use x<br>&gt; <br>&gt; If this proposal would be accepted, the next step would be to ask for dispatch_sync functions et al. to use this qualifier (as well as other standard functions like autoreleasepool, withUnsafeBufferPointer, etc.):<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	dispatch_sync(queue) {<br>&gt; 		x = 1<br>&gt; 	}<br>&gt; <br>&gt; And now high-level objects that use internal queues are easier to use:<br>&gt; <br>&gt; 	let items: [Item]<br>&gt; 	let users: [User]<br>&gt; 	dbQueue.inDatabase { db in<br>&gt; 		items = Item.fetchAll(db)<br>&gt; 		users = User.fetchAll(db)<br>&gt; 	}<br></p><p>These are all nice examples. If @once can be combined with the let/var-initialization system, it&#39;s a real improvement. I think dispatch_sync should be defined like<br></p><p>    func dispatch_sync(queue: dispatch_queue_t, block: @once () throws -&gt; ()) rethrows { ... }<br></p><p>and since @once implies @noescape, @noescape would be optional. The following would be equivalent:<br></p><p>    func dispatch_sync(queue: dispatch_queue_t, block: @once @noescape () throws -&gt; ()) rethrows { ... }<br></p><p>I think that our opinions only differ regarding the proper syntax of these features...<br></p><p>Another feature I would like to have is converting a block into a noescape block. This seems necessary when creating wrappers around existing APIs. E.g.<br></p><p>    func swift_dispatch_sync(queue: dispatch_queue_t, block: @noescape! () -&gt; ()) {<br>        dispatch_sync(queue, block: block)<br>    }<br></p><p>(note the &quot;!&quot; after &quot;@noescape&quot;.)<br>This should behave like this:<br></p><p>    func swift_dispatch_sync(queue: dispatch_queue_t, block: @noescape () -&gt; ()) {<br>        var isAlive = true<br>        let noescapeBlock = {<br>            if(!isAlive) { fatalError(&quot;noescape block called out of scope&quot;) }<br>            block()<br>        }<br>        defer { isAlive = false }<br>        dispatch_sync(queue, block: noescapeBlock)<br>    }<br></p><p>I would like to tell the compiler: &quot;I see that you cannot prove at compile time, that this closure doesn&#39;t escape, but believe me when I say, &#39;it really really does not escape&#39;. Can you please be less skeptical? May the fatalError hit me if I&#39;m wrong.&quot; (And the same would apply to &#39;@once&#39;, or &#39;@noescape(once)&#39;.)<br></p><p>When I think of it, my experimental synchronized-function would also profit from &#39;@once&#39;:<br></p><p>    /// same as Objective-C&#39;s @synchronized(object) { ... } function.<br>    func synchronized&lt;T&gt;(lock: AnyObject, @noescape _ closure: () throws -&gt; T) rethrows -&gt; T {<br>        var result: T;<br>        objc_sync_enter(lock)<br>        defer { objc_sync_exit(lock) }<br>        result = try closure()<br>        return result;<br>    }<br></p><p>-Michael<br></p><p>&gt; <br>&gt; This pattern would greatly improve many libraries, and my own http://github.com/groue/GRDB.swift in particular.<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt;&gt; Le 23 avr. 2016 à 14:16, Michael Peternell &lt;michael.peternell at gmx.at&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi Gwendal,<br>&gt;&gt; <br>&gt;&gt;&gt; Am 23.04.2016 um 12:18 schrieb Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Andrew,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m rather embarrassed: the initial design of this proposal was based on a modifier of @noescape:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func f(@noescape(once) closure: () -&gt; ()) { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But since the 0049 proposal has been accepted (https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md), @noescape is no longer an argument qualifier, but a type attribute.<br>&gt;&gt; <br>&gt;&gt; maybe I cannot give competent advice from the language designers perspective, but I can speak as a language user.<br>&gt;&gt; <br>&gt;&gt; I think it is more intuitive to have the name of the argument first: &quot;ARGUMENT-NAME: NOESCAPE AUTOCLOSURE TYPE FOOBAR-QUALIFIER..., NEXT-ARGUMENT-NAME...&quot; and not &quot;SOME-MODIFIERS-FIRST ARGUMENT-NAME: SOME-MODIFIERS-LAST&quot;. I think the old behavior reminded me too much of C, where the argument name is at some arbitrary place, surrounded by type names, parens, and whatnot; &quot;void foo(int __cdecl (*bar)(int foobar, void *context))&quot; where &quot;bar&quot; is the argument name, the first &quot;int&quot; is the return type of the &quot;bar&quot; function, &quot;int&quot; and &quot;void*&quot; are the two argument types, and &quot;__cdecl&quot; is the calling convention of the &quot;bar&quot; function.<br>&gt;&gt; <br>&gt;&gt; And about @noescape(once)... Would it not work anymore? I know it&#39;s not part of the current SE-0049 proposal, but I can&#39;t see why it couldn&#39;t be expanded to include `once`. Or maybe it&#39;s just because I can&#39;t think of a realistic use case for using &quot;@noescape(once)&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; The `once` discussed here can not be part of the type: if noescape can understandably be part of the type, the fact that a function guarantees it will call a closure once is a quality of that function, not of the closure.<br>&gt;&gt; <br>&gt;&gt; Yes it is a quality of the function and not of the type. But why not just leave it at that place and just call it &quot;argument qualifier&quot;? Or maybe the general layout changed? In Swift 2 it was &quot;ARGUMENT_QUALIFIERS ARGUMENT_NAME: TYPE_ATTRIBUTES TYPE&quot;, and in Swift 3 it is &quot;ARGUMENT_NAME: ARGUMENT_QUALIFIERS TYPE_ATTRIBUTES TYPE&quot;?<br>&gt;&gt; <br>&gt;&gt;&gt; So the proposed @noescape(once) syntax is now confusing as it would mix a type attribute and a argument qualifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t quite know how to escape this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// two @ signs<br>&gt;&gt;&gt; 	func f(@noescape @once closure: () -&gt; ()) { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// Implies @noescape<br>&gt;&gt;&gt; 	func f(@once closure: () -&gt; ()) { … }<br>&gt;&gt; <br>&gt;&gt; How about<br>&gt;&gt; <br>&gt;&gt;   func f(closure: @noescape(once) () -&gt; ()) { ... }<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like advice from competent people before I would attempt a rewrite of the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry I missed that scrolling back through the history, that proposal looks great. It doesn&#39;t look like it has been submitted as a pull request to swift-evolution yet though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Felix Cloutier already wrote one: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you think it needs to be rewritten?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you summarizing this thread in a formal proposal and putting it up for discussion or submitting it as a PR :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was wondering if this topic had evolved in anyway since its original introduction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	• It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Le 23 avr. 2016 à 15:47, michael.peternell at gmx.at a écrit :<br>&gt; <br>&gt; why not just write<br>&gt; <br>&gt;    func f(closure: @once () -&gt; ()) // ?<br>&gt; <br>&gt; Because, to be honest, I don&#39;t want to have to learn the difference between an &quot;argument qualifier&quot; and a &quot;type attribute&quot;. <br></p><p>I&#39;m with you here, but I will certainly not fight a Swift lawyer about the actual syntax :-)<br></p><p>For me the best syntax is the following because it makes the @noescape explicit, so that I know that I don&#39;t need to use explicit `self.` inside the closure.<br></p><p>	func f(closure: @noescape(once) () -&gt; ())<br></p><p>	let x: Int<br>	f { x = myIntProperty } // implicit self<br></p><p>&gt; When I think of it, my experimental synchronized-function would also profit from &#39;@once&#39;:<br>&gt; <br>&gt;    /// same as Objective-C&#39;s @synchronized(object) { ... } function.<br>&gt;    func synchronized&lt;T&gt;(lock: AnyObject, @noescape _ closure: () throws -&gt; T) rethrows -&gt; T {<br>&gt;        var result: T;<br>&gt;        objc_sync_enter(lock)<br>&gt;        defer { objc_sync_exit(lock) }<br>&gt;        result = try closure()<br>&gt;        return result;<br>&gt;    }<br></p><p>I&#39;m glad you see the point :-) I really believe that @noescape(once) is on the same boat as SE-0061 &quot;Add Generic Result and Error Handling to autoreleasepool() https://github.com/apple/swift-evolution/blob/master/proposals/0061-autoreleasepool-signature.md<br></p><p>Gwendal<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 23, 2016, at 5:56 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;<br>[...]<br>&gt; <br>&gt; Since @once actually implies @noescape (as described earlier in the thread), it can be shortened to:<br>[...]<br></p><p>I&#39;m surprised that @once would imply @noescape. In my opinion this makes it much less useful. For example, it is common to have asynchronous operations with a completion handler -- the completion handler will definitely escape and should definitely get called once.<br></p><p>In some cases the completion handler may get passed to other functions that take an @once block, so that should count as passing off your responsibility to call it.<br></p><p>In other cases, it may get stored in an object representing a long-lived async operation. This is trickier, but I would hope that a nullable var property, only in a reference type, could be marked @once. Reading that property would return an @once block *and* clear the property (so you&#39;d be back to needing to call it or pass it away). It is unclear if only closure properties should be allowed to be marked @once, but presumable the implementation cloud support any type.<br></p><p>A simple noescape @once might find a few trivial uses in my codebase, but the really hard to diagnose bugs have been in async code where escaping is natural and necessary.<br></p><p>-tim<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April 23, 2016 at 09:00:00am</p></header><div class="content"><p>Oh, and I forgot to mention that this would mean deinit would need to extract the block it it hadn&#39;t been done already. I would hope (to avoid silent errors) that the compiler would require a reference type with an @once property to have a deinit that checks for a lingering value and deals with it. This would have avoided a few bugs over the years...<br></p><p>-tim<br></p><p>&gt; On Apr 23, 2016, at 9:33 AM, Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 23, 2016, at 5:56 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; [...]<br>&gt;&gt; <br>&gt;&gt; Since @once actually implies @noescape (as described earlier in the thread), it can be shortened to:<br>&gt; [...]<br>&gt; <br>&gt; I&#39;m surprised that @once would imply @noescape. In my opinion this makes it much less useful. For example, it is common to have asynchronous operations with a completion handler -- the completion handler will definitely escape and should definitely get called once.<br>&gt; <br>&gt; In some cases the completion handler may get passed to other functions that take an @once block, so that should count as passing off your responsibility to call it.<br>&gt; <br>&gt; In other cases, it may get stored in an object representing a long-lived async operation. This is trickier, but I would hope that a nullable var property, only in a reference type, could be marked @once. Reading that property would return an @once block *and* clear the property (so you&#39;d be back to needing to call it or pass it away). It is unclear if only closure properties should be allowed to be marked @once, but presumable the implementation cloud support any type.<br>&gt; <br>&gt; A simple noescape @once might find a few trivial uses in my codebase, but the really hard to diagnose bugs have been in async code where escaping is natural and necessary.<br>&gt; <br>&gt; -tim<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 24, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Le 23 avr. 2016 à 18:33, Timothy Wood &lt;tjw at me.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 23, 2016, at 5:56 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; [...]<br>&gt;&gt; <br>&gt;&gt; Since @once actually implies @noescape (as described earlier in the thread), it can be shortened to:<br>&gt; [...]<br>&gt; <br>&gt; I&#39;m surprised that @once would imply @noescape. In my opinion this makes it much less useful. For example, it is common to have asynchronous operations with a completion handler -- the completion handler will definitely escape and should definitely get called once.<br></p><p>I&#39;m sorry but the goal of this proposal is not abstract, but very very very concrete:<br></p><p>	let x: Int<br>	f { x = 1 }<br>	// use x without compiler error<br></p><p>If you break this (and you do), you miss the point entirely.<br></p><p>&gt; In some cases the completion handler may get passed to other functions that take an @once block, so that should count as passing off your responsibility to call it.<br>&gt; <br>&gt; In other cases, it may get stored in an object representing a long-lived async operation. This is trickier, but I would hope that a nullable var property, only in a reference type, could be marked @once. Reading that property would return an @once block *and* clear the property (so you&#39;d be back to needing to call it or pass it away). It is unclear if only closure properties should be allowed to be marked @once, but presumable the implementation cloud support any type.<br>&gt; <br>&gt; A simple noescape @once might find a few trivial uses in my codebase, but the really hard to diagnose bugs have been in async code where escaping is natural and necessary.<br></p><p>You are describing another proposal. Please please please please don&#39;t pollute this one.<br></p><p>Gwendal Roué<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 23 avr. 2016 à 18:33, Timothy Wood &lt;tjw at me.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 23, 2016, at 5:56 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; [...]<br>&gt;&gt; <br>&gt;&gt; Since @once actually implies @noescape (as described earlier in the thread), it can be shortened to:<br>&gt; [...]<br>&gt; <br>&gt; I&#39;m surprised that @once would imply @noescape.<br></p><p>I should try to rewrite my last answer, which did not explain why @once implies @noescape.<br></p><p>It is because @once is not a documenting token that is ignored by the compiler. Its goal is to be actually *used* by the compiler - and let the following snippet compile:<br></p><p>	func f(closure: @noescape(once) () -&gt; ()) { closure() }<br>	<br>	let x: Int<br>	f { x = 1 }<br>	// use x without compiler complaining that x may be uninitialized.<br></p><p>For this pattern to work, the compiler needs to be able to prove that the closure has been called once at the end of the f function execution.<br></p><p>If the @once would only mean &quot;will eventually be called once&quot;, the compiler would have the biggest difficulties proving it (one can not prove for example that NSOperation&#39;s completionBlock is called. It is a documentation given, not a provable fact), and the compiler would not accept the use of a variable initialized in a `once` closure, as in the above sample code.<br></p><p>That&#39;s why this proposal focuses on a `once` modifier that implies @noescape, AND allows the use of variables initialized in such a closure.<br></p><p>I said in an earlier post that this was a natural extension of  SE-0061 &quot;Add Generic Result and Error Handling to autoreleasepool() https://github.com/apple/swift-evolution/blob/master/proposals/0061-autoreleasepool-signature.md<br></p><p>Before SE-0061, we had to write:<br></p><p>	var x: Int = 0<br>	autoreleasepol {<br>		x = 1<br>	}<br>	// use x<br></p><p>With SE-0061, we can write:<br></p><p>	let x = autoreleasepol {<br>		return 1<br>	}<br>	// use x<br></p><p>With this proposal, we can write:<br></p><p>	let x: Int<br>	let y: String<br>	autoreleasepol {<br>		x = 1<br>		y = &quot;foo&quot;<br>	}<br>	// use x and y<br></p><p>Gwendal Roué<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 23, 2016 at 11:00:00pm</p></header><div class="content"><p>I agree, it would be good if someone like Brent or Chris could chip in.<br>However, I think that @noescape(once) is still fine.<br></p><p>As long as a @noescape(once) closure must either be passed to a single<br>function, or called once it seems enforceable.<br></p><p>I don&#39;t believe a @noescape closure can be stored, so it doesn&#39;t change<br>anything.<br></p><p><br>On Sat, Apr 23, 2016 at 8:18 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt;<br>wrote:<br></p><p>&gt; Hello Andrew,<br>&gt;<br>&gt; I&#39;m rather embarrassed: the initial design of this proposal was based on a<br>&gt; modifier of @noescape:<br>&gt;<br>&gt; func f(@noescape(once) closure: () -&gt; ()) { … }<br>&gt;<br>&gt; But since the 0049 proposal has been accepted (<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md),<br>&gt; @noescape is no longer an argument qualifier, but a type attribute.<br>&gt;<br>&gt; The `once` discussed here can not be part of the type: if noescape can<br>&gt; understandably be part of the type, the fact that a function guarantees it<br>&gt; will call a closure once is a quality of that function, not of the closure.<br>&gt;<br>&gt; So the proposed @noescape(once) syntax is now confusing as it would mix a<br>&gt; type attribute and a argument qualifier.<br>&gt;<br>&gt; I don&#39;t quite know how to escape this:<br>&gt;<br>&gt; // two @ signs<br>&gt; func f(@noescape @once closure: () -&gt; ()) { … }<br>&gt;<br>&gt; // Implies @noescape<br>&gt; func f(@once closure: () -&gt; ()) { … }<br>&gt;<br>&gt; I&#39;d like advice from competent people before I would attempt a rewrite of<br>&gt; the proposal.<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;<br>&gt; Sorry I missed that scrolling back through the history, that proposal<br>&gt; looks great. It doesn&#39;t look like it has been submitted as a pull request<br>&gt; to swift-evolution yet though.<br>&gt;<br>&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Felix Cloutier already wrote one:<br>&gt;&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;<br>&gt;&gt; Do you think it needs to be rewritten?<br>&gt;&gt;<br>&gt;&gt; Gwendal Roué<br>&gt;&gt;<br>&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you<br>&gt;&gt; summarizing this thread in a formal proposal and putting it up for<br>&gt;&gt; discussion or submitting it as a PR :)<br>&gt;&gt;<br>&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was wondering if this topic had evolved in anyway since its original<br>&gt;&gt;&gt; introduction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at:<br>&gt;&gt;&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - It now says that the closure must be called on code paths where<br>&gt;&gt;&gt;    the function throws;<br>&gt;&gt;&gt;    - you can have multiple @noescape(once) parameters but they can&#39;t<br>&gt;&gt;&gt;    make assumptions from one another.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is<br>&gt;&gt;&gt; always desirable. I&#39;ve changed it because Chris&#39;s support probably means<br>&gt;&gt;&gt; that the feature has better chances of making it, but I&#39;m not convinced<br>&gt;&gt;&gt; yet. If throwing allows me to return without calling the closure, I can<br>&gt;&gt;&gt; write this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; let foo: Int<br>&gt;&gt;&gt; try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt; foo = sharedThing.foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter<br>&gt;&gt;&gt; to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/2bcb7e8f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 23, 2016, at 3:18 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Andrew,<br>&gt; <br>&gt; I&#39;m rather embarrassed: the initial design of this proposal was based on a modifier of @noescape:<br>&gt; <br>&gt; 	func f(@noescape(once) closure: () -&gt; ()) { … }<br>&gt; <br>&gt; But since the 0049 proposal has been accepted (https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md&gt;), @noescape is no longer an argument qualifier, but a type attribute.<br>&gt; <br>&gt; The `once` discussed here can not be part of the type: if noescape can understandably be part of the type, the fact that a function guarantees it will call a closure once is a quality of that function, not of the closure.<br>&gt; <br>&gt; So the proposed @noescape(once) syntax is now confusing as it would mix a type attribute and a argument qualifier.<br>&gt; <br>&gt; I don&#39;t quite know how to escape this:<br>&gt; <br>&gt; 	// two @ signs<br>&gt; 	func f(@noescape @once closure: () -&gt; ()) { … }<br>&gt; <br>&gt; 	// Implies @noescape<br>&gt; 	func f(@once closure: () -&gt; ()) { … }<br>&gt; <br>&gt; I&#39;d like advice from competent people before I would attempt a rewrite of the proposal.<br></p><p>Hi Gwendal,<br></p><p>I don’t think that the movement of @noescape affects the approach: I’d suggest that a proposal (e.g. Felix’s) go with:<br></p><p>	func f(closure: @noescape(once) () -&gt; ()) { … }<br></p><p>The semantics are clear: the closure is guaranteed to be called exactly once on all normal and “throw” paths.  Paths that do not return in either of those ways (e.g. a call to abort) do not need to call the closure.<br></p><p>IMO, this is a small scope proposal that is likely to be accepted.<br></p><p>-Chris<br></p><p><br></p><p>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Sorry I missed that scrolling back through the history, that proposal looks great. It doesn&#39;t look like it has been submitted as a pull request to swift-evolution yet though.<br>&gt;&gt; <br>&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com &lt;mailto:gwendal.roue at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Felix Cloutier already wrote one: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt; <br>&gt;&gt; Do you think it needs to be rewritten?<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cacoyi at gmail.com&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you summarizing this thread in a formal proposal and putting it up for discussion or submitting it as a PR :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was wondering if this topic had evolved in anyway since its original introduction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It now says that the closure must be called on code paths where the function throws;<br>&gt;&gt;&gt;&gt; you can have multiple @noescape(once) parameters but they can&#39;t make assumptions from one another.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is always desirable. I&#39;ve changed it because Chris&#39;s support probably means that the feature has better chances of making it, but I&#39;m not convinced yet. If throwing allows me to return without calling the closure, I can write this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt; 	let foo: Int<br>&gt;&gt;&gt;&gt; 	try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt;&gt; 		foo = sharedThing.foo<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt; 	print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/c45eab9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>Just curious, is there a deeper-than-semantic difference between a<br>@noescape(once) closure and an inlined closure?<br></p><p>On Sun, Apr 24, 2016, 5:58 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Apr 23, 2016, at 3:18 AM, Gwendal Roué via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello Andrew,<br>&gt;<br>&gt; I&#39;m rather embarrassed: the initial design of this proposal was based on a<br>&gt; modifier of @noescape:<br>&gt;<br>&gt; func f(@noescape(once) closure: () -&gt; ()) { … }<br>&gt;<br>&gt; But since the 0049 proposal has been accepted (<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0049-noescape-autoclosure-type-attrs.md),<br>&gt; @noescape is no longer an argument qualifier, but a type attribute.<br>&gt;<br>&gt; The `once` discussed here can not be part of the type: if noescape can<br>&gt; understandably be part of the type, the fact that a function guarantees it<br>&gt; will call a closure once is a quality of that function, not of the closure.<br>&gt;<br>&gt; So the proposed @noescape(once) syntax is now confusing as it would mix a<br>&gt; type attribute and a argument qualifier.<br>&gt;<br>&gt; I don&#39;t quite know how to escape this:<br>&gt;<br>&gt; // two @ signs<br>&gt; func f(@noescape @once closure: () -&gt; ()) { … }<br>&gt;<br>&gt; // Implies @noescape<br>&gt; func f(@once closure: () -&gt; ()) { … }<br>&gt;<br>&gt; I&#39;d like advice from competent people before I would attempt a rewrite of<br>&gt; the proposal.<br>&gt;<br>&gt;<br>&gt; Hi Gwendal,<br>&gt;<br>&gt; I don’t think that the movement of @noescape affects the approach: I’d<br>&gt; suggest that a proposal (e.g. Felix’s) go with:<br>&gt;<br>&gt; func f(closure: @noescape(once) () -&gt; ()) { … }<br>&gt;<br>&gt; The semantics are clear: the closure is guaranteed to be called exactly<br>&gt; once on all normal and “throw” paths.  Paths that do not return in either<br>&gt; of those ways (e.g. a call to abort) do not need to call the closure.<br>&gt;<br>&gt; IMO, this is a small scope proposal that is likely to be accepted.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; Gwendal Roué<br>&gt;<br>&gt; Le 10 avr. 2016 à 23:26, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;<br>&gt; Sorry I missed that scrolling back through the history, that proposal<br>&gt; looks great. It doesn&#39;t look like it has been submitted as a pull request<br>&gt; to swift-evolution yet though.<br>&gt;<br>&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Felix Cloutier already wrote one:<br>&gt;&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;<br>&gt;&gt; Do you think it needs to be rewritten?<br>&gt;&gt;<br>&gt;&gt; Gwendal Roué<br>&gt;&gt;<br>&gt;&gt; Le 10 avr. 2016 à 14:56, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Hi, not beyond this thread that I have seen. I think it&#39;s worth you<br>&gt;&gt; summarizing this thread in a formal proposal and putting it up for<br>&gt;&gt; discussion or submitting it as a PR :)<br>&gt;&gt;<br>&gt;&gt; On Sunday, 10 April 2016, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was wondering if this topic had evolved in anyway since its original<br>&gt;&gt;&gt; introduction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @noescape(once) would still be a useful addition to the language!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 3 févr. 2016 à 22:21, Félix Cloutier via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I updated the proposal to address some concerns. It can be found at:<br>&gt;&gt;&gt; https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Things that changed:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - It now says that the closure must be called on code paths where<br>&gt;&gt;&gt;    the function throws;<br>&gt;&gt;&gt;    - you can have multiple @noescape(once) parameters but they can&#39;t<br>&gt;&gt;&gt;    make assumptions from one another.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not 100% convinced that forcing a call on code paths that throw is<br>&gt;&gt;&gt; always desirable. I&#39;ve changed it because Chris&#39;s support probably means<br>&gt;&gt;&gt; that the feature has better chances of making it, but I&#39;m not convinced<br>&gt;&gt;&gt; yet. If throwing allows me to return without calling the closure, I can<br>&gt;&gt;&gt; write this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt; let foo: Int<br>&gt;&gt;&gt; try withLock(someLock, timeout: 0.5) {<br>&gt;&gt;&gt; foo = sharedThing.foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; print(&quot;couldn&#39;t acquire lock fast enough&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; which would be kind of messy if instead, the closure needed a parameter<br>&gt;&gt;&gt; to tell whether the lock was acquired or not when it runs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/6c25c1b5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 27, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Hi Gwendal,<br>&gt; <br>&gt; I don’t think that the movement of @noescape affects the approach: I’d suggest that a proposal (e.g. Felix’s) go with:<br>&gt; <br>&gt; 	func f(closure: @noescape(once) () -&gt; ()) { … }<br>&gt; <br>&gt; The semantics are clear: the closure is guaranteed to be called exactly once on all normal and “throw” paths.  Paths that do not return in either of those ways (e.g. a call to abort) do not need to call the closure.<br>&gt; <br>&gt; IMO, this is a small scope proposal that is likely to be accepted.<br></p><p>The pull request is open: https://github.com/apple/swift-evolution/pull/271<br></p><p>Gwendal Roué<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jan 31, 2016, at 9:54 AM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; it is not required to be executed on a code path that throws;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It may need to be clarified into &quot;must&quot; or &quot;must not&quot;, but I can&#39;t think about very good examples supporting either case right now.<br>&gt;&gt; <br>&gt; <br>&gt; What is the implication of this @noescape(once) closure not being call on throws when the caller use try? variation?<br></p><p>The compiler needs a guarantee one way or the other (that the closure is called or that it is not called), because it needs to know whether to clean up values initialized by the closure.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 10:17 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to pitch this proposal to implement the feature: https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;<br>&gt; <br>&gt; Rationale for some points:<br>&gt; <br>&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt; <br>&gt; <br>&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br></p><p>I don’t see a reason to have this limitation.  Definitive initialization has to be able to generate conditional code for partially initialized cases anyway, e.g.:<br></p><p>var c : C<br></p><p>if … {<br>   c = C()<br>}<br>c = C()  // could be an initialization or an assignment.<br>use(c)<br></p><p><br>The caller side would just have to conservatively prove that the closure bodies initialized any values they touch before using them (or that they were initialized already at the call site).<br></p><p>&gt;&gt; it is not required to be executed on a code path that throws;<br>&gt; <br>&gt; <br>&gt; It may need to be clarified into &quot;must&quot; or &quot;must not”,<br></p><p>Yes, I agree it needs to be one or the other.<br></p><p>&gt; but I can&#39;t think about very good examples supporting either case right now.<br></p><p>I think the simplest model is that it should be “must”.  IMO, the only most common (and again, simplest) semantics here is that the closure is called exactly once on any path to a return or throw.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/fca33603/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  1, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Le 31 janv. 2016 à 23:41:59, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt;&gt; Rationale for some points:<br>&gt;&gt; <br>&gt;&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br>&gt; <br>&gt; I don’t see a reason to have this limitation.  Definitive initialization has to be able to generate conditional code for partially initialized cases anyway, e.g.:<br>&gt; <br>&gt; var c : C<br>&gt; <br>&gt; if … {<br>&gt;    c = C()<br>&gt; }<br>&gt; c = C()  // could be an initialization or an assignment.<br>&gt; use(c)<br>&gt; <br>&gt; The caller side would just have to conservatively prove that the closure bodies initialized any values they touch before using them (or that they were initialized already at the call site).<br></p><p>I&#39;m not sure I communicated the concern clearly. Here&#39;s an example:<br></p><p>&gt; func withNoEscape(@noescape(once) a: () -&gt; (), @noescape(once) b: () -&gt; ()) { /* snip */ }<br>&gt; <br>&gt; func foo() {<br>&gt; 	let a: Int<br>&gt; 	let b: Int<br>&gt; 	withNoEscape({ a = 4 }, { b = a + 2})<br>&gt; }<br></p><p><br>How does the compiler know that `a` has been assigned a value by the time that `b = a + 2` is executed? Nothing says that `withNoEscape` executes the two closures in &quot;visual order&quot;.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Le 1 févr. 2016 à 06:12, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Le 31 janv. 2016 à 23:41:59, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt;&gt;&gt; Rationale for some points:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br>&gt;&gt; <br>&gt;&gt; I don’t see a reason to have this limitation.  Definitive initialization has to be able to generate conditional code for partially initialized cases anyway, e.g.:<br>&gt;&gt; <br>&gt;&gt; var c : C<br>&gt;&gt; <br>&gt;&gt; if … {<br>&gt;&gt;   c = C()<br>&gt;&gt; }<br>&gt;&gt; c = C()  // could be an initialization or an assignment.<br>&gt;&gt; use(c)<br>&gt;&gt; <br>&gt;&gt; The caller side would just have to conservatively prove that the closure bodies initialized any values they touch before using them (or that they were initialized already at the call site).<br>&gt; <br>&gt; I&#39;m not sure I communicated the concern clearly. Here&#39;s an example:<br>&gt; <br>&gt;&gt; func withNoEscape(@noescape(once) a: () -&gt; (), @noescape(once) b: () -&gt; ()) { /* snip */ }<br>&gt;&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt; 	let a: Int<br>&gt;&gt; 	let b: Int<br>&gt;&gt; 	withNoEscape({ a = 4 }, { b = a + 2})<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; How does the compiler know that `a` has been assigned a value by the time that `b = a + 2` is executed? Nothing says that `withNoEscape` executes the two closures in &quot;visual order ».<br></p><p>Indeed if the second closure could be made ready for both assignment or initialization of `b`, as Chris says. But here the concern is different: can even `a + 2` be computed?<br></p><p>Could a solution be to allow several @noescape(once) closures, but to forbid such dependency between them?<br>	<br>	let a: Int<br>	let b: Int<br>	withNoEscape({ a = 4 }, { b = 2 }) // OK<br>	withNoEscape({ a = 4 }, { b = a }) // Compiler error<br></p><p>Let me try to find reasons why we may want to support several @noescape(once) closures. Let’s imagine the context behind a use case for this.<br></p><p>1. Maybe one closure depends on the execution of the other. But then closures would likely take or return values, and our `a` and `b` initializations above are more like unnecessary side effects, some kind of clever trick that we may not need to support with so much convenience.<br></p><p>2. The two closures are internally run with code between them, code that involves a stateful API in which the ordering of statements is very important. Think OpenGL. Think our beloved UIKit. Now this may deserve attention. Because some kind of external constraint imposes the exposure of two distinct closures. It’s not fancy because it wants, it’s fancy because it must.<br></p><p>What do you think?<br></p><p>Gwendal<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 9:12 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 31 janv. 2016 à 23:41:59, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt;&gt;&gt; Rationale for some points:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Only one closure parameter can be marked as @noescape(once) in a function signature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The attribute doesn&#39;t specify the order of execution of the closures, so it could have unintended consequences if closure B depends on closure A but closure B is called first. Given the typical use case (the @noescape(once) closure as a trailing closure), I don&#39;t think that it&#39;s worth it to invest a lot of effort into coming up with a model to decide (and enforce) which closure has to be called first and what to do if either closure throws or something.<br>&gt;&gt; <br>&gt;&gt; I don’t see a reason to have this limitation.  Definitive initialization has to be able to generate conditional code for partially initialized cases anyway, e.g.:<br>&gt;&gt; <br>&gt;&gt; var c : C<br>&gt;&gt; <br>&gt;&gt; if … {<br>&gt;&gt;   c = C()<br>&gt;&gt; }<br>&gt;&gt; c = C()  // could be an initialization or an assignment.<br>&gt;&gt; use(c)<br>&gt;&gt; <br>&gt;&gt; The caller side would just have to conservatively prove that the closure bodies initialized any values they touch before using them (or that they were initialized already at the call site).<br>&gt; <br>&gt; I&#39;m not sure I communicated the concern clearly. Here&#39;s an example:<br>&gt; <br>&gt;&gt; func withNoEscape(@noescape(once) a: () -&gt; (), @noescape(once) b: () -&gt; ()) { /* snip */ }<br>&gt;&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt; 	let a: Int<br>&gt;&gt; 	let b: Int<br>&gt;&gt; 	withNoEscape({ a = 4 }, { b = a + 2})<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; How does the compiler know that `a` has been assigned a value by the time that `b = a + 2` is executed? Nothing says that `withNoEscape` executes the two closures in &quot;visual order”.<br></p><p>It wouldn’t know that, this would be a compile-time error.  Each closure would only be able to use values defined before the call.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 30, 2016 at 03:00:00pm</p></header><div class="content"><p>Can the compiler even enforce it? If the closure escapes, it necessarily means that you assigned it elsewhere. How do you enforce that you never call this reference more than once?<br></p><p>If the compiler can&#39;t take advantage of it and can&#39;t enforce it either, I would rather not have it at all.<br></p><p>I would also think that for a lot of APIs with an escaping closure, it could be more useful to say that it will be called &quot;at most once&quot; than &quot;exactly once&quot;. Additionally, if completion blocks are the main client of the feature, I would avoid giving it too much effort before we figure out the favored concurrency model.<br></p><p>@noescape(once) really looks like a special case to me, because it&#39;s enforceable, useful to the compiler and useful to the user.<br></p><p>Félix<br></p><p>&gt; Le 30 janv. 2016 à 15:07:11, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 30, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that many closures are expected to be executed only once, but it seems to me that it&#39;s only useful to the compiler if it&#39;s also marked @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t allow the compiler to determine that a variable will have been initialized after the call that takes the closure.<br>&gt;&gt; <br>&gt;&gt; So in these other cases, it only serves as documentation. I&#39;m not very enthusiastic about attributes that only serve as documentation because there is an infinity of attributes that can be added to the language for documentation purposes.<br>&gt; <br>&gt; It also serves as a guarantee that the closure is executed exactly once.  Even if the compiler can’t use it for optimization the guarantee could be useful.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; There are other places than `dispatch_sync` where you may want a `@noescape(once)` attribute. Any function that executes a closure while providing some sort of guarantee/RAII-like handle can benefit from it. Most of the functions starting with `with` in the standard library could benefit from it: withExtendedLifetime, withUnsafePointer and friends, withVaList. String&#39;s `withCString` and `withMutableCharacters` could benefit from it too. Someone who writes a `withLock(lock) { closure }` function would be happy to have it too.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m very supportive of this type of proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat orthogonal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a lot of places where you want to be clear that the block will be called but no more than once. For example, the NSURLSession callback blocks you would expect never to be called multiple times. Completion handlers are almost always used only once. I don&#39;t think this case, which is extremely common, can be overlooked.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, I suspect the majority of places you use closures with @noescape, it seems more likely you&#39;d want it used multiple times, like a search, filter, find etc of multiple items in a collection or group, otherwise you&#39;d generally just put the closured activity before or after. The only areas where I would expect to see such closures of @noescape and &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom code in the middle of a complex operation of a method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that separating them, but allowing them to be used together, makes more sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	    closure()<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt; 	print(x)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let items: [Item]<br>&gt;&gt;&gt;&gt;&gt;&gt; 	let users: [User]<br>&gt;&gt;&gt;&gt;&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt;&gt;&gt;&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/eed53c53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 30, 2016 at 09:00:00pm</p></header><div class="content"><p>+1<br></p><p>I&#39;ve wanted the ability require that a closure be called for a little while<br>now. Clean up code is an example of when this can be useful.<br></p><p>On Sat, Jan 30, 2016 at 9:54 PM, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Can the compiler even enforce it? If the closure escapes, it necessarily<br>&gt; means that you assigned it elsewhere. How do you enforce that you never<br>&gt; call this reference more than once?<br>&gt;<br>&gt; If the compiler can&#39;t take advantage of it and can&#39;t enforce it either, I<br>&gt; would rather not have it at all.<br>&gt;<br>&gt; I would also think that for a lot of APIs with an escaping closure, it<br>&gt; could be more useful to say that it will be called &quot;at most once&quot; than<br>&gt; &quot;exactly once&quot;. Additionally, if completion blocks are the main client of<br>&gt; the feature, I would avoid giving it too much effort before we figure out<br>&gt; the favored concurrency model.<br>&gt;<br>&gt; @noescape(once) really looks like a special case to me, because it&#39;s<br>&gt; enforceable, useful to the compiler and useful to the user.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 30 janv. 2016 à 15:07:11, Matthew Johnson &lt;matthew at anandabits.com&gt; a<br>&gt; écrit :<br>&gt;<br>&gt;<br>&gt; On Jan 30, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree that many closures are expected to be executed only once, but it<br>&gt; seems to me that it&#39;s only useful to the compiler if it&#39;s also marked<br>&gt; @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t<br>&gt; allow the compiler to determine that a variable will have been initialized<br>&gt; after the call that takes the closure.<br>&gt;<br>&gt; So in these other cases, it only serves as documentation. I&#39;m not very<br>&gt; enthusiastic about attributes that only serve as documentation because<br>&gt; there is an infinity of attributes that can be added to the language for<br>&gt; documentation purposes.<br>&gt;<br>&gt;<br>&gt; It also serves as a guarantee that the closure is executed exactly once.<br>&gt; Even if the compiler can’t use it for optimization the guarantee could be<br>&gt; useful.<br>&gt;<br>&gt;<br>&gt; There are other places than `dispatch_sync` where you may want a<br>&gt; `@noescape(once)` attribute. Any function that executes a closure while<br>&gt; providing some sort of guarantee/RAII-like handle can benefit from it. Most<br>&gt; of the functions starting with `with` in the standard library could benefit<br>&gt; from it: withExtendedLifetime, withUnsafePointer and friends, withVaList.<br>&gt; String&#39;s `withCString` and `withMutableCharacters` could benefit from it<br>&gt; too. Someone who writes a `withLock(lock) { closure }` function would be<br>&gt; happy to have it too.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com&gt; a écrit<br>&gt; :<br>&gt;<br>&gt; I&#39;m very supportive of this type of proposal.<br>&gt;<br>&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat<br>&gt; orthogonal.<br>&gt;<br>&gt; There are a lot of places where you want to be clear that the block will<br>&gt; be called but no more than once. For example, the NSURLSession callback<br>&gt; blocks you would expect never to be called multiple times. Completion<br>&gt; handlers are almost always used only once. I don&#39;t think this case, which<br>&gt; is extremely common, can be overlooked.<br>&gt;<br>&gt; On the other hand, I suspect the majority of places you use closures with<br>&gt; @noescape, it seems more likely you&#39;d *want *it used multiple times, like<br>&gt; a search, filter, find etc of multiple items in a collection or group,<br>&gt; otherwise you&#39;d generally just put the closured activity before or after.<br>&gt; The only areas where I would expect to see such closures of @noescape and<br>&gt; &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom<br>&gt; code in the middle of a complex operation of a method.<br>&gt;<br>&gt; It seems to me that separating them, but allowing them to be used<br>&gt; together, makes more sense.<br>&gt;<br>&gt; Rod<br>&gt;<br>&gt;<br>&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve wanted something like this as well. I think it would be harder than<br>&gt; it seems, because &quot;x = 1&quot; might need to perform initialization, or<br>&gt; assignment, depending how it&#39;s used.<br>&gt;<br>&gt; It could make sense to have something like<br>&gt; &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not<br>&gt; worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;<br>&gt;<br>&gt; I think that something like this is implementable, and making it a<br>&gt; modifier to @noescape is sensible.<br>&gt;<br>&gt; The semantics we could support is that the function is guaranteed to call<br>&gt; the closure exactly once on any path that could lead to a return or throw.<br>&gt;<br>&gt; This approach allows you to pass the closure down the stack, and composes<br>&gt; with error handling.  It is obviously limited what you can do with the<br>&gt; closure, but that is necessary to validate correctness.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; I’d like to discuss the opportunity to let functions declare that a<br>&gt;&gt; closure argument is guaranteed to have been executed when the function has<br>&gt;&gt; returned.<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;     closure()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The expected advantage is that the compiler would know that a variable<br>&gt;&gt; set inside the closure is guaranteed to be initialized, and that it can be<br>&gt;&gt; used after the execution of the function, as below:<br>&gt;&gt;<br>&gt;&gt; let x: Int  // Not initialized<br>&gt;&gt; f { x = 1 }<br>&gt;&gt; print(x)    // Guaranteed to be initialized<br>&gt;&gt;<br>&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;<br>&gt;&gt; var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt; f { x = 1 }<br>&gt;&gt; print(x)<br>&gt;&gt;<br>&gt;&gt; As for a real world usage, I’d like to access a database in a safe<br>&gt;&gt; (queued) way, and fetch values out of it:<br>&gt;&gt;<br>&gt;&gt; let items: [Item]<br>&gt;&gt; let users: [User]<br>&gt;&gt; dbQueue.inDatabase { db in<br>&gt;&gt;     items = Item.all().fetchAll(db)<br>&gt;&gt;     users = Item.all().fetchAll(db)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Gwendal Roué<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/8f88dd07/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 2:54 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Can the compiler even enforce it? If the closure escapes, it necessarily means that you assigned it elsewhere. How do you enforce that you never call this reference more than once?<br></p><p>Good point. It would probably be difficult if not impossible to enforce.<br></p><p>&gt; If the compiler can&#39;t take advantage of it and can&#39;t enforce it either, I would rather not have it at all.<br></p><p>Agree, if there is no guarantee it is better to live it out.<br></p><p>&gt; <br>&gt; I would also think that for a lot of APIs with an escaping closure, it could be more useful to say that it will be called &quot;at most once&quot; than &quot;exactly once&quot;. Additionally, if completion blocks are the main client of the feature, I would avoid giving it too much effort before we figure out the favored concurrency model.<br>&gt; <br>&gt; @noescape(once) really looks like a special case to me, because it&#39;s enforceable, useful to the compiler and useful to the user.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 janv. 2016 à 15:07:11, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 30, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that many closures are expected to be executed only once, but it seems to me that it&#39;s only useful to the compiler if it&#39;s also marked @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t allow the compiler to determine that a variable will have been initialized after the call that takes the closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So in these other cases, it only serves as documentation. I&#39;m not very enthusiastic about attributes that only serve as documentation because there is an infinity of attributes that can be added to the language for documentation purposes.<br>&gt;&gt; <br>&gt;&gt; It also serves as a guarantee that the closure is executed exactly once.  Even if the compiler can’t use it for optimization the guarantee could be useful.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are other places than `dispatch_sync` where you may want a `@noescape(once)` attribute. Any function that executes a closure while providing some sort of guarantee/RAII-like handle can benefit from it. Most of the functions starting with `with` in the standard library could benefit from it: withExtendedLifetime, withUnsafePointer and friends, withVaList. String&#39;s `withCString` and `withMutableCharacters` could benefit from it too. Someone who writes a `withLock(lock) { closure }` function would be happy to have it too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m very supportive of this type of proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat orthogonal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a lot of places where you want to be clear that the block will be called but no more than once. For example, the NSURLSession callback blocks you would expect never to be called multiple times. Completion handlers are almost always used only once. I don&#39;t think this case, which is extremely common, can be overlooked.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the other hand, I suspect the majority of places you use closures with @noescape, it seems more likely you&#39;d want it used multiple times, like a search, filter, find etc of multiple items in a collection or group, otherwise you&#39;d generally just put the closured activity before or after. The only areas where I would expect to see such closures of @noescape and &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom code in the middle of a complex operation of a method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that separating them, but allowing them to be used together, makes more sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rod<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    closure()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	print(x)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	let items: [Item]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	let users: [User]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/4fa31d23/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 12:54 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can the compiler even enforce it? If the closure escapes, it necessarily means that you assigned it elsewhere. How do you enforce that you never call this reference more than once?<br></p><p>It isn’t.  I agree with what I think you’re saying: noescape and “once” really are not orthogonal.<br></p><p>The combination of noescape+once is something the compiler can enforce, and because of that, it can provide improved initialization flexibility (and help make things like autoreleasepool feel more statement like).<br></p><p>The combination of escaping+once is not something the compiler can enforce, and becomes of that, it is little more than documentation.  I’m a huge fan of documentation, but building it into the language like this would mislead people into thinking it IS enforced by the compiler.  Also, this is not how we would build a documentation feature.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; If the compiler can&#39;t take advantage of it and can&#39;t enforce it either, I would rather not have it at all.<br>&gt; <br>&gt; I would also think that for a lot of APIs with an escaping closure, it could be more useful to say that it will be called &quot;at most once&quot; than &quot;exactly once&quot;. Additionally, if completion blocks are the main client of the feature, I would avoid giving it too much effort before we figure out the favored concurrency model.<br>&gt; <br>&gt; @noescape(once) really looks like a special case to me, because it&#39;s enforceable, useful to the compiler and useful to the user.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 janv. 2016 à 15:07:11, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 30, 2016, at 1:56 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that many closures are expected to be executed only once, but it seems to me that it&#39;s only useful to the compiler if it&#39;s also marked @noescape. A completion handler marked &quot;once&quot; without &quot;noescape&quot; doesn&#39;t allow the compiler to determine that a variable will have been initialized after the call that takes the closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So in these other cases, it only serves as documentation. I&#39;m not very enthusiastic about attributes that only serve as documentation because there is an infinity of attributes that can be added to the language for documentation purposes.<br>&gt;&gt; <br>&gt;&gt; It also serves as a guarantee that the closure is executed exactly once.  Even if the compiler can’t use it for optimization the guarantee could be useful.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are other places than `dispatch_sync` where you may want a `@noescape(once)` attribute. Any function that executes a closure while providing some sort of guarantee/RAII-like handle can benefit from it. Most of the functions starting with `with` in the standard library could benefit from it: withExtendedLifetime, withUnsafePointer and friends, withVaList. String&#39;s `withCString` and `withMutableCharacters` could benefit from it too. Someone who writes a `withLock(lock) { closure }` function would be happy to have it too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 30 janv. 2016 à 07:11:23, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m very supportive of this type of proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do agree with Brent though that @noescape and &#39;once&#39; is somewhat orthogonal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a lot of places where you want to be clear that the block will be called but no more than once. For example, the NSURLSession callback blocks you would expect never to be called multiple times. Completion handlers are almost always used only once. I don&#39;t think this case, which is extremely common, can be overlooked.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the other hand, I suspect the majority of places you use closures with @noescape, it seems more likely you&#39;d want it used multiple times, like a search, filter, find etc of multiple items in a collection or group, otherwise you&#39;d generally just put the closured activity before or after. The only areas where I would expect to see such closures of @noescape and &#39;once&#39; would be dispatch_sync, or somewhere where you want to invoke custom code in the middle of a complex operation of a method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that separating them, but allowing them to be used together, makes more sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rod<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Jan 2016, at 5:05 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t have much to add but I also think that it would be nice to have.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 29 janv. 2016 à 12:38:01, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 12:23 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve wanted something like this as well. I think it would be harder than it seems, because &quot;x = 1&quot; might need to perform initialization, or assignment, depending how it&#39;s used.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It could make sense to have something like &quot;@noescape(executed_exactly_once)&quot; but this might be so limited it&#39;s not worth it. And I&#39;m not sure how it should interact with throws.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think that something like this is implementable, and making it a modifier to @noescape is sensible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The semantics we could support is that the function is guaranteed to call the closure exactly once on any path that could lead to a return or throw.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This approach allows you to pass the closure down the stack, and composes with error handling.  It is obviously limited what you can do with the closure, but that is necessary to validate correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jan 28, 2016 at 11:38 PM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d like to discuss the opportunity to let functions declare that a closure argument is guaranteed to have been executed when the function has returned.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	func f(@noescape(executed) closure: () -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    closure()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The expected advantage is that the compiler would know that a variable set inside the closure is guaranteed to be initialized, and that it can be used after the execution of the function, as below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	let x: Int  // Not initialized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	print(x)    // Guaranteed to be initialized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Today developers have to write pessimistic code like below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	var x: Int = 0 // `var` declaration, with some irrelevant value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	f { x = 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	print(x)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for a real world usage, I’d like to access a database in a safe (queued) way, and fetch values out of it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	let items: [Item]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	let users: [User]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	dbQueue.inDatabase { db in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    items = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    users = Item.all().fetchAll(db)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/b7e0de83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Guaranteed closure execution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  1, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; The combination of noescape+once is something the compiler can enforce, and because of that, it can provide improved initialization flexibility (and help make things like autoreleasepool feel more statement like).<br>&gt; <br>&gt; The combination of escaping+once is not something the compiler can enforce, and becomes of that, it is little more than documentation.  I’m a huge fan of documentation, but building it into the language like this would mislead people into thinking it IS enforced by the compiler.  Also, this is not how we would build a documentation feature.<br></p><p>The main practical use I imagine this for is completion parameters. These should always be called exactly once, but it&#39;s all too easy to write one of these:<br></p><p>	if cantActuallyDoThis() {<br>		completion(.CantDoThisError)<br>		// forgot to return<br>	}<br>	guard doThing() else {<br>		return<br>		// forgot to call completion<br>	}<br></p><p>If a parameter is marked `@once`, but there are paths where it is executed twice or zero times, Swift ought to be able to detect that and emit an error. It can also assume that, if the parameter is called once within another closure, and *that* closure is passed to an `@once` parameter, it will be called once. A smart overlay on libdispatch could mark its APIs in appropriate places, and in general, the Clang importer could mark any parameter marked &quot;completion&quot; or &quot;completionHandler&quot; as `@once`. That would mark a large and useful subset of the frameworks.<br></p><p>If the parameter is called within a closure that&#39;s passed non-once, it&#39;s undecidable; it might be called zero, one, or many times. You could just complain about it, or you could do the analysis both ways, and if neither of them yields `@once`-compliant behavior, give a yell. <br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
