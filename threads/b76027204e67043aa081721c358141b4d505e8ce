<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d70fcf5ed1663dcaa9a68145abd470d5?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Ryan Lovelett</string> &lt;ryan at lovelett.me&gt;<p>November  4, 2016 at 08:00:00am</p></header><div class="content"><p>struct Foo {<br>  init(from buffer: Data) {<br>     bar = integer(withBytes: Array(buffer[4..&lt;6]))<br>     baz = integer(withBytes: Array(buffer[6..&lt;8]))<br>     ...<br>  }<br></p><p>let d = Data(count: Int(3e+8))<br>let f = Foo(from: d)<br></p><p>Did I just make two copies of the `Data`? How would I investigate this<br>to understand it?<br></p><p>I _think_ that if I made it `inout` then it would not make a copy but<br>now the data buffer is mutable. I want it to be clear I&#39;m not mutating<br>the buffer inside the initializer but I also want to be sure I&#39;m not<br>making a copy of the buffer either.<br></p><p>Help?<br></p><p>-- <br>  Ryan Lovelett<br>  ryan at lovelett.me<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>November  4, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 5:59 AM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; struct Foo {<br>&gt;  init(from buffer: Data) {<br>&gt;     bar = integer(withBytes: Array(buffer[4..&lt;6]))<br>&gt;     baz = integer(withBytes: Array(buffer[6..&lt;8]))<br>&gt;     ...<br>&gt;  }<br>&gt; <br>&gt; let d = Data(count: Int(3e+8))<br>&gt; let f = Foo(from: d)<br>&gt; <br>&gt; Did I just make two copies of the `Data`? How would I investigate this<br>&gt; to understand it?<br></p><p>Do you mean, &quot;did I make two copies of the `Data`, one in a top-level variable named `d` and the other in a parameter named `buffer`&quot;?<br></p><p>If so, then answer is &quot;Yes, but…&quot;<br></p><p>A value type like `Data` can&#39;t really hold variable-sized data like the bytes in a `Data` object. Instead, the bytes are stored in a separate object, and `Data` manages that with copy-on-write semantics. In other words, there are two copies of the `Data` instance itself, but they share a single copy of the bytes they&#39;re storing.<br></p><p>To illustrate more clearly, after this line:<br></p><p>	let d = Data(count: Int(3e+8))<br></p><p>You have something like this:<br></p><p>	| ...stack frame for top level...	|			+-------------------------------+<br>	| Data instance (d)			| --------------&gt;	 | ...3e+8 bytes of data... |<br>	| 						|			+-------------------------------+<br></p><p>And then once you execute the call on this line:<br></p><p>	let f = Foo(from: d)<br></p><p>You have this:<br></p><p>	| ...stack frame for top level...	|			+-------------------------------+<br>	| Data instance (d)			| --------------&gt;	 | ...3e+8 bytes of data... |<br>	| 						|			+-------------------------------+<br>	| ...stack frame for Foo(from:)	|					  ^			<br>	| Data instance (buffer)		| ---------------------------------+<br></p><p>If `Foo(from:)` were to copy `buffer` and then mutate the copy, the bytes would be copied before the mutation occurred. But since neither `f` nor `buffer` is mutated in this code (indeed, both are in immutable variables!), that never happens here.<br></p><p>&gt; I _think_ that if I made it `inout` then it would not make a copy but<br>&gt; now the data buffer is mutable. I want it to be clear I&#39;m not mutating<br>&gt; the buffer inside the initializer but I also want to be sure I&#39;m not<br>&gt; making a copy of the buffer either.<br></p><p>That&#39;s implementation-specific. Notionally, an `inout` variable is essentially passed in by value, modified as a copy, returned to the caller, and then assigned back to the original value. In some cases that&#39;s basically what actually ends up happening. But Swift tries to optimize `inout` behavior into directly mutating the original variable, and it&#39;s often successful.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d70fcf5ed1663dcaa9a68145abd470d5?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Ryan Lovelett</string> &lt;ryan at lovelett.me&gt;<p>November  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Do you mean, &quot;did I make two copies of the `Data`, one in a top-level<br>&gt; variable named `d` and the other in a parameter named `buffer`&quot;?<br></p><p>That is more precisely what I meant. Mutters to self: &quot;Precision of<br>language, Ryan!&quot;<br></p><p>That fairly completely answers my quandary. Thank you for your time and<br>energy.<br></p><p>Just out of curiosity if I looked at the SIL, would that allow me to see<br>any of that in action? Or would it be too opaque?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>November  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 9:45 AM, Ryan Lovelett &lt;ryan at lovelett.me&gt; wrote:<br>&gt; <br>&gt; Just out of curiosity if I looked at the SIL, would that allow me to see<br>&gt; any of that in action? Or would it be too opaque?<br></p><p>Maybe. What might be more directly useful is looking at the source for `Data` in Foundation:<br></p><p>&lt;https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/Data.swift#L73&gt;<br></p><p>You&#39;ll notice that `Data` has an internal property called `_wrapped` of type `_SwiftNSData`, which (if you jump up a few dozen lines) is a class. Since it&#39;s inside a class, the contents of that property won&#39;t be automatically copied.<br></p><p>Looking around a little more thoroughly, you might notice that `mutating` methods call `_applyUnmanagedMutation(_:)`: &lt;https://github.com/apple/swift/blob/14b689dee1dcd4e5e7a8b5722ce343a57e10149d/stdlib/public/SDK/Foundation/Data.swift#L444&gt;. If you search the codebase, you&#39;ll find the implementation of that method in a different file: &lt;https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/stdlib/public/SDK/Foundation/Boxing.swift#L173&gt;.<br></p><p>The heart of the copy-on-write behavior is the call to `isKnownUniquelyReferenced(_:)`. This is a part of the standard library which is basically only used to implement copy-on-write. `isKnownUniquelyReferenced(_:)` returns `true` if your variable is the only one which has a strong reference to the object. If so, it&#39;s safe to mutate; if not, you&#39;ll need to make a copy so you don&#39;t affect any of the other instances sharing the object with you.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  4, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 04 Nov 2016, at 13:59, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; struct Foo {<br>&gt;  init(from buffer: Data) {<br>&gt;     bar = integer(withBytes: Array(buffer[4..&lt;6]))<br>&gt;     baz = integer(withBytes: Array(buffer[6..&lt;8]))<br>&gt;     ...<br>&gt;  }<br>&gt; <br>&gt; let d = Data(count: Int(3e+8))<br>&gt; let f = Foo(from: d)<br>&gt; <br>&gt; Did I just make two copies of the `Data`? How would I investigate this<br>&gt; to understand it?<br></p><p>I often end up “printing” the addresses or using GDB to take an inside look.<br>However those snippets of inside information obtained that way are not necessary useful outside the specific problem that was studied.<br>As Brent already hinted: the compiler will generate different code in different situations. And for an outsider it is not always easy to understand why which code was generated.<br>The best approach imo is to “trust” the compiler and only start such investigations if you experience performance problems.<br></p><p>One thing that tripped me up: if you use inout variables, the observers will be triggered once the function completes. Even if the function never changed the data referred to. (This is now documented behaviour)<br></p><p><br>&gt; <br>&gt; I _think_ that if I made it `inout` then it would not make a copy but<br>&gt; now the data buffer is mutable. I want it to be clear I&#39;m not mutating<br>&gt; the buffer inside the initializer but I also want to be sure I&#39;m not<br>&gt; making a copy of the buffer either.<br>&gt; <br>&gt; Help?<br>&gt; <br>&gt; -- <br>&gt;  Ryan Lovelett<br>&gt;  ryan at lovelett.me<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d70fcf5ed1663dcaa9a68145abd470d5?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Ryan Lovelett</string> &lt;ryan at lovelett.me&gt;<p>November  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I often end up “printing” the addresses or using GDB to take an inside<br>&gt; look.<br></p><p>That is a really simple interrogation technique I wish I had thought of<br>that! Thank you!<br></p><p>&gt; One thing that tripped me up: if you use inout variables, the observers<br>&gt; will be triggered once the function completes. Even if the function never<br>&gt; changed the data referred to. (This is now documented behaviour)<br></p><p>Could you provide a link to such documentation? I think that would be<br>interesting to read.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  4, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 04 Nov 2016, at 17:48, Ryan Lovelett &lt;ryan at lovelett.me&gt; wrote:<br>&gt; <br>&gt;&gt; I often end up “printing” the addresses or using GDB to take an inside<br>&gt;&gt; look.<br>&gt; <br>&gt; That is a really simple interrogation technique I wish I had thought of<br>&gt; that! Thank you!<br>&gt; <br>&gt;&gt; One thing that tripped me up: if you use inout variables, the observers<br>&gt;&gt; will be triggered once the function completes. Even if the function never<br>&gt;&gt; changed the data referred to. (This is now documented behaviour)<br>&gt; <br>&gt; Could you provide a link to such documentation? I think that would be<br>&gt; interesting to read.<br></p><p>https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254<br></p><p>Check the last ‘note’ in the Property Observer section.<br>You can also follow the link in there for more.<br></p><p><br></p><p><br>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Understanding pass-by-value</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 10:12 AM, Rien via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 04 Nov 2016, at 17:48, Ryan Lovelett &lt;ryan at lovelett.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I often end up “printing” the addresses or using GDB to take an inside<br>&gt;&gt;&gt; look.<br>&gt;&gt; <br>&gt;&gt; That is a really simple interrogation technique I wish I had thought of<br>&gt;&gt; that! Thank you!<br>&gt;&gt; <br>&gt;&gt;&gt; One thing that tripped me up: if you use inout variables, the observers<br>&gt;&gt;&gt; will be triggered once the function completes. Even if the function never<br>&gt;&gt;&gt; changed the data referred to. (This is now documented behaviour)<br>&gt;&gt; <br>&gt;&gt; Could you provide a link to such documentation? I think that would be<br>&gt;&gt; interesting to read.<br>&gt; <br>&gt; https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254<br>&gt; <br>&gt; Check the last ‘note’ in the Property Observer section.<br>&gt; You can also follow the link in there for more.<br></p><p>There&#39;s also some deeper documentation about the accessor model in the compiler, here:<br></p><p>https://github.com/jckarter/swift/blob/master/docs/proposals/Accessors.rst &lt;https://github.com/jckarter/swift/blob/master/docs/proposals/Accessors.rst&gt;<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161104/06ee3dc7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
