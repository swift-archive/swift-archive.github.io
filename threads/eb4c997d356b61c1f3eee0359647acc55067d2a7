<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p># Abstract classes and methods<br></p><p>* Author(s): David Scrève<br></p><p>## Introduction<br></p><p>When developing framework and reusable, we need to develop classes that are partially <br>abstract with partial implementation. Protocol and protocol extensions provide this, but <br>they cannot have attributes as classes have.<br>A partial class combines the behavior of a class with the requirement of implementing methods<br>in inherited class like protocols.<br></p><p>Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br></p><p>## Motivation<br>Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>sometimes required abstract classes facility.<br>An abstract class is like a regular class, but some methods/properties are not implemented <br>and must be implemented in one of inherited classes.<br>An abstract class can inherit from other class, implements protocols and has members <br>attributes as opposite from protocols.<br>Only some methods and properties might be abstract.<br>The goal of abstract classes is to encapsulate a generic behavior that may need some <br>specific implementation methods which are not known in abstract class. This behavior <br>requires attributes that are used by internal abstract class method.<br></p><p>Example : <br>Considere a generic RESTClient that is included in a framework : <br></p><p>```swift<br>class RESTClient {<br>    <br>    var timeout = 3000<br>    <br>    var url : String {<br>        assert(false,&quot;Must be overriden&quot;)<br>        return &quot;&quot;<br>    }<br>    <br>    func performNetworkCall() {<br>        let restURL = self.url<br>        print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>    }<br>}<br></p><p>```<br></p><p>And an implementation : <br>```swift<br>class MyRestServiceClient : RESTClient {<br>    override var url : String {<br>        return &quot;http://www.foo.com/client&quot;<br>    }<br>    <br>}<br>```<br></p><p>As you can see, url properties must be implemented by inherited class and should not be <br>implemented by ancestor.<br>As workaround, we have added assertion, but this error is only detected at runtime and not <br>at compile time and might create crash for end-user.<br></p><p>## Proposed solution<br>We propose to add a new keyword to indicate that a method or a property is abstract and <br>not implemented in current class.<br>This indicates that method or properties must be implemented in inherited class that can <br>be implemented.<br>We propose the keyword abstract that must be added to class and property/method : <br></p><p>```swift<br>abstract class RESTClient {    <br>     var timeout = 3000<br></p><p>    abstract var url : String { get }<br>    <br>    func performNetworkCall() {<br>        let restURL = self.url<br>        print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>    }<br>}<br>```<br></p><p>And an implementation : <br>```swift<br>class MyRestServiceClient : RESTClient {<br>    override var url : String {<br>        return &quot;http://www.foo.com/client&quot;<br>    }<br>    <br>}<br>```<br></p><p>## Detailed design<br>An abstract class cannot be instanciated. <br></p><p>If a class contains one or more abstract methods/properties, it must be declared abstract.<br></p><p>A class that inherits from abstract must be declared abstract if it does not implements <br>all inherited methods/properties.<br></p><p>If you try to implement an abstract class or a inherited class that implements partially <br>abstract methods/properties, you will get a compiler error.<br></p><p>As for override keyword, abstract properties apply on setter, getter and observers. <br></p><p>When declaring an abstract property, you must specify which methods must be implemented : <br>get, set, didSet, willSet. <br></p><p>If you do not specify anything, only setter and getter are made <br>abstracts as below : <br></p><p>```swift<br>    abstract var url : String<br>```<br></p><p>Observers provides default empty implementation.<br></p><p>Type is mandatory for abstract properties since it cannot be inferred.<br></p><p>## Impact on existing code<br>This change has no impact on existing code, but might change the ABI that is being <br>stabilizing in Swift 3.0.<br></p><p>## Alternatives considered<br>As first reading, it seems that protocols and protocol extensions might fit the need. It <br>actually does not because abstract classes can have attributs and properties that <br>protocols does not support.<br></p><p>An alternative solution would be to add attributes to protocols and protocol extensions, <br>but this might break compatibility with Objective-C runtime.<br></p><p><br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/eb4cd2a7/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fdb7d28949d81cc824f5842c17b18512?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>charles@charlesism.com</string> &lt;charlesism.com at gmail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>+1<br></p><p>I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br></p><p>    var boo:Bool! { return nil /*DUMMY*/ }<br></p><p>It takes a significant amount of energy atm to plan a Swift project because there are quirky differences between: protocol / subclass / class extension. It&#39;s not so straightforward to pick the most appropriate one.<br></p><p><br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # Abstract classes and methods<br>&gt; <br>&gt; * Author(s): David Scrève<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt; they cannot have attributes as classes have.<br>&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt; in inherited class like protocols.<br>&gt; <br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt; <br>&gt; ## Motivation<br>&gt; Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>&gt; sometimes required abstract classes facility.<br>&gt; An abstract class is like a regular class, but some methods/properties are not implemented <br>&gt; and must be implemented in one of inherited classes.<br>&gt; An abstract class can inherit from other class, implements protocols and has members <br>&gt; attributes as opposite from protocols.<br>&gt; Only some methods and properties might be abstract.<br>&gt; The goal of abstract classes is to encapsulate a generic behavior that may need some <br>&gt; specific implementation methods which are not known in abstract class. This behavior <br>&gt; requires attributes that are used by internal abstract class method.<br>&gt; <br>&gt; Example : <br>&gt; Considere a generic RESTClient that is included in a framework : <br>&gt; <br>&gt; ```swift<br>&gt; class RESTClient {<br>&gt; <br>&gt;    var timeout = 3000<br>&gt; <br>&gt;    var url : String {<br>&gt;        assert(false,&quot;Must be overriden&quot;)<br>&gt;        return &quot;&quot;<br>&gt;    }<br>&gt; <br>&gt;    func performNetworkCall() {<br>&gt;        let restURL = self.url<br>&gt;        print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; And an implementation : <br>&gt; ```swift<br>&gt; class MyRestServiceClient : RESTClient {<br>&gt;    override var url : String {<br>&gt;        return &quot;http://www.foo.com/client&quot;<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; As you can see, url properties must be implemented by inherited class and should not be <br>&gt; implemented by ancestor.<br>&gt; As workaround, we have added assertion, but this error is only detected at runtime and not <br>&gt; at compile time and might create crash for end-user.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; We propose to add a new keyword to indicate that a method or a property is abstract and <br>&gt; not implemented in current class.<br>&gt; This indicates that method or properties must be implemented in inherited class that can <br>&gt; be implemented.<br>&gt; We propose the keyword abstract that must be added to class and property/method : <br>&gt; <br>&gt; ```swift<br>&gt; abstract class RESTClient {    <br>&gt;     var timeout = 3000<br>&gt; <br>&gt;    abstract var url : String { get }<br>&gt; <br>&gt;    func performNetworkCall() {<br>&gt;        let restURL = self.url<br>&gt;        print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;    }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; And an implementation : <br>&gt; ```swift<br>&gt; class MyRestServiceClient : RESTClient {<br>&gt;    override var url : String {<br>&gt;        return &quot;http://www.foo.com/client&quot;<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ## Detailed design<br>&gt; An abstract class cannot be instanciated. <br>&gt; <br>&gt; If a class contains one or more abstract methods/properties, it must be declared abstract.<br>&gt; <br>&gt; A class that inherits from abstract must be declared abstract if it does not implements <br>&gt; all inherited methods/properties.<br>&gt; <br>&gt; If you try to implement an abstract class or a inherited class that implements partially <br>&gt; abstract methods/properties, you will get a compiler error.<br>&gt; <br>&gt; As for override keyword, abstract properties apply on setter, getter and observers. <br>&gt; <br>&gt; When declaring an abstract property, you must specify which methods must be implemented : <br>&gt; get, set, didSet, willSet. <br>&gt; <br>&gt; If you do not specify anything, only setter and getter are made <br>&gt; abstracts as below : <br>&gt; <br>&gt; ```swift<br>&gt;    abstract var url : String<br>&gt; ```<br>&gt; <br>&gt; Observers provides default empty implementation.<br>&gt; <br>&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; This change has no impact on existing code, but might change the ABI that is being <br>&gt; stabilizing in Swift 3.0.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; As first reading, it seems that protocols and protocol extensions might fit the need. It <br>&gt; actually does not because abstract classes can have attributs and properties that <br>&gt; protocols does not support.<br>&gt; <br>&gt; An alternative solution would be to add attributes to protocols and protocol extensions, <br>&gt; but this might break compatibility with Objective-C runtime.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br></p><p>&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt; <br>&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt; <br>&gt; It takes a significant amount of energy atm to plan a Swift project because there are quirky differences between: protocol / subclass / class extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # Abstract classes and methods<br>&gt;&gt; <br>&gt;&gt; * Author(s): David Scrève<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt; in inherited class like protocols.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>&gt;&gt; sometimes required abstract classes facility.<br>&gt;&gt; An abstract class is like a regular class, but some methods/properties are not implemented <br>&gt;&gt; and must be implemented in one of inherited classes.<br>&gt;&gt; An abstract class can inherit from other class, implements protocols and has members <br>&gt;&gt; attributes as opposite from protocols.<br>&gt;&gt; Only some methods and properties might be abstract.<br>&gt;&gt; The goal of abstract classes is to encapsulate a generic behavior that may need some <br>&gt;&gt; specific implementation methods which are not known in abstract class. This behavior <br>&gt;&gt; requires attributes that are used by internal abstract class method.<br>&gt;&gt; <br>&gt;&gt; Example : <br>&gt;&gt; Considere a generic RESTClient that is included in a framework : <br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; class RESTClient {<br>&gt;&gt; <br>&gt;&gt;   var timeout = 3000<br>&gt;&gt; <br>&gt;&gt;   var url : String {<br>&gt;&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;&gt;       return &quot;&quot;<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;       let restURL = self.url<br>&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; And an implementation : <br>&gt;&gt; ```swift<br>&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;   override var url : String {<br>&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; As you can see, url properties must be implemented by inherited class and should not be <br>&gt;&gt; implemented by ancestor.<br>&gt;&gt; As workaround, we have added assertion, but this error is only detected at runtime and not <br>&gt;&gt; at compile time and might create crash for end-user.<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; We propose to add a new keyword to indicate that a method or a property is abstract and <br>&gt;&gt; not implemented in current class.<br>&gt;&gt; This indicates that method or properties must be implemented in inherited class that can <br>&gt;&gt; be implemented.<br>&gt;&gt; We propose the keyword abstract that must be added to class and property/method : <br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; abstract class RESTClient {    <br>&gt;&gt;    var timeout = 3000<br>&gt;&gt; <br>&gt;&gt;   abstract var url : String { get }<br>&gt;&gt; <br>&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;       let restURL = self.url<br>&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; And an implementation : <br>&gt;&gt; ```swift<br>&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;   override var url : String {<br>&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; An abstract class cannot be instanciated. <br>&gt;&gt; <br>&gt;&gt; If a class contains one or more abstract methods/properties, it must be declared abstract.<br>&gt;&gt; <br>&gt;&gt; A class that inherits from abstract must be declared abstract if it does not implements <br>&gt;&gt; all inherited methods/properties.<br>&gt;&gt; <br>&gt;&gt; If you try to implement an abstract class or a inherited class that implements partially <br>&gt;&gt; abstract methods/properties, you will get a compiler error.<br>&gt;&gt; <br>&gt;&gt; As for override keyword, abstract properties apply on setter, getter and observers. <br>&gt;&gt; <br>&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : <br>&gt;&gt; get, set, didSet, willSet. <br>&gt;&gt; <br>&gt;&gt; If you do not specify anything, only setter and getter are made <br>&gt;&gt; abstracts as below : <br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt;   abstract var url : String<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Observers provides default empty implementation.<br>&gt;&gt; <br>&gt;&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; This change has no impact on existing code, but might change the ABI that is being <br>&gt;&gt; stabilizing in Swift 3.0.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; As first reading, it seems that protocols and protocol extensions might fit the need. It <br>&gt;&gt; actually does not because abstract classes can have attributs and properties that <br>&gt;&gt; protocols does not support.<br>&gt;&gt; <br>&gt;&gt; An alternative solution would be to add attributes to protocols and protocol extensions, <br>&gt;&gt; but this might break compatibility with Objective-C runtime.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/8ce49779/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:42 PM, David James via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br></p><p>+1 to these comments.  This proposal notes that protocols would provide very similar behavior if they were allowed to have stored properties.  That has already been discussed a little bit.  I think it would be best to decide whether that will happen or not before introducing abstract classes and methods.<br></p><p>Matthew<br></p><p>&gt; <br>&gt;&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt;&gt; <br>&gt;&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt;&gt; <br>&gt;&gt; It takes a significant amount of energy atm to plan a Swift project because there are quirky differences between: protocol / subclass / class extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Abstract classes and methods<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Author(s): David Scrève<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt;&gt; in inherited class like protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>&gt;&gt;&gt; sometimes required abstract classes facility.<br>&gt;&gt;&gt; An abstract class is like a regular class, but some methods/properties are not implemented <br>&gt;&gt;&gt; and must be implemented in one of inherited classes.<br>&gt;&gt;&gt; An abstract class can inherit from other class, implements protocols and has members <br>&gt;&gt;&gt; attributes as opposite from protocols.<br>&gt;&gt;&gt; Only some methods and properties might be abstract.<br>&gt;&gt;&gt; The goal of abstract classes is to encapsulate a generic behavior that may need some <br>&gt;&gt;&gt; specific implementation methods which are not known in abstract class. This behavior <br>&gt;&gt;&gt; requires attributes that are used by internal abstract class method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example : <br>&gt;&gt;&gt; Considere a generic RESTClient that is included in a framework : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class RESTClient {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var timeout = 3000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var url : String {<br>&gt;&gt;&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;&gt;&gt;       return &quot;&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;       return &quot;http://www.foo.com/client &lt;http://www.foo.com/client&gt;&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you can see, url properties must be implemented by inherited class and should not be <br>&gt;&gt;&gt; implemented by ancestor.<br>&gt;&gt;&gt; As workaround, we have added assertion, but this error is only detected at runtime and not <br>&gt;&gt;&gt; at compile time and might create crash for end-user.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; We propose to add a new keyword to indicate that a method or a property is abstract and <br>&gt;&gt;&gt; not implemented in current class.<br>&gt;&gt;&gt; This indicates that method or properties must be implemented in inherited class that can <br>&gt;&gt;&gt; be implemented.<br>&gt;&gt;&gt; We propose the keyword abstract that must be added to class and property/method : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; abstract class RESTClient {    <br>&gt;&gt;&gt;    var timeout = 3000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   abstract var url : String { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;       return &quot;http://www.foo.com/client &lt;http://www.foo.com/client&gt;&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; An abstract class cannot be instanciated. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a class contains one or more abstract methods/properties, it must be declared abstract.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A class that inherits from abstract must be declared abstract if it does not implements <br>&gt;&gt;&gt; all inherited methods/properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you try to implement an abstract class or a inherited class that implements partially <br>&gt;&gt;&gt; abstract methods/properties, you will get a compiler error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for override keyword, abstract properties apply on setter, getter and observers. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : <br>&gt;&gt;&gt; get, set, didSet, willSet. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you do not specify anything, only setter and getter are made <br>&gt;&gt;&gt; abstracts as below : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;   abstract var url : String<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Observers provides default empty implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; This change has no impact on existing code, but might change the ABI that is being <br>&gt;&gt;&gt; stabilizing in Swift 3.0.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; As first reading, it seems that protocols and protocol extensions might fit the need. It <br>&gt;&gt;&gt; actually does not because abstract classes can have attributs and properties that <br>&gt;&gt;&gt; protocols does not support.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An alternative solution would be to add attributes to protocols and protocol extensions, <br>&gt;&gt;&gt; but this might break compatibility with Objective-C runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; David James<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/e00b2f49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 7 janv. 2016 à 19:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 12:42 PM, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br>&gt; <br>&gt; +1 to these comments.  This proposal notes that protocols would provide very similar behavior if they were allowed to have stored properties.  That has already been discussed a little bit.  I think it would be best to decide whether that will happen or not before introducing abstract classes and methods.<br></p><p>I agree that the support for stored properties in protocols should definitely help avoiding the need for an abstract classes in many cases.<br></p><p>The problem, though, is that abstract classes still have something that protocol do not, and this is the encapsulation of implementation details. Protocols, on the other side, are open in the wide, expose all their inner guts. The problem with convenience protocols that expose too much implementation details is that they make refactoring very difficult, if possible at all. Abstract classes don’t have this issue.<br></p><p>So I think protocols still have a long, long, way before they can match abstract classes.<br></p><p>Gwendal<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/14a50664/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 12:57 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 19:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 12:42 PM, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br>&gt;&gt; <br>&gt;&gt; +1 to these comments.  This proposal notes that protocols would provide very similar behavior if they were allowed to have stored properties.  That has already been discussed a little bit.  I think it would be best to decide whether that will happen or not before introducing abstract classes and methods.<br>&gt; <br>&gt; I agree that the support for stored properties in protocols should definitely help avoiding the need for an abstract classes in many cases.<br>&gt; <br>&gt; The problem, though, is that abstract classes still have something that protocol do not, and this is the encapsulation of implementation details. Protocols, on the other side, are open in the wide, expose all their inner guts. The problem with convenience protocols that expose too much implementation details is that they make refactoring very difficult, if possible at all. Abstract classes don’t have this issue.<br></p><p>That doesn’t have to be the case.  In fact, if an enhancement came along that allowed protocols to have stored properties I think there will be a request to allow access control on those properties.  If they aren’t required to have initial values some way to initialize them would also be necessary.  This would allow pretty strong encapsulation.<br></p><p>It is also possible that stored properties in protocols won’t be adopted or would be adopted without allowing for encapsulation.  If that is the path that we follow then you make good points.  I am just suggesting that we might want to wait and see before considering abstract classes.  It might turn out that they really aren’t necessary.<br></p><p>&gt; <br>&gt; So I think protocols still have a long, long, way before they can match abstract classes.<br>&gt; <br>&gt; Gwendal<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/ae17513e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 7 janv. 2016 à 20:01, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt;&gt; The problem, though, is that abstract classes still have something that protocol do not, and this is the encapsulation of implementation details. Protocols, on the other side, are open in the wide, expose all their inner guts. The problem with convenience protocols that expose too much implementation details is that they make refactoring very difficult, if possible at all. Abstract classes don’t have this issue.<br>&gt; <br>&gt; That doesn’t have to be the case.  In fact, if an enhancement came along that allowed protocols to have stored properties I think there will be a request to allow access control on those properties.  If they aren’t required to have initial values some way to initialize them would also be necessary.  This would allow pretty strong encapsulation.<br></p><p>You clearly address the hiding of implementation details from the code that uses types adopting such a protocol. But I’m not sure those implementation details can be hidden from the adopting types themselves?<br></p><p>&gt; It is also possible that stored properties in protocols won’t be adopted or would be adopted without allowing for encapsulation.  If that is the path that we follow then you make good points.  I am just suggesting that we might want to wait and see before considering abstract classes.  It might turn out that they really aren’t necessary.<br></p><p><br>And we’ll continue fatalError(&quot;subclass must override&quot;) :-)<br></p><p>Gwendal<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/8763d038/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 1:18 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 20:01, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; The problem, though, is that abstract classes still have something that protocol do not, and this is the encapsulation of implementation details. Protocols, on the other side, are open in the wide, expose all their inner guts. The problem with convenience protocols that expose too much implementation details is that they make refactoring very difficult, if possible at all. Abstract classes don’t have this issue.<br>&gt;&gt; <br>&gt;&gt; That doesn’t have to be the case.  In fact, if an enhancement came along that allowed protocols to have stored properties I think there will be a request to allow access control on those properties.  If they aren’t required to have initial values some way to initialize them would also be necessary.  This would allow pretty strong encapsulation.<br>&gt; <br>&gt; You clearly address the hiding of implementation details from the code that uses types adopting such a protocol. But I’m not sure those implementation details can be hidden from the adopting types themselves?<br></p><p>Yes, it would be possible to have `private` stored properties in a protocol that were only visible within the file declaring the protocol.  Presumably they would be used by default implementations or `final` methods  added in an extension in the same file.<br></p><p>I do not know whether Swift will go down the path of allowing this or not but it would be possible.<br></p><p>&gt; <br>&gt;&gt; It is also possible that stored properties in protocols won’t be adopted or would be adopted without allowing for encapsulation.  If that is the path that we follow then you make good points.  I am just suggesting that we might want to wait and see before considering abstract classes.  It might turn out that they really aren’t necessary.<br>&gt; <br>&gt; <br>&gt; And we’ll continue fatalError(&quot;subclass must override&quot;) :-)<br></p><p>If we end up in that situation I would not be surprised to see a proposal for abstract classes.  But I’d rather wait and see.<br></p><p>&gt; <br>&gt; Gwendal<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/2432534c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Hello David,<br></p><p>I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused. Composition does not mean you should never subclass and Swift should not make it trickier to implement inheritance although I could agree it should not bend over backwards for it either.<br>I think this proposal goes along this direction.<br></p><p>With that said, this is where protocols and protocol extensions with default methods come in, but there we have the static dispatching of the methods declare in the protocol extension with the default implementation unless they were also created in the original protocol in which case the default implementation is only used if the type implementing the protocol does not override it... That area needs some revisiting too perhaps.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Jan 2016, at 18:42, David James via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt;&gt; <br>&gt;&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt;&gt; <br>&gt;&gt; It takes a significant amount of energy atm to plan a Swift project because there are quirky differences between: protocol / subclass / class extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Abstract classes and methods<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Author(s): David Scrève<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt;&gt; in inherited class like protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>&gt;&gt;&gt; sometimes required abstract classes facility.<br>&gt;&gt;&gt; An abstract class is like a regular class, but some methods/properties are not implemented <br>&gt;&gt;&gt; and must be implemented in one of inherited classes.<br>&gt;&gt;&gt; An abstract class can inherit from other class, implements protocols and has members <br>&gt;&gt;&gt; attributes as opposite from protocols.<br>&gt;&gt;&gt; Only some methods and properties might be abstract.<br>&gt;&gt;&gt; The goal of abstract classes is to encapsulate a generic behavior that may need some <br>&gt;&gt;&gt; specific implementation methods which are not known in abstract class. This behavior <br>&gt;&gt;&gt; requires attributes that are used by internal abstract class method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example : <br>&gt;&gt;&gt; Considere a generic RESTClient that is included in a framework : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class RESTClient {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var timeout = 3000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var url : String {<br>&gt;&gt;&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;&gt;&gt;       return &quot;&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you can see, url properties must be implemented by inherited class and should not be <br>&gt;&gt;&gt; implemented by ancestor.<br>&gt;&gt;&gt; As workaround, we have added assertion, but this error is only detected at runtime and not <br>&gt;&gt;&gt; at compile time and might create crash for end-user.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; We propose to add a new keyword to indicate that a method or a property is abstract and <br>&gt;&gt;&gt; not implemented in current class.<br>&gt;&gt;&gt; This indicates that method or properties must be implemented in inherited class that can <br>&gt;&gt;&gt; be implemented.<br>&gt;&gt;&gt; We propose the keyword abstract that must be added to class and property/method : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; abstract class RESTClient {    <br>&gt;&gt;&gt;    var timeout = 3000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   abstract var url : String { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; An abstract class cannot be instanciated. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a class contains one or more abstract methods/properties, it must be declared abstract.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A class that inherits from abstract must be declared abstract if it does not implements <br>&gt;&gt;&gt; all inherited methods/properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you try to implement an abstract class or a inherited class that implements partially <br>&gt;&gt;&gt; abstract methods/properties, you will get a compiler error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for override keyword, abstract properties apply on setter, getter and observers. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : <br>&gt;&gt;&gt; get, set, didSet, willSet. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you do not specify anything, only setter and getter are made <br>&gt;&gt;&gt; abstracts as below : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;   abstract var url : String<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Observers provides default empty implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; This change has no impact on existing code, but might change the ABI that is being <br>&gt;&gt;&gt; stabilizing in Swift 3.0.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; As first reading, it seems that protocols and protocol extensions might fit the need. It <br>&gt;&gt;&gt; actually does not because abstract classes can have attributs and properties that <br>&gt;&gt;&gt; protocols does not support.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An alternative solution would be to add attributes to protocols and protocol extensions, <br>&gt;&gt;&gt; but this might break compatibility with Objective-C runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; David James<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/09bccd85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I am not sure that the language should discourage a feature it supports<br>and impose friction on it because it could be abused.<br></p><p>Especially since the OOP philosophy is falling out of fashion anyway.<br>Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come<br>to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t<br>going to turn that ship around.<br></p><p><br></p><p>On Thu, Jan 7, 2016 at 11:27 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt;<br>wrote:<br></p><p>&gt; Hello David,<br>&gt;<br>&gt; I am not sure that the language should discourage a feature it supports<br>&gt; and impose friction on it because it could be abused. Composition does not<br>&gt; mean you should never subclass and Swift should not make it trickier to<br>&gt; implement inheritance although I could agree it should not bend over<br>&gt; backwards for it either.<br>&gt; I think this proposal goes along this direction.<br>&gt;<br>&gt; With that said, this is where protocols and protocol extensions with<br>&gt; default methods come in, but there we have the static dispatching of the<br>&gt; methods declare in the protocol extension with the default implementation<br>&gt; unless they were also created in the original protocol in which case the<br>&gt; default implementation is only used if the type implementing the protocol<br>&gt; does not override it... That area needs some revisiting too perhaps.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 7 Jan 2016, at 18:42, David James via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Not sure the language direction should *encourage* inheritance based<br>&gt; structures, which abstract classes and methods do. That’s not to say that<br>&gt; inheritance is dead, but that a modern language should encourage and<br>&gt; support compositional patterns rather than inheritance based patterns.<br>&gt;<br>&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1<br>&gt;<br>&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt;<br>&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt;<br>&gt; It takes a significant amount of energy atm to plan a Swift project<br>&gt; because there are quirky differences between: protocol / subclass / class<br>&gt; extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; # Abstract classes and methods<br>&gt;<br>&gt; * Author(s): David Scrève<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; When developing framework and reusable, we need to develop classes that<br>&gt; are partially<br>&gt; abstract with partial implementation. Protocol and protocol extensions<br>&gt; provide this, but<br>&gt; they cannot have attributes as classes have.<br>&gt; A partial class combines the behavior of a class with the requirement of<br>&gt; implementing methods<br>&gt; in inherited class like protocols.<br>&gt;<br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt; Like pure virtual methods in C++ and abtract classes in Java and C#,<br>&gt; frameworks development<br>&gt; sometimes required abstract classes facility.<br>&gt; An abstract class is like a regular class, but some methods/properties are<br>&gt; not implemented<br>&gt; and must be implemented in one of inherited classes.<br>&gt; An abstract class can inherit from other class, implements protocols and<br>&gt; has members<br>&gt; attributes as opposite from protocols.<br>&gt; Only some methods and properties might be abstract.<br>&gt; The goal of abstract classes is to encapsulate a generic behavior that may<br>&gt; need some<br>&gt; specific implementation methods which are not known in abstract class.<br>&gt; This behavior<br>&gt; requires attributes that are used by internal abstract class method.<br>&gt;<br>&gt; Example :<br>&gt; Considere a generic RESTClient that is included in a framework :<br>&gt;<br>&gt; ```swift<br>&gt; class RESTClient {<br>&gt;<br>&gt;   var timeout = 3000<br>&gt;<br>&gt;   var url : String {<br>&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;       return &quot;&quot;<br>&gt;   }<br>&gt;<br>&gt;   func performNetworkCall() {<br>&gt;       let restURL = self.url<br>&gt;       print(&quot;Performing URL call to \(restURL) with timeout<br>&gt; \(self.timeout)&quot;)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; And an implementation :<br>&gt; ```swift<br>&gt; class MyRestServiceClient : RESTClient {<br>&gt;   override var url : String {<br>&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; As you can see, url properties must be implemented by inherited class and<br>&gt; should not be<br>&gt; implemented by ancestor.<br>&gt; As workaround, we have added assertion, but this error is only detected at<br>&gt; runtime and not<br>&gt; at compile time and might create crash for end-user.<br>&gt;<br>&gt; ## Proposed solution<br>&gt; We propose to add a new keyword to indicate that a method or a property is<br>&gt; abstract and<br>&gt; not implemented in current class.<br>&gt; This indicates that method or properties must be implemented in inherited<br>&gt; class that can<br>&gt; be implemented.<br>&gt; We propose the keyword abstract that must be added to class and<br>&gt; property/method :<br>&gt;<br>&gt; ```swift<br>&gt; abstract class RESTClient {<br>&gt;    var timeout = 3000<br>&gt;<br>&gt;   abstract var url : String { get }<br>&gt;<br>&gt;   func performNetworkCall() {<br>&gt;       let restURL = self.url<br>&gt;       print(&quot;Performing URL call to \(restURL) with timeout<br>&gt; \(self.timeout)&quot;)<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; And an implementation :<br>&gt; ```swift<br>&gt; class MyRestServiceClient : RESTClient {<br>&gt;   override var url : String {<br>&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ## Detailed design<br>&gt; An abstract class cannot be instanciated.<br>&gt;<br>&gt; If a class contains one or more abstract methods/properties, it must be<br>&gt; declared abstract.<br>&gt;<br>&gt; A class that inherits from abstract must be declared abstract if it does<br>&gt; not implements<br>&gt; all inherited methods/properties.<br>&gt;<br>&gt; If you try to implement an abstract class or a inherited class that<br>&gt; implements partially<br>&gt; abstract methods/properties, you will get a compiler error.<br>&gt;<br>&gt; As for override keyword, abstract properties apply on setter, getter and<br>&gt; observers.<br>&gt;<br>&gt; When declaring an abstract property, you must specify which methods must<br>&gt; be implemented :<br>&gt; get, set, didSet, willSet.<br>&gt;<br>&gt; If you do not specify anything, only setter and getter are made<br>&gt; abstracts as below :<br>&gt;<br>&gt; ```swift<br>&gt;   abstract var url : String<br>&gt; ```<br>&gt;<br>&gt; Observers provides default empty implementation.<br>&gt;<br>&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt; This change has no impact on existing code, but might change the ABI that<br>&gt; is being<br>&gt; stabilizing in Swift 3.0.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt; As first reading, it seems that protocols and protocol extensions might<br>&gt; fit the need. It<br>&gt; actually does not because abstract classes can have attributs and<br>&gt; properties that<br>&gt; protocols does not support.<br>&gt;<br>&gt; An alternative solution would be to add attributes to protocols and<br>&gt; protocol extensions,<br>&gt; but this might break compatibility with Objective-C runtime.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; David James<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/f3cb392b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>True too, but I think there is some overreaction too especially with the heavy push from FP programmers. Truth is that composition, inheritance, and functional programming are all tools and not religions. We can learn from each how to code better in general and mix and match.<br></p><p>Although this talk predates Swift&#39;s default methods/mixins, and so it stops earlier than you might like, it makes a lot of valid points:<br></p><p>Watch “Somewhere Between Tomorrowland and Frontierland - Daniel Steinberg” on Vimeo: https://vimeo.com/124349158<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Jan 2016, at 19:41, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt; <br>&gt; &gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused.<br>&gt; <br>&gt; Especially since the OOP philosophy is falling out of fashion anyway. Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t going to turn that ship around.<br>&gt; <br>&gt;  <br>&gt; <br>&gt;&gt; On Thu, Jan 7, 2016 at 11:27 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; Hello David,<br>&gt;&gt; <br>&gt;&gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused. Composition does not mean you should never subclass and Swift should not make it trickier to implement inheritance although I could agree it should not bend over backwards for it either.<br>&gt;&gt; I think this proposal goes along this direction.<br>&gt;&gt; <br>&gt;&gt; With that said, this is where protocols and protocol extensions with default methods come in, but there we have the static dispatching of the methods declare in the protocol extension with the default implementation unless they were also created in the original protocol in which case the default implementation is only used if the type implementing the protocol does not override it... That area needs some revisiting too perhaps.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Jan 2016, at 18:42, David James via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It takes a significant amount of energy atm to plan a Swift project because there are quirky differences between: protocol / subclass / class extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Abstract classes and methods<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Author(s): David Scrève<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt;&gt;&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt;&gt;&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt;&gt;&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt;&gt;&gt;&gt; in inherited class like protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt; Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>&gt;&gt;&gt;&gt;&gt; sometimes required abstract classes facility.<br>&gt;&gt;&gt;&gt;&gt; An abstract class is like a regular class, but some methods/properties are not implemented <br>&gt;&gt;&gt;&gt;&gt; and must be implemented in one of inherited classes.<br>&gt;&gt;&gt;&gt;&gt; An abstract class can inherit from other class, implements protocols and has members <br>&gt;&gt;&gt;&gt;&gt; attributes as opposite from protocols.<br>&gt;&gt;&gt;&gt;&gt; Only some methods and properties might be abstract.<br>&gt;&gt;&gt;&gt;&gt; The goal of abstract classes is to encapsulate a generic behavior that may need some <br>&gt;&gt;&gt;&gt;&gt; specific implementation methods which are not known in abstract class. This behavior <br>&gt;&gt;&gt;&gt;&gt; requires attributes that are used by internal abstract class method.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example : <br>&gt;&gt;&gt;&gt;&gt; Considere a generic RESTClient that is included in a framework : <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; class RESTClient {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var timeout = 3000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var url : String {<br>&gt;&gt;&gt;&gt;&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;&gt;&gt;&gt;&gt;       return &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As you can see, url properties must be implemented by inherited class and should not be <br>&gt;&gt;&gt;&gt;&gt; implemented by ancestor.<br>&gt;&gt;&gt;&gt;&gt; As workaround, we have added assertion, but this error is only detected at runtime and not <br>&gt;&gt;&gt;&gt;&gt; at compile time and might create crash for end-user.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt; We propose to add a new keyword to indicate that a method or a property is abstract and <br>&gt;&gt;&gt;&gt;&gt; not implemented in current class.<br>&gt;&gt;&gt;&gt;&gt; This indicates that method or properties must be implemented in inherited class that can <br>&gt;&gt;&gt;&gt;&gt; be implemented.<br>&gt;&gt;&gt;&gt;&gt; We propose the keyword abstract that must be added to class and property/method : <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; abstract class RESTClient {    <br>&gt;&gt;&gt;&gt;&gt;    var timeout = 3000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   abstract var url : String { get }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt; An abstract class cannot be instanciated. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If a class contains one or more abstract methods/properties, it must be declared abstract.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A class that inherits from abstract must be declared abstract if it does not implements <br>&gt;&gt;&gt;&gt;&gt; all inherited methods/properties.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you try to implement an abstract class or a inherited class that implements partially <br>&gt;&gt;&gt;&gt;&gt; abstract methods/properties, you will get a compiler error.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for override keyword, abstract properties apply on setter, getter and observers. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : <br>&gt;&gt;&gt;&gt;&gt; get, set, didSet, willSet. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you do not specify anything, only setter and getter are made <br>&gt;&gt;&gt;&gt;&gt; abstracts as below : <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;   abstract var url : String<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Observers provides default empty implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; This change has no impact on existing code, but might change the ABI that is being <br>&gt;&gt;&gt;&gt;&gt; stabilizing in Swift 3.0.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; As first reading, it seems that protocols and protocol extensions might fit the need. It <br>&gt;&gt;&gt;&gt;&gt; actually does not because abstract classes can have attributs and properties that <br>&gt;&gt;&gt;&gt;&gt; protocols does not support.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An alternative solution would be to add attributes to protocols and protocol extensions, <br>&gt;&gt;&gt;&gt;&gt; but this might break compatibility with Objective-C runtime.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David James<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/5e778eab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>January  8, 2016 at 03:00:00am</p></header><div class="content"><p>Just for my own education, what is the difference between &quot;protocols&quot; and<br>&quot;traits&quot; or are they different in name only.<br></p><p>Im a new swift programmer, and im trying to map things back to languages i<br>have experience with,  the languages i have used in anger are  c++, modern<br>(post 5.2) php,  javascript and golang,  to be truthfull the thing that is<br>driving me away from golang and towards swift is go&#39;s lack of extensive oop<br>support. In particular the lack of classes and inheritance.<br>On Jan 8, 2016 3:50 AM, &quot;Goffredo Marocchi via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; True too, but I think there is some overreaction too especially with the<br>&gt; heavy push from FP programmers. Truth is that composition, inheritance, and<br>&gt; functional programming are all tools and not religions. We can learn from<br>&gt; each how to code better in general and mix and match.<br>&gt;<br>&gt; Although this talk predates Swift&#39;s default methods/mixins, and so it<br>&gt; stops earlier than you might like, it makes a lot of valid points:<br>&gt;<br>&gt; Watch “Somewhere Between Tomorrowland and Frontierland - Daniel Steinberg”<br>&gt; on Vimeo: https://vimeo.com/124349158<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 7 Jan 2016, at 19:41, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;<br>&gt; &gt; I am not sure that the language should discourage a feature it supports<br>&gt; and impose friction on it because it could be abused.<br>&gt;<br>&gt; Especially since the OOP philosophy is falling out of fashion anyway.<br>&gt; Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come<br>&gt; to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t<br>&gt; going to turn that ship around.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jan 7, 2016 at 11:27 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hello David,<br>&gt;&gt;<br>&gt;&gt; I am not sure that the language should discourage a feature it supports<br>&gt;&gt; and impose friction on it because it could be abused. Composition does not<br>&gt;&gt; mean you should never subclass and Swift should not make it trickier to<br>&gt;&gt; implement inheritance although I could agree it should not bend over<br>&gt;&gt; backwards for it either.<br>&gt;&gt; I think this proposal goes along this direction.<br>&gt;&gt;<br>&gt;&gt; With that said, this is where protocols and protocol extensions with<br>&gt;&gt; default methods come in, but there we have the static dispatching of the<br>&gt;&gt; methods declare in the protocol extension with the default implementation<br>&gt;&gt; unless they were also created in the original protocol in which case the<br>&gt;&gt; default implementation is only used if the type implementing the protocol<br>&gt;&gt; does not override it... That area needs some revisiting too perhaps.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On 7 Jan 2016, at 18:42, David James via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Not sure the language direction should *encourage* inheritance based<br>&gt;&gt; structures, which abstract classes and methods do. That’s not to say that<br>&gt;&gt; inheritance is dead, but that a modern language should encourage and<br>&gt;&gt; support compositional patterns rather than inheritance based patterns.<br>&gt;&gt;<br>&gt;&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt;&gt;<br>&gt;&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt;&gt;<br>&gt;&gt; It takes a significant amount of energy atm to plan a Swift project<br>&gt;&gt; because there are quirky differences between: protocol / subclass / class<br>&gt;&gt; extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; # Abstract classes and methods<br>&gt;&gt;<br>&gt;&gt; * Author(s): David Scrève<br>&gt;&gt;<br>&gt;&gt; ## Introduction<br>&gt;&gt;<br>&gt;&gt; When developing framework and reusable, we need to develop classes that<br>&gt;&gt; are partially<br>&gt;&gt; abstract with partial implementation. Protocol and protocol extensions<br>&gt;&gt; provide this, but<br>&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt; A partial class combines the behavior of a class with the requirement of<br>&gt;&gt; implementing methods<br>&gt;&gt; in inherited class like protocols.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt;<br>&gt;&gt; ## Motivation<br>&gt;&gt; Like pure virtual methods in C++ and abtract classes in Java and C#,<br>&gt;&gt; frameworks development<br>&gt;&gt; sometimes required abstract classes facility.<br>&gt;&gt; An abstract class is like a regular class, but some methods/properties<br>&gt;&gt; are not implemented<br>&gt;&gt; and must be implemented in one of inherited classes.<br>&gt;&gt; An abstract class can inherit from other class, implements protocols and<br>&gt;&gt; has members<br>&gt;&gt; attributes as opposite from protocols.<br>&gt;&gt; Only some methods and properties might be abstract.<br>&gt;&gt; The goal of abstract classes is to encapsulate a generic behavior that<br>&gt;&gt; may need some<br>&gt;&gt; specific implementation methods which are not known in abstract class.<br>&gt;&gt; This behavior<br>&gt;&gt; requires attributes that are used by internal abstract class method.<br>&gt;&gt;<br>&gt;&gt; Example :<br>&gt;&gt; Considere a generic RESTClient that is included in a framework :<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; class RESTClient {<br>&gt;&gt;<br>&gt;&gt;   var timeout = 3000<br>&gt;&gt;<br>&gt;&gt;   var url : String {<br>&gt;&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;&gt;       return &quot;&quot;<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;       let restURL = self.url<br>&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout<br>&gt;&gt; \(self.timeout)&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; And an implementation :<br>&gt;&gt; ```swift<br>&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;   override var url : String {<br>&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; As you can see, url properties must be implemented by inherited class and<br>&gt;&gt; should not be<br>&gt;&gt; implemented by ancestor.<br>&gt;&gt; As workaround, we have added assertion, but this error is only detected<br>&gt;&gt; at runtime and not<br>&gt;&gt; at compile time and might create crash for end-user.<br>&gt;&gt;<br>&gt;&gt; ## Proposed solution<br>&gt;&gt; We propose to add a new keyword to indicate that a method or a property<br>&gt;&gt; is abstract and<br>&gt;&gt; not implemented in current class.<br>&gt;&gt; This indicates that method or properties must be implemented in inherited<br>&gt;&gt; class that can<br>&gt;&gt; be implemented.<br>&gt;&gt; We propose the keyword abstract that must be added to class and<br>&gt;&gt; property/method :<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; abstract class RESTClient {<br>&gt;&gt;    var timeout = 3000<br>&gt;&gt;<br>&gt;&gt;   abstract var url : String { get }<br>&gt;&gt;<br>&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;       let restURL = self.url<br>&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout<br>&gt;&gt; \(self.timeout)&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; And an implementation :<br>&gt;&gt; ```swift<br>&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;   override var url : String {<br>&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; ## Detailed design<br>&gt;&gt; An abstract class cannot be instanciated.<br>&gt;&gt;<br>&gt;&gt; If a class contains one or more abstract methods/properties, it must be<br>&gt;&gt; declared abstract.<br>&gt;&gt;<br>&gt;&gt; A class that inherits from abstract must be declared abstract if it does<br>&gt;&gt; not implements<br>&gt;&gt; all inherited methods/properties.<br>&gt;&gt;<br>&gt;&gt; If you try to implement an abstract class or a inherited class that<br>&gt;&gt; implements partially<br>&gt;&gt; abstract methods/properties, you will get a compiler error.<br>&gt;&gt;<br>&gt;&gt; As for override keyword, abstract properties apply on setter, getter and<br>&gt;&gt; observers.<br>&gt;&gt;<br>&gt;&gt; When declaring an abstract property, you must specify which methods must<br>&gt;&gt; be implemented :<br>&gt;&gt; get, set, didSet, willSet.<br>&gt;&gt;<br>&gt;&gt; If you do not specify anything, only setter and getter are made<br>&gt;&gt; abstracts as below :<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt;   abstract var url : String<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Observers provides default empty implementation.<br>&gt;&gt;<br>&gt;&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;&gt;<br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; This change has no impact on existing code, but might change the ABI that<br>&gt;&gt; is being<br>&gt;&gt; stabilizing in Swift 3.0.<br>&gt;&gt;<br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; As first reading, it seems that protocols and protocol extensions might<br>&gt;&gt; fit the need. It<br>&gt;&gt; actually does not because abstract classes can have attributs and<br>&gt;&gt; properties that<br>&gt;&gt; protocols does not support.<br>&gt;&gt;<br>&gt;&gt; An alternative solution would be to add attributes to protocols and<br>&gt;&gt; protocol extensions,<br>&gt;&gt; but this might break compatibility with Objective-C runtime.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; David James<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/9e1bda2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>Think of a protocol as an abstract contract a type can adopt. A protocol helps by decoupling the promise the protocol makes to the code using a type conforming to it from the actual implementation of said functionality. You can adopt one or more protocols depending on the behaviours your object wants to support.<br></p><p>This helps testing and refactoring the code greatly.<br></p><p>A trait differs from a protocol in that it provides a method implementation too (protocol extensions allow to specify default method implementations). A mixin differs from a trait in that you can add stored properties to it as well.<br></p><p>Some resources: http://matthijshollemans.com/2015/07/22/mixins-and-traits-in-swift-2/?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=rss&amp;utm_source=This_Week_in_Swift_67<br></p><p>The code in the video referenced earlier on augmented with protocol extensions: http://kelan.io/2015/approachable-functional-thinking-using-protocol-extensions/?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=rss&amp;utm_source=This_Week_in_Swift_67.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Jan 2016, at 19:59, Tim Hawkins &lt;tim.thawkins at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just for my own education, what is the difference between &quot;protocols&quot; and &quot;traits&quot; or are they different in name only.<br>&gt; <br>&gt; Im a new swift programmer, and im trying to map things back to languages i have experience with,  the languages i have used in anger are  c++, modern (post 5.2) php,  javascript and golang,  to be truthfull the thing that is driving me away from golang and towards swift is go&#39;s lack of extensive oop support. In particular the lack of classes and inheritance.<br>&gt; <br>&gt;&gt; On Jan 8, 2016 3:50 AM, &quot;Goffredo Marocchi via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; True too, but I think there is some overreaction too especially with the heavy push from FP programmers. Truth is that composition, inheritance, and functional programming are all tools and not religions. We can learn from each how to code better in general and mix and match.<br>&gt;&gt; <br>&gt;&gt; Although this talk predates Swift&#39;s default methods/mixins, and so it stops earlier than you might like, it makes a lot of valid points:<br>&gt;&gt; <br>&gt;&gt; Watch “Somewhere Between Tomorrowland and Frontierland - Daniel Steinberg” on Vimeo: https://vimeo.com/124349158<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Jan 2016, at 19:41, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially since the OOP philosophy is falling out of fashion anyway. Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t going to turn that ship around.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jan 7, 2016 at 11:27 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello David,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused. Composition does not mean you should never subclass and Swift should not make it trickier to implement inheritance although I could agree it should not bend over backwards for it either.<br>&gt;&gt;&gt;&gt; I think this proposal goes along this direction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With that said, this is where protocols and protocol extensions with default methods come in, but there we have the static dispatching of the methods declare in the protocol extension with the default implementation unless they were also created in the original protocol in which case the default implementation is only used if the type implementing the protocol does not override it... That area needs some revisiting too perhaps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 7 Jan 2016, at 18:42, David James via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not sure the language direction should encourage inheritance based structures, which abstract classes and methods do. That’s not to say that inheritance is dead, but that a modern language should encourage and support compositional patterns rather than inheritance based patterns. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 7:19 PM, charles--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have loads of &quot;pretend abstract&quot; classes littered with stuff like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    var boo:Bool! { return nil /*DUMMY*/ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It takes a significant amount of energy atm to plan a Swift project because there are quirky differences between: protocol / subclass / class extension. It&#39;s not so straightforward to pick the most appropriate one.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; # Abstract classes and methods<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Author(s): David Scrève<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in inherited class like protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Like pure virtual methods in C++ and abtract classes in Java and C#, frameworks development <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sometimes required abstract classes facility.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An abstract class is like a regular class, but some methods/properties are not implemented <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and must be implemented in one of inherited classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An abstract class can inherit from other class, implements protocols and has members <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; attributes as opposite from protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Only some methods and properties might be abstract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of abstract classes is to encapsulate a generic behavior that may need some <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; specific implementation methods which are not known in abstract class. This behavior <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requires attributes that are used by internal abstract class method.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Considere a generic RESTClient that is included in a framework : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class RESTClient {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var timeout = 3000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var url : String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       assert(false,&quot;Must be overriden&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As you can see, url properties must be implemented by inherited class and should not be <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implemented by ancestor.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As workaround, we have added assertion, but this error is only detected at runtime and not <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; at compile time and might create crash for end-user.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose to add a new keyword to indicate that a method or a property is abstract and <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not implemented in current class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This indicates that method or properties must be implemented in inherited class that can <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be implemented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose the keyword abstract that must be added to class and property/method : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstract class RESTClient {    <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var timeout = 3000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   abstract var url : String { get }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   func performNetworkCall() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       let restURL = self.url<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       print(&quot;Performing URL call to \(restURL) with timeout \(self.timeout)&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And an implementation : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyRestServiceClient : RESTClient {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   override var url : String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return &quot;http://www.foo.com/client&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An abstract class cannot be instanciated. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a class contains one or more abstract methods/properties, it must be declared abstract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A class that inherits from abstract must be declared abstract if it does not implements <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; all inherited methods/properties.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you try to implement an abstract class or a inherited class that implements partially <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstract methods/properties, you will get a compiler error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for override keyword, abstract properties apply on setter, getter and observers. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; get, set, didSet, willSet. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you do not specify anything, only setter and getter are made <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstracts as below : <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   abstract var url : String<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Observers provides default empty implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Type is mandatory for abstract properties since it cannot be inferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This change has no impact on existing code, but might change the ABI that is being <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; stabilizing in Swift 3.0.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As first reading, it seems that protocols and protocol extensions might fit the need. It <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; actually does not because abstract classes can have attributs and properties that <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocols does not support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An alternative solution would be to add attributes to protocols and protocol extensions, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but this might break compatibility with Objective-C runtime.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; David James<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/6bf6f071/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 7 janv. 2016 à 20:41, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused.<br>&gt; <br>&gt; Especially since the OOP philosophy is falling out of fashion anyway. Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t going to turn that ship around.<br></p><p>It’s not only about fashion, is it?<br></p><p>Let’s take a practical example, and consider a Swift library that accesses a database. Its writer has jumped in the protocol-oriented wagon, and provides protocols that grants adopting types fetching and persistence methods:<br></p><p>- RowConvertible: types that can be converted from a database row can be fetched:<br></p><p>	Person.fetch(database, &quot;SELECT …&quot;)<br></p><p>- TableMapping: types that are linked to a database table. On top of RowConvertible, it grants fetching by primary key:<br></p><p>	Person.fetch(database, key: 12)<br></p><p>- DatabasePersistable (inherits from TableMapping): types that can be saved in the database:<br></p><p>	Person(name: &quot;Arthur&quot;).insert(database)<br></p><p>So far, so good. How does look a user type that uses all those features?<br></p><p>	struct Person: RowConvertible, TableMapping, DatabasePersistable { … }<br></p><p>That’s quite a long declaration, but it works.<br></p><p>Enter another feature: changes tracking. Changes tracking requires remembering reference data in order to see what’s changed. Protocols don’t (yet) provide stored properties, so the library, today, has to expose a class for this purpose. That class is *abstract* since subclasses *have* to override the method that tells the table name.<br></p><p>	class Record: RowConvertible, TableMapping, DatabasePersistable { … }<br></p><p>How does look a user type that provides the full toolkit (fetching + persistence + changes tracking) ?<br></p><p>	class Person: Record { … }<br></p><p>Sweet! Can you see how the abstract Record class provides:<br></p><p>1. less mental overhead for the library user (a single type provides the full toolkit)<br>2. Succinct user types declaration (you don’t have to learn about the three core protocols, just inherit from Record)<br>3. features that protocols can’t provide (here, changes tracking)<br></p><p>In conclusion: protocol-oriented programming is *more complex* than class-based programming. I think that it is important that the Swift ecosystem lets libraries expose simple entry points even though they provide a list of small and focused protocols that can be composed, because protocol composition requires more engagement from library users.<br></p><p>In the example above, the Record class would benefit from being declared abstract, if the language would support such feature. BTW, that Record class exists: https://github.com/groue/GRDB.swift#database-protocols-and-record &lt;https://github.com/groue/GRDB.swift#database-protocols-and-record&gt;.<br></p><p>Gwendal<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/59917f26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  7, 2016 at 11:00:00pm</p></header><div class="content"><p>I agree that abstract classes/methods are useful and probably belong in Swift. Inheritance is still (in my opinion) the most natural way to model certain problem domains, even if it has been falsely touted as a panacea for far too long, and I feel like its inclusion in Swift is more than just a sop to Objective-C interoperability.<br></p><p>Practically speaking, iOS/OS X GUI applications written using Apple&#39;s existing frameworks are going to be a major part of Swift&#39;s future for a long time to come, and the ability to define abstract classes is a natural fit for Cocoa, UIKit, and Foundation&#39;s inheritance-based paradigm. Abstract classes serve a purpose (e.g. abstract subclasses of UITableViewController intended to break out shared app-specific functionality) that protocol extensions can&#39;t fulfill. You can also go through the documentation and note the many classes which are intended to be subclassed (with mandatory extension points), but cannot express misuse to the programmer until they are used at runtime.<br></p><p>Austin<br></p><p>&gt; On Jan 7, 2016, at 11:22 PM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 20:41, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; &gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused.<br>&gt;&gt; <br>&gt;&gt; Especially since the OOP philosophy is falling out of fashion anyway. Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t going to turn that ship around.<br>&gt; <br>&gt; It’s not only about fashion, is it?<br>&gt; <br>&gt; Let’s take a practical example, and consider a Swift library that accesses a database. Its writer has jumped in the protocol-oriented wagon, and provides protocols that grants adopting types fetching and persistence methods:<br>&gt; <br>&gt; - RowConvertible: types that can be converted from a database row can be fetched:<br>&gt; <br>&gt; 	Person.fetch(database, &quot;SELECT …&quot;)<br>&gt; <br>&gt; - TableMapping: types that are linked to a database table. On top of RowConvertible, it grants fetching by primary key:<br>&gt; <br>&gt; 	Person.fetch(database, key: 12)<br>&gt; <br>&gt; - DatabasePersistable (inherits from TableMapping): types that can be saved in the database:<br>&gt; <br>&gt; 	Person(name: &quot;Arthur&quot;).insert(database)<br>&gt; <br>&gt; So far, so good. How does look a user type that uses all those features?<br>&gt; <br>&gt; 	struct Person: RowConvertible, TableMapping, DatabasePersistable { … }<br>&gt; <br>&gt; That’s quite a long declaration, but it works.<br>&gt; <br>&gt; Enter another feature: changes tracking. Changes tracking requires remembering reference data in order to see what’s changed. Protocols don’t (yet) provide stored properties, so the library, today, has to expose a class for this purpose. That class is *abstract* since subclasses *have* to override the method that tells the table name.<br>&gt; <br>&gt; 	class Record: RowConvertible, TableMapping, DatabasePersistable { … }<br>&gt; <br>&gt; How does look a user type that provides the full toolkit (fetching + persistence + changes tracking) ?<br>&gt; <br>&gt; 	class Person: Record { … }<br>&gt; <br>&gt; Sweet! Can you see how the abstract Record class provides:<br>&gt; <br>&gt; 1. less mental overhead for the library user (a single type provides the full toolkit)<br>&gt; 2. Succinct user types declaration (you don’t have to learn about the three core protocols, just inherit from Record)<br>&gt; 3. features that protocols can’t provide (here, changes tracking)<br>&gt; <br>&gt; In conclusion: protocol-oriented programming is *more complex* than class-based programming. I think that it is important that the Swift ecosystem lets libraries expose simple entry points even though they provide a list of small and focused protocols that can be composed, because protocol composition requires more engagement from library users.<br>&gt; <br>&gt; In the example above, the Record class would benefit from being declared abstract, if the language would support such feature. BTW, that Record class exists: https://github.com/groue/GRDB.swift#database-protocols-and-record &lt;https://github.com/groue/GRDB.swift#database-protocols-and-record&gt;.<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/73a9a61a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  8, 2016 at 07:00:00am</p></header><div class="content"><p>Agreed, thanks for the example too. It was clear before, but this brings a huge +1 from me.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 8 Jan 2016, at 07:22, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 20:41, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; &gt; I am not sure that the language should discourage a feature it supports and impose friction on it because it could be abused.<br>&gt;&gt; <br>&gt;&gt; Especially since the OOP philosophy is falling out of fashion anyway. Thousands of CompSci profs, and programming blogs, all saying &quot;we&#39;ve come to our senses, OOP is confusing&quot;. Adding Abstract classes to Swift isn&#39;t going to turn that ship around.<br>&gt; <br>&gt; It’s not only about fashion, is it?<br>&gt; <br>&gt; Let’s take a practical example, and consider a Swift library that accesses a database. Its writer has jumped in the protocol-oriented wagon, and provides protocols that grants adopting types fetching and persistence methods:<br>&gt; <br>&gt; - RowConvertible: types that can be converted from a database row can be fetched:<br>&gt; <br>&gt; 	Person.fetch(database, &quot;SELECT …&quot;)<br>&gt; <br>&gt; - TableMapping: types that are linked to a database table. On top of RowConvertible, it grants fetching by primary key:<br>&gt; <br>&gt; 	Person.fetch(database, key: 12)<br>&gt; <br>&gt; - DatabasePersistable (inherits from TableMapping): types that can be saved in the database:<br>&gt; <br>&gt; 	Person(name: &quot;Arthur&quot;).insert(database)<br>&gt; <br>&gt; So far, so good. How does look a user type that uses all those features?<br>&gt; <br>&gt; 	struct Person: RowConvertible, TableMapping, DatabasePersistable { … }<br>&gt; <br>&gt; That’s quite a long declaration, but it works.<br>&gt; <br>&gt; Enter another feature: changes tracking. Changes tracking requires remembering reference data in order to see what’s changed. Protocols don’t (yet) provide stored properties, so the library, today, has to expose a class for this purpose. That class is *abstract* since subclasses *have* to override the method that tells the table name.<br>&gt; <br>&gt; 	class Record: RowConvertible, TableMapping, DatabasePersistable { … }<br>&gt; <br>&gt; How does look a user type that provides the full toolkit (fetching + persistence + changes tracking) ?<br>&gt; <br>&gt; 	class Person: Record { … }<br>&gt; <br>&gt; Sweet! Can you see how the abstract Record class provides:<br>&gt; <br>&gt; 1. less mental overhead for the library user (a single type provides the full toolkit)<br>&gt; 2. Succinct user types declaration (you don’t have to learn about the three core protocols, just inherit from Record)<br>&gt; 3. features that protocols can’t provide (here, changes tracking)<br>&gt; <br>&gt; In conclusion: protocol-oriented programming is *more complex* than class-based programming. I think that it is important that the Swift ecosystem lets libraries expose simple entry points even though they provide a list of small and focused protocols that can be composed, because protocol composition requires more engagement from library users.<br>&gt; <br>&gt; In the example above, the Record class would benefit from being declared abstract, if the language would support such feature. BTW, that Record class exists: https://github.com/groue/GRDB.swift#database-protocols-and-record.<br>&gt; <br>&gt; Gwendal<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/d338e43f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # Abstract classes and methods<br>&gt; <br>&gt; * Author(s): David Scrève<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt; they cannot have attributes as classes have.<br>&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt; in inherited class like protocols.<br></p><p>I tend to agree that adding abstract methods (and classes) is the right thing to do.  OOP is an important part of Swift, and is a great way for modeling certain classes of problems.<br></p><p>I wonder if we could simplify our initializer model if we had this, for example, could “required&quot; initializers go away?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January  9, 2016 at 10:00:00pm</p></header><div class="content"><p>I’m not sure that we should remove required initializers because they handle a different semantic : a required initializer has a default implementation whereas abstract initializer does not.	<br></p><p>But I agree that required keyword is less useful if we introduce the abstract concept and I admit I do not have any real use case of this.<br></p><p>I think this should be introduced in another proposal where we also might discuss about the extensibility of required keyword to any method in classes.<br></p><p>David<br></p><p><br>&gt; Le 9 janv. 2016 à 20:02, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # Abstract classes and methods<br>&gt;&gt; <br>&gt;&gt; * Author(s): David Scrève<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt; in inherited class like protocols.<br>&gt; <br>&gt; I tend to agree that adding abstract methods (and classes) is the right thing to do.  OOP is an important part of Swift, and is a great way for modeling certain classes of problems.<br>&gt; <br>&gt; I wonder if we could simplify our initializer model if we had this, for example, could “required&quot; initializers go away?<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/e2603a86/attachment.p7s&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 11:02 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:55 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # Abstract classes and methods<br>&gt;&gt; <br>&gt;&gt; * Author(s): David Scrève<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; When developing framework and reusable, we need to develop classes that are partially <br>&gt;&gt; abstract with partial implementation. Protocol and protocol extensions provide this, but <br>&gt;&gt; they cannot have attributes as classes have.<br>&gt;&gt; A partial class combines the behavior of a class with the requirement of implementing methods<br>&gt;&gt; in inherited class like protocols.<br>&gt; <br>&gt; I tend to agree that adding abstract methods (and classes) is the right thing to do.  OOP is an important part of Swift, and is a great way for modeling certain classes of problems.<br></p><p>I’m not nearly as convinced that it’s worth doing. It’s a small feature with a small win, and I tend to think that protocols are a better answer for most problems for which one would reflexively reach for an abstract class.<br></p><p>&gt; <br>&gt; I wonder if we could simplify our initializer model if we had this, for example, could “required&quot; initializers go away?<br></p><p><br>No, it doesn’t help with required, but the differences between “abstract” and “required” would be sure to cause confusion. “abstract” means “some class along the inheritance path below me must implement this”, whereas “required” means “every class along the inheritance path below me must implement this.&quot;<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 11, 2016 at 01:00:00am</p></header><div class="content"><p>Not if you can’t figure out how to write the protocol such that it doesn’t refer to Self, have typealiases, or do something else that means you can only use it as a generic constraint rather than an actual type.<br></p><p>&gt; On Jan 10, 2016, at 20:59, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not nearly as convinced that it’s worth doing. It’s a small feature with a small win, and I tend to think that protocols are a better answer for most problems for which one would reflexively reach for an abstract class.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draff] abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Not if you can’t figure out how to write the protocol such that it doesn’t refer to Self, have typealiases, or do something else that means you can only use it as a generic constraint rather than an actual type.<br></p><p>As abstract classes also cannot use Self the way protocols can or have associated types, I&#39;m not certain what an abstract class could express that an existential protocol couldn&#39;t.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
