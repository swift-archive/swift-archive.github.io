<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 29, 2016 at 03:00:00pm</p></header><div class="content"><p>When we introduced Swift, we wanted to provide value types for common containers, with the safety and state isolation benefits they provide, while still working well with the reference-oriented world of Cocoa. To that end, we invested a lot of work into bridging between Swift’s value semantics containers and their analogous Cocoa container classes. This bridging consisted of several pieces in the language, the compiler, and the runtime:<br></p><p>Importer bridging, importing Objective-C APIs that take and return NSString, NSArray, NSDictionary and NSSet so that they take and return Swift’s analogous value types instead.<br></p><p>Originally, the language allowed implicit conversions in both directions between Swift value types and their analogous classes. We’ve been working on phasing the implicit conversions out—we removed the object-to-value implicit conversion in Swift 1.2, and propose to remove the other direction in SE–0072—but the conversions can still be performed by an explicit coercion string as NSString. These required-explicit as coercions don’t otherwise exist in the language, since as generally is used to force coercions that can also happen implicitly, and value-preserving conversions are more idiomatically performed by constructors in the standard library.<br></p><p>The runtime supports dynamic bridging casts. If you have a value that’s dynamically of a Swift value type, and try to as?, as!, or is-cast it to its bridged Cocoa class type, the cast will succeed, and the runtime will apply the bridging conversion:<br></p><p>// An Any that dynamically contains a value &quot;foo&quot;: String<br>let x: Any = &quot;foo&quot;<br>// Cast succeeds and produces the bridged &quot;foo&quot;: NSString<br>let y = x as! NSString <br>Since Swift first came out, Cocoa has done a great job of “Swiftification”, aided by new Objective-C features like nullability and lightweight generics that have greatly improved the up-front quality of importer-bridged APIs. This has let us deemphasize and gradually remove the special case implicit conversions from the language. I think it’s time to consider extricating them from the dynamic type system as well, making it so that as?, as!, and is casts only concern themselves with typechecks, and transitioning to using standard initializers and methods for performing bridging conversions. I’d like to propose the following changes:<br></p><p>Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes.<br>Coercion syntax as should no longer be used to explicitly force certain bridging conversions.<br>To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations.<br>The Rules of as[?]<br></p><p>Our original goal implementing this behavior into the dynamic casting machinery was to preserve some transitivity identities between implicit conversions and casts that users could reason about, including:<br></p><p>x as! T as! U === x as! U, if x as! T succeeds. Casting to a type U should succeed and give the same result for any derived cast result.<br>x as! T as U === x as! U. If T is coercible to U, then you should get the same result by casting to Tand coercing to U as by casting to U directly.<br>x as T as! U === x as! U. Likewise, coercing shouldn’t affect the result of any ensuing dynamic casts.<br>x as T as U === x as U.<br>The interaction of these identities with the bridging conversions, as well as with other type system features like implicit nonoptional-to-Optional conversion, occasionally requires surprising behavior, for instance the behavior of nil Optional values in https://github.com/apple/swift/pull/1949. These rules also inform the otherwise-inconsistent use of as to perform explicit bridging conversions, when as normally only forces implicit conversions. By simplifying the scope of dynamic casts, it becomes easier to preserve these rules without bugs and unfortunate edge cases.<br></p><p>The Abilities of as? Today<br></p><p>In discussing how to change the behavior of dynamic casts, it’s worth enumerating all the things dynamic casts are currently able to do:<br></p><p>Check that an object is an instance of a specific class.<br></p><p>class Base {}; class Derived: Base {}<br></p><p>func isKindOfDerived(object: Base) -&gt; Bool {<br>  return object is Derived<br>}<br></p><p>isKindOfDerived(object: Derived()) // true<br>isKindOfDerived(object: Base()) // false<br>Check that an existential contains an instance of a type.<br></p><p>protocol P {}<br>extension Int: P {}<br>extension Double: P {}<br></p><p>func isKindOfInt(value: P) -&gt; Bool {<br>  return value is Int<br>}<br>isKindOfInt(value: 0) // true<br>isKindOfInt(value: 0.0) // false<br>Check that a generic value is also an instance of a different type.<br></p><p>func is&lt;T, U&gt;(value: T, kindOf: U.Type) -&gt; Bool {<br>  return value is U<br>}<br></p><p>is(value: Derived(), kindOf: Derived.self) // true<br>is(value: Derived(), kindOf: Base.self) // true<br>is(value: Base(), kindOf: Derived.self) // false<br>is(value: 0, kindOf: Int.self) // true<br>Check whether the type of a value conforms to a protocol, and wrap it in an existential if so:<br></p><p>protocol Fooable { func foo() }<br></p><p>func fooIfYouCanFoo&lt;T&gt;(value: T) {<br>  if let fooable = value as? Fooable {<br>    return fooable.foo()<br>  }<br>}<br></p><p>extension Int: Fooable { func foo() { print(&quot;foo!&quot;) } }<br></p><p>fooIfYouCanFoo(value: 1) // Prints &quot;foo!&quot;<br>fooIfYouCanFoo(value: &quot;bar&quot;) // No-op<br>Check whether a value is _ObjectiveCBridgeable to a class, or conversely, that an object is _ObjectiveCBridgeable to a value type, and perform the bridging conversion if so:<br></p><p>func getAsString&lt;T&gt;(value: T) -&gt; String? {<br>  return value as? String<br>}<br>func getAsNSString&lt;T&gt;(value: T) -&gt; NSString {<br>  return value as? NSString<br>}<br></p><p>getAsString(value: &quot;string&quot;) // produces &quot;string&quot;: String<br>getAsNSString(value: &quot;string&quot;) // produces &quot;string&quot;: NSString<br></p><p>let ns = NSString(&quot;nsstring&quot;)<br>getAsString(value: ns) // produces &quot;nsstring&quot;: String<br>getAsNSString(value: ns) // produces &quot;nsstring&quot;: NSString<br>Check whether a value conforms to ErrorProtocol, and bridge it to NSError if so:<br></p><p>enum CommandmentError { case Killed, Stole, GravenImage, CovetedOx }<br></p><p>func getAsNSError&lt;T&gt;(value: T) -&gt; NSError? {<br>  return value as? NSError<br>}<br></p><p>getAsNSError(CommandmentError.GravenImage) // produces bridged NSError<br>This is what enables the use of catch let x as NSError pattern matching to catch Swift errors as NSErrorobjects today.<br></p><p>Check whether an NSError object has a domain and code matching a type conforming to _ObjectiveCBridgeableErrorProtocol, and extracting the Swift error if so:<br></p><p>func getAsNSCocoaError(error: NSError) -&gt; NSCocoaError? {<br>  return error as? NSCocoaError<br>}<br></p><p>// Returns NSCocoaError.fileNoSuchFileError<br>getAsNSCocoaError(error: NSError(domain: NSCocoaErrorDomain,<br>                                 code: NSFileNoSuchFileError,<br>                                 userInfo: []))<br>Drill through Optionals. If an Optional contains some value, it is extracted, and the cast is attempted on the contained value; the cast fails if the source value is none and the result type is not optional:<br></p><p>var x: String? = &quot;optional string&quot;<br>getAsNSString(value: x) // produces &quot;optional string&quot;: NSString<br>x = nil<br>getAsNSString(value: x) // fails<br>If the result type is also Optional, a successful cast is wrapped as some value of the result Optional type. nil source values succeed and become nil values of the result Optional type:<br></p><p>func getAsOptionalNSString&lt;T&gt;(value: T) -&gt; NSString?? {<br>  return value as? NSString?<br>}<br></p><p>var x: String? = &quot;optional string&quot;<br>getAsOptionalNSString(value: x) // produces &quot;optional string&quot;: NSString?<br>x = nil<br>getAsOptionalNSString(value: x) // produces nil: NSString?<br>Perform covariant container element checks and conversions for Array, Dictionary, and Set.<br></p><p>There are roughly three categories of functionality intertwined here. (1) through (4) are straightforward dynamic type checks. ((4) is arguably a bit different from (1) through (3) in that protocol conformances are extrinsic to a type, whereas (1) through (3) check the intrinsic type only of the participating value.) (5) through (7) involve Cocoa bridging conversions. (8) and (9) reflect additional implicit conversions supported by the language at compile time into the runtime type system. Optional and covariant container conversions have also been criticized as occasionally surprising and inconsistent with the rest of the language. If we curtail these conversions in the compiler, we would also want to consider removing their special dynamic cast behavior too. For the purposes of this discussion, I’d like to focus on removing the bridging behavior, cases (5) through (7).<br></p><p>Replacements for Dynamic Cast Behavior<br></p><p>If we remove bridging behavior from dynamic casts, we still need to provide API for performing those conversions. I’d recommend introducing unlabeled initializers for these conversions, matching the conventions for other value-preserving conversions in the standard library:<br></p><p><br>extension String {<br>  init(_ ns: NSString)<br>}<br>extension NSString {<br>  init(_ value: String)<br>}<br>extension Array where Element: _ObjectiveCBridgeable {<br>  init(_ ns: NSArray&lt;Element._ObjectiveCType&gt;)<br>}<br>extension NSArray {<br>  init&lt;BridgedElement: _ObjectiveCBridgeable<br>       where BridgedElement._ObjectiveCType == Element&gt;(<br>    _ value: Array&lt;BridgedElement&gt;)<br>}<br>/* etc. */<br></p><p>NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br></p><p><br>extension NSError {<br>  init(_ swiftError: ErrorType)<br>}<br></p><p>It’s also useful to be able to conditionally bridge to a value type from AnyObject, especially when working with heterogeneous property lists from Cocoa. This could be handled using failable initializers:<br></p><p><br>extension String {<br>  init?(bridging: AnyObject)<br>}<br>extension Array {<br>  init?(bridging: AnyObject)<br>}<br>extension Dictionary {<br>  init?(bridging: AnyObject)<br>}<br>/* etc. */<br></p><p>(This can probably be factored into a protocol extension on _ObjectiveCBridgeable.) Similarly, one could add a failable initializer to ErrorProtocol for bridging NSErrors back to Swift error values:<br></p><p><br>extension ErrorType {<br>  init?(bridging: NSError)<br>}<br></p><p>If you want to get really reductionist, you can ask whether as? and related operations really need special syntax at all; they could in theory be fully expressed as global functions, or as extension methods on Any/AnyObject if we allowed such things. Regardless, I think we want type-checking dynamic casts to be clearly a different operation from these bridging conversions. This will lead to a cleaner, easier-to-understand model with less special-case magic behavior.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/afcf5258/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  2, 2016 at 02:00:00pm</p></header><div class="content"><p>On Apr 29, 2016, at 3:00 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I’d like to propose the following changes:<br>&gt; <br>&gt; Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes.<br>&gt; Coercion syntax as should no longer be used to explicitly force certain bridging conversions.<br>&gt; To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations.<br>+1.  I think that this will lead to a much cleaner and more predictable set of rules.  It will probably also define away a ton of bugs in the compiler and runtime.<br></p><p><br></p><p>&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt; <br></p><p>I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br> <br>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/2948d63e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt; <br>&gt; <br>&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br></p><p>Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/c238da64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 2:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt; <br>&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br></p><p>I’m not sure what you’re saying.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/f650375f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 4:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 2, 2016, at 2:48 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt; <br>&gt;&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br>&gt; <br>&gt; I’m not sure what you’re saying.<br>&gt; <br>&gt; -Chris<br></p><p>It&#39;s a message of support, riffing on the famous Serenity Prayer (https://en.wikipedia.org/wiki/Serenity_Prayer &lt;https://en.wikipedia.org/wiki/Serenity_Prayer&gt;), agreeing with you and saying that partial implementation of a good idea (limiting bridging conversions between value types and a subset of Cocoa classes) is to be preferred to a full implementation of an idea that requires extraordinary effort for one special case (NSError).<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/ba341c5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  3, 2016 at 12:00:00am</p></header><div class="content"><p>I got the reference, made me laugh :)<br></p><p>&gt; On 03 May 2016, at 00:21, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 4:15 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 2:48 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you’re saying.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; It&#39;s a message of support, riffing on the famous Serenity Prayer (https://en.wikipedia.org/wiki/Serenity_Prayer &lt;https://en.wikipedia.org/wiki/Serenity_Prayer&gt;), agreeing with you and saying that partial implementation of a good idea (limiting bridging conversions between value types and a subset of Cocoa classes) is to be preferred to a full implementation of an idea that requires extraordinary effort for one special case (NSError).<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/7e82f10d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 3:21 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 4:15 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 2:48 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you’re saying.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; It&#39;s a message of support, riffing on the famous Serenity Prayer (https://en.wikipedia.org/wiki/Serenity_Prayer &lt;https://en.wikipedia.org/wiki/Serenity_Prayer&gt;), agreeing with you and saying that partial implementation of a good idea (limiting bridging conversions between value types and a subset of Cocoa classes) is to be preferred to a full implementation of an idea that requires extraordinary effort for one special case (NSError).<br></p><p>Hah, ok, thanks.  I admit that I clicked the link and was disappointed that it wasn’t a firefly reference ;-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/5ecdb5cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 4:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt; <br>&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br>&gt; <br>&gt; -- E<br></p><p>Among the things that Billy Pilgrim could not change were the past, the present, and the future. Hopefully we have better luck, because the ErrorType to NSError bridging is currently a bit buggy.<br></p><p>Have a look at this code, and take a guess at what the results should be:<br></p><p>import Foundation<br></p><p>extension ErrorType {<br>	public func toNSError() -&gt; NSError {<br>		return self as NSError<br>	}<br>}<br></p><p>let error = NSError(domain: &quot;Foo&quot;, code: -1, userInfo: [NSLocalizedFailureReasonErrorKey : &quot;Something went wrong&quot;])<br></p><p>let ns = error.toNSError()<br></p><p>print(&quot;Type of error was \(error.dynamicType), type of ns is \(ns.dynamicType)&quot;)<br></p><p>print(&quot;error&#39;s user info: \(error.userInfo)&quot;)<br>print(&quot;ns user info: \(ns.userInfo)”)<br></p><p>--<br></p><p>The results are a bit surprising:<br></p><p>Type of error was NSError, type of ns is _SwiftNativeNSError<br>error&#39;s user info: [NSLocalizedFailureReason: Something went wrong]<br>ns user info: [:]<br></p><p>What happened was:<br></p><p>1. The toNSError() method showed up for our NSError, since NSError is presented to Swift as conforming to ErrorType. <br></p><p>2. However, due to a lack of dynamism, the code in the extension assumes that we have a Swift native error and *not* an NSError, so it goes ahead and wraps the NSError inside another NSError.<br></p><p>3. And since Swift doesn’t currently do anything to address the userInfo field, the userInfo that our error had gets chopped off.<br></p><p>Whoops.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/827ec0ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May  2, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 to this. `as` is a hairy beast.<br></p><p>On Mon, May 2, 2016 at 8:45 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On May 2, 2016, at 4:48 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; NSError bridging can also be extracted from the runtime, and the same<br>&gt; functionality exposed as a factory initializer on NSError:<br>&gt;<br>&gt; I think that this proposal is overall really great, but what does it do to<br>&gt; the “catch let x as NSError” pattern?  What is the replacement?  If the<br>&gt; result is ugly, we may have to subset out NSError out of this pass, and<br>&gt; handle it specifically with improvements to the error bridging story.<br>&gt;<br>&gt;<br>&gt; Grant me the serenity to accept the `NSError` I cannot change and<br>&gt; the courage to change the bridging conversions I should. Grant me the<br>&gt; wisdom to know the difference between a partial solution that offers a<br>&gt; cleaner more predictable interface set now and a full solution that cannot<br>&gt; be achieved in a reasonable timeframe.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; Among the things that Billy Pilgrim could not change were the past, the<br>&gt; present, and the future. Hopefully we have better luck, because the<br>&gt; ErrorType to NSError bridging is currently a bit buggy.<br>&gt;<br>&gt; Have a look at this code, and take a guess at what the results should be:<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; extension ErrorType {<br>&gt; public func toNSError() -&gt; NSError {<br>&gt; return self as NSError<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; let error = NSError(domain: &quot;Foo&quot;, code: -1, userInfo:<br>&gt; [NSLocalizedFailureReasonErrorKey : &quot;Something went wrong&quot;])<br>&gt;<br>&gt; let ns = error.toNSError()<br>&gt;<br>&gt; print(&quot;Type of error was \(error.dynamicType), type of ns is<br>&gt; \(ns.dynamicType)&quot;)<br>&gt;<br>&gt; print(&quot;error&#39;s user info: \(error.userInfo)&quot;)<br>&gt; print(&quot;ns user info: \(ns.userInfo)”)<br>&gt;<br>&gt; --<br>&gt;<br>&gt; The results are a bit surprising:<br>&gt;<br>&gt; Type of error was NSError, type of ns is _SwiftNativeNSError<br>&gt; error&#39;s user info: [NSLocalizedFailureReason: Something went wrong]<br>&gt; ns user info: [:]<br>&gt;<br>&gt; What happened was:<br>&gt;<br>&gt; 1. The toNSError() method showed up for our NSError, since NSError is<br>&gt; presented to Swift as conforming to ErrorType.<br>&gt;<br>&gt; 2. However, due to a lack of dynamism, the code in the extension assumes<br>&gt; that we have a Swift native error and *not* an NSError, so it goes ahead<br>&gt; and wraps the NSError inside another NSError.<br>&gt;<br>&gt; 3. And since Swift doesn’t currently do anything to address the userInfo<br>&gt; field, the userInfo that our error had gets chopped off.<br>&gt;<br>&gt; Whoops.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/e8c2a131/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 2, 2016, at 5:45 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 2, 2016, at 4:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt; <br>&gt;&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; <br>&gt; Among the things that Billy Pilgrim could not change were the past, the present, and the future. Hopefully we have better luck, because the ErrorType to NSError bridging is currently a bit buggy.<br>&gt; <br>&gt; Have a look at this code, and take a guess at what the results should be:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; extension ErrorType {<br>&gt; 	public func toNSError() -&gt; NSError {<br>&gt; 		return self as NSError<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; let error = NSError(domain: &quot;Foo&quot;, code: -1, userInfo: [NSLocalizedFailureReasonErrorKey : &quot;Something went wrong&quot;])<br>&gt; <br>&gt; let ns = error.toNSError()<br>&gt; <br>&gt; print(&quot;Type of error was \(error.dynamicType), type of ns is \(ns.dynamicType)&quot;)<br>&gt; <br>&gt; print(&quot;error&#39;s user info: \(error.userInfo)&quot;)<br>&gt; print(&quot;ns user info: \(ns.userInfo)”)<br>&gt; <br>&gt; --<br>&gt; <br>&gt; The results are a bit surprising:<br>&gt; <br>&gt; Type of error was NSError, type of ns is _SwiftNativeNSError<br>&gt; error&#39;s user info: [NSLocalizedFailureReason: Something went wrong]<br>&gt; ns user info: [:]<br>&gt; <br>&gt; What happened was:<br>&gt; <br>&gt; 1. The toNSError() method showed up for our NSError, since NSError is presented to Swift as conforming to ErrorType. <br>&gt; <br>&gt; 2. However, due to a lack of dynamism, the code in the extension assumes that we have a Swift native error and *not* an NSError, so it goes ahead and wraps the NSError inside another NSError.<br>&gt; <br>&gt; 3. And since Swift doesn’t currently do anything to address the userInfo field, the userInfo that our error had gets chopped off.<br>&gt; <br>&gt; Whoops.<br></p><p>This is a known bug, not intended behavior. The runtime rewraps NSErrors in a bridging _SwiftNativeNSError when it should just pass them through.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 11:03 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 2, 2016, at 5:45 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 4:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 3:45 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Grant me the serenity to accept the `NSError` I cannot change and the courage to change the bridging conversions I should. Grant me the wisdom to know the difference between a partial solution that offers a cleaner more predictable interface set now and a full solution that cannot be achieved in a reasonable timeframe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; Among the things that Billy Pilgrim could not change were the past, the present, and the future. Hopefully we have better luck, because the ErrorType to NSError bridging is currently a bit buggy.<br>&gt;&gt; <br>&gt;&gt; Have a look at this code, and take a guess at what the results should be:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; extension ErrorType {<br>&gt;&gt; 	public func toNSError() -&gt; NSError {<br>&gt;&gt; 		return self as NSError<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let error = NSError(domain: &quot;Foo&quot;, code: -1, userInfo: [NSLocalizedFailureReasonErrorKey : &quot;Something went wrong&quot;])<br>&gt;&gt; <br>&gt;&gt; let ns = error.toNSError()<br>&gt;&gt; <br>&gt;&gt; print(&quot;Type of error was \(error.dynamicType), type of ns is \(ns.dynamicType)&quot;)<br>&gt;&gt; <br>&gt;&gt; print(&quot;error&#39;s user info: \(error.userInfo)&quot;)<br>&gt;&gt; print(&quot;ns user info: \(ns.userInfo)”)<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; The results are a bit surprising:<br>&gt;&gt; <br>&gt;&gt; Type of error was NSError, type of ns is _SwiftNativeNSError<br>&gt;&gt; error&#39;s user info: [NSLocalizedFailureReason: Something went wrong]<br>&gt;&gt; ns user info: [:]<br>&gt;&gt; <br>&gt;&gt; What happened was:<br>&gt;&gt; <br>&gt;&gt; 1. The toNSError() method showed up for our NSError, since NSError is presented to Swift as conforming to ErrorType. <br>&gt;&gt; <br>&gt;&gt; 2. However, due to a lack of dynamism, the code in the extension assumes that we have a Swift native error and *not* an NSError, so it goes ahead and wraps the NSError inside another NSError.<br>&gt;&gt; <br>&gt;&gt; 3. And since Swift doesn’t currently do anything to address the userInfo field, the userInfo that our error had gets chopped off.<br>&gt;&gt; <br>&gt;&gt; Whoops.<br>&gt; <br>&gt; This is a known bug, not intended behavior. The runtime rewraps NSErrors in a bridging _SwiftNativeNSError when it should just pass them through.<br>&gt; <br>&gt; -Joe<br></p><p>Yes, but it might present an argument in favor of the pitch, since simplifying what “as” means would likely reduce the possibility for bugs like this to crop up.<br></p><p>The difficulty in working around it is also kind of telling. You’d expect to be able to just do this:<br></p><p>if let err = self as? NSError {<br>	return err<br>}<br></p><p>but of course the “as?” is going to invoke the bridging mechanism rather than what you wanted, which is just telling you what the thing is. Trying “if self is NSError” doesn’t work either, since the “is” check comes out to be always true due to the bridging mechanism. When I was playing around with this, the only way I could find to just do a plain old type-check without bridging something was to kludge around it using a mirror and unsafeBitCast:<br></p><p>extension ErrorType {<br>    public func toNSError() -&gt; NSError {<br>        // NOPE!!! -- for var mirror: Mirror? = Mirror(reflecting: self); mirror != nil; mirror = mirror?.superclassMirror() {<br>        <br>        var argh: Mirror? = Mirror(reflecting: self)<br>        <br>        while let mirror = argh {<br>            if mirror.subjectType == NSError.self {<br>                return unsafeBitCast(self, NSError.self)<br>            }<br>            <br>            argh = mirror.superclassMirror()<br>        }<br>        <br>        return self as NSError<br>    }<br>}<br></p><p>Now, isn’t that code beautiful? Truly a work of art.<br></p><p>Anyway, the point is that with a simpler type-checking system, we could avoid complications like this.<br></p><p>As an aside, I wonder if NSError could be bridged by doing something similar to how other core Foundation types like NSString and NSArray are bridged. How would it be if:<br></p><p>1. ErrorProtocol has public, non-underscored methods for domain, code, and userInfo, the last of these having a default implementation that just returns an empty dictionary.<br></p><p>2. NSError no longer conforms to ErrorProtocol.<br></p><p>3. A new private error value type is introduced that does conform to ErrorProtocol, probably called something like _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br></p><p>4. There is a subclass of NSError that wraps a native Swift error and forwards the domain, code, and userInfo properties. This already exists in _SwiftNativeNSError, except this would now forward userInfo as well.<br></p><p>5. Objective-C APIs that return NSError object present it as ErrorProtocol in the signature. If the NSError is a _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol, and the user can access its domain, code, and userInfo through the three methods in the protocol.<br></p><p>6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API; otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br></p><p>7. For manually bridging from one side to the other, NSError would get an initializer in an extension that would take a Swift error and result in a bridged error. It would also get a swiftNativeError() method that would return an ErrorProtocol.<br></p><p>On the downside, special casing is still needed in steps 5 and 6 to distinguish between wrapped and unwrapped errors. On the upside:<br></p><p>a) This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary.<br></p><p>b) The special casing would be mostly restricted to the special magic that the compiler inserts when crossing the boundary.<br></p><p>c) As NSError would no longer be an ErrorProtocol, shenanigans related to not knowing whether an ErrorProtocol was native or not, as in the above example, would never happen.<br></p><p>d) Since the is, as, as?, and as! operators would no longer be need to bridge NSErrors to native errors and back, the pitch here becomes viable, and these operators can be made to no longer act in often surprising and confusing ways.<br></p><p>e) The programmer would never have to deal with NSError objects again.<br></p><p>What think you?<br></p><p>Charles<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 2:45 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Apr 29, 2016, at 3:00 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’d like to propose the following changes:<br>&gt;&gt; <br>&gt;&gt; 	• Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes.<br>&gt;&gt; 	• Coercion syntax as should no longer be used to explicitly force certain bridging conversions.<br>&gt;&gt; 	• To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations.<br>&gt; +1.  I think that this will lead to a much cleaner and more predictable set of rules.  It will probably also define away a ton of bugs in the compiler and runtime.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt; <br>&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;  <br></p><p>If we remove the bridging magic and do nothing else, then the best you can do to catch any error and handle it as an NSError becomes a two-liner:<br></p><p>	do {<br>	  try something()<br>	} catch let error {<br>	  let nsError = NSError(error)<br>	  handle(nsError)<br>	}<br></p><p>That&#39;s definitely uglier, but just to play devil&#39;s advocate, this does have the benefit of making it much clearer that the &#39;catch&#39; is exhaustive. &#39;as&#39; patterns are usually refutable, and it&#39;s a weird exception that &#39;error as NSError&#39; is an exhaustive match (and we do have bugs where we get this wrong, especially inside closures when we haven&#39;t fully propagated contextual types yet).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 3:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 2:45 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 29, 2016, at 3:00 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I’d like to propose the following changes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes.<br>&gt;&gt;&gt; 	• Coercion syntax as should no longer be used to explicitly force certain bridging conversions.<br>&gt;&gt;&gt; 	• To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations.<br>&gt;&gt; +1.  I think that this will lead to a much cleaner and more predictable set of rules.  It will probably also define away a ton of bugs in the compiler and runtime.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt; <br>&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt; <br>&gt; <br>&gt; If we remove the bridging magic and do nothing else, then the best you can do to catch any error and handle it as an NSError becomes a two-liner:<br>&gt; <br>&gt; 	do {<br>&gt; 	  try something()<br>&gt; 	} catch let error {<br>&gt; 	  let nsError = NSError(error)<br>&gt; 	  handle(nsError)<br>&gt; 	}<br>&gt; <br>&gt; That&#39;s definitely uglier, but just to play devil&#39;s advocate, this does have the benefit of making it much clearer that the &#39;catch&#39; is exhaustive. &#39;as&#39; patterns are usually refutable, and it&#39;s a weird exception that &#39;error as NSError&#39; is an exhaustive match (and we do have bugs where we get this wrong, especially inside closures when we haven&#39;t fully propagated contextual types yet).<br></p><p>Right, that’s what I expected.  The problem here is that this is a super common pattern.  The solution to this is pretty straight-forward though: we should just make the most commonly used members of NSError be a protocol extension on ErrorProtocol (née ErrorType).  This would eliminate the most common reasons that people need this pattern.  Do you know of any issues with this, or are we merely a proposal away from making this happen?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 3:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 3:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 2:45 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 29, 2016, at 3:00 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I’d like to propose the following changes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	• Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes.<br>&gt;&gt;&gt;&gt; 	• Coercion syntax as should no longer be used to explicitly force certain bridging conversions.<br>&gt;&gt;&gt;&gt; 	• To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations.<br>&gt;&gt;&gt; +1.  I think that this will lead to a much cleaner and more predictable set of rules.  It will probably also define away a ton of bugs in the compiler and runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that this proposal is overall really great, but what does it do to the “catch let x as NSError” pattern?  What is the replacement?  If the result is ugly, we may have to subset out NSError out of this pass, and handle it specifically with improvements to the error bridging story.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If we remove the bridging magic and do nothing else, then the best you can do to catch any error and handle it as an NSError becomes a two-liner:<br>&gt;&gt; <br>&gt;&gt; 	do {<br>&gt;&gt; 	  try something()<br>&gt;&gt; 	} catch let error {<br>&gt;&gt; 	  let nsError = NSError(error)<br>&gt;&gt; 	  handle(nsError)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; That&#39;s definitely uglier, but just to play devil&#39;s advocate, this does have the benefit of making it much clearer that the &#39;catch&#39; is exhaustive. &#39;as&#39; patterns are usually refutable, and it&#39;s a weird exception that &#39;error as NSError&#39; is an exhaustive match (and we do have bugs where we get this wrong, especially inside closures when we haven&#39;t fully propagated contextual types yet).<br>&gt; <br>&gt; Right, that’s what I expected.  The problem here is that this is a super common pattern.  The solution to this is pretty straight-forward though: we should just make the most commonly used members of NSError be a protocol extension on ErrorProtocol (née ErrorType).  This would eliminate the most common reasons that people need this pattern.  Do you know of any issues with this, or are we merely a proposal away from making this happen?<br></p><p>I can&#39;t think of any problems that would block us from doing that today. It&#39;d be pretty easy to write an ErrorProtocol extension that just forwards NSError&#39;s interface via bridging, and I bet that&#39;d cover most use cases for &#39;as NSError&#39;:<br></p><p>extension ErrorProtocol {<br>  var domain: String { return NSError(self).domain }<br>  var code: Int { return NSError(self).code }<br>  var userInfo: [String: AnyObject] { return NSError(self).userInfo }<br>  /* etc. */<br>}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  2, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 5:53 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can&#39;t think of any problems that would block us from doing that today. It&#39;d be pretty easy to write an ErrorProtocol extension that just forwards NSError&#39;s interface via bridging, and I bet that&#39;d cover most use cases for &#39;as NSError&#39;:<br>&gt; <br>&gt; extension ErrorProtocol {<br>&gt;  var domain: String { return NSError(self).domain }<br>&gt;  var code: Int { return NSError(self).code }<br>&gt;  var userInfo: [String: AnyObject] { return NSError(self).userInfo }<br>&gt;  /* etc. */<br>&gt; }<br>&gt; <br>&gt; -Joe<br></p><p>This could be fantastic if it accompanied the addition to ErrorProtocol of an “userInfo” property (or even _userInfo, although I’d really prefer that all three of these be de-underscored) that NSError(self) would pick up on when doing the conversion. Otherwise, we’re just going to have to keep on using custom .toNSError() methods instead of the official way, so it won’t matter if the latter is “as NSError” or “NSError(foo)” or something else.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/ab78c9ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  3, 2016 at 02:00:00pm</p></header><div class="content"><p>Here’s another argument in favor of the pitch:<br></p><p>Take an array:<br></p><p>let array = [&quot;Foo&quot;, &quot;Bar”]<br></p><p>We can convert this to an NSArray via the bridge:<br></p><p>let nsArray = array as NSArray<br></p><p>We can also convert this to a CFArray:<br></p><p>let cfArray = array as CFArray<br></p><p>Now, let’s convert them back.<br></p><p>let nsUntypedArray = nsArray as Array<br>let cfUntypedArray = cfArray as Array<br></p><p>This works, but both arrays are now Array&lt;AnyObject&gt;, which probably isn’t what we want. Since Swift arrays care about type, and NS/CFArrays generally don’t, we’ll want to do a check when converting them back:<br></p><p>let nsToNativeArray = nsArray as? Array&lt;String&gt;<br>let cfToNativeArray = cfArray as? Array&lt;String&gt;<br></p><p>Checking the value of the first one there, we get a nice Optional([&quot;Foo&quot;, &quot;Bar”]), as expected. However, checking the second one reveals that it now contains *nil!* Worse, the bug won’t be discovered until runtime, and may be hard to track down, since the code above *looks* fine.<br></p><p>Adding an intermediate cast to NSArray, of course, makes it work fine:<br></p><p>let cfToNativeArray = cfArray as NSArray? as? Array&lt;String&gt; // Optional([&quot;Foo&quot;, &quot;Bar&quot;])<br></p><p>This may be a bug, maybe even a known one. However, if this had been done via initializers on Array rather than via bridging magic, the compiler would have thrown a type error when we tried to pass a CFArray to Array’s initializer if Array didn’t have an initializer that took a CFArray. The bridge, however, just cheerfully returns nil at runtime, leaving you with no idea something’s wrong until it all blows up mysteriously at runtime.<br></p><p>So basically, I guess I’m +1 on the pitch.<br></p><p>Charles<br></p><p>&gt; On Apr 29, 2016, at 5:00 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When we introduced Swift, we wanted to provide value types for common containers, with the safety and state isolation benefits they provide, while still working well with the reference-oriented world of Cocoa. To that end, we invested a lot of work into bridging between Swift’s value semantics containers and their analogous Cocoa container classes. This bridging consisted of several pieces in the language, the compiler, and the runtime:<br>&gt; <br>&gt; Importer bridging, importing Objective-C APIs that take and return NSString, NSArray, NSDictionary and NSSet so that they take and return Swift’s analogous value types instead.<br>&gt; <br>&gt; Originally, the language allowed implicit conversions in both directions between Swift value types and their analogous classes. We’ve been working on phasing the implicit conversions out—we removed the object-to-value implicit conversion in Swift 1.2, and propose to remove the other direction in SE–0072—but the conversions can still be performed by an explicit coercion string as NSString. These required-explicit as coercions don’t otherwise exist in the language, since as generally is used to force coercions that can also happen implicitly, and value-preserving conversions are more idiomatically performed by constructors in the standard library.<br>&gt; <br>&gt; The runtime supports dynamic bridging casts. If you have a value that’s dynamically of a Swift value type, and try to as?, as!, or is-cast it to its bridged Cocoa class type, the cast will succeed, and the runtime will apply the bridging conversion:<br>&gt; <br>&gt; // An Any that dynamically contains a value &quot;foo&quot;: String<br>&gt; let x: Any = &quot;foo&quot;<br>&gt; // Cast succeeds and produces the bridged &quot;foo&quot;: NSString<br>&gt; let y = x as! NSString <br>&gt; Since Swift first came out, Cocoa has done a great job of “Swiftification”, aided by new Objective-C features like nullability and lightweight generics that have greatly improved the up-front quality of importer-bridged APIs. This has let us deemphasize and gradually remove the special case implicit conversions from the language. I think it’s time to consider extricating them from the dynamic type system as well, making it so that as?, as!, and is casts only concern themselves with typechecks, and transitioning to using standard initializers and methods for performing bridging conversions. I’d like to propose the following changes:<br>&gt; <br>&gt; Dynamic casts as?, as! and is should no longer perform bridging conversions between value types and Cocoa classes.<br>&gt; Coercion syntax as should no longer be used to explicitly force certain bridging conversions.<br>&gt; To replace this functionality, we should add initializers to bridged value types and classes that perform the value-preserving bridging operations.<br>&gt; The Rules of as[?]<br>&gt; <br>&gt; Our original goal implementing this behavior into the dynamic casting machinery was to preserve some transitivity identities between implicit conversions and casts that users could reason about, including:<br>&gt; <br>&gt; x as! T as! U === x as! U, if x as! T succeeds. Casting to a type U should succeed and give the same result for any derived cast result.<br>&gt; x as! T as U === x as! U. If T is coercible to U, then you should get the same result by casting to Tand coercing to U as by casting to U directly.<br>&gt; x as T as! U === x as! U. Likewise, coercing shouldn’t affect the result of any ensuing dynamic casts.<br>&gt; x as T as U === x as U.<br>&gt; The interaction of these identities with the bridging conversions, as well as with other type system features like implicit nonoptional-to-Optional conversion, occasionally requires surprising behavior, for instance the behavior of nil Optional values in https://github.com/apple/swift/pull/1949 &lt;https://github.com/apple/swift/pull/1949&gt;. These rules also inform the otherwise-inconsistent use of as to perform explicit bridging conversions, when as normally only forces implicit conversions. By simplifying the scope of dynamic casts, it becomes easier to preserve these rules without bugs and unfortunate edge cases.<br>&gt; <br>&gt; The Abilities of as? Today<br>&gt; <br>&gt; In discussing how to change the behavior of dynamic casts, it’s worth enumerating all the things dynamic casts are currently able to do:<br>&gt; <br>&gt; Check that an object is an instance of a specific class.<br>&gt; <br>&gt; class Base {}; class Derived: Base {}<br>&gt; <br>&gt; func isKindOfDerived(object: Base) -&gt; Bool {<br>&gt;   return object is Derived<br>&gt; }<br>&gt; <br>&gt; isKindOfDerived(object: Derived()) // true<br>&gt; isKindOfDerived(object: Base()) // false<br>&gt; Check that an existential contains an instance of a type.<br>&gt; <br>&gt; protocol P {}<br>&gt; extension Int: P {}<br>&gt; extension Double: P {}<br>&gt; <br>&gt; func isKindOfInt(value: P) -&gt; Bool {<br>&gt;   return value is Int<br>&gt; }<br>&gt; isKindOfInt(value: 0) // true<br>&gt; isKindOfInt(value: 0.0) // false<br>&gt; Check that a generic value is also an instance of a different type.<br>&gt; <br>&gt; func is&lt;T, U&gt;(value: T, kindOf: U.Type) -&gt; Bool {<br>&gt;   return value is U<br>&gt; }<br>&gt; <br>&gt; is(value: Derived(), kindOf: Derived.self) // true<br>&gt; is(value: Derived(), kindOf: Base.self) // true<br>&gt; is(value: Base(), kindOf: Derived.self) // false<br>&gt; is(value: 0, kindOf: Int.self) // true<br>&gt; Check whether the type of a value conforms to a protocol, and wrap it in an existential if so:<br>&gt; <br>&gt; protocol Fooable { func foo() }<br>&gt; <br>&gt; func fooIfYouCanFoo&lt;T&gt;(value: T) {<br>&gt;   if let fooable = value as? Fooable {<br>&gt;     return fooable.foo()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension Int: Fooable { func foo() { print(&quot;foo!&quot;) } }<br>&gt; <br>&gt; fooIfYouCanFoo(value: 1) // Prints &quot;foo!&quot;<br>&gt; fooIfYouCanFoo(value: &quot;bar&quot;) // No-op<br>&gt; Check whether a value is _ObjectiveCBridgeable to a class, or conversely, that an object is _ObjectiveCBridgeable to a value type, and perform the bridging conversion if so:<br>&gt; <br>&gt; func getAsString&lt;T&gt;(value: T) -&gt; String? {<br>&gt;   return value as? String<br>&gt; }<br>&gt; func getAsNSString&lt;T&gt;(value: T) -&gt; NSString {<br>&gt;   return value as? NSString<br>&gt; }<br>&gt; <br>&gt; getAsString(value: &quot;string&quot;) // produces &quot;string&quot;: String<br>&gt; getAsNSString(value: &quot;string&quot;) // produces &quot;string&quot;: NSString<br>&gt; <br>&gt; let ns = NSString(&quot;nsstring&quot;)<br>&gt; getAsString(value: ns) // produces &quot;nsstring&quot;: String<br>&gt; getAsNSString(value: ns) // produces &quot;nsstring&quot;: NSString<br>&gt; Check whether a value conforms to ErrorProtocol, and bridge it to NSError if so:<br>&gt; <br>&gt; enum CommandmentError { case Killed, Stole, GravenImage, CovetedOx }<br>&gt; <br>&gt; func getAsNSError&lt;T&gt;(value: T) -&gt; NSError? {<br>&gt;   return value as? NSError<br>&gt; }<br>&gt; <br>&gt; getAsNSError(CommandmentError.GravenImage) // produces bridged NSError<br>&gt; This is what enables the use of catch let x as NSError pattern matching to catch Swift errors as NSErrorobjects today.<br>&gt; <br>&gt; Check whether an NSError object has a domain and code matching a type conforming to _ObjectiveCBridgeableErrorProtocol, and extracting the Swift error if so:<br>&gt; <br>&gt; func getAsNSCocoaError(error: NSError) -&gt; NSCocoaError? {<br>&gt;   return error as? NSCocoaError<br>&gt; }<br>&gt; <br>&gt; // Returns NSCocoaError.fileNoSuchFileError<br>&gt; getAsNSCocoaError(error: NSError(domain: NSCocoaErrorDomain,<br>&gt;                                  code: NSFileNoSuchFileError,<br>&gt;                                  userInfo: []))<br>&gt; Drill through Optionals. If an Optional contains some value, it is extracted, and the cast is attempted on the contained value; the cast fails if the source value is none and the result type is not optional:<br>&gt; <br>&gt; var x: String? = &quot;optional string&quot;<br>&gt; getAsNSString(value: x) // produces &quot;optional string&quot;: NSString<br>&gt; x = nil<br>&gt; getAsNSString(value: x) // fails<br>&gt; If the result type is also Optional, a successful cast is wrapped as some value of the result Optional type. nil source values succeed and become nil values of the result Optional type:<br>&gt; <br>&gt; func getAsOptionalNSString&lt;T&gt;(value: T) -&gt; NSString?? {<br>&gt;   return value as? NSString?<br>&gt; }<br>&gt; <br>&gt; var x: String? = &quot;optional string&quot;<br>&gt; getAsOptionalNSString(value: x) // produces &quot;optional string&quot;: NSString?<br>&gt; x = nil<br>&gt; getAsOptionalNSString(value: x) // produces nil: NSString?<br>&gt; Perform covariant container element checks and conversions for Array, Dictionary, and Set.<br>&gt; <br>&gt; There are roughly three categories of functionality intertwined here. (1) through (4) are straightforward dynamic type checks. ((4) is arguably a bit different from (1) through (3) in that protocol conformances are extrinsic to a type, whereas (1) through (3) check the intrinsic type only of the participating value.) (5) through (7) involve Cocoa bridging conversions. (8) and (9) reflect additional implicit conversions supported by the language at compile time into the runtime type system. Optional and covariant container conversions have also been criticized as occasionally surprising and inconsistent with the rest of the language. If we curtail these conversions in the compiler, we would also want to consider removing their special dynamic cast behavior too. For the purposes of this discussion, I’d like to focus on removing the bridging behavior, cases (5) through (7).<br>&gt; <br>&gt; Replacements for Dynamic Cast Behavior<br>&gt; <br>&gt; If we remove bridging behavior from dynamic casts, we still need to provide API for performing those conversions. I’d recommend introducing unlabeled initializers for these conversions, matching the conventions for other value-preserving conversions in the standard library:<br>&gt; <br>&gt; <br>&gt; extension String {<br>&gt;   init(_ ns: NSString)<br>&gt; }<br>&gt; extension NSString {<br>&gt;   init(_ value: String)<br>&gt; }<br>&gt; extension Array where Element: _ObjectiveCBridgeable {<br>&gt;   init(_ ns: NSArray&lt;Element._ObjectiveCType&gt;)<br>&gt; }<br>&gt; extension NSArray {<br>&gt;   init&lt;BridgedElement: _ObjectiveCBridgeable<br>&gt;        where BridgedElement._ObjectiveCType == Element&gt;(<br>&gt;     _ value: Array&lt;BridgedElement&gt;)<br>&gt; }<br>&gt; /* etc. */<br>&gt; <br>&gt; NSError bridging can also be extracted from the runtime, and the same functionality exposed as a factory initializer on NSError:<br>&gt; <br>&gt; <br>&gt; extension NSError {<br>&gt;   init(_ swiftError: ErrorType)<br>&gt; }<br>&gt; <br>&gt; It’s also useful to be able to conditionally bridge to a value type from AnyObject, especially when working with heterogeneous property lists from Cocoa. This could be handled using failable initializers:<br>&gt; <br>&gt; <br>&gt; extension String {<br>&gt;   init?(bridging: AnyObject)<br>&gt; }<br>&gt; extension Array {<br>&gt;   init?(bridging: AnyObject)<br>&gt; }<br>&gt; extension Dictionary {<br>&gt;   init?(bridging: AnyObject)<br>&gt; }<br>&gt; /* etc. */<br>&gt; <br>&gt; (This can probably be factored into a protocol extension on _ObjectiveCBridgeable.) Similarly, one could add a failable initializer to ErrorProtocol for bridging NSErrors back to Swift error values:<br>&gt; <br>&gt; <br>&gt; extension ErrorType {<br>&gt;   init?(bridging: NSError)<br>&gt; }<br>&gt; <br>&gt; If you want to get really reductionist, you can ask whether as? and related operations really need special syntax at all; they could in theory be fully expressed as global functions, or as extension methods on Any/AnyObject if we allowed such things. Regardless, I think we want type-checking dynamic casts to be clearly a different operation from these bridging conversions. This will lead to a cleaner, easier-to-understand model with less special-case magic behavior.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/25134c24/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Thanks everyone for the initial round of feedback. I&#39;ve submitted a draft proposal:<br></p><p>https://github.com/apple/swift-evolution/pull/289<br>https://github.com/jckarter/swift-evolution/blob/remove-bridging-conversion-dynamic-casts/proposals/XXXX-remove-bridging-from-dynamic-casts.md<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May  6, 2016 at 09:00:00am</p></header><div class="content"><p>Definitely a welcome change from me (+1). But this proposal makes me curious about the impact on the `AnyObject` protocol?<br></p><p>let string = &quot;foo&quot;<br>let nsString = string as AnyObject<br>nsString.dynamicType // _NSCFConstantString.Type<br>NSString().dynamicType // __NSCFConstantString.Type // there are two different types? <br></p><p>This sample won’t bridge anymore if SE-0083 will be accepted. Can we also drop the @objc from `AnyObject` protocol and leave it as an implicit protocol for classes? (Personally I’d rename `AnyObject` to `AnyReference` if Swift will introduce other reference types.)<br></p><p>This change might allow the replacement of the `class` keyword from protocols with the implicit `AnyObject` protocol, which can be discussed in this thread: Should we rename &quot;class&quot; when referring to	protocol conformance?<br></p><p>One more thing I’d like to ask: is there any possibility of adding a new `bridge` keyword, which would allow explicit bridging to a different language type (ObjC, etc. if there are any more languages we can bridge to [C or maybe one day C++])?<br></p><p>T `bridge` U<br>T? `bridge` U?<br></p><p>Wouldn’t this move the bridging mechanism to its own area?<br></p><p>The ugly NSError pattern could be rewritten and migrated to:<br></p><p>do {<br>   try something()<br>} catch let error {<br>   handle(error `bridge` NSError)<br>}<br></p><p>Is such a change complicated, what do you think?<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 4. Mai 2016 bei 01:50:54, Joe Groff via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Thanks everyone for the initial round of feedback. I&#39;ve submitted a draft proposal:<br></p><p>https://github.com/apple/swift-evolution/pull/289<br>https://github.com/jckarter/swift-evolution/blob/remove-bridging-conversion-dynamic-casts/proposals/XXXX-remove-bridging-from-dynamic-casts.md<br></p><p>-Joe<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/cfb015a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 12:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Definitely a welcome change from me (+1). But this proposal makes me curious about the impact on the `AnyObject` protocol?<br>&gt; <br>&gt; let string = &quot;foo&quot;<br>&gt; let nsString = string as AnyObject<br>&gt; nsString.dynamicType // _NSCFConstantString.Type<br>&gt; NSString().dynamicType // __NSCFConstantString.Type // there are two different types? <br>&gt; <br>&gt; This sample won’t bridge anymore if SE-0083 will be accepted.<br></p><p>Right, you&#39;d need to do NSString(string) as AnyObject to explicitly bridge.<br></p><p>&gt; Can we also drop the @objc from `AnyObject` protocol and leave it as an implicit protocol for classes? (Personally I’d rename `AnyObject` to `AnyReference` if Swift will introduce other reference types.)<br></p><p>The @objc-ness of AnyObject is more or less an implementation detail. On Darwin platforms at least, AnyObject still has the magic ability to dispatch to all @objc methods, similar to `id` in Objective-C, which vaguely defends its @objc-ness. (If we&#39;re going to rename it, my own preference would be to drop the Any and just call it `Object`, since we don&#39;t put Any in any other protocol names.)<br></p><p>&gt; This change might allow the replacement of the `class` keyword from protocols with the implicit `AnyObject` protocol, which can be discussed in this thread: Should we rename &quot;class&quot; when referring to	protocol conformance?<br>&gt; <br>&gt; One more thing I’d like to ask: is there any possibility of adding a new `bridge` keyword, which would allow explicit bridging to a different language type (ObjC, etc. if there are any more languages we can bridge to [C or maybe one day C++])?<br>&gt; <br>&gt; T `bridge` U<br>&gt; T? `bridge` U?<br></p><p>One could write `bridge` as a method in most cases; it doesn&#39;t need to be a keyword with special syntax, since you could write `T.bridge(U.self)` (or, if we accept https://github.com/apple/swift-evolution/pull/299, `T.bridge(U)`). Idiomatically, though, we generally use initializers for value-preserving conversions, so U(T) would be more consistent with the rest of the standard library.<br></p><p>-Joe<br></p><p>&gt; The ugly NSError pattern could be rewritten and migrated to:<br>&gt; <br>&gt; do {<br>&gt;    try something()<br>&gt; } catch let error {<br>&gt;    handle(error `bridge` NSError)<br>&gt; }<br>&gt; <br>&gt; Is such a change complicated, what do you think?<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 4. Mai 2016 bei 01:50:54, Joe Groff via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; Thanks everyone for the initial round of feedback. I&#39;ve submitted a draft proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/289<br>&gt;&gt; https://github.com/jckarter/swift-evolution/blob/remove-bridging-conversion-dynamic-casts/proposals/XXXX-remove-bridging-from-dynamic-casts.md<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May  9, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Right, you&#39;d need to do NSString(string) as AnyObject to explicitly bridge.  <br></p><p>Okay great I&#39;m fine with that. :)  <br></p><p>&gt; The @objc-ness of AnyObject is more or less an implementation detail. On Darwin platforms at least, AnyObject still has the magic ability to dispatch to all @objc methods, similar to `id` in Objective-C, which vaguely defends its @objc-ness. (If we&#39;re going to rename it, my own preference would be to drop the Any and just call it `Object`, since we don&#39;t put Any in any other protocol names.)  <br></p><p>Did I miss something again? I checked SR-0006 and it still has protocols like `Any`, `AnyIterator` or `AnyCollectionProtocol`.  <br>--  <br>Adrian Zubarev  <br></p><p>Am 9. Mai 2016 um 21:38:22, Joe Groff (jgroff at apple.com(mailto:jgroff at apple.com)) schrieb:<br></p><p>&gt;  <br>&gt;  <br>&gt; &gt; On May 6, 2016, at 12:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;  <br>&gt; &gt; Definitely a welcome change from me (+1). But this proposal makes me curious about the impact on the `AnyObject` protocol?<br>&gt; &gt;  <br>&gt; &gt; let string = &quot;foo&quot;<br>&gt; &gt; let nsString = string as AnyObject<br>&gt; &gt; nsString.dynamicType // _NSCFConstantString.Type<br>&gt; &gt; NSString().dynamicType // __NSCFConstantString.Type // there are two different types?<br>&gt; &gt;  <br>&gt; &gt; This sample won’t bridge anymore if SE-0083 will be accepted.<br>&gt;  <br>&gt; Right, you&#39;d need to do NSString(string) as AnyObject to explicitly bridge.<br>&gt;  <br>&gt; &gt; Can we also drop the @objc from `AnyObject` protocol and leave it as an implicit protocol for classes? (Personally I’d rename `AnyObject` to `AnyReference` if Swift will introduce other reference types.)<br>&gt;  <br>&gt; The @objc-ness of AnyObject is more or less an implementation detail. On Darwin platforms at least, AnyObject still has the magic ability to dispatch to all @objc methods, similar to `id` in Objective-C, which vaguely defends its @objc-ness. (If we&#39;re going to rename it, my own preference would be to drop the Any and just call it `Object`, since we don&#39;t put Any in any other protocol names.)<br>&gt;  <br>&gt; &gt; This change might allow the replacement of the `class` keyword from protocols with the implicit `AnyObject` protocol, which can be discussed in this thread: Should we rename &quot;class&quot; when referring to protocol conformance?<br>&gt; &gt;  <br>&gt; &gt; One more thing I’d like to ask: is there any possibility of adding a new `bridge` keyword, which would allow explicit bridging to a different language type (ObjC, etc. if there are any more languages we can bridge to [C or maybe one day C++])?<br>&gt; &gt;  <br>&gt; &gt; T `bridge` U<br>&gt; &gt; T? `bridge` U?<br>&gt;  <br>&gt; One could write `bridge` as a method in most cases; it doesn&#39;t need to be a keyword with special syntax, since you could write `T.bridge(U.self)` (or, if we accept https://github.com/apple/swift-evolution/pull/299, `T.bridge(U)`). Idiomatically, though, we generally use initializers for value-preserving conversions, so U(T) would be more consistent with the rest of the standard library.<br>&gt;  <br>&gt; -Joe<br>&gt;  <br>&gt; &gt; The ugly NSError pattern could be rewritten and migrated to:<br>&gt; &gt;  <br>&gt; &gt; do {<br>&gt; &gt; try something()<br>&gt; &gt; } catch let error {<br>&gt; &gt; handle(error `bridge` NSError)<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; Is such a change complicated, what do you think?<br>&gt; &gt;  <br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt;  <br>&gt; &gt; Am 4. Mai 2016 bei 01:50:54, Joe Groff via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; &gt;  <br>&gt; &gt; &gt; Thanks everyone for the initial round of feedback. I&#39;ve submitted a draft proposal:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; https://github.com/apple/swift-evolution/pull/289<br>&gt; &gt; &gt; https://github.com/jckarter/swift-evolution/blob/remove-bridging-conversion-dynamic-casts/proposals/XXXX-remove-bridging-from-dynamic-casts.md<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; -Joe<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/fe48faaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 2:28 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Right, you&#39;d need to do NSString(string) as AnyObject to explicitly bridge. <br>&gt; <br>&gt; Okay great I&#39;m fine with that. :)<br>&gt; <br>&gt;&gt; The @objc-ness of AnyObject is more or less an implementation detail. On Darwin platforms at least, AnyObject still has the magic ability to dispatch to all @objc methods, similar to `id` in Objective-C, which vaguely defends its @objc-ness. (If we&#39;re going to rename it, my own preference would be to drop the Any and just call it `Object`, since we don&#39;t put Any in any other protocol names.) <br>&gt; <br>&gt; Did I miss something again? I checked SR-0006 and it still has protocols like `Any`, `AnyIterator` or `AnyCollectionProtocol`.<br></p><p>&quot;Any&quot; is a typealias for the protocol type without any protocol requirements, which is natively spelled &quot;protocol&lt;&gt;&quot;. &quot;AnyIterator&quot; and &quot;AnyCollection&quot; are both wrapper types for holding a value that conforms to the Iterator or Collection protocol; they aren&#39;t protocols themselves.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 2:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The ugly NSError pattern could be rewritten and migrated to:<br>&gt; <br>&gt; do {<br>&gt;    try something()<br>&gt; } catch let error {<br>&gt;    handle(error `bridge` NSError)<br>&gt; }<br>&gt; <br>&gt; Is such a change complicated, what do you think?<br></p><p>I’ve made a pitch, &quot;Consistent bridging for NSErrors at the language boundary”, which I believe would not only eliminate the need for “as” to contain bridging magic, but is also much less ugly than either the current pattern or the example above.<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016618.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016618.html&gt;<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/0387b010/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>May  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Joe, <br></p><p>Would I still be able to cast an AnyObject to a String or Array etc?<br></p><p>I am thinking about working with JSON files and using the Apple JSON Parser. <br></p><p>Thanks<br></p><p><br></p><p>&gt; On May 3, 2016, at 4:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the initial round of feedback. I&#39;ve submitted a draft proposal:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/289<br>&gt; https://github.com/jckarter/swift-evolution/blob/remove-bridging-conversion-dynamic-casts/proposals/XXXX-remove-bridging-from-dynamic-casts.md<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Reducing the bridging magic in dynamic casts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 6, 2016, at 7:24 PM, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt; <br>&gt; Hi Joe, <br>&gt; <br>&gt; Would I still be able to cast an AnyObject to a String or Array etc?<br></p><p>You would do so via constructors rather than using `as?`, something like String(bridging: object).<br></p><p>-Joe<br></p><p>&gt; I am thinking about working with JSON files and using the Apple JSON Parser. <br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 4:50 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks everyone for the initial round of feedback. I&#39;ve submitted a draft proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/289<br>&gt;&gt; https://github.com/jckarter/swift-evolution/blob/remove-bridging-conversion-dynamic-casts/proposals/XXXX-remove-bridging-from-dynamic-casts.md<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
