<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  8, 2016 at 10:00:00pm</p></header><div class="content"><p>==Motivation==<br></p><p>protocol From {<br>    associatedtype FromType<br>    init(_ value: FromType)<br>}<br></p><p>The problem is, one type cannot implement multiple From &quot;conversions&quot;.<br></p><p>==Proposed solution==<br></p><p>Allow specifying all associated types using generic syntax.<br></p><p>extension Int : From&lt;Float&gt; { }<br>extension Int : From&lt;Double&gt; { }<br></p><p>This is only allowed in conformance declarations.<br></p><p>==Future directions==<br></p><p>We can replace all *Convertible protocols with From and Into, which will be<br>defined similarly to Rust.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/ff35e595/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>Associated types aren&#39;t generic parameters; the whole point is that they&#39;re requirements, just like the other declarations in a protocol.<br></p><p>You might be trying to invent generic protocols instead, which (IIRC) aren&#39;t inherently a bad thing. But I think this needs a lot more fleshing out before it can really be discussed—it&#39;s hard to know how you can and can&#39;t use these things, and how they might be implemented.<br></p><p>Best,<br>Jordan<br></p><p><br>&gt; On Jun 8, 2016, at 12:07, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ==Motivation==<br>&gt; <br>&gt; protocol From {<br>&gt;     associatedtype FromType<br>&gt;     init(_ value: FromType)<br>&gt; }<br>&gt; <br>&gt; The problem is, one type cannot implement multiple From &quot;conversions&quot;.<br>&gt; <br>&gt; ==Proposed solution==<br>&gt; <br>&gt; Allow specifying all associated types using generic syntax.<br>&gt; <br>&gt; extension Int : From&lt;Float&gt; { }<br>&gt; extension Int : From&lt;Double&gt; { }<br>&gt; <br>&gt; This is only allowed in conformance declarations.<br>&gt; <br>&gt; ==Future directions==<br>&gt; <br>&gt; We can replace all *Convertible protocols with From and Into, which will be defined similarly to Rust.<br>&gt; <br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>FWIW they&#39;re marked as &#39;unlikely&#39; here:<br>https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br></p><p>It would probably be useful to have counterarguments against the points<br>raised in that document if you want to prepare a proposal.<br></p><p>Austin<br></p><p>On Wed, Jun 8, 2016 at 2:32 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Associated types aren&#39;t generic parameters; the whole point is that<br>&gt; they&#39;re requirements, just like the other declarations in a protocol.<br>&gt;<br>&gt; You might be trying to invent generic protocols instead, which (IIRC)<br>&gt; aren&#39;t inherently a bad thing. But I think this needs a lot more fleshing<br>&gt; out before it can really be discussed—it&#39;s hard to know how you can and<br>&gt; can&#39;t use these things, and how they might be implemented.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 8, 2016, at 12:07, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; ==Motivation==<br>&gt; &gt;<br>&gt; &gt; protocol From {<br>&gt; &gt;     associatedtype FromType<br>&gt; &gt;     init(_ value: FromType)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; The problem is, one type cannot implement multiple From &quot;conversions&quot;.<br>&gt; &gt;<br>&gt; &gt; ==Proposed solution==<br>&gt; &gt;<br>&gt; &gt; Allow specifying all associated types using generic syntax.<br>&gt; &gt;<br>&gt; &gt; extension Int : From&lt;Float&gt; { }<br>&gt; &gt; extension Int : From&lt;Double&gt; { }<br>&gt; &gt;<br>&gt; &gt; This is only allowed in conformance declarations.<br>&gt; &gt;<br>&gt; &gt; ==Future directions==<br>&gt; &gt;<br>&gt; &gt; We can replace all *Convertible protocols with From and Into, which will<br>&gt; be defined similarly to Rust.<br>&gt; &gt;<br>&gt; &gt; - Anton<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/110a6ce0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 10, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; FWIW they&#39;re marked as &#39;unlikely&#39; here: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br>&gt; <br>&gt; It would probably be useful to have counterarguments against the points raised in that document if you want to prepare a proposal.<br></p><p>Here&#39;s my counterargument.<br></p><p>	* * *<br></p><p>Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic protocols (real generic protocols, not Sequence&lt;Element&gt;) are already needed to make several existing or likely future features work better. For instance:<br></p><p>* Pattern matching<br></p><p>Currently, if you want to customize your type&#39;s behavior in a `switch` statement, you do it in an ad hoc, almost Objective-C-like way: You define a free `~=` operator and the compiler resolves the overloads to magically find and use it. There is no way to constrain a generic parameter to &quot;only types that can pattern match against type X&quot;, which seems like a pretty useful thing to offer. For instance, in the past people have suggested some sort of expression-based switch alternative. The lack of a pattern matching protocol makes this impossible to implement in either the standard library or your own code.<br></p><p>If we had generic protocols, we could define a protocol for this matching operator and fix the issue:<br></p><p>	protocol Matchable&lt;MatchingValue&gt; {<br>		func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>	}<br>	<br>	protocol Equatable: Matchable&lt;Self&gt; {<br>		func == (lhs: Self, rhs: Self) -&gt; Bool<br>	}<br>	func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>		return lhs == rhs<br>	}<br>	<br>	extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>	func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>		return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>	}<br></p><p>Then you could write, for instance, a PatternDictionary which took patterns instead of keys and, when subscripted, matched the key against each pattern until it found a matching one, then returned the corresponding value.<br></p><p>* String interpolation<br></p><p>Currently, StringInterpolationConvertible only offers an `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you absolutely *must* permit any type to be interpolated into your type&#39;s string literals. This blocks certain important use cases, like a `LocalizedString` type which requires all strings it interacts with to pass through a localization API, from being statically checked. It also would normally require any type-specific behavior to be performed through runtime tests, but just as in `~=`, the Swift compiler applies compile-time magic to escape this restriction—you can write an `init(stringInterpolationSegment:)` with a concrete type, and that will be preferred over the generic one.<br></p><p>In theory, it should be possible in current Swift to redefine StringInterpolationConvertible to allow you to restrict the interpolatable values by doing something like this:<br></p><p>	protocol StringInterpolationConvertible {<br>		associatedtype Interpolatable = Any<br>		init(stringInterpolation: Self...)<br>		init(stringInterpolationSegment expr: Interpolatable)<br>	}<br></p><p>(This is no longer generic because I believe Interpolatable would have to be somehow constrained to only protocol types to make that work. But you get the idea.)<br></p><p>However, in many uses, developers will want to support interpolation of many custom types which do not share a common supertype. For instance, LocalizedString might want to support interpolation of any LocalizedString, Date, Integer, or FloatingPoint number. However, since Integer and FloatingPoint are protocols, you cannot use an extension to make them retroactively conform to a common protocol with LocalizedString. <br></p><p>With generic protocols, we could define StringInterpolationConvertible like this:<br></p><p>	protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>		init(stringInterpolation: Self...)<br>		init(stringInterpolationSegment expr: Interpolatable)<br>	}<br></p><p>And then say:<br></p><p>	extension LocalizedString: StringInterpolationConvertible&lt;LocalizedString&gt;, StringInterpolationConvertible&lt;Integer&gt;, StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>		init(stringInterpolationSegment expr: LocalizedString) {<br>			self.init()<br>			self.components = expr.components<br>		}<br>		init(stringInterpolationSegment expr: Integer) {<br>			self.init()<br>			self.components.append(.integer(expr))<br>		}<br>		init(stringInterpolationSegment expr: FloatingPoint) {<br>			self.components.append(.floatingPoint(expr))<br>		}<br>		init(stringInterpolation strings: LocalizedString...) {<br>			self.init()<br>			self.components = strings.map { $0.components }.reduce([], combine: +)<br>		}<br>	}<br></p><p>This example shows an interesting wrinkle: A generic protocol may have requirements which don&#39;t use any of the generic types, so that each of the multiple conformances will require members with identical signatures. When this happens, Swift must only allow the member to be implemented once, with that implementation being shared among all conformances.<br></p><p>* Subtype-supertype relationships<br></p><p>Though not currently implemented, there are long-term plans to permit at least value types to form subtype-supertype relationships with each other. A protocol would be a sensible way to express this behavior:<br></p><p>	protocol Upcastable {<br>		associatedtype Supertype<br>		<br>		init?(attemptingCastFrom value: Supertype)<br>		func casting() -&gt; Supertype<br>	}<br></p><p>However, this would require a type to have only one supertype, which isn&#39;t necessarily appropriate. For instance, we might want a UInt8 to be a subtype of both Int16 and UInt16. For that to work, Upcastable would have to be generic:<br></p><p>	protocol Upcastable&lt;Supertype&gt; {<br>		init?(attemptingCastFrom value: Supertype)<br>		func casting() -&gt; Supertype<br>	}<br>	<br>	extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br></p><p>Without generic protocols, the only way to offer sufficiently flexible subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br></p><p>	* * *<br></p><p>Secondly, I think the concerns about people trying to use Sequence as a generic protocol aren&#39;t that big a deal. To put it simply: Sequence is *not* a generic protocol. The Swift team controls the definition of Sequence, and we define it to not be generic. If people complain, we explain that generic protocols don&#39;t actually do the right thing for this and that they should use existentials instead. We put it in a FAQ. It&#39;s just not that big a deal.<br></p><p>The real concern is not that people will try to use Sequence as a generic protocol, but that they will try to inappropriately make their own protocols generic. I see this as a more minor issue, but if we&#39;re worried about it, we can address it by changing the mental model to one which doesn&#39;t make it look like a generics feature.<br></p><p>Basically, rather than thinking of this feature as &quot;generic protocols&quot;, it could instead be thought of as &quot;associated type overloading&quot;: a particular associated type can be overloaded, and you can use a `where` clause to select a particular overload. This would have a different syntax but handle the same use cases.<br></p><p>For instance, rather than saying this:<br></p><p>	protocol Matchable&lt;MatchingValue&gt; {<br>		func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>	}<br>	<br>	protocol Equatable: Matchable&lt;Self&gt; {<br>		func == (lhs: Self, rhs: Self) -&gt; Bool<br>	}<br>	func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>		return lhs == rhs<br>	}<br>	<br>	extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>	func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>		return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>	}<br>	<br>	struct PatternDictionary&lt;Matching, Value&gt;: DictionaryLiteralConvertible {<br>		typealias Key = Matchable&lt;Matching&gt;<br>		typealias Value = OutValue<br>		<br>		var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>		init(dictionaryLiteral pairs: (Key, Value)...) { patterns = DictionaryLiteral(pairs) }<br>		<br>		subscript(matchingValue: Matching) -&gt; Value? {<br>			for (pattern, value) in patterns {<br>				if pattern ~= matchingValue {<br>					return value<br>				}<br>			}<br>			return nil<br>		}<br>	}<br></p><p>You could instead say:<br></p><p>	protocol Matchable {<br>		@overloadable associatedtype MatchingValue<br>		func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>	}<br>	<br>	protocol Equatable: Matchable where MatchingValue |= Self {<br>		func == (lhs: Self, rhs: Self) -&gt; Bool<br>	}<br>	func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>		return lhs == rhs<br>	}<br>	<br>	extension Range: Equatable, Matchable {<br>		typealias MatchingValue |= Bound<br>	}<br>	func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>		return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>	}<br></p><p>	struct PatternDictionary&lt;Matching, Value&gt;: DictionaryLiteralConvertible {<br>		typealias Key = Any&lt;Matchable where .MatchingValue &amp; Matching&gt;<br>		typealias Value = Value<br>		<br>		var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>		init(dictionaryLiteral pairs: (Key, Value)...) { patterns = DictionaryLiteral(pairs) }<br>		<br>		subscript(matchingValue: Matching) -&gt; Value? {<br>			for (pattern, value) in patterns {<br>				if pattern ~= matchingValue {<br>					return value<br>				}<br>			}<br>			return nil<br>		}<br>	}<br></p><p>(Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It does have the syntax of one, but there&#39;s a separate overload for each type, so I don&#39;t think it really acts like one.)<br></p><p>This is very nearly the same feature, but presented with different syntax—effectively with a different metaphor. That should prevent it from being abused the way the core team fears it will be.<br></p><p>(One difference is that this version permits &quot;vacuous&quot; conformances: in theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an `@overloadable associatedtype` and define zero types. On the other hand, that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;ve prepared a proper draft:<br></p><p>https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br></p><p>- Anton<br></p><p>2016-06-10 17:18 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt; &gt; FWIW they&#39;re marked as &#39;unlikely&#39; here:<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br>&gt; &gt;<br>&gt; &gt; It would probably be useful to have counterarguments against the points<br>&gt; raised in that document if you want to prepare a proposal.<br>&gt;<br>&gt; Here&#39;s my counterargument.<br>&gt;<br>&gt;         * * *<br>&gt;<br>&gt; Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic<br>&gt; protocols (real generic protocols, not Sequence&lt;Element&gt;) are already<br>&gt; needed to make several existing or likely future features work better. For<br>&gt; instance:<br>&gt;<br>&gt; * Pattern matching<br>&gt;<br>&gt; Currently, if you want to customize your type&#39;s behavior in a `switch`<br>&gt; statement, you do it in an ad hoc, almost Objective-C-like way: You define<br>&gt; a free `~=` operator and the compiler resolves the overloads to magically<br>&gt; find and use it. There is no way to constrain a generic parameter to &quot;only<br>&gt; types that can pattern match against type X&quot;, which seems like a pretty<br>&gt; useful thing to offer. For instance, in the past people have suggested some<br>&gt; sort of expression-based switch alternative. The lack of a pattern matching<br>&gt; protocol makes this impossible to implement in either the standard library<br>&gt; or your own code.<br>&gt;<br>&gt; If we had generic protocols, we could define a protocol for this matching<br>&gt; operator and fix the issue:<br>&gt;<br>&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;         }<br>&gt;<br>&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;         }<br>&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;                 return lhs == rhs<br>&gt;         }<br>&gt;<br>&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt; -&gt; Bool {<br>&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt; pattern.upperBound<br>&gt;         }<br>&gt;<br>&gt; Then you could write, for instance, a PatternDictionary which took<br>&gt; patterns instead of keys and, when subscripted, matched the key against<br>&gt; each pattern until it found a matching one, then returned the corresponding<br>&gt; value.<br>&gt;<br>&gt; * String interpolation<br>&gt;<br>&gt; Currently, StringInterpolationConvertible only offers an<br>&gt; `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you<br>&gt; absolutely *must* permit any type to be interpolated into your type&#39;s<br>&gt; string literals. This blocks certain important use cases, like a<br>&gt; `LocalizedString` type which requires all strings it interacts with to pass<br>&gt; through a localization API, from being statically checked. It also would<br>&gt; normally require any type-specific behavior to be performed through runtime<br>&gt; tests, but just as in `~=`, the Swift compiler applies compile-time magic<br>&gt; to escape this restriction—you can write an<br>&gt; `init(stringInterpolationSegment:)` with a concrete type, and that will be<br>&gt; preferred over the generic one.<br>&gt;<br>&gt; In theory, it should be possible in current Swift to redefine<br>&gt; StringInterpolationConvertible to allow you to restrict the interpolatable<br>&gt; values by doing something like this:<br>&gt;<br>&gt;         protocol StringInterpolationConvertible {<br>&gt;                 associatedtype Interpolatable = Any<br>&gt;                 init(stringInterpolation: Self...)<br>&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;         }<br>&gt;<br>&gt; (This is no longer generic because I believe Interpolatable would have to<br>&gt; be somehow constrained to only protocol types to make that work. But you<br>&gt; get the idea.)<br>&gt;<br>&gt; However, in many uses, developers will want to support interpolation of<br>&gt; many custom types which do not share a common supertype. For instance,<br>&gt; LocalizedString might want to support interpolation of any LocalizedString,<br>&gt; Date, Integer, or FloatingPoint number. However, since Integer and<br>&gt; FloatingPoint are protocols, you cannot use an extension to make them<br>&gt; retroactively conform to a common protocol with LocalizedString.<br>&gt;<br>&gt; With generic protocols, we could define StringInterpolationConvertible<br>&gt; like this:<br>&gt;<br>&gt;         protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>&gt;                 init(stringInterpolation: Self...)<br>&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;         }<br>&gt;<br>&gt; And then say:<br>&gt;<br>&gt;         extension LocalizedString:<br>&gt; StringInterpolationConvertible&lt;LocalizedString&gt;,<br>&gt; StringInterpolationConvertible&lt;Integer&gt;,<br>&gt; StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>&gt;                 init(stringInterpolationSegment expr: LocalizedString) {<br>&gt;                         self.init()<br>&gt;                         self.components = expr.components<br>&gt;                 }<br>&gt;                 init(stringInterpolationSegment expr: Integer) {<br>&gt;                         self.init()<br>&gt;                         self.components.append(.integer(expr))<br>&gt;                 }<br>&gt;                 init(stringInterpolationSegment expr: FloatingPoint) {<br>&gt;                         self.components.append(.floatingPoint(expr))<br>&gt;                 }<br>&gt;                 init(stringInterpolation strings: LocalizedString...) {<br>&gt;                         self.init()<br>&gt;                         self.components = strings.map { $0.components<br>&gt; }.reduce([], combine: +)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; This example shows an interesting wrinkle: A generic protocol may have<br>&gt; requirements which don&#39;t use any of the generic types, so that each of the<br>&gt; multiple conformances will require members with identical signatures. When<br>&gt; this happens, Swift must only allow the member to be implemented once, with<br>&gt; that implementation being shared among all conformances.<br>&gt;<br>&gt; * Subtype-supertype relationships<br>&gt;<br>&gt; Though not currently implemented, there are long-term plans to permit at<br>&gt; least value types to form subtype-supertype relationships with each other.<br>&gt; A protocol would be a sensible way to express this behavior:<br>&gt;<br>&gt;         protocol Upcastable {<br>&gt;                 associatedtype Supertype<br>&gt;<br>&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;                 func casting() -&gt; Supertype<br>&gt;         }<br>&gt;<br>&gt; However, this would require a type to have only one supertype, which isn&#39;t<br>&gt; necessarily appropriate. For instance, we might want a UInt8 to be a<br>&gt; subtype of both Int16 and UInt16. For that to work, Upcastable would have<br>&gt; to be generic:<br>&gt;<br>&gt;         protocol Upcastable&lt;Supertype&gt; {<br>&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;                 func casting() -&gt; Supertype<br>&gt;         }<br>&gt;<br>&gt;         extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br>&gt;<br>&gt; Without generic protocols, the only way to offer sufficiently flexible<br>&gt; subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br>&gt;<br>&gt;         * * *<br>&gt;<br>&gt; Secondly, I think the concerns about people trying to use Sequence as a<br>&gt; generic protocol aren&#39;t that big a deal. To put it simply: Sequence is<br>&gt; *not* a generic protocol. The Swift team controls the definition of<br>&gt; Sequence, and we define it to not be generic. If people complain, we<br>&gt; explain that generic protocols don&#39;t actually do the right thing for this<br>&gt; and that they should use existentials instead. We put it in a FAQ. It&#39;s<br>&gt; just not that big a deal.<br>&gt;<br>&gt; The real concern is not that people will try to use Sequence as a generic<br>&gt; protocol, but that they will try to inappropriately make their own<br>&gt; protocols generic. I see this as a more minor issue, but if we&#39;re worried<br>&gt; about it, we can address it by changing the mental model to one which<br>&gt; doesn&#39;t make it look like a generics feature.<br>&gt;<br>&gt; Basically, rather than thinking of this feature as &quot;generic protocols&quot;, it<br>&gt; could instead be thought of as &quot;associated type overloading&quot;: a particular<br>&gt; associated type can be overloaded, and you can use a `where` clause to<br>&gt; select a particular overload. This would have a different syntax but handle<br>&gt; the same use cases.<br>&gt;<br>&gt; For instance, rather than saying this:<br>&gt;<br>&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;         }<br>&gt;<br>&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;         }<br>&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;                 return lhs == rhs<br>&gt;         }<br>&gt;<br>&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt; -&gt; Bool {<br>&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt; pattern.upperBound<br>&gt;         }<br>&gt;<br>&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt; DictionaryLiteralConvertible {<br>&gt;                 typealias Key = Matchable&lt;Matching&gt;<br>&gt;                 typealias Value = OutValue<br>&gt;<br>&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns<br>&gt; = DictionaryLiteral(pairs) }<br>&gt;<br>&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;                         for (pattern, value) in patterns {<br>&gt;                                 if pattern ~= matchingValue {<br>&gt;                                         return value<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         return nil<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; You could instead say:<br>&gt;<br>&gt;         protocol Matchable {<br>&gt;                 @overloadable associatedtype MatchingValue<br>&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;         }<br>&gt;<br>&gt;         protocol Equatable: Matchable where MatchingValue |= Self {<br>&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;         }<br>&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;                 return lhs == rhs<br>&gt;         }<br>&gt;<br>&gt;         extension Range: Equatable, Matchable {<br>&gt;                 typealias MatchingValue |= Bound<br>&gt;         }<br>&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt; -&gt; Bool {<br>&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt; pattern.upperBound<br>&gt;         }<br>&gt;<br>&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt; DictionaryLiteralConvertible {<br>&gt;                 typealias Key = Any&lt;Matchable where .MatchingValue &amp;<br>&gt; Matching&gt;<br>&gt;                 typealias Value = Value<br>&gt;<br>&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns<br>&gt; = DictionaryLiteral(pairs) }<br>&gt;<br>&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;                         for (pattern, value) in patterns {<br>&gt;                                 if pattern ~= matchingValue {<br>&gt;                                         return value<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         return nil<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; (Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It does<br>&gt; have the syntax of one, but there&#39;s a separate overload for each type, so I<br>&gt; don&#39;t think it really acts like one.)<br>&gt;<br>&gt; This is very nearly the same feature, but presented with different<br>&gt; syntax—effectively with a different metaphor. That should prevent it from<br>&gt; being abused the way the core team fears it will be.<br>&gt;<br>&gt; (One difference is that this version permits &quot;vacuous&quot; conformances: in<br>&gt; theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an<br>&gt; `@overloadable associatedtype` and define zero types. On the other hand,<br>&gt; that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/19b76cb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Looks good to me!<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; Am 12.06.2016 um 15:01 schrieb Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;ve prepared a proper draft:<br>&gt; <br>&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md &lt;https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md&gt;<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; 2016-06-10 17:18 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt;:<br>&gt; &gt; FWIW they&#39;re marked as &#39;unlikely&#39; here: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols&gt;<br>&gt; &gt;<br>&gt; &gt; It would probably be useful to have counterarguments against the points raised in that document if you want to prepare a proposal.<br>&gt; <br>&gt; Here&#39;s my counterargument.<br>&gt; <br>&gt;         * * *<br>&gt; <br>&gt; Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic protocols (real generic protocols, not Sequence&lt;Element&gt;) are already needed to make several existing or likely future features work better. For instance:<br>&gt; <br>&gt; * Pattern matching<br>&gt; <br>&gt; Currently, if you want to customize your type&#39;s behavior in a `switch` statement, you do it in an ad hoc, almost Objective-C-like way: You define a free `~=` operator and the compiler resolves the overloads to magically find and use it. There is no way to constrain a generic parameter to &quot;only types that can pattern match against type X&quot;, which seems like a pretty useful thing to offer. For instance, in the past people have suggested some sort of expression-based switch alternative. The lack of a pattern matching protocol makes this impossible to implement in either the standard library or your own code.<br>&gt; <br>&gt; If we had generic protocols, we could define a protocol for this matching operator and fix the issue:<br>&gt; <br>&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;         }<br>&gt; <br>&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;         }<br>&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;                 return lhs == rhs<br>&gt;         }<br>&gt; <br>&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>&gt;         }<br>&gt; <br>&gt; Then you could write, for instance, a PatternDictionary which took patterns instead of keys and, when subscripted, matched the key against each pattern until it found a matching one, then returned the corresponding value.<br>&gt; <br>&gt; * String interpolation<br>&gt; <br>&gt; Currently, StringInterpolationConvertible only offers an `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you absolutely *must* permit any type to be interpolated into your type&#39;s string literals. This blocks certain important use cases, like a `LocalizedString` type which requires all strings it interacts with to pass through a localization API, from being statically checked. It also would normally require any type-specific behavior to be performed through runtime tests, but just as in `~=`, the Swift compiler applies compile-time magic to escape this restriction—you can write an `init(stringInterpolationSegment:)` with a concrete type, and that will be preferred over the generic one.<br>&gt; <br>&gt; In theory, it should be possible in current Swift to redefine StringInterpolationConvertible to allow you to restrict the interpolatable values by doing something like this:<br>&gt; <br>&gt;         protocol StringInterpolationConvertible {<br>&gt;                 associatedtype Interpolatable = Any<br>&gt;                 init(stringInterpolation: Self...)<br>&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;         }<br>&gt; <br>&gt; (This is no longer generic because I believe Interpolatable would have to be somehow constrained to only protocol types to make that work. But you get the idea.)<br>&gt; <br>&gt; However, in many uses, developers will want to support interpolation of many custom types which do not share a common supertype. For instance, LocalizedString might want to support interpolation of any LocalizedString, Date, Integer, or FloatingPoint number. However, since Integer and FloatingPoint are protocols, you cannot use an extension to make them retroactively conform to a common protocol with LocalizedString.<br>&gt; <br>&gt; With generic protocols, we could define StringInterpolationConvertible like this:<br>&gt; <br>&gt;         protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>&gt;                 init(stringInterpolation: Self...)<br>&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;         }<br>&gt; <br>&gt; And then say:<br>&gt; <br>&gt;         extension LocalizedString: StringInterpolationConvertible&lt;LocalizedString&gt;, StringInterpolationConvertible&lt;Integer&gt;, StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>&gt;                 init(stringInterpolationSegment expr: LocalizedString) {<br>&gt;                         self.init()<br>&gt;                         self.components = expr.components<br>&gt;                 }<br>&gt;                 init(stringInterpolationSegment expr: Integer) {<br>&gt;                         self.init()<br>&gt;                         self.components.append(.integer(expr))<br>&gt;                 }<br>&gt;                 init(stringInterpolationSegment expr: FloatingPoint) {<br>&gt;                         self.components.append(.floatingPoint(expr))<br>&gt;                 }<br>&gt;                 init(stringInterpolation strings: LocalizedString...) {<br>&gt;                         self.init()<br>&gt;                         self.components = strings.map { $0.components }.reduce([], combine: +)<br>&gt;                 }<br>&gt;         }<br>&gt; <br>&gt; This example shows an interesting wrinkle: A generic protocol may have requirements which don&#39;t use any of the generic types, so that each of the multiple conformances will require members with identical signatures. When this happens, Swift must only allow the member to be implemented once, with that implementation being shared among all conformances.<br>&gt; <br>&gt; * Subtype-supertype relationships<br>&gt; <br>&gt; Though not currently implemented, there are long-term plans to permit at least value types to form subtype-supertype relationships with each other. A protocol would be a sensible way to express this behavior:<br>&gt; <br>&gt;         protocol Upcastable {<br>&gt;                 associatedtype Supertype<br>&gt; <br>&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;                 func casting() -&gt; Supertype<br>&gt;         }<br>&gt; <br>&gt; However, this would require a type to have only one supertype, which isn&#39;t necessarily appropriate. For instance, we might want a UInt8 to be a subtype of both Int16 and UInt16. For that to work, Upcastable would have to be generic:<br>&gt; <br>&gt;         protocol Upcastable&lt;Supertype&gt; {<br>&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;                 func casting() -&gt; Supertype<br>&gt;         }<br>&gt; <br>&gt;         extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br>&gt; <br>&gt; Without generic protocols, the only way to offer sufficiently flexible subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br>&gt; <br>&gt;         * * *<br>&gt; <br>&gt; Secondly, I think the concerns about people trying to use Sequence as a generic protocol aren&#39;t that big a deal. To put it simply: Sequence is *not* a generic protocol. The Swift team controls the definition of Sequence, and we define it to not be generic. If people complain, we explain that generic protocols don&#39;t actually do the right thing for this and that they should use existentials instead. We put it in a FAQ. It&#39;s just not that big a deal.<br>&gt; <br>&gt; The real concern is not that people will try to use Sequence as a generic protocol, but that they will try to inappropriately make their own protocols generic. I see this as a more minor issue, but if we&#39;re worried about it, we can address it by changing the mental model to one which doesn&#39;t make it look like a generics feature.<br>&gt; <br>&gt; Basically, rather than thinking of this feature as &quot;generic protocols&quot;, it could instead be thought of as &quot;associated type overloading&quot;: a particular associated type can be overloaded, and you can use a `where` clause to select a particular overload. This would have a different syntax but handle the same use cases.<br>&gt; <br>&gt; For instance, rather than saying this:<br>&gt; <br>&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;         }<br>&gt; <br>&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;         }<br>&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;                 return lhs == rhs<br>&gt;         }<br>&gt; <br>&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>&gt;         }<br>&gt; <br>&gt;         struct PatternDictionary&lt;Matching, Value&gt;: DictionaryLiteralConvertible {<br>&gt;                 typealias Key = Matchable&lt;Matching&gt;<br>&gt;                 typealias Value = OutValue<br>&gt; <br>&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns = DictionaryLiteral(pairs) }<br>&gt; <br>&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;                         for (pattern, value) in patterns {<br>&gt;                                 if pattern ~= matchingValue {<br>&gt;                                         return value<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         return nil<br>&gt;                 }<br>&gt;         }<br>&gt; <br>&gt; You could instead say:<br>&gt; <br>&gt;         protocol Matchable {<br>&gt;                 @overloadable associatedtype MatchingValue<br>&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;         }<br>&gt; <br>&gt;         protocol Equatable: Matchable where MatchingValue |= Self {<br>&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;         }<br>&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;                 return lhs == rhs<br>&gt;         }<br>&gt; <br>&gt;         extension Range: Equatable, Matchable {<br>&gt;                 typealias MatchingValue |= Bound<br>&gt;         }<br>&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>&gt;         }<br>&gt; <br>&gt;         struct PatternDictionary&lt;Matching, Value&gt;: DictionaryLiteralConvertible {<br>&gt;                 typealias Key = Any&lt;Matchable where .MatchingValue &amp; Matching&gt;<br>&gt;                 typealias Value = Value<br>&gt; <br>&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns = DictionaryLiteral(pairs) }<br>&gt; <br>&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;                         for (pattern, value) in patterns {<br>&gt;                                 if pattern ~= matchingValue {<br>&gt;                                         return value<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         return nil<br>&gt;                 }<br>&gt;         }<br>&gt; <br>&gt; (Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It does have the syntax of one, but there&#39;s a separate overload for each type, so I don&#39;t think it really acts like one.)<br>&gt; <br>&gt; This is very nearly the same feature, but presented with different syntax—effectively with a different metaphor. That should prevent it from being abused the way the core team fears it will be.<br>&gt; <br>&gt; (One difference is that this version permits &quot;vacuous&quot; conformances: in theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an `@overloadable associatedtype` and define zero types. On the other hand, that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/a6e3439f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 12, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sun, Jun 12, 2016 at 8:01 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I&#39;ve prepared a proper draft:<br>&gt;<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;<br>&gt;<br>When you propose this:<br>Syntax in protocol extensions<br></p><p>protocol MyComparable&lt;T&gt; {<br>  func &lt; (left: Self, right: T)<br>}extension MyComparable {<br>  func &gt; (left: T, right: Self) {<br>    return right &lt; left<br>  }<br>}<br></p><p><br>Would it be possible for me to write something like:<br></p><p>```<br>extension MyComparable&lt;T : SignedNumber&gt; { ... }<br>```<br></p><p><br>- Anton<br>&gt;<br>&gt; 2016-06-10 17:18 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;<br>&gt;&gt; &gt; FWIW they&#39;re marked as &#39;unlikely&#39; here:<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It would probably be useful to have counterarguments against the points<br>&gt;&gt; raised in that document if you want to prepare a proposal.<br>&gt;&gt;<br>&gt;&gt; Here&#39;s my counterargument.<br>&gt;&gt;<br>&gt;&gt;         * * *<br>&gt;&gt;<br>&gt;&gt; Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic<br>&gt;&gt; protocols (real generic protocols, not Sequence&lt;Element&gt;) are already<br>&gt;&gt; needed to make several existing or likely future features work better. For<br>&gt;&gt; instance:<br>&gt;&gt;<br>&gt;&gt; * Pattern matching<br>&gt;&gt;<br>&gt;&gt; Currently, if you want to customize your type&#39;s behavior in a `switch`<br>&gt;&gt; statement, you do it in an ad hoc, almost Objective-C-like way: You define<br>&gt;&gt; a free `~=` operator and the compiler resolves the overloads to magically<br>&gt;&gt; find and use it. There is no way to constrain a generic parameter to &quot;only<br>&gt;&gt; types that can pattern match against type X&quot;, which seems like a pretty<br>&gt;&gt; useful thing to offer. For instance, in the past people have suggested some<br>&gt;&gt; sort of expression-based switch alternative. The lack of a pattern matching<br>&gt;&gt; protocol makes this impossible to implement in either the standard library<br>&gt;&gt; or your own code.<br>&gt;&gt;<br>&gt;&gt; If we had generic protocols, we could define a protocol for this matching<br>&gt;&gt; operator and fix the issue:<br>&gt;&gt;<br>&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;                 return lhs == rhs<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt;&gt; -&gt; Bool {<br>&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt; pattern.upperBound<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; Then you could write, for instance, a PatternDictionary which took<br>&gt;&gt; patterns instead of keys and, when subscripted, matched the key against<br>&gt;&gt; each pattern until it found a matching one, then returned the corresponding<br>&gt;&gt; value.<br>&gt;&gt;<br>&gt;&gt; * String interpolation<br>&gt;&gt;<br>&gt;&gt; Currently, StringInterpolationConvertible only offers an<br>&gt;&gt; `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you<br>&gt;&gt; absolutely *must* permit any type to be interpolated into your type&#39;s<br>&gt;&gt; string literals. This blocks certain important use cases, like a<br>&gt;&gt; `LocalizedString` type which requires all strings it interacts with to pass<br>&gt;&gt; through a localization API, from being statically checked. It also would<br>&gt;&gt; normally require any type-specific behavior to be performed through runtime<br>&gt;&gt; tests, but just as in `~=`, the Swift compiler applies compile-time magic<br>&gt;&gt; to escape this restriction—you can write an<br>&gt;&gt; `init(stringInterpolationSegment:)` with a concrete type, and that will be<br>&gt;&gt; preferred over the generic one.<br>&gt;&gt;<br>&gt;&gt; In theory, it should be possible in current Swift to redefine<br>&gt;&gt; StringInterpolationConvertible to allow you to restrict the interpolatable<br>&gt;&gt; values by doing something like this:<br>&gt;&gt;<br>&gt;&gt;         protocol StringInterpolationConvertible {<br>&gt;&gt;                 associatedtype Interpolatable = Any<br>&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; (This is no longer generic because I believe Interpolatable would have to<br>&gt;&gt; be somehow constrained to only protocol types to make that work. But you<br>&gt;&gt; get the idea.)<br>&gt;&gt;<br>&gt;&gt; However, in many uses, developers will want to support interpolation of<br>&gt;&gt; many custom types which do not share a common supertype. For instance,<br>&gt;&gt; LocalizedString might want to support interpolation of any LocalizedString,<br>&gt;&gt; Date, Integer, or FloatingPoint number. However, since Integer and<br>&gt;&gt; FloatingPoint are protocols, you cannot use an extension to make them<br>&gt;&gt; retroactively conform to a common protocol with LocalizedString.<br>&gt;&gt;<br>&gt;&gt; With generic protocols, we could define StringInterpolationConvertible<br>&gt;&gt; like this:<br>&gt;&gt;<br>&gt;&gt;         protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; And then say:<br>&gt;&gt;<br>&gt;&gt;         extension LocalizedString:<br>&gt;&gt; StringInterpolationConvertible&lt;LocalizedString&gt;,<br>&gt;&gt; StringInterpolationConvertible&lt;Integer&gt;,<br>&gt;&gt; StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>&gt;&gt;                 init(stringInterpolationSegment expr: LocalizedString) {<br>&gt;&gt;                         self.init()<br>&gt;&gt;                         self.components = expr.components<br>&gt;&gt;                 }<br>&gt;&gt;                 init(stringInterpolationSegment expr: Integer) {<br>&gt;&gt;                         self.init()<br>&gt;&gt;                         self.components.append(.integer(expr))<br>&gt;&gt;                 }<br>&gt;&gt;                 init(stringInterpolationSegment expr: FloatingPoint) {<br>&gt;&gt;                         self.components.append(.floatingPoint(expr))<br>&gt;&gt;                 }<br>&gt;&gt;                 init(stringInterpolation strings: LocalizedString...) {<br>&gt;&gt;                         self.init()<br>&gt;&gt;                         self.components = strings.map { $0.components<br>&gt;&gt; }.reduce([], combine: +)<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; This example shows an interesting wrinkle: A generic protocol may have<br>&gt;&gt; requirements which don&#39;t use any of the generic types, so that each of the<br>&gt;&gt; multiple conformances will require members with identical signatures. When<br>&gt;&gt; this happens, Swift must only allow the member to be implemented once, with<br>&gt;&gt; that implementation being shared among all conformances.<br>&gt;&gt;<br>&gt;&gt; * Subtype-supertype relationships<br>&gt;&gt;<br>&gt;&gt; Though not currently implemented, there are long-term plans to permit at<br>&gt;&gt; least value types to form subtype-supertype relationships with each other.<br>&gt;&gt; A protocol would be a sensible way to express this behavior:<br>&gt;&gt;<br>&gt;&gt;         protocol Upcastable {<br>&gt;&gt;                 associatedtype Supertype<br>&gt;&gt;<br>&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; However, this would require a type to have only one supertype, which<br>&gt;&gt; isn&#39;t necessarily appropriate. For instance, we might want a UInt8 to be a<br>&gt;&gt; subtype of both Int16 and UInt16. For that to work, Upcastable would have<br>&gt;&gt; to be generic:<br>&gt;&gt;<br>&gt;&gt;         protocol Upcastable&lt;Supertype&gt; {<br>&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br>&gt;&gt;<br>&gt;&gt; Without generic protocols, the only way to offer sufficiently flexible<br>&gt;&gt; subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br>&gt;&gt;<br>&gt;&gt;         * * *<br>&gt;&gt;<br>&gt;&gt; Secondly, I think the concerns about people trying to use Sequence as a<br>&gt;&gt; generic protocol aren&#39;t that big a deal. To put it simply: Sequence is<br>&gt;&gt; *not* a generic protocol. The Swift team controls the definition of<br>&gt;&gt; Sequence, and we define it to not be generic. If people complain, we<br>&gt;&gt; explain that generic protocols don&#39;t actually do the right thing for this<br>&gt;&gt; and that they should use existentials instead. We put it in a FAQ. It&#39;s<br>&gt;&gt; just not that big a deal.<br>&gt;&gt;<br>&gt;&gt; The real concern is not that people will try to use Sequence as a generic<br>&gt;&gt; protocol, but that they will try to inappropriately make their own<br>&gt;&gt; protocols generic. I see this as a more minor issue, but if we&#39;re worried<br>&gt;&gt; about it, we can address it by changing the mental model to one which<br>&gt;&gt; doesn&#39;t make it look like a generics feature.<br>&gt;&gt;<br>&gt;&gt; Basically, rather than thinking of this feature as &quot;generic protocols&quot;,<br>&gt;&gt; it could instead be thought of as &quot;associated type overloading&quot;: a<br>&gt;&gt; particular associated type can be overloaded, and you can use a `where`<br>&gt;&gt; clause to select a particular overload. This would have a different syntax<br>&gt;&gt; but handle the same use cases.<br>&gt;&gt;<br>&gt;&gt; For instance, rather than saying this:<br>&gt;&gt;<br>&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;                 return lhs == rhs<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt;&gt; -&gt; Bool {<br>&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt; pattern.upperBound<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt;&gt; DictionaryLiteralConvertible {<br>&gt;&gt;                 typealias Key = Matchable&lt;Matching&gt;<br>&gt;&gt;                 typealias Value = OutValue<br>&gt;&gt;<br>&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns<br>&gt;&gt; = DictionaryLiteral(pairs) }<br>&gt;&gt;<br>&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;                                         return value<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         return nil<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; You could instead say:<br>&gt;&gt;<br>&gt;&gt;         protocol Matchable {<br>&gt;&gt;                 @overloadable associatedtype MatchingValue<br>&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         protocol Equatable: Matchable where MatchingValue |= Self {<br>&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;                 return lhs == rhs<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension Range: Equatable, Matchable {<br>&gt;&gt;                 typealias MatchingValue |= Bound<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt;&gt; -&gt; Bool {<br>&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt; pattern.upperBound<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt;&gt; DictionaryLiteralConvertible {<br>&gt;&gt;                 typealias Key = Any&lt;Matchable where .MatchingValue &amp;<br>&gt;&gt; Matching&gt;<br>&gt;&gt;                 typealias Value = Value<br>&gt;&gt;<br>&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns<br>&gt;&gt; = DictionaryLiteral(pairs) }<br>&gt;&gt;<br>&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;                                         return value<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         return nil<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; (Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It does<br>&gt;&gt; have the syntax of one, but there&#39;s a separate overload for each type, so I<br>&gt;&gt; don&#39;t think it really acts like one.)<br>&gt;&gt;<br>&gt;&gt; This is very nearly the same feature, but presented with different<br>&gt;&gt; syntax—effectively with a different metaphor. That should prevent it from<br>&gt;&gt; being abused the way the core team fears it will be.<br>&gt;&gt;<br>&gt;&gt; (One difference is that this version permits &quot;vacuous&quot; conformances: in<br>&gt;&gt; theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an<br>&gt;&gt; `@overloadable associatedtype` and define zero types. On the other hand,<br>&gt;&gt; that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/cb474c31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June 12, 2016 at 09:00:00pm</p></header><div class="content"><p>Yes, everything that works on generic types should work for generic<br>protocols. I&#39;ll add that.<br></p><p>What won&#39;t work is declaring that  MyComparable : Comparable  iff  T ==<br>Self. The same won&#39;t work for current non-generic protocols as well.<br>Although that feature is highly requested, it is discussed in a separate<br>proposal.<br></p><p>- Anton<br></p><p>2016-06-12 21:16 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt;<br>&gt;<br>&gt; On Sun, Jun 12, 2016 at 8:01 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ve prepared a proper draft:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt; When you propose this:<br>&gt; Syntax in protocol extensions<br>&gt;<br>&gt; protocol MyComparable&lt;T&gt; {<br>&gt;   func &lt; (left: Self, right: T)<br>&gt; }extension MyComparable {<br>&gt;   func &gt; (left: T, right: Self) {<br>&gt;     return right &lt; left<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Would it be possible for me to write something like:<br>&gt;<br>&gt; ```<br>&gt; extension MyComparable&lt;T : SignedNumber&gt; { ... }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; - Anton<br>&gt;&gt;<br>&gt;&gt; 2016-06-10 17:18 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; FWIW they&#39;re marked as &#39;unlikely&#39; here:<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It would probably be useful to have counterarguments against the<br>&gt;&gt;&gt; points raised in that document if you want to prepare a proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here&#39;s my counterargument.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         * * *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic<br>&gt;&gt;&gt; protocols (real generic protocols, not Sequence&lt;Element&gt;) are already<br>&gt;&gt;&gt; needed to make several existing or likely future features work better. For<br>&gt;&gt;&gt; instance:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Pattern matching<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, if you want to customize your type&#39;s behavior in a `switch`<br>&gt;&gt;&gt; statement, you do it in an ad hoc, almost Objective-C-like way: You define<br>&gt;&gt;&gt; a free `~=` operator and the compiler resolves the overloads to magically<br>&gt;&gt;&gt; find and use it. There is no way to constrain a generic parameter to &quot;only<br>&gt;&gt;&gt; types that can pattern match against type X&quot;, which seems like a pretty<br>&gt;&gt;&gt; useful thing to offer. For instance, in the past people have suggested some<br>&gt;&gt;&gt; sort of expression-based switch alternative. The lack of a pattern matching<br>&gt;&gt;&gt; protocol makes this impossible to implement in either the standard library<br>&gt;&gt;&gt; or your own code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we had generic protocols, we could define a protocol for this<br>&gt;&gt;&gt; matching operator and fix the issue:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;                 return lhs == rhs<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt;&gt;&gt; -&gt; Bool {<br>&gt;&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt;&gt; pattern.upperBound<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then you could write, for instance, a PatternDictionary which took<br>&gt;&gt;&gt; patterns instead of keys and, when subscripted, matched the key against<br>&gt;&gt;&gt; each pattern until it found a matching one, then returned the corresponding<br>&gt;&gt;&gt; value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * String interpolation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, StringInterpolationConvertible only offers an<br>&gt;&gt;&gt; `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you<br>&gt;&gt;&gt; absolutely *must* permit any type to be interpolated into your type&#39;s<br>&gt;&gt;&gt; string literals. This blocks certain important use cases, like a<br>&gt;&gt;&gt; `LocalizedString` type which requires all strings it interacts with to pass<br>&gt;&gt;&gt; through a localization API, from being statically checked. It also would<br>&gt;&gt;&gt; normally require any type-specific behavior to be performed through runtime<br>&gt;&gt;&gt; tests, but just as in `~=`, the Swift compiler applies compile-time magic<br>&gt;&gt;&gt; to escape this restriction—you can write an<br>&gt;&gt;&gt; `init(stringInterpolationSegment:)` with a concrete type, and that will be<br>&gt;&gt;&gt; preferred over the generic one.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In theory, it should be possible in current Swift to redefine<br>&gt;&gt;&gt; StringInterpolationConvertible to allow you to restrict the interpolatable<br>&gt;&gt;&gt; values by doing something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol StringInterpolationConvertible {<br>&gt;&gt;&gt;                 associatedtype Interpolatable = Any<br>&gt;&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (This is no longer generic because I believe Interpolatable would have<br>&gt;&gt;&gt; to be somehow constrained to only protocol types to make that work. But you<br>&gt;&gt;&gt; get the idea.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, in many uses, developers will want to support interpolation of<br>&gt;&gt;&gt; many custom types which do not share a common supertype. For instance,<br>&gt;&gt;&gt; LocalizedString might want to support interpolation of any LocalizedString,<br>&gt;&gt;&gt; Date, Integer, or FloatingPoint number. However, since Integer and<br>&gt;&gt;&gt; FloatingPoint are protocols, you cannot use an extension to make them<br>&gt;&gt;&gt; retroactively conform to a common protocol with LocalizedString.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With generic protocols, we could define StringInterpolationConvertible<br>&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>&gt;&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And then say:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension LocalizedString:<br>&gt;&gt;&gt; StringInterpolationConvertible&lt;LocalizedString&gt;,<br>&gt;&gt;&gt; StringInterpolationConvertible&lt;Integer&gt;,<br>&gt;&gt;&gt; StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>&gt;&gt;&gt;                 init(stringInterpolationSegment expr: LocalizedString) {<br>&gt;&gt;&gt;                         self.init()<br>&gt;&gt;&gt;                         self.components = expr.components<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;                 init(stringInterpolationSegment expr: Integer) {<br>&gt;&gt;&gt;                         self.init()<br>&gt;&gt;&gt;                         self.components.append(.integer(expr))<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;                 init(stringInterpolationSegment expr: FloatingPoint) {<br>&gt;&gt;&gt;                         self.components.append(.floatingPoint(expr))<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;                 init(stringInterpolation strings: LocalizedString...) {<br>&gt;&gt;&gt;                         self.init()<br>&gt;&gt;&gt;                         self.components = strings.map { $0.components<br>&gt;&gt;&gt; }.reduce([], combine: +)<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This example shows an interesting wrinkle: A generic protocol may have<br>&gt;&gt;&gt; requirements which don&#39;t use any of the generic types, so that each of the<br>&gt;&gt;&gt; multiple conformances will require members with identical signatures. When<br>&gt;&gt;&gt; this happens, Swift must only allow the member to be implemented once, with<br>&gt;&gt;&gt; that implementation being shared among all conformances.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Subtype-supertype relationships<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Though not currently implemented, there are long-term plans to permit at<br>&gt;&gt;&gt; least value types to form subtype-supertype relationships with each other.<br>&gt;&gt;&gt; A protocol would be a sensible way to express this behavior:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Upcastable {<br>&gt;&gt;&gt;                 associatedtype Supertype<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, this would require a type to have only one supertype, which<br>&gt;&gt;&gt; isn&#39;t necessarily appropriate. For instance, we might want a UInt8 to be a<br>&gt;&gt;&gt; subtype of both Int16 and UInt16. For that to work, Upcastable would have<br>&gt;&gt;&gt; to be generic:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Upcastable&lt;Supertype&gt; {<br>&gt;&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Without generic protocols, the only way to offer sufficiently flexible<br>&gt;&gt;&gt; subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         * * *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Secondly, I think the concerns about people trying to use Sequence as a<br>&gt;&gt;&gt; generic protocol aren&#39;t that big a deal. To put it simply: Sequence is<br>&gt;&gt;&gt; *not* a generic protocol. The Swift team controls the definition of<br>&gt;&gt;&gt; Sequence, and we define it to not be generic. If people complain, we<br>&gt;&gt;&gt; explain that generic protocols don&#39;t actually do the right thing for this<br>&gt;&gt;&gt; and that they should use existentials instead. We put it in a FAQ. It&#39;s<br>&gt;&gt;&gt; just not that big a deal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The real concern is not that people will try to use Sequence as a<br>&gt;&gt;&gt; generic protocol, but that they will try to inappropriately make their own<br>&gt;&gt;&gt; protocols generic. I see this as a more minor issue, but if we&#39;re worried<br>&gt;&gt;&gt; about it, we can address it by changing the mental model to one which<br>&gt;&gt;&gt; doesn&#39;t make it look like a generics feature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Basically, rather than thinking of this feature as &quot;generic protocols&quot;,<br>&gt;&gt;&gt; it could instead be thought of as &quot;associated type overloading&quot;: a<br>&gt;&gt;&gt; particular associated type can be overloaded, and you can use a `where`<br>&gt;&gt;&gt; clause to select a particular overload. This would have a different syntax<br>&gt;&gt;&gt; but handle the same use cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For instance, rather than saying this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;                 return lhs == rhs<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt;&gt;&gt; -&gt; Bool {<br>&gt;&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt;&gt; pattern.upperBound<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt;&gt;&gt; DictionaryLiteralConvertible {<br>&gt;&gt;&gt;                 typealias Key = Matchable&lt;Matching&gt;<br>&gt;&gt;&gt;                 typealias Value = OutValue<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) {<br>&gt;&gt;&gt; patterns = DictionaryLiteral(pairs) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;&gt;                                         return value<br>&gt;&gt;&gt;                                 }<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;                         return nil<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You could instead say:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Matchable {<br>&gt;&gt;&gt;                 @overloadable associatedtype MatchingValue<br>&gt;&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol Equatable: Matchable where MatchingValue |= Self {<br>&gt;&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;                 return lhs == rhs<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         extension Range: Equatable, Matchable {<br>&gt;&gt;&gt;                 typealias MatchingValue |= Bound<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound)<br>&gt;&gt;&gt; -&gt; Bool {<br>&gt;&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt;&gt; pattern.upperBound<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt;&gt;&gt; DictionaryLiteralConvertible {<br>&gt;&gt;&gt;                 typealias Key = Any&lt;Matchable where .MatchingValue &amp;<br>&gt;&gt;&gt; Matching&gt;<br>&gt;&gt;&gt;                 typealias Value = Value<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) {<br>&gt;&gt;&gt; patterns = DictionaryLiteral(pairs) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;&gt;                                         return value<br>&gt;&gt;&gt;                                 }<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;                         return nil<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It does<br>&gt;&gt;&gt; have the syntax of one, but there&#39;s a separate overload for each type, so I<br>&gt;&gt;&gt; don&#39;t think it really acts like one.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is very nearly the same feature, but presented with different<br>&gt;&gt;&gt; syntax—effectively with a different metaphor. That should prevent it from<br>&gt;&gt;&gt; being abused the way the core team fears it will be.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (One difference is that this version permits &quot;vacuous&quot; conformances: in<br>&gt;&gt;&gt; theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an<br>&gt;&gt;&gt; `@overloadable associatedtype` and define zero types. On the other hand,<br>&gt;&gt;&gt; that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/71661230/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>June 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Awesome that you guys started this! I&#39;ve been meaning to pitch it for a<br>while. Couple notes:<br></p><p>- in the motivation, you&#39;re conforming to SequenceType while defining a<br>&gt;From protocol (just a typo I think)<br>- the proposal should mention Brent&#39;s comments since it doesn&#39;t have a<br>rebuttal to the &quot;unlikely&quot; status generic protocols were given in the<br>generic manifesto. Brent does a great job of doing that<br>- is there a way for generic protocols to still have associated types? I<br>think that could have some interesting use cases.<br></p><p>Dan Appel<br></p><p>On Sun, Jun 12, 2016 at 11:28 AM Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Yes, everything that works on generic types should work for generic<br>&gt; protocols. I&#39;ll add that.<br>&gt;<br>&gt; What won&#39;t work is declaring that  MyComparable : Comparable  iff  T ==<br>&gt; Self. The same won&#39;t work for current non-generic protocols as well.<br>&gt; Although that feature is highly requested, it is discussed in a separate<br>&gt; proposal.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; 2016-06-12 21:16 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 12, 2016 at 8:01 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve prepared a proper draft:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; When you propose this:<br>&gt;&gt; Syntax in protocol extensions<br>&gt;&gt;<br>&gt;&gt; protocol MyComparable&lt;T&gt; {<br>&gt;&gt;   func &lt; (left: Self, right: T)<br>&gt;&gt; }extension MyComparable {<br>&gt;&gt;   func &gt; (left: T, right: Self) {<br>&gt;&gt;     return right &lt; left<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Would it be possible for me to write something like:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; extension MyComparable&lt;T : SignedNumber&gt; { ... }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2016-06-10 17:18 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; FWIW they&#39;re marked as &#39;unlikely&#39; here:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; It would probably be useful to have counterarguments against the<br>&gt;&gt;&gt;&gt; points raised in that document if you want to prepare a proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here&#39;s my counterargument.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         * * *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic<br>&gt;&gt;&gt;&gt; protocols (real generic protocols, not Sequence&lt;Element&gt;) are already<br>&gt;&gt;&gt;&gt; needed to make several existing or likely future features work better. For<br>&gt;&gt;&gt;&gt; instance:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Pattern matching<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently, if you want to customize your type&#39;s behavior in a `switch`<br>&gt;&gt;&gt;&gt; statement, you do it in an ad hoc, almost Objective-C-like way: You define<br>&gt;&gt;&gt;&gt; a free `~=` operator and the compiler resolves the overloads to magically<br>&gt;&gt;&gt;&gt; find and use it. There is no way to constrain a generic parameter to &quot;only<br>&gt;&gt;&gt;&gt; types that can pattern match against type X&quot;, which seems like a pretty<br>&gt;&gt;&gt;&gt; useful thing to offer. For instance, in the past people have suggested some<br>&gt;&gt;&gt;&gt; sort of expression-based switch alternative. The lack of a pattern matching<br>&gt;&gt;&gt;&gt; protocol makes this impossible to implement in either the standard library<br>&gt;&gt;&gt;&gt; or your own code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we had generic protocols, we could define a protocol for this<br>&gt;&gt;&gt;&gt; matching operator and fix the issue:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;                 return lhs == rhs<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value:<br>&gt;&gt;&gt;&gt; Bound) -&gt; Bool {<br>&gt;&gt;&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt;&gt;&gt; pattern.upperBound<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Then you could write, for instance, a PatternDictionary which took<br>&gt;&gt;&gt;&gt; patterns instead of keys and, when subscripted, matched the key against<br>&gt;&gt;&gt;&gt; each pattern until it found a matching one, then returned the corresponding<br>&gt;&gt;&gt;&gt; value.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * String interpolation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently, StringInterpolationConvertible only offers an<br>&gt;&gt;&gt;&gt; `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you<br>&gt;&gt;&gt;&gt; absolutely *must* permit any type to be interpolated into your type&#39;s<br>&gt;&gt;&gt;&gt; string literals. This blocks certain important use cases, like a<br>&gt;&gt;&gt;&gt; `LocalizedString` type which requires all strings it interacts with to pass<br>&gt;&gt;&gt;&gt; through a localization API, from being statically checked. It also would<br>&gt;&gt;&gt;&gt; normally require any type-specific behavior to be performed through runtime<br>&gt;&gt;&gt;&gt; tests, but just as in `~=`, the Swift compiler applies compile-time magic<br>&gt;&gt;&gt;&gt; to escape this restriction—you can write an<br>&gt;&gt;&gt;&gt; `init(stringInterpolationSegment:)` with a concrete type, and that will be<br>&gt;&gt;&gt;&gt; preferred over the generic one.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In theory, it should be possible in current Swift to redefine<br>&gt;&gt;&gt;&gt; StringInterpolationConvertible to allow you to restrict the interpolatable<br>&gt;&gt;&gt;&gt; values by doing something like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol StringInterpolationConvertible {<br>&gt;&gt;&gt;&gt;                 associatedtype Interpolatable = Any<br>&gt;&gt;&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (This is no longer generic because I believe Interpolatable would have<br>&gt;&gt;&gt;&gt; to be somehow constrained to only protocol types to make that work. But you<br>&gt;&gt;&gt;&gt; get the idea.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, in many uses, developers will want to support interpolation of<br>&gt;&gt;&gt;&gt; many custom types which do not share a common supertype. For instance,<br>&gt;&gt;&gt;&gt; LocalizedString might want to support interpolation of any LocalizedString,<br>&gt;&gt;&gt;&gt; Date, Integer, or FloatingPoint number. However, since Integer and<br>&gt;&gt;&gt;&gt; FloatingPoint are protocols, you cannot use an extension to make them<br>&gt;&gt;&gt;&gt; retroactively conform to a common protocol with LocalizedString.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; With generic protocols, we could define StringInterpolationConvertible<br>&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>&gt;&gt;&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And then say:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension LocalizedString:<br>&gt;&gt;&gt;&gt; StringInterpolationConvertible&lt;LocalizedString&gt;,<br>&gt;&gt;&gt;&gt; StringInterpolationConvertible&lt;Integer&gt;,<br>&gt;&gt;&gt;&gt; StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>&gt;&gt;&gt;&gt;                 init(stringInterpolationSegment expr: LocalizedString) {<br>&gt;&gt;&gt;&gt;                         self.init()<br>&gt;&gt;&gt;&gt;                         self.components = expr.components<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;                 init(stringInterpolationSegment expr: Integer) {<br>&gt;&gt;&gt;&gt;                         self.init()<br>&gt;&gt;&gt;&gt;                         self.components.append(.integer(expr))<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;                 init(stringInterpolationSegment expr: FloatingPoint) {<br>&gt;&gt;&gt;&gt;                         self.components.append(.floatingPoint(expr))<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;                 init(stringInterpolation strings: LocalizedString...) {<br>&gt;&gt;&gt;&gt;                         self.init()<br>&gt;&gt;&gt;&gt;                         self.components = strings.map { $0.components<br>&gt;&gt;&gt;&gt; }.reduce([], combine: +)<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This example shows an interesting wrinkle: A generic protocol may have<br>&gt;&gt;&gt;&gt; requirements which don&#39;t use any of the generic types, so that each of the<br>&gt;&gt;&gt;&gt; multiple conformances will require members with identical signatures. When<br>&gt;&gt;&gt;&gt; this happens, Swift must only allow the member to be implemented once, with<br>&gt;&gt;&gt;&gt; that implementation being shared among all conformances.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Subtype-supertype relationships<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Though not currently implemented, there are long-term plans to permit<br>&gt;&gt;&gt;&gt; at least value types to form subtype-supertype relationships with each<br>&gt;&gt;&gt;&gt; other. A protocol would be a sensible way to express this behavior:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Upcastable {<br>&gt;&gt;&gt;&gt;                 associatedtype Supertype<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, this would require a type to have only one supertype, which<br>&gt;&gt;&gt;&gt; isn&#39;t necessarily appropriate. For instance, we might want a UInt8 to be a<br>&gt;&gt;&gt;&gt; subtype of both Int16 and UInt16. For that to work, Upcastable would have<br>&gt;&gt;&gt;&gt; to be generic:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Upcastable&lt;Supertype&gt; {<br>&gt;&gt;&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Without generic protocols, the only way to offer sufficiently flexible<br>&gt;&gt;&gt;&gt; subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         * * *<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Secondly, I think the concerns about people trying to use Sequence as a<br>&gt;&gt;&gt;&gt; generic protocol aren&#39;t that big a deal. To put it simply: Sequence is<br>&gt;&gt;&gt;&gt; *not* a generic protocol. The Swift team controls the definition of<br>&gt;&gt;&gt;&gt; Sequence, and we define it to not be generic. If people complain, we<br>&gt;&gt;&gt;&gt; explain that generic protocols don&#39;t actually do the right thing for this<br>&gt;&gt;&gt;&gt; and that they should use existentials instead. We put it in a FAQ. It&#39;s<br>&gt;&gt;&gt;&gt; just not that big a deal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The real concern is not that people will try to use Sequence as a<br>&gt;&gt;&gt;&gt; generic protocol, but that they will try to inappropriately make their own<br>&gt;&gt;&gt;&gt; protocols generic. I see this as a more minor issue, but if we&#39;re worried<br>&gt;&gt;&gt;&gt; about it, we can address it by changing the mental model to one which<br>&gt;&gt;&gt;&gt; doesn&#39;t make it look like a generics feature.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Basically, rather than thinking of this feature as &quot;generic protocols&quot;,<br>&gt;&gt;&gt;&gt; it could instead be thought of as &quot;associated type overloading&quot;: a<br>&gt;&gt;&gt;&gt; particular associated type can be overloaded, and you can use a `where`<br>&gt;&gt;&gt;&gt; clause to select a particular overload. This would have a different syntax<br>&gt;&gt;&gt;&gt; but handle the same use cases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For instance, rather than saying this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;                 return lhs == rhs<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value:<br>&gt;&gt;&gt;&gt; Bound) -&gt; Bool {<br>&gt;&gt;&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt;&gt;&gt; pattern.upperBound<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt;&gt;&gt;&gt; DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;                 typealias Key = Matchable&lt;Matching&gt;<br>&gt;&gt;&gt;&gt;                 typealias Value = OutValue<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) {<br>&gt;&gt;&gt;&gt; patterns = DictionaryLiteral(pairs) }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;&gt;&gt;                                         return value<br>&gt;&gt;&gt;&gt;                                 }<br>&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;                         return nil<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You could instead say:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Matchable {<br>&gt;&gt;&gt;&gt;                 @overloadable associatedtype MatchingValue<br>&gt;&gt;&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol Equatable: Matchable where MatchingValue |= Self {<br>&gt;&gt;&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;                 return lhs == rhs<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         extension Range: Equatable, Matchable {<br>&gt;&gt;&gt;&gt;                 typealias MatchingValue |= Bound<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value:<br>&gt;&gt;&gt;&gt; Bound) -&gt; Bool {<br>&gt;&gt;&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt;<br>&gt;&gt;&gt;&gt; pattern.upperBound<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;:<br>&gt;&gt;&gt;&gt; DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;                 typealias Key = Any&lt;Matchable where .MatchingValue &amp;<br>&gt;&gt;&gt;&gt; Matching&gt;<br>&gt;&gt;&gt;&gt;                 typealias Value = Value<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) {<br>&gt;&gt;&gt;&gt; patterns = DictionaryLiteral(pairs) }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;&gt;&gt;                                         return value<br>&gt;&gt;&gt;&gt;                                 }<br>&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;                         return nil<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It<br>&gt;&gt;&gt;&gt; does have the syntax of one, but there&#39;s a separate overload for each type,<br>&gt;&gt;&gt;&gt; so I don&#39;t think it really acts like one.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is very nearly the same feature, but presented with different<br>&gt;&gt;&gt;&gt; syntax—effectively with a different metaphor. That should prevent it from<br>&gt;&gt;&gt;&gt; being abused the way the core team fears it will be.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (One difference is that this version permits &quot;vacuous&quot; conformances: in<br>&gt;&gt;&gt;&gt; theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an<br>&gt;&gt;&gt;&gt; `@overloadable associatedtype` and define zero types. On the other hand,<br>&gt;&gt;&gt;&gt; that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/f61587dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June 12, 2016 at 11:00:00pm</p></header><div class="content"><p>Copy of link to the proposal:<br>https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br></p><p>Inline:<br></p><p>2016-06-12 21:51 GMT+03:00 Dan Appel &lt;dan.appel00 at gmail.com&gt;:<br></p><p>&gt; Awesome that you guys started this! I&#39;ve been meaning to pitch it for a<br>&gt; while. Couple notes:<br>&gt;<br>&gt; - in the motivation, you&#39;re conforming to SequenceType while defining a<br>&gt; From protocol (just a typo I think)<br>&gt;<br></p><p>Fixed<br></p><p><br>&gt; - the proposal should mention Brent&#39;s comments since it doesn&#39;t have a<br>&gt; rebuttal to the &quot;unlikely&quot; status generic protocols were given in the<br>&gt; generic manifesto. Brent does a great job of doing that<br>&gt;<br></p><p>Added a bold link<br></p><p><br>&gt; - is there a way for generic protocols to still have associated types? I<br>&gt; think that could have some interesting use cases.<br>&gt;<br></p><p>Generic protocols can contain associated types, but no type can conform to<br>multiple instances of such protocols.<br></p><p>Actually, this limitation is more restricting than it seems, because if our<br>protocol conforms to a protocol with associated type requirements, then we<br>still can&#39;t conform to our protocol multiple times.<br></p><p><br>&gt; Dan Appel<br>&gt;<br>&gt; On Sun, Jun 12, 2016 at 11:28 AM Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Yes, everything that works on generic types should work for generic<br>&gt;&gt; protocols. I&#39;ll add that.<br>&gt;&gt;<br>&gt;&gt; What won&#39;t work is declaring that  MyComparable : Comparable  iff  T ==<br>&gt;&gt; Self. The same won&#39;t work for current non-generic protocols as well.<br>&gt;&gt; Although that feature is highly requested, it is discussed in a separate<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;<br>&gt;&gt; 2016-06-12 21:16 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Jun 12, 2016 at 8:01 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ve prepared a proper draft:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; When you propose this:<br>&gt;&gt;&gt; Syntax in protocol extensions<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol MyComparable&lt;T&gt; {<br>&gt;&gt;&gt;   func &lt; (left: Self, right: T)<br>&gt;&gt;&gt; }extension MyComparable {<br>&gt;&gt;&gt;   func &gt; (left: T, right: Self) {<br>&gt;&gt;&gt;     return right &lt; left<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would it be possible for me to write something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; extension MyComparable&lt;T : SignedNumber&gt; { ... }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Dan Appel<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/22dcb4ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>June 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;if our protocol conforms to a protocol with associated type requirements,<br>then we still can&#39;t conform to our protocol multiple times.<br></p><p>I don&#39;t think so:<br></p><p>protocol A {<br></p><p>    associatedtype TypeA<br></p><p>}<br></p><p><br>protocol B&lt;TypeB&gt;: A {<br></p><p>    func convert(from: TypeB) -&gt; TypeA<br></p><p>}<br></p><p><br>struct C: A {<br></p><p>    typealias TypeA = String<br></p><p>}<br></p><p>extension C: B&lt;Int&gt; {<br></p><p>    func convert(from int: Int) -&gt; String {<br></p><p>        return String(int)<br></p><p>    }<br></p><p>}<br></p><p>extension C: B&lt;Double&gt; {<br></p><p>    func convert(from double: Double) -&gt; String {<br></p><p>        return String(double)<br></p><p>    }<br></p><p>}<br></p><p>Seems to me like the above should work fine: the associated type is<br>declared once, but the generic protocol is conformed to multiple times.<br></p><p>On Sun, Jun 12, 2016 at 1:22 PM Антон Жилин &lt;antonyzhilin at gmail.com&gt; wrote:<br></p><p>&gt; Copy of link to the proposal:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;<br>&gt; Inline:<br>&gt;<br>&gt; 2016-06-12 21:51 GMT+03:00 Dan Appel &lt;dan.appel00 at gmail.com&gt;:<br>&gt;<br>&gt;&gt; Awesome that you guys started this! I&#39;ve been meaning to pitch it for a<br>&gt;&gt; while. Couple notes:<br>&gt;&gt;<br>&gt;&gt; - in the motivation, you&#39;re conforming to SequenceType while defining a<br>&gt;&gt; From protocol (just a typo I think)<br>&gt;&gt;<br>&gt;<br>&gt; Fixed<br>&gt;<br>&gt;<br>&gt;&gt; - the proposal should mention Brent&#39;s comments since it doesn&#39;t have a<br>&gt;&gt; rebuttal to the &quot;unlikely&quot; status generic protocols were given in the<br>&gt;&gt; generic manifesto. Brent does a great job of doing that<br>&gt;&gt;<br>&gt;<br>&gt; Added a bold link<br>&gt;<br>&gt;<br>&gt;&gt; - is there a way for generic protocols to still have associated types? I<br>&gt;&gt; think that could have some interesting use cases.<br>&gt;&gt;<br>&gt;<br>&gt; Generic protocols can contain associated types, but no type can conform to<br>&gt; multiple instances of such protocols.<br>&gt;<br>&gt; Actually, this limitation is more restricting than it seems, because if<br>&gt; our protocol conforms to a protocol with associated type requirements, then<br>&gt; we still can&#39;t conform to our protocol multiple times.<br>&gt;<br>&gt;<br>&gt;&gt; Dan Appel<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 12, 2016 at 11:28 AM Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt; Yes, everything that works on generic types should work for generic<br>&gt;&gt;&gt; protocols. I&#39;ll add that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What won&#39;t work is declaring that  MyComparable : Comparable  iff  T ==<br>&gt;&gt;&gt; Self. The same won&#39;t work for current non-generic protocols as well.<br>&gt;&gt;&gt; Although that feature is highly requested, it is discussed in a separate<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2016-06-12 21:16 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Jun 12, 2016 at 8:01 AM, Антон Жилин &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve prepared a proper draft:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When you propose this:<br>&gt;&gt;&gt;&gt; Syntax in protocol extensions<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol MyComparable&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   func &lt; (left: Self, right: T)<br>&gt;&gt;&gt;&gt; }extension MyComparable {<br>&gt;&gt;&gt;&gt;   func &gt; (left: T, right: Self) {<br>&gt;&gt;&gt;&gt;     return right &lt; left<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Would it be possible for me to write something like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; extension MyComparable&lt;T : SignedNumber&gt; { ... }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dan Appel<br>&gt;&gt;<br>&gt; --<br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/a6f8dfdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June 13, 2016 at 12:00:00am</p></header><div class="content"><p>Right. If associated type has the same value for both conformances, then<br>everything should be fine. Fixed that example.<br></p><p>- Anton<br></p><p>2016-06-13 0:15 GMT+03:00 Dan Appel &lt;dan.appel00 at gmail.com&gt;:<br></p><p>&gt; &gt;if our protocol conforms to a protocol with associated type requirements,<br>&gt; then we still can&#39;t conform to our protocol multiple times.<br>&gt;<br>&gt; I don&#39;t think so:<br>&gt;<br>&gt; protocol A {<br>&gt;<br>&gt;     associatedtype TypeA<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; protocol B&lt;TypeB&gt;: A {<br>&gt;<br>&gt;     func convert(from: TypeB) -&gt; TypeA<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct C: A {<br>&gt;<br>&gt;     typealias TypeA = String<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension C: B&lt;Int&gt; {<br>&gt;<br>&gt;     func convert(from int: Int) -&gt; String {<br>&gt;<br>&gt;         return String(int)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension C: B&lt;Double&gt; {<br>&gt;<br>&gt;     func convert(from double: Double) -&gt; String {<br>&gt;<br>&gt;         return String(double)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Seems to me like the above should work fine: the associated type is<br>&gt; declared once, but the generic protocol is conformed to multiple times.<br>&gt;<br>&gt; On Sun, Jun 12, 2016 at 1:22 PM Антон Жилин &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Copy of link to the proposal:<br>&gt;&gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;&gt;<br>&gt;&gt; Inline:<br>&gt;&gt;<br>&gt;&gt; 2016-06-12 21:51 GMT+03:00 Dan Appel &lt;dan.appel00 at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; Awesome that you guys started this! I&#39;ve been meaning to pitch it for a<br>&gt;&gt;&gt; while. Couple notes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - in the motivation, you&#39;re conforming to SequenceType while defining a<br>&gt;&gt;&gt; From protocol (just a typo I think)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Fixed<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; - the proposal should mention Brent&#39;s comments since it doesn&#39;t have a<br>&gt;&gt;&gt; rebuttal to the &quot;unlikely&quot; status generic protocols were given in the<br>&gt;&gt;&gt; generic manifesto. Brent does a great job of doing that<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Added a bold link<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; - is there a way for generic protocols to still have associated types? I<br>&gt;&gt;&gt; think that could have some interesting use cases.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Generic protocols can contain associated types, but no type can conform<br>&gt;&gt; to multiple instances of such protocols.<br>&gt;&gt;<br>&gt;&gt; Actually, this limitation is more restricting than it seems, because if<br>&gt;&gt; our protocol conforms to a protocol with associated type requirements, then<br>&gt;&gt; we still can&#39;t conform to our protocol multiple times.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Jun 12, 2016 at 11:28 AM Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt; Yes, everything that works on generic types should work for generic<br>&gt;&gt;&gt;&gt; protocols. I&#39;ll add that.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What won&#39;t work is declaring that  MyComparable : Comparable  iff  T ==<br>&gt;&gt;&gt;&gt; Self. The same won&#39;t work for current non-generic protocols as well.<br>&gt;&gt;&gt;&gt; Although that feature is highly requested, it is discussed in a<br>&gt;&gt;&gt;&gt; separate proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2016-06-12 21:16 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sun, Jun 12, 2016 at 8:01 AM, Антон Жилин &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve prepared a proper draft:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; When you propose this:<br>&gt;&gt;&gt;&gt;&gt; Syntax in protocol extensions<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; protocol MyComparable&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;   func &lt; (left: Self, right: T)<br>&gt;&gt;&gt;&gt;&gt; }extension MyComparable {<br>&gt;&gt;&gt;&gt;&gt;   func &gt; (left: T, right: Self) {<br>&gt;&gt;&gt;&gt;&gt;     return right &lt; left<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Would it be possible for me to write something like:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; extension MyComparable&lt;T : SignedNumber&gt; { ... }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt; Dan Appel<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/474ac1b2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 12, 2016 at 04:00:00pm</p></header><div class="content"><p>+1<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 12, 2016, at 08:01, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve prepared a proper draft:<br>&gt; <br>&gt; https://github.com/Anton3/swift-evolution/blob/generic-protocols/proposals/NNNN-generic-protocols.md<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; 2016-06-10 17:18 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt; &gt; FWIW they&#39;re marked as &#39;unlikely&#39; here: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It would probably be useful to have counterarguments against the points raised in that document if you want to prepare a proposal.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s my counterargument.<br>&gt;&gt; <br>&gt;&gt;         * * *<br>&gt;&gt; <br>&gt;&gt; Firstly, I think they&#39;re underestimating the feature&#39;s utility. Generic protocols (real generic protocols, not Sequence&lt;Element&gt;) are already needed to make several existing or likely future features work better. For instance:<br>&gt;&gt; <br>&gt;&gt; * Pattern matching<br>&gt;&gt; <br>&gt;&gt; Currently, if you want to customize your type&#39;s behavior in a `switch` statement, you do it in an ad hoc, almost Objective-C-like way: You define a free `~=` operator and the compiler resolves the overloads to magically find and use it. There is no way to constrain a generic parameter to &quot;only types that can pattern match against type X&quot;, which seems like a pretty useful thing to offer. For instance, in the past people have suggested some sort of expression-based switch alternative. The lack of a pattern matching protocol makes this impossible to implement in either the standard library or your own code.<br>&gt;&gt; <br>&gt;&gt; If we had generic protocols, we could define a protocol for this matching operator and fix the issue:<br>&gt;&gt; <br>&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;                 return lhs == rhs<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; Then you could write, for instance, a PatternDictionary which took patterns instead of keys and, when subscripted, matched the key against each pattern until it found a matching one, then returned the corresponding value.<br>&gt;&gt; <br>&gt;&gt; * String interpolation<br>&gt;&gt; <br>&gt;&gt; Currently, StringInterpolationConvertible only offers an `init&lt;T&gt;(stringInterpolationSegment: T)` initializer. That means you absolutely *must* permit any type to be interpolated into your type&#39;s string literals. This blocks certain important use cases, like a `LocalizedString` type which requires all strings it interacts with to pass through a localization API, from being statically checked. It also would normally require any type-specific behavior to be performed through runtime tests, but just as in `~=`, the Swift compiler applies compile-time magic to escape this restriction—you can write an `init(stringInterpolationSegment:)` with a concrete type, and that will be preferred over the generic one.<br>&gt;&gt; <br>&gt;&gt; In theory, it should be possible in current Swift to redefine StringInterpolationConvertible to allow you to restrict the interpolatable values by doing something like this:<br>&gt;&gt; <br>&gt;&gt;         protocol StringInterpolationConvertible {<br>&gt;&gt;                 associatedtype Interpolatable = Any<br>&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; (This is no longer generic because I believe Interpolatable would have to be somehow constrained to only protocol types to make that work. But you get the idea.)<br>&gt;&gt; <br>&gt;&gt; However, in many uses, developers will want to support interpolation of many custom types which do not share a common supertype. For instance, LocalizedString might want to support interpolation of any LocalizedString, Date, Integer, or FloatingPoint number. However, since Integer and FloatingPoint are protocols, you cannot use an extension to make them retroactively conform to a common protocol with LocalizedString.<br>&gt;&gt; <br>&gt;&gt; With generic protocols, we could define StringInterpolationConvertible like this:<br>&gt;&gt; <br>&gt;&gt;         protocol StringInterpolationConvertible&lt;Interpolatable&gt; {<br>&gt;&gt;                 init(stringInterpolation: Self...)<br>&gt;&gt;                 init(stringInterpolationSegment expr: Interpolatable)<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; And then say:<br>&gt;&gt; <br>&gt;&gt;         extension LocalizedString: StringInterpolationConvertible&lt;LocalizedString&gt;, StringInterpolationConvertible&lt;Integer&gt;, StringInterpolationConvertible&lt;FloatingPoint&gt; {<br>&gt;&gt;                 init(stringInterpolationSegment expr: LocalizedString) {<br>&gt;&gt;                         self.init()<br>&gt;&gt;                         self.components = expr.components<br>&gt;&gt;                 }<br>&gt;&gt;                 init(stringInterpolationSegment expr: Integer) {<br>&gt;&gt;                         self.init()<br>&gt;&gt;                         self.components.append(.integer(expr))<br>&gt;&gt;                 }<br>&gt;&gt;                 init(stringInterpolationSegment expr: FloatingPoint) {<br>&gt;&gt;                         self.components.append(.floatingPoint(expr))<br>&gt;&gt;                 }<br>&gt;&gt;                 init(stringInterpolation strings: LocalizedString...) {<br>&gt;&gt;                         self.init()<br>&gt;&gt;                         self.components = strings.map { $0.components }.reduce([], combine: +)<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; This example shows an interesting wrinkle: A generic protocol may have requirements which don&#39;t use any of the generic types, so that each of the multiple conformances will require members with identical signatures. When this happens, Swift must only allow the member to be implemented once, with that implementation being shared among all conformances.<br>&gt;&gt; <br>&gt;&gt; * Subtype-supertype relationships<br>&gt;&gt; <br>&gt;&gt; Though not currently implemented, there are long-term plans to permit at least value types to form subtype-supertype relationships with each other. A protocol would be a sensible way to express this behavior:<br>&gt;&gt; <br>&gt;&gt;         protocol Upcastable {<br>&gt;&gt;                 associatedtype Supertype<br>&gt;&gt; <br>&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; However, this would require a type to have only one supertype, which isn&#39;t necessarily appropriate. For instance, we might want a UInt8 to be a subtype of both Int16 and UInt16. For that to work, Upcastable would have to be generic:<br>&gt;&gt; <br>&gt;&gt;         protocol Upcastable&lt;Supertype&gt; {<br>&gt;&gt;                 init?(attemptingCastFrom value: Supertype)<br>&gt;&gt;                 func casting() -&gt; Supertype<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         extension UInt8: Upcastable&lt;Int16&gt;, Upcastable&lt;UInt16&gt; { … }<br>&gt;&gt; <br>&gt;&gt; Without generic protocols, the only way to offer sufficiently flexible subtyping is to offer it as a one-off, ad-hoc feature with special syntax.<br>&gt;&gt; <br>&gt;&gt;         * * *<br>&gt;&gt; <br>&gt;&gt; Secondly, I think the concerns about people trying to use Sequence as a generic protocol aren&#39;t that big a deal. To put it simply: Sequence is *not* a generic protocol. The Swift team controls the definition of Sequence, and we define it to not be generic. If people complain, we explain that generic protocols don&#39;t actually do the right thing for this and that they should use existentials instead. We put it in a FAQ. It&#39;s just not that big a deal.<br>&gt;&gt; <br>&gt;&gt; The real concern is not that people will try to use Sequence as a generic protocol, but that they will try to inappropriately make their own protocols generic. I see this as a more minor issue, but if we&#39;re worried about it, we can address it by changing the mental model to one which doesn&#39;t make it look like a generics feature.<br>&gt;&gt; <br>&gt;&gt; Basically, rather than thinking of this feature as &quot;generic protocols&quot;, it could instead be thought of as &quot;associated type overloading&quot;: a particular associated type can be overloaded, and you can use a `where` clause to select a particular overload. This would have a different syntax but handle the same use cases.<br>&gt;&gt; <br>&gt;&gt; For instance, rather than saying this:<br>&gt;&gt; <br>&gt;&gt;         protocol Matchable&lt;MatchingValue&gt; {<br>&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         protocol Equatable: Matchable&lt;Self&gt; {<br>&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;                 return lhs == rhs<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         extension Range: Equatable, Matchable&lt;Bound&gt; {}<br>&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;: DictionaryLiteralConvertible {<br>&gt;&gt;                 typealias Key = Matchable&lt;Matching&gt;<br>&gt;&gt;                 typealias Value = OutValue<br>&gt;&gt; <br>&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns = DictionaryLiteral(pairs) }<br>&gt;&gt; <br>&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;                                         return value<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         return nil<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; You could instead say:<br>&gt;&gt; <br>&gt;&gt;         protocol Matchable {<br>&gt;&gt;                 @overloadable associatedtype MatchingValue<br>&gt;&gt;                 func ~= (pattern: Self, value: MatchingValue) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         protocol Equatable: Matchable where MatchingValue |= Self {<br>&gt;&gt;                 func == (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;                 return lhs == rhs<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         extension Range: Equatable, Matchable {<br>&gt;&gt;                 typealias MatchingValue |= Bound<br>&gt;&gt;         }<br>&gt;&gt;         func ~= &lt;Bound: Comparable&gt;(pattern: Range&lt;Bound&gt;, value: Bound) -&gt; Bool {<br>&gt;&gt;                 return pattern.lowerBound &lt;= value &amp;&amp; value &lt; pattern.upperBound<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         struct PatternDictionary&lt;Matching, Value&gt;: DictionaryLiteralConvertible {<br>&gt;&gt;                 typealias Key = Any&lt;Matchable where .MatchingValue &amp; Matching&gt;<br>&gt;&gt;                 typealias Value = Value<br>&gt;&gt; <br>&gt;&gt;                 var patterns: DictionaryLiteral&lt;Key, Value&gt;<br>&gt;&gt;                 init(dictionaryLiteral pairs: (Key, Value)...) { patterns = DictionaryLiteral(pairs) }<br>&gt;&gt; <br>&gt;&gt;                 subscript(matchingValue: Matching) -&gt; Value? {<br>&gt;&gt;                         for (pattern, value) in patterns {<br>&gt;&gt;                                 if pattern ~= matchingValue {<br>&gt;&gt;                                         return value<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         return nil<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; (Is `MatchingValue |= Bound` a union type feature? I&#39;m not sure. It does have the syntax of one, but there&#39;s a separate overload for each type, so I don&#39;t think it really acts like one.)<br>&gt;&gt; <br>&gt;&gt; This is very nearly the same feature, but presented with different syntax—effectively with a different metaphor. That should prevent it from being abused the way the core team fears it will be.<br>&gt;&gt; <br>&gt;&gt; (One difference is that this version permits &quot;vacuous&quot; conformances: in theory, there&#39;s no reason you couldn&#39;t conform to a protocol with an `@overloadable associatedtype` and define zero types. On the other hand, that&#39;s not necessarily *wrong*, and might even be useful in some cases.)<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/04e23467/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  9, 2016 at 05:00:00pm</p></header><div class="content"><p>I like the idea as associatedtype is playing the role of generic type and <br>in extension we conforms to the protocol with some specific generic type as <br>associated type.<br></p><p>I mean the first idea probably could be<br>protocol From&lt;T&gt; {<br>      init(_ value: T)<br>  }<br>but &quot;protocols do not allow generic parameters; use associated types <br>instead&quot;, so it seems natural to express concrete type as associated type <br>for protocol in generic syntax &lt;Type&gt;<br></p><p>Probably alternative syntax could look like:<br></p><p>extension Int : From where .FromType = Float { }<br></p><p>Also, it seems like this proposal could help to solve a problem with the <br>same name of associated type in different protocols:<br></p><p>protocol One {<br>      associatedtype Element<br>      func foo(t: Element)<br>  }<br></p><p>protocol Two {<br>      associatedtype Element<br>      func bar(t: Element)<br>  }<br></p><p>struct OneTwo : One, Two {<br>     func foo(t: Int) {}<br>     func bar(t: String) {}<br>}<br>// type &#39;OneTwo&#39; does not conform to protocol &#39;Two&#39;<br>// candidate has non-matching type &#39;(t: String) -&gt; ()&#39; [with Element = Element]<br></p><p>So, as I understand, will be possible<br>struct OneTwo : One, Two&lt;String&gt; {<br>     func foo(t: Int) {} // OneTwo.Element will be Int<br>     func bar(t: String) {}<br>}<br></p><p>On 08.06.2016 22:07, Антон Жилин via swift-evolution wrote:<br>&gt; ==Motivation==<br>&gt;<br>&gt; protocol From {<br>&gt;     associatedtype FromType<br>&gt;     init(_ value: FromType)<br>&gt; }<br>&gt;<br>&gt; The problem is, one type cannot implement multiple From &quot;conversions&quot;.<br>&gt;<br>&gt; ==Proposed solution==<br>&gt;<br>&gt; Allow specifying all associated types using generic syntax.<br>&gt;<br>&gt; extension Int : From&lt;Float&gt; { }<br>&gt; extension Int : From&lt;Double&gt; { }<br>&gt;<br>&gt; This is only allowed in conformance declarations.<br>&gt;<br>&gt; ==Future directions==<br>&gt;<br>&gt; We can replace all *Convertible protocols with From and Into, which will be<br>&gt; defined similarly to Rust.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  9, 2016 at 06:00:00pm</p></header><div class="content"><p>A problem with my solution is that there is a conflict between<br>associatedtype declarations inherited from From&lt;Int&gt; and From&lt;Double&gt;.<br>Or in your example, associatedtype Element = Int  and  associatedtype<br>Element = String  are in conflict.<br>Another example:<br></p><p>protocol Computer {<br>    associatedtype Internal<br>    mutable func prepare() -&gt; Internal<br>    mutable func compute(input: Internal)<br>}<br></p><p>extension MyType : Computer&lt;Int&gt; { }<br>extension MyType : Computer&lt;Double&gt; { }<br></p><p>func test&lt;T: Computer&gt;(input: inout T) {<br>    let internal: T.Internal = input.prepare()<br>    input.compute(internal)<br>}<br></p><p>What is T.Internal , Int or Double? I showed the problem very eplicitly,<br>but it would exist hidden in a much greater number of cases.<br></p><p>It&#39;s not that such resolution is impossible, but solution of Chris does not<br>have this problem at all: generic types do not create associated type<br>requirements.<br>In this case, there is no ambiguity:<br></p><p>protocol Computer&lt;Internal&gt; {<br>    mutable func prepare() -&gt; Internal<br>    mutable func compute(input: Internal)<br>}<br></p><p>extension MyType : Computer&lt;Int&gt; { }<br>extension MyType : Computer&lt;Double&gt; { }<br></p><p>func test&lt;I, T: Computer&lt;I&gt;&gt;(input: inout T) {<br>    let internal: I = input.prepare()<br>    input.compute(internal)<br>}<br></p><p>test(MyType() as Computer&lt;Int&gt;)  // no ambiguity<br>test(MyType() as Computer&lt;Double&gt;)  // no ambiguity<br></p><p>- Anton<br></p><p>2016-06-09 17:25 GMT+03:00 Vladimir.S &lt;svabox at gmail.com&gt;:<br></p><p>&gt; I like the idea as associatedtype is playing the role of generic type and<br>&gt; in extension we conforms to the protocol with some specific generic type as<br>&gt; associated type.<br>&gt;<br>&gt; I mean the first idea probably could be<br>&gt; protocol From&lt;T&gt; {<br>&gt;      init(_ value: T)<br>&gt;  }<br>&gt; but &quot;protocols do not allow generic parameters; use associated types<br>&gt; instead&quot;, so it seems natural to express concrete type as associated type<br>&gt; for protocol in generic syntax &lt;Type&gt;<br>&gt;<br>&gt; Probably alternative syntax could look like:<br>&gt;<br>&gt; extension Int : From where .FromType = Float { }<br>&gt;<br>&gt; Also, it seems like this proposal could help to solve a problem with the<br>&gt; same name of associated type in different protocols:<br>&gt;<br>&gt; protocol One {<br>&gt;      associatedtype Element<br>&gt;      func foo(t: Element)<br>&gt;  }<br>&gt;<br>&gt; protocol Two {<br>&gt;      associatedtype Element<br>&gt;      func bar(t: Element)<br>&gt;  }<br>&gt;<br>&gt; struct OneTwo : One, Two {<br>&gt;     func foo(t: Int) {}<br>&gt;     func bar(t: String) {}<br>&gt; }<br>&gt; // type &#39;OneTwo&#39; does not conform to protocol &#39;Two&#39;<br>&gt; // candidate has non-matching type &#39;(t: String) -&gt; ()&#39; [with Element =<br>&gt; Element]<br>&gt;<br>&gt; So, as I understand, will be possible<br>&gt; struct OneTwo : One, Two&lt;String&gt; {<br>&gt;     func foo(t: Int) {} // OneTwo.Element will be Int<br>&gt;     func bar(t: String) {}<br>&gt;<br>&gt; }<br>&gt;<br>&gt; On 08.06.2016 22:07, Антон Жилин via swift-evolution wrote:<br>&gt;<br>&gt;&gt; ==Motivation==<br>&gt;&gt;<br>&gt;&gt; protocol From {<br>&gt;&gt;     associatedtype FromType<br>&gt;&gt;     init(_ value: FromType)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The problem is, one type cannot implement multiple From &quot;conversions&quot;.<br>&gt;&gt;<br>&gt;&gt; ==Proposed solution==<br>&gt;&gt;<br>&gt;&gt; Allow specifying all associated types using generic syntax.<br>&gt;&gt;<br>&gt;&gt; extension Int : From&lt;Float&gt; { }<br>&gt;&gt; extension Int : From&lt;Double&gt; { }<br>&gt;&gt;<br>&gt;&gt; This is only allowed in conformance declarations.<br>&gt;&gt;<br>&gt;&gt; ==Future directions==<br>&gt;&gt;<br>&gt;&gt; We can replace all *Convertible protocols with From and Into, which will<br>&gt;&gt; be<br>&gt;&gt; defined similarly to Rust.<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/c3dca7a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  9, 2016 at 06:00:00pm</p></header><div class="content"><p>Hmm.. In case we *can* have generic `protocol Computer*&lt;Internal&gt;*{..}` - <br>then yes, it seems like a best solution(generic protocols and using of <br>generic types).<br></p><p>As for hypothetical solution without generic protocol, then we need to <br>separate two `Internal` assotiated types (i.e. separate implementation of <br>Computer(Internal=Int) and Computer(Internal=Double) protocols).  I.e. it <br>seems like the same protocol with different assotiated type should be <br>treated as different protocol.<br></p><p> &gt; func test&lt;T: Computer&gt;(input: inout T) {<br> &gt;     let internal: T.Internal = input.prepare()<br> &gt;     input.compute(internal)<br> &gt; }<br> &gt;<br> &gt; What is T.Internal , Int or Double? I showed the problem very eplicitly,<br> &gt; but it would exist hidden in a much greater number of cases.<br></p><p>As I see the situation: our type implemented two protocols, one Computer <br>with Internal = Int, and second with Internal = Double. So, in case we <br>*can* implement the same protocol with different assotiated types - we <br>*must* have a requirement and the ability to separate these implementation <br>*before* calling this func.<br>I.e. we should be forced to call `test` simething like this:<br></p><p>test(MyType() as Computer where .Internal = Int)<br>// just MyType() will produce something like &quot;multiply conformance to <br>Computer with different assotiated types, need explicit cast to one of <br>concrete implementation&quot;<br></p><p>This is just abstract thoughts with abstract syntax, don&#39;t know if there is <br>something useful in them at all :-)<br></p><p>On 09.06.2016 18:01, Антон Жилин wrote:<br>&gt; A problem with my solution is that there is a conflict between<br>&gt; associatedtype declarations inherited from From&lt;Int&gt; and From&lt;Double&gt;.<br>&gt; Or in your example, associatedtype Element = Int  and  associatedtype<br>&gt; Element = String  are in conflict.<br>&gt; Another example:<br>&gt;<br>&gt; protocol Computer {<br>&gt;     associatedtype Internal<br>&gt;     mutable func prepare() -&gt; Internal<br>&gt;     mutable func compute(input: Internal)<br>&gt; }<br>&gt;<br>&gt; extension MyType : Computer&lt;Int&gt; { }<br>&gt; extension MyType : Computer&lt;Double&gt; { }<br>&gt;<br>&gt; func test&lt;T: Computer&gt;(input: inout T) {<br>&gt;     let internal: T.Internal = input.prepare()<br>&gt;     input.compute(internal)<br>&gt; }<br>&gt;<br>&gt; What is T.Internal , Int or Double? I showed the problem very eplicitly,<br>&gt; but it would exist hidden in a much greater number of cases.<br>&gt;<br>&gt; It&#39;s not that such resolution is impossible, but solution of Chris does not<br>&gt; have this problem at all: generic types do not create associated type<br>&gt; requirements.<br>&gt; In this case, there is no ambiguity:<br>&gt;<br>&gt; protocol Computer&lt;Internal&gt; {<br>&gt;     mutable func prepare() -&gt; Internal<br>&gt;     mutable func compute(input: Internal)<br>&gt; }<br>&gt;<br>&gt; extension MyType : Computer&lt;Int&gt; { }<br>&gt; extension MyType : Computer&lt;Double&gt; { }<br>&gt;<br>&gt; func test&lt;I, T: Computer&lt;I&gt;&gt;(input: inout T) {<br>&gt;     let internal: I = input.prepare()<br>&gt;     input.compute(internal)<br>&gt; }<br>&gt;<br>&gt; test(MyType() as Computer&lt;Int&gt;)  // no ambiguity<br>&gt; test(MyType() as Computer&lt;Double&gt;)  // no ambiguity<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; 2016-06-09 17:25 GMT+03:00 Vladimir.S &lt;svabox at gmail.com<br>&gt; &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;<br>&gt;     I like the idea as associatedtype is playing the role of generic type<br>&gt;     and in extension we conforms to the protocol with some specific generic<br>&gt;     type as associated type.<br>&gt;<br>&gt;     I mean the first idea probably could be<br>&gt;     protocol From&lt;T&gt; {<br>&gt;          init(_ value: T)<br>&gt;      }<br>&gt;     but &quot;protocols do not allow generic parameters; use associated types<br>&gt;     instead&quot;, so it seems natural to express concrete type as associated<br>&gt;     type for protocol in generic syntax &lt;Type&gt;<br>&gt;<br>&gt;     Probably alternative syntax could look like:<br>&gt;<br>&gt;     extension Int : From where .FromType = Float { }<br>&gt;<br>&gt;     Also, it seems like this proposal could help to solve a problem with<br>&gt;     the same name of associated type in different protocols:<br>&gt;<br>&gt;     protocol One {<br>&gt;          associatedtype Element<br>&gt;          func foo(t: Element)<br>&gt;      }<br>&gt;<br>&gt;     protocol Two {<br>&gt;          associatedtype Element<br>&gt;          func bar(t: Element)<br>&gt;      }<br>&gt;<br>&gt;     struct OneTwo : One, Two {<br>&gt;         func foo(t: Int) {}<br>&gt;         func bar(t: String) {}<br>&gt;     }<br>&gt;     // type &#39;OneTwo&#39; does not conform to protocol &#39;Two&#39;<br>&gt;     // candidate has non-matching type &#39;(t: String) -&gt; ()&#39; [with Element =<br>&gt;     Element]<br>&gt;<br>&gt;     So, as I understand, will be possible<br>&gt;     struct OneTwo : One, Two&lt;String&gt; {<br>&gt;         func foo(t: Int) {} // OneTwo.Element will be Int<br>&gt;         func bar(t: String) {}<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     On 08.06.2016 22:07, Антон Жилин via swift-evolution wrote:<br>&gt;<br>&gt;         ==Motivation==<br>&gt;<br>&gt;         protocol From {<br>&gt;             associatedtype FromType<br>&gt;             init(_ value: FromType)<br>&gt;         }<br>&gt;<br>&gt;         The problem is, one type cannot implement multiple From &quot;conversions&quot;.<br>&gt;<br>&gt;         ==Proposed solution==<br>&gt;<br>&gt;         Allow specifying all associated types using generic syntax.<br>&gt;<br>&gt;         extension Int : From&lt;Float&gt; { }<br>&gt;         extension Int : From&lt;Double&gt; { }<br>&gt;<br>&gt;         This is only allowed in conformance declarations.<br>&gt;<br>&gt;         ==Future directions==<br>&gt;<br>&gt;         We can replace all *Convertible protocols with From and Into, which<br>&gt;         will be<br>&gt;         defined similarly to Rust.<br>&gt;<br>&gt;         - Anton<br>&gt;<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Allow multiple conformances to the same protocol</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>When I said that the problem would exist internally, I meant that there<br>would still be two conflicting associatedtype declarations inside MyType.<br>This can be perfectly solved by conformance-with-renaming. Example:<br></p><p>extension MyType : Computer {<br>    from Computer rename Internal to Internal1<br>    associatedtype Internal1 = Int<br>}<br>extension MyType : Computer {<br>    from Computer rename Internal to Internal2<br>    associatedtype Internal2 = Double<br>}<br></p><p>Then MyType should play well both in contexts of  T: Computer where<br>Internal == Int  and  T: Computer where Internal == Double.<br></p><p>It potentially convers a broad range of conflicts, such as conflicting<br>functions and conflicting properties.<br>We could include composition operations of traits in Swift&#39;s protocols,<br>most notably, rename and exclude.<br>Niall Young &lt;niall at iinet.net.au&gt; is working on this problem, but his<br>proposal is going to add new separate &quot;trait&quot; declarations for that, a<br>decision which I don&#39;t quite understand.<br></p><p>And still I think I&#39;ll propose generic protocols if noone does that before.<br></p><p>- Anton<br></p><p>2016-06-09 18:37 GMT+03:00 Vladimir.S &lt;svabox at gmail.com&gt;:<br></p><p>&gt; Hmm.. In case we *can* have generic `protocol Computer*&lt;Internal&gt;*{..}` -<br>&gt; then yes, it seems like a best solution(generic protocols and using of<br>&gt; generic types).<br>&gt;<br>&gt; As for hypothetical solution without generic protocol, then we need to<br>&gt; separate two `Internal` assotiated types (i.e. separate implementation of<br>&gt; Computer(Internal=Int) and Computer(Internal=Double) protocols).  I.e. it<br>&gt; seems like the same protocol with different assotiated type should be<br>&gt; treated as different protocol.<br>&gt;<br>&gt; &gt; func test&lt;T: Computer&gt;(input: inout T) {<br>&gt; &gt;     let internal: T.Internal = input.prepare()<br>&gt; &gt;     input.compute(internal)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; What is T.Internal , Int or Double? I showed the problem very eplicitly,<br>&gt; &gt; but it would exist hidden in a much greater number of cases.<br>&gt;<br>&gt; As I see the situation: our type implemented two protocols, one Computer<br>&gt; with Internal = Int, and second with Internal = Double. So, in case we<br>&gt; *can* implement the same protocol with different assotiated types - we<br>&gt; *must* have a requirement and the ability to separate these implementation<br>&gt; *before* calling this func.<br>&gt; I.e. we should be forced to call `test` simething like this:<br>&gt;<br>&gt; test(MyType() as Computer where .Internal = Int)<br>&gt; // just MyType() will produce something like &quot;multiply conformance to<br>&gt; Computer with different assotiated types, need explicit cast to one of<br>&gt; concrete implementation&quot;<br>&gt;<br>&gt; This is just abstract thoughts with abstract syntax, don&#39;t know if there<br>&gt; is something useful in them at all :-)<br>&gt;<br>&gt;<br>&gt; On 09.06.2016 18:01, Антон Жилин wrote:<br>&gt;<br>&gt;&gt; A problem with my solution is that there is a conflict between<br>&gt;&gt; associatedtype declarations inherited from From&lt;Int&gt; and From&lt;Double&gt;.<br>&gt;&gt; Or in your example, associatedtype Element = Int  and  associatedtype<br>&gt;&gt; Element = String  are in conflict.<br>&gt;&gt; Another example:<br>&gt;&gt;<br>&gt;&gt; protocol Computer {<br>&gt;&gt;     associatedtype Internal<br>&gt;&gt;     mutable func prepare() -&gt; Internal<br>&gt;&gt;     mutable func compute(input: Internal)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension MyType : Computer&lt;Int&gt; { }<br>&gt;&gt; extension MyType : Computer&lt;Double&gt; { }<br>&gt;&gt;<br>&gt;&gt; func test&lt;T: Computer&gt;(input: inout T) {<br>&gt;&gt;     let internal: T.Internal = input.prepare()<br>&gt;&gt;     input.compute(internal)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; What is T.Internal , Int or Double? I showed the problem very eplicitly,<br>&gt;&gt; but it would exist hidden in a much greater number of cases.<br>&gt;&gt;<br>&gt;&gt; It&#39;s not that such resolution is impossible, but solution of Chris does<br>&gt;&gt; not<br>&gt;&gt; have this problem at all: generic types do not create associated type<br>&gt;&gt; requirements.<br>&gt;&gt; In this case, there is no ambiguity:<br>&gt;&gt;<br>&gt;&gt; protocol Computer&lt;Internal&gt; {<br>&gt;&gt;     mutable func prepare() -&gt; Internal<br>&gt;&gt;     mutable func compute(input: Internal)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension MyType : Computer&lt;Int&gt; { }<br>&gt;&gt; extension MyType : Computer&lt;Double&gt; { }<br>&gt;&gt;<br>&gt;&gt; func test&lt;I, T: Computer&lt;I&gt;&gt;(input: inout T) {<br>&gt;&gt;     let internal: I = input.prepare()<br>&gt;&gt;     input.compute(internal)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; test(MyType() as Computer&lt;Int&gt;)  // no ambiguity<br>&gt;&gt; test(MyType() as Computer&lt;Double&gt;)  // no ambiguity<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;<br>&gt;&gt; 2016-06-09 17:25 GMT+03:00 Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     I like the idea as associatedtype is playing the role of generic type<br>&gt;&gt;     and in extension we conforms to the protocol with some specific<br>&gt;&gt; generic<br>&gt;&gt;     type as associated type.<br>&gt;&gt;<br>&gt;&gt;     I mean the first idea probably could be<br>&gt;&gt;     protocol From&lt;T&gt; {<br>&gt;&gt;          init(_ value: T)<br>&gt;&gt;      }<br>&gt;&gt;     but &quot;protocols do not allow generic parameters; use associated types<br>&gt;&gt;     instead&quot;, so it seems natural to express concrete type as associated<br>&gt;&gt;     type for protocol in generic syntax &lt;Type&gt;<br>&gt;&gt;<br>&gt;&gt;     Probably alternative syntax could look like:<br>&gt;&gt;<br>&gt;&gt;     extension Int : From where .FromType = Float { }<br>&gt;&gt;<br>&gt;&gt;     Also, it seems like this proposal could help to solve a problem with<br>&gt;&gt;     the same name of associated type in different protocols:<br>&gt;&gt;<br>&gt;&gt;     protocol One {<br>&gt;&gt;          associatedtype Element<br>&gt;&gt;          func foo(t: Element)<br>&gt;&gt;      }<br>&gt;&gt;<br>&gt;&gt;     protocol Two {<br>&gt;&gt;          associatedtype Element<br>&gt;&gt;          func bar(t: Element)<br>&gt;&gt;      }<br>&gt;&gt;<br>&gt;&gt;     struct OneTwo : One, Two {<br>&gt;&gt;         func foo(t: Int) {}<br>&gt;&gt;         func bar(t: String) {}<br>&gt;&gt;     }<br>&gt;&gt;     // type &#39;OneTwo&#39; does not conform to protocol &#39;Two&#39;<br>&gt;&gt;     // candidate has non-matching type &#39;(t: String) -&gt; ()&#39; [with Element =<br>&gt;&gt;     Element]<br>&gt;&gt;<br>&gt;&gt;     So, as I understand, will be possible<br>&gt;&gt;     struct OneTwo : One, Two&lt;String&gt; {<br>&gt;&gt;         func foo(t: Int) {} // OneTwo.Element will be Int<br>&gt;&gt;         func bar(t: String) {}<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     On 08.06.2016 22:07, Антон Жилин via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;         ==Motivation==<br>&gt;&gt;<br>&gt;&gt;         protocol From {<br>&gt;&gt;             associatedtype FromType<br>&gt;&gt;             init(_ value: FromType)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         The problem is, one type cannot implement multiple From<br>&gt;&gt; &quot;conversions&quot;.<br>&gt;&gt;<br>&gt;&gt;         ==Proposed solution==<br>&gt;&gt;<br>&gt;&gt;         Allow specifying all associated types using generic syntax.<br>&gt;&gt;<br>&gt;&gt;         extension Int : From&lt;Float&gt; { }<br>&gt;&gt;         extension Int : From&lt;Double&gt; { }<br>&gt;&gt;<br>&gt;&gt;         This is only allowed in conformance declarations.<br>&gt;&gt;<br>&gt;&gt;         ==Future directions==<br>&gt;&gt;<br>&gt;&gt;         We can replace all *Convertible protocols with From and Into,<br>&gt;&gt; which<br>&gt;&gt;         will be<br>&gt;&gt;         defined similarly to Rust.<br>&gt;&gt;<br>&gt;&gt;         - Anton<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/71e0f683/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
