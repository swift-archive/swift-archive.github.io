<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] access control modifier inconsistency</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 17, 2016 at 11:00:00am</p></header><div class="content"><p>I’ve spotted some inconsistency on access control modifier I’d like to discuss in this thread (the behavior is not groundbreaking but inconsistent from readers and developers view perspective).<br></p><p>Why are extensions not marked as public in public apis when the module is imported?<br></p><p>Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br></p><p>Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.<br></p><p>Source: Apple Inc. The Swift Programming Language (Swift 2.2).<br>This does not tell us how the access control modifier works on extensions. Here are three examples:<br>public struct A {}<br>     <br>/* implicitly internal */ extension A {}<br>     <br>// This extension won&#39;t be exported<br>as soon as at least one member modifier of an extension is public (if the extended type allows that and is also public), the extension itself becomes implicitly public:<br>public struct B {}<br>     <br>/* implicitly public */ extension B {<br>         <br>    public func foo() {}     <br>         <br>    /* implicitly internal */ func boo() {}<br>}<br>     <br>// This extension will be exported as<br>     <br>extension B {<br>         <br>    public func foo()<br>}<br>This is inconsistent to other types, because you can not leave out the modifier for instance on classes, then add a public member and assume that your class is implicitly public! The compiler knows that and provides a correct warning that the mentioned class is internal.<br></p><p>public struct C {}<br>     <br>public extension C {<br>         <br>    public func foo() {}     <br>         <br>    /* implicitly internal */ func boo() {}<br>}<br>     <br>// This extension will be exported as<br>     <br>/* public is missing here */ extension C {<br>         <br>    public func foo()<br>}<br>Extensions seem to behave differently and its behaviors is inconsistent and not documented.<br></p><p>protocols has explicit public modifier on its members when the module is imported. However, &#39;public&#39; modifier cannot be used in protocols is how the compiler treat modifiers in protocols on declaration.<br></p><p>public protocol D {<br>         <br>    func doSomething()<br>}<br>Protocol D will be exported as:<br></p><p>public protocol D {<br>         <br>    public func doSomething()<br>}<br>Here is my suggestion:<br></p><p>Fix the behavior for extensions and document it correctly:<br></p><p>public struct B {}<br>     <br>/* implicitly public */ extension B {<br>         <br>    public func foo() {}     <br>         <br>    /* implicitly internal */ func boo() {}<br>}<br>Such an extension should not be implicitly public and behave like other types and stay implicitly internal.<br>The compiler should provide a warning for the foo() function: Declaring a public function for an internal type<br>Extensions should have explicit public modifier like other types if the extension was marked as public and was imported into an other project/module.<br>This inconsistent behavior is source breaking and I’d suggest this change to happen in Swift 3!<br>Remove public modifier from imported protocols OR document this behavior correctly!<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/9cfc7064/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] access control modifier inconsistency</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 19, 2016 at 09:00:00am</p></header><div class="content"><p>One problem I found with the mentioned suggestion of mine is this:<br></p><p>public protocol A {}<br></p><p>public class B {}<br></p><p>// &#39;public&#39; modifier cannot be used with  <br>// extensions that declare protocol conformances<br>public extension B: A {}<br>Why is that like this?<br>Can this be fixed?<br>Implicit public extension feels odd and is inconsistent if you ask me.<br>Any statement to the pitched suggestion?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Juni 2016 um 11:28:18, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I’ve spotted some inconsistency on access control modifier I’d like to discuss in this thread (the behavior is not groundbreaking but inconsistent from readers and developers view perspective).<br></p><p>Why are extensions not marked as public in public apis when the module is imported?<br></p><p>Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br></p><p>Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.<br></p><p>Source: Apple Inc. The Swift Programming Language (Swift 2.2).<br>This does not tell us how the access control modifier works on extensions. Here are three examples:<br>public struct A {}<br>      <br>/* implicitly internal */ extension A {}<br>      <br>// This extension won&#39;t be exported<br>as soon as at least one member modifier of an extension is public (if the extended type allows that and is also public), the extension itself becomes implicitly public:<br>public struct B {}<br>      <br>/* implicitly public */ extension B {<br>          <br>    public func foo() {}      <br>          <br>    /* implicitly internal */ func boo() {}<br>}<br>      <br>// This extension will be exported as<br>      <br>extension B {<br>          <br>    public func foo()<br>}<br>This is inconsistent to other types, because you can not leave out the modifier for instance on classes, then add a public member and assume that your class is implicitly public! The compiler knows that and provides a correct warning that the mentioned class is internal.<br></p><p>public struct C {}<br>      <br>public extension C {<br>          <br>    public func foo() {}      <br>          <br>    /* implicitly internal */ func boo() {}<br>}<br>      <br>// This extension will be exported as<br>      <br>/* public is missing here */ extension C {<br>          <br>    public func foo()<br>}<br>Extensions seem to behave differently and its behaviors is inconsistent and not documented.<br></p><p>protocols has explicit public modifier on its members when the module is imported. However, &#39;public&#39; modifier cannot be used in protocols is how the compiler treat modifiers in protocols on declaration.<br></p><p>public protocol D {<br>          <br>    func doSomething()<br>}<br>Protocol D will be exported as:<br></p><p>public protocol D {<br>          <br>    public func doSomething()<br>}<br>Here is my suggestion:<br></p><p>Fix the behavior for extensions and document it correctly:<br></p><p>public struct B {}<br>      <br>/* implicitly public */ extension B {<br>          <br>    public func foo() {}      <br>          <br>    /* implicitly internal */ func boo() {}<br>}<br>Such an extension should not be implicitly public and behave like other types and stay implicitly internal.<br>The compiler should provide a warning for the foo() function: Declaring a public function for an internal type<br>Extensions should have explicit public modifier like other types if the extension was marked as public and was imported into an other project/module.<br>This inconsistent behavior is source breaking and I’d suggest this change to happen in Swift 3!<br>Remove public modifier from imported protocols OR document this behavior correctly!<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/762af2c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] access control modifier inconsistency</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 20, 2016 at 10:00:00am</p></header><div class="content"><p>Everyone does feel comfortable with implicit public extensions?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. Juni 2016 um 09:18:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>One problem I found with the mentioned suggestion of mine is this:<br></p><p>public protocol A {}<br></p><p>public class B {}<br></p><p>// &#39;public&#39; modifier cannot be used with   <br>// extensions that declare protocol conformances<br>public extension B: A {}<br>Why is that like this?<br>Can this be fixed?<br>Implicit public extension feels odd and is inconsistent if you ask me.<br>Any statement to the pitched suggestion?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Juni 2016 um 11:28:18, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I’ve spotted some inconsistency on access control modifier I’d like to discuss in this thread (the behavior is not groundbreaking but inconsistent from readers and developers view perspective).<br></p><p>Why are extensions not marked as public in public apis when the module is imported?<br></p><p>Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br></p><p>Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.<br></p><p>Source: Apple Inc. The Swift Programming Language (Swift 2.2).<br>This does not tell us how the access control modifier works on extensions. Here are three examples:<br>public struct A {}<br>       <br>/* implicitly internal */ extension A {}<br>       <br>// This extension won&#39;t be exported<br>as soon as at least one member modifier of an extension is public (if the extended type allows that and is also public), the extension itself becomes implicitly public:<br>public struct B {}<br>       <br>/* implicitly public */ extension B {<br>           <br>    public func foo() {}       <br>           <br>    /* implicitly internal */ func boo() {}<br>}<br>       <br>// This extension will be exported as<br>       <br>extension B {<br>           <br>    public func foo()<br>}<br>This is inconsistent to other types, because you can not leave out the modifier for instance on classes, then add a public member and assume that your class is implicitly public! The compiler knows that and provides a correct warning that the mentioned class is internal.<br></p><p>public struct C {}<br>       <br>public extension C {<br>           <br>    public func foo() {}       <br>           <br>    /* implicitly internal */ func boo() {}<br>}<br>       <br>// This extension will be exported as<br>       <br>/* public is missing here */ extension C {<br>           <br>    public func foo()<br>}<br>Extensions seem to behave differently and its behaviors is inconsistent and not documented.<br></p><p>protocols has explicit public modifier on its members when the module is imported. However, &#39;public&#39; modifier cannot be used in protocols is how the compiler treat modifiers in protocols on declaration.<br></p><p>public protocol D {<br>           <br>    func doSomething()<br>}<br>Protocol D will be exported as:<br></p><p>public protocol D {<br>           <br>    public func doSomething()<br>}<br>Here is my suggestion:<br></p><p>Fix the behavior for extensions and document it correctly:<br></p><p>public struct B {}<br>       <br>/* implicitly public */ extension B {<br>           <br>    public func foo() {}       <br>           <br>    /* implicitly internal */ func boo() {}<br>}<br>Such an extension should not be implicitly public and behave like other types and stay implicitly internal.<br>The compiler should provide a warning for the foo() function: Declaring a public function for an internal type<br>Extensions should have explicit public modifier like other types if the extension was marked as public and was imported into an other project/module.<br>This inconsistent behavior is source breaking and I’d suggest this change to happen in Swift 3!<br>Remove public modifier from imported protocols OR document this behavior correctly!<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/85f859d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>[Discussion] access control modifier inconsistency</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>June 20, 2016 at 03:00:00am</p></header><div class="content"><p>I&#39;d strongly favor correcting this inconsistency; I’ve run into it and been confused until I remembered the semantics more than once. I would much prefer always explicitly specifying the access modifier to receive its effect (versus changing the documentation) - in short I agree that extensions should be internal until declared otherwise.<br></p><p>-- Gwynne Raskind<br></p><p>&gt; On Jun 20, 2016, at 03:35, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Everyone does feel comfortable with implicit public extensions?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. Juni 2016 um 09:18:35, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; One problem I found with the mentioned suggestion of mine is this:<br>&gt;&gt; <br>&gt;&gt; public protocol A {}<br>&gt;&gt; <br>&gt;&gt; public class B {}<br>&gt;&gt; <br>&gt;&gt; // &#39;public&#39; modifier cannot be used with   <br>&gt;&gt; // extensions that declare protocol conformances<br>&gt;&gt; public extension B: A {}<br>&gt;&gt; Why is that like this?<br>&gt;&gt; Can this be fixed?<br>&gt;&gt; Implicit public extension feels odd and is inconsistent if you ask me.<br>&gt;&gt; Any statement to the pitched suggestion?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Juni 2016 um 11:28:18, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; I’ve spotted some inconsistency on access control modifier I’d like to discuss in this thread (the behavior is not groundbreaking but inconsistent from readers and developers view perspective).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why are extensions not marked as public in public apis when the module is imported?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Source: Apple Inc. The Swift Programming Language (Swift 2.2).<br>&gt;&gt;&gt; This does not tell us how the access control modifier works on extensions. Here are three examples:<br>&gt;&gt;&gt; public struct A {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* implicitly internal */ extension A {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; // This extension won&#39;t be exported<br>&gt;&gt;&gt; as soon as at least one member modifier of an extension is public (if the extended type allows that and is also public), the extension itself becomes implicitly public:<br>&gt;&gt;&gt; public struct B {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* implicitly public */ extension B {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo() {}       <br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     /* implicitly internal */ func boo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; // This extension will be exported as<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; extension B {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This is inconsistent to other types, because you can not leave out the modifier for instance on classes, then add a public member and assume that your class is implicitly public! The compiler knows that and provides a correct warning that the mentioned class is internal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct C {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; public extension C {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo() {}       <br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     /* implicitly internal */ func boo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; // This extension will be exported as<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* public is missing here */ extension C {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Extensions seem to behave differently and its behaviors is inconsistent and not documented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocols has explicit public modifier on its members when the module is imported. However, &#39;public&#39; modifier cannot be used in protocols is how the compiler treat modifiers in protocols on declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol D {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Protocol D will be exported as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol D {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Here is my suggestion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fix the behavior for extensions and document it correctly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct B {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* implicitly public */ extension B {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo() {}       <br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     /* implicitly internal */ func boo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Such an extension should not be implicitly public and behave like other types and stay implicitly internal.<br>&gt;&gt;&gt; The compiler should provide a warning for the foo() function: Declaring a public function for an internal type<br>&gt;&gt;&gt; Extensions should have explicit public modifier like other types if the extension was marked as public and was imported into an other project/module.<br>&gt;&gt;&gt; This inconsistent behavior is source breaking and I’d suggest this change to happen in Swift 3!<br>&gt;&gt;&gt; Remove public modifier from imported protocols OR document this behavior correctly!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/4d21da7a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] access control modifier inconsistency</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 20, 2016 at 11:00:00am</p></header><div class="content"><p>Access control modifier: public &gt; internal == /* implicitly internal */ &gt; fileprivate &gt;= private<br></p><p>//===== TOPLEVEL / File - Scope<br></p><p>//===== some protocols  <br></p><p>public protocol A {<br>     <br>    func aa()  <br>}<br></p><p>private protocol B {<br>     <br>    func bb()  <br>}<br></p><p>fileprivate protocol C {<br>     <br>    func cc()  <br>}<br></p><p>internal protocol D {<br>     <br>    func dd()  <br>}<br></p><p>/* implicitly internal */ protocol E {<br>     <br>    func ee()  <br>}<br></p><p>//===== some types<br></p><p>public struct FF {}<br></p><p>private struct GG {}<br></p><p>fileprivate struct HH {}<br></p><p>internal struct II {}<br></p><p>/* implicitly internal */ struct JJ {}<br></p><p>//===== some extensions<br></p><p>// We should be able to extend it with all protocols: A, B, C, D, E<br>// BUT it depends whether all protocols are visible at this scope<br>// In this example they are visible!<br>//<br>// The compiler should force you to write modifier for: A, B and C<br>// `internal` is always optional<br></p><p>public extension FF: A, B, C, D, E {<br></p><p>    public func aa()<br>     <br>    // Visible in this scope only<br>    private func bb()<br>     <br>    // Visible in this file<br>    fileprivate func cc()<br>     <br>    // Visible for the whole module<br>    // We do not need to write out `internal` here<br>    /* implicitly internal */ func dd()<br>     <br>    // visible for the whole module<br>    /* implicitly internal */ func ee()<br>}<br></p><p>// At top-level `private` is like `fileprivate`<br>private extension FF: A, B, C, D, E {  <br>     <br>    // Same as in `public extension`<br>    // Except everything is `private` (or `fileprivate`)<br>}<br></p><p>fileprivate extension FF: A, B, C, D, E {  <br>     <br>    // Same as in `public extension`<br>    // Except everything is `fileprivate`<br>}<br></p><p>internal extension FF: A, B, C, D, E {  <br>     <br>    // Same as in `public extension`<br>    // Except everything is `internal` or explicitly `private` or `fileprivate`<br>}<br></p><p>/* implicitly internal */ extension FF: A, B, C, D, E {  <br>     <br>    // Same as in `internal extension`<br>}<br></p><p>// For GG, HH, II and JJ we cannot extend these types with a `public` modifier!<br>// GG and HH can&#39;t be extended with `internal` modifier<br>If I missed anything, please let me know.<br></p><p>Protocols should not import an access modifier on their members, because this is a documented rule that we use the modifier from protocols definition.<br></p><p>public protocol A {<br>    var someMember: Type {}<br>}<br></p><p>// SHOULD NOT LOOK LIKE THIS:<br>public protocol A {<br>    public var someMember: Type {}<br>}<br></p><p>// CORRECT VERSION:<br>public protocol A {<br> var someMember: Type {}<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Juni 2016 um 10:35:59, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Everyone does feel comfortable with implicit public extensions?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. Juni 2016 um 09:18:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>One problem I found with the mentioned suggestion of mine is this:<br></p><p>public protocol A {}<br></p><p>public class B {}<br></p><p>// &#39;public&#39; modifier cannot be used with    <br>// extensions that declare protocol conformances<br>public extension B: A {}<br>Why is that like this?<br>Can this be fixed?<br>Implicit public extension feels odd and is inconsistent if you ask me.<br>Any statement to the pitched suggestion?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Juni 2016 um 11:28:18, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I’ve spotted some inconsistency on access control modifier I’d like to discuss in this thread (the behavior is not groundbreaking but inconsistent from readers and developers view perspective).<br></p><p>Why are extensions not marked as public in public apis when the module is imported?<br></p><p>Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br></p><p>Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.<br></p><p>Source: Apple Inc. The Swift Programming Language (Swift 2.2).<br>This does not tell us how the access control modifier works on extensions. Here are three examples:<br>public struct A {}<br>        <br>/* implicitly internal */ extension A {}<br>        <br>// This extension won&#39;t be exported<br>as soon as at least one member modifier of an extension is public (if the extended type allows that and is also public), the extension itself becomes implicitly public:<br>public struct B {}<br>        <br>/* implicitly public */ extension B {<br>            <br>    public func foo() {}        <br>            <br>    /* implicitly internal */ func boo() {}<br>}<br>        <br>// This extension will be exported as<br>        <br>extension B {<br>            <br>    public func foo()<br>}<br>This is inconsistent to other types, because you can not leave out the modifier for instance on classes, then add a public member and assume that your class is implicitly public! The compiler knows that and provides a correct warning that the mentioned class is internal.<br></p><p>public struct C {}<br>        <br>public extension C {<br>            <br>    public func foo() {}        <br>            <br>    /* implicitly internal */ func boo() {}<br>}<br>        <br>// This extension will be exported as<br>        <br>/* public is missing here */ extension C {<br>            <br>    public func foo()<br>}<br>Extensions seem to behave differently and its behaviors is inconsistent and not documented.<br></p><p>protocols has explicit public modifier on its members when the module is imported. However, &#39;public&#39; modifier cannot be used in protocols is how the compiler treat modifiers in protocols on declaration.<br></p><p>public protocol D {<br>            <br>    func doSomething()<br>}<br>Protocol D will be exported as:<br></p><p>public protocol D {<br>            <br>    public func doSomething()<br>}<br>Here is my suggestion:<br></p><p>Fix the behavior for extensions and document it correctly:<br></p><p>public struct B {}<br>        <br>/* implicitly public */ extension B {<br>            <br>    public func foo() {}        <br>            <br>    /* implicitly internal */ func boo() {}<br>}<br>Such an extension should not be implicitly public and behave like other types and stay implicitly internal.<br>The compiler should provide a warning for the foo() function: Declaring a public function for an internal type<br>Extensions should have explicit public modifier like other types if the extension was marked as public and was imported into an other project/module.<br>This inconsistent behavior is source breaking and I’d suggest this change to happen in Swift 3!<br>Remove public modifier from imported protocols OR document this behavior correctly!<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/98808371/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] access control modifier inconsistency</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 10:35 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Everyone does feel comfortable with implicit public extensions?<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. Juni 2016 um 09:18:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt; <br>&gt;&gt; One problem I found with the mentioned suggestion of mine is this:<br>&gt;&gt; <br>&gt;&gt; public protocol A {}<br>&gt;&gt; <br>&gt;&gt; public class B {}<br>&gt;&gt; <br>&gt;&gt; // &#39;public&#39; modifier cannot be used with   <br>&gt;&gt; // extensions that declare protocol conformances<br>&gt;&gt; public extension B: A {}<br>&gt;&gt; Why is that like this?<br>&gt;&gt; Can this be fixed?<br>&gt;&gt; Implicit public extension feels odd and is inconsistent if you ask me.<br></p><p>Doug explained some of the compiler internals as related to protocol conformance on protocols (particularly why private conformance is at this point unlikely). Reading it might give more perspective to the current state. I&#39;m sorry I cannot point to his post exactly, but it did happen in the last 3 weeks.<br></p><p>&gt;&gt; Any statement to the pitched suggestion?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Juni 2016 um 11:28:18, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; I’ve spotted some inconsistency on access control modifier I’d like to discuss in this thread (the behavior is not groundbreaking but inconsistent from readers and developers view perspective).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why are extensions not marked as public in public apis when the module is imported?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Source: Apple Inc. The Swift Programming Language (Swift 2.2).<br>&gt;&gt;&gt; This does not tell us how the access control modifier works on extensions. Here are three examples:<br>&gt;&gt;&gt; public struct A {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* implicitly internal */ extension A {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; // This extension won&#39;t be exported<br>&gt;&gt;&gt; as soon as at least one member modifier of an extension is public (if the extended type allows that and is also public), the extension itself becomes implicitly public:<br>&gt;&gt;&gt; public struct B {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* implicitly public */ extension B {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo() {}       <br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     /* implicitly internal */ func boo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; // This extension will be exported as<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; extension B {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This is inconsistent to other types, because you can not leave out the modifier for instance on classes, then add a public member and assume that your class is implicitly public! The compiler knows that and provides a correct warning that the mentioned class is internal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct C {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; public extension C {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo() {}       <br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     /* implicitly internal */ func boo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; // This extension will be exported as<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* public is missing here */ extension C {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Extensions seem to behave differently and its behaviors is inconsistent and not documented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocols has explicit public modifier on its members when the module is imported. However, &#39;public&#39; modifier cannot be used in protocols is how the compiler treat modifiers in protocols on declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol D {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Protocol D will be exported as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol D {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Here is my suggestion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fix the behavior for extensions and document it correctly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct B {}<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt; /* implicitly public */ extension B {<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     public func foo() {}       <br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;     /* implicitly internal */ func boo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Such an extension should not be implicitly public and behave like other types and stay implicitly internal.<br>&gt;&gt;&gt; The compiler should provide a warning for the foo() function: Declaring a public function for an internal type<br>&gt;&gt;&gt; Extensions should have explicit public modifier like other types if the extension was marked as public and was imported into an other project/module.<br>&gt;&gt;&gt; This inconsistent behavior is source breaking and I’d suggest this change to happen in Swift 3!<br>&gt;&gt;&gt; Remove public modifier from imported protocols OR document this behavior correctly!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/8e3f770d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
