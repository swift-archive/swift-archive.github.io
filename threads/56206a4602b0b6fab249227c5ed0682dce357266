<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>A (better) Swift Equivalent For The Classical For-Loop With Numeric Scalars</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 30, 2016 at 10:00:00pm</p></header><div class="content"><p>I still would like to see this new for-loop statement be implemented in the next Swift version<br></p><p> Examples:<br>     for v from 0.5 to 30.0 by 0.3    // floating point types<br>     for v from 0 to 100 by 5           // Integer<br>     for v from 12.0 to -10.0 by -2  // Floating points backward <br></p><p>the “by …” clause is optional for Ints only <br></p><p><br>As previously written, a tolerance factor could also be implemented as optional,<br>allowing to “end on a humanly accepted boundary” so like in this example<br>the highest loop value would be 10.0 (+/- ca. 0.000000001) , not 9.9 :  <br>  <br> for v from 0.0 to 10.0 by 0.1 tolerance 0.001     <br></p><p>// the “tolerance ..” clause is optional and allowed for floating point vars only<br></p><p><br>Again I need to emphasize very strongly that this for-loop really <br>has absolutely <br>     nothing, nada, zilch, niente, nichts, niets, niks, rien, zero, nenio,<br>to do with the: <br></p><p>for i in stride(…. <br></p><p>or any other for in… variant working with collections.<br></p><p>However inexplicably, in the previous discussions, a lot of people ***<br>tried desperately to replace this simple but precious gem, <br>a miracle of astonishing beauty:           (sorry, got carried away a bit :o) <br>  <br>    for v from v1 to v2 by vstep <br> <br>with the collection based <br></p><p>for in ….<br></p><p>The for in… is wonderful for collection based iterations, I use it <br>all the time like<br>    for thing in things // etc.<br></p><p><br></p><p>for d in 10.0.stride(to: 5.0, by: -0.1)<br>{<br>    print(d)<br>}<br></p><p><br>but, once again - <br>provided you don’t want to do other operations<br>on the generated collection before iterating -  <br>a collection is used here totally unnecessary, <br>which puts a burden on performance because the contents <br>of a collection are unpredictable <br>It is also tedious to write and (as a matter of my personal taste) downright ugly.<br></p><p>Imho this looks a whole lot better and can also be very efficiently compiled: <br></p><p>for d from 10.0 to 5.0 by -0.1 tolerance 0.01<br>{<br>    print(d)<br>}<br></p><p><br>  **************************** !!! **************************************<br>  Important is to see that this “for…”  is in fact<br>  a convenience solution for  “while” and “repeat” constructs: <br>  and thus a totally different beast compared to the   &quot;for in…” ! <br>  *********************************************************************<br>var d = 10.0   <br>var v = 0.0<br>let step = 0.1<br></p><p>while d &gt; 5.0     <br>{ <br>    print(d)<br>    d -= step<br>}<br></p><p><br>The above is a bare minimum “while” equivalent<br>for the above for-loop, but still tedious to write!<br></p><p>What more can I write to convince? <br></p><p><br>*** Please tell me if I am wrong, but: <br>I am inclined to think that Functional Programming Minded<br>Colleagues are trying to push persistently their <br>(mathematically correct?)  way of thinking upon Swift, <br>thereby ignoring that Swift is and should remain a <br>general purpose programming language.<br></p><p><br>TedvG<br>www.ravelnotes.com<br></p><p>@Erica,<br></p><p>Erica, as I seem to remember, You wrote somewhere<br>that Stride is broken, but the &quot;10.0.stride…” example<br>above works perfectly well in Swift 2.2. playground.<br></p><p>So, what do you regard as wrong with it?<br>(apart from in some cases needing to specify an <br>epsilon(tolerance) value? ) <br></p><p><br></p><p>  <br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/56207266/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>A (better) Swift Equivalent For The Classical For-Loop With Numeric Scalars</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>March 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 30 Mar 2016, at 22:05, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Again I need to emphasize very strongly that this for-loop really <br>&gt; has absolutely <br>&gt;      nothing, nada, zilch, niente, nichts, niets, niks, rien, zero, nenio,<br>&gt; to do with the: <br>&gt; <br>&gt; for i in stride(…. <br>&gt; <br>&gt; or any other for in… variant working with collections.<br></p><p>Of course it does. Collection-based for loop can express exactly the same semantics, so why do you need a new construct when you already have a perfectly good one to do the job? <br></p><p>&gt; <br>&gt; but, once again - <br>&gt; provided you don’t want to do other operations<br>&gt; on the generated collection before iterating -  <br>&gt; a collection is used here totally unnecessary, <br>&gt; which puts a burden on performance because the contents <br>&gt; of a collection are unpredictable <br></p><p>I find it quite irritating that you keep repeating these untrue facts. Again: both for loops compile to exactly the same code. <br></p><p>&gt; It is also tedious to write and (as a matter of my personal taste) downright ugly.<br></p><p>Right, because <br></p><p> for d in stride(from:10, to: 5, by: 0-.1, tolerance: 0.01) <br></p><p>is that much more tedious to write than what you propose<br></p><p>Best, <br></p><p> Taras<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/28591ecf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>A (better) Swift Equivalent For The Classical For-Loop With Numeric Scalars</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Grüezi wohl Taras<br></p><p>you wrote:<br></p><p>&gt; I find it quite irritating that you keep repeating these untrue facts. Again: both for loops compile to exactly the same code. <br></p><p><br>Alas, I don’t understand you irritation, <br>but it is your irritation, not mine.<br></p><p>Please note again, that “for ... in …”  always has <br>some sort of collection type as its argument..<br>At run time, the content of a collection <br>is in most cases unpredictable.<br>Ergo: this implies that in these cases,<br>the compiler cannot optimize the collection <br>part of the “for … in …” statement out of the way. <br>In an attempt to overcome this restriction, <br>it would need to analyze all entities that have <br>influenced the content of the collection, <br>which is virtually impossible.<br>     <br>I do not understand your aversion against <br>the for loop I brought forward, as it does not <br>conflict at all with the “for ... in …” construct <br>and probably also does not stand in the way <br>of possible future extensions that could be <br>added to the &quot;for in..” construct. <br></p><p>E.g. For similar reasons one could be irritated by <br>the brave attempts of some of us to supply <br>most peculiar variants of “Strides&quot;, seemingly,<br>at least as seen from my limited perspective,<br>to compensate the loss of the classical for-loop’s<br>facilities...  <br>In spite of all this being very fascinating and <br>creative, to me, this effort is comparable with<br>trying to climb the Eiffel tower, equipped<br>with boxing gloves and diving fins.<br>it could irritate me.. However it does not,<br>for the mere reason that I do not fully <br>understand their motives and logical grounds...<br>Nevertheless, they might -or might not- <br>have good reasons to do so, as we no <br>doubt will find out sooner or later...<br>In any case, this does affect the collection-based<br>“for … in …” only, and has no impact on the <br>“for v from v1 to v2 by vstep” <br>that I am proposing. <br></p><p><br></p><p>&gt; Collection-based for loop can express exactly the same semantics, so why do you need a new construct when you already have a perfectly good one to do the job? <br></p><p><br>For the simple reason that there are no collections involved: <br>I have very clearly described and motivated it. <br>Please read it again, thank you.<br></p><p>By the way, it is not a new construct as it has been<br>existing for decades.<br></p><p>I took the liberty to read about you on the internet. Interesting.<br></p><p>I’ve read that you have a degree in linguistics, <br>which makes me assume that of all people, <br>you’d understand that in most languages <br>there are many different ways to express something,<br>and that the way to express or say something <br>is mostly determined by contextual aspects... <br>So in the light of this very specific knowledge<br>that you have, I fail to understand what your<br>objections are against the presence of <br>two slightly different for-loop variants<br>that can co-exist easily and are effective,<br>each in its own different context?  <br></p><p>Last but not least, you might find this interesting:<br>(although I am almost sure you have read it before)<br></p><p>http://blog.oxforddictionaries.com/2014/09/george-orwell-newspeak/<br></p><p>and then most particularly in this text: <br></p><p>“Newspeak goals and real-world ramifications”<br></p><p>I cannot completely clear myself from the association<br>of this with the removal of certain Swift language <br>elements..<br></p><p><br>Met vriendelijke groeten.<br>TedvG<br></p><p><br> <br></p><p>&gt; On 31.03.2016, at 10:11, Taras Zakharko &lt;taras.zakharko at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 30 Mar 2016, at 22:05, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Again I need to emphasize very strongly that this for-loop really <br>&gt;&gt; has absolutely <br>&gt;&gt;      nothing, nada, zilch, niente, nichts, niets, niks, rien, zero, nenio,<br>&gt;&gt; to do with the: <br>&gt;&gt; <br>&gt;&gt; for i in stride(…. <br>&gt;&gt; <br>&gt;&gt; or any other for in… variant working with collections.<br>&gt; <br>&gt; Of course it does. Collection-based for loop can express exactly the same semantics, so why do you need a new construct when you already have a perfectly good one to do the job? <br>&gt; <br></p><p>&gt;&gt; <br>&gt;&gt; but, once again - <br>&gt;&gt; provided you don’t want to do other operations<br>&gt;&gt; on the generated collection before iterating -  <br>&gt;&gt; a collection is used here totally unnecessary, <br>&gt;&gt; which puts a burden on performance because the contents <br>&gt;&gt; of a collection are unpredictable <br>&gt; <br>&gt; I find it quite irritating that you keep repeating these untrue facts. Again: both for loops compile to exactly the same code. <br>&gt; <br>&gt;&gt; It is also tedious to write and (as a matter of my personal taste) downright ugly.<br>&gt; <br>&gt; Right, because <br>&gt; <br>&gt;  for d in stride(from:10, to: 5, by: 0-.1, tolerance: 0.01) <br>&gt; <br>&gt; is that much more tedious to write than what you propose<br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/f2525c8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>A (better) Swift Equivalent For The Classical For-Loop With Numeric Scalars</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 31 Mar 2016, at 14:12, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Alas, I don’t understand you irritation, <br>&gt; but it is your irritation, not mine.<br></p><p>Well, its quite simple: we are having a discussion here. You are claiming that the collection-based iteration is inherently slower than a classical numerical loop. This is incorrect. I have even sent around some C code that uses different abstractions and shown that it compiles to the same machine code. Yet you are consistently ignoring this. <br></p><p>&gt; Please note again, that “for ... in …”  always has <br>&gt; some sort of collection type as its argument..<br>&gt; At run time, the content of a collection <br>&gt; is in most cases unpredictable.<br></p><p>Again, incorrect. The simple collections that are relevant to this discussion are based on trivial iterators that can be statically dispatched and inlined by the compiler. They can potentially even be unrolled (although I doubt that Swift optimiser does this kind of optimisation currently). Again, the difference between<br></p><p>for(int i = x0; i&lt;x1; i++)<br></p><p>and<br></p><p>for(int i = iterator-&gt;next(); !iterator-&gt;endReached, int i = iterator-&gt;next()) <br></p><p>is just one level of indirection. If the value of iterator-&gt;next() is available at the compile time and the compiler can safely assume that the iterator has a unique reference, the code can be inlined, producing the same loop as above<br></p><p>&gt; E.g. For similar reasons one could be irritated by <br>&gt; the brave attempts of some of us to supply <br>&gt; most peculiar variants of “Strides&quot;, seemingly,<br>&gt; at least as seen from my limited perspective,<br>&gt; to compensate the loss of the classical for-loop’s<br>&gt; facilities…  <br></p><p>I am not at all a fan of the stride() method because they are weird to read. However, a stride() global function will do the job just fine, as shown by the example of such languages as R and Python, which are used quite prominently in the numerical domain (there the functions are called seq() and range() )<br></p><p>&gt; For the simple reason that there are no collections involved: <br>&gt; I have very clearly described and motivated it. <br></p><p>Your description clearly involve numerical sequences. So they perfectly well fall into the domain of sequence-based iteration. <br></p><p>&gt; I took the liberty to read about you on the internet. Interesting.<br></p><p>Thank you, its very flattering :) <br></p><p>&gt; I fail to understand what your<br>&gt; objections are against the presence of <br>&gt; two slightly different for-loop variants<br>&gt; that can co-exist easily and are effective,<br>&gt; each in its own different context?  <br></p><p>In case I didn’t explain my reasoning clear enough, here is another attempt. Swift already has a very powerful, compact tool that offers a strict superset of the iteration semantics. I simply see no purpose into making the language more verbose and complicated for no particular gain. What you do is argue for having two different syntactic styles for accomplishing exactly the same thing, simply on the grounds of your personal dislike of one of them. <br></p><p>Best, <br></p><p> Taras<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>A (better) Swift Equivalent For The Classical For-Loop With Numeric Scalars</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April  5, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Taras<br></p><p>I’ve watched the WWDC15 video about Swift compiler optimization, read some more<br>in depth material about it. It is probably advanced in many aspects of optimization.<br>So, you might be correct to assume that the compiler can optimize<br>&gt;      for(int i = x0; i&lt;x1; i++)<br>(also with floats)<br>and perhaps also for a collection based variant such as:<br></p><p>     for v in stride(from -8.4, to: 3.2, by 0.1)<br></p><p>In any case, I don’t know for sure. I am not a compiler specialist<br>Therefore I void our argument about whether or not the compiler<br>can do enough magic to get it right.<br></p><p>Still, there are no good alternatives for the many advanced possibilities<br>which traditional for loop offers.<br>E.g.<br>In the Apple TV app I am currently working on I had to refactor<br>my for ;; loops with reversing floats with step values to “while” loops!<br></p><p>So, to me the best option is still to bring the for ;; back<br>or to make a new Swift equivalent for it as described here again.<br></p><p>for d from 10.0 to 5.0 by -0.1 tolerance 0.01  //tolerance is optional<br>{<br>    print(d)<br>}<br> <br>-=straight from the front line: =-<br>Because my music maker apps RavelNotes and RavelNotesBasic are still<br>for the most part Objective C sources, I only have to do this in the Swift<br>sources of my apps. <br>Now, I have to refactor (only) about 10 for ;; loops to for in.. loops<br>and have to convert about 10  ++   to +=  things. <br>Luckily, they are all for-loops with integers, so the refactoring <br>itself took less than hour, that was no problem.<br>However, now I have to thoroughly retest everything again, <br>costing me several days or so, before I can submit a <br>new release of my  apps to the app store!!<br>I am still lucky not to work for a company and <br>having to convert a lot more source code.<br>I was considering converting more ObjC to Swift, put<br>put this on halt until Swift stabilizes.<br></p><p>Now, like me, many programmers have to do a <br>whole lot of nasty for-loop refactoring!<br></p><p>Therefore, excuses moi, but currently I can’t help <br>being in a state just somewhere between <br>annoyed and aggravated because I am unnecessarily <br>waisting lots of time  due to some puritan obsessed <br>decisions,  partially from some people with high <br>theoretical knowledge but very little  practical experience, <br>or so it seems.  <br>Don’t get me wrong: <br>Swift is great, e.g. i like the new protocol developments, and of course I understand <br>(and support) that one needs to be very thoughtful about components of the language. <br>But one should be pragmatic as well. <br> -==- <br></p><p>You also wrote:<br></p><p>&gt; In case I didn’t explain my reasoning clear enough, here is another attempt. Swift already has a very powerful, compact tool that offers a strict superset of the iteration semantics.<br>That is not (yet) the case, let alone a superset!<br></p><p>&gt; I simply see no purpose into making the language more verbose and complicated for no particular gain.<br></p><p>It doesn’t make the language more complicated, rather, the reverse is true.<br>If you want a less verbose language, learn APL, or J.<br>APL proves unintentionally the inverse relation between “verbose”and “complicated” :o) <br></p><p>&gt; What you do is argue for having two different syntactic styles for accomplishing exactly the same thing,<br>&gt; simply on the grounds of your personal dislike of one of them. <br>It is not at all personal dislike, it is many years of die-hard experience <br>with a multitude of programming languages and systems.<br>I don’t think in emotional terms about programming constructs but<br>solely about practical implications, usefulness, reliably and so on.<br></p><p>I assume this difference of opinion will remain...<br></p><p>     -----<br>Coincidentally, today John Heerema, described here on swift-evolution <br>exactly my point of view on these matters based on facts. <br>read his text please. Thank you.<br>     -----<br>I hope I am not too unfriendly here, Nothing personal. <br>If I am in Zürich again it would be nice to discuss this with a beer. <br>Although not so far from here, currently my finances prevent this.<br></p><p>Kind regards<br>Ted<br>www.ravelnotes.com<br></p><p>  == The problem is not what you add to a programming language<br>  == but what you remove!<br>  <br></p><p><br></p><p><br></p><p><br></p><p><br>&gt; On 31.03.2016, at 14:59, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 31 Mar 2016, at 14:12, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Alas, I don’t understand you irritation, <br>&gt;&gt; but it is your irritation, not mine.<br>&gt; <br>&gt; Well, its quite simple: we are having a discussion here. You are claiming that the collection-based iteration is inherently slower than a classical numerical loop. This is incorrect. I have even sent around some C code that uses different abstractions and shown that it compiles to the same machine code. Yet you are consistently ignoring this. <br>&gt; <br>&gt;&gt; Please note again, that “for ... in …”  always has <br>&gt;&gt; some sort of collection type as its argument..<br>&gt;&gt; At run time, the content of a collection <br>&gt;&gt; is in most cases unpredictable.<br>&gt; <br>&gt; Again, incorrect. The simple collections that are relevant to this discussion are based on trivial iterators that can be statically dispatched and inlined by the compiler. They can potentially even be unrolled (although I doubt that Swift optimiser does this kind of optimisation currently). Again, the difference between<br>&gt; <br>&gt; for(int i = x0; i&lt;x1; i++)<br>&gt; <br>&gt; and<br>&gt; <br>&gt; for(int i = iterator-&gt;next(); !iterator-&gt;endReached, int i = iterator-&gt;next()) <br>&gt; <br>&gt; is just one level of indirection. If the value of iterator-&gt;next() is available at the compile time and the compiler can safely assume that the iterator has a unique reference, the code can be inlined, producing the same loop as above<br>&gt; <br>&gt;&gt; E.g. For similar reasons one could be irritated by <br>&gt;&gt; the brave attempts of some of us to supply <br>&gt;&gt; most peculiar variants of “Strides&quot;, seemingly,<br>&gt;&gt; at least as seen from my limited perspective,<br>&gt;&gt; to compensate the loss of the classical for-loop’s<br>&gt;&gt; facilities…  <br>&gt; <br>&gt; I am not at all a fan of the stride() method because they are weird to read. However, a stride() global function will do the job just fine, as shown by the example of such languages as R and Python, which are used quite prominently in the numerical domain (there the functions are called seq() and range() )<br>&gt; <br>&gt;&gt; For the simple reason that there are no collections involved: <br>&gt;&gt; I have very clearly described and motivated it. <br>&gt; <br>&gt; Your description clearly involve numerical sequences. So they perfectly well fall into the domain of sequence-based iteration. <br>&gt; <br>&gt;&gt; I took the liberty to read about you on the internet. Interesting.<br>&gt; <br>&gt; Thank you, its very flattering :) <br>&gt; <br>&gt;&gt; I fail to understand what your<br>&gt;&gt; objections are against the presence of <br>&gt;&gt; two slightly different for-loop variants<br>&gt;&gt; that can co-exist easily and are effective,<br>&gt;&gt; each in its own different context?  <br>&gt; <br>&gt; In case I didn’t explain my reasoning clear enough, here is another attempt. Swift already has a very powerful, compact tool that offers a strict superset of the iteration semantics. I simply see no purpose into making the language more verbose and complicated for no particular gain. What you do is argue for having two different syntactic styles for accomplishing exactly the same thing, simply on the grounds of your personal dislike of one of them. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt; Taras<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/98c6b228/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
