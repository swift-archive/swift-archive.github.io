<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 06:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/72f4f9a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  5, 2016 at 06:00:00pm</p></header><div class="content"><p>At a theoretical level — if you add ‘if/where’ conditions to either acc or x then the function being performed can no longer be guaranteed to be commutative (especially if the ‘if’ uses ‘acc’ in it).<br></p><p>If the function is not commutative, then the reduce cannot be broken down and processed in parallel.  <br></p><p>‘map’ (single values) don’t have this issue since it is a single value independent of all other values (so it can be processed in parallel - no problem).<br></p><p>‘fold’ by it’s definition either processes things synchronously left to right, or right to left — and not in parallel.  <br></p><p>Swift reduce has a starting value and likely is just a fold, not a reduce (at least when it is compared to Scala; not sure about when it comes to big data).<br></p><p>Just a guess really though, at least it puts my mind to rest.  <br></p><p>&gt; On 2016-02-05, at 13:48:33, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; You are right, it seems that Scala is doing automatic unsplatting now. Why it doesn&#39;t work for reduce I can&#39;t say.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; Am 05. Februar 2016 um 07:01 schrieb Craig Cruden &lt;ccruden at novafore.com&gt;:<br>&gt; <br>&gt;&gt; No, that cannot be the reason.<br>&gt;&gt; <br>&gt;&gt; — this works<br>&gt;&gt; val r2 = a.foldLeft(0)  {<br>&gt;&gt;   case (acc, x) if x &gt; 4 =&gt; println(x); acc + x<br>&gt;&gt;   case (acc, x) if x &lt;= 4 =&gt; acc - x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; — this does not.<br>&gt;&gt; val r3 = a.reduce {<br>&gt;&gt;   case (acc, x) if x &gt; 4 =&gt; println(x); acc + x<br>&gt;&gt;   case (acc, x) if x &lt;= 4 =&gt; acc - x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-05, at 12:59:06, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason is simply that partial functions in Scala are unary function, i.e. take only one argument, while reduce takes a binary function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I already wrote in another mail why I think that the reduce example in the proposal is problematic, because it does argument splatting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 04.02.2016 um 22:57 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Off Topic a little.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was playing around with the equivalent case - partial functions in Scala …. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have known for whatever reason that they would not work within the Scala `reduce` but would work in other functions….  and it bugged me as to why it would work in most but not all (I was wondering if this was some weird implementation limitation).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As far as I can tell, there is a little difference that prevents it.  Swift reduce is probably the same as Scala’s foldLeft.  I had thought Scala’s reduce is a specialized form of fold but it is not the case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The difference has to be that Scala’s `reduce` takes a “commutative monoid” — and case partial functions by their very nature [conditions on accumulator or value prevent it] are not commutative in nature — or at least not guaranteed to be so.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Scala’s fold is either left to right, or right to left.  `reduce` on the other hand provides no guarantees because it may parallelize it [I am wondering if this is something in common with the concept of big data mapReduce].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ——<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Paul, I will look at updating the proposal to make that clear. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-02-05, at 4:17:03, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I haven&#39;t thought of doing it this way This is why these reviews are great. I agree with Craig that, we would not allow commas before the colon. The proposal probably should be updated to make sure that is clear. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks <br>&gt;&gt;&gt;&gt;&gt; - Paul <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 4, 2016, at 10:31 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I definitely see the point against dictionaries but I’m afraid of the actual pattern matching in &quot;cases&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; match(1) {<br>&gt;&gt;&gt;&gt;&gt;&gt;     case 1, 3: 10<br>&gt;&gt;&gt;&gt;&gt;&gt;     case 2, 4: 20<br>&gt;&gt;&gt;&gt;&gt;&gt;     default: 30<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // with &quot;cases&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; match(1) { cases<br>&gt;&gt;&gt;&gt;&gt;&gt;     1, 3: 10,<br>&gt;&gt;&gt;&gt;&gt;&gt;     2, 4: 20,<br>&gt;&gt;&gt;&gt;&gt;&gt;     default: 30<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // it is very hard to disambiguate between pattern and return value even though for the compiler it could be doable<br>&gt;&gt;&gt;&gt;&gt;&gt; match(1) { cases<br>&gt;&gt;&gt;&gt;&gt;&gt;     1, 3: 10, 2, 4: 20, default: 30<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There should be a more visible distinction between two &quot;case-item-map&quot; like &quot;|&quot;. But we have to consider &quot;expression-patterns&quot; where operators (like &quot;|&quot;) are ambiguous.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 04.02.2016 um 18:48 schrieb Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is a good point and I forgot about that. There are frequent cases where what I am dealing with is not hashable and it is generally a lot of work to make it hashable, including adding a heading function which if done wrong, can lead to errors.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 4, 2016, at 8:38 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I still vote for keeping &quot;cases&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see it as a replacement for dictionary literal &quot;pattern matching&quot;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [1 : &quot;one&quot;, 2 : &quot;two&quot;, 3 : &quot;three&quot;][1] ?? &quot;undefined&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A dictionary needs keys that are Hashable. A dictionary produces an optional. We&#39;ve discussed this, and more, earlier in the thread.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Even though it would be nice to have but I don’t think that I would use it frequently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Granted, it&#39;s a bit ugly, but given the choice, I would pick &quot;cases&quot; over &quot;case case case case ...&quot; every time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In addition, to be more consistent with &quot;case&quot;, &quot;cases&quot; would introduce pattern matching which doesn’t seem right with this concise syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I haven&#39;t thought this through. It just bums me out a little to replace the switch with something that still has imho unnecessary verbosity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/97fcb685/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
