<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Today, you can reference an instance property as a member of its type to access it as a fully unbound function, which is currently curried:<br></p><p>struct Foo {<br>  var x: Int<br>  func foo(y y: Int) { return x + y }<br>}<br></p><p>let foo = Foo.foo<br>foo(Foo(x: 1))(y: 2) // returns 3<br></p><p>However, this is problematic for `mutating` methods. Since the first argument is `inout`, the mutation window for the parameter formally ends before the second argument can be applied to complete the call. Currently we miscompile this, and form a closure over a dangling pointer, leading to undefined behavior:<br></p><p>struct Bar {<br>  var x = 0<br>  mutating func bar() { x += 1 }<br>}<br></p><p>let bar = Bar.bar<br>var a = Bar()<br>bar(&amp;a)() // This might appear to work, if we don&#39;t optimize too hard<br></p><p>let closure: () -&gt; ()<br>do {<br>  var b = Bar()<br>  closure = bar(&amp;b)<br>}<br>closure() // This scribbles dead stack space<br></p><p>var c = Bar() {<br>  didSet { print(&quot;c was set&quot;) }<br>}<br></p><p>bar(&amp;c)() // This will scribble over c after didSet is called, if not worse<br></p><p>We can close this hole by disallowing a reference to Bar.bar, like we already disallow partial applications. However, I think it would be in line with our other simplifications of the function type system to change the type of `Bar.bar` and other unapplied instance method references to no longer be curried. In addition to providing a model for unapplied instance methods that works with mutating methods, this would also eliminate a type difference between free functions and methods of the same arity, allowing for easier code reuse. For instance, `reduce` takes a closure of type (State, Element) -&gt; State. Flattening the formal type of instance methods would allow binary methods to be used as-is with `reduce`, like binary free functions can:<br></p><p>func sumOfInts(ints: [Int]) -&gt; Int { <br>  return ints.reduce(0, combine: +)<br>}<br>func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; { <br>  return ints.reduce([], combine: Set.union)<br>}<br></p><p>What do you all think?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/d212ebb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>February 22, 2016 at 06:00:00pm</p></header><div class="content"><p>I personally use the existing behavior in some of my code, by providing the reference to the method directly to a method/function that takes a closure as a parameter. A modified excerpt from my code:<br></p><p>    let observer = NSNotificationCenter.defaultCenter().addObserverForName(LoginSuccess, object: nil, queue: nil, usingBlock: weakify(self, self.dynamicType.userDidLogin))<br></p><p>(Note: This usage normally would lead to a retain cycle, but I wrap the method reference in this weakify() function which handles weakly applying self to the returned method reference.)<br></p><p>Un-currying method references would make this pattern harder to apply, so if there was a way to resolve this behavior without removing the current flexibility that the curried behavior offers, I would prefer that. Un-currying mutating methods only would be one option, but that seems a bit ugly. <br></p><p>However, if there isn&#39;t a way to fix it without changing existing behavior, I&#39;d prefer the un-curried form everywhere to removing static method access outright.<br></p><p>Kevin Lundberg<br>kevin at klundberg.com<br></p><p><br></p><p>&gt; On Feb 22, 2016, at 5:52 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Today, you can reference an instance property as a member of its type to access it as a fully unbound function, which is currently curried:<br>&gt; <br>&gt; struct Foo {<br>&gt;   var x: Int<br>&gt;   func foo(y y: Int) { return x + y }<br>&gt; }<br>&gt; <br>&gt; let foo = Foo.foo<br>&gt; foo(Foo(x: 1))(y: 2) // returns 3<br>&gt; <br>&gt; However, this is problematic for `mutating` methods. Since the first argument is `inout`, the mutation window for the parameter formally ends before the second argument can be applied to complete the call. Currently we miscompile this, and form a closure over a dangling pointer, leading to undefined behavior:<br>&gt; <br>&gt; struct Bar {<br>&gt;   var x = 0<br>&gt;   mutating func bar() { x += 1 }<br>&gt; }<br>&gt; <br>&gt; let bar = Bar.bar<br>&gt; var a = Bar()<br>&gt; bar(&amp;a)() // This might appear to work, if we don&#39;t optimize too hard<br>&gt; <br>&gt; let closure: () -&gt; ()<br>&gt; do {<br>&gt;   var b = Bar()<br>&gt;   closure = bar(&amp;b)<br>&gt; }<br>&gt; closure() // This scribbles dead stack space<br>&gt; <br>&gt; var c = Bar() {<br>&gt;   didSet { print(&quot;c was set&quot;) }<br>&gt; }<br>&gt; <br>&gt; bar(&amp;c)() // This will scribble over c after didSet is called, if not worse<br>&gt; <br>&gt; We can close this hole by disallowing a reference to Bar.bar, like we already disallow partial applications. However, I think it would be in line with our other simplifications of the function type system to change the type of `Bar.bar` and other unapplied instance method references to no longer be curried. In addition to providing a model for unapplied instance methods that works with mutating methods, this would also eliminate a type difference between free functions and methods of the same arity, allowing for easier code reuse. For instance, `reduce` takes a closure of type (State, Element) -&gt; State. Flattening the formal type of instance methods would allow binary methods to be used as-is with `reduce`, like binary free functions can:<br>&gt; <br>&gt; func sumOfInts(ints: [Int]) -&gt; Int { <br>&gt;   return ints.reduce(0, combine: +)<br>&gt; }<br>&gt; func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; { <br>&gt;   return ints.reduce([], combine: Set.union)<br>&gt; }<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/151682ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 3:11 PM, Kevin Lundberg &lt;kevin at klundberg.com&gt; wrote:<br>&gt; <br>&gt; I personally use the existing behavior in some of my code, by providing the reference to the method directly to a method/function that takes a closure as a parameter. A modified excerpt from my code:<br>&gt; <br>&gt;     let observer = NSNotificationCenter.defaultCenter().addObserverForName(LoginSuccess, object: nil, queue: nil, usingBlock: weakify(self, self.dynamicType.userDidLogin))<br>&gt; <br>&gt; (Note: This usage normally would lead to a retain cycle, but I wrap the method reference in this weakify() function which handles weakly applying self to the returned method reference.)<br>&gt; <br>&gt; Un-currying method references would make this pattern harder to apply, so if there was a way to resolve this behavior without removing the current flexibility that the curried behavior offers, I would prefer that. Un-currying mutating methods only would be one option, but that seems a bit ugly. <br>&gt; <br>&gt; However, if there isn&#39;t a way to fix it without changing existing behavior, I&#39;d prefer the un-curried form everywhere to removing static method access outright.<br></p><p>If I understand the intent of `weakify` correctly, I think this kind of use case is already pretty severely curtailed by our removing the tuple splat feature, since you can no longer make `weakify` generic across multiple method signatures. Like the tuple splat feature, an explicit variadic splatting feature ought to make this possible for flattened method signatures:<br></p><p>func weakify&lt;Class: class, Args, Result&gt;(instance: Class, method: (Class, Args...) -&gt; Result) -&gt; (Args...) -&gt; Result {<br>  return {[weak instance] args... in method(instance, args...) }<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/9636a84c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>February 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On 2/22/2016 6:18 PM, Joe Groff wrote:<br>&gt;<br>&gt; If I understand the intent of `weakify` correctly, I think this kind<br>&gt; of use case is already pretty severely curtailed by our removing the<br>&gt; tuple splat feature, since you can no longer make `weakify` generic<br>&gt; across multiple method signatures. Like the tuple splat feature, an<br>&gt; explicit variadic splatting feature ought to make this possible for<br>&gt; flattened method signatures:<br>&gt;<br>&gt;     func weakify&lt;Class: class, Args, Result&gt;(instance: Class, method:<br>&gt;     (Class, Args...) -&gt; Result) -&gt; (Args...) -&gt; Result {<br>&gt;       return {[weak instance] args... in method(instance, args...) }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; -Joe<br></p><p>Agreed on the tuple splat removal point, but the common use cases I use<br>this for today don&#39;t apply weakify to methods with more than one<br>argument in practice. Even so, your example here is admittedly a pretty<br>simple change to make to keep existing functionality if the curried form<br>of this goes away, and this language change would make it haeder for<br>people who want to do something similar to create a retain cycle<br>scenario if they don&#39;t use something like weakify to safely pass method<br>references around.<br></p><p>I do like the current behavior, but given this you&#39;ve convinced me that<br>it may be best for it to change :)<br></p><p>- Kevin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/8a7aa328/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February 22, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 for this. A clear win with regard to simplification.<br></p><p>On Mon, Feb 22, 2016 at 8:41 PM, Kevin Lundberg via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 2/22/2016 6:18 PM, Joe Groff wrote:<br>&gt;<br>&gt;<br>&gt; If I understand the intent of `weakify` correctly, I think this kind of<br>&gt; use case is already pretty severely curtailed by our removing the tuple<br>&gt; splat feature, since you can no longer make `weakify` generic across<br>&gt; multiple method signatures. Like the tuple splat feature, an explicit<br>&gt; variadic splatting feature ought to make this possible for flattened method<br>&gt; signatures:<br>&gt;<br>&gt; func weakify&lt;Class: class, Args, Result&gt;(instance: Class, method: (Class,<br>&gt; Args...) -&gt; Result) -&gt; (Args...) -&gt; Result {<br>&gt;   return {[weak instance] args... in method(instance, args...) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; Agreed on the tuple splat removal point, but the common use cases I use<br>&gt; this for today don&#39;t apply weakify to methods with more than one argument<br>&gt; in practice. Even so, your example here is admittedly a pretty simple<br>&gt; change to make to keep existing functionality if the curried form of this<br>&gt; goes away, and this language change would make it haeder for people who<br>&gt; want to do something similar to create a retain cycle scenario if they<br>&gt; don&#39;t use something like weakify to safely pass method references around.<br>&gt;<br>&gt; I do like the current behavior, but given this you&#39;ve convinced me that it<br>&gt; may be best for it to change :)<br>&gt;<br>&gt; - Kevin<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/47d6466a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February 23, 2016 at 12:00:00am</p></header><div class="content"><p>At a glance it sounds great!<br></p><p>The current behaviour should clearly be changed and I&#39;m very much in favor keeping the ability to get unapplied instance methods for mutating methods.<br></p><p>I particularly liked the last example. I&#39;ve tried similar things before only to be disappointed when it didn&#39;t work.<br></p><p>- Janosch<br></p><p>&gt; On 22 Feb 2016, at 23:52, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Today, you can reference an instance property as a member of its type to access it as a fully unbound function, which is currently curried:<br>&gt; <br>&gt; struct Foo {<br>&gt;   var x: Int<br>&gt;   func foo(y y: Int) { return x + y }<br>&gt; }<br>&gt; <br>&gt; let foo = Foo.foo<br>&gt; foo(Foo(x: 1))(y: 2) // returns 3<br>&gt; <br>&gt; However, this is problematic for `mutating` methods. Since the first argument is `inout`, the mutation window for the parameter formally ends before the second argument can be applied to complete the call. Currently we miscompile this, and form a closure over a dangling pointer, leading to undefined behavior:<br>&gt; <br>&gt; struct Bar {<br>&gt;   var x = 0<br>&gt;   mutating func bar() { x += 1 }<br>&gt; }<br>&gt; <br>&gt; let bar = Bar.bar<br>&gt; var a = Bar()<br>&gt; bar(&amp;a)() // This might appear to work, if we don&#39;t optimize too hard<br>&gt; <br>&gt; let closure: () -&gt; ()<br>&gt; do {<br>&gt;   var b = Bar()<br>&gt;   closure = bar(&amp;b)<br>&gt; }<br>&gt; closure() // This scribbles dead stack space<br>&gt; <br>&gt; var c = Bar() {<br>&gt;   didSet { print(&quot;c was set&quot;) }<br>&gt; }<br>&gt; <br>&gt; bar(&amp;c)() // This will scribble over c after didSet is called, if not worse<br>&gt; <br>&gt; We can close this hole by disallowing a reference to Bar.bar, like we already disallow partial applications. However, I think it would be in line with our other simplifications of the function type system to change the type of `Bar.bar` and other unapplied instance method references to no longer be curried. In addition to providing a model for unapplied instance methods that works with mutating methods, this would also eliminate a type difference between free functions and methods of the same arity, allowing for easier code reuse. For instance, `reduce` takes a closure of type (State, Element) -&gt; State. Flattening the formal type of instance methods would allow binary methods to be used as-is with `reduce`, like binary free functions can:<br>&gt; <br>&gt; func sumOfInts(ints: [Int]) -&gt; Int { <br>&gt;   return ints.reduce(0, combine: +)<br>&gt; }<br>&gt; func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; { <br>&gt;   return ints.reduce([], combine: Set.union)<br>&gt; }<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/8e17fbc0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 23, 2016 at 04:00:00pm</p></header><div class="content"><p>+1<br></p><p>-Thorsten <br></p><p>&gt; Am 22.02.2016 um 23:52 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Today, you can reference an instance property as a member of its type to access it as a fully unbound function, which is currently curried:<br>&gt; <br>&gt; struct Foo {<br>&gt;   var x: Int<br>&gt;   func foo(y y: Int) { return x + y }<br>&gt; }<br>&gt; <br>&gt; let foo = Foo.foo<br>&gt; foo(Foo(x: 1))(y: 2) // returns 3<br>&gt; <br>&gt; However, this is problematic for `mutating` methods. Since the first argument is `inout`, the mutation window for the parameter formally ends before the second argument can be applied to complete the call. Currently we miscompile this, and form a closure over a dangling pointer, leading to undefined behavior:<br>&gt; <br>&gt; struct Bar {<br>&gt;   var x = 0<br>&gt;   mutating func bar() { x += 1 }<br>&gt; }<br>&gt; <br>&gt; let bar = Bar.bar<br>&gt; var a = Bar()<br>&gt; bar(&amp;a)() // This might appear to work, if we don&#39;t optimize too hard<br>&gt; <br>&gt; let closure: () -&gt; ()<br>&gt; do {<br>&gt;   var b = Bar()<br>&gt;   closure = bar(&amp;b)<br>&gt; }<br>&gt; closure() // This scribbles dead stack space<br>&gt; <br>&gt; var c = Bar() {<br>&gt;   didSet { print(&quot;c was set&quot;) }<br>&gt; }<br>&gt; <br>&gt; bar(&amp;c)() // This will scribble over c after didSet is called, if not worse<br>&gt; <br>&gt; We can close this hole by disallowing a reference to Bar.bar, like we already disallow partial applications. However, I think it would be in line with our other simplifications of the function type system to change the type of `Bar.bar` and other unapplied instance method references to no longer be curried. In addition to providing a model for unapplied instance methods that works with mutating methods, this would also eliminate a type difference between free functions and methods of the same arity, allowing for easier code reuse. For instance, `reduce` takes a closure of type (State, Element) -&gt; State. Flattening the formal type of instance methods would allow binary methods to be used as-is with `reduce`, like binary free functions can:<br>&gt; <br>&gt; func sumOfInts(ints: [Int]) -&gt; Int { <br>&gt;   return ints.reduce(0, combine: +)<br>&gt; }<br>&gt; func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; { <br>&gt;   return ints.reduce([], combine: Set.union)<br>&gt; }<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/577261a4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 24, 2016 at 08:00:00am</p></header><div class="content"><p>+1. It is very obscure that you can do this!<br></p><p>On Tuesday, 23 February 2016, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Today, you can reference an instance property as a member of its type to<br>&gt; access it as a fully unbound function, which is currently curried:<br>&gt;<br>&gt; struct Foo {<br>&gt;   var x: Int<br>&gt;   func foo(y y: Int) { return x + y }<br>&gt; }<br>&gt;<br>&gt; let foo = Foo.foo<br>&gt; foo(Foo(x: 1))(y: 2) // returns 3<br>&gt;<br>&gt; However, this is problematic for `mutating` methods. Since the first<br>&gt; argument is `inout`, the mutation window for the parameter formally ends<br>&gt; before the second argument can be applied to complete the call. Currently<br>&gt; we miscompile this, and form a closure over a dangling pointer, leading to<br>&gt; undefined behavior:<br>&gt;<br>&gt; struct Bar {<br>&gt;   var x = 0<br>&gt;   mutating func bar() { x += 1 }<br>&gt; }<br>&gt;<br>&gt; let bar = Bar.bar<br>&gt; var a = Bar()<br>&gt; bar(&amp;a)() // This might appear to work, if we don&#39;t optimize too hard<br>&gt;<br>&gt; let closure: () -&gt; ()<br>&gt; do {<br>&gt;   var b = Bar()<br>&gt;   closure = bar(&amp;b)<br>&gt; }<br>&gt; closure() // This scribbles dead stack space<br>&gt;<br>&gt; var c = Bar() {<br>&gt;   didSet { print(&quot;c was set&quot;) }<br>&gt; }<br>&gt;<br>&gt; bar(&amp;c)() // This will scribble over c after didSet is called, if not worse<br>&gt;<br>&gt; We can close this hole by disallowing a reference to Bar.bar, like we<br>&gt; already disallow partial applications. However, I think it would be in line<br>&gt; with our other simplifications of the function type system to change the<br>&gt; type of `Bar.bar` and other unapplied instance method references to no<br>&gt; longer be curried. In addition to providing a model for unapplied instance<br>&gt; methods that works with mutating methods, this would also eliminate a type<br>&gt; difference between free functions and methods of the same arity, allowing<br>&gt; for easier code reuse. For instance, `reduce` takes a closure of type<br>&gt; (State, Element) -&gt; State. Flattening the formal type of instance methods<br>&gt; would allow binary methods to be used as-is with `reduce`, like binary free<br>&gt; functions can:<br>&gt;<br>&gt; func sumOfInts(ints: [Int]) -&gt; Int {<br>&gt;<br>&gt;   return ints.reduce(0, combine: +)<br>&gt;<br>&gt; }<br>&gt;<br>&gt; func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; {<br>&gt;   return ints.reduce([], combine: Set.union)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; What do you all think?<br>&gt;<br>&gt; -Joe<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/49bf74f9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 24, 2016 at 08:00:00pm</p></header><div class="content"><p>On Feb 22, 2016, at 2:52 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; However, this is problematic for `mutating` methods. Since the first argument is `inout`, the mutation window for the parameter formally ends before the second argument can be applied to complete the call. Currently we miscompile this, and form a closure over a dangling pointer, leading to undefined behavior:<br>&gt; <br>&gt; struct Bar {<br>&gt;   var x = 0<br>&gt;   mutating func bar() { x += 1 }<br>&gt; }<br>&gt; <br>&gt; let bar = Bar.bar<br></p><p>Wow, I thought we were banning this, along with the other unsupported partial application cases.  I’d strongly suggest doing that *now* (independently of how the design topic is resolved) since it is such an open tar pit.<br></p><p>&gt; We can close this hole by disallowing a reference to Bar.bar, like we already disallow partial applications. However, I think it would be in line with our other simplifications of the function type system to change the type of `Bar.bar` and other unapplied instance method references to no longer be curried.<br></p><p>I see a few possible design points:<br></p><p>1. Disallow partial application of mutating methods.<br>2. Change all partially applied methods to be an uncurried form (as you propose).<br>3. Change mutating methods to be uncurried, but leave everything else curried.<br>4. Change methods on structs/enums(protocols?) to be uncurried, but leave classes curried.<br></p><p>#1 is the safe path.<br>#2 is the nuclear path.<br>#3/#4 are the weirdly inconsistent paths.<br></p><p>None of these are really great.  Since you’re advocating for it, I’m very concerned about making partially applied methods be uncurried always (#2).  I have seen a *lot* of people use curried methods on classes (in particular) and this leads to some pretty elegant patterns.  I’d expect any serious discussion of changing this behavior to include a survey of what people are actually using this for, and whether the end result we’d get from this change would be better or worse overall (not just in a single case).<br></p><p>-Chris<br></p><p><br>&gt; In addition to providing a model for unapplied instance methods that works with mutating methods, this would also eliminate a type difference between free functions and methods of the same arity, allowing for easier code reuse. For instance, `reduce` takes a closure of type (State, Element) -&gt; State. Flattening the formal type of instance methods would allow binary methods to be used as-is with `reduce`, like binary free functions can:<br>&gt; <br>&gt; func sumOfInts(ints: [Int]) -&gt; Int { <br>&gt;   return ints.reduce(0, combine: +)<br>&gt; }<br>&gt; func unionOfSets&lt;T&gt;(sets: [Set&lt;T&gt;]) -&gt; Set&lt;T&gt; { <br>&gt;   return ints.reduce([], combine: Set.union)<br>&gt; }<br>&gt; <br>&gt; What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/60cfdbc0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 24, 2016, at 8:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; None of these are really great.  Since you’re advocating for it, I’m very concerned about making partially applied methods be uncurried always (#2).  I have seen a *lot* of people use curried methods on classes (in particular) and this leads to some pretty elegant patterns.  I’d expect any serious discussion of changing this behavior to include a survey of what people are actually using this for, and whether the end result we’d get from this change would be better or worse overall (not just in a single case).<br></p><p>I&#39;m concerned about that too, but I think most of these use cases are already impeded by removing tuple argument splatting, since that makes it impossible to make a generic method transformation like `alterMethod&lt;Receiver, Args, Ret&gt;(method: Receiver -&gt; Args -&gt; Ret)`. I think these use cases can be recovered on flattened methods by explicit variadic splatting, since you could then write `alterMethod&lt;Receiver, Args, Ret&gt;(method: (Receiver, Args...) -&gt; Ret)` instead.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/05153f5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 9:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 24, 2016, at 8:50 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; None of these are really great.  Since you’re advocating for it, I’m very concerned about making partially applied methods be uncurried always (#2).  I have seen a *lot* of people use curried methods on classes (in particular) and this leads to some pretty elegant patterns.  I’d expect any serious discussion of changing this behavior to include a survey of what people are actually using this for, and whether the end result we’d get from this change would be better or worse overall (not just in a single case).<br>&gt; <br>&gt; I&#39;m concerned about that too, but I think most of these use cases are already impeded by removing tuple argument splatting, since that makes it impossible to make a generic method transformation like `alterMethod&lt;Receiver, Args, Ret&gt;(method: Receiver -&gt; Args -&gt; Ret)`. I think these use cases can be recovered on flattened methods by explicit variadic splatting, since you could then write `alterMethod&lt;Receiver, Args, Ret&gt;(method: (Receiver, Args...) -&gt; Ret)` instead.<br></p><p>I don’t really understand that, because the use-cases I’ve seen aren’t in generic context’s, but let me step back and see if I understand your proposal.  Here’s your example again:<br></p><p>&gt; struct Bar {<br>&gt;   var x = 0<br>&gt;   mutating func bar() { x += 1 }<br>&gt; }<br>&gt; <br>&gt; let a = Bar.bar<br></p><p><br>I believe that you’re proposing that “a” have type &quot;(inout Bar) -&gt; ()” since the empty argument list got flattened into the self argument.<br></p><p>However, what is the type of the partial application case, i.e. “someBarInstance.bar”?<br></p><p>It seems that this *has* to be invalid for mutating methods, and it is the most commonly curried forms that I’ve seen for classes.<br></p><p><br>I would be extremely nervous about saying that partial application and the raw name disagree, and I really wouldn’t want to kill partial application for classes and non-mutating methods.<br></p><p>I think that the least bad answer here is to just have sema reject attempts to get the base name of the mutating methods.  In fact, my memory was partially right.  We *are* already rejecting the partial application case:<br></p><p>  5&gt; var b = Bar()<br>b: Bar = {<br>  x = 0<br>}<br>  6&gt; b.bar<br>repl.swift:6:3: error: partial application of &#39;mutating&#39; method is not allowed<br></p><p>so I think that we are just missing a simple case that we should be rejecting here.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/6cfdce2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 4:22 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 9:13 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 24, 2016, at 8:50 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None of these are really great.  Since you’re advocating for it, I’m very concerned about making partially applied methods be uncurried always (#2).  I have seen a *lot* of people use curried methods on classes (in particular) and this leads to some pretty elegant patterns.  I’d expect any serious discussion of changing this behavior to include a survey of what people are actually using this for, and whether the end result we’d get from this change would be better or worse overall (not just in a single case).<br>&gt;&gt; <br>&gt;&gt; I&#39;m concerned about that too, but I think most of these use cases are already impeded by removing tuple argument splatting, since that makes it impossible to make a generic method transformation like `alterMethod&lt;Receiver, Args, Ret&gt;(method: Receiver -&gt; Args -&gt; Ret)`. I think these use cases can be recovered on flattened methods by explicit variadic splatting, since you could then write `alterMethod&lt;Receiver, Args, Ret&gt;(method: (Receiver, Args...) -&gt; Ret)` instead.<br>&gt; <br>&gt; I don’t really understand that, because the use-cases I’ve seen aren’t in generic context’s<br></p><p>Do you have an example in mind of a nongeneric use of curried methods that can&#39;t be easily rewritten in terms of a flat method type?<br></p><p>&gt; , but let me step back and see if I understand your proposal.  Here’s your example again:<br></p><p><br>&gt;&gt; struct Bar {<br>&gt;&gt;   var x = 0<br>&gt;&gt;   mutating func bar() { x += 1 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = Bar.bar<br>&gt; <br>&gt; <br>&gt; I believe that you’re proposing that “a” have type &quot;(inout Bar) -&gt; ()” since the empty argument list got flattened into the self argument.<br>&gt; <br>&gt; However, what is the type of the partial application case, i.e. “someBarInstance.bar”?<br>&gt; <br>&gt; It seems that this *has* to be invalid for mutating methods, and it is the most commonly curried forms that I’ve seen for classes.<br></p><p>Yes, the partial application is not allowed. We currently incorrectly accept the fully applied reference `Bar.bar`. I agree that if we change nothing else, that&#39;s a hole we should plug.<br></p><p>&gt; <br>&gt; I would be extremely nervous about saying that partial application and the raw name disagree, and I really wouldn’t want to kill partial application for classes and non-mutating methods.<br></p><p>We can decouple the meaning of `Type.instanceMethod` from the partial application `instance.instanceMethod`. Even if the type of `Type.instanceMethod` is flattened, we can still accept `instance.instanceMethod` with the current behavior. It&#39;s maybe a bit less elegant that `instance.instanceMethod` isn&#39;t just &quot;sugar&quot; for `Type.instanceMethod(instance)`, but that already isn&#39;t really the case for `mutating` methods—we treat a full application `instance.instanceMethod(foo)` as a single call for the purposes of the mutation model.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; I think that the least bad answer here is to just have sema reject attempts to get the base name of the mutating methods.  In fact, my memory was partially right.  We *are* already rejecting the partial application case:<br>&gt; <br>&gt;   5&gt; var b = Bar()<br>&gt; b: Bar = {<br>&gt;   x = 0<br>&gt; }<br>&gt;   6&gt; b.bar<br>&gt; repl.swift:6:3: error: partial application of &#39;mutating&#39; method is not allowed<br>&gt; <br>&gt; so I think that we are just missing a simple case that we should be rejecting here.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/f540f3db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>February 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 4:57 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I&#39;m concerned about that too, but I think most of these use cases are already impeded by removing tuple argument splatting, since that makes it impossible to make a generic method transformation like `alterMethod&lt;Receiver, Args, Ret&gt;(method: Receiver -&gt; Args -&gt; Ret)`. I think these use cases can be recovered on flattened methods by explicit variadic splatting, since you could then write `alterMethod&lt;Receiver, Args, Ret&gt;(method: (Receiver, Args...) -&gt; Ret)` instead.<br>&gt;&gt; <br>&gt;&gt; I don’t really understand that, because the use-cases I’ve seen aren’t in generic context’s<br>&gt; <br>&gt; Do you have an example in mind of a nongeneric use of curried methods that can&#39;t be easily rewritten in terms of a flat method type?<br></p><p>I may be off-track, but you mentioned the binary tree example of passing methods as binary closures. Wouldn&#39;t the converse be true for wedging state into unary func using existing class methods?<br></p><p>func visit(numbers: [Int], predicate: (Int) -&gt; Bool) {<br>  numbers.lazy.filter(predicate).forEach({ print($0) })<br>}<br></p><p>// For some reason not a closure...<br>class FilterNumbersWithRejects {<br>  var rejects = [Int]()<br></p><p>  func check(val: Int) -&gt; Bool {<br>    if (val &lt; 100) { return true }<br>    rejects.append(val)<br>    return false<br>  }<br>}<br></p><p>let filterNumbers = FilterNumbersWithRejects()<br>visit([3, 33, 333], predicate: filterNumbers.check)<br>print(filterNumbers.rejects)<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/c6937311/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 10:16 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 25, 2016, at 4:57 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m concerned about that too, but I think most of these use cases are already impeded by removing tuple argument splatting, since that makes it impossible to make a generic method transformation like `alterMethod&lt;Receiver, Args, Ret&gt;(method: Receiver -&gt; Args -&gt; Ret)`. I think these use cases can be recovered on flattened methods by explicit variadic splatting, since you could then write `alterMethod&lt;Receiver, Args, Ret&gt;(method: (Receiver, Args...) -&gt; Ret)` instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t really understand that, because the use-cases I’ve seen aren’t in generic context’s<br>&gt;&gt; <br>&gt;&gt; Do you have an example in mind of a nongeneric use of curried methods that can&#39;t be easily rewritten in terms of a flat method type?<br>&gt; <br>&gt; I may be off-track, but you mentioned the binary tree example of passing methods as binary closures. Wouldn&#39;t the converse be true for wedging state into unary func using existing class methods?<br>&gt; <br>&gt; func visit(numbers: [Int], predicate: (Int) -&gt; Bool) {<br>&gt;   numbers.lazy.filter(predicate).forEach({ print($0) })<br>&gt; }<br>&gt; <br>&gt; // For some reason not a closure...<br>&gt; class FilterNumbersWithRejects {<br>&gt;   var rejects = [Int]()<br>&gt; <br>&gt;   func check(val: Int) -&gt; Bool {<br>&gt;     if (val &lt; 100) { return true }<br>&gt;     rejects.append(val)<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let filterNumbers = FilterNumbersWithRejects()<br>&gt; visit([3, 33, 333], predicate: filterNumbers.check)<br>&gt; print(filterNumbers.rejects)<br></p><p>I&#39;m not proposing that we take the ability to use `filterNumbers.check` away. I&#39;m proposing changing the type of the fully unapplied reference FilterNumbersWithRejects.check.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/2d59c794/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 9:44 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; let filterNumbers = FilterNumbersWithRejects()<br>&gt;&gt; visit([3, 33, 333], predicate: filterNumbers.check)<br>&gt;&gt; print(filterNumbers.rejects)<br>&gt; <br>&gt; I&#39;m not proposing that we take the ability to use `filterNumbers.check` away. I&#39;m proposing changing the type of the fully unapplied reference FilterNumbersWithRejects.check.<br></p><p>This was the core of my misunderstanding.  I didn’t realize that you were proposing to break the symmetry between Type.method and instance.method.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/3429e147/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Flattening the function type of unapplied instance methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 10:20 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 9:44 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let filterNumbers = FilterNumbersWithRejects()<br>&gt;&gt;&gt; visit([3, 33, 333], predicate: filterNumbers.check)<br>&gt;&gt;&gt; print(filterNumbers.rejects)<br>&gt;&gt; <br>&gt;&gt; I&#39;m not proposing that we take the ability to use `filterNumbers.check` away. I&#39;m proposing changing the type of the fully unapplied reference FilterNumbersWithRejects.check.<br>&gt; <br>&gt; This was the core of my misunderstanding.  I didn’t realize that you were proposing to break the symmetry between Type.method and instance.method.<br></p><p>Joe explained this to me in a calming tone of voice and used small words that I was able to understand, I’m onboard now :-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/ffee170d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
