<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>February 28, 2016 at 08:00:00am</p></header><div class="content"><p>I’d like to add a couple of thoughts to the discussion.<br></p><p>I agree that the current Strideable naming is surprising, and toward/to instead of to/through would have been more appropriate.<br></p><p>I’m not so sure that having a proper ‘through’ method that would pass through the endpoint would be useful, and that it would do anything to solve the floating point issues.<br></p><p>The specific example that started the discussion was 1.0 through 2.0 by 0.1. The expected result was to end exactly at 2.0, instead it ended at 1.9 because `by`+epsilon was added at every step. Changing the behavior of `through`to end past the endpoint would have solved this case.<br></p><p>However, I suspect that changing the stride values you could end in the opposite condition, where `by`-epsilon is added at every step, and so with a changed `through` behavior you would end at the equivalent of 2.1; which is equally wrong.<br></p><p>The root of the problem is that Strideable is clearly designed with exact (not necessarily integer, but exact) math in mind. Floating point values shouldn’t conform to it, as they need different semantics.<br></p><p>In my experience, when dealing with floating point values in loops it has always been one of two cases:<br></p><p>1) (most common) iterate from A to *exactly* B, doing steps *as close as possible* to S<br>2) (less common) iterate from A to *as close as possible* to B, doing steps of *exactly* S<br></p><p>1) would be implemented with integer math, computing the number of steps needed and then interpolating between A and B. This guarantees that the final iteration is exactly on B, however the difference between two steps would not be exactly S.<br></p><p>2) would be implemented by tweaking the end condition so that the final iteration can be either before or after B—whichever is closest.<br></p><p>—<br>Nicola<br></p><p>&gt; I&#39;ve updated the proposal to take this into account:https://gist.github.com/erica/03c398c06f6c47824429<br>&gt; <br>&gt; It makes two core recommendations:<br>&gt; <br>&gt; 1. Adjust stride function semantics to expand from two to three functions, renaming them appropriately.<br>&gt; 2. Break floating point strides away from Strideable to provide their own stride method implementations.<br>&gt; <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; &gt; On Feb 27, 2016, at 8:07 PM, Charles Kissinger&lt;crk at akkyra.com(mailto:crk at akkyra.com)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; &gt; On Feb 27, 2016, at 5:38 PM, Erica Sadun&lt;erica at ericasadun.com(mailto:erica at ericasadun.com)&gt;wrote:<br>&gt; &gt; &gt; Would you accept a third version then? towards (to, `[a, b)`), to (through, `[a, b]`), and through (new, `[a,&gt;=b]`&lt;-- not sure that even has a representation)?<br>&gt; &gt; <br>&gt; &gt; No objection here. It’s a really interesting problem you’ve pointed out. I’m not sure yet the best way to minimize it.<br>&gt; &gt; <br>&gt; &gt; —CK<br>&gt; &gt; &gt; -- E<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; On Feb 27, 2016, at 6:25 PM, Charles Kissinger&lt;crk at akkyra.com(mailto:crk at akkyra.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; Hi Erica,<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; With your suggested change, there would be no way to specify a precise upper bound for a sequence (except for integers in specific cases). The current pair of functions provide numbers in the intervals [a, b) and [a,b], which is what is needed to cover all use cases. With your change, the two functions would produce sequences that potentially lie either in the interval [a, b) for &quot;stride to” or [a, infinity] for &quot;stride through” since the size of the stride isn’t necessarily known at compile time or predictable.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; In addition to breaking existing code, it would not cover every use case. Sometimes you won’t know the stride until runtime, but you know it has to be able to reach but not exceed a certain value.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; —CK<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On Feb 27, 2016, at 3:27 PM, Erica Sadun via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; Following up to myself. Thoughts and feedback are welcome. -- Erica<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Changing the Behavior of StrideThroughGenerator<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Swift offers two stride functions,stride(to:, by:)andstride(through:, by:). I propose to change the way thethroughvariation works.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Current Art<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; AStrideable tosequence returns the sequence of values (self,self + stride,self + stride + stride, …last) wherelastis the last value in<br>&gt; &gt; &gt; &gt; &gt; the progression that is less thanend.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; AStrideable throughsequence currently returns the sequence of values (self,self + stride,self + tride + stride, …last) wherelastis the last value in the progression less than or equal toend. There is no guarantee thatendis an element of the sequence.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Under the current implementation, each floating point addition accrues errors. The progression never reaches 2.0.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; print(Array(1.0.stride(through:2.0,by:0.1)))/// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; To force the progression to include 2.0, you must add an (ugly) epsilon, as in the following example:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; print(Array(1.0.stride(through:2.01,by:0.1)))/// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; This is problematic for the following reasons:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; The name of the calling function “through” suggests the progression will passthroughthe end point before stopping<br>&gt; &gt; &gt; &gt; &gt; Floating point calls present an extremely common use-case<br>&gt; &gt; &gt; &gt; &gt; It’s unreasonable to expect developers to consider every case of “will floating point math prevent my progression from actually reaching the end point, which has already been differentiated by usingthroughrather thanto”<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Proposed Modifications<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; I recommend the following changes:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Change the documentation text from<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; AStrideable throughsequence currently returns the sequence of values (self,self + stride,self + stride + stride, …last) wherelastis the last value in the progressionless than or equal toend. There is no guarantee thatendis an element of the sequence.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; to<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; AStrideable throughsequence currently returns the sequence of values (self,self + stride,self + stride + stride, …last) wherelastis the last value in the progressiongreater than or equal toend. There is no guarantee thatendis an element of the sequence.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Modify the implementation<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Current:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; ///Advanceto thenextelementandreturnit,or`nil`ifnonext///element exists.   public mutating funcnext() -&gt;Element? {ifdone {returnnil}ifstride&gt;0? current&gt;=end:current&lt;=end{ifcurrent ==end{         done =truereturncurrent       }returnnil}     let result = current     current += stridereturnresult   }<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Proposed:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; ///Advanceto thenextelementandreturnit,or`nil`ifnonext///element exists.   public mutating funcnext() -&gt;Element? {ifdone {returnnil}ifstride&gt;0? current&gt;=end:current&lt;=end{//NOTE:`current&gt;=end`andnot`current ==end`ifcurrent&gt;=end{         done =truereturncurrent       }returnnil}     let result = current     current += stridereturnresult   } }<br>&gt; &gt; &gt; &gt; &gt; Introduced Changes<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Under these changes, the following progression ends at 2.0 not 1.9:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; print(Array(1.0.stride(through:2.0,by:0.1)))// prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Integer progressions are unchanged:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; print(Array(1.stride(through2:10,by:1)))/// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Floating point strides will extend up-to or past thethroughvalue:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; // Oldprint(Array(1.0.stride(through:1.9,by:0.25)))// prints [1.0, 1.25, 1.5, 1.75]// Newprint(Array(1.0.stride(through:1.9,by:0.25)))// prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt; &gt; &gt; &gt; &gt; Alternates Considered<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Other changes could include:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Introducing adigitalStridefunction with a set precision that works in integer math, multiplying each value by 10n, converting to integers, and then working back to floating point after each change<br>&gt; &gt; &gt; &gt; &gt; Counting expected iterations by forming(max - min) / by, e.g.(2.0 - 1.0) / 0.1, which is 10, and performing each step as a pro-rated progression along those steps, which would remove most of the accumulated floating point errors along the way.<br>&gt; &gt; &gt; &gt; &gt; Introducing aDecimalNumbertype, with its ownstridemethods, e.g.DecimalNumber(1.0).stride(through:DecimalNumber(2.0), by: DecimalNumber(0.1)).<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; On Feb 26, 2016, at 5:12 PM, Erica Sadun via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; I have a problem with the way floating point ranges work with striding:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 1.0.stride(through: 2.0, by: 0.1)returns the sequence[1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9].<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Documentation: &quot;It returns the sequence where last is less than or equal to `end`.&quot;<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; (And yes, the same issue exists with tradition C-style for loops).<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Would it be really horrible if the implementation and definition was changed to:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &quot;It returns the sequence where last is greater than or equal to `end`?&quot;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; This would offer no change for integers, and include 2.0 for floating point sequences.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Alternatively, could there bedecimalStride? Using Double but a rounding system with a fixed number of decimal places (e.g. 1, 2, 3), to ensure at least the end point is hit? It might look like:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; 1.0.stride(through: 2.0, by: 0.1, places: 1)<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; I know there have been several discussions on-list about decimal number systems (Re: Is there a need for a Decimal type?(http://article.gmane.org/gmane.comp.lang.swift.evolution/7130/match=decimal)) as well, but this could fix an ongoing annoyance without a major change.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Thanks for your thoughts,<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; -- Erica<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
