<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>I’d like to discuss with the community to see their reactions on that topic.<br></p><p>Basically from the beginning of Swift I thought it was just confusing how these typealiases were used and named.<br>As we know from Apply API Guidelines to the Standard Library the Type suffix will be dropped.<br></p><p>Currently we also discuss about the `Any&lt;…&gt;` existential which may contain Any-type requirement one day (by ’type’ I mean `class`, `struct`, `enum` in a way like this: `Any&lt;class&gt;`).<br></p><p>The Any-class requirement could replace the current `AnyObject` protocol with a typealias like this: `typealias AnyObject = Any&lt;class&gt;`<br></p><p>Assume Swift would introduce Any-struct and Any-enum requirement one day. How would one name a typealias for these, where `AnyClass` means `AnyObject.Type`?<br></p><p>I suggest we drop the current `AnyClass` and rename `AnyObject` to `AnyClass`. If one would need the old `AnyClass` behavior it will become `AnyClass.Type`.<br></p><p>In the future we could have typealiases like this, which are more clear:<br></p><p>`typealias AnyClass = Any&lt;class&gt;`<br>`typealias AnyStruct = Any&lt;struct&gt;`<br>`typealias AnyEnum = Any&lt;enum&gt;`<br></p><p>I don’t know how the migration process works but I can assume that this should be done in the right order:<br></p><p>- migrate every `AnyClass` to `AnyClass.Type`<br>- at the end migrate `AnyObject` to `AnyClass`<br></p><p>What do you think? I’d write a small proposal if the community reaction is positive. <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4849afef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; The Any-class requirement could replace the current `AnyObject` protocol with a typealias like this: `typealias AnyObject = Any&lt;class&gt;`<br>&gt; <br>&gt; Assume Swift would introduce Any-struct and Any-enum requirement one day. How would one name a typealias for these, where `AnyClass` means `AnyObject.Type`?<br>&gt; <br>&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to `AnyClass`. If one would need the old `AnyClass` behavior it will become `AnyClass.Type`.<br></p><p>I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No typealias, just directly using `Any&lt;&gt;`. We would also deprecate `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do this by providing `AnyObject` and `AnyClass` typealiases in Swift 3, but marking them as deprecated.)<br></p><p>I like this approach because it exposes people to `Any&lt;&gt;` and more quickly gets them to see how it&#39;s connected to a protocol declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;` has other capabilities from that list, like the ability to handle multiple protocols.<br></p><p>&gt; In the future we could have typealiases like this, which are more clear:<br>&gt; <br>&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br></p><p>Even in the long term, I don&#39;t see any good reason to support `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction* between a struct and an enum; you can always implement something enum-y using a struct with a mode field, or something struct-y using an enum with associated values. `Bool`, for instance, was once an enum and was changed to a struct for implementation reasons; this change made no difference to how it was used.<br></p><p>Now, there *is* a semantic distinction between struct/enum and class—one is a value type, the other is a reference type. To support that distinction, it might make sense to support an `Any&lt;value&gt;` or `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;` syntax, though, not a typealias.<br></p><p>(I&#39;ve read the arguments about pure vs. non-pure value type conformances and I&#39;m not convinced. It is always possible to nominally &quot;conform&quot; to a protocol in a way that actually undermines its guarantees; for example, you could implement `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler cannot reject all invalid conformances; it can only reject ones which it can trivially show are invalid, because for instance they do not even attempt to provide a required method. Similarly, the compiler may not be able to prove you are providing value semantics, but it *can* reject conformances of reference types to a protocol requiring value semantics, since those cannot possibly be valid conformances.<br></p><p>Incidentally, I am not convinced that it *ever* makes sense to have a mutating protocol which does not specify either value or reference semantics. The only intentional Stdlib examples I&#39;m aware of are `IteratorProtocol` and `OutputStream`, and I think both of those should be reference-only.<br></p><p>(On the other hand, it might make sense to be able to mark a struct or enum as &quot;this is actually a reference type&quot;. For instance, if you import libc, UnsafeMutablePointer&lt;FILE&gt; is essentially a reference type. But on the gripping hand, you *could*, and perhaps should, just wrap it in a class, either through importer magic or a manually-created type. That would permit you to conform it to reference-typed mutating protocols.))<br></p><p><br></p><p>* There *are* some distinctions, particularly in pattern matching, but protocols can&#39;t model them anyway. Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br></p><p>    protocol OptionalProtocol { <br>        associatedtype W<br>        static var none: Self { get } <br>        static func some(value: W) -&gt; Self <br>    } <br>    extension Optional: OptionalProtocol {<br>        typealias W = Wrapped<br>    }<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 7:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The Any-class requirement could replace the current `AnyObject` protocol with a typealias like this: `typealias AnyObject = Any&lt;class&gt;`<br>&gt;&gt; <br>&gt;&gt; Assume Swift would introduce Any-struct and Any-enum requirement one day. How would one name a typealias for these, where `AnyClass` means `AnyObject.Type`?<br>&gt;&gt; <br>&gt;&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to `AnyClass`. If one would need the old `AnyClass` behavior it will become `AnyClass.Type`.<br>&gt; <br>&gt; I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No typealias, just directly using `Any&lt;&gt;`. We would also deprecate `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do this by providing `AnyObject` and `AnyClass` typealiases in Swift 3, but marking them as deprecated.)<br>&gt; <br>&gt; I like this approach because it exposes people to `Any&lt;&gt;` and more quickly gets them to see how it&#39;s connected to a protocol declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;` has other capabilities from that list, like the ability to handle multiple protocols.<br>&gt; <br>&gt;&gt; In the future we could have typealiases like this, which are more clear:<br>&gt;&gt; <br>&gt;&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt;&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br>&gt; <br>&gt; Even in the long term, I don&#39;t see any good reason to support `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction* between a struct and an enum; you can always implement something enum-y using a struct with a mode field, or something struct-y using an enum with associated values. `Bool`, for instance, was once an enum and was changed to a struct for implementation reasons; this change made no difference to how it was used.<br>&gt; <br>&gt; Now, there *is* a semantic distinction between struct/enum and class—one is a value type, the other is a reference type. To support that distinction, it might make sense to support an `Any&lt;value&gt;` or `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;` syntax, though, not a typealias.<br></p><p>You can implement reference types with value semantics and value types with reference semantics.  Until the compiler can verify value semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The semantic distinction is what is important.  There has been discussion about strengthening the “value type == value semantics” and “reference type == reference semantics” relations but that hasn’t yet moved beyond talk.<br></p><p>&gt; <br>&gt; (I&#39;ve read the arguments about pure vs. non-pure value type conformances and I&#39;m not convinced. It is always possible to nominally &quot;conform&quot; to a protocol in a way that actually undermines its guarantees; for example, you could implement `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler cannot reject all invalid conformances; it can only reject ones which it can trivially show are invalid, because for instance they do not even attempt to provide a required method. Similarly, the compiler may not be able to prove you are providing value semantics, but it *can* reject conformances of reference types to a protocol requiring value semantics, since those cannot possibly be valid conformances.<br></p><p>Immutable reference types actually *can* provide valid value semantics (at least as long as as they can provide their own implementation of `==` which I believe Dave A is arguing against).<br></p><p>There is a big difference between semantics that the compiler *could* but *does not yet* verify and semantics that simply cannot be verified.<br></p><p>&gt; <br>&gt; Incidentally, I am not convinced that it *ever* makes sense to have a mutating protocol which does not specify either value or reference semantics.<br>&gt; The only intentional Stdlib examples I&#39;m aware of are `IteratorProtocol` and `OutputStream`, and I think both of those should be reference-only.<br>&gt; <br>&gt; (On the other hand, it might make sense to be able to mark a struct or enum as &quot;this is actually a reference type&quot;. For instance, if you import libc, UnsafeMutablePointer&lt;FILE&gt; is essentially a reference type. But on the gripping hand, you *could*, and perhaps should, just wrap it in a class, either through importer magic or a manually-created type. That would permit you to conform it to reference-typed mutating protocols.))<br></p><p>This is a good example of why the semantics aren’t so simple.  <br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; * There *are* some distinctions, particularly in pattern matching, but protocols can&#39;t model them anyway. Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br>&gt; <br>&gt;    protocol OptionalProtocol { <br>&gt;        associatedtype W<br>&gt;        static var none: Self { get } <br>&gt;        static func some(value: W) -&gt; Self <br>&gt;    } <br>&gt;    extension Optional: OptionalProtocol {<br>&gt;        typealias W = Wrapped<br>&gt;    }<br></p><p>I think there was discussion at some point about introducing enum case requirements into protocols.  But that is mostly tangential to this discussion.<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; You can implement reference types with value semantics and value types with reference semantics.<br></p><p>&gt; Immutable reference types actually *can* provide valid value semantics (at least as long as as they can provide their own implementation of `==` which I believe Dave A is arguing against).<br></p><p>Not in the sense I mean—that is, not if the protocol has members which require you to mutate self.<br></p><p>If a reference type is immutable, you can treat it like a value type. But then it can&#39;t correctly conform to a protocol (like `RangeReplaceableCollection`) with mutating members, because it is *immutable*. It would have to take `self` as an `inout` parameter and replace `self` with a copy, but methods on classes cannot take `self` as an inout parameter. It&#39;s stuck.<br></p><p>In other words, there are three sensible types of protocols:<br></p><p>1. Protocols that do not require any self-mutating members, and do not assume either value or reference semantics.<br>2. Protocols that require self-mutating members, and assume value semantics.<br>3. Protocols that require self-mutating members, and assume reference semantics.<br></p><p>However, what Swift actually supports is:<br></p><p>1. Protocols that do not require any self-mutating members, and do not assume either value or reference semantics.<br>2. Protocols that require self-mutating members, and can be implemented by either classes or structs/enums.<br>3. Protocols that require self-mutating members, and must be implemented by classes.<br></p><p>The mismatch in #2 (between assuming value semantics and allowing classes to conform) is one source of mischief: the compiler does nothing to help you realize that you cannot possibly correctly conform a class to the protocol. Requiring you to use a struct or an enum is not *sufficient* to ensure you&#39;ll provide value semantics, but it is *necessary* in the face of self-mutation.<br></p><p>The mismatch in #3 (between assuming reference semantics and requiring a class) is another, separate source of mischief: your particular value type happens to provide reference semantics even in the face of self-mutation, but it can&#39;t conform to a class-constrained protocol. This *is* a problem, but I consider it less important because you can always wrap your value type in a class to convince the compiler you know what you&#39;re doing.<br></p><p>In #2, the compiler is not being cautious enough; in #3, it&#39;s being too cautious. You can work around #3, but there&#39;s no fix for the recklessness in #2.<br></p><p>&gt; Until the compiler can verify value semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The semantic distinction is what is important.  There has been discussion about strengthening the “value type == value semantics” and “reference type == reference semantics” relations but that hasn’t yet moved beyond talk.<br></p><p>Don&#39;t let the perfect be the enemy of the good. If the algorithm can&#39;t possibly work properly with a type that has reference semantics, then rejecting class types is a good first step, even if it doesn&#39;t reject every type with reference semantics.<br></p><p>&gt;&gt; (I&#39;ve read the arguments about pure vs. non-pure value type conformances and I&#39;m not convinced. It is always possible to nominally &quot;conform&quot; to a protocol in a way that actually undermines its guarantees; for example, you could implement `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler cannot reject all invalid conformances; it can only reject ones which it can trivially show are invalid, because for instance they do not even attempt to provide a required method. Similarly, the compiler may not be able to prove you are providing value semantics, but it *can* reject conformances of reference types to a protocol requiring value semantics, since those cannot possibly be valid conformances.<br>&gt; <br>&gt; There is a big difference between semantics that the compiler *could* but *does not yet* verify and semantics that simply cannot be verified.<br></p><p>And there&#39;s also a difference between research projects leading to large-scale changes to foundational language features and incremental fixes. `value` or `!class` or whatever we call it is something we could add to the language without any big redesigns or deep ponderings about the meaning of `==`. It would not be 100%, but it would filter out a fair bit of obviously incorrect code.<br></p><p>&gt;&gt; Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br>&gt; <br>&gt; But that is mostly tangential to this discussion.<br></p><p>Yes, that is very tangential. Honestly, it&#39;s kind of a tangent to a tangent.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 8:53 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; You can implement reference types with value semantics and value types with reference semantics.<br>&gt; <br>&gt;&gt; Immutable reference types actually *can* provide valid value semantics (at least as long as as they can provide their own implementation of `==` which I believe Dave A is arguing against).<br>&gt; <br>&gt; Not in the sense I mean—that is, not if the protocol has members which require you to mutate self.<br></p><p>Yes, it goes without saying that an immutable reference type cannot have a mutating member.<br></p><p>&gt; <br>&gt; If a reference type is immutable, you can treat it like a value type. But then it can&#39;t correctly conform to a protocol (like `RangeReplaceableCollection`) with mutating members, because it is *immutable*. It would have to take `self` as an `inout` parameter and replace `self` with a copy, but methods on classes cannot take `self` as an inout parameter. It&#39;s stuck.<br></p><p>It’s not just for that reason alone.  An immutable type would not be able to support operations that mutate, regardless of the need to take `self` as an `inout`parameter.  For example, if there were `NSImmutableArray` (`NSArray` does not guarantee immutability, it just doesn’t expose mutating operations) it would not be able to conform to `RangeReplaceableCollection` most importantly because you could not do things like `replaceSubrange`.<br></p><p>&gt; <br>&gt; In other words, there are three sensible types of protocols:<br>&gt; <br>&gt; 1. Protocols that do not require any self-mutating members, and do not assume either value or reference semantics.<br>&gt; 2. Protocols that require self-mutating members, and assume value semantics.<br>&gt; 3. Protocols that require self-mutating members, and assume reference semantics.<br></p><p>It is also sensible to have a protocol that requires value semantics even if it does not have mutating operations.  There are times when you want a guarantee that you will not observe mutations made by others.<br></p><p>&gt; <br>&gt; However, what Swift actually supports is: <br>&gt; <br>&gt; 1. Protocols that do not require any self-mutating members, and do not assume either value or reference semantics.<br>&gt; 2. Protocols that require self-mutating members, and can be implemented by either classes or structs/enums.<br>&gt; 3. Protocols that require self-mutating members, and must be implemented by classes.<br>&gt; <br>&gt; The mismatch in #2 (between assuming value semantics and allowing classes to conform) is one source of mischief: the compiler does nothing to help you realize that you cannot possibly correctly conform a class to the protocol. Requiring you to use a struct or an enum is not *sufficient* to ensure you&#39;ll provide value semantics, but it is *necessary* in the face of self-mutation.<br>&gt; <br>&gt; The mismatch in #3 (between assuming reference semantics and requiring a class) is another, separate source of mischief: your particular value type happens to provide reference semantics even in the face of self-mutation, but it can&#39;t conform to a class-constrained protocol. This *is* a problem, but I consider it less important because you can always wrap your value type in a class to convince the compiler you know what you&#39;re doing.<br>&gt; <br>&gt; In #2, the compiler is not being cautious enough; in #3, it&#39;s being too cautious. You can work around #3, but there&#39;s no fix for the recklessness in #2.<br>&gt; <br>&gt;&gt; Until the compiler can verify value semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The semantic distinction is what is important.  There has been discussion about strengthening the “value type == value semantics” and “reference type == reference semantics” relations but that hasn’t yet moved beyond talk.<br>&gt; <br>&gt; Don&#39;t let the perfect be the enemy of the good. If the algorithm can&#39;t possibly work properly with a type that has reference semantics, then rejecting class types is a good first step, even if it doesn&#39;t reject every type with reference semantics.<br></p><p>Fair enough.  But in that case I think we want something that does exactly that: rejects classes, rather than indicating value semantics.  We need to do this in a way that doesn’t lead to a situation where we used the word `value` to mean “value type”, and later we have the capability to very value semantics and really wish `value` could mean value semantics but that would be a breaking change we aren’t willing to make.<br></p><p>&gt; <br>&gt;&gt;&gt; (I&#39;ve read the arguments about pure vs. non-pure value type conformances and I&#39;m not convinced. It is always possible to nominally &quot;conform&quot; to a protocol in a way that actually undermines its guarantees; for example, you could implement `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler cannot reject all invalid conformances; it can only reject ones which it can trivially show are invalid, because for instance they do not even attempt to provide a required method. Similarly, the compiler may not be able to prove you are providing value semantics, but it *can* reject conformances of reference types to a protocol requiring value semantics, since those cannot possibly be valid conformances.<br>&gt;&gt; <br>&gt;&gt; There is a big difference between semantics that the compiler *could* but *does not yet* verify and semantics that simply cannot be verified.<br>&gt; <br>&gt; And there&#39;s also a difference between research projects leading to large-scale changes to foundational language features and incremental fixes. `value` or `!class` or whatever we call it is something we could add to the language without any big redesigns or deep ponderings about the meaning of `==`. It would not be 100%, but it would filter out a fair bit of obviously incorrect code.<br></p><p>I don’t think this is a research project.  IIRC the core team has already talked positively about supporting pure functions eventually, for example.  There is a lot of overlap in the work to verify that a function is pure and the work involved in verifying value semantics.<br></p><p>&gt; <br>&gt;&gt;&gt; Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br>&gt;&gt; <br>&gt;&gt; But that is mostly tangential to this discussion.<br>&gt; <br>&gt; Yes, that is very tangential. Honestly, it&#39;s kind of a tangent to a tangent.<br></p><p>I don’t think it’s that far off.  It’s related to Any&lt;enum&gt; because protocols with case requirements could only be implemented by an enum.  But that’s a discussion for another day (and is probably not the best way to achieve the goal behind that request anyway).<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/7ed313cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 21, 2016 at 08:00:00am</p></header><div class="content"><p>Fair enough.  But in that case I think we want something that does exactly that: rejects classes, rather than indicating value semantics.  We need to do this in a way that doesn’t lead to a situation where we used the word `value` to mean “value type”, and later we have the capability to very value semantics and really wish `value` could mean value semantics but that would be a breaking change we aren’t willing to make.<br>Exactly, `any&lt;class&gt;` is just a constraint that indicates which type it can hold, where `any&lt;struct&gt;` or `any&lt;enum&gt;` are two constraints and (not yet existing) counterparts to `any&lt;class&gt;`.<br></p><p>The idea behind `any&lt;struct&gt;` (or `any&lt;enum&gt;`) might look like this:<br></p><p>func foo(struct: any&lt;struct, SomeProtocol&gt;)<br></p><p>Where it is clear that you have to provide a custom struct which conforms to `SomeProtocol`, you’re not constrained to just a single struct, you can build as many as you want it it’s your desire. :)<br></p><p>Lets just imagine we already have `any&lt;…&gt;` and we also get `oneOf&lt;…&gt;` or `one&lt;…&gt;` which picks only one constraint at compile time and proceeds.<br></p><p>Here is what you could do for extendable types:<br></p><p>typealias AnyValue = one&lt;any&lt;struct&gt;, any&lt;enum&gt;&gt;<br></p><p>func boo(value: any&lt;AnyValue, SomeProtocol&gt;)<br></p><p>Not sure if we’ll get there or not but its a nice imagination. :)<br></p><p>I’m not exactly in favor of using `any&lt;class&gt;` instead of AnyClass but I’m openminded. :)<br></p><p>One problem to solve is the conformance to protocols:<br></p><p>If we’ll get `any&lt;…&gt;` and depricate `AnyClass` `AnyObject` we cannot do this directly:<br></p><p>protocol A: any&lt;class&gt; {}<br>protocol B: any&lt;ProtocolX, ProtocolY&gt;<br></p><p>We still need a typealias as a workaround:<br></p><p>typealias AnyClass = any&lt;class&gt;<br>typealias AnyXY = any&lt;ProtocolX, ProtocolY&gt;<br></p><p>protocol A: AnyClass {} furthermore is this protocol equivalent to protocol A: class {} ???<br>protocol B: AnyXY {}<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/ab40683b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 21, 2016 at 12:00:00am</p></header><div class="content"><p>Another thing to consider is that AnyObject currently has magic that allows any Objective-C method to be called upon it if Foundation is imported on an Apple platform. I think it may be desirable to have AnyObject become something like Any&lt;class&gt;, and have a differently-named construct take the place of an ersatz &#39;id&#39; type for Objective-C interop.<br></p><p>Austin<br></p><p>&gt; On May 20, 2016, at 11:42 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Fair enough.  But in that case I think we want something that does exactly that: rejects classes, rather than indicating value semantics.  We need to do this in a way that doesn’t lead to a situation where we used the word `value` to mean “value type”, and later we have the capability to very value semantics and really wish `value` could mean value semantics but that would be a breaking change we aren’t willing to make.<br>&gt; <br>&gt; Exactly, `any&lt;class&gt;` is just a constraint that indicates which type it can hold, where `any&lt;struct&gt;` or `any&lt;enum&gt;` are two constraints and (not yet existing) counterparts to `any&lt;class&gt;`.<br>&gt; <br>&gt; The idea behind `any&lt;struct&gt;` (or `any&lt;enum&gt;`) might look like this:<br>&gt; <br>&gt; func foo(struct: any&lt;struct, SomeProtocol&gt;)<br>&gt; <br>&gt; Where it is clear that you have to provide a custom struct which conforms to `SomeProtocol`, you’re not constrained to just a single struct, you can build as many as you want it it’s your desire. :)<br>&gt; <br>&gt; Lets just imagine we already have `any&lt;…&gt;` and we also get `oneOf&lt;…&gt;` or `one&lt;…&gt;` which picks only one constraint at compile time and proceeds.<br>&gt; <br>&gt; Here is what you could do for extendable types:<br>&gt; <br>&gt; typealias AnyValue = one&lt;any&lt;struct&gt;, any&lt;enum&gt;&gt;<br>&gt; <br>&gt; func boo(value: any&lt;AnyValue, SomeProtocol&gt;)<br>&gt; <br>&gt; Not sure if we’ll get there or not but its a nice imagination. :)<br>&gt; <br>&gt; I’m not exactly in favor of using `any&lt;class&gt;` instead of AnyClass but I’m openminded. :)<br>&gt; <br>&gt; One problem to solve is the conformance to protocols:<br>&gt; <br>&gt; If we’ll get `any&lt;…&gt;` and depricate `AnyClass` `AnyObject` we cannot do this directly:<br>&gt; <br>&gt; protocol A: any&lt;class&gt; {}<br>&gt; protocol B: any&lt;ProtocolX, ProtocolY&gt;<br>&gt; <br>&gt; We still need a typealias as a workaround:<br>&gt; <br>&gt; typealias AnyClass = any&lt;class&gt;<br>&gt; typealias AnyXY = any&lt;ProtocolX, ProtocolY&gt;<br>&gt; <br>&gt; protocol A: AnyClass {} furthermore is this protocol equivalent to protocol A: class {} ???<br>&gt; protocol B: AnyXY {}<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/d0a4ccfb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 21, 2016 at 09:00:00am</p></header><div class="content"><p>Another thing to consider is that AnyObject currently has magic that allows any Objective-C method to be called upon it if Foundation is imported on an Apple platform. I think it may be desirable to have AnyObject become something like Any&lt;class&gt;, and have a differently-named construct take the place of an ersatz &#39;id&#39; type for Objective-C interop.<br>I’m not sure if this will be the case, just because this proposal is accepted:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md<br></p><p>And this might be accepted as well (which I defiantly support):<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0083-remove-bridging-from-dynamic-casts.md<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/143901be/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 21, 2016 at 11:00:00am</p></header><div class="content"><p>Straight Any&lt;class&gt; sounds good to me. Otherwise keep it at AnyObject. Renaming it to AnyClass does not seem right, especially as there already is one present in Swift 2 with the different meaning.<br></p><p><br>&gt; On 21 May 2016, at 10:40 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The Any-class requirement could replace the current `AnyObject` protocol with a typealias like this: `typealias AnyObject = Any&lt;class&gt;`<br>&gt;&gt; <br>&gt;&gt; Assume Swift would introduce Any-struct and Any-enum requirement one day. How would one name a typealias for these, where `AnyClass` means `AnyObject.Type`?<br>&gt;&gt; <br>&gt;&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to `AnyClass`. If one would need the old `AnyClass` behavior it will become `AnyClass.Type`.<br>&gt; <br>&gt; I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No typealias, just directly using `Any&lt;&gt;`. We would also deprecate `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do this by providing `AnyObject` and `AnyClass` typealiases in Swift 3, but marking them as deprecated.)<br>&gt; <br>&gt; I like this approach because it exposes people to `Any&lt;&gt;` and more quickly gets them to see how it&#39;s connected to a protocol declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;` has other capabilities from that list, like the ability to handle multiple protocols.<br>&gt; <br>&gt;&gt; In the future we could have typealiases like this, which are more clear:<br>&gt;&gt; <br>&gt;&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt;&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br>&gt; <br>&gt; Even in the long term, I don&#39;t see any good reason to support `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction* between a struct and an enum; you can always implement something enum-y using a struct with a mode field, or something struct-y using an enum with associated values. `Bool`, for instance, was once an enum and was changed to a struct for implementation reasons; this change made no difference to how it was used.<br>&gt; <br>&gt; Now, there *is* a semantic distinction between struct/enum and class—one is a value type, the other is a reference type. To support that distinction, it might make sense to support an `Any&lt;value&gt;` or `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;` syntax, though, not a typealias.<br>&gt; <br>&gt; (I&#39;ve read the arguments about pure vs. non-pure value type conformances and I&#39;m not convinced. It is always possible to nominally &quot;conform&quot; to a protocol in a way that actually undermines its guarantees; for example, you could implement `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler cannot reject all invalid conformances; it can only reject ones which it can trivially show are invalid, because for instance they do not even attempt to provide a required method. Similarly, the compiler may not be able to prove you are providing value semantics, but it *can* reject conformances of reference types to a protocol requiring value semantics, since those cannot possibly be valid conformances.<br>&gt; <br>&gt; Incidentally, I am not convinced that it *ever* makes sense to have a mutating protocol which does not specify either value or reference semantics. The only intentional Stdlib examples I&#39;m aware of are `IteratorProtocol` and `OutputStream`, and I think both of those should be reference-only.<br>&gt; <br>&gt; (On the other hand, it might make sense to be able to mark a struct or enum as &quot;this is actually a reference type&quot;. For instance, if you import libc, UnsafeMutablePointer&lt;FILE&gt; is essentially a reference type. But on the gripping hand, you *could*, and perhaps should, just wrap it in a class, either through importer magic or a manually-created type. That would permit you to conform it to reference-typed mutating protocols.))<br>&gt; <br>&gt; <br>&gt; <br>&gt; * There *are* some distinctions, particularly in pattern matching, but protocols can&#39;t model them anyway. Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br>&gt; <br>&gt;    protocol OptionalProtocol { <br>&gt;        associatedtype W<br>&gt;        static var none: Self { get } <br>&gt;        static func some(value: W) -&gt; Self <br>&gt;    } <br>&gt;    extension Optional: OptionalProtocol {<br>&gt;        typealias W = Wrapped<br>&gt;    }<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
