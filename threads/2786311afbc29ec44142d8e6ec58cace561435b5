<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>Consistent formal type for &#39;self&#39; in class methods<br></p><p>Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/9999-self-formal-type-in-class.md&gt;<br>Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>Status: Awaiting review<br>Review manager: TBD<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#introduction&gt;Introduction<br></p><p>This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br></p><p>Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br> &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#motivation&gt;Motivation<br></p><p>Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br></p><p>Consider the following code:<br></p><p>class Base {<br>  @discardableResult<br>  func methodWithDynamicSelf() -&gt; Self {<br>    doSomething(self)<br>    return self<br>  }<br></p><p>  func methodWithoutDynamicSelf() {<br>    doSomething(self)<br>  }<br>}<br></p><p>class Derived : Base {}<br></p><p>func doSomething&lt;T&gt;(_ t: T) {<br>  print(T.self)<br>}<br></p><p>Base().methodWithDynamicSelf()<br>Base().methodWithoutDynamicSelf()<br></p><p>Derived().methodWithDynamicSelf()<br>Derived().methodWithoutDynamicSelf()<br>Currently, it prints the following output:<br></p><p>Base<br>Base<br>Derived<br>Base<br>Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br></p><p><br> &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#proposed-solution&gt;Proposed solution<br></p><p>The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br></p><p>With this proposal, the above code will instead produce the following:<br></p><p>Base<br>Base<br>Derived<br>Derived<br>Here, the type of self would always be Derived when called on an instance of the derived class.<br></p><p>Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br></p><p>This also dovetails nicely with SE-0068 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/0068-universal-self.md&gt;.<br></p><p>Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br></p><p>class ArtClass {<br>  func paint(withBrush: (Self) -&gt; ()) { ... }<br>}<br>This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br></p><p>protocol OddProtocol {<br>  func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>}<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#detailed-design&gt;Detailed design<br></p><p>There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br></p><p><br> &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#impact-on-existing-code&gt;Impact on existing code<br></p><p>This will have a small impact on existing code that uses a pattern similar to the above.<br></p><p><br> &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#alternatives-considered&gt;Alternatives considered<br></p><p>One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/278635b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>+1.  I have not encountered this issue myself but it looks like something that would cause a lot of head scratching if I had.  It is also something that I am unlikely to remember immediately if I run into it in the future.  The current behavior appears broken to me.  It will be great to have it fixed.<br></p><p>&gt; On Jun 23, 2016, at 2:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt; <br>&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/9999-self-formal-type-in-class.md&gt;<br>&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#motivation&gt;Motivation<br>&gt; <br>&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; class Base {<br>&gt;   @discardableResult<br>&gt;   func methodWithDynamicSelf() -&gt; Self {<br>&gt;     doSomething(self)<br>&gt;     return self<br>&gt;   }<br>&gt; <br>&gt;   func methodWithoutDynamicSelf() {<br>&gt;     doSomething(self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Derived : Base {}<br>&gt; <br>&gt; func doSomething&lt;T&gt;(_ t: T) {<br>&gt;   print(T.self)<br>&gt; }<br>&gt; <br>&gt; Base().methodWithDynamicSelf()<br>&gt; Base().methodWithoutDynamicSelf()<br>&gt; <br>&gt; Derived().methodWithDynamicSelf()<br>&gt; Derived().methodWithoutDynamicSelf()<br>&gt; Currently, it prints the following output:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Base<br>&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt; <br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt; <br>&gt; With this proposal, the above code will instead produce the following:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Derived<br>&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt; <br>&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt; <br>&gt; This also dovetails nicely with SE-0068 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/0068-universal-self.md&gt;.<br>&gt; <br>&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt; <br>&gt; class ArtClass {<br>&gt;   func paint(withBrush: (Self) -&gt; ()) { ... }<br>&gt; }<br>&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt; <br>&gt; protocol OddProtocol {<br>&gt;   func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt; }<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#detailed-design&gt;Detailed design<br>&gt; <br>&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt; <br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/f6067902/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>Great to hear some feedback so quickly, especially about something so mundane.<br></p><p>I suspect the real reason it doesn’t work this way now is that ‘Self’ is not fully plumbed through. In particular, if a closure captures the ‘Self’ type, IRGen does not properly codegen it, causing compile-time or run-time crashes:<br></p><p>class MyClass {<br>	func foo(x: Int) -&gt; Self {<br></p><p>		// Crash!<br>		_ = { print(self); print(x) }<br></p><p>		return self<br>	}<br></p><p>	func bar(x: Int) -&gt; MyClass {<br></p><p>		// OK!<br>		_ = { print(self); print(x) }<br></p><p>		return self<br>	}<br>}<br></p><p>Assertion failed: (LocalSelf &amp;&amp; &quot;no local self metadata&quot;), function getLocalSelfMetadata, file /Users/slava/new/swift/lib/IRGen/GenType.cpp, line 1805.<br>0  swift                    0x0000000114d5276e llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) + 46<br>1  swift                    0x0000000114d52c99 PrintStackTraceSignalHandler(void*) + 25<br>2  swift                    0x0000000114d4efc9 llvm::sys::RunSignalHandlers() + 425<br>3  swift                    0x0000000114d53312 SignalHandler(int) + 354<br>4  libsystem_platform.dylib 0x00007fffc438a01a _sigtramp + 26<br>5  libsystem_platform.dylib 0x00000000507ca710 _sigtramp + 2353268496<br>6  swift                    0x0000000114d52cbb raise + 27<br>7  swift                    0x0000000114d52d62 abort + 18<br>8  swift                    0x0000000114d52d4e __assert_rtn + 126<br>9  swift                    0x000000010f6e8524 swift::irgen::IRGenFunction::getLocalSelfMetadata() + 100<br></p><p>This comes up most frequently with the ‘weak self / strong self’ dance.<br></p><p>I’m going to fix this bug really soon, and it seems logical to deal with the language wart as well. We need the IRGen fix for SE-0086 as well in any case.<br></p><p>Slava<br></p><p>&gt; On Jun 23, 2016, at 1:08 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; +1.  I have not encountered this issue myself but it looks like something that would cause a lot of head scratching if I had.  It is also something that I am unlikely to remember immediately if I run into it in the future.  The current behavior appears broken to me.  It will be great to have it fixed.<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 2:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/9999-self-formal-type-in-class.md&gt;<br>&gt;&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt;&gt; <br>&gt;&gt; Consider the following code:<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;   @discardableResult<br>&gt;&gt;   func methodWithDynamicSelf() -&gt; Self {<br>&gt;&gt;     doSomething(self)<br>&gt;&gt;     return self<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   func methodWithoutDynamicSelf() {<br>&gt;&gt;     doSomething(self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived : Base {}<br>&gt;&gt; <br>&gt;&gt; func doSomething&lt;T&gt;(_ t: T) {<br>&gt;&gt;   print(T.self)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Base().methodWithDynamicSelf()<br>&gt;&gt; Base().methodWithoutDynamicSelf()<br>&gt;&gt; <br>&gt;&gt; Derived().methodWithDynamicSelf()<br>&gt;&gt; Derived().methodWithoutDynamicSelf()<br>&gt;&gt; Currently, it prints the following output:<br>&gt;&gt; <br>&gt;&gt; Base<br>&gt;&gt; Base<br>&gt;&gt; Derived<br>&gt;&gt; Base<br>&gt;&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt; <br>&gt;&gt; With this proposal, the above code will instead produce the following:<br>&gt;&gt; <br>&gt;&gt; Base<br>&gt;&gt; Base<br>&gt;&gt; Derived<br>&gt;&gt; Derived<br>&gt;&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt;&gt; <br>&gt;&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt;&gt; <br>&gt;&gt; This also dovetails nicely with SE-0068 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/0068-universal-self.md&gt;.<br>&gt;&gt; <br>&gt;&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt;&gt; <br>&gt;&gt; class ArtClass {<br>&gt;&gt;   func paint(withBrush: (Self) -&gt; ()) { ... }<br>&gt;&gt; }<br>&gt;&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt;&gt; <br>&gt;&gt; protocol OddProtocol {<br>&gt;&gt;   func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/3219cdb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 23, 2016, at 3:12 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; Great to hear some feedback so quickly, especially about something so mundane.<br></p><p>You caught me at the right time I guess.  :)  <br></p><p>This kind of thing is only mundane until your code doesn&#39;t behave as you expect.  Then it can become downright maddening!  I would never in a million years guess that the return type would affect the interpretation of self in this way.<br></p><p>BTW, allowing Self to appear in covarying positions in argument types and the protocol conformances this will enable are a very nice bonus (even if it doesn&#39;t happen right away).<br></p><p>&gt; <br>&gt; I suspect the real reason it doesn’t work this way now is that ‘Self’ is not fully plumbed through. In particular, if a closure captures the ‘Self’ type, IRGen does not properly codegen it, causing compile-time or run-time crashes:<br>&gt; <br>&gt; class MyClass {<br>&gt; 	func foo(x: Int) -&gt; Self {<br>&gt; <br>&gt; 		// Crash!<br>&gt; 		_ = { print(self); print(x) }<br>&gt; <br>&gt; 		return self<br>&gt; 	}<br>&gt; <br>&gt; 	func bar(x: Int) -&gt; MyClass {<br>&gt; <br>&gt; 		// OK!<br>&gt; 		_ = { print(self); print(x) }<br>&gt; <br>&gt; 		return self<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Assertion failed: (LocalSelf &amp;&amp; &quot;no local self metadata&quot;), function getLocalSelfMetadata, file /Users/slava/new/swift/lib/IRGen/GenType.cpp, line 1805.<br>&gt; 0  swift                    0x0000000114d5276e llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) + 46<br>&gt; 1  swift                    0x0000000114d52c99 PrintStackTraceSignalHandler(void*) + 25<br>&gt; 2  swift                    0x0000000114d4efc9 llvm::sys::RunSignalHandlers() + 425<br>&gt; 3  swift                    0x0000000114d53312 SignalHandler(int) + 354<br>&gt; 4  libsystem_platform.dylib 0x00007fffc438a01a _sigtramp + 26<br>&gt; 5  libsystem_platform.dylib 0x00000000507ca710 _sigtramp + 2353268496<br>&gt; 6  swift                    0x0000000114d52cbb raise + 27<br>&gt; 7  swift                    0x0000000114d52d62 abort + 18<br>&gt; 8  swift                    0x0000000114d52d4e __assert_rtn + 126<br>&gt; 9  swift                    0x000000010f6e8524 swift::irgen::IRGenFunction::getLocalSelfMetadata() + 100<br>&gt; <br>&gt; This comes up most frequently with the ‘weak self / strong self’ dance.<br>&gt; <br>&gt; I’m going to fix this bug really soon, and it seems logical to deal with the language wart as well. We need the IRGen fix for SE-0086 as well in any case.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:08 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1.  I have not encountered this issue myself but it looks like something that would cause a lot of head scratching if I had.  It is also something that I am unlikely to remember immediately if I run into it in the future.  The current behavior appears broken to me.  It will be great to have it fixed.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 2:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt;&gt;&gt; Proposal: SE-9999<br>&gt;&gt;&gt; Author: Slava Pestov<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;   @discardableResult<br>&gt;&gt;&gt;   func methodWithDynamicSelf() -&gt; Self {<br>&gt;&gt;&gt;     doSomething(self)<br>&gt;&gt;&gt;     return self<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func methodWithoutDynamicSelf() {<br>&gt;&gt;&gt;     doSomething(self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Derived : Base {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething&lt;T&gt;(_ t: T) {<br>&gt;&gt;&gt;   print(T.self)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Base().methodWithDynamicSelf()<br>&gt;&gt;&gt; Base().methodWithoutDynamicSelf()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Derived().methodWithDynamicSelf()<br>&gt;&gt;&gt; Derived().methodWithoutDynamicSelf()<br>&gt;&gt;&gt; Currently, it prints the following output:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Base<br>&gt;&gt;&gt; Base<br>&gt;&gt;&gt; Derived<br>&gt;&gt;&gt; Base<br>&gt;&gt;&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this proposal, the above code will instead produce the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Base<br>&gt;&gt;&gt; Base<br>&gt;&gt;&gt; Derived<br>&gt;&gt;&gt; Derived<br>&gt;&gt;&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This also dovetails nicely with SE-0068.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class ArtClass {<br>&gt;&gt;&gt;   func paint(withBrush: (Self) -&gt; ()) { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol OddProtocol {<br>&gt;&gt;&gt;   func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/71c13406/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>This is certainly surprisingly behavior to me! +1<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 23, 2016, at 2:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt; <br>&gt; 	• Proposal: SE-9999<br>&gt; 	• Author: Slava Pestov<br>&gt; 	• Status: Awaiting review<br>&gt; 	• Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; <br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; class<br>&gt;  Base {<br>&gt;   <br>&gt; @discardableResult<br>&gt; <br>&gt;   <br>&gt; func methodWithDynamicSelf() -&gt;<br>&gt;  Self {<br>&gt;     doSomething(<br>&gt; self<br>&gt; )<br>&gt;     <br>&gt; return self<br>&gt; <br>&gt;   }<br>&gt; <br>&gt;   <br>&gt; func methodWithoutDynamicSelf<br>&gt; () {<br>&gt;     doSomething(<br>&gt; self<br>&gt; )<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Derived :<br>&gt;  Base {}<br>&gt; <br>&gt; <br>&gt; func doSomething&lt;T&gt;(_ t<br>&gt; : T) {<br>&gt;   <br>&gt; print(T.self<br>&gt; )<br>&gt; }<br>&gt; <br>&gt; Base()<br>&gt; .<br>&gt; methodWithDynamicSelf()<br>&gt; Base()<br>&gt; .<br>&gt; methodWithoutDynamicSelf()<br>&gt; <br>&gt; Derived()<br>&gt; .<br>&gt; methodWithDynamicSelf()<br>&gt; Derived()<br>&gt; .methodWithoutDynamicSelf()<br>&gt; Currently, it prints the following output:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Base<br>&gt; <br>&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt; <br>&gt; With this proposal, the above code will instead produce the following:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Derived<br>&gt; <br>&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt; <br>&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt; <br>&gt; This also dovetails nicely with SE-0068.<br>&gt; <br>&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt; <br>&gt; class<br>&gt;  ArtClass {<br>&gt;   <br>&gt; func paint(withBrush: (Self) -&gt; ()) { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt; <br>&gt; protocol<br>&gt;  OddProtocol {<br>&gt;   <br>&gt; func weaken&lt;X, Y&gt;((Self) -&gt;<br>&gt;  (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br></p><p>We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br></p><p>- Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/daef30ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:46 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt; <br>&gt; We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br>&gt; <br>&gt; - Andy<br></p><p>I’m not sure what that means. Do you currently punt on certain optimizations if a method returns ‘Self’?<br></p><p>It should be possible to keep the reified type information around, by passing in a metatype or something for example. Can you give a concrete code snippet demonstrating the optimization and how this change would inhibit it?<br></p><p>Slava<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/8c1a1c7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:48 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:46 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt; <br>&gt;&gt; We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br>&gt;&gt; <br>&gt;&gt; - Andy<br>&gt; <br>&gt; I’m not sure what that means. Do you currently punt on certain optimizations if a method returns ‘Self’?<br>&gt; <br>&gt; It should be possible to keep the reified type information around, by passing in a metatype or something for example. Can you give a concrete code snippet demonstrating the optimization and how this change would inhibit it?<br></p><p>We bail out of generic specialization, inlining, and function signature specialization when a type substitution contains dynamic self. (hasDynamicSelfTypes). So, yes we currently almost entirely punt on optimization for methods that return Self.<br></p><p>I don’t have an interesting case to point out. You can look into any trivial example:<br></p><p>func foo&lt;T&gt;(_: T) {}<br></p><p>func method() {<br>  foo(self)<br>}<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/46174f3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 2:02 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:48 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 1:46 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Andy<br>&gt;&gt; <br>&gt;&gt; I’m not sure what that means. Do you currently punt on certain optimizations if a method returns ‘Self’?<br>&gt;&gt; <br>&gt;&gt; It should be possible to keep the reified type information around, by passing in a metatype or something for example. Can you give a concrete code snippet demonstrating the optimization and how this change would inhibit it?<br>&gt; <br>&gt; We bail out of generic specialization, inlining, and function signature specialization when a type substitution contains dynamic self. (hasDynamicSelfTypes). So, yes we currently almost entirely punt on optimization for methods that return Self.<br></p><p>I see. That makes sense.<br></p><p>I think the problem is that if we specialize a top-level function with a substitution involving Self, we have no way to recover what the ‘Self’ type actually is in IRGen. However I think it could be made to work by passing in a metatype for Self, and somehow ensuring we don’t mix up Self from two different contexts...<br></p><p>This is certainly a trickier change than I first imagined, but it would be nice to figure out how to solve this in a principled way so that we can get these optimizations to be more generally applicable. It seems even more surprising, now, if changing the return type of a method inhibits optimizations in a non-obvious way, especially ones that can have a drastic effect on performance.<br></p><p>I think next week I’ll try implementing this proposal behind a staging flag, and play around with the optimizer to see how hard it would be plumb through the relevant type information.<br></p><p>Slava<br></p><p>&gt; <br>&gt; I don’t have an interesting case to point out. You can look into any trivial example:<br>&gt; <br>&gt; func foo&lt;T&gt;(_: T) {}<br>&gt; <br>&gt; func method() {<br>&gt;   foo(self)<br>&gt; }<br>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/a0431d76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 2:06 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 2:02 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 1:48 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 1:46 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure what that means. Do you currently punt on certain optimizations if a method returns ‘Self’?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It should be possible to keep the reified type information around, by passing in a metatype or something for example. Can you give a concrete code snippet demonstrating the optimization and how this change would inhibit it?<br>&gt;&gt; <br>&gt;&gt; We bail out of generic specialization, inlining, and function signature specialization when a type substitution contains dynamic self. (hasDynamicSelfTypes). So, yes we currently almost entirely punt on optimization for methods that return Self.<br>&gt; <br>&gt; I see. That makes sense.<br>&gt; <br>&gt; I think the problem is that if we specialize a top-level function with a substitution involving Self, we have no way to recover what the ‘Self’ type actually is in IRGen. However I think it could be made to work by passing in a metatype for Self, and somehow ensuring we don’t mix up Self from two different contexts...<br>&gt; <br>&gt; This is certainly a trickier change than I first imagined, but it would be nice to figure out how to solve this in a principled way so that we can get these optimizations to be more generally applicable. It seems even more surprising, now, if changing the return type of a method inhibits optimizations in a non-obvious way, especially ones that can have a drastic effect on performance.<br>&gt; <br>&gt; I think next week I’ll try implementing this proposal behind a staging flag, and play around with the optimizer to see how hard it would be plumb through the relevant type information.<br>&gt; <br>&gt; Slava<br></p><p>Perfect. I didn’t mean to discourage you, just warn you that some benchmarking and optimizer work is also needed.<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t have an interesting case to point out. You can look into any trivial example:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(_: T) {}<br>&gt;&gt; <br>&gt;&gt; func method() {<br>&gt;&gt;   foo(self)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/9cb02488/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 2:08 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 23, 2016, at 2:06 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 2:02 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 1:48 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 23, 2016, at 1:46 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Andy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure what that means. Do you currently punt on certain optimizations if a method returns ‘Self’?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It should be possible to keep the reified type information around, by passing in a metatype or something for example. Can you give a concrete code snippet demonstrating the optimization and how this change would inhibit it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We bail out of generic specialization, inlining, and function signature specialization when a type substitution contains dynamic self. (hasDynamicSelfTypes). So, yes we currently almost entirely punt on optimization for methods that return Self.<br>&gt;&gt; <br>&gt;&gt; I see. That makes sense.<br>&gt;&gt; <br>&gt;&gt; I think the problem is that if we specialize a top-level function with a substitution involving Self, we have no way to recover what the ‘Self’ type actually is in IRGen. However I think it could be made to work by passing in a metatype for Self, and somehow ensuring we don’t mix up Self from two different contexts...<br>&gt;&gt; <br>&gt;&gt; This is certainly a trickier change than I first imagined, but it would be nice to figure out how to solve this in a principled way so that we can get these optimizations to be more generally applicable. It seems even more surprising, now, if changing the return type of a method inhibits optimizations in a non-obvious way, especially ones that can have a drastic effect on performance.<br>&gt;&gt; <br>&gt;&gt; I think next week I’ll try implementing this proposal behind a staging flag, and play around with the optimizer to see how hard it would be plumb through the relevant type information.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt; <br>&gt; Perfect. I didn’t mean to discourage you, just warn you that some benchmarking and optimizer work is also needed.<br>&gt; <br></p><p>No worries :) Dynamic ‘Self’ is one of the dark corners of Swift I don’t fully understand — so the proposal is as much about cleaning it up as clarifying my own understanding of the issues.<br></p><p><br></p><p>&gt; -Andy<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t have an interesting case to point out. You can look into any trivial example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T&gt;(_: T) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func method() {<br>&gt;&gt;&gt;   foo(self)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/6194499c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 24, 2016 at 06:00:00am</p></header><div class="content"><p>Quick (semi) related question: any particular reason for .Type to be a contextual kwd rather than defined on a protocol? (No concrete def for metatypes?)<br>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 23, 2016, at 11:02 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 1:48 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 1:46 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’re currently specializing functions that take `self` as an argument. I don’t think that will be possible after your proposed change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Andy<br>&gt;&gt; <br>&gt;&gt; I’m not sure what that means. Do you currently punt on certain optimizations if a method returns ‘Self’?<br>&gt;&gt; <br>&gt;&gt; It should be possible to keep the reified type information around, by passing in a metatype or something for example. Can you give a concrete code snippet demonstrating the optimization and how this change would inhibit it?<br>&gt; <br>&gt; We bail out of generic specialization, inlining, and function signature specialization when a type substitution contains dynamic self. (hasDynamicSelfTypes). So, yes we currently almost entirely punt on optimization for methods that return Self.<br>&gt; <br>&gt; I don’t have an interesting case to point out. You can look into any trivial example:<br>&gt; <br>&gt; func foo&lt;T&gt;(_: T) {}<br>&gt; <br>&gt; func method() {<br>&gt;   foo(self)<br>&gt; }<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/1366102f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 24, 2016 at 12:00:00am</p></header><div class="content"><p>This looks great to me. Much more sane. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 23, 2016, at 12:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt; Proposal: SE-9999<br>&gt; Author: Slava Pestov<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; class Base {<br>&gt;   @discardableResult<br>&gt;   func methodWithDynamicSelf() -&gt; Self {<br>&gt;     doSomething(self)<br>&gt;     return self<br>&gt;   }<br>&gt; <br>&gt;   func methodWithoutDynamicSelf() {<br>&gt;     doSomething(self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Derived : Base {}<br>&gt; <br>&gt; func doSomething&lt;T&gt;(_ t: T) {<br>&gt;   print(T.self)<br>&gt; }<br>&gt; <br>&gt; Base().methodWithDynamicSelf()<br>&gt; Base().methodWithoutDynamicSelf()<br>&gt; <br>&gt; Derived().methodWithDynamicSelf()<br>&gt; Derived().methodWithoutDynamicSelf()<br>&gt; Currently, it prints the following output:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Base<br>&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt; <br>&gt; With this proposal, the above code will instead produce the following:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Derived<br>&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt; <br>&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt; <br>&gt; This also dovetails nicely with SE-0068.<br>&gt; <br>&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt; <br>&gt; class ArtClass {<br>&gt;   func paint(withBrush: (Self) -&gt; ()) { ... }<br>&gt; }<br>&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt; <br>&gt; protocol OddProtocol {<br>&gt;   func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt; }<br>&gt; Detailed design<br>&gt; <br>&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/0308c396/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June 24, 2016 at 06:00:00am</p></header><div class="content"><p>+1; I *really* appreciate taking a proactive approach to eliminating future sources of bizarre “gotcha” moments!<br></p><p>&gt; On Jun 23, 2016, at 2:53 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt; <br>&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/9999-self-formal-type-in-class.md&gt;<br>&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#motivation&gt;Motivation<br>&gt; <br>&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; class Base {<br>&gt;   @discardableResult<br>&gt;   func methodWithDynamicSelf() -&gt; Self {<br>&gt;     doSomething(self)<br>&gt;     return self<br>&gt;   }<br>&gt; <br>&gt;   func methodWithoutDynamicSelf() {<br>&gt;     doSomething(self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Derived : Base {}<br>&gt; <br>&gt; func doSomething&lt;T&gt;(_ t: T) {<br>&gt;   print(T.self)<br>&gt; }<br>&gt; <br>&gt; Base().methodWithDynamicSelf()<br>&gt; Base().methodWithoutDynamicSelf()<br>&gt; <br>&gt; Derived().methodWithDynamicSelf()<br>&gt; Derived().methodWithoutDynamicSelf()<br>&gt; Currently, it prints the following output:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Base<br>&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt; <br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt; <br>&gt; With this proposal, the above code will instead produce the following:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Derived<br>&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt; <br>&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt; <br>&gt; This also dovetails nicely with SE-0068 &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/0068-universal-self.md&gt;.<br>&gt; <br>&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt; <br>&gt; class ArtClass {<br>&gt;   func paint(withBrush: (Self) -&gt; ()) { ... }<br>&gt; }<br>&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt; <br>&gt; protocol OddProtocol {<br>&gt;   func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt; }<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#detailed-design&gt;Detailed design<br>&gt; <br>&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt; <br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/9279bd4a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 24, 2016 at 05:00:00pm</p></header><div class="content"><p>+1. This should be fixed.<br></p><p>On 23.06.2016 22:53, Slava Pestov via swift-evolution wrote:<br>&gt;<br>&gt;   Consistent formal type for &#39;self&#39; in class methods<br>&gt;<br>&gt;<br>&gt;     * Proposal: SE-9999<br>&gt;       &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/9999-self-formal-type-in-class.md&gt;<br>&gt;     * Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;     * Status: Awaiting review<br>&gt;     * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#introduction&gt;Introduction<br>&gt;<br>&gt;<br>&gt;   This proposal makes the |self| value behave consistently whether or not<br>&gt;   it is used from a method with a |Self| return type.<br>&gt;<br>&gt;   Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;   &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#motivation&gt;Motivation<br>&gt;<br>&gt;<br>&gt;   Right now, we exhibit inconsistent behavior when |self| is used as an<br>&gt;   argument to a generic function, violating the principle of least surprise.<br>&gt;<br>&gt;   Consider the following code:<br>&gt;<br>&gt;   class Base {<br>&gt;     @discardableResult<br>&gt;     func methodWithDynamicSelf() -&gt; Self {<br>&gt;       doSomething(self)<br>&gt;       return self<br>&gt;     }<br>&gt;<br>&gt;     func methodWithoutDynamicSelf() {<br>&gt;       doSomething(self)<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt;   class Derived : Base {}<br>&gt;<br>&gt;   func doSomething&lt;T&gt;(_ t: T) {<br>&gt;     print(T.self)<br>&gt;   }<br>&gt;<br>&gt;   Base().methodWithDynamicSelf()<br>&gt;   Base().methodWithoutDynamicSelf()<br>&gt;<br>&gt;   Derived().methodWithDynamicSelf()<br>&gt;   Derived().methodWithoutDynamicSelf()<br>&gt;<br>&gt;   Currently, it prints the following output:<br>&gt;<br>&gt;   Base<br>&gt;   Base<br>&gt;   Derived<br>&gt;   Base<br>&gt;<br>&gt;   Note that there&#39;s no inconsistency when the method is called on the base<br>&gt;   class. When called on the derived class however, we see that in a method<br>&gt;   with a dynamic |Self| return type, the type of |self| is |Derived|,<br>&gt;   whereas in a method with any other return type, the type of |self| is |Base|.<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#proposed-solution&gt;Proposed<br>&gt;     solution<br>&gt;<br>&gt;<br>&gt;   The proposal is to change the type of |self| to always be |Self|, which<br>&gt;   can be thought of as a special generic type parameter bound to the<br>&gt;   dynamic type of the instance.<br>&gt;<br>&gt;   With this proposal, the above code will instead produce the following:<br>&gt;<br>&gt;   Base<br>&gt;   Base<br>&gt;   Derived<br>&gt;   Derived<br>&gt;<br>&gt;   Here, the type of |self| would always be |Derived| when called on an<br>&gt;   instance of the derived class.<br>&gt;<br>&gt;   Of course a more useful program could instead do something with the type<br>&gt;   parameter |T|, such as constraining it to a protocol or a class with a<br>&gt;   required initializer, and then using the type to construct a new instance<br>&gt;   of the class.<br>&gt;<br>&gt;   This also dovetails nicely with SE-0068<br>&gt;   &lt;https://github.com/slavapestov/swift-evolution/blob/self-formal-type-in-class/proposals/0068-universal-self.md&gt;.<br>&gt;<br>&gt;   Finally, it opens the door to generalizing dynamic |Self|, allowing it to<br>&gt;   appear in covariant position within parameter types:<br>&gt;<br>&gt;   class ArtClass {<br>&gt;     func paint(withBrush: (Self) -&gt; ()) { ... }<br>&gt;   }<br>&gt;<br>&gt;   This would allow a class to conform to a protocol with a requirement<br>&gt;   written like the following, something that is currently not possible at all:<br>&gt;<br>&gt;   protocol OddProtocol {<br>&gt;     func weaken&lt;X, Y&gt;((Self) -&gt; (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt;   }<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#detailed-design&gt;Detailed<br>&gt;     design<br>&gt;<br>&gt;<br>&gt;   There&#39;s really not much more to say here. The code for typing |self| with<br>&gt;   a dynamic |Self| is in place already, however enabling this change might<br>&gt;   expose some new bugs we have not yet encountered, because currently,<br>&gt;   methods with dynamic |Self| return type are relatively rare.<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#impact-on-existing-code&gt;Impact<br>&gt;     on existing code<br>&gt;<br>&gt;<br>&gt;   This will have a small impact on existing code that uses a pattern<br>&gt;   similar to the above.<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/slavapestov/swift-evolution/tree/self-formal-type-in-class#alternatives-considered&gt;Alternatives<br>&gt;     considered<br>&gt;<br>&gt;<br>&gt;   One alternative is to simply do nothing, but this makes the language less<br>&gt;   consistent than it could be.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Pitch] Make the formal type of &#39;self&#39; consistent in class methods</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 24, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not sure if this even requires a proposal. This just looks like an ordinary bug in the language implementation. But if this would become a formal proposal, I will support it.<br></p><p>-Michael<br></p><p>&gt; Am 23.06.2016 um 21:53 schrieb Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Consistent formal type for &#39;self&#39; in class methods<br>&gt; <br>&gt; 	• Proposal: SE-9999<br>&gt; 	• Author: Slava Pestov<br>&gt; 	• Status: Awaiting review<br>&gt; 	• Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal makes the self value behave consistently whether or not it is used from a method with a Self return type.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; <br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Right now, we exhibit inconsistent behavior when self is used as an argument to a generic function, violating the principle of least surprise.<br>&gt; <br>&gt; Consider the following code:<br>&gt; <br>&gt; class<br>&gt;  Base {<br>&gt;   <br>&gt; @discardableResult<br>&gt; <br>&gt;   <br>&gt; func methodWithDynamicSelf() -&gt;<br>&gt;  Self {<br>&gt;     doSomething(<br>&gt; self<br>&gt; )<br>&gt;     <br>&gt; return self<br>&gt; <br>&gt;   }<br>&gt; <br>&gt;   <br>&gt; func methodWithoutDynamicSelf<br>&gt; () {<br>&gt;     doSomething(<br>&gt; self<br>&gt; )<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Derived :<br>&gt;  Base {}<br>&gt; <br>&gt; <br>&gt; func doSomething&lt;T&gt;(_ t<br>&gt; : T) {<br>&gt;   <br>&gt; print(T.self<br>&gt; )<br>&gt; }<br>&gt; <br>&gt; Base()<br>&gt; .<br>&gt; methodWithDynamicSelf()<br>&gt; Base()<br>&gt; .<br>&gt; methodWithoutDynamicSelf()<br>&gt; <br>&gt; Derived()<br>&gt; .<br>&gt; methodWithDynamicSelf()<br>&gt; Derived()<br>&gt; .methodWithoutDynamicSelf()<br>&gt; Currently, it prints the following output:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Base<br>&gt; <br>&gt; Note that there&#39;s no inconsistency when the method is called on the base class. When called on the derived class however, we see that in a method with a dynamic Self return type, the type of self is Derived, whereas in a method with any other return type, the type of self is Base.<br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposal is to change the type of self to always be Self, which can be thought of as a special generic type parameter bound to the dynamic type of the instance.<br>&gt; <br>&gt; With this proposal, the above code will instead produce the following:<br>&gt; <br>&gt; Base<br>&gt; Base<br>&gt; Derived<br>&gt; Derived<br>&gt; <br>&gt; Here, the type of self would always be Derived when called on an instance of the derived class.<br>&gt; <br>&gt; Of course a more useful program could instead do something with the type parameter T, such as constraining it to a protocol or a class with a required initializer, and then using the type to construct a new instance of the class.<br>&gt; <br>&gt; This also dovetails nicely with SE-0068.<br>&gt; <br>&gt; Finally, it opens the door to generalizing dynamic Self, allowing it to appear in covariant position within parameter types:<br>&gt; <br>&gt; class<br>&gt;  ArtClass {<br>&gt;   <br>&gt; func paint(withBrush: (Self) -&gt; ()) { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; This would allow a class to conform to a protocol with a requirement written like the following, something that is currently not possible at all:<br>&gt; <br>&gt; protocol<br>&gt;  OddProtocol {<br>&gt;   <br>&gt; func weaken&lt;X, Y&gt;((Self) -&gt;<br>&gt;  (X) -&gt; Y) -&gt; (X) -&gt; Y<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; There&#39;s really not much more to say here. The code for typing self with a dynamic Self is in place already, however enabling this change might expose some new bugs we have not yet encountered, because currently, methods with dynamic Self return type are relatively rare.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; One alternative is to simply do nothing, but this makes the language less consistent than it could be.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
