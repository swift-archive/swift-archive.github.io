<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>January 15, 2016 at 11:00:00am</p></header><div class="content"><p>To handle the case of duplicate keys, why not allow to pass in a &#39;combine&#39;<br>function? This could default to a preconditionFailure to be consistent with<br>the DictionaryLiteral behavior, but be overridden by the caller as needed.<br></p><p>extension Dictionary {<br>    /// Creates a dictionary with the keys and values in the given sequence.<br>    init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>sequence: S, combine: (existing: Value, other: Value) -&gt; Value = {<br>preconditionFailure(&quot;Sequence contains duplicate keys&quot;); return $1 } ) {<br>        self.init()<br>        for (key, value) in sequence {<br>            if let existing = updateValue(value, forKey: key) {<br>                updateValue(combine(existing: existing, other: value),<br>forKey: key)<br>            }<br>        }<br>    }<br>}<br></p><p><br>usage examples:<br></p><p><br>&gt; A brief draft is below... I had mostly written this up before I saw the<br>thread and Gwendal&#39;s similar contribution -- happy to hear feedback and<br>fold in comments/revisions!<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The Dictionary type should allow initialization from a sequence of (Key,<br>Value) tuples.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Array and Set both have initializers that create a new instance from a<br>sequence of elements. The Array initializer is useful for converting other<br>sequences and collections to the &quot;standard&quot; collection type, but the Set<br>initializer is essential for recovering set operations after performing any<br>functional operations on a set. For example, filtering a set produces a<br>collection without any kind of set operations available:<br>&gt;<br>&gt; let numberSet = Set(1 ... 100)<br>&gt; let fivesOnly = numberSet.lazy.filter { $0 % 5 == 0 }<br>&gt;<br>&gt; &quot;fivesOnly&quot; is a LazyFilterCollection&lt;Set&lt;Int&gt;&gt; instead of a Set --<br>sending that back through the Set sequence initializer restores the<br>expected methods:<br>&gt;<br>&gt; let fivesOnlySet = Set(numberSet.lazy.filter { $0 % 5 == 0 })<br>&gt; fivesOnlySet.isSubsetOf(numberSet) // true<br>&gt;<br>&gt; Dictionary, on the other hand, has no such initializer, so a similar<br>operation leaves no room except for building a mutable Dictionary via<br>iteration or functional methods with dubious performance. These techniques<br>also don&#39;t support type inference from the source sequence, increasing<br>verbosity:<br>&gt;<br>&gt; var viaIteration: [String: Int] = [:]<br>&gt; for (key, value) in evenOnly {<br>&gt;     viaIteration[key] = value<br>&gt; }<br>&gt;<br>&gt; let viaFunction: [String: Int] = evenOnly.reduce([:]) { (cumulative,<br>keyValue) in<br>&gt;     var mutableDictionary = cumulative<br>&gt;     mutableDictionary[keyValue.0] = keyValue.1<br>&gt;     return mutableDictionary<br>&gt; }<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; The proposed solution would add an initializer to Dictionary that accepts<br>any sequence of (Key, Value) tuple pairs, matching the Dictionary&#39;s element<br>type when treated as a sequence:<br>&gt;<br>&gt; init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_<br>sequence: S)<br>&gt;<br>&gt; Instead of the techniques for recovering a Dictionary shown above, the<br>proposed initializer would allow a much cleaner syntax to be written:<br>&gt;<br>&gt; let viaProposed = Dictionary(evenOnly)<br>&gt;<br>&gt; Moreover, this new initializer would allow for some convenient uses that<br>aren&#39;t currently possible.<br>&gt;<br>&gt; üëçüèº Initializing from an array of tuples:<br>&gt;<br>&gt; let dictFromArray = Dictionary([(&quot;a&quot;, 1), (&quot;b&quot;, 2), (&quot;c&quot;, 3), (&quot;d&quot;, 4)])<br>&gt;<br>&gt; üëèüèº Initializing from a DictionaryLiteral (the type, not an actual<br>literal):<br>&gt;<br>&gt; let literal: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4]<br>&gt; let dictFromDL = Dictionary(literal)<br>&gt;<br>&gt; üéâ Initializing from a pair of zipped sequences (examples abound):<br>&gt;<br>&gt; let letters = &quot;abcdefghij&quot;.characters.lazy.map { String($0) }<br>&gt; let dictFromZip = Dictionary(zip(letters, 1...10))<br>&gt; // [&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;i&quot;: 9, &quot;j&quot;: 10, &quot;c&quot;: 3, &quot;e&quot;: 5, &quot;f&quot;: 6, &quot;g&quot;: 7, &quot;d&quot;:<br>4, &quot;h&quot;: 8]<br>&gt;<br>&gt; Potential pitfalls<br>&gt;<br>&gt; One caveat is that the new initializer doesn&#39;t prevent using a sequence<br>with multiple identical keys. In such a case, the last key/value would<br>&quot;win&quot; and exist in the dictionary. Such an initialization is a compile-time<br>error with a dictionary literal, but succeeds under the new initializer:<br>&gt;<br>&gt; let _ = [&quot;z&quot;: 1, &quot;z&quot;: 2, &quot;z&quot;: 3, &quot;z&quot;: 4]<br>&gt; // fatal error: Dictionary literal contains duplicate keys<br>&gt; Dictionary([(&quot;z&quot;, 1), (&quot;z&quot;, 2), (&quot;z&quot;, 3), (&quot;z&quot;, 4)])<br>&gt; // [&quot;z&quot;: 4]<br>&gt;<br>&gt; This behavior is particularly troublesome when used in conjunction with a<br>mapping operation that modifies a dictionary&#39;s keys, since dictionaries<br>have no particular guaranteed order:<br>&gt;<br>&gt; let overlapping = Dictionary(dictFromArray.lazy.map { (_, value) in (&quot;z&quot;,<br>value) })<br>&gt; // [&quot;z&quot;: ???]<br>&gt;<br>&gt; While a pitfall, this behavior is less a symptom of the proposed API and<br>more an inherent problem with recovering a dictionary after modifying its<br>keys. The current ways of rebuilding a dictionary (as shown above) are just<br>as susceptible to silently dropping values. Moreover, the sequence-based<br>initializer for Set exhibits the same behavior, though slightly less<br>problematic in most cases:<br>&gt;<br>&gt; let dividedNumbers = Set(numberSet.map { $0 / 20 })<br>&gt; // {4, 5, 2, 0, 1, 3}<br>&gt;<br>&gt; Given the potential lossiness of the initializer, should it use a<br>parameter name for the sequence? I would suggest not, to match the syntax<br>of Array.init(_:) and Set.init(_:), but a parameter like &quot;collapsingKeys&quot;<br>would make the risk clear to users.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; The implementation is simple enough to show in the proposal:<br>&gt;<br>&gt; extension Dictionary {<br>&gt;     /// Creates a dictionary with the keys and values in the given<br>sequence.<br>&gt;     init&lt;S: SequenceType where S.Generator.Element ==<br>Generator.Element&gt;(_ sequence: S) {<br>&gt;         self.init()<br>&gt;         for (key, value) in sequence {<br>&gt;             updateValue(value, forKey: key)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; (As part of the standard library, this could use the nativeUpdateValue<br>method.)<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; As a new API, this will have no impact on existing code.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; As suggested in the thread below, a method could be added to SequenceType<br>that would build a dictionary. This approach seems less of a piece with the<br>rest of the standard library, and overly verbose when used with a<br>Dictionary that is only passing through filtering or mapping operations. I<br>don&#39;t think the current protocol extension system could handle a<br>passthrough case (i.e., something like &quot;extension SequenceType where<br>Generator.Element == (Key, Value)&quot;).<br>&gt;<br>&gt; Alternately, the status quo could be maintained. Which would be sad.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; On Jan 13, 2016, at 11:55 AM, Gwendal Rou√© via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Doesn‚Äôt Swift prefer initializers?<br>&gt; &gt;<br>&gt; &gt; So let‚Äôs build a Dictionary initializer that eats any sequence of (key,<br>value) pairs:<br>&gt; &gt;<br>&gt; &gt; extension Dictionary {<br>&gt; &gt;     init&lt;S: SequenceType where S.Generator.Element == (Key,<br>Value)&gt;(keyValueSequence s: S) {<br>&gt; &gt;         self.init()<br>&gt; &gt;         for (key, value) in s {<br>&gt; &gt;             self[key] = value<br>&gt; &gt;         }<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; do {<br>&gt; &gt;     // From array of (key, value) pairs<br>&gt; &gt;     let input = [(&quot;foo&quot;, 1), (&quot;bar&quot;, 2)]<br>&gt; &gt;     let d = Dictionary(keyValueSequence: input)<br>&gt; &gt;     print(d)<br>&gt; &gt; }<br>&gt; &gt; do {<br>&gt; &gt;     // From another dictionary<br>&gt; &gt;     let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>&gt; &gt;     let d = Dictionary(keyValueSequence: input)<br>&gt; &gt;     print(d)<br>&gt; &gt; }<br>&gt; &gt; do {<br>&gt; &gt;     // Reverse key and values<br>&gt; &gt;     let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>&gt; &gt;     let d = Dictionary(keyValueSequence: input.map { ($1, $0) })<br>&gt; &gt;     print(d)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Gwendal<br>&gt; &gt;<br>&gt; &gt;&gt; Le 13 janv. 2016 √† 18:41, Thorsten Seitz via swift-evolution<br>&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a<br>√©crit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;d prefer &quot;mapToDict&quot; otherwise it sounds like a dictionary gets<br>mapped, at least for me.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 13.01.2016 um 17:13 schrieb Kenny Leung via swift-evolution<br>&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This solution looks great! How do you feel about ‚ÄúmapDict‚Äù?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com<br>&lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I named the method(s) ‚ÄûtoDict‚Äú instead of ‚Äûmap‚Äú because map<br>normally returns a collection which is either the same as the receiver or a<br>simple one.<br>&gt; &gt;&gt;&gt;&gt;&gt; The second version is more general and allows to do things like<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index,<br>value) in (index + 1, value) }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Map would probably be a more correct mathematically speaking ‚Äî but<br>it would be inconsistent with the naming convention already chosen for<br>Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/ec35ed7f/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
